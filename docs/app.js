(function() {
  'use strict';

  var globals = typeof global === 'undefined' ? self : global;
  if (typeof globals.require === 'function') return;

  var modules = {};
  var cache = {};
  var aliases = {};
  var has = {}.hasOwnProperty;

  var expRe = /^\.\.?(\/|$)/;
  var expand = function(root, name) {
    var results = [], part;
    var parts = (expRe.test(name) ? root + '/' + name : name).split('/');
    for (var i = 0, length = parts.length; i < length; i++) {
      part = parts[i];
      if (part === '..') {
        results.pop();
      } else if (part !== '.' && part !== '') {
        results.push(part);
      }
    }
    return results.join('/');
  };

  var dirname = function(path) {
    return path.split('/').slice(0, -1).join('/');
  };

  var localRequire = function(path) {
    return function expanded(name) {
      var absolute = expand(dirname(path), name);
      return globals.require(absolute, path);
    };
  };

  var initModule = function(name, definition) {
    var hot = hmr && hmr.createHot(name);
    var module = {id: name, exports: {}, hot: hot};
    cache[name] = module;
    definition(module.exports, localRequire(name), module);
    return module.exports;
  };

  var expandAlias = function(name) {
    var val = aliases[name];
    return (val && name !== val) ? expandAlias(val) : name;
  };

  var _resolve = function(name, dep) {
    return expandAlias(expand(dirname(name), dep));
  };

  var require = function(name, loaderPath) {
    if (loaderPath == null) loaderPath = '/';
    var path = expandAlias(name);

    if (has.call(cache, path)) return cache[path].exports;
    if (has.call(modules, path)) return initModule(path, modules[path]);

    throw new Error("Cannot find module '" + name + "' from '" + loaderPath + "'");
  };

  require.alias = function(from, to) {
    aliases[to] = from;
  };

  var extRe = /\.[^.\/]+$/;
  var indexRe = /\/index(\.[^\/]+)?$/;
  var addExtensions = function(bundle) {
    if (extRe.test(bundle)) {
      var alias = bundle.replace(extRe, '');
      if (!has.call(aliases, alias) || aliases[alias].replace(extRe, '') === alias + '/index') {
        aliases[alias] = bundle;
      }
    }

    if (indexRe.test(bundle)) {
      var iAlias = bundle.replace(indexRe, '');
      if (!has.call(aliases, iAlias)) {
        aliases[iAlias] = bundle;
      }
    }
  };

  require.register = require.define = function(bundle, fn) {
    if (bundle && typeof bundle === 'object') {
      for (var key in bundle) {
        if (has.call(bundle, key)) {
          require.register(key, bundle[key]);
        }
      }
    } else {
      modules[bundle] = fn;
      delete cache[bundle];
      addExtensions(bundle);
    }
  };

  require.list = function() {
    var list = [];
    for (var item in modules) {
      if (has.call(modules, item)) {
        list.push(item);
      }
    }
    return list;
  };

  var hmr = globals._hmr && new globals._hmr(_resolve, require, modules, cache);
  require._cache = cache;
  require.hmr = hmr && hmr.wrap;
  require.brunch = true;
  globals.require = require;
})();

(function() {
var global = typeof window === 'undefined' ? this : window;
var __makeRelativeRequire = function(require, mappings, pref) {
  var none = {};
  var tryReq = function(name, pref) {
    var val;
    try {
      val = require(pref + '/node_modules/' + name);
      return val;
    } catch (e) {
      if (e.toString().indexOf('Cannot find module') === -1) {
        throw e;
      }

      if (pref.indexOf('node_modules') !== -1) {
        var s = pref.split('/');
        var i = s.lastIndexOf('node_modules');
        var newPref = s.slice(0, i).join('/');
        return tryReq(name, newPref);
      }
    }
    return none;
  };
  return function(name) {
    if (name in mappings) name = mappings[name];
    if (!name) return;
    if (name[0] !== '.' && pref) {
      var val = tryReq(name, pref);
      if (val !== none) return val;
    }
    return require(name);
  }
};

require.register("curvature/animate/Ease.js", function(exports, require, module) {
  require = __makeRelativeRequire(require, {}, "curvature");
  (function() {
    "use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Ease = void 0;
var _Mixin = require("../base/Mixin");
var _PromiseMixin = require("../mixin/PromiseMixin");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
var Ease = /*#__PURE__*/function (_Mixin$with) {
  _inherits(Ease, _Mixin$with);
  var _super = _createSuper(Ease);
  function Ease(interval, options = {}) {
    var _this;
    _classCallCheck(this, Ease);
    _this = _super.call(this);
    _this.interval = interval;
    _this.terminal = false;
    _this.initial = false;
    _this.timeout = false;
    _this.final = false;
    _this.canceled = false;
    _this.done = false;
    _this.calculate = _this.calculate || 'calculate' in options ? options.calculate : false;
    _this.bounded = 'bounded' in options ? options.bounded : true;
    _this.repeat = 'repeat' in options ? options.repeat : 1;
    _this.reverse = 'reverse' in options ? options.reverse : false;
    return _this;
  }
  _createClass(Ease, [{
    key: "start",
    value: function start() {
      this.done = false;
      requestAnimationFrame(() => {
        this.initial = Date.now();
        this.terminal = this.initial + this.interval;
        if (this.repeat >= 0) {
          this.terminal = this.initial + this.interval * this.repeat;
          this.timeout = setTimeout(() => {
            if (this.done) {
              return this.reverse ? 0 : 1;
            }
            this.done = true;
            this[_PromiseMixin.PromiseMixin.Accept](this.reverse ? 0 : 1);
          }, this.interval * this.repeat);
        }
      });
    }
  }, {
    key: "cancel",
    value: function cancel() {
      if (this.done) {
        return this.final;
      }
      clearTimeout(this.timeout);
      this.final = this.current();
      this.canceled = this.done = true;
      this[_PromiseMixin.PromiseMixin.Reject](this.final);
      return this.final;
    }
  }, {
    key: "fraction",
    value: function fraction() {
      if (this.done) {
        return this.reverse ? 0 : 1;
      }
      if (this.initial === false) {
        return this.reverse ? 1 : 0;
      }
      var elapsed = Date.now() - this.initial;
      if (elapsed / this.interval >= this.repeat) {
        return this.reverse ? 0 : 1;
      }
      var fraction = elapsed % this.interval / this.interval;
      return this.reverse ? 1 - fraction : fraction;
    }
  }, {
    key: "current",
    value: function current() {
      var t = this.fraction();
      if (this.calculate) {
        return this.calculate(t);
      }
      return t;
    }
  }]);
  return Ease;
}(_Mixin.Mixin.with(_PromiseMixin.PromiseMixin));
exports.Ease = Ease;
  })();
});

require.register("curvature/animate/ease/CubicInOut.js", function(exports, require, module) {
  require = __makeRelativeRequire(require, {}, "curvature");
  (function() {
    "use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CubicInOut = void 0;
var _Ease2 = require("../Ease");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var CubicInOut = /*#__PURE__*/function (_Ease) {
  _inherits(CubicInOut, _Ease);
  var _super = _createSuper(CubicInOut);
  function CubicInOut(...args) {
    var _this;
    _classCallCheck(this, CubicInOut);
    _this = _super.call(this, ...args);
    _defineProperty(_assertThisInitialized(_this), "calculate", t => t < .5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1);
    return _this;
  }
  return _createClass(CubicInOut);
}(_Ease2.Ease);
exports.CubicInOut = CubicInOut;
  })();
});

require.register("curvature/animate/ease/QuintInOut.js", function(exports, require, module) {
  require = __makeRelativeRequire(require, {}, "curvature");
  (function() {
    "use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.QuintInOut = void 0;
var _Ease2 = require("../Ease");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var QuintInOut = /*#__PURE__*/function (_Ease) {
  _inherits(QuintInOut, _Ease);
  var _super = _createSuper(QuintInOut);
  function QuintInOut(...args) {
    var _this;
    _classCallCheck(this, QuintInOut);
    _this = _super.call(this, ...args);
    _defineProperty(_assertThisInitialized(_this), "calculate", t => t < .5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t);
    return _this;
  }
  return _createClass(QuintInOut);
}(_Ease2.Ease);
exports.QuintInOut = QuintInOut;
  })();
});

require.register("curvature/base/Bag.js", function(exports, require, module) {
  require = __makeRelativeRequire(require, {}, "curvature");
  (function() {
    "use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Bag = void 0;
var _Bindable = require("./Bindable");
var _Mixin = require("./Mixin");
var _EventTargetMixin = require("../mixin/EventTargetMixin");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
var toId = int => Number(int);
var fromId = id => parseInt(id);
var Mapped = Symbol('Mapped');
var Has = Symbol('Has');
var Add = Symbol('Add');
var Remove = Symbol('Remove');
var Delete = Symbol('Delete');
var Bag = /*#__PURE__*/function (_Mixin$with) {
  _inherits(Bag, _Mixin$with);
  var _super = _createSuper(Bag);
  function Bag(changeCallback = undefined) {
    var _this;
    _classCallCheck(this, Bag);
    _this = _super.call(this);
    _this.changeCallback = changeCallback;
    _this.content = new Map();
    _this.current = 0;
    _this.length = 0;
    _this.list = _Bindable.Bindable.makeBindable([]);
    _this.meta = Symbol('meta');
    _this.type = undefined;
    return _this;
  }
  _createClass(Bag, [{
    key: "has",
    value: function has(item) {
      if (this[Mapped]) {
        return this[Mapped].has(item);
      }
      return this[Has](item);
    }
  }, {
    key: Has,
    value: function value(item) {
      return this.content.has(item);
    }
  }, {
    key: "add",
    value: function add(item) {
      if (this[Mapped]) {
        return this[Mapped].add(item);
      }
      return this[Add](item);
    }
  }, {
    key: Add,
    value: function value(item) {
      if (item === undefined || !(item instanceof Object)) {
        throw new Error('Only objects may be added to Bags.');
      }
      if (this.type && !(item instanceof this.type)) {
        console.error(this.type, item);
        throw new Error("Only objects of type ".concat(this.type, " may be added to this Bag."));
      }
      item = _Bindable.Bindable.make(item);
      if (this.content.has(item)) {
        return;
      }
      var adding = new CustomEvent('adding', {
        detail: {
          item: item
        }
      });
      if (!this.dispatchEvent(adding)) {
        return;
      }
      var id = toId(this.current++);
      this.content.set(item, id);
      this.list[id] = item;
      if (this.changeCallback) {
        this.changeCallback(item, this.meta, Bag.ITEM_ADDED, id);
      }
      var add = new CustomEvent('added', {
        detail: {
          item: item,
          id: id
        }
      });
      this.dispatchEvent(add);
      this.length = this.size;
      return id;
    }
  }, {
    key: "remove",
    value: function remove(item) {
      if (this[Mapped]) {
        return this[Mapped].remove(item);
      }
      return this[Remove](item);
    }
  }, {
    key: Remove,
    value: function value(item) {
      if (item === undefined || !(item instanceof Object)) {
        throw new Error('Only objects may be removed from Bags.');
      }
      if (this.type && !(item instanceof this.type)) {
        console.error(this.type, item);
        throw new Error("Only objects of type ".concat(this.type, " may be removed from this Bag."));
      }
      item = _Bindable.Bindable.make(item);
      if (!this.content.has(item)) {
        if (this.changeCallback) {
          this.changeCallback(item, this.meta, 0, undefined);
        }
        return false;
      }
      var removing = new CustomEvent('removing', {
        detail: {
          item: item
        }
      });
      if (!this.dispatchEvent(removing)) {
        return;
      }
      var id = this.content.get(item);
      delete this.list[id];
      this.content.delete(item);
      if (this.changeCallback) {
        this.changeCallback(item, this.meta, Bag.ITEM_REMOVED, id);
      }
      var remove = new CustomEvent('removed', {
        detail: {
          item: item,
          id: id
        }
      });
      this.dispatchEvent(remove);
      this.length = this.size;
      return item;
    }
  }, {
    key: "delete",
    value: function _delete(item) {
      if (this[Mapped]) {
        return this[Mapped].delete(item);
      }
      this[Delete](item);
    }
  }, {
    key: Delete,
    value: function value(item) {
      this.remove(item);
    }
  }, {
    key: "map",
    value: function map(mapper = x => x, filter = x => x) {
      var mappedItems = new WeakMap();
      var mappedBag = new Bag();
      mappedBag[Mapped] = this;
      this.addEventListener('added', event => {
        var item = event.detail.item;
        if (!filter(item)) {
          return;
        }
        if (mappedItems.has(item)) {
          return;
        }
        var mapped = mapper(item);
        mappedItems.set(item, mapped);
        mappedBag[Add](mapped);
      });
      this.addEventListener('removed', event => {
        var item = event.detail.item;
        if (!mappedItems.has(item)) {
          return;
        }
        var mapped = mappedItems.get(item);
        mappedItems.delete(item);
        mappedBag[Remove](mapped);
      });
      return mappedBag;
    }
  }, {
    key: "size",
    get: function get() {
      return this.content.size;
    }
  }, {
    key: "items",
    value: function items() {
      return Array.from(this.content.entries()).map(entry => entry[0]);
    }
  }]);
  return Bag;
}(_Mixin.Mixin.with(_EventTargetMixin.EventTargetMixin));
exports.Bag = Bag;
Object.defineProperty(Bag, 'ITEM_ADDED', {
  configurable: false,
  enumerable: false,
  writable: true,
  value: 1
});
Object.defineProperty(Bag, 'ITEM_REMOVED', {
  configurable: false,
  enumerable: false,
  writable: true,
  value: -1
});
  })();
});

require.register("curvature/base/Bindable.js", function(exports, require, module) {
  require = __makeRelativeRequire(require, {}, "curvature");
  (function() {
    "use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Bindable = void 0;
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
var Ref = Symbol('ref');
var Original = Symbol('original');
var Deck = Symbol('deck');
var Binding = Symbol('binding');
var SubBinding = Symbol('subBinding');
var BindingAll = Symbol('bindingAll');
var IsBindable = Symbol('isBindable');
var Wrapping = Symbol('wrapping');
var Names = Symbol('Names');
var Executing = Symbol('executing');
var Stack = Symbol('stack');
var ObjSymbol = Symbol('object');
var Wrapped = Symbol('wrapped');
var Unwrapped = Symbol('unwrapped');
var GetProto = Symbol('getProto');
var OnGet = Symbol('onGet');
var OnAllGet = Symbol('onAllGet');
var BindChain = Symbol('bindChain');
var Descriptors = Symbol('Descriptors');
var Before = Symbol('Before');
var After = Symbol('After');
var NoGetters = Symbol('NoGetters');
var TypedArray = Object.getPrototypeOf(Int8Array);
var SetIterator = Set.prototype[Symbol.iterator];
var MapIterator = Map.prototype[Symbol.iterator];
var win = (typeof globalThis === "undefined" ? "undefined" : _typeof(globalThis)) === 'object' ? globalThis : (typeof window === "undefined" ? "undefined" : _typeof(window)) === 'object' ? window : (typeof self === "undefined" ? "undefined" : _typeof(self)) === 'object' ? self : void 0;
var isExcluded = object => typeof win.Map === 'function' && object instanceof win.Map || typeof win.Set === 'function' && object instanceof win.Set || typeof win.Node === 'function' && object instanceof win.Node || typeof win.WeakMap === 'function' && object instanceof win.WeakMap || typeof win.Location === 'function' && object instanceof win.Location || typeof win.Storage === 'function' && object instanceof win.Storage || typeof win.WeakSet === 'function' && object instanceof win.WeakSet || typeof win.ArrayBuffer === 'function' && object instanceof win.ArrayBuffer || typeof win.Promise === 'function' && object instanceof win.Promise || typeof win.File === 'function' && object instanceof win.File || typeof win.Event === 'function' && object instanceof win.Event || typeof win.CustomEvent === 'function' && object instanceof win.CustomEvent || typeof win.Gamepad === 'function' && object instanceof win.Gamepad || typeof win.ResizeObserver === 'function' && object instanceof win.ResizeObserver || typeof win.MutationObserver === 'function' && object instanceof win.MutationObserver || typeof win.PerformanceObserver === 'function' && object instanceof win.PerformanceObserver || typeof win.IntersectionObserver === 'function' && object instanceof win.IntersectionObserver || typeof win.IDBCursor === 'function' && object instanceof win.IDBCursor || typeof win.IDBCursorWithValue === 'function' && object instanceof win.IDBCursorWithValue || typeof win.IDBDatabase === 'function' && object instanceof win.IDBDatabase || typeof win.IDBFactory === 'function' && object instanceof win.IDBFactory || typeof win.IDBIndex === 'function' && object instanceof win.IDBIndex || typeof win.IDBKeyRange === 'function' && object instanceof win.IDBKeyRange || typeof win.IDBObjectStore === 'function' && object instanceof win.IDBObjectStore || typeof win.IDBOpenDBRequest === 'function' && object instanceof win.IDBOpenDBRequest || typeof win.IDBRequest === 'function' && object instanceof win.IDBRequest || typeof win.IDBTransaction === 'function' && object instanceof win.IDBTransaction || typeof win.IDBVersionChangeEvent === 'function' && object instanceof win.IDBVersionChangeEvent || typeof win.FileSystemFileHandle === 'function' && object instanceof win.FileSystemFileHandle || typeof win.RTCPeerConnection === 'function' && object instanceof win.RTCPeerConnection || typeof win.ServiceWorkerRegistration === 'function' && object instanceof win.ServiceWorkerRegistration;
var Bindable = /*#__PURE__*/function () {
  function Bindable() {
    _classCallCheck(this, Bindable);
  }
  _createClass(Bindable, null, [{
    key: "isBindable",
    value: function isBindable(object) {
      if (!object || !object[IsBindable]) {
        return false;
      }
      return object[IsBindable] === Bindable;
    }
  }, {
    key: "onDeck",
    value: function onDeck(object, key) {
      return object[Deck].get(key) || false;
    }
  }, {
    key: "ref",
    value: function ref(object) {
      return object[Ref] || object || false;
    }
  }, {
    key: "makeBindable",
    value: function makeBindable(object) {
      return this.make(object);
    }
  }, {
    key: "shuck",
    value: function shuck(original, seen) {
      seen = seen || new Map();
      var clone = Object.create({});
      if (original instanceof TypedArray || original instanceof ArrayBuffer) {
        var _clone = original.slice(0);
        seen.set(original, _clone);
        return _clone;
      }
      var properties = Object.keys(original);
      for (var i in properties) {
        var ii = properties[i];
        if (ii.substring(0, 3) === '___') {
          continue;
        }
        var alreadyCloned = seen.get(original[ii]);
        if (alreadyCloned) {
          clone[ii] = alreadyCloned;
          continue;
        }
        if (original[ii] === original) {
          seen.set(original[ii], clone);
          clone[ii] = clone;
          continue;
        }
        if (original[ii] && _typeof(original[ii]) === 'object') {
          var originalProp = original[ii];
          if (Bindable.isBindable(original[ii])) {
            originalProp = original[ii][Original];
          }
          clone[ii] = this.shuck(originalProp, seen);
        } else {
          clone[ii] = original[ii];
        }
        seen.set(original[ii], clone[ii]);
      }
      if (Bindable.isBindable(original)) {
        delete clone.bindTo;
        delete clone.isBound;
      }
      return clone;
    }
  }, {
    key: "make",
    value: function make(object) {
      if (!object || !['function', 'object'].includes(_typeof(object))) {
        return object;
      }
      if (object[Ref]) {
        return object[Ref];
      }
      if (object[IsBindable]) {
        return object;
      }
      if (Object.isSealed(object) || Object.isFrozen(object) || !Object.isExtensible(object) || isExcluded(object)) {
        return object;
      }
      Object.defineProperty(object, IsBindable, {
        configurable: false,
        enumerable: false,
        writable: false,
        value: Bindable
      });
      Object.defineProperty(object, Ref, {
        configurable: true,
        enumerable: false,
        writable: true,
        value: false
      });
      Object.defineProperty(object, Original, {
        configurable: false,
        enumerable: false,
        writable: false,
        value: object
      });
      Object.defineProperty(object, Deck, {
        configurable: false,
        enumerable: false,
        writable: false,
        value: new Map()
      });
      Object.defineProperty(object, Binding, {
        configurable: false,
        enumerable: false,
        writable: false,
        value: Object.create(null)
      });
      Object.defineProperty(object, SubBinding, {
        configurable: false,
        enumerable: false,
        writable: false,
        value: new Map()
      });
      Object.defineProperty(object, BindingAll, {
        configurable: false,
        enumerable: false,
        writable: false,
        value: new Set()
      });
      Object.defineProperty(object, Executing, {
        enumerable: false,
        writable: true
      });
      Object.defineProperty(object, Wrapping, {
        enumerable: false,
        writable: true
      });
      Object.defineProperty(object, Stack, {
        configurable: false,
        enumerable: false,
        writable: false,
        value: []
      });
      Object.defineProperty(object, Before, {
        configurable: false,
        enumerable: false,
        writable: false,
        value: new Set()
      });
      Object.defineProperty(object, After, {
        configurable: false,
        enumerable: false,
        writable: false,
        value: new Set()
      });
      Object.defineProperty(object, Wrapped, {
        configurable: false,
        enumerable: false,
        writable: false,
        value: Object.preventExtensions(new Map())
      });
      Object.defineProperty(object, Unwrapped, {
        configurable: false,
        enumerable: false,
        writable: false,
        value: Object.preventExtensions(new Map())
      });
      Object.defineProperty(object, Descriptors, {
        configurable: false,
        enumerable: false,
        writable: false,
        value: Object.preventExtensions(new Map())
      });
      var bindTo = (property, callback = null, options = {}) => {
        var bindToAll = false;
        if (Array.isArray(property)) {
          var debinders = property.map(p => bindTo(p, callback, options));
          return () => debinders.forEach(d => d());
        }
        if (property instanceof Function) {
          options = callback || {};
          callback = property;
          bindToAll = true;
        }
        if (options.delay >= 0) {
          callback = this.wrapDelayCallback(callback, options.delay);
        }
        if (options.throttle >= 0) {
          callback = this.wrapThrottleCallback(callback, options.throttle);
        }
        if (options.wait >= 0) {
          callback = this.wrapWaitCallback(callback, options.wait);
        }
        if (options.frame) {
          callback = this.wrapFrameCallback(callback, options.frame);
        }
        if (options.idle) {
          callback = this.wrapIdleCallback(callback);
        }
        if (bindToAll) {
          object[BindingAll].add(callback);
          if (!('now' in options) || options.now) {
            for (var i in object) {
              callback(object[i], i, object, false);
            }
          }
          return () => {
            object[BindingAll].delete(callback);
          };
        }
        if (!object[Binding][property]) {
          object[Binding][property] = new Set();
        }

        // let bindIndex = object[Binding][property].length;

        if (options.children) {
          var original = callback;
          callback = (...args) => {
            var v = args[0];
            var subDebind = object[SubBinding].get(original);
            if (subDebind) {
              object[SubBinding].delete(original);
              subDebind();
            }
            if (_typeof(v) !== 'object') {
              original(...args);
              return;
            }
            var vv = Bindable.make(v);
            if (Bindable.isBindable(vv)) {
              object[SubBinding].set(original, vv.bindTo((...subArgs) => original(...args, ...subArgs), Object.assign({}, options, {
                children: false
              })));
            }
            original(...args);
          };
        }
        object[Binding][property].add(callback);
        if (!('now' in options) || options.now) {
          callback(object[property], property, object, false);
        }
        var debinder = () => {
          var subDebind = object[SubBinding].get(callback);
          if (subDebind) {
            object[SubBinding].delete(callback);
            subDebind();
          }
          if (!object[Binding][property]) {
            return;
          }
          if (!object[Binding][property].has(callback)) {
            return;
          }
          object[Binding][property].delete(callback);
        };
        if (options.removeWith && options.removeWith instanceof View) {
          options.removeWith.onRemove(() => debinder);
        }
        return debinder;
      };
      Object.defineProperty(object, 'bindTo', {
        configurable: false,
        enumerable: false,
        writable: false,
        value: bindTo
      });
      var ___before = callback => {
        object[Before].add(callback);
        return () => object[Before].delete(callback);
      };
      var ___after = callback => {
        object[After].add(callback);
        return () => object[After].delete(callback);
      };
      Object.defineProperty(object, BindChain, {
        configurable: false,
        enumerable: false,
        writable: false,
        value: (path, callback) => {
          var parts = path.split('.');
          var node = parts.shift();
          var subParts = parts.slice(0);
          var debind = [];
          debind.push(object.bindTo(node, (v, k, t, d) => {
            var rest = subParts.join('.');
            if (subParts.length === 0) {
              callback(v, k, t, d);
              return;
            }
            if (v === undefined) {
              v = t[k] = this.make({});
            }
            debind = debind.concat(v[BindChain](rest, callback));
          }));
          return () => debind.forEach(x => x());
        }
      });
      Object.defineProperty(object, '___before', {
        configurable: false,
        enumerable: false,
        writable: false,
        value: ___before
      });
      Object.defineProperty(object, '___after', {
        configurable: false,
        enumerable: false,
        writable: false,
        value: ___after
      });
      var isBound = () => {
        if (object[BindingAll].size) {
          return true;
        }
        for (var callbacks of Object.values(object[Binding])) {
          if (callbacks.size) {
            return true;
          }
          // for(let callback of callbacks)
          // {
          // 	if(callback)
          // 	{
          // 		return true;
          // 	}
          // }
        }

        return false;
      };
      Object.defineProperty(object, 'isBound', {
        configurable: false,
        enumerable: false,
        writable: false,
        value: isBound
      });
      for (var i in object) {
        // const descriptors = Object.getOwnPropertyDescriptors(object);

        if (!object[i] || _typeof(object[i]) !== 'object') {
          continue;
        }
        if (object[i][Ref] || object[i] instanceof Promise) {
          continue;
        }
        if (!Object.isExtensible(object[i]) || Object.isSealed(object[i])) {
          continue;
        }
        if (!isExcluded(object[i])) {
          object[i] = Bindable.make(object[i]);
        }
      }
      var descriptors = object[Descriptors];
      var wrapped = object[Wrapped];
      var stack = object[Stack];
      var set = (target, key, value) => {
        if (value && _typeof(value) === 'object') {
          value = Bindable.make(value);
          if (target[key] === value) {
            return true;
          }
        }
        if (wrapped.has(key)) {
          wrapped.delete(key);
        }
        var onDeck = object[Deck];
        var isOnDeck = onDeck.has(key);
        var valOnDeck = isOnDeck && onDeck.get(key);

        // if(onDeck[key] !== undefined && onDeck[key] === value)
        if (isOnDeck && valOnDeck === value) {
          return true;
        }
        if (key.slice && key.slice(-3) === '___') {
          return true;
        }
        if (target[key] === value || typeof value === 'number' && isNaN(valOnDeck) && isNaN(value)) {
          return true;
        }
        onDeck.set(key, value);
        for (var callback of object[BindingAll]) {
          callback(value, key, target, false);
        }
        if (key in object[Binding]) {
          for (var _callback of object[Binding][key]) {
            _callback(value, key, target, false, target[key]);
          }
        }
        onDeck.delete(key);
        var excluded = win.File && target instanceof win.File && key == 'lastModifiedDate';
        if (!excluded) {
          Reflect.set(target, key, value);
        }
        if (Array.isArray(target) && object[Binding]['length']) {
          for (var _i in object[Binding]['length']) {
            var _callback2 = object[Binding]['length'][_i];
            _callback2(target.length, 'length', target, false, target.length);
          }
        }
        return true;
      };
      var deleteProperty = (target, key) => {
        var onDeck = object[Deck];
        var isOnDeck = onDeck.has(key);
        if (isOnDeck) {
          return true;
        }
        if (!(key in target)) {
          return true;
        }
        if (descriptors.has(key)) {
          var descriptor = descriptors.get(key);
          if (descriptor && !descriptor.configurable) {
            return false;
          }
          descriptors.delete(key);
        }
        onDeck.set(key, null);
        if (wrapped.has(key)) {
          wrapped.delete(key);
        }
        for (var callback of object[BindingAll]) {
          callback(undefined, key, target, true, target[key]);
        }
        if (key in object[Binding]) {
          for (var binding of object[Binding][key]) {
            binding(undefined, key, target, true, target[key]);
          }
        }
        Reflect.deleteProperty(target, key);
        onDeck.delete(key);
        return true;
      };
      var construct = (target, args) => {
        var key = 'constructor';
        for (var callback of target[Before]) {
          callback(target, key, object[Stack], undefined, args);
        }
        var instance = Bindable.make(new target[Original](...args));
        for (var _callback3 of target[After]) {
          _callback3(target, key, object[Stack], instance, args);
        }
        return instance;
      };
      var get = (target, key) => {
        if (wrapped.has(key)) {
          return wrapped.get(key);
        }
        if (key === Ref || key === Original || key === 'apply' || key === 'isBound' || key === 'bindTo' || key === '__proto__' || key === 'constructor') {
          return object[key];
        }
        var descriptor;
        if (descriptors.has(key)) {
          descriptor = descriptors.get(key);
        } else {
          descriptor = Object.getOwnPropertyDescriptor(object, key);
          descriptors.set(key, descriptor);
        }
        if (descriptor && !descriptor.configurable && !descriptor.writable) {
          return object[key];
        }
        if (OnAllGet in object) {
          return object[OnAllGet](key);
        }
        if (OnGet in object && !(key in object)) {
          return object[OnGet](key);
        }
        if (descriptor && !descriptor.configurable && !descriptor.writable) {
          wrapped.set(key, object[key]);
          return object[key];
        }
        if (typeof object[key] === 'function') {
          if (Names in object[key]) {
            return object[key];
          }
          object[Unwrapped].set(key, object[key]);
          var prototype = Object.getPrototypeOf(object);
          var isMethod = prototype[key] === object[key];
          var objRef =
          // (typeof Promise === 'function'                    && object instanceof Promise)
          // || (typeof Storage === 'function'                 && object instanceof Storage)
          // || (typeof Map === 'function'                     && object instanceof Map)
          // || (typeof Set === 'function'                     && object instanceof Set)
          // || (typeof WeakMap === 'function'                 && object instanceof WeakMap)
          // || (typeof WeakSet === 'function'                 && object instanceof WeakSet)
          // || (typeof ArrayBuffer === 'function'             && object instanceof ArrayBuffer)
          // || (typeof ResizeObserver === 'function'          && object instanceof ResizeObserver)
          // || (typeof MutationObserver === 'function'        && object instanceof MutationObserver)
          // || (typeof PerformanceObserver === 'function'     && object instanceof PerformanceObserver)
          // || (typeof IntersectionObserver === 'function'    && object instanceof IntersectionObserver)
          isExcluded(object) || typeof object[Symbol.iterator] === 'function' && key === 'next' || typeof TypedArray === 'function' && object instanceof TypedArray || typeof EventTarget === 'function' && object instanceof EventTarget || typeof Date === 'function' && object instanceof Date || typeof MapIterator === 'function' && object.prototype === MapIterator || typeof SetIterator === 'function' && object.prototype === SetIterator ? object : object[Ref];
          var wrappedMethod = function wrappedMethod(...providedArgs) {
            object[Executing] = key;
            stack.unshift(key);
            for (var beforeCallback of object[Before]) {
              beforeCallback(object, key, stack, object, providedArgs);
            }
            var ret;
            if (new.target) {
              ret = new (object[Unwrapped].get(key))(...providedArgs);
            } else {
              var func = object[Unwrapped].get(key);
              if (isMethod) {
                ret = func.apply(objRef || object, providedArgs);
              } else {
                ret = func(...providedArgs);
              }
            }
            for (var afterCallback of object[After]) {
              afterCallback(object, key, stack, object, providedArgs);
            }
            object[Executing] = null;
            stack.shift();
            return ret;
          };
          wrappedMethod[OnAllGet] = _key => object[key][_key];
          var result = Bindable.make(wrappedMethod);
          wrapped.set(key, result);
          return result;
        }
        return object[key];
      };
      var getPrototypeOf = target => {
        if (GetProto in object) {
          return object[GetProto];
        }
        return Reflect.getPrototypeOf(target);
      };
      var handlerDef = Object.create(null);
      handlerDef.set = set;
      handlerDef.construct = construct;
      handlerDef.deleteProperty = deleteProperty;
      if (!object[NoGetters]) {
        handlerDef.getPrototypeOf = getPrototypeOf;
        handlerDef.get = get;
      }
      Object.defineProperty(object, Ref, {
        configurable: false,
        enumerable: false,
        writable: false,
        value: new Proxy(object, handlerDef)
      });
      return object[Ref];
    }
  }, {
    key: "clearBindings",
    value: function clearBindings(object) {
      var maps = func => (...os) => os.map(func);
      var clearObj = o => Object.keys(o).map(k => delete o[k]);
      var clearObjs = maps(clearObj);
      object[BindingAll].clear();
      clearObjs(object[Wrapped], object[Binding], object[After], object[Before]);
    }
  }, {
    key: "resolve",
    value: function resolve(object, path, owner = false) {
      var node;
      var pathParts = path.split('.');
      var top = pathParts[0];
      while (pathParts.length) {
        if (owner && pathParts.length === 1) {
          var obj = this.make(object);
          return [obj, pathParts.shift(), top];
        }
        node = pathParts.shift();
        if (!(node in object) || !object[node] || !(_typeof(object[node]) === 'object')) {
          object[node] = Object.create(null);
        }
        object = this.make(object[node]);
      }
      return [this.make(object), node, top];
    }
  }, {
    key: "wrapDelayCallback",
    value: function wrapDelayCallback(callback, delay) {
      return (...args) => setTimeout(() => callback(...args), delay);
    }
  }, {
    key: "wrapThrottleCallback",
    value: function wrapThrottleCallback(callback, throttle) {
      this.throttles.set(callback, false);
      return (...args) => {
        if (this.throttles.get(callback, true)) {
          return;
        }
        callback(...args);
        this.throttles.set(callback, true);
        setTimeout(() => {
          this.throttles.set(callback, false);
        }, throttle);
      };
    }
  }, {
    key: "wrapWaitCallback",
    value: function wrapWaitCallback(callback, wait) {
      return (...args) => {
        var waiter;
        if (waiter = this.waiters.get(callback)) {
          this.waiters.delete(callback);
          clearTimeout(waiter);
        }
        waiter = setTimeout(() => callback(...args), wait);
        this.waiters.set(callback, waiter);
      };
    }
  }, {
    key: "wrapFrameCallback",
    value: function wrapFrameCallback(callback, frames) {
      return (...args) => {
        requestAnimationFrame(() => callback(...args));
      };
    }
  }, {
    key: "wrapIdleCallback",
    value: function wrapIdleCallback(callback) {
      return (...args) => {
        // Compatibility for Safari 08/2020
        var req = window.requestIdleCallback || requestAnimationFrame;
        req(() => callback(...args));
      };
    }
  }]);
  return Bindable;
}();
exports.Bindable = Bindable;
_defineProperty(Bindable, "waiters", new WeakMap());
_defineProperty(Bindable, "throttles", new WeakMap());
Object.defineProperty(Bindable, 'OnGet', {
  configurable: false,
  enumerable: false,
  writable: false,
  value: OnGet
});
Object.defineProperty(Bindable, 'NoGetters', {
  configurable: false,
  enumerable: false,
  writable: false,
  value: NoGetters
});
Object.defineProperty(Bindable, 'GetProto', {
  configurable: false,
  enumerable: false,
  writable: false,
  value: GetProto
});
Object.defineProperty(Bindable, 'OnAllGet', {
  configurable: false,
  enumerable: false,
  writable: false,
  value: OnAllGet
});
  })();
});

require.register("curvature/base/Cache.js", function(exports, require, module) {
  require = __makeRelativeRequire(require, {}, "curvature");
  (function() {
    "use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Cache = void 0;
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var Cache = /*#__PURE__*/function () {
  function Cache() {
    _classCallCheck(this, Cache);
  }
  _createClass(Cache, null, [{
    key: "store",
    value: function store(key, value, expiry, bucket = 'standard') {
      var expiration = 0;
      if (expiry) {
        expiration = expiry * 1000 + new Date().getTime();
      }
      if (!this.buckets) {
        this.buckets = new Map();
      }
      if (!this.buckets.has(bucket)) {
        this.buckets.set(bucket, new Map());
      }
      var eventEnd = new CustomEvent('cvCacheStore', {
        cancelable: true,
        detail: {
          key: key,
          value: value,
          expiry: expiry,
          bucket: bucket
        }
      });
      if (document.dispatchEvent(eventEnd)) {
        this.buckets.get(bucket).set(key, {
          value: value,
          expiration: expiration
        });
      }
    }
  }, {
    key: "load",
    value: function load(key, defaultvalue = false, bucket = 'standard') {
      var eventEnd = new CustomEvent('cvCacheLoad', {
        cancelable: true,
        detail: {
          key: key,
          defaultvalue: defaultvalue,
          bucket: bucket
        }
      });
      if (!document.dispatchEvent(eventEnd)) {
        return defaultvalue;
      }
      if (this.buckets && this.buckets.has(bucket) && this.buckets.get(bucket).has(key)) {
        var entry = this.buckets.get(bucket).get(key);
        // console.log(this.bucket[bucket][key].expiration, (new Date).getTime());
        if (entry.expiration === 0 || entry.expiration > new Date().getTime()) {
          return this.buckets.get(bucket).get(key).value;
        }
      }
      return defaultvalue;
    }
  }]);
  return Cache;
}();
exports.Cache = Cache;
  })();
});

require.register("curvature/base/Config.js", function(exports, require, module) {
  require = __makeRelativeRequire(require, {}, "curvature");
  (function() {
    "use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Config = void 0;
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
var AppConfig = {};
var _require = require;
var win = (typeof globalThis === "undefined" ? "undefined" : _typeof(globalThis)) === 'object' ? globalThis : (typeof window === "undefined" ? "undefined" : _typeof(window)) === 'object' ? window : (typeof self === "undefined" ? "undefined" : _typeof(self)) === 'object' ? self : void 0;
try {
  AppConfig = _require('/Config').Config;
} catch (error) {
  win.devMode === true && console.error(error);
  AppConfig = {};
}
var Config = /*#__PURE__*/function () {
  function Config() {
    _classCallCheck(this, Config);
  }
  _createClass(Config, null, [{
    key: "get",
    value: function get(name) {
      return this.configs[name];
    }
  }, {
    key: "set",
    value: function set(name, value) {
      this.configs[name] = value;
      return this;
    }
  }, {
    key: "dump",
    value: function dump() {
      return this.configs;
    }
  }, {
    key: "init",
    value: function init(...configs) {
      for (var i in configs) {
        var config = configs[i];
        if (typeof config === 'string') {
          config = JSON.parse(config);
        }
        for (var name in config) {
          var value = config[name];
          return this.configs[name] = value;
        }
      }
      return this;
    }
  }]);
  return Config;
}();
exports.Config = Config;
Object.defineProperty(Config, 'configs', {
  configurable: false,
  enumerable: false,
  writable: false,
  value: AppConfig
});
  })();
});

require.register("curvature/base/Dom.js", function(exports, require, module) {
  require = __makeRelativeRequire(require, {}, "curvature");
  (function() {
    "use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Dom = void 0;
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var traversals = 0;
var Dom = /*#__PURE__*/function () {
  function Dom() {
    _classCallCheck(this, Dom);
  }
  _createClass(Dom, null, [{
    key: "mapTags",
    value: function mapTags(doc, selector, callback, startNode, endNode) {
      var result = [];
      var started = true;
      if (startNode) {
        started = false;
      }
      var ended = false;
      var _globalThis$window = globalThis.window,
        Node = _globalThis$window.Node,
        Element = _globalThis$window.Element,
        NodeFilter = _globalThis$window.NodeFilter,
        document = _globalThis$window.document;
      var treeWalker = document.createTreeWalker(doc, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT, {
        acceptNode: (node, walker) => {
          if (!started) {
            if (node === startNode) {
              started = true;
            } else {
              return NodeFilter.FILTER_SKIP;
            }
          }
          if (endNode && node === endNode) {
            ended = true;
          }
          if (ended) {
            return NodeFilter.FILTER_SKIP;
          }
          if (selector) {
            if (node instanceof Element) {
              if (node.matches(selector)) {
                return NodeFilter.FILTER_ACCEPT;
              }
            }
            return NodeFilter.FILTER_SKIP;
          }
          return NodeFilter.FILTER_ACCEPT;
        }
      }, false);
      var traversal = traversals++;
      while (treeWalker.nextNode()) {
        result.push(callback(treeWalker.currentNode, treeWalker));
      }
      return result;
    }
  }, {
    key: "dispatchEvent",
    value: function dispatchEvent(doc, event) {
      doc.dispatchEvent(event);
      this.mapTags(doc, false, node => {
        node.dispatchEvent(event);
      });
    }
  }]);
  return Dom;
}();
exports.Dom = Dom;
  })();
});

require.register("curvature/base/Mixin.js", function(exports, require, module) {
  require = __makeRelativeRequire(require, {}, "curvature");
  (function() {
    "use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Mixin = void 0;
var _Bindable = require("./Bindable");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var Constructor = Symbol('constructor');
var MixinList = Symbol('mixinList');
var Mixin = /*#__PURE__*/function () {
  function Mixin() {
    _classCallCheck(this, Mixin);
  }
  _createClass(Mixin, null, [{
    key: "from",
    value: function from(baseClass, ...mixins) {
      var newClass = /*#__PURE__*/function (_baseClass) {
        _inherits(newClass, _baseClass);
        var _super = _createSuper(newClass);
        function newClass(...args) {
          var _this;
          _classCallCheck(this, newClass);
          var instance = baseClass.constructor ? _this = _super.call(this, ...args) : null;
          for (var mixin of mixins) {
            if (mixin[Mixin.Constructor]) {
              mixin[Mixin.Constructor].apply(_assertThisInitialized(_this));
            }
            switch (_typeof(mixin)) {
              case 'function':
                Mixin.mixClass(mixin, newClass);
                break;
              case 'object':
                Mixin.mixObject(mixin, _assertThisInitialized(_this));
                break;
            }
          }
          return _possibleConstructorReturn(_this, instance);
        }
        return _createClass(newClass);
      }(baseClass);
      return newClass;
    }
  }, {
    key: "make",
    value: function make(...classes) {
      var base = classes.pop();
      return Mixin.to(base, ...classes);
    }
  }, {
    key: "to",
    value: function to(base, ...mixins) {
      var descriptors = {};
      mixins.map(mixin => {
        switch (_typeof(mixin)) {
          case 'object':
            Object.assign(descriptors, Object.getOwnPropertyDescriptors(mixin));
            break;
          case 'function':
            Object.assign(descriptors, Object.getOwnPropertyDescriptors(mixin.prototype));
            break;
        }
        delete descriptors.constructor;
        Object.defineProperties(base.prototype, descriptors);
      });
    }
  }, {
    key: "with",
    value: function _with(...mixins) {
      return this.from( /*#__PURE__*/function () {
        function _class() {
          _classCallCheck(this, _class);
        }
        return _createClass(_class);
      }(), ...mixins);
    }
  }, {
    key: "mixObject",
    value: function mixObject(mixin, instance) {
      for (var func of Object.getOwnPropertyNames(mixin)) {
        if (typeof mixin[func] === 'function') {
          instance[func] = mixin[func].bind(instance);
          continue;
        }
        instance[func] = mixin[func];
      }
      for (var _func of Object.getOwnPropertySymbols(mixin)) {
        if (typeof mixin[_func] === 'function') {
          instance[_func] = mixin[_func].bind(instance);
          continue;
        }
        instance[_func] = mixin[_func];
      }
    }
  }, {
    key: "mixClass",
    value: function mixClass(cls, newClass) {
      for (var func of Object.getOwnPropertyNames(cls.prototype)) {
        if (['name', 'prototype', 'length'].includes(func)) {
          continue;
        }
        var descriptor = Object.getOwnPropertyDescriptor(newClass, func);
        if (descriptor && !descriptor.writable) {
          continue;
        }
        if (typeof cls[func] !== 'function') {
          newClass.prototype[func] = cls.prototype[func];
          continue;
        }
        newClass.prototype[func] = cls.prototype[func].bind(newClass.prototype);
      }
      for (var _func2 of Object.getOwnPropertySymbols(cls.prototype)) {
        if (typeof cls[_func2] !== 'function') {
          newClass.prototype[_func2] = cls.prototype[_func2];
          continue;
        }
        newClass.prototype[_func2] = cls.prototype[_func2].bind(newClass.prototype);
      }
      var _loop = function _loop() {
        if (['name', 'prototype', 'length'].includes(_func3)) {
          return "continue";
        }
        var descriptor = Object.getOwnPropertyDescriptor(newClass, _func3);
        if (descriptor && !descriptor.writable) {
          return "continue";
        }
        if (typeof cls[_func3] !== 'function') {
          newClass[_func3] = cls[_func3];
          return "continue";
        }
        var prev = newClass[_func3] || false;
        var meth = cls[_func3].bind(newClass);
        newClass[_func3] = (...args) => {
          prev && prev(...args);
          return meth(...args);
        };
      };
      for (var _func3 of Object.getOwnPropertyNames(cls)) {
        var _ret = _loop();
        if (_ret === "continue") continue;
      }
      var _loop2 = function _loop2() {
        if (typeof cls[_func4] !== 'function') {
          newClass.prototype[_func4] = cls[_func4];
          return "continue";
        }
        var prev = newClass[_func4] || false;
        var meth = cls[_func4].bind(newClass);
        newClass[_func4] = (...args) => {
          prev && prev(...args);
          return meth(...args);
        };
      };
      for (var _func4 of Object.getOwnPropertySymbols(cls)) {
        var _ret2 = _loop2();
        if (_ret2 === "continue") continue;
      }
    }
  }, {
    key: "mix",
    value: function mix(mixinTo) {
      var constructors = [];
      var allStatic = {};
      var allInstance = {};
      var mixable = _Bindable.Bindable.makeBindable(mixinTo);
      var _loop3 = function _loop3(base) {
        var instanceNames = Object.getOwnPropertyNames(base.prototype);
        var staticNames = Object.getOwnPropertyNames(base);
        var prefix = /^(before|after)__(.+)/;
        var _loop5 = function _loop5(_methodName2) {
          var match = _methodName2.match(prefix);
          if (match) {
            switch (match[1]) {
              case 'before':
                mixable.___before((t, e, s, o, a) => {
                  if (e !== match[2]) {
                    return;
                  }
                  var method = base[_methodName2].bind(o);
                  return method(...a);
                });
                break;
              case 'after':
                mixable.___after((t, e, s, o, a) => {
                  if (e !== match[2]) {
                    return;
                  }
                  var method = base[_methodName2].bind(o);
                  return method(...a);
                });
                break;
            }
            return "continue";
          }
          if (allStatic[_methodName2]) {
            return "continue";
          }
          if (typeof base[_methodName2] !== 'function') {
            return "continue";
          }
          allStatic[_methodName2] = base[_methodName2];
        };
        for (var _methodName2 of staticNames) {
          var _ret3 = _loop5(_methodName2);
          if (_ret3 === "continue") continue;
        }
        var _loop6 = function _loop6(_methodName3) {
          var match = _methodName3.match(prefix);
          if (match) {
            switch (match[1]) {
              case 'before':
                mixable.___before((t, e, s, o, a) => {
                  if (e !== match[2]) {
                    return;
                  }
                  var method = base.prototype[_methodName3].bind(o);
                  return method(...a);
                });
                break;
              case 'after':
                mixable.___after((t, e, s, o, a) => {
                  if (e !== match[2]) {
                    return;
                  }
                  var method = base.prototype[_methodName3].bind(o);
                  return method(...a);
                });
                break;
            }
            return "continue";
          }
          if (allInstance[_methodName3]) {
            return "continue";
          }
          if (typeof base.prototype[_methodName3] !== 'function') {
            return "continue";
          }
          allInstance[_methodName3] = base.prototype[_methodName3];
        };
        for (var _methodName3 of instanceNames) {
          var _ret4 = _loop6(_methodName3);
          if (_ret4 === "continue") continue;
        }
      };
      for (var base = this; base && base.prototype; base = Object.getPrototypeOf(base)) {
        _loop3(base);
      }
      for (var methodName in allStatic) {
        mixinTo[methodName] = allStatic[methodName].bind(mixinTo);
      }
      var _loop4 = function _loop4(_methodName) {
        mixinTo.prototype[_methodName] = function (...args) {
          return allInstance[_methodName].apply(this, args);
        };
      };
      for (var _methodName in allInstance) {
        _loop4(_methodName);
      }
      return mixable;
    }
  }]);
  return Mixin;
}();
exports.Mixin = Mixin;
Mixin.Constructor = Constructor;
  })();
});

require.register("curvature/base/Pool.js", function(exports, require, module) {
  require = __makeRelativeRequire(require, {}, "curvature");
  (function() {
    "use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Pool = void 0;
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var Pool = /*#__PURE__*/function () {
  function Pool({
    max: max,
    init: init
  }) {
    _classCallCheck(this, Pool);
    _defineProperty(this, "backlog", []);
    _defineProperty(this, "running", new Set());
    _defineProperty(this, "max", 1);
    _defineProperty(this, "init", item => new Promise(item));
    this.init = init || this.init;
    this.max = max || this.max;
  }
  _createClass(Pool, [{
    key: "add",
    value: function add(item) {
      var onCompleted = () => {
        this.running.delete(item);
        if (!this.backlog.length) {
          return;
        }
        var next = this.backlog.shift();
        var wrapped = this.init(next);
        wrapped.finally(onCompleted);
        this.running.add(next);
      };
      if (this.running.size < this.max) {
        var wrapped = this.init(item);
        wrapped.finally(onCompleted);
        this.running.add(item);
      } else {
        this.backlog.push(item);
      }
    }
  }]);
  return Pool;
}();
exports.Pool = Pool;
  })();
});

require.register("curvature/base/Router.js", function(exports, require, module) {
  require = __makeRelativeRequire(require, {}, "curvature");
  (function() {
    "use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Router = void 0;
var _View = require("./View");
var _Cache = require("./Cache");
var _Config = require("./Config");
var _Routes = require("./Routes");
var _win$CustomEvent;
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
var NotFoundError = Symbol('NotFound');
var InternalError = Symbol('Internal');
var win = (typeof globalThis === "undefined" ? "undefined" : _typeof(globalThis)) === 'object' ? globalThis : (typeof window === "undefined" ? "undefined" : _typeof(window)) === 'object' ? window : (typeof self === "undefined" ? "undefined" : _typeof(self)) === 'object' ? self : void 0;
win.CustomEvent = (_win$CustomEvent = win.CustomEvent) !== null && _win$CustomEvent !== void 0 ? _win$CustomEvent : win.Event;
var Router = /*#__PURE__*/function () {
  function Router() {
    _classCallCheck(this, Router);
  }
  _createClass(Router, null, [{
    key: "wait",
    value: function wait(view, event = 'DOMContentLoaded', node = document) {
      node.addEventListener(event, () => {
        this.listen(view);
      });
    }
  }, {
    key: "listen",
    value: function listen(listener, routes = false) {
      this.listener = listener || this.listener;
      this.routes = routes || listener.routes;
      Object.assign(this.query, this.queryOver({}));
      var listen = event => {
        event.preventDefault();
        if (event.state && 'routedId' in event.state) {
          if (event.state.routedId <= this.routeCount) {
            this.history.splice(event.state.routedId);
            this.routeCount = event.state.routedId;
          } else if (event.state.routedId > this.routeCount) {
            this.history.push(event.state.prev);
            this.routeCount = event.state.routedId;
          }
          this.state = event.state;
        } else {
          if (this.prevPath !== null && this.prevPath !== location.pathname) {
            this.history.push(this.prevPath);
          }
        }
        if (!this.isOriginLimited(location)) {
          this.match(location.pathname, listener);
        } else {
          this.match(this.nextPath, listener);
        }
      };
      window.addEventListener('cvUrlChanged', listen);
      window.addEventListener('popstate', listen);
      var route = !this.isOriginLimited(location) ? location.pathname + location.search : false;
      if (!this.isOriginLimited(location) && location.hash) {
        route += location.hash;
      }
      var state = {
        routedId: this.routeCount,
        url: location.pathname,
        prev: this.prevPath
      };
      if (!this.isOriginLimited(location)) {
        history.replaceState(state, null, location.pathname);
      }
      this.go(route !== false ? route : '/');
    }
  }, {
    key: "go",
    value: function go(path, silent = false) {
      var configTitle = _Config.Config.get('title');
      if (configTitle) {
        document.title = configTitle;
      }
      var state = {
        routedId: this.routeCount,
        prev: this.prevPath,
        url: location.pathname
      };
      if (silent === -1) {
        this.match(path, this.listener, true);
      } else if (this.isOriginLimited(location)) {
        this.nextPath = path;
      } else if (silent === 2 && location.pathname !== path) {
        history.replaceState(state, null, path);
      } else if (location.pathname !== path) {
        history.pushState(state, null, path);
      }
      if (!silent || silent < 0) {
        if (silent === false) {
          this.path = null;
        }
        if (!silent) {
          if (path.substring(0, 1) === '#') {
            window.dispatchEvent(new HashChangeEvent('hashchange'));
          } else {
            window.dispatchEvent(new CustomEvent('cvUrlChanged'));
          }
        }
      }
      this.prevPath = path;
    }
  }, {
    key: "processRoute",
    value: function processRoute(routes, selected, args) {
      var result = false;
      if (typeof routes[selected] === 'function') {
        if (routes[selected].prototype instanceof _View.View) {
          result = new routes[selected](args);
        } else {
          result = routes[selected](args);
        }
      } else {
        result = routes[selected];
      }
      return result;
    }
  }, {
    key: "handleError",
    value: function handleError(error, routes, selected, args, listener, path, prev, forceRefresh) {
      if (typeof document !== 'undefined') {
        document.dispatchEvent(new CustomEvent('cvRouteError', {
          detail: {
            error: error,
            path: path,
            prev: prev,
            view: listener,
            routes: routes,
            selected: selected
          }
        }));
      }
      var result = win['devMode'] ? 'Unexpected error: ' + String(error) : 'Unexpected error.';
      if (routes[InternalError]) {
        args[InternalError] = error;
        result = this.processRoute(routes, InternalError, args);
      }
      this.update(listener, path, result, routes, selected, args, forceRefresh);
    }
  }, {
    key: "match",
    value: function match(path, listener, options = false) {
      var event = null,
        request = null,
        forceRefresh = false;
      if (options === true) {
        forceRefresh = options;
      }
      if (options && _typeof(options) === 'object') {
        forceRefresh = options.forceRefresh;
        event = options.event;
      }
      if (typeof document !== 'undefined' && this.path === path && !forceRefresh) {
        return;
      }
      var origin = 'http://example.com';
      if (typeof document !== 'undefined') {
        origin = this.isOriginLimited(location) ? origin : location.origin;
        this.queryString = location.search;
      }
      var url = new URL(path, origin);
      path = this.path = url.pathname;
      if (typeof document === 'undefined') {
        this.queryString = url.search;
      }
      var prev = this.prevPath;
      var current = listener && listener.args ? listener.args.content : null;
      var routes = this.routes || listener && listener.routes || _Routes.Routes.dump();
      var query = new URLSearchParams(this.queryString);
      if (event && event.request) {
        this.request = event.request;
      }
      for (var key in Object.keys(this.query)) {
        delete this.query[key];
      }
      for (var _ref3 of query) {
        var _ref2 = _slicedToArray(_ref3, 2);
        var _key = _ref2[0];
        var value = _ref2[1];
        this.query[_key] = value;
      }
      var args = {},
        selected = false,
        result = '';
      if (path.substring(0, 1) === '/') {
        path = path.substring(1);
      }
      path = path.split('/');
      for (var i in this.query) {
        args[i] = this.query[i];
      }
      L1: for (var _i2 in routes) {
        var route = _i2.split('/');
        if (route.length < path.length && route[route.length - 1] !== '*') {
          continue;
        }
        L2: for (var j in route) {
          if (route[j].substr(0, 1) == '%') {
            var argName = null;
            var groups = /^%(\w+)\??/.exec(route[j]);
            if (groups && groups[1]) {
              argName = groups[1];
            }
            if (!argName) {
              throw new Error("".concat(route[j], " is not a valid argument segment in route \"").concat(_i2, "\""));
            }
            if (!path[j]) {
              if (route[j].substr(route[j].length - 1, 1) == '?') {
                args[argName] = '';
              } else {
                continue L1;
              }
            } else {
              args[argName] = path[j];
            }
          } else if (route[j] !== '*' && path[j] !== route[j]) {
            continue L1;
          }
        }
        selected = _i2;
        result = routes[_i2];
        if (route[route.length - 1] === '*') {
          args.pathparts = path.slice(route.length - 1);
        }
        break;
      }
      var eventStart = new CustomEvent('cvRouteStart', {
        cancelable: true,
        detail: {
          path: path,
          prev: prev,
          root: listener,
          selected: selected,
          routes: routes
        }
      });
      if (typeof document !== 'undefined') {
        if (!document.dispatchEvent(eventStart)) {
          return;
        }
      }
      if (!forceRefresh && listener && current && result instanceof Object && current instanceof result && !(result instanceof Promise) && current.update(args)) {
        listener.args.content = current;
        return true;
      }
      if (!(selected in routes)) {
        routes[selected] = routes[NotFoundError];
      }
      try {
        result = this.processRoute(routes, selected, args);
        if (result === false) {
          result = this.processRoute(routes, NotFoundError, args);
        }
        if (typeof document === 'undefined') {
          if (!(result instanceof Promise)) {
            return Promise.resolve(result);
          }
          return result;
        }
        if (!(result instanceof Promise)) {
          return this.update(listener, path, result, routes, selected, args, forceRefresh);
        }
        return result.then(realResult => this.update(listener, path, realResult, routes, selected, args, forceRefresh)).catch(error => {
          this.handleError(error, routes, selected, args, listener, path, prev, forceRefresh);
        });
      } catch (error) {
        this.handleError(error, routes, selected, args, listener, path, prev, forceRefresh);
      }
    }
  }, {
    key: "update",
    value: function update(listener, path, result, routes, selected, args, forceRefresh) {
      if (!listener) {
        return;
      }
      var prev = this.prevPath;
      var event = new CustomEvent('cvRoute', {
        cancelable: true,
        detail: {
          result: result,
          path: path,
          prev: prev,
          view: listener,
          routes: routes,
          selected: selected
        }
      });
      if (result !== false) {
        if (listener.args.content instanceof _View.View) {
          listener.args.content.pause(true);
          listener.args.content.remove();
        }
        if (document.dispatchEvent(event)) {
          listener.args.content = result;
        }
        if (result instanceof _View.View) {
          result.pause(false);
          result.update(args, forceRefresh);
        }
      }
      var eventEnd = new CustomEvent('cvRouteEnd', {
        cancelable: true,
        detail: {
          result: result,
          path: path,
          prev: prev,
          view: listener,
          routes: routes,
          selected: selected
        }
      });
      document.dispatchEvent(eventEnd);
    }
  }, {
    key: "isOriginLimited",
    value: function isOriginLimited({
      origin: origin
    }) {
      return origin === 'null' || origin === 'file://';
    }
  }, {
    key: "queryOver",
    value: function queryOver(args = {}) {
      var params = new URLSearchParams(location.search);
      var finalArgs = {};
      var query = {};
      for (var pair of params) {
        query[pair[0]] = pair[1];
      }
      finalArgs = Object.assign(finalArgs, query, args);
      delete finalArgs['api'];
      return finalArgs;

      // for(let i in query)
      // {
      // 	finalArgs[i] = query[i];
      // }

      // for(let i in args)
      // {
      // 	finalArgs[i] = args[i];
      // }
    }
  }, {
    key: "queryToString",
    value: function queryToString(args = {}, fresh = false) {
      var parts = [],
        finalArgs = args;
      if (!fresh) {
        finalArgs = this.queryOver(args);
      }
      for (var i in finalArgs) {
        if (finalArgs[i] === '') {
          continue;
        }
        parts.push(i + '=' + encodeURIComponent(finalArgs[i]));
      }
      return parts.join('&');
    }
  }, {
    key: "setQuery",
    value: function setQuery(name, value, silent) {
      var args = this.queryOver();
      args[name] = value;
      if (value === undefined) {
        delete args[name];
      }
      var queryString = this.queryToString(args, true);
      this.go(location.pathname + (queryString ? '?' + queryString : '?'), silent);
    }
  }]);
  return Router;
}();
exports.Router = Router;
Object.defineProperty(Router, 'query', {
  configurable: false,
  enumerable: false,
  writable: false,
  value: {}
});
Object.defineProperty(Router, 'history', {
  configurable: false,
  enumerable: false,
  writable: false,
  value: []
});
Object.defineProperty(Router, 'routeCount', {
  configurable: false,
  enumerable: false,
  writable: true,
  value: 0
});
Object.defineProperty(Router, 'prevPath', {
  configurable: false,
  enumerable: false,
  writable: true,
  value: null
});
Object.defineProperty(Router, 'queryString', {
  configurable: false,
  enumerable: false,
  writable: true,
  value: null
});
Object.defineProperty(Router, 'InternalError', {
  configurable: false,
  enumerable: false,
  writable: false,
  value: InternalError
});
Object.defineProperty(Router, 'NotFoundError', {
  configurable: false,
  enumerable: false,
  writable: false,
  value: NotFoundError
});
  })();
});

require.register("curvature/base/Routes.js", function(exports, require, module) {
  require = __makeRelativeRequire(require, {}, "curvature");
  (function() {
    "use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Routes = void 0;
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var AppRoutes = {};
var _require = require;
var imported = false;
var runImport = () => {
  if (imported) {
    return;
  }
  ;
  try {
    Object.assign(AppRoutes, _require('Routes').Routes || {});
  } catch (error) {
    globalThis.devMode === true && console.warn(error);
  }
  imported = true;
};
var Routes = /*#__PURE__*/function () {
  function Routes() {
    _classCallCheck(this, Routes);
  }
  _createClass(Routes, null, [{
    key: "get",
    value: function get(name) {
      runImport();
      return this.routes[name];
    }
  }, {
    key: "dump",
    value: function dump() {
      runImport();
      return this.routes;
    }
  }]);
  return Routes;
}();
exports.Routes = Routes;
Object.defineProperty(Routes, 'routes', {
  configurable: false,
  enumerable: false,
  writable: false,
  value: AppRoutes
});
  })();
});

require.register("curvature/base/RuleSet.js", function(exports, require, module) {
  require = __makeRelativeRequire(require, {}, "curvature");
  (function() {
    "use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RuleSet = void 0;
var _Dom = require("./Dom");
var _Tag = require("./Tag");
var _View = require("./View");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var RuleSet = /*#__PURE__*/function () {
  function RuleSet() {
    _classCallCheck(this, RuleSet);
  }
  _createClass(RuleSet, [{
    key: "add",
    value: function add(selector, callback) {
      this.rules = this.rules || {};
      this.rules[selector] = this.rules[selector] || [];
      this.rules[selector].push(callback);
      return this;
    }
  }, {
    key: "apply",
    value: function apply(doc = document, view = null) {
      RuleSet.apply(doc, view);
      for (var selector in this.rules) {
        for (var i in this.rules[selector]) {
          var callback = this.rules[selector][i];
          var wrapped = RuleSet.wrap(doc, callback, view);
          var nodes = doc.querySelectorAll(selector);
          for (var node of nodes) {
            wrapped(node);
          }
        }
      }
    }
  }, {
    key: "purge",
    value: function purge() {
      if (!this.rules) {
        return;
      }
      for (var _ref3 of Object.entries(this.rules)) {
        var _ref2 = _slicedToArray(_ref3, 2);
        var k = _ref2[0];
        var v = _ref2[1];
        if (!this.rules[k]) {
          continue;
        }
        for (var kk in this.rules[k]) {
          delete this.rules[k][kk];
        }
      }
    }
  }], [{
    key: "add",
    value: function add(selector, callback) {
      this.globalRules = this.globalRules || {};
      this.globalRules[selector] = this.globalRules[selector] || [];
      this.globalRules[selector].push(callback);
      return this;
    }
  }, {
    key: "apply",
    value: function apply(doc = document, view = null) {
      for (var selector in this.globalRules) {
        for (var i in this.globalRules[selector]) {
          var callback = this.globalRules[selector][i];
          var wrapped = this.wrap(doc, callback, view);
          var nodes = doc.querySelectorAll(selector);
          for (var node of nodes) {
            wrapped(node);
          }
        }
      }
    }
  }, {
    key: "wait",
    value: function wait(event = 'DOMContentLoaded', node = document) {
      var listener = ((event, node) => () => {
        node.removeEventListener(event, listener);
        return this.apply();
      })(event, node);
      node.addEventListener(event, listener);
    }
  }, {
    key: "wrap",
    value: function wrap(doc, originalCallback, view = null) {
      var callback = originalCallback;
      if (originalCallback instanceof _View.View || originalCallback && originalCallback.prototype && originalCallback.prototype instanceof _View.View) {
        callback = () => originalCallback;
      }
      return element => {
        if (typeof element.___cvApplied___ === 'undefined') {
          Object.defineProperty(element, '___cvApplied___', {
            enumerable: false,
            writable: false,
            value: new WeakSet()
          });
        }
        if (element.___cvApplied___.has(originalCallback)) {
          return;
        }
        var direct, parentView;
        if (view) {
          direct = parentView = view;
          if (view.viewList) {
            parentView = view.viewList.parent;
          }
        }
        var tag = new _Tag.Tag(element, parentView, null, undefined, direct);
        var parent = tag.element.parentNode;
        var sibling = tag.element.nextSibling;
        var result = callback(tag);
        if (result !== false) {
          element.___cvApplied___.add(originalCallback);
        }
        if (result instanceof HTMLElement) {
          result = new _Tag.Tag(result);
        }
        if (result instanceof _Tag.Tag) {
          if (!result.element.contains(tag.element)) {
            while (tag.element.firstChild) {
              result.element.appendChild(tag.element.firstChild);
            }
            tag.remove();
          }
          if (sibling) {
            parent.insertBefore(result.element, sibling);
          } else {
            parent.appendChild(result.element);
          }
        }
        if (result && result.prototype && result.prototype instanceof _View.View) {
          result = new result({}, view);
        }
        if (result instanceof _View.View) {
          if (view) {
            view.cleanup.push(() => result.remove());
            view.cleanup.push(view.args.bindTo((v, k, t) => {
              t[k] = v;
              result.args[k] = v;
            }));
            view.cleanup.push(result.args.bindTo((v, k, t, d) => {
              t[k] = v;
              view.args[k] = v;
            }));
          }
          tag.clear();
          result.render(tag.element);
        }
      };
    }
  }]);
  return RuleSet;
}();
exports.RuleSet = RuleSet;
  })();
});

require.register("curvature/base/SetMap.js", function(exports, require, module) {
  require = __makeRelativeRequire(require, {}, "curvature");
  (function() {
    "use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SetMap = void 0;
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var SetMap = /*#__PURE__*/function () {
  function SetMap() {
    _classCallCheck(this, SetMap);
    _defineProperty(this, "_map", new Map());
  }
  _createClass(SetMap, [{
    key: "has",
    value: function has(key) {
      return this._map.has(key);
    }
  }, {
    key: "get",
    value: function get(key) {
      return this._map.get(key);
    }
  }, {
    key: "getOne",
    value: function getOne(key) {
      var set = this.get(key);
      for (var entry of set) {
        return entry;
      }
    }
  }, {
    key: "add",
    value: function add(key, value) {
      var set = this._map.get(key);
      if (!set) {
        this._map.set(key, set = new Set());
      }
      return set.add(value);
    }
  }, {
    key: "remove",
    value: function remove(key, value) {
      var set = this._map.get(key);
      if (!set) {
        return;
      }
      var res = set.delete(value);
      if (!set.size) {
        this._map.delete(key);
      }
      return res;
    }
  }, {
    key: "values",
    value: function values() {
      return new Set(...[...this._map.values()].map(set => [...set.values()]));
    }
  }]);
  return SetMap;
}();
exports.SetMap = SetMap;
  })();
});

require.register("curvature/base/Tag.js", function(exports, require, module) {
  require = __makeRelativeRequire(require, {}, "curvature");
  (function() {
    "use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Tag = void 0;
var _Bindable = require("./Bindable");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var CurrentStyle = Symbol('CurrentStyle');
var styler = function styler(styles) {
  if (!this.node) {
    return;
  }
  for (var property in styles) {
    var stringedProperty = String(styles[property]);
    if (this[CurrentStyle].has(property) && this[CurrentStyle].get(property) === styles[property]) {
      continue;
    }
    if (property[0] === '-') {
      this.node.style.setProperty(property, stringedProperty);
    } else {
      this.node.style[property] = stringedProperty;
    }
    if (styles[property] !== undefined) {
      this[CurrentStyle].set(property, styles[property]);
    } else {
      this[CurrentStyle].delete(property);
    }
  }
};
var getter = function getter(name) {
  if (typeof this[name] === 'function') {
    return this[name];
  }
  if (this.node && typeof this.node[name] === 'function') {
    return this[name] = (...args) => this.node[name](...args);
  }
  if (name === 'style') {
    return this.proxy.style;
  }
  if (this.node && name in this.node) {
    return this.node[name];
  }
  return this[name];
};
var Tag = /*#__PURE__*/function () {
  function Tag(element, parent, ref, index, direct) {
    _classCallCheck(this, Tag);
    if (typeof element === 'string') {
      var subdoc = document.createRange().createContextualFragment(element);
      element = subdoc.firstChild;
    }
    this.element = _Bindable.Bindable.makeBindable(element);
    this.node = this.element;
    this.parent = parent;
    this.direct = direct;
    this.ref = ref;
    this.index = index;
    this.cleanup = [];
    this[_Bindable.Bindable.OnAllGet] = getter.bind(this);
    this[CurrentStyle] = new Map();
    var boundStyler = _Bindable.Bindable.make(styler.bind(this));
    Object.defineProperty(this, 'style', {
      value: boundStyler
    });
    this.proxy = _Bindable.Bindable.make(this);
    this.proxy.style.bindTo((v, k, t, d) => {
      if (this[CurrentStyle].has(k) && this[CurrentStyle].get(k) === v) {
        return;
      }
      this.node.style[k] = v;
      if (!d && v !== undefined) {
        this[CurrentStyle].set(k, v);
      } else {
        this[CurrentStyle].delete(k);
      }
    });
    this.proxy.bindTo((v, k) => {
      if (k === 'index') {
        return;
      }
      if (k in element && element[k] !== v) {
        element[k] = v;
      }
      return false;
    });
    return this.proxy;
  }
  _createClass(Tag, [{
    key: "attr",
    value: function attr(attributes) {
      for (var attribute in attributes) {
        if (attributes[attribute] === undefined) {
          this.node.removeAttribute(attribute);
        } else if (attributes[attribute] === null) {
          this.node.setAttribute(attribute, '');
        } else {
          this.node.setAttribute(attribute, attributes[attribute]);
        }
      }
      return this;
    }
  }, {
    key: "remove",
    value: function remove() {
      if (this.node) {
        this.node.remove();
      }
      _Bindable.Bindable.clearBindings(this);
      var cleanup;
      while (cleanup = this.cleanup.shift()) {
        cleanup();
      }
      this.clear();
      if (!this.node) {
        return;
      }
      var detachEvent = new Event('cvDomDetached');
      this.node.dispatchEvent(detachEvent);
      this.node = this.element = this.ref = this.parent = undefined;
    }
  }, {
    key: "clear",
    value: function clear() {
      if (!this.node) {
        return;
      }
      var detachEvent = new Event('cvDomDetached');
      while (this.node.firstChild) {
        this.node.firstChild.dispatchEvent(detachEvent);
        this.node.removeChild(this.node.firstChild);
      }
    }
  }, {
    key: "pause",
    value: function pause(paused = true) {}
  }, {
    key: "listen",
    value: function listen(eventName, callback, options) {
      var node = this.node;
      node.addEventListener(eventName, callback, options);
      var remove = () => {
        node.removeEventListener(eventName, callback, options);
      };
      var remover = () => {
        remove();
        remove = () => console.warn('Already removed!');
      };
      this.parent.onRemove(() => remover());
      return remover;
    }
  }]);
  return Tag;
}();
exports.Tag = Tag;
  })();
});

require.register("curvature/base/Uuid.js", function(exports, require, module) {
  require = __makeRelativeRequire(require, {}, "curvature");
  (function() {
    "use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Uuid = void 0;
var _Symbol$toPrimitive;
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
var win = (typeof globalThis === "undefined" ? "undefined" : _typeof(globalThis)) === 'object' ? globalThis : (typeof window === "undefined" ? "undefined" : _typeof(window)) === 'object' ? window : (typeof self === "undefined" ? "undefined" : _typeof(self)) === 'object' ? self : void 0;
var crypto = win.crypto;
_Symbol$toPrimitive = Symbol.toPrimitive;
var Uuid = /*#__PURE__*/function () {
  function Uuid(uuid = null, version = 4) {
    _classCallCheck(this, Uuid);
    _defineProperty(this, "uuid", null);
    _defineProperty(this, "version", 4);
    if (uuid) {
      if (typeof uuid !== 'string' && !(uuid instanceof Uuid) || !uuid.match(/[0-9A-Fa-f]{8}(-[0-9A-Fa-f]{4}){3}-[0-9A-Fa-f]{12}/)) {
        throw new Error("Invalid input for Uuid: \"".concat(uuid, "\""));
      }
      this.version = version;
      this.uuid = uuid;
    } else if (crypto && typeof crypto.randomUUID === 'function') {
      this.uuid = crypto.randomUUID();
    } else {
      var init = [1e7] + -1e3 + -4e3 + -8e3 + -1e11;
      var rand = crypto && typeof crypto.randomUUID === 'function' ? () => crypto.getRandomValues(new Uint8Array(1))[0] : () => Math.trunc(Math.random() * 256);
      this.uuid = init.replace(/[018]/g, c => (c ^ rand() & 15 >> c / 4).toString(16));
    }
    Object.freeze(this);
  }
  _createClass(Uuid, [{
    key: _Symbol$toPrimitive,
    value: function value() {
      return this.toString();
    }
  }, {
    key: "toString",
    value: function toString() {
      return this.uuid;
    }
  }, {
    key: "toJson",
    value: function toJson() {
      return {
        version: this.version,
        uuid: this.uuid
      };
    }
  }]);
  return Uuid;
}();
exports.Uuid = Uuid;
  })();
});

require.register("curvature/base/View.js", function(exports, require, module) {
  require = __makeRelativeRequire(require, {}, "curvature");
  (function() {
    "use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.View = void 0;
var _Bindable = require("./Bindable");
var _ViewList = require("./ViewList");
var _Router = require("./Router");
var _Uuid = require("./Uuid");
var _Dom = require("./Dom");
var _Tag = require("./Tag");
var _Bag = require("./Bag");
var _RuleSet = require("./RuleSet");
var _Mixin = require("./Mixin");
var _EventTargetMixin = require("../mixin/EventTargetMixin");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
var dontParse = Symbol('dontParse');
var expandBind = Symbol('expandBind');
var uuid = Symbol('uuid');
var View = /*#__PURE__*/function (_Mixin$with) {
  _inherits(View, _Mixin$with);
  var _super = _createSuper(View);
  function View(args = {}, mainView = null) {
    var _this;
    _classCallCheck(this, View);
    _this = _super.call(this, args, mainView);
    _this[_EventTargetMixin.EventTargetMixin.Parent] = mainView;
    Object.defineProperty(_assertThisInitialized(_this), 'args', {
      value: _Bindable.Bindable.make(args)
    });
    Object.defineProperty(_assertThisInitialized(_this), uuid, {
      value: _this.constructor.uuid()
    });
    Object.defineProperty(_assertThisInitialized(_this), 'nodesAttached', {
      value: new _Bag.Bag((i, s, a) => {})
    });
    Object.defineProperty(_assertThisInitialized(_this), 'nodesDetached', {
      value: new _Bag.Bag((i, s, a) => {})
    });
    Object.defineProperty(_assertThisInitialized(_this), '_onRemove', {
      value: new _Bag.Bag((i, s, a) => {})
    });
    Object.defineProperty(_assertThisInitialized(_this), 'cleanup', {
      value: []
    });
    Object.defineProperty(_assertThisInitialized(_this), 'parent', {
      value: mainView,
      writable: true
    });
    Object.defineProperty(_assertThisInitialized(_this), 'views', {
      value: new Map()
    });
    Object.defineProperty(_assertThisInitialized(_this), 'viewLists', {
      value: new Map()
    });
    Object.defineProperty(_assertThisInitialized(_this), 'withViews', {
      value: new Map()
    });
    Object.defineProperty(_assertThisInitialized(_this), 'tags', {
      value: _Bindable.Bindable.make({})
    });
    Object.defineProperty(_assertThisInitialized(_this), 'nodes', {
      value: _Bindable.Bindable.make([])
    });
    Object.defineProperty(_assertThisInitialized(_this), 'timeouts', {
      value: new Map()
    });
    Object.defineProperty(_assertThisInitialized(_this), 'intervals', {
      value: new Map()
    });
    Object.defineProperty(_assertThisInitialized(_this), 'frames', {
      value: []
    });
    Object.defineProperty(_assertThisInitialized(_this), 'ruleSet', {
      value: new _RuleSet.RuleSet()
    });
    Object.defineProperty(_assertThisInitialized(_this), 'preRuleSet', {
      value: new _RuleSet.RuleSet()
    });
    Object.defineProperty(_assertThisInitialized(_this), 'subBindings', {
      value: {}
    });
    Object.defineProperty(_assertThisInitialized(_this), 'templates', {
      value: {}
    });
    Object.defineProperty(_assertThisInitialized(_this), 'postMapping', {
      value: new Set()
    });
    Object.defineProperty(_assertThisInitialized(_this), 'eventCleanup', {
      value: []
    });
    Object.defineProperty(_assertThisInitialized(_this), 'unpauseCallbacks', {
      value: new Map()
    });
    Object.defineProperty(_assertThisInitialized(_this), 'interpolateRegex', {
      value: /(\[\[((?:\$+)?[\w\.\|-]+)\]\])/g
    });
    Object.defineProperty(_assertThisInitialized(_this), 'rendered', {
      value: new Promise((accept, reject) => Object.defineProperty(_assertThisInitialized(_this), 'renderComplete', {
        value: accept
      }))
    });
    _this.onRemove(() => {
      if (!_this[_EventTargetMixin.EventTargetMixin.Parent]) {
        return;
      }
      _this[_EventTargetMixin.EventTargetMixin.Parent] = null;
    });
    _this.controller = _assertThisInitialized(_this);
    _this.template = "";
    _this.firstNode = null;
    _this.lastNode = null;
    _this.viewList = null;
    _this.mainView = null;
    _this.preserve = false;
    _this.removed = false;
    _this.loaded = Promise.resolve(_assertThisInitialized(_this));

    // return Bindable.make(this);
    return _this;
  }
  _createClass(View, [{
    key: "_id",
    get: function get() {
      return this[uuid];
    }
  }, {
    key: "onFrame",
    value: function onFrame(callback) {
      var stopped = false;
      var cancel = () => {
        stopped = true;
      };
      var c = timestamp => {
        if (this.removed || stopped) {
          return;
        }
        if (!this.paused) {
          callback(Date.now());
        }
        requestAnimationFrame(c);
      };
      requestAnimationFrame(() => c(Date.now()));
      this.frames.push(cancel);
      return cancel;
    }
  }, {
    key: "onNextFrame",
    value: function onNextFrame(callback) {
      return requestAnimationFrame(() => callback(Date.now()));
    }
  }, {
    key: "onIdle",
    value: function onIdle(callback) {
      return requestIdleCallback(() => callback(Date.now()));
    }
  }, {
    key: "onTimeout",
    value: function onTimeout(time, callback) {
      var timeoutInfo = {
        timeout: null,
        callback: null,
        time: time,
        fired: false,
        created: new Date().getTime(),
        paused: false
      };
      var wrappedCallback = () => {
        callback();
        timeoutInfo.fired = true;
        this.timeouts.delete(timeoutInfo.timeout);
      };
      var timeout = setTimeout(wrappedCallback, time);
      timeoutInfo.callback = wrappedCallback;
      timeoutInfo.timeout = timeout;
      this.timeouts.set(timeoutInfo.timeout, timeoutInfo);
      return timeout;
    }
  }, {
    key: "clearTimeout",
    value: function (_clearTimeout) {
      function clearTimeout(_x) {
        return _clearTimeout.apply(this, arguments);
      }
      clearTimeout.toString = function () {
        return _clearTimeout.toString();
      };
      return clearTimeout;
    }(function (timeout) {
      if (!this.timeouts.has(timeout)) {
        return;
      }
      var timeoutInfo = this.timeouts.get(timeout);
      clearTimeout(timeoutInfo.timeout);
      this.timeouts.delete(timeoutInfo.timeout);
    })
  }, {
    key: "onInterval",
    value: function onInterval(time, callback) {
      var timeout = setInterval(callback, time);
      this.intervals.set(timeout, {
        timeout: timeout,
        callback: callback,
        time: time,
        paused: false
      });
      return timeout;
    }
  }, {
    key: "clearInterval",
    value: function clearInterval(timeout) {
      if (!this.intervals.has(timeout)) {
        return;
      }
      var timeoutInfo = this.intervals.get(timeout);
      clearTimeout(timeoutInfo.timeout);
      this.intervals.delete(timeoutInfo.timeout);
    }
  }, {
    key: "pause",
    value: function pause(paused = undefined) {
      if (paused === undefined) {
        this.paused = !this.paused;
      }
      this.paused = paused;
      if (this.paused) {
        for (var _ref3 of this.timeouts) {
          var _ref2 = _slicedToArray(_ref3, 2);
          var callback = _ref2[0];
          var timeout = _ref2[1];
          if (timeout.fired) {
            this.timeouts.delete(timeout.timeout);
            continue;
          }
          clearTimeout(timeout.timeout);
          timeout.paused = true;
          timeout.time = Math.max(0, timeout.time - (Date.now() - timeout.created));
        }
        for (var _ref6 of this.intervals) {
          var _ref5 = _slicedToArray(_ref6, 2);
          var _callback = _ref5[0];
          var _timeout = _ref5[1];
          clearInterval(_timeout.timeout);
          _timeout.paused = true;
        }
      } else {
        for (var _ref9 of this.timeouts) {
          var _ref8 = _slicedToArray(_ref9, 2);
          var _callback2 = _ref8[0];
          var _timeout2 = _ref8[1];
          if (!_timeout2.paused) {
            continue;
          }
          if (_timeout2.fired) {
            this.timeouts.delete(_timeout2.timeout);
            continue;
          }
          _timeout2.timeout = setTimeout(_timeout2.callback, _timeout2.time);
          _timeout2.paused = false;
        }
        for (var _ref12 of this.intervals) {
          var _ref11 = _slicedToArray(_ref12, 2);
          var _callback3 = _ref11[0];
          var _timeout3 = _ref11[1];
          if (!_timeout3.paused) {
            continue;
          }
          _timeout3.timeout = setInterval(_timeout3.callback, _timeout3.time);
          _timeout3.paused = false;
        }
        for (var _ref15 of this.unpauseCallbacks) {
          var _ref14 = _slicedToArray(_ref15, 2);
          var _callback4 = _ref14[1];
          _callback4();
        }
        this.unpauseCallbacks.clear();
      }
      for (var _ref18 of this.viewLists) {
        var _ref17 = _slicedToArray(_ref18, 2);
        var tag = _ref17[0];
        var viewList = _ref17[1];
        viewList.pause(!!paused);
      }
      for (var i in this.tags) {
        if (Array.isArray(this.tags[i])) {
          for (var j in this.tags[i]) {
            this.tags[i][j].pause(!!paused);
          }
          continue;
        }
        this.tags[i].pause(!!paused);
      }
    }
  }, {
    key: "render",
    value: function render(parentNode = null, insertPoint = null, outerView = null) {
      var document = globalThis.window.document;
      if (parentNode instanceof View) {
        parentNode = parentNode.firstNode.parentNode;
      }
      if (insertPoint instanceof View) {
        insertPoint = insertPoint.firstNode;
      }
      if (this.firstNode) {
        return this.reRender(parentNode, insertPoint, outerView);
      }
      this.dispatchEvent(new CustomEvent('render'));
      var templateIsFragment = _typeof(this.template) === 'object' && typeof this.template.cloneNode === 'function';
      var templateParsed = templateIsFragment || View.templates.has(this.template);
      var subDoc;
      if (templateParsed) {
        if (templateIsFragment) {
          subDoc = this.template.cloneNode(true);
        } else {
          subDoc = View.templates.get(this.template).cloneNode(true);
        }
      } else {
        subDoc = document.createRange().createContextualFragment(this.template);
      }
      if (!templateParsed && !templateIsFragment) {
        View.templates.set(this.template, subDoc.cloneNode(true));
      }
      this.mainView || this.preRuleSet.apply(subDoc, this);
      this.mapTags(subDoc);
      this.mainView || this.ruleSet.apply(subDoc, this);
      if (globalThis.devMode === true) {
        this.firstNode = document.createComment("Template ".concat(this._id, " Start"));
        this.lastNode = document.createComment("Template ".concat(this._id, " End"));
      } else {
        this.firstNode = document.createTextNode('');
        this.lastNode = document.createTextNode('');
      }
      this.nodes.push(this.firstNode, ...Array.from(subDoc.childNodes), this.lastNode);
      this.postRender(parentNode);
      this.dispatchEvent(new CustomEvent('rendered'));
      if (!this.dispatchAttach()) {
        return;
      }
      if (parentNode) {
        if (insertPoint) {
          parentNode.insertBefore(this.firstNode, insertPoint);
          parentNode.insertBefore(this.lastNode, insertPoint);
        } else {
          parentNode.appendChild(this.firstNode);
          parentNode.appendChild(this.lastNode);
        }
        parentNode.insertBefore(subDoc, this.lastNode);
        var rootNode = parentNode.getRootNode();
        if (rootNode.isConnected) {
          this.attached(rootNode, parentNode);
          this.dispatchAttached(rootNode, parentNode, outerView);
        } else if (outerView) {
          var firstDomAttach = event => {
            var rootNode = parentNode.getRootNode();
            this.attached(rootNode, parentNode);
            this.dispatchAttached(rootNode, parentNode, outerView);
            outerView.removeEventListener('attached', firstDomAttach);
          };
          outerView.addEventListener('attached', firstDomAttach);
        }
      }
      this.renderComplete(this.nodes);
      return this.nodes;
    }
  }, {
    key: "dispatchAttach",
    value: function dispatchAttach() {
      var CustomEvent = globalThis.window.CustomEvent;
      return this.dispatchEvent(new CustomEvent('attach', {
        cancelable: true,
        target: this
      }));
    }
  }, {
    key: "dispatchAttached",
    value: function dispatchAttached(rootNode, parentNode, view = undefined) {
      var CustomEvent = globalThis.window.CustomEvent;
      this.dispatchEvent(new CustomEvent('attached', {
        detail: {
          view: view || this,
          node: parentNode,
          root: rootNode,
          mainView: this
        }
      }));
      this.dispatchDomAttached(view);
      for (var callback of this.nodesAttached.items()) {
        callback(rootNode, parentNode);
      }
    }
  }, {
    key: "dispatchDomAttached",
    value: function dispatchDomAttached(view) {
      var _globalThis$window = globalThis.window,
        Node = _globalThis$window.Node,
        CustomEvent = _globalThis$window.CustomEvent;
      this.nodes.filter(n => n.nodeType !== Node.COMMENT_NODE).forEach(child => {
        if (!child.matches) {
          return;
        }
        child.dispatchEvent(new CustomEvent('cvDomAttached', {
          target: child,
          detail: {
            view: view || this,
            mainView: this
          }
        }));
        _Dom.Dom.mapTags(child, false, (tag, walker) => {
          if (!tag.matches) {
            return;
          }
          tag.dispatchEvent(new CustomEvent('cvDomAttached', {
            target: tag,
            detail: {
              view: view || this,
              mainView: this
            }
          }));
        });
      });
    }
  }, {
    key: "reRender",
    value: function reRender(parentNode, insertPoint, outerView) {
      var CustomEvent = globalThis.window.CustomEvent;
      var willReRender = this.dispatchEvent(new CustomEvent('reRender'), {
        cancelable: true,
        target: this,
        view: outerView
      });
      if (!willReRender) {
        return;
      }
      var subDoc = new DocumentFragment();
      if (this.firstNode.isConnected) {
        var detach = this.nodesDetached.items();
        for (var i in detach) {
          detach[i]();
        }
      }
      subDoc.append(...this.nodes);
      if (parentNode) {
        if (insertPoint) {
          parentNode.insertBefore(this.firstNode, insertPoint);
          parentNode.insertBefore(this.lastNode, insertPoint);
        } else {
          parentNode.appendChild(this.firstNode);
          parentNode.appendChild(this.lastNode);
        }
        parentNode.insertBefore(subDoc, this.lastNode);
        this.dispatchEvent(new CustomEvent('reRendered'), {
          cancelable: true,
          target: this,
          view: outerView
        });
        var rootNode = parentNode.getRootNode();
        if (rootNode.isConnected) {
          this.attached(rootNode, parentNode);
          this.dispatchAttached(rootNode, parentNode);
        }
      }
      return this.nodes;
    }
  }, {
    key: "mapTags",
    value: function mapTags(subDoc) {
      _Dom.Dom.mapTags(subDoc, false, (tag, walker) => {
        if (tag[dontParse]) {
          return;
        }
        if (tag.matches) {
          tag = this.mapInterpolatableTag(tag);
          tag = tag.matches('[cv-template]') && this.mapTemplateTag(tag) || tag;
          tag = tag.matches('[cv-slot]') && this.mapSlotTag(tag) || tag;
          tag = tag.matches('[cv-prerender]') && this.mapPrendererTag(tag) || tag;
          tag = tag.matches('[cv-link]') && this.mapLinkTag(tag) || tag;
          tag = tag.matches('[cv-attr]') && this.mapAttrTag(tag) || tag;
          tag = tag.matches('[cv-expand]') && this.mapExpandableTag(tag) || tag;
          tag = tag.matches('[cv-ref]') && this.mapRefTag(tag) || tag;
          tag = tag.matches('[cv-on]') && this.mapOnTag(tag) || tag;
          tag = tag.matches('[cv-each]') && this.mapEachTag(tag) || tag;
          tag = tag.matches('[cv-bind]') && this.mapBindTag(tag) || tag;
          tag = tag.matches('[cv-with]') && this.mapWithTag(tag) || tag;
          tag = tag.matches('[cv-if]') && this.mapIfTag(tag) || tag;
          tag = tag.matches('[cv-view]') && this.mapViewTag(tag) || tag;
        } else {
          tag = this.mapInterpolatableTag(tag);
        }
        if (tag !== walker.currentNode) {
          walker.currentNode = tag;
        }
      });
      this.postMapping.forEach(c => c());
    }
  }, {
    key: "mapExpandableTag",
    value: function mapExpandableTag(tag) {
      // const tagCompiler = this.compileExpandableTag(tag);
      // const newTag = tagCompiler(this);
      // tag.replaceWith(newTag);
      // return newTag;

      var existing = tag[expandBind];
      if (existing) {
        existing();
        tag[expandBind] = false;
      }
      var _Bindable$resolve = _Bindable.Bindable.resolve(this.args, tag.getAttribute('cv-expand'), true),
        _Bindable$resolve2 = _slicedToArray(_Bindable$resolve, 2),
        proxy = _Bindable$resolve2[0],
        expandProperty = _Bindable$resolve2[1];
      tag.removeAttribute('cv-expand');
      if (!proxy[expandProperty]) {
        proxy[expandProperty] = {};
      }
      proxy[expandProperty] = _Bindable.Bindable.make(proxy[expandProperty]);
      this.onRemove(tag[expandBind] = proxy[expandProperty].bindTo((v, k, t, d, p) => {
        if (d || v === undefined) {
          tag.removeAttribute(k, v);
          return;
        }
        if (v === null) {
          tag.setAttribute(k, '');
          return;
        }
        tag.setAttribute(k, v);
      }));

      // let expandProperty = tag.getAttribute('cv-expand');
      // let expandArg = Bindable.makeBindable(
      // 	this.args[expandProperty] || {}
      // );

      // tag.removeAttribute('cv-expand');

      // for(let i in expandArg)
      // {
      // 	if(i === 'name' || i === 'type')
      // 	{
      // 		continue;
      // 	}

      // 	let debind = expandArg.bindTo(i, ((tag,i)=>(v)=>{
      // 		tag.setAttribute(i, v);
      // 	})(tag,i));

      // 	this.onRemove(()=>{
      // 		debind();
      // 		if(expandArg.isBound())
      // 		{
      // 			Bindable.clearBindings(expandArg);
      // 		}
      // 	});
      // }

      return tag;
    }

    // compileExpandableTag(sourceTag)
    // {
    // 	return (bindingView) => {

    // 		const tag = sourceTag.cloneNode(true);

    // 		let expandProperty = tag.getAttribute('cv-expand');
    // 		let expandArg = Bindable.make(
    // 			bindingView.args[expandProperty] || {}
    // 		);

    // 		tag.removeAttribute('cv-expand');

    // 		for(let i in expandArg)
    // 		{
    // 			if(i === 'name' || i === 'type')
    // 			{
    // 				continue;
    // 			}

    // 			let debind = expandArg.bindTo(i, ((tag,i)=>(v)=>{
    // 				tag.setAttribute(i, v);
    // 			})(tag,i));

    // 			bindingView.onRemove(()=>{
    // 				debind();
    // 				if(expandArg.isBound())
    // 				{
    // 					Bindable.clearBindings(expandArg);
    // 				}
    // 			});
    // 		}

    // 		return tag;
    // 	};
    // }
  }, {
    key: "mapAttrTag",
    value: function mapAttrTag(tag) {
      var tagCompiler = this.compileAttrTag(tag);
      var newTag = tagCompiler(this);
      tag.replaceWith(newTag);
      return newTag;

      // let attrProperty = tag.getAttribute('cv-attr');

      // tag.removeAttribute('cv-attr');

      // let pairs = attrProperty.split(',');
      // let attrs = pairs.map((p) => p.split(':'));

      // for (let i in attrs)
      // {
      // 	let proxy        = this.args;
      // 	let bindProperty = attrs[i][1];
      // 	let property     = bindProperty;

      // 	if(bindProperty.match(/\./))
      // 	{
      // 		[proxy, property] = Bindable.resolve(
      // 			this.args
      // 			, bindProperty
      // 			, true
      // 		);
      // 	}

      // 	let attrib = attrs[i][0];

      // 	this.onRemove(proxy.bindTo(
      // 		property
      // 		, (v)=>{
      // 			if(v == null)
      // 			{
      // 				tag.setAttribute(attrib, '');
      // 				return;
      // 			}
      // 			tag.setAttribute(attrib, v);
      // 		}
      // 	));
      // }

      // return tag;
    }
  }, {
    key: "compileAttrTag",
    value: function compileAttrTag(sourceTag) {
      var attrProperty = sourceTag.getAttribute('cv-attr');
      var pairs = attrProperty.split(/[,;]/);
      var attrs = pairs.map(p => p.split(':'));
      sourceTag.removeAttribute('cv-attr');
      return bindingView => {
        var tag = sourceTag.cloneNode(true);
        var _loop = function _loop() {
          var bindProperty = attrs[i][1] || attrs[i][0];
          var _Bindable$resolve3 = _Bindable.Bindable.resolve(bindingView.args, bindProperty, true),
            _Bindable$resolve4 = _slicedToArray(_Bindable$resolve3, 2),
            proxy = _Bindable$resolve4[0],
            property = _Bindable$resolve4[1];
          var attrib = attrs[i][0];
          bindingView.onRemove(proxy.bindTo(property, (v, k, t, d) => {
            if (d || v === undefined) {
              tag.removeAttribute(attrib, v);
              return;
            }
            if (v === null) {
              tag.setAttribute(attrib, '');
              return;
            }
            tag.setAttribute(attrib, v);
          }));
        };
        for (var i in attrs) {
          _loop();
        }
        return tag;
      };
    }
  }, {
    key: "mapInterpolatableTag",
    value: function mapInterpolatableTag(tag) {
      var _this2 = this;
      var regex = this.interpolateRegex;
      var _globalThis$window2 = globalThis.window,
        Node = _globalThis$window2.Node,
        document = _globalThis$window2.document;
      if (tag.nodeType === Node.TEXT_NODE) {
        var original = tag.nodeValue;
        if (!this.interpolatable(original)) {
          return tag;
        }
        var header = 0;
        var match;
        var _loop2 = function _loop2() {
          var bindProperty = match[2];
          var unsafeHtml = false;
          var unsafeView = false;
          var propertySplit = bindProperty.split('|');
          var transformer = false;
          if (propertySplit.length > 1) {
            transformer = _this2.stringTransformer(propertySplit.slice(1));
            bindProperty = propertySplit[0];
          }
          if (bindProperty.substr(0, 2) === '$$') {
            unsafeHtml = true;
            unsafeView = true;
            bindProperty = bindProperty.substr(2);
          }
          if (bindProperty.substr(0, 1) === '$') {
            unsafeHtml = true;
            bindProperty = bindProperty.substr(1);
          }
          if (bindProperty.substr(0, 3) === '000') {
            expand = true;
            bindProperty = bindProperty.substr(3);
            return "continue";
          }
          var staticPrefix = original.substring(header, match.index);
          header = match.index + match[1].length;
          var staticNode = document.createTextNode(staticPrefix);
          staticNode[dontParse] = true;
          tag.parentNode.insertBefore(staticNode, tag);
          var dynamicNode;
          if (unsafeHtml) {
            dynamicNode = document.createElement('div');
          } else {
            dynamicNode = document.createTextNode('');
          }
          dynamicNode[dontParse] = true;
          var proxy = _this2.args;
          var property = bindProperty;
          if (bindProperty.match(/\./)) {
            var _Bindable$resolve5 = _Bindable.Bindable.resolve(_this2.args, bindProperty, true);
            var _Bindable$resolve6 = _slicedToArray(_Bindable$resolve5, 2);
            proxy = _Bindable$resolve6[0];
            property = _Bindable$resolve6[1];
          }
          tag.parentNode.insertBefore(dynamicNode, tag);
          if (_typeof(proxy) !== 'object') {
            return "break";
          }
          proxy = _Bindable.Bindable.make(proxy);
          var debind = proxy.bindTo(property, (v, k, t) => {
            if (t[k] !== v && (t[k] instanceof View || t[k] instanceof Node || t[k] instanceof _Tag.Tag)) {
              if (!t[k].preserve) {
                t[k].remove();
              }
            }
            dynamicNode.nodeValue = '';
            if (unsafeView && !(v instanceof View)) {
              var _v;
              var unsafeTemplate = (_v = v) !== null && _v !== void 0 ? _v : '';
              v = new View(_this2.args, _this2);
              v.template = unsafeTemplate;
            }
            if (transformer) {
              v = transformer(v);
            }
            if (v instanceof View) {
              v[_EventTargetMixin.EventTargetMixin.Parent] = _this2;
              v.render(tag.parentNode, dynamicNode, _this2);
              var cleanup = () => {
                if (!v.preserve) {
                  v.remove();
                }
              };
              _this2.onRemove(cleanup);
              v.onRemove(() => _this2._onRemove.remove(cleanup));
            } else if (v instanceof Node) {
              tag.parentNode.insertBefore(v, dynamicNode);
              _this2.onRemove(() => v.remove());
            } else if (v instanceof _Tag.Tag) {
              if (v.node) {
                tag.parentNode.insertBefore(v.node, dynamicNode);
                _this2.onRemove(() => v.remove());
              } else {
                v.remove();
              }
            } else {
              if (v instanceof Object && v.__toString instanceof Function) {
                v = v.__toString();
              }
              if (unsafeHtml) {
                dynamicNode.innerHTML = v;
              } else {
                dynamicNode.nodeValue = v;
              }
            }
            dynamicNode[dontParse] = true;
          });
          _this2.onRemove(debind);
        };
        while (match = regex.exec(original)) {
          var _ret = _loop2();
          if (_ret === "continue") continue;
          if (_ret === "break") break;
        }
        var staticSuffix = original.substring(header);
        var staticNode = document.createTextNode(staticSuffix);
        staticNode[dontParse] = true;
        tag.parentNode.insertBefore(staticNode, tag);
        tag.nodeValue = '';
      } else if (tag.nodeType === Node.ELEMENT_NODE) {
        var _loop3 = function _loop3() {
          if (!_this2.interpolatable(tag.attributes[i].value)) {
            return "continue";
          }
          var header = 0;
          var match;
          var original = tag.attributes[i].value;
          var attribute = tag.attributes[i];
          var bindProperties = {};
          var segments = [];
          while (match = regex.exec(original)) {
            segments.push(original.substring(header, match.index));
            if (!bindProperties[match[2]]) {
              bindProperties[match[2]] = [];
            }
            bindProperties[match[2]].push(segments.length);
            segments.push(match[1]);
            header = match.index + match[1].length;
          }
          segments.push(original.substring(header));
          var _loop4 = function _loop4() {
            var proxy = _this2.args;
            var property = j;
            var propertySplit = j.split('|');
            var transformer = false;
            var longProperty = j;
            if (propertySplit.length > 1) {
              transformer = _this2.stringTransformer(propertySplit.slice(1));
              property = propertySplit[0];
            }
            if (property.match(/\./)) {
              var _Bindable$resolve7 = _Bindable.Bindable.resolve(_this2.args, property, true);
              var _Bindable$resolve8 = _slicedToArray(_Bindable$resolve7, 2);
              proxy = _Bindable$resolve8[0];
              property = _Bindable$resolve8[1];
            }
            var matching = [];
            var bindProperty = j;
            var matchingSegments = bindProperties[longProperty];

            // const changeAttribute = (v, k, t, d) => {
            // 	tag.setAttribute(attribute.name, segments.join(''));
            // };

            _this2.onRemove(proxy.bindTo(property, (v, k, t, d) => {
              if (transformer) {
                v = transformer(v);
              }
              for (var _i2 in bindProperties) {
                for (var _j in bindProperties[longProperty]) {
                  segments[bindProperties[longProperty][_j]] = t[_i2];
                  if (k === property) {
                    segments[bindProperties[longProperty][_j]] = v;
                  }
                }
              }
              if (!_this2.paused) {
                // changeAttribute(v,k,t,d);
                tag.setAttribute(attribute.name, segments.join(''));
              } else {
                // this.unpauseCallbacks.set(attribute, () => changeAttribute(v,k,t,d));
                _this2.unpauseCallbacks.set(attribute, () => tag.setAttribute(attribute.name, segments.join('')));
              }
            }));

            // this.onRemove(()=>{
            // 	if(!proxy.isBound())
            // 	{
            // 		Bindable.clearBindings(proxy);
            // 	}
            // });
          };
          for (var j in bindProperties) {
            _loop4();
          }
        };
        for (var i = 0; i < tag.attributes.length; i++) {
          var _ret2 = _loop3();
          if (_ret2 === "continue") continue;
        }
      }
      return tag;
    }
  }, {
    key: "mapRefTag",
    value: function mapRefTag(tag) {
      var refAttr = tag.getAttribute('cv-ref');
      var _refAttr$split = refAttr.split(':'),
        _refAttr$split2 = _slicedToArray(_refAttr$split, 3),
        refProp = _refAttr$split2[0],
        _refAttr$split2$ = _refAttr$split2[1],
        refClassname = _refAttr$split2$ === void 0 ? null : _refAttr$split2$,
        _refAttr$split2$2 = _refAttr$split2[2],
        refKey = _refAttr$split2$2 === void 0 ? null : _refAttr$split2$2;
      var refClass = _Tag.Tag;
      if (refClassname) {
        refClass = this.stringToClass(refClassname);
      }
      tag.removeAttribute('cv-ref');
      Object.defineProperty(tag, '___tag___', {
        enumerable: false,
        writable: true
      });
      this.onRemove(() => {
        tag.___tag___ = null;
        tag.remove();
      });
      var parent = this;
      var direct = this;
      if (this.viewList) {
        parent = this.viewList.parent;
        // if(!this.viewList.parent.tags[refProp])
        // {
        // 	this.viewList.parent.tags[refProp] = [];
        // }

        // let refKeyVal = this.args[refKey];

        // this.viewList.parent.tags[refProp][refKeyVal] = new refClass(
        // 	tag, this, refProp, refKeyVal
        // );
      }
      // else
      // {
      // 	this.tags[refProp] = new refClass(
      // 		tag, this, refProp
      // 	);
      // }

      var tagObject = new refClass(tag, this, refProp, undefined, direct);
      tag.___tag___ = tagObject;
      this.tags[refProp] = tagObject;
      while (parent) {
        var refKeyVal = this.args[refKey];
        if (refKeyVal !== undefined) {
          if (!parent.tags[refProp]) {
            parent.tags[refProp] = [];
          }
          parent.tags[refProp][refKeyVal] = tagObject;
        } else {
          parent.tags[refProp] = tagObject;
        }
        if (!parent.parent) {
          break;
        }
        parent = parent.parent;
      }
      return tag;
    }
  }, {
    key: "mapBindTag",
    value: function mapBindTag(tag) {
      var bindArg = tag.getAttribute('cv-bind');
      var proxy = this.args;
      var property = bindArg;
      var top = null;
      if (bindArg.match(/\./)) {
        var _Bindable$resolve9 = _Bindable.Bindable.resolve(this.args, bindArg, true);
        var _Bindable$resolve10 = _slicedToArray(_Bindable$resolve9, 3);
        proxy = _Bindable$resolve10[0];
        property = _Bindable$resolve10[1];
        top = _Bindable$resolve10[2];
      }
      if (proxy !== this.args) {
        this.subBindings[bindArg] = this.subBindings[bindArg] || [];
        this.onRemove(this.args.bindTo(top, () => {
          while (this.subBindings.length) {
            this.subBindings.shift()();
          }
        }));
      }
      var unsafeHtml = false;
      if (property.substr(0, 1) === '$') {
        property = property.substr(1);
        unsafeHtml = true;
      }
      var autoEventStarted = false;
      var debind = proxy.bindTo(property, (v, k, t, d, p) => {
        if ((p instanceof View || p instanceof Node || p instanceof _Tag.Tag) && p !== v) {
          p.remove();
        }
        if (['INPUT', 'SELECT', 'TEXTAREA'].includes(tag.tagName)) {
          var _type = tag.getAttribute('type');
          if (_type && _type.toLowerCase() === 'checkbox') {
            tag.checked = !!v;
          } else if (_type && _type.toLowerCase() === 'radio') {
            tag.checked = v == tag.value;
          } else if (_type !== 'file') {
            if (tag.tagName === 'SELECT') {
              var selectOption = () => {
                for (var i = 0; i < tag.options.length; i++) {
                  var option = tag.options[i];
                  if (option.value == v) {
                    tag.selectedIndex = i;
                  }
                }
              };
              selectOption();
              this.nodesAttached.add(selectOption);
            } else {
              tag.value = v == null ? '' : v;
            }
          }
          if (autoEventStarted) {
            tag.dispatchEvent(new CustomEvent('cvAutoChanged', {
              bubbles: true
            }));
          }
          autoEventStarted = true;
        } else {
          if (v instanceof View) {
            for (var node of tag.childNodes) {
              node.remove();
            }
            v[_EventTargetMixin.EventTargetMixin.Parent] = this;
            v.render(tag, null, this);
          } else if (v instanceof Node) {
            tag.insert(v);
          } else if (v instanceof _Tag.Tag) {
            tag.append(v.node);
          } else if (unsafeHtml) {
            if (tag.innerHTML !== v) {
              v = String(v);
              if (tag.innerHTML === v.substring(0, tag.innerHTML.length)) {
                tag.innerHTML += v.substring(tag.innerHTML.length);
              } else {
                for (var _node of tag.childNodes) {
                  _node.remove();
                }
                tag.innerHTML = v;
              }
              _Dom.Dom.mapTags(tag, false, t => t[dontParse] = true);
            }
          } else {
            if (tag.textContent !== v) {
              for (var _node2 of tag.childNodes) {
                _node2.remove();
              }
              tag.textContent = v;
            }
          }
        }
      });
      if (proxy !== this.args) {
        this.subBindings[bindArg].push(debind);
      }
      this.onRemove(debind);
      var type = tag.getAttribute('type');
      var multi = tag.getAttribute('multiple');
      var inputListener = event => {
        if (event.target !== tag) {
          return;
        }
        if (type && type.toLowerCase() === 'checkbox') {
          if (tag.checked) {
            proxy[property] = event.target.getAttribute('value');
          } else {
            proxy[property] = false;
          }
        } else if (event.target.matches('[contenteditable=true]')) {
          proxy[property] = event.target.innerHTML;
        } else if (type === 'file' && multi) {
          var files = Array.from(event.target.files);
          var current = proxy[property] || _Bindable.Bindable.onDeck(proxy, property);
          if (!current || !files.length) {
            proxy[property] = files;
          } else {
            var _loop5 = function _loop5(i) {
              if (files[i] !== current[i]) {
                files[i].toJSON = () => {
                  return {
                    name: file[i].name,
                    size: file[i].size,
                    type: file[i].type,
                    date: file[i].lastModified
                  };
                };
                current[i] = files[i];
                return "break";
              }
            };
            for (var i in files) {
              var _ret3 = _loop5(i);
              if (_ret3 === "break") break;
            }
          }
        } else if (type === 'file' && !multi && event.target.files.length) {
          var _file = event.target.files.item(0);
          _file.toJSON = () => {
            return {
              name: _file.name,
              size: _file.size,
              type: _file.type,
              date: _file.lastModified
            };
          };
          proxy[property] = _file;
        } else {
          proxy[property] = event.target.value;
        }
      };
      if (type === 'file' || type === 'radio') {
        tag.addEventListener('change', inputListener);
      } else {
        tag.addEventListener('input', inputListener);
        tag.addEventListener('change', inputListener);
        tag.addEventListener('value-changed', inputListener);
      }
      this.onRemove(() => {
        if (type === 'file' || type === 'radio') {
          tag.removeEventListener('change', inputListener);
        } else {
          tag.removeEventListener('input', inputListener);
          tag.removeEventListener('change', inputListener);
          tag.removeEventListener('value-changed', inputListener);
        }
      });
      tag.removeAttribute('cv-bind');
      return tag;
    }
  }, {
    key: "mapOnTag",
    value: function mapOnTag(tag) {
      var referents = String(tag.getAttribute('cv-on'));
      referents.split(';').map(a => a.split(':')).forEach(a => {
        a = a.map(a => a.trim());
        var argLen = a.length;
        var eventName = String(a.shift()).trim();
        var callbackName = String(a.shift() || eventName).trim();
        var eventFlags = String(a.shift() || '').trim();
        var argList = [];
        var groups = /(\w+)(?:\(([$\w\s-'",]+)\))?/.exec(callbackName);
        if (groups) {
          callbackName = groups[1].replace(/(^[\s\n]+|[\s\n]+$)/, '');
          if (groups[2]) {
            argList = groups[2].split(',').map(s => s.trim());
          }
        }
        if (!argList.length) {
          argList.push('$event');
        }
        if (!eventName || argLen === 1) {
          eventName = callbackName;
        }
        var eventMethod;
        var parent = this;
        var _loop6 = function _loop6() {
          var controller = parent.controller;
          if (typeof controller[callbackName] === 'function') {
            eventMethod = (...args) => {
              controller[callbackName](...args);
            };
            return "break";
          } else if (typeof parent[callbackName] === 'function') {
            eventMethod = (...args) => {
              parent[callbackName](...args);
            };
            return "break";
          }
          if (parent.parent) {
            parent = parent.parent;
          } else {
            return "break";
          }
        };
        while (parent) {
          var _ret4 = _loop6();
          if (_ret4 === "break") break;
        }
        var eventListener = event => {
          var argRefs = argList.map(arg => {
            var match;
            if (Number(arg) == arg) {
              return arg;
            } else if (arg === 'event' || arg === '$event') {
              return event;
            } else if (arg === '$view') {
              return parent;
            } else if (arg === '$controller') {
              return controller;
            } else if (arg === '$tag') {
              return tag;
            } else if (arg === '$parent') {
              return this.parent;
            } else if (arg === '$subview') {
              return this;
            } else if (arg in this.args) {
              return this.args[arg];
            } else if (match = /^['"]([\w-]+?)["']$/.exec(arg)) {
              return match[1];
            }
          });
          if (!(typeof eventMethod === 'function')) {
            throw new Error("".concat(callbackName, " is not defined on View object.") + "\n" + "Tag:" + "\n" + "".concat(tag.outerHTML));
          }
          eventMethod(...argRefs);
        };
        var eventOptions = {};
        if (eventFlags.includes('p')) {
          eventOptions.passive = true;
        } else if (eventFlags.includes('P')) {
          eventOptions.passive = false;
        }
        if (eventFlags.includes('c')) {
          eventOptions.capture = true;
        } else if (eventFlags.includes('C')) {
          eventOptions.capture = false;
        }
        if (eventFlags.includes('o')) {
          eventOptions.once = true;
        } else if (eventFlags.includes('O')) {
          eventOptions.once = false;
        }
        switch (eventName) {
          case '_init':
            eventListener();
            break;
          case '_attach':
            this.nodesAttached.add(eventListener);
            break;
          case '_detach':
            this.nodesDetached.add(eventListener);
            break;
          default:
            tag.addEventListener(eventName, eventListener, eventOptions);
            this.onRemove(() => {
              tag.removeEventListener(eventName, eventListener, eventOptions);
            });
            break;
        }
        return [eventName, callbackName, argList];
      });
      tag.removeAttribute('cv-on');
      return tag;
    }
  }, {
    key: "mapLinkTag",
    value: function mapLinkTag(tag) {
      // const tagCompiler = this.compileLinkTag(tag);

      // const newTag = tagCompiler(this);

      // tag.replaceWith(newTag);

      // return newTag;

      var linkAttr = tag.getAttribute('cv-link');
      tag.setAttribute('href', linkAttr);
      var linkClick = event => {
        event.preventDefault();
        if (linkAttr.substring(0, 4) === 'http' || linkAttr.substring(0, 2) === '//') {
          globalThis.open(tag.getAttribute('href', linkAttr));
          return;
        }
        _Router.Router.go(tag.getAttribute('href'));
      };
      tag.addEventListener('click', linkClick);
      this.onRemove(((tag, eventListener) => () => {
        tag.removeEventListener('click', eventListener);
        tag = undefined;
        eventListener = undefined;
      })(tag, linkClick));
      tag.removeAttribute('cv-link');
      return tag;
    }

    // compileLinkTag(sourceTag)
    // {
    // 	const linkAttr = sourceTag.getAttribute('cv-link');
    // 	sourceTag.removeAttribute('cv-link');
    // 	return (bindingView) => {
    // 		const tag = sourceTag.cloneNode(true);
    // 		tag.setAttribute('href', linkAttr);
    // 		return tag;
    // 	};
    // }
  }, {
    key: "mapPrendererTag",
    value: function mapPrendererTag(tag) {
      var prerenderAttr = tag.getAttribute('cv-prerender');
      var prerendering = globalThis.prerenderer || navigator.userAgent.match(/prerender/i);
      tag.removeAttribute('cv-prerender');
      if (prerendering) {
        globalThis.prerenderer = globalThis.prerenderer || true;
      }
      if (prerenderAttr === 'never' && prerendering || prerenderAttr === 'only' && !prerendering) {
        this.postMapping.add(() => tag.parentNode.removeChild(tag));
      }
      return tag;
    }
  }, {
    key: "mapWithTag",
    value: function mapWithTag(tag) {
      var _this3 = this;
      var withAttr = tag.getAttribute('cv-with');
      var carryAttr = tag.getAttribute('cv-carry');
      var viewAttr = tag.getAttribute('cv-view');
      tag.removeAttribute('cv-with');
      tag.removeAttribute('cv-carry');
      tag.removeAttribute('cv-view');
      var viewClass = viewAttr ? this.stringToClass(viewAttr) : View;
      var subTemplate = new DocumentFragment();
      [...tag.childNodes].forEach(n => subTemplate.appendChild(n));
      var carryProps = [];
      if (carryAttr) {
        carryProps = carryAttr.split(',').map(s => s.trim());
      }
      var debind = this.args.bindTo(withAttr, (v, k, t, d) => {
        if (this.withViews.has(tag)) {
          this.withViews.delete(tag);
        }
        while (tag.firstChild) {
          tag.removeChild(tag.firstChild);
        }
        var view = new viewClass({}, this);
        this.onRemove((view => () => {
          view.remove();
        })(view));
        view.template = subTemplate;
        var _loop7 = function _loop7() {
          var debind = _this3.args.bindTo(carryProps[i], (v, k) => {
            view.args[k] = v;
          });
          view.onRemove(debind);
          _this3.onRemove(() => {
            debind();
            view.remove();
          });
        };
        for (var i in carryProps) {
          _loop7();
        }
        var _loop8 = function _loop8() {
          if (_typeof(v) !== 'object') {
            return "continue";
          }
          v = _Bindable.Bindable.make(v);
          var debind = v.bindTo(_i3, (vv, kk, tt, dd) => {
            if (!dd) {
              view.args[kk] = vv;
            } else if (kk in view.args) {
              delete view.args[kk];
            }
          });
          var debindUp = view.args.bindTo(_i3, (vv, kk, tt, dd) => {
            if (!dd) {
              v[kk] = vv;
            } else if (kk in v) {
              delete v[kk];
            }
          });
          _this3.onRemove(() => {
            debind();
            if (!v.isBound()) {
              _Bindable.Bindable.clearBindings(v);
            }
            view.remove();
          });
          view.onRemove(() => {
            debind();
            if (!v.isBound()) {
              _Bindable.Bindable.clearBindings(v);
            }
          });
        };
        for (var _i3 in v) {
          var _ret5 = _loop8();
          if (_ret5 === "continue") continue;
        }
        view.render(tag, null, this);
        this.withViews.set(tag, view);
      });
      this.onRemove(() => {
        this.withViews.delete(tag);
        debind();
      });
      return tag;
    }
  }, {
    key: "mapViewTag",
    value: function mapViewTag(tag) {
      var viewAttr = tag.getAttribute('cv-view');
      tag.removeAttribute('cv-view');
      var subTemplate = new DocumentFragment();
      [...tag.childNodes].forEach(n => subTemplate.appendChild(n));
      var parts = viewAttr.split(':');
      var viewName = parts.shift();
      var viewClass = parts.length ? this.stringToClass(parts[0]) : View;
      var view = new viewClass(this.args, this);
      this.views.set(tag, view);
      this.views.set(viewName, view);
      this.onRemove(() => {
        view.remove();
        this.views.delete(tag);
        this.views.delete(viewName);
      });
      view.template = subTemplate;
      view.render(tag, null, this);
      return tag;
    }
  }, {
    key: "mapEachTag",
    value: function mapEachTag(tag) {
      var eachAttr = tag.getAttribute('cv-each');
      var viewAttr = tag.getAttribute('cv-view');
      tag.removeAttribute('cv-each');
      tag.removeAttribute('cv-view');
      var viewClass = viewAttr ? this.stringToClass(viewAttr) : View;
      var subTemplate = new DocumentFragment();
      [...tag.childNodes].forEach(n => subTemplate.appendChild(n));
      var _eachAttr$split = eachAttr.split(':'),
        _eachAttr$split2 = _slicedToArray(_eachAttr$split, 3),
        eachProp = _eachAttr$split2[0],
        asProp = _eachAttr$split2[1],
        keyProp = _eachAttr$split2[2];
      var proxy = this.args;
      var property = eachProp;
      if (eachProp.match(/\./)) {
        var _Bindable$resolve11 = _Bindable.Bindable.resolve(this.args, eachProp, true);
        var _Bindable$resolve12 = _slicedToArray(_Bindable$resolve11, 2);
        proxy = _Bindable$resolve12[0];
        property = _Bindable$resolve12[1];
      }
      var debind = proxy.bindTo(property, (v, k, t, d, p) => {
        if (v instanceof _Bag.Bag) {
          v = v.list;
        }
        if (this.viewLists.has(tag)) {
          this.viewLists.get(tag).remove();
        }
        var viewList = new _ViewList.ViewList(subTemplate, asProp, v, this, keyProp, viewClass);
        var viewListRemover = () => viewList.remove();
        this.onRemove(viewListRemover);
        viewList.onRemove(() => this._onRemove.remove(viewListRemover));
        var debindA = this.args.bindTo((v, k, t, d) => {
          if (k === '_id') {
            return;
          }
          if (!d) {
            viewList.subArgs[k] = v;
          } else {
            if (k in viewList.subArgs) {
              delete viewList.subArgs[k];
            }
          }
        });
        var debindB = viewList.args.bindTo((v, k, t, d, p) => {
          if (k === '_id' || k === 'value' || String(k).substring(0, 3) === '___') {
            return;
          }
          if (!d) {
            if (k in this.args) {
              this.args[k] = v;
            }
          } else {
            delete this.args[k];
          }
        });
        viewList.onRemove(debindA);
        viewList.onRemove(debindB);
        this.onRemove(debindA);
        this.onRemove(debindB);
        while (tag.firstChild) {
          tag.removeChild(tag.firstChild);
        }
        this.viewLists.set(tag, viewList);
        viewList.render(tag, null, this);
      });
      this.onRemove(debind);
      return tag;
    }
  }, {
    key: "mapIfTag",
    value: function mapIfTag(tag) {
      var sourceTag = tag;
      var viewProperty = sourceTag.getAttribute('cv-view');
      var ifProperty = sourceTag.getAttribute('cv-if');
      var isProperty = sourceTag.getAttribute('cv-is');
      var inverted = false;
      var defined = false;
      sourceTag.removeAttribute('cv-view');
      sourceTag.removeAttribute('cv-if');
      sourceTag.removeAttribute('cv-is');
      var viewClass = viewProperty ? this.stringToClass(viewProperty) : View;
      if (ifProperty.substr(0, 1) === '!') {
        ifProperty = ifProperty.substr(1);
        inverted = true;
      }
      if (ifProperty.substr(0, 1) === '?') {
        ifProperty = ifProperty.substr(1);
        defined = true;
      }
      var subTemplate = new DocumentFragment();
      [...sourceTag.childNodes].forEach(n => subTemplate.appendChild(n));
      var bindingView = this;
      var ifDoc = new DocumentFragment();

      // let view = new viewClass(Object.assign({}, this.args), bindingView);
      var view = new viewClass(this.args, bindingView);
      view.tags.bindTo((v, k) => this.tags[k] = v, {
        removeWith: this
      });
      view.template = subTemplate;
      var proxy = bindingView.args;
      var property = ifProperty;
      if (ifProperty.match(/\./)) {
        var _Bindable$resolve13 = _Bindable.Bindable.resolve(bindingView.args, ifProperty, true);
        var _Bindable$resolve14 = _slicedToArray(_Bindable$resolve13, 2);
        proxy = _Bindable$resolve14[0];
        property = _Bindable$resolve14[1];
      }
      view.render(ifDoc, null, this);
      var propertyDebind = proxy.bindTo(property, (v, k) => {
        var o = v;
        if (defined) {
          v = v !== null && v !== undefined;
        }
        if (v instanceof _Bag.Bag) {
          v = v.list;
        }
        if (Array.isArray(v)) {
          v = !!v.length;
        }
        if (isProperty !== null) {
          v = o == isProperty;
        }
        if (inverted) {
          v = !v;
        }
        if (v) {
          tag.appendChild(ifDoc);
          [...ifDoc.childNodes].forEach(node => _Dom.Dom.mapTags(node, false, (tag, walker) => {
            if (!tag.matches) {
              return;
            }
            tag.dispatchEvent(new CustomEvent('cvDomAttached', {
              target: tag,
              detail: {
                view: view || this,
                mainView: this
              }
            }));
          }));
        } else {
          view.nodes.forEach(n => ifDoc.appendChild(n));
          _Dom.Dom.mapTags(ifDoc, false, (tag, walker) => {
            if (!tag.matches) {
              return;
            }
            new CustomEvent('cvDomDetached', {
              target: tag,
              detail: {
                view: view || this,
                mainView: this
              }
            });
          });
        }
      }, {
        children: Array.isArray(proxy[property])
      });

      // const propertyDebind = this.args.bindChain(property, onUpdate);

      bindingView.onRemove(propertyDebind);

      // const debindA = this.args.bindTo((v,k,t,d) => {
      // 	if(k === '_id')
      // 	{
      // 		return;
      // 	}

      // 	if(!d)
      // 	{
      // 		view.args[k] = v;
      // 	}
      // 	else if(k in view.args)
      // 	{
      // 		delete view.args[k];
      // 	}

      // });

      // const debindB = view.args.bindTo((v,k,t,d,p) => {
      // 	if(k === '_id' || String(k).substring(0,3) === '___')
      // 	{
      // 		return;
      // 	}

      // 	if(k in this.args)
      // 	{
      // 		if(!d)
      // 		{
      // 			this.args[k] = v;
      // 		}
      // 		else
      // 		{
      // 			delete this.args[k];
      // 		}
      // 	}
      // });

      var viewDebind = () => {
        propertyDebind();
        // debindA();
        // debindB();
        bindingView._onRemove.remove(propertyDebind);
        // bindingView._onRemove.remove(bindableDebind);
      };

      bindingView.onRemove(viewDebind);
      this.onRemove(() => {
        // debindA();
        // debindB();
        view.remove();
        if (bindingView !== this) {
          bindingView.remove();
        }
      });
      return tag;
    }

    // compileIfTag(sourceTag)
    // {
    // 	let ifProperty = sourceTag.getAttribute('cv-if');
    // 	let inverted   = false;

    // 	sourceTag.removeAttribute('cv-if');

    // 	if(ifProperty.substr(0, 1) === '!')
    // 	{
    // 		ifProperty = ifProperty.substr(1);
    // 		inverted   = true;
    // 	}

    // 	const subTemplate = new DocumentFragment;

    // 	[...sourceTag.childNodes].forEach(
    // 		n => subTemplate.appendChild(n.cloneNode(true))
    // 	);

    // 	return (bindingView) => {

    // 		const tag = sourceTag.cloneNode();

    // 		const ifDoc = new DocumentFragment;

    // 		let view = new View({}, bindingView);

    // 		view.template = subTemplate;
    // 		// view.parent   = bindingView;

    // 		bindingView.syncBind(view);

    // 		let proxy    = bindingView.args;
    // 		let property = ifProperty;

    // 		if(ifProperty.match(/\./))
    // 		{
    // 			[proxy, property] = Bindable.resolve(
    // 				bindingView.args
    // 				, ifProperty
    // 				, true
    // 			);
    // 		}

    // 		let hasRendered = false;

    // 		const propertyDebind = proxy.bindTo(property, (v,k) => {

    // 			if(!hasRendered)
    // 			{
    // 				const renderDoc = (bindingView.args[property] || inverted)
    // 					? tag : ifDoc;

    // 				view.render(renderDoc);

    // 				hasRendered = true;

    // 				return;
    // 			}

    // 			if(Array.isArray(v))
    // 			{
    // 				v = !!v.length;
    // 			}

    // 			if(inverted)
    // 			{
    // 				v = !v;
    // 			}

    // 			if(v)
    // 			{
    // 				tag.appendChild(ifDoc);
    // 			}
    // 			else
    // 			{
    // 				view.nodes.forEach(n=>ifDoc.appendChild(n));
    // 			}

    // 		});

    // 		// let cleaner = bindingView;

    // 		// while(cleaner.parent)
    // 		// {
    // 		// 	cleaner = cleaner.parent;
    // 		// }

    // 		bindingView.onRemove(propertyDebind);

    // 		let bindableDebind = () => {

    // 			if(!proxy.isBound())
    // 			{
    // 				Bindable.clearBindings(proxy);
    // 			}

    // 		};

    // 		let viewDebind = ()=>{
    // 			propertyDebind();
    // 			bindableDebind();
    // 			bindingView._onRemove.remove(propertyDebind);
    // 			bindingView._onRemove.remove(bindableDebind);
    // 		};

    // 		view.onRemove(viewDebind);

    // 		return tag;
    // 	};
    // }
  }, {
    key: "mapTemplateTag",
    value: function mapTemplateTag(tag) {
      // const templateName = tag.getAttribute('cv-template');

      // tag.removeAttribute('cv-template');

      // this.templates[ templateName ] = tag.tagName === 'TEMPLATE'
      // 	? tag.cloneNode(true).content
      // 	: new DocumentFragment(tag.innerHTML);

      var templateName = tag.getAttribute('cv-template');
      tag.removeAttribute('cv-template');
      var source = tag.innerHTML;
      if (!View.templates.has(source)) {
        View.templates.set(source, document.createRange().createContextualFragment(tag.innerHTML));
      }
      this.templates[templateName] = View.templates.get(source);
      this.postMapping.add(() => tag.remove());
      return tag;
    }
  }, {
    key: "mapSlotTag",
    value: function mapSlotTag(tag) {
      var templateName = tag.getAttribute('cv-slot');
      var template = this.templates[templateName];
      if (!template) {
        var parent = this;
        while (parent) {
          template = parent.templates[templateName];
          if (template) {
            break;
          }
          parent = this.parent;
        }
        if (!template) {
          console.error("Template ".concat(templateName, " not found."));
          return;
        }
      }
      tag.removeAttribute('cv-slot');
      while (tag.firstChild) {
        tag.firstChild.remove();
      }
      tag.appendChild(template.cloneNode(true));
      return tag;
    }

    // syncBind(subView)
    // {
    // 	let debindA = this.args.bindTo((v,k,t,d)=>{
    // 		if(k === '_id')
    // 		{
    // 			return;
    // 		}

    // 		if(subView.args[k] !== v)
    // 		{
    // 			subView.args[k] = v;
    // 		}
    // 	});

    // 	let debindB = subView.args.bindTo((v,k,t,d,p)=>{

    // 		if(k === '_id')
    // 		{
    // 			return;
    // 		}

    // 		let newRef = v;
    // 		let oldRef = p;

    // 		if(newRef instanceof View)
    // 		{
    // 			newRef = newRef.___ref___;
    // 		}

    // 		if(oldRef instanceof View)
    // 		{
    // 			oldRef = oldRef.___ref___;
    // 		}

    // 		if(newRef !== oldRef && oldRef instanceof View)
    // 		{
    // 			p.remove();
    // 		}

    // 		if(k in this.args)
    // 		{
    // 			this.args[k] = v;
    // 		}

    // 	});

    // 	this.onRemove(debindA);
    // 	this.onRemove(debindB);

    // 	subView.onRemove(()=>{
    // 		this._onRemove.remove(debindA);
    // 		this._onRemove.remove(debindB);
    // 	});
    // }
  }, {
    key: "postRender",
    value: function postRender(parentNode) {}
  }, {
    key: "attached",
    value: function attached(parentNode) {}
  }, {
    key: "interpolatable",
    value: function interpolatable(str) {
      return !!String(str).match(this.interpolateRegex);
    }
  }, {
    key: "remove",
    value: function remove(now = false) {
      if (!this.dispatchEvent(new CustomEvent('remove', {
        detail: {
          view: this
        },
        cancelable: true
      }))) {
        return;
      }
      var remover = () => {
        for (var i in this.tags) {
          if (Array.isArray(this.tags[i])) {
            this.tags[i] && this.tags[i].forEach(t => t.remove());
            this.tags[i].splice(0);
          } else {
            this.tags[i] && this.tags[i].remove();
            this.tags[i] = undefined;
          }
        }
        for (var _i4 in this.nodes) {
          this.nodes[_i4] && this.nodes[_i4].dispatchEvent(new Event('cvDomDetached'));
          this.nodes[_i4] && this.nodes[_i4].remove();
          this.nodes[_i4] = undefined;
        }
        this.nodes.splice(0);
        this.firstNode = this.lastNode = undefined;
      };
      if (now) {
        remover();
      } else {
        requestAnimationFrame(remover);
      }
      var callbacks = this._onRemove.items();
      for (var callback of callbacks) {
        callback();
        this._onRemove.remove(callback);
      }
      for (var cleanup of this.cleanup) {
        cleanup && cleanup();
      }
      this.cleanup.length = 0;
      for (var _ref21 of this.viewLists) {
        var _ref20 = _slicedToArray(_ref21, 2);
        var tag = _ref20[0];
        var viewList = _ref20[1];
        viewList.remove();
      }
      this.viewLists.clear();
      for (var _ref24 of this.timeouts) {
        var _ref23 = _slicedToArray(_ref24, 2);
        var _callback5 = _ref23[0];
        var timeout = _ref23[1];
        clearTimeout(timeout.timeout);
        this.timeouts.delete(timeout.timeout);
      }
      for (var interval of this.intervals) {
        clearInterval(interval);
      }
      this.intervals.length = 0;
      for (var frame of this.frames) {
        frame();
      }
      this.frames.length = 0;
      this.preRuleSet.purge();
      this.ruleSet.purge();
      this.removed = true;
      this.dispatchEvent(new CustomEvent('removed', {
        detail: {
          view: this
        },
        cancelable: true
      }));
    }
  }, {
    key: "findTag",
    value: function findTag(selector) {
      for (var i in this.nodes) {
        var result = void 0;
        if (!this.nodes[i].querySelector) {
          continue;
        }
        if (this.nodes[i].matches(selector)) {
          return new _Tag.Tag(this.nodes[i], this, undefined, undefined, this);
        }
        if (result = this.nodes[i].querySelector(selector)) {
          return new _Tag.Tag(result, this, undefined, undefined, this);
        }
      }
    }
  }, {
    key: "findTags",
    value: function findTags(selector) {
      var topLevel = this.nodes.filter(n => n.matches && n.matches(selector));
      var subLevel = this.nodes.filter(n => n.querySelectorAll).map(n => [...n.querySelectorAll(selector)]).flat().map(n => new _Tag.Tag(n, this, undefined, undefined, this)) || [];
      return topLevel.concat(subLevel);
    }
  }, {
    key: "onRemove",
    value: function onRemove(callback) {
      if (callback instanceof Event) {
        return;
      }
      this._onRemove.add(callback);
    }
  }, {
    key: "update",
    value: function update() {}
  }, {
    key: "beforeUpdate",
    value: function beforeUpdate(args) {}
  }, {
    key: "afterUpdate",
    value: function afterUpdate(args) {}
  }, {
    key: "stringTransformer",
    value: function stringTransformer(methods) {
      return x => {
        for (var m in methods) {
          var parent = this;
          var method = methods[m];
          while (parent && !parent[method]) {
            parent = parent.parent;
          }
          if (!parent) {
            return;
          }
          x = parent[methods[m]](x);
        }
        return x;
      };
    }
  }, {
    key: "stringToClass",
    value: function stringToClass(refClassname) {
      if (View.refClasses.has(refClassname)) {
        return View.refClasses.get(refClassname);
      }
      var refClassSplit = refClassname.split('/');
      var refShortClass = refClassSplit[refClassSplit.length - 1];
      var refClass = require(refClassname);
      View.refClasses.set(refClassname, refClass[refShortClass]);
      return refClass[refShortClass];
    }
  }, {
    key: "preventParsing",
    value: function preventParsing(node) {
      node[dontParse] = true;
    }
  }, {
    key: "toString",
    value: function toString() {
      return this.nodes.map(n => n.outerHTML).join(' ');
    }
  }, {
    key: "listen",
    value: function listen(node, eventName, callback, options) {
      if (typeof node === 'string') {
        options = callback;
        callback = eventName;
        eventName = node;
        node = this;
      }
      if (node instanceof View) {
        return this.listen(node.nodes, eventName, callback, options);
      }
      if (Array.isArray(node)) {
        return node.map(n => this.listen(n, eventName, callback, options));
        // .forEach(r => r());
      }

      if (node instanceof _Tag.Tag) {
        return this.listen(node.element, eventName, callback, options);
      }
      node.addEventListener(eventName, callback, options);
      var remove = () => node.removeEventListener(eventName, callback, options);
      var remover = () => {
        remove();
        remove = () => {};
      };
      this.onRemove(() => remover());
      return remover;
    }
  }, {
    key: "detach",
    value: function detach() {
      for (var n in this.nodes) {
        this.nodes[n].remove();
      }
      return this.nodes;
    }
  }], [{
    key: "from",
    value: function from(template, args = {}, mainView = null) {
      var view = new this(args, mainView);
      view.template = template;
      return view;
    }
  }, {
    key: "isView",
    value: function isView() {
      return View;
    }
  }, {
    key: "uuid",
    value: function uuid() {
      return new _Uuid.Uuid();
    }
  }]);
  return View;
}(_Mixin.Mixin.with(_EventTargetMixin.EventTargetMixin));
exports.View = View;
Object.defineProperty(View, 'templates', {
  value: new Map()
});
Object.defineProperty(View, 'refClasses', {
  value: new Map()
});
  })();
});

require.register("curvature/base/ViewList.js", function(exports, require, module) {
  require = __makeRelativeRequire(require, {}, "curvature");
  (function() {
    "use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ViewList = void 0;
var _Bindable = require("./Bindable");
var _SetMap = require("./SetMap");
var _Bag = require("./Bag");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var ViewList = /*#__PURE__*/function () {
  function ViewList(template, subProperty, list, parent, keyProperty = null, viewClass = null) {
    _classCallCheck(this, ViewList);
    this.removed = false;
    this.args = _Bindable.Bindable.makeBindable(Object.create(null));
    this.args.value = _Bindable.Bindable.makeBindable(list || Object.create(null));
    this.subArgs = _Bindable.Bindable.makeBindable(Object.create(null));
    this.views = [];
    this.cleanup = [];
    this.viewClass = viewClass;
    this._onRemove = new _Bag.Bag();
    this.template = template;
    this.subProperty = subProperty;
    this.keyProperty = keyProperty;
    this.tag = null;
    this.downDebind = [];
    this.upDebind = [];
    this.paused = false;
    this.parent = parent;
    this.viewCount = 0;
    this.rendered = new Promise((accept, reject) => {
      Object.defineProperty(this, 'renderComplete', {
        configurable: false,
        writable: true,
        value: accept
      });
    });
    this.willReRender = false;
    this.args.___before((t, e, s, o, a) => {
      if (e == 'bindTo') {
        return;
      }
      this.paused = true;
    });
    this.args.___after((t, e, s, o, a) => {
      if (e == 'bindTo') {
        return;
      }
      this.paused = s.length > 1;
      this.reRender();
    });
    var debind = this.args.value.bindTo((v, k, t, d) => {
      if (this.paused) {
        return;
      }
      var kk = k;
      if (_typeof(k) === 'symbol') {
        return;
      }
      if (isNaN(k)) {
        kk = '_' + k;
      }
      if (d) {
        if (this.views[kk]) {
          this.views[kk].remove(true);
        }
        delete this.views[kk];
        for (var i in this.views) {
          if (!this.views[i]) {
            continue;
          }
          if (isNaN(i)) {
            this.views[i].args[this.keyProperty] = i.substr(1);
            continue;
          }
          this.views[i].args[this.keyProperty] = i;
        }
      } else if (!this.views[kk]) {
        if (!this.viewCount) {
          this.reRender();
        } else {
          if (this.willReRender === false) {
            this.willReRender = requestAnimationFrame(() => {
              this.willReRender = false;
              this.reRender();
            });
          }
        }
      } else if (this.views[kk] && this.views[kk].args) {
        this.views[kk].args[this.keyProperty] = k;
        this.views[kk].args[this.subProperty] = v;
      }
    }, {
      wait: 0
    });
    this._onRemove.add(debind);
    Object.preventExtensions(this);
  }
  _createClass(ViewList, [{
    key: "render",
    value: function render(tag) {
      var _this = this;
      var renders = [];
      var _loop = function _loop(view) {
        view.viewList = _this;
        view.render(tag, null, _this.parent);
        renders.push(view.rendered.then(() => view));
      };
      for (var view of this.views) {
        _loop(view);
      }
      this.tag = tag;
      Promise.all(renders).then(views => this.renderComplete(views));
      this.parent.dispatchEvent(new CustomEvent('listRendered', {
        detail: {
          detail: {
            key: this.subProperty,
            value: this.args.value
          }
        }
      }));
    }
  }, {
    key: "reRender",
    value: function reRender() {
      var _this2 = this;
      if (this.paused || !this.tag) {
        return;
      }
      var views = [];
      var existingViews = new _SetMap.SetMap();
      for (var i in this.views) {
        var view = this.views[i];
        if (view === undefined) {
          views[i] = view;
          continue;
        }
        var rawValue = view.args[this.subProperty];
        existingViews.add(rawValue, view);
        views[i] = view;
      }
      var finalViews = [];
      var finalViewSet = new Set();
      this.downDebind.length && this.downDebind.forEach(d => d && d());
      this.upDebind.length && this.upDebind.forEach(d => d && d());
      this.upDebind.length = 0;
      this.downDebind.length = 0;
      var minKey = Infinity;
      var anteMinKey = Infinity;
      var _loop2 = function _loop2() {
        var found = false;
        var k = _i;
        if (isNaN(k)) {
          k = '_' + _i;
        } else if (String(k).length) {
          k = Number(k);
        }
        if (_this2.args.value[_i] !== undefined && existingViews.has(_this2.args.value[_i])) {
          var existingView = existingViews.getOne(_this2.args.value[_i]);
          if (existingView) {
            existingView.args[_this2.keyProperty] = _i;
            finalViews[k] = existingView;
            finalViewSet.add(existingView);
            found = true;
            if (!isNaN(k)) {
              minKey = Math.min(minKey, k);
              k > 0 && (anteMinKey = Math.min(anteMinKey, k));
            }
            existingViews.remove(_this2.args.value[_i], existingView);
          }
        }
        if (!found) {
          var viewArgs = Object.create(null);
          var _view = finalViews[k] = new _this2.viewClass(viewArgs, _this2.parent);
          if (!isNaN(k)) {
            minKey = Math.min(minKey, k);
            k > 0 && (anteMinKey = Math.min(anteMinKey, k));
          }
          finalViews[k].template = _this2.template;
          finalViews[k].viewList = _this2;
          finalViews[k].args[_this2.keyProperty] = _i;
          finalViews[k].args[_this2.subProperty] = _this2.args.value[_i];
          _this2.upDebind[k] = viewArgs.bindTo(_this2.subProperty, (v, k, t, d) => {
            var index = viewArgs[_this2.keyProperty];
            if (d) {
              delete _this2.args.value[index];
              return;
            }
            _this2.args.value[index] = v;
          });
          _this2.downDebind[k] = _this2.subArgs.bindTo((v, k, t, d) => {
            if (d) {
              delete viewArgs[k];
              return;
            }
            viewArgs[k] = v;
          });
          var upDebind = () => {
            _this2.upDebind.filter(x => x).forEach(d => d());
            _this2.upDebind.length = 0;
          };
          var downDebind = () => {
            _this2.downDebind.filter(x => x).forEach(d => d());
            _this2.downDebind.length = 0;
          };
          _view.onRemove(() => {
            _this2._onRemove.remove(upDebind);
            _this2._onRemove.remove(downDebind);
            _this2.upDebind[k] && _this2.upDebind[k]();
            _this2.downDebind[k] && _this2.downDebind[k]();
            delete _this2.upDebind[k];
            delete _this2.downDebind[k];
          });
          _this2._onRemove.add(upDebind);
          _this2._onRemove.add(downDebind);
          viewArgs[_this2.subProperty] = _this2.args.value[_i];
        }
      };
      for (var _i in this.args.value) {
        _loop2();
      }
      for (var _i2 in views) {
        if (views[_i2] && !finalViewSet.has(views[_i2])) {
          views[_i2].remove(true);
        }
      }
      if (Array.isArray(this.args.value)) {
        var localMin = minKey === 0 && finalViews[1] !== undefined && finalViews.length > 1 || anteMinKey === Infinity ? minKey : anteMinKey;
        var renderRecurse = (i = 0) => {
          var ii = finalViews.length - i - 1;
          while (ii > localMin && finalViews[ii] === undefined) {
            ii--;
          }
          if (ii < localMin) {
            return Promise.resolve();
          }
          if (finalViews[ii] === this.views[ii]) {
            if (finalViews[ii] && !finalViews[ii].firstNode) {
              finalViews[ii].render(this.tag, finalViews[ii + 1], this.parent);
              return finalViews[ii].rendered.then(() => renderRecurse(Number(i) + 1));
            } else {
              var split = 500;
              if (i === 0 || i % split) {
                return renderRecurse(Number(i) + 1);
              } else {
                return new Promise(accept => requestAnimationFrame(() => accept(renderRecurse(Number(i) + 1))));
              }
            }
          }
          finalViews[ii].render(this.tag, finalViews[ii + 1], this.parent);
          this.views.splice(ii, 0, finalViews[ii]);
          return finalViews[ii].rendered.then(() => renderRecurse(i + 1));
        };
        this.rendered = renderRecurse();
      } else {
        var renders = [];
        var leftovers = Object.assign(Object.create(null), finalViews);
        var isInt = x => parseInt(x) === x - 0;
        var keys = Object.keys(finalViews).sort((a, b) => {
          if (isInt(a) && isInt(b)) {
            return Math.sign(a - b);
          }
          if (!isInt(a) && !isInt(b)) {
            return 0;
          }
          if (!isInt(a) && isInt(b)) {
            return -1;
          }
          if (isInt(a) && !isInt(b)) {
            return 1;
          }
        });
        var _loop3 = function _loop3(_i3) {
          delete leftovers[_i3];
          if (finalViews[_i3].firstNode && finalViews[_i3] === _this2.views[_i3]) {
            return "continue";
          }
          finalViews[_i3].render(_this2.tag, null, _this2.parent);
          renders.push(finalViews[_i3].rendered.then(() => finalViews[_i3]));
        };
        for (var _i3 of keys) {
          var _ret = _loop3(_i3);
          if (_ret === "continue") continue;
        }
        for (var _i4 in leftovers) {
          delete this.args.views[_i4];
          leftovers.remove(true);
        }
        this.rendered = Promise.all(renders);
      }
      for (var _i5 in finalViews) {
        if (isNaN(_i5)) {
          finalViews[_i5].args[this.keyProperty] = _i5.substr(1);
          continue;
        }
        finalViews[_i5].args[this.keyProperty] = _i5;
      }
      this.views = Array.isArray(this.args.value) ? [...finalViews] : finalViews;
      this.viewCount = finalViews.length;
      finalViewSet.clear();
      this.willReRender = false;
      this.rendered.then(() => {
        this.parent.dispatchEvent(new CustomEvent('listRendered', {
          detail: {
            detail: {
              key: this.subProperty,
              value: this.args.value,
              tag: this.tag
            }
          }
        }));
        this.tag.dispatchEvent(new CustomEvent('listRendered', {
          detail: {
            detail: {
              key: this.subProperty,
              value: this.args.value,
              tag: this.tag
            }
          }
        }));
      });
      return this.rendered;
    }
  }, {
    key: "pause",
    value: function pause(_pause = true) {
      for (var i in this.views) {
        this.views[i].pause(_pause);
      }
    }
  }, {
    key: "onRemove",
    value: function onRemove(callback) {
      this._onRemove.add(callback);
    }
  }, {
    key: "remove",
    value: function remove() {
      for (var i in this.views) {
        this.views[i] && this.views[i].remove(true);
      }
      var onRemove = this._onRemove.items();
      for (var _i6 in onRemove) {
        this._onRemove.remove(onRemove[_i6]);
        onRemove[_i6]();
      }
      var cleanup;
      while (this.cleanup.length) {
        cleanup = this.cleanup.pop();
        cleanup();
      }
      this.views = [];
      while (this.tag && this.tag.firstChild) {
        this.tag.removeChild(this.tag.firstChild);
      }
      if (this.subArgs) {
        _Bindable.Bindable.clearBindings(this.subArgs);
      }
      _Bindable.Bindable.clearBindings(this.args);

      // if(this.args.value && !this.args.value.isBound())
      // {
      // 	Bindable.clearBindings(this.args.value);
      // }

      this.removed = true;
    }
  }]);
  return ViewList;
}();
exports.ViewList = ViewList;
  })();
});

require.register("curvature/input/Keyboard.js", function(exports, require, module) {
  require = __makeRelativeRequire(require, {}, "curvature");
  (function() {
    "use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Keyboard = void 0;
var _Bindable = require("../base/Bindable");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var Keyboard = /*#__PURE__*/function () {
  function Keyboard() {
    _classCallCheck(this, Keyboard);
    this.maxDecay = 120;
    this.comboTime = 500;
    this.listening = false;
    this.focusElement = document.body;
    this[_Bindable.Bindable.NoGetters] = true;
    Object.defineProperty(this, 'combo', {
      value: _Bindable.Bindable.make([])
    });
    Object.defineProperty(this, 'whichs', {
      value: _Bindable.Bindable.make({})
    });
    Object.defineProperty(this, 'codes', {
      value: _Bindable.Bindable.make({})
    });
    Object.defineProperty(this, 'keys', {
      value: _Bindable.Bindable.make({})
    });
    Object.defineProperty(this, 'pressedWhich', {
      value: _Bindable.Bindable.make({})
    });
    Object.defineProperty(this, 'pressedCode', {
      value: _Bindable.Bindable.make({})
    });
    Object.defineProperty(this, 'pressedKey', {
      value: _Bindable.Bindable.make({})
    });
    Object.defineProperty(this, 'releasedWhich', {
      value: _Bindable.Bindable.make({})
    });
    Object.defineProperty(this, 'releasedCode', {
      value: _Bindable.Bindable.make({})
    });
    Object.defineProperty(this, 'releasedKey', {
      value: _Bindable.Bindable.make({})
    });
    Object.defineProperty(this, 'keyRefs', {
      value: _Bindable.Bindable.make({})
    });
    document.addEventListener('keyup', event => {
      if (!this.listening) {
        return;
      }
      if (!(this.keys[event.key] > 0) && this.focusElement && document.activeElement !== this.focusElement && (!this.focusElement.contains(document.activeElement) || document.activeElement.matches('input,textarea'))) {
        return;
      }
      event.preventDefault();
      this.releasedWhich[event.which] = Date.now();
      this.releasedCode[event.code] = Date.now();
      this.releasedKey[event.key] = Date.now();
      this.whichs[event.which] = -1;
      this.codes[event.code] = -1;
      this.keys[event.key] = -1;
    });
    document.addEventListener('keydown', event => {
      if (!this.listening) {
        return;
      }
      if (this.focusElement && document.activeElement !== this.focusElement && (!this.focusElement.contains(document.activeElement) || document.activeElement.matches('input,textarea'))) {
        return;
      }
      event.preventDefault();
      if (event.repeat) {
        return;
      }
      this.combo.push(event.code);
      clearTimeout(this.comboTimer);
      this.comboTimer = setTimeout(() => this.combo.splice(0), this.comboTime);
      this.pressedWhich[event.which] = Date.now();
      this.pressedCode[event.code] = Date.now();
      this.pressedKey[event.key] = Date.now();
      if (this.keys[event.key] > 0) {
        return;
      }
      this.whichs[event.which] = 1;
      this.codes[event.code] = 1;
      this.keys[event.key] = 1;
    });
    var windowBlur = event => {
      for (var i in this.keys) {
        if (this.keys[i] < 0) {
          continue;
        }
        this.releasedKey[i] = Date.now();
        this.keys[i] = -1;
      }
      for (var _i in this.codes) {
        if (this.codes[_i] < 0) {
          continue;
        }
        this.releasedCode[_i] = Date.now();
        this.codes[_i] = -1;
      }
      for (var _i2 in this.whichs) {
        if (this.whichs[_i2] < 0) {
          continue;
        }
        this.releasedWhich[_i2] = Date.now();
        this.whichs[_i2] = -1;
      }
    };
    window.addEventListener('blur', windowBlur);
    window.addEventListener('visibilitychange', () => {
      if (document.visibilityState === 'visible') {
        return;
      }
      windowBlur();
    });
  }
  _createClass(Keyboard, [{
    key: "getKeyRef",
    value: function getKeyRef(keyCode) {
      var keyRef = this.keyRefs[keyCode] = this.keyRefs[keyCode] || _Bindable.Bindable.make({});
      return keyRef;
    }
  }, {
    key: "getKeyTime",
    value: function getKeyTime(key) {
      var released = this.releasedKey[key];
      var pressed = this.pressedKey[key];
      if (!pressed) {
        return 0;
      }
      if (!released || released < pressed) {
        return Date.now() - pressed;
      }
      return (Date.now() - released) * -1;
    }
  }, {
    key: "getCodeTime",
    value: function getCodeTime(code) {
      var released = this.releasedCode[code];
      var pressed = this.pressedCode[code];
      if (!pressed) {
        return 0;
      }
      if (!released || released < pressed) {
        return Date.now() - pressed;
      }
      return (Date.now() - released) * -1;
    }
  }, {
    key: "getWhichTime",
    value: function getWhichTime(code) {
      var released = this.releasedWhich[code];
      var pressed = this.pressedWhich[code];
      if (!pressed) {
        return 0;
      }
      if (!released || released < pressed) {
        return Date.now() - pressed;
      }
      return (Date.now() - released) * -1;
    }
  }, {
    key: "getKey",
    value: function getKey(key) {
      if (!this.keys[key]) {
        return 0;
      }
      return this.keys[key];
    }
  }, {
    key: "getKeyCode",
    value: function getKeyCode(code) {
      if (!this.codes[code]) {
        return 0;
      }
      return this.codes[code];
    }
  }, {
    key: "reset",
    value: function reset() {
      for (var i in this.keys) {
        delete this.keys[i];
      }
      for (var i in this.codes) {
        delete this.codes[i];
      }
      for (var i in this.whichs) {
        delete this.whichs[i];
      }
    }
  }, {
    key: "update",
    value: function update() {
      for (var i in this.keys) {
        if (this.keys[i] > 0) {
          this.keys[i]++;
        } else if (this.keys[i] > -this.maxDecay) {
          this.keys[i]--;
        } else {
          delete this.keys[i];
        }
      }
      for (var i in this.codes) {
        var released = this.releasedCode[i];
        var pressed = this.pressedCode[i];
        var keyRef = this.getKeyRef(i);
        if (this.codes[i] > 0) {
          keyRef.frames = this.codes[i]++;
          keyRef.time = pressed ? Date.now() - pressed : 0;
          keyRef.down = true;
          if (!released || released < pressed) {
            return;
          }
          return (Date.now() - released) * -1;
        } else if (this.codes[i] > -this.maxDecay) {
          keyRef.frames = this.codes[i]--;
          keyRef.time = released - Date.now();
          keyRef.down = false;
        } else {
          keyRef.frames = 0;
          keyRef.time = 0;
          keyRef.down = false;
          delete this.codes[i];
        }
      }
      for (var i in this.whichs) {
        if (this.whichs[i] > 0) {
          this.whichs[i]++;
        } else if (this.whichs[i] > -this.maxDecay) {
          this.whichs[i]--;
        } else {
          delete this.whichs[i];
        }
      }
    }
  }], [{
    key: "get",
    value: function get() {
      return this.instance = this.instance || _Bindable.Bindable.make(new this());
    }
  }]);
  return Keyboard;
}();
exports.Keyboard = Keyboard;
  })();
});

require.register("curvature/input/Sequence.js", function(exports, require, module) {
  require = __makeRelativeRequire(require, {}, "curvature");
  (function() {
    "use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Sequence = void 0;
var _Bindable = require("../base/Bindable");
var _Mixin = require("../base/Mixin");
var _EventTargetMixin = require("../mixin/EventTargetMixin");
var _Bindable$NoGetters;
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
_Bindable$NoGetters = _Bindable.Bindable.NoGetters;
var Sequence = /*#__PURE__*/function (_Mixin$with) {
  _inherits(Sequence, _Mixin$with);
  var _super = _createSuper(Sequence);
  function Sequence({
    callback: callback,
    keys: keys,
    timing: timing,
    gamepad: gamepad
  }) {
    var _this;
    _classCallCheck(this, Sequence);
    _this = _super.call(this);
    _defineProperty(_assertThisInitialized(_this), _Bindable$NoGetters, true);
    _defineProperty(_assertThisInitialized(_this), "lastTap", false);
    _defineProperty(_assertThisInitialized(_this), "recent", []);
    _defineProperty(_assertThisInitialized(_this), "callback", () => {});
    _defineProperty(_assertThisInitialized(_this), "timing", 500);
    _defineProperty(_assertThisInitialized(_this), "keys", '');
    var _ref = [callback, timing, keys, gamepad];
    _this.callback = _ref[0];
    _this.timing = _ref[1];
    _this.keys = _ref[2];
    _this.gamepad = _ref[3];
    return _this;
  }
  _createClass(Sequence, [{
    key: "check",
    value: function check(k) {
      var recent = this.recent;
      var now = Date.now();
      if (now + -this.lastTap > this.timing) {
        recent.splice(0);
      }
      recent.push({
        code: k,
        time: Date.now()
      });
      var current = recent.map(r => r.code).join(',');
      var konami = this.keys.join(',');
      this.lastTap = now;
      var matched = [];
      for (var i in recent) {
        var r = recent[i];
        var matchable = recent.slice(i);
        var chunk = matchable.map(r => r.code).join(',');
        if (chunk === konami.substr(0, chunk.length)) {
          matched.push(...matchable);
          this.dispatchEvent(new CustomEvent('advance', {
            detail: {
              matched: matched,
              recent: recent,
              keys: this.keys,
              length: matchable.length
            }
          }));
          break;
        }
      }
      if (!matched.length) {
        this.dispatchEvent(new CustomEvent('cancel', {
          detail: {
            matched: matched,
            recent: recent,
            keys: this.keys,
            length: matched.length
          }
        }));
        return;
      }
      if (konami === current.substr(-konami.length)) {
        this.dispatchEvent(new CustomEvent('complete', {
          detail: {
            matched: matched,
            recent: recent,
            keys: this.keys,
            length: matched.length
          }
        }));
      }
    }
  }]);
  return Sequence;
}(_Mixin.Mixin.with(_EventTargetMixin.EventTargetMixin));
exports.Sequence = Sequence;
  })();
});

require.register("curvature/mixin/EventTargetMixin.js", function(exports, require, module) {
  require = __makeRelativeRequire(require, {}, "curvature");
  (function() {
    "use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EventTargetMixin = void 0;
var _Mixin = require("../base/Mixin");
var _EventTargetMixin;
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
var EventTargetParent = Symbol('EventTargetParent');
var CallHandler = Symbol('CallHandler');
var Capture = Symbol('Capture');
var Bubble = Symbol('Bubble');
var Target = Symbol('Target');
var HandlersBubble = Symbol('HandlersBubble');
var HandlersCapture = Symbol('HandlersCapture');
var EventTargetMixin = (_EventTargetMixin = {}, _defineProperty(_EventTargetMixin, _Mixin.Mixin.Constructor, function () {
  this[HandlersCapture] = new Map();
  this[HandlersBubble] = new Map();
}), _defineProperty(_EventTargetMixin, "dispatchEvent", function dispatchEvent(...args) {
  var event = args[0];
  if (typeof event === 'string') {
    event = new CustomEvent(event);
    args[0] = event;
  }
  event.cvPath = event.cvPath || [];
  event.cvTarget = event.cvCurrentTarget = this;
  var result = this[Capture](...args);
  if (event.cancelable && (result === false || event.cancelBubble)) {
    return result;
  }
  var handlers = [];
  if (this[HandlersCapture].has(event.type)) {
    var handlerMap = this[HandlersCapture].get(event.type);
    var newHandlers = [...handlerMap];
    newHandlers.forEach(h => h.push(handlerMap));
    handlers.push(...newHandlers);
  }
  if (this[HandlersBubble].has(event.type)) {
    var _handlerMap = this[HandlersBubble].get(event.type);
    var _newHandlers = [..._handlerMap];
    _newHandlers.forEach(h => h.push(_handlerMap));
    handlers.push(..._newHandlers);
  }
  handlers.push([() => this[CallHandler](...args), {}, null]);
  for (var _ref3 of handlers) {
    var _ref2 = _slicedToArray(_ref3, 3);
    var handler = _ref2[0];
    var options = _ref2[1];
    var map = _ref2[2];
    if (options.once) {
      map.delete(handler);
    }
    result = handler(event);
    if (event.cancelable && result === false) {
      break;
    }
  }
  if (!event.cancelable || !event.cancelBubble && result !== false) {
    this[Bubble](...args);
  }
  if (!this[EventTargetParent]) {
    Object.freeze(event.cvPath);
  }
  return event.returnValue;
}), _defineProperty(_EventTargetMixin, "addEventListener", function addEventListener(type, callback, options = {}) {
  if (options === true) {
    options = {
      useCapture: true
    };
  }
  var handlers = HandlersBubble;
  if (options.useCapture) {
    handlers = HandlersCapture;
  }
  if (!this[handlers].has(type)) {
    this[handlers].set(type, new Map());
  }
  this[handlers].get(type).set(callback, options);
  if (options.signal) {
    options.signal.addEventListener('abort', event => this.removeEventListener(type, callback, options), {
      once: true
    });
  }
}), _defineProperty(_EventTargetMixin, "removeEventListener", function removeEventListener(type, callback, options = {}) {
  if (options === true) {
    options = {
      useCapture: true
    };
  }
  var handlers = HandlersBubble;
  if (options.useCapture) {
    handlers = HandlersCapture;
  }
  if (!this[handlers].has(type)) {
    return;
  }
  this[handlers].get(type).delete(callback);
}), _defineProperty(_EventTargetMixin, Capture, function (...args) {
  var event = args[0];
  event.cvPath.push(this);
  if (!this[EventTargetParent]) {
    return;
  }
  var result = this[EventTargetParent][Capture](...args);
  if (event.cancelable && (result === false || event.cancelBubble)) {
    return;
  }
  if (!this[EventTargetParent][HandlersCapture].has(event.type)) {
    return;
  }
  event.cvCurrentTarget = this[EventTargetParent];
  var type = event.type;
  var handlers = this[EventTargetParent][HandlersCapture].get(type);
  for (var _ref6 of handlers) {
    var _ref5 = _slicedToArray(_ref6, 2);
    var handler = _ref5[0];
    var options = _ref5[1];
    if (options.once) {
      handlers.delete(handler);
    }
    result = handler(event);
    if (event.cancelable && (result === false || event.cancelBubble)) {
      break;
    }
  }
  return result;
}), _defineProperty(_EventTargetMixin, Bubble, function (...args) {
  var event = args[0];
  if (!event.bubbles || !this[EventTargetParent] || event.cancelBubble) {
    return;
  }
  if (!this[EventTargetParent][HandlersBubble].has(event.type)) {
    return this[EventTargetParent][Bubble](...args);
  }
  var result;
  event.cvCurrentTarget = this[EventTargetParent];
  var type = event.type;
  var handlers = this[EventTargetParent][HandlersBubble].get(event.type);
  for (var _ref9 of handlers) {
    var _ref8 = _slicedToArray(_ref9, 2);
    var handler = _ref8[0];
    var options = _ref8[1];
    if (options.once) {
      handlers.delete(handler);
    }
    result = handler(event);
    if (event.cancelable && result === false) {
      return result;
    }
  }
  result = this[EventTargetParent][CallHandler](...args);
  if (event.cancelable && (result === false || event.cancelBubble)) {
    return result;
  }
  return this[EventTargetParent][Bubble](...args);
}), _defineProperty(_EventTargetMixin, CallHandler, function (...args) {
  var event = args[0];
  if (event.defaultPrevented) {
    return;
  }
  var defaultHandler = "on".concat(event.type[0].toUpperCase() + event.type.slice(1));
  if (typeof this[defaultHandler] === 'function') {
    return this[defaultHandler](event);
  }
}), _EventTargetMixin);
exports.EventTargetMixin = EventTargetMixin;
Object.defineProperty(EventTargetMixin, 'Parent', {
  value: EventTargetParent
});
  })();
});

require.register("curvature/mixin/PromiseMixin.js", function(exports, require, module) {
  require = __makeRelativeRequire(require, {}, "curvature");
  (function() {
    "use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PromiseMixin = void 0;
var _Mixin = require("../base/Mixin");
var _PromiseMixin;
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var _Promise = Symbol('Promise');
var Accept = Symbol('Accept');
var Reject = Symbol('Reject');
var PromiseMixin = (_PromiseMixin = {}, _defineProperty(_PromiseMixin, _Mixin.Mixin.Constructor, function () {
  this[_Promise] = new Promise((accept, reject) => {
    this[Accept] = accept;
    this[Reject] = reject;
  });
}), _defineProperty(_PromiseMixin, "then", function then(...args) {
  return this[_Promise].then(...args);
}), _defineProperty(_PromiseMixin, "catch", function _catch(...args) {
  return this[_Promise].catch(...args);
}), _defineProperty(_PromiseMixin, "finally", function _finally(...args) {
  return this[_Promise].finally(...args);
}), _PromiseMixin);
exports.PromiseMixin = PromiseMixin;
Object.defineProperty(PromiseMixin, 'Reject', {
  value: Reject
});
Object.defineProperty(PromiseMixin, 'Accept', {
  value: Accept
});
  })();
});

require.register("curvature/model/Database.js", function(exports, require, module) {
  require = __makeRelativeRequire(require, {}, "curvature");
  (function() {
    "use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Database = void 0;
var _Bindable = require("../base/Bindable");
var _Mixin = require("../base/Mixin");
var _EventTargetMixin = require("../mixin/EventTargetMixin");
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
var BeforeWrite = Symbol('BeforeWrite');
var AfterWrite = Symbol('AfterWrite');
var BeforeDelete = Symbol('BeforeDelete');
var AfterDelete = Symbol('AfterDelete');
var BeforeInsert = Symbol('BeforeInsert');
var AfterInsert = Symbol('AfterInsert');
var BeforeUpdate = Symbol('BeforeUpdate');
var AfterUpdate = Symbol('AfterUpdate');
var BeforeRead = Symbol('BeforeRead');
var AfterRead = Symbol('AfterRead');
var PrimaryKey = Symbol('PrimaryKey');
var Connection = Symbol('Connection');
var Instances = Symbol('Instances');
var HighWater = Symbol('HighWater');
var Metadata = Symbol('Metadata');
var Timers = Symbol('Timers');
var Target = Symbol('Target');
var Store = Symbol('Store');
var Fetch = Symbol('Each');
var Name = Symbol('Name');
var Bank = Symbol('Bank');
var Database = /*#__PURE__*/function (_Mixin$with) {
  _inherits(Database, _Mixin$with);
  var _super = _createSuper(Database);
  function Database(connection) {
    var _this;
    _classCallCheck(this, Database);
    _this = _super.call(this);
    Object.defineProperty(_assertThisInitialized(_this), Connection, {
      value: connection
    });
    Object.defineProperty(_assertThisInitialized(_this), Name, {
      value: connection.name
    });
    Object.defineProperty(_assertThisInitialized(_this), Timers, {
      value: {}
    });
    Object.defineProperty(_assertThisInitialized(_this), Metadata, {
      value: {}
    });
    Object.defineProperty(_assertThisInitialized(_this), Bank, {
      value: {}
    });
    return _this;
  }
  _createClass(Database, [{
    key: "select",
    value: function select({
      store: store,
      index: index,
      range = undefined,
      ranges = [],
      direction = 'next',
      limit = 0,
      offset = 0,
      type = false,
      origin = undefined,
      map = undefined
    }) {
      var transaction = this[Connection].transaction(store, "readonly");
      var storeObject = transaction.objectStore(store);
      var indexObject = index ? storeObject.index(index) : storeObject;
      if (range !== undefined && (!ranges || !ranges.length)) {
        ranges = [range];
      }
      var params = [type, indexObject, direction, ranges, limit, offset, origin, map];
      var existing = null;
      return {
        finally: c => (existing || (existing = this[Fetch](...params)(e => e))).finally(c),
        catch: c => (existing || (existing = this[Fetch](...params)(e => e))).catch(c),
        then: c => (existing || (existing = this[Fetch](...params)(e => e))).then(c),
        each: c => existing || (existing = this[Fetch](...params)(c)),
        one: c => existing || (existing = this[Fetch](...Object.assign(params, [,,,, 1]))(c))
      };
    }
  }, {
    key: "insert",
    value: function insert(storeName, records, origin = {}) {
      var inserts = this.inserts(_defineProperty({}, storeName, records), origin);
      return inserts[0];
    }
  }, {
    key: "inserts",
    value: function inserts(storesToRecords, origin = {}) {
      var _this2 = this;
      var storeNames = Object.keys(storesToRecords);
      var transaction = this[Connection].transaction(storeNames, 'readwrite');
      var inserts = [];
      var _loop = function _loop() {
        _ref2 = _slicedToArray(_ref3, 2);
        var storeName = _ref2[0];
        var records = _ref2[1];
        var store = transaction.objectStore(storeName);
        var bank = _this2[Bank][storeName] = _this2[Bank][storeName] || {};
        var list = true;
        if (!Array.isArray(records)) {
          records = [records];
          list = false;
        }
        var results = records.map(record => new Promise((accept, reject) => {
          record = _Bindable.Bindable.make(record);
          var detail = {
            database: _this2,
            record: record,
            store: storeName,
            type: 'write',
            subType: 'insert',
            origin: origin
          };
          detail.key = Database.getPrimaryKey(record);
          var cancelable = true;
          var writeEvent = new CustomEvent('write', {
            cancelable: cancelable,
            detail: detail
          });
          var eventResult = _this2.dispatchEvent(writeEvent);
          if (!eventResult) {
            transaction.abort && transaction.abort();
            return;
          }
          var beforeWriteResult = record[Database.BeforeWrite] ? record[Database.BeforeWrite](detail) : null;
          var beforeInsertResult = record[Database.BeforeInsert] ? record[Database.BeforeInsert](detail) : null;
          var request = store.add(Object.assign({}, _Bindable.Bindable.shuck(record)));
          if (beforeWriteResult === false || beforeInsertResult === false) {
            transaction.abort && transaction.abort();
            return;
          }
          request.onerror = error => {
            _this2.dispatchEvent(new CustomEvent('writeError', {
              detail: detail
            }));
            transaction.abort && transaction.abort();
            reject(error);
          };
          request.onsuccess = event => {
            var pk = event.target.result;
            transaction.addEventListener('complete', event => {
              if (store.autoIncrement) {
                record.id = pk;
              }
              record[Database.AfterInsert] && record[Database.AfterInsert](detail);
              record[Database.AfterWrite] && record[Database.AfterWrite](detail);
              bank[pk] = record;
              record[PrimaryKey] = Symbol.for(pk);
              accept(record);
              if (!_this2[Metadata][storeName]) {
                _this2[Metadata][storeName] = _this2.getStoreMeta(storeName, 'store', {});
              }
              if (_this2[Metadata][storeName]) {
                var currentHighMark = _this2.checkHighWaterMark(storeName, record);
                var currentLowMark = _this2.checkLowWaterMark(storeName, record);
                var metadata = _this2[Metadata][storeName];
                var recordMark = record[metadata.highWater];
                if (origin.setHighWater && currentHighMark < recordMark) {
                  _this2.setHighWaterMark(storeName, record, origin, 'insert');
                }
                if (origin.setLowWater && currentLowMark > recordMark) {
                  _this2.setLowWaterMark(storeName, record, origin, 'insert');
                }
              }
            });
          };
        }));
        var finalResult;
        if (list) {
          finalResult = Promise.all(results);
        } else {
          finalResult = results[0];
        }
        inserts.push(finalResult);
      };
      for (var _ref3 of Object.entries(storesToRecords)) {
        var _ref2;
        _loop();
      }

      // Promise.all(inserts).then(() => transaction.commit && transaction.commit());

      return inserts;
    }
  }, {
    key: "update",
    value: function update(storeName, record, origin = {}) {
      var updates = this.updates(_defineProperty({}, storeName, [record]), origin);
      return updates[0];
    }
  }, {
    key: "updates",
    value: function updates(storesToRecords, origin = {}) {
      var _this3 = this;
      var storeNames = Object.keys(storesToRecords);
      var transaction = this[Connection].transaction(storeNames, 'readwrite');
      var updates = [];
      var _loop2 = function _loop2() {
        _ref5 = _slicedToArray(_ref6, 2);
        var storeName = _ref5[0];
        var records = _ref5[1];
        var store = transaction.objectStore(storeName);
        var _loop3 = function _loop3(record) {
          if (!record[PrimaryKey]) {
            throw Error('Value provided is not a DB record!');
          }
          updates.push(new Promise((accept, reject) => {
            var detail = {
              database: _this3,
              key: Database.getPrimaryKey(record),
              record: record,
              store: storeName,
              type: 'write',
              subType: 'update',
              origin: origin
            };
            var cancelable = true;
            var writeEvent = new CustomEvent('write', {
              cancelable: cancelable,
              detail: detail
            });
            var eventResult = _this3.dispatchEvent(writeEvent);
            if (!eventResult) {
              transaction.abort && transaction.abort();
              return;
            }
            var beforeWriteResult = record[Database.BeforeWrite] ? record[Database.BeforeWrite](detail) : null;
            var beforeUpdateResult = record[Database.BeforeUpdate] ? record[Database.BeforeUpdate](detail) : null;
            if (beforeWriteResult === false || beforeUpdateResult === false) {
              transaction.abort && transaction.abort();
              return;
            }
            var requestA = store.delete(record.id);
            requestA.onerror = error => {
              _this3.dispatchEvent(new CustomEvent('writeError', {
                detail: detail
              }));
              reject(error);
            };
            requestA.onsuccess = event => {
              var requestB = store.put(Object.assign({}, _Bindable.Bindable.shuck(record)));
              requestB.onerror = error => {
                _this3.dispatchEvent(new CustomEvent('writeError', {
                  detail: detail
                }));
                reject(error);
              };
              requestB.onsuccess = event => {
                accept(writeEvent);
                transaction.oncomplete = event => {
                  record[Database.AfterInsert] && record[Database.AfterInsert](detail);
                  record[Database.AfterWrite] && record[Database.AfterWrite](detail);
                  if (!_this3[Metadata][storeName]) {
                    _this3[Metadata][storeName] = _this3.getStoreMeta(storeName, 'store', {});
                  }
                  if (_this3[Metadata][storeName]) {
                    var currentHighMark = _this3.checkHighWaterMark(storeName, record);
                    var currentLowMark = _this3.checkLowWaterMark(storeName, record);
                    var metadata = _this3[Metadata][storeName];
                    var recordMark = record[metadata.highWater];
                    if (origin.setHighWater && currentHighMark < recordMark) {
                      _this3.setHighWaterMark(storeName, record, origin, 'insert');
                    }
                    if (origin.setLowWater && currentLowMark > recordMark) {
                      _this3.setLowWaterMark(storeName, record, origin, 'insert');
                    }
                  }
                };
              };
            };
          }));
        };
        for (var record of records) {
          _loop3(record);
        }
      };
      for (var _ref6 of Object.entries(storesToRecords)) {
        var _ref5;
        _loop2();
      }
      Promise.all(updates).then(() => transaction.commit && transaction.commit());
      return updates;
    }
  }, {
    key: "delete",
    value: function _delete(storeName, record, origin = {}) {
      var deletes = this.deletes(_defineProperty({}, storeName, [record]), origin);
      return deletes[0];
    }
  }, {
    key: "deletes",
    value: function deletes(storesToRecords, origin = {}) {
      var _this4 = this;
      var storeNames = Object.keys(storesToRecords);
      var transaction = this[Connection].transaction(storeNames, 'readwrite');
      var deletes = [];
      var _loop4 = function _loop4() {
        _ref8 = _slicedToArray(_ref9, 2);
        var storeName = _ref8[0];
        var records = _ref8[1];
        var store = transaction.objectStore(storeName);
        var _loop5 = function _loop5(record) {
          if (!record[PrimaryKey]) {
            throw Error('Value provided is not a DB record!');
          }
          deletes.push(new Promise((accept, reject) => {
            var detail = {
              database: _this4,
              record: record,
              key: Database.getPrimaryKey(record),
              store: storeName,
              type: 'write',
              subType: 'delete',
              origin: origin
            };
            var cancelable = true;
            var writeEvent = new CustomEvent('write', {
              cancelable: cancelable,
              detail: detail
            });
            var eventResult = _this4.dispatchEvent(writeEvent);
            if (!eventResult) {
              transaction.abort && transaction.abort();
              return;
            }
            var beforeDeleteResult = record[Database.BeforeDelete] ? record[Database.BeforeDelete](detail) : null;
            if (beforeDeleteResult === false) {
              transaction.abort && transaction.abort();
              return;
            }
            var request = store.delete(record.id);
            request.onerror = error => {
              detail.original = error;
              var deleteEvent = new CustomEvent('writeError', {
                detail: detail
              });
              _this4.dispatchEvent(deleteEvent);
              reject(error);
            };
            request.onsuccess = event => {
              accept(writeEvent);
              transaction.oncomplete = event => {
                record[PrimaryKey] = undefined;
                record[Database.AfterDelete] && record[Database.AfterDelete](detail);
                detail.original = event;
              };
            };
          }));
        };
        for (var record of records) {
          _loop5(record);
        }
      };
      for (var _ref9 of Object.entries(storesToRecords)) {
        var _ref8;
        _loop4();
      }
      Promise.all(deletes).then(() => transaction.commit && transaction.commit());
      return deletes;
    }
  }, {
    key: "clear",
    value: function clear(storeName) {
      return new Promise((accept, reject) => {
        var trans = this[Connection].transaction([storeName], 'readwrite');
        var store = trans.objectStore(storeName);
        var request = store.clear();
        var detail = {
          database: this[Name],
          store: storeName,
          type: 'write',
          subType: 'clear',
          origin: origin
        };
        request.onerror = error => {
          detail.original = error;
          var deleteEvent = new CustomEvent('writeError', {
            detail: detail
          });
          this.dispatchEvent(deleteEvent);
          reject(error);
        };
        request.onsuccess = event => {
          detail.original = event;
          var writeEvent = new CustomEvent('write', {
            detail: detail
          });
          this.dispatchEvent(writeEvent);
          trans.commit && trans.commit();
          accept(writeEvent);
        };
      });
    }
  }, {
    key: "listStores",
    value: function listStores() {
      return [...this[Connection].objectStoreNames];
    }
  }, {
    key: "listIndexes",
    value: function listIndexes(storeName) {
      var trans = this[Connection].transaction([storeName]);
      var store = trans.objectStore(storeName);
      return [...store.indexNames];
    }
  }, {
    key: Fetch,
    value: function value(type, index, direction, ranges, limit, offset, origin, map) {
      var processRange = (range, callback) => new Promise((accept, reject) => {
        if (range instanceof IDBKeyRange) {
          // NOOP
        } else if (!Array.isArray(range)) {
          if (typeof range !== 'undefined' && range !== null) {
            range = IDBKeyRange.only(range);
          }
        } else if (range.length === 0) {
          range = undefined;
        } else if (range.length === 1) {
          range = IDBKeyRange.only(range[0]);
        } else {
          if (range[0] === undefined && range[1] === undefined) {
            range = undefined;
          } else if (range[0] === undefined) {
            var _range$;
            range = IDBKeyRange.upperBound(range[1], (_range$ = range[2]) !== null && _range$ !== void 0 ? _range$ : true);
          } else if (range[1] === undefined) {
            var _range$2;
            range = IDBKeyRange.lowerBound(range[0], (_range$2 = range[2]) !== null && _range$2 !== void 0 ? _range$2 : false);
          } else {
            var _range$3, _range$4;
            range = IDBKeyRange.bound(range[0], range[1], (_range$3 = range[2]) !== null && _range$3 !== void 0 ? _range$3 : false, (_range$4 = range[3]) !== null && _range$4 !== void 0 ? _range$4 : true);
          }
        }
        var request = index.openCursor(range, direction);
        var i = 0;
        var resultHandler = event => {
          var cursor = event.target.result;
          if (!cursor) {
            return accept({
              record: null,
              result: null,
              index: i
            });
          }
          var source = cursor.source;
          var storeName = source.objectStore ? source.objectStore.name : index.name;
          this[Bank][storeName] = this[Bank][storeName] || {};
          var bank = this[Bank][storeName];
          var pk = cursor.primaryKey;
          var value = type ? type.from(cursor.value) : cursor.value;
          var bindableValue = _Bindable.Bindable.makeBindable(value);
          var detail = {
            database: this[Name],
            key: Database.getPrimaryKey(bindableValue),
            record: value,
            store: index.name,
            type: 'read',
            subType: 'select',
            origin: origin
          };
          var beforeReadResult = value[Database.BeforeRead] ? value[Database.BeforeRead](detail) : null;
          if (offset > i++ || beforeReadResult === false) {
            return cursor.continue();
          }
          if (bank[pk]) {
            Object.assign(bank[pk], value);
          } else {
            value[PrimaryKey] = Symbol.for(pk);
            bank[pk] = value;
          }
          detail.record = value;
          bank[pk][Database.AfterRead] && bank[pk][Database.AfterRead](detail);
          var cancelable = true;
          var eventResult = this.dispatchEvent(new CustomEvent('read', {
            detail: detail,
            cancelable: cancelable
          }));
          if (eventResult) {
            var record = type ? type.from(bank[pk]) : bank[pk];
            record[PrimaryKey] = Symbol.for(pk);
            var mapped = map ? map(record) : record;
            var result = callback ? callback(mapped, i) : mapped;
            if (limit && i - offset >= limit) {
              offset += limit;
              return accept({
                mapped: mapped,
                result: result,
                index: i
              });
            }
          }
          cursor.continue();
        };
        request.addEventListener('success', resultHandler);
      });
      var results = [];
      ranges = ranges && ranges.length ? ranges.slice() : [[]];
      var processResult = (result, callback) => {
        results.push(result);
        if (ranges.length) {
          return processRange(ranges.shift(), callback).then(result => processResult(result, callback));
        }
        if (results.length === 1) {
          return results[0];
        }
        return results;
      };
      return callback => processRange(ranges.shift(), callback).then(result => processResult(result, callback));
    }
  }, {
    key: "getObjectStores",
    value: function getObjectStores(storeName) {
      return [...this[Connection].objectStoreNames];
    }
  }, {
    key: "getStoreIndexes",
    value: function getStoreIndexes(storeName) {
      var transaction = this[Connection].transaction([storeName], 'readonly');
      var storeObject = transaction.objectStore(storeName);
      var indexes = [...storeObject.indexNames];
      transaction.abort();
      return indexes;
    }
  }, {
    key: "setStoreMeta",
    value: function setStoreMeta(storeName, key, value) {
      localStorage.setItem("::::cvdb::".concat(storeName, "::").concat(key), JSON.stringify(value));
    }
  }, {
    key: "getStoreMeta",
    value: function getStoreMeta(storeName, key, notFound = null) {
      var source = localStorage.getItem("::::cvdb::".concat(storeName, "::").concat(key));
      var value = source !== null ? JSON.parse(source) : notFound;
      if (value === null) {
        return notFound;
      }
      return value;
    }
  }, {
    key: "createObjectStore",
    value: function createObjectStore(storeName, options) {
      var store = this[Connection].createObjectStore(storeName, options);
      this.setStoreMeta(storeName, 'store', options);
      return store;
    }
  }, {
    key: "deleteObjectStore",
    value: function deleteObjectStore(storeName) {
      return this[Connection].deleteObjectStore(storeName);
    }
  }, {
    key: "checkHighWaterMark",
    value: function checkHighWaterMark(storeName, record, origin = undefined) {
      var currentMark = this.getStoreMeta(storeName, 'highWater', 0);
      return currentMark;
    }
  }, {
    key: "setHighWaterMark",
    value: function setHighWaterMark(storeName, record, origin = undefined, subType = undefined) {
      var metadata = this[Metadata][storeName];
      var recordMark = record[metadata.highWater];
      var currentMark = this.getStoreMeta(storeName, 'highWater', 0);
      this.setStoreMeta(storeName, 'highWater', recordMark);
      this.dispatchEvent(new CustomEvent('highWaterMoved', {
        detail: {
          database: this[Name],
          record: record,
          store: storeName,
          type: 'highWaterMoved',
          subType: subType,
          origin: origin,
          oldValue: currentMark,
          value: recordMark
        }
      }));
    }
  }, {
    key: "checkLowWaterMark",
    value: function checkLowWaterMark(storeName, record, origin = undefined) {
      var currentMark = this.getStoreMeta(storeName, 'lowWater', Infinity);
      return currentMark;
    }
  }, {
    key: "setLowWaterMark",
    value: function setLowWaterMark(storeName, record, origin = undefined, subType = undefined) {
      var metadata = this[Metadata][storeName];
      var recordMark = record[metadata.highWater];
      var currentMark = this.getStoreMeta(storeName, 'lowWater', null);
      this.setStoreMeta(storeName, 'lowWater', recordMark);
      this.dispatchEvent(new CustomEvent('lowWaterMoved', {
        detail: {
          database: this[Name],
          record: record,
          store: storeName,
          type: 'lowWaterMoved',
          subType: subType,
          origin: origin,
          oldValue: currentMark,
          value: recordMark
        }
      }));
    }
  }], [{
    key: "open",
    value: function open(dbName, version = 0) {
      if (this[Instances][dbName]) {
        return this[Instances][dbName];
      }
      return this[Instances][dbName] = new Promise((accept, reject) => {
        var request = indexedDB.open(dbName, version);
        request.onerror = error => {
          Database.dispatchEvent(new CustomEvent('error', {
            detail: {
              database: this[Name],
              error: error,
              store: undefined,
              type: 'read',
              subType: 'select'
            }
          }));
          reject(error);
        };
        request.onsuccess = event => {
          var instance = new this(event.target.result);
          accept(instance);
        };
        request.onupgradeneeded = event => {
          var connection = event.target.result;
          connection.addEventListener('error', error => console.error(error));
          var instance = new this(connection);
          for (var v = event.oldVersion + 1; v <= version; v += 1) {
            instance['_version_' + v](connection, instance, event);
          }
        };
      });
    }
  }, {
    key: "getPrimaryKey",
    value: function getPrimaryKey(record) {
      return record[PrimaryKey] ? record[PrimaryKey] : null;
    }
  }, {
    key: "destroyDatabase",
    value: function destroyDatabase() {
      return new Promise((accept, reject) => {
        var request = indexedDB.delete(dbName);
        request.onerror = error => {
          Database.dispatchEvent(new CustomEvent('error', {
            detail: {
              database: dbName,
              error: error,
              type: 'destroy'
            }
          }));
          reject(error);
        };
        request.onsuccess = event => {
          delete this[Instances][dbName];
          accept(dbName);
        };
      });
    }
  }]);
  return Database;
}(_Mixin.Mixin.with(_EventTargetMixin.EventTargetMixin));
exports.Database = Database;
Object.defineProperty(Database, Instances, {
  value: []
});
Object.defineProperty(Database, 'BeforeDelete', {
  value: BeforeDelete
});
Object.defineProperty(Database, 'AfterDelete', {
  value: AfterDelete
});
Object.defineProperty(Database, 'BeforeWrite', {
  value: BeforeWrite
});
Object.defineProperty(Database, 'AfterWrite', {
  value: AfterWrite
});
Object.defineProperty(Database, 'BeforeInsert', {
  value: BeforeInsert
});
Object.defineProperty(Database, 'AfterInsert', {
  value: AfterInsert
});
Object.defineProperty(Database, 'BeforeUpdate', {
  value: BeforeUpdate
});
Object.defineProperty(Database, 'AfterUpdate', {
  value: AfterUpdate
});
Object.defineProperty(Database, 'BeforeRead', {
  value: BeforeRead
});
Object.defineProperty(Database, 'AfterRead', {
  value: AfterRead
});
Object.defineProperty(Database, 'PKSymbol', {
  value: PrimaryKey
});
Object.defineProperty(Database, 'PrimaryKey', {
  value: PrimaryKey
});
try {
  Object.defineProperty(Database, Target, {
    value: new EventTarget()
  });
} catch (error) {
  Object.defineProperty(Database, Target, {
    value: document.createDocumentFragment()
  });
}
var _loop6 = function _loop6(method) {
  Object.defineProperty(Database, method, {
    value: (...args) => Database[Target][method](...args)
  });
};
for (var method of ['addEventListener', 'removeEventListener', 'dispatchEvent']) {
  _loop6(method);
}
  })();
});

require.register("curvature/model/Model.js", function(exports, require, module) {
  require = __makeRelativeRequire(require, {}, "curvature");
  (function() {
    "use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Model = void 0;
var _Cache = require("../base/Cache");
var _Bindable = require("../base/Bindable");
var _Database = require("./Database");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var Changed = Symbol('Changed');
var Deleted = Symbol('Deleted');
var Saved = Symbol('Saved');
var Keys = Symbol('Keys');
var Model = /*#__PURE__*/function () {
  function Model() {
    _classCallCheck(this, Model);
    _defineProperty(this, "id", void 0);
    _defineProperty(this, "class", void 0);
    Object.defineProperty(this, Changed, {
      value: _Bindable.Bindable.make({})
    });
    Object.defineProperty(this, Deleted, {
      writable: true,
      value: false
    });
    Object.defineProperty(this, Saved, {
      writable: true,
      value: false
    });
    Object.defineProperty(this, Keys, {
      writable: true,
      value: new Set()
    });
    return _Bindable.Bindable.make(this);
  }
  _createClass(Model, [{
    key: "consume",
    value: function consume(skeleton, override = false) {
      var keyProps = Model.keyProps;
      var setProp = (property, value) => {
        if (value && _typeof(value) === 'object' && value.constructor.keyProps) {
          var subKeyProps = value.constructor.keyProps;
          var propCacheKey = subKeyProps.map(prop => value[prop]).join('::');
          var bucket = 'models-by-type-and-publicId';
          var propCached = _Cache.Cache.load(propCacheKey, false, bucket);
          if (propCached) {
            propCached.consume(value);
            value = propCached;
          }
        }
        if (!override && this[Changed][property]) {
          return;
        }
        this[property] = value;
      };
      if (_Database.Database.PKSymbol in skeleton) {
        setProp(_Database.Database.PKSymbol, skeleton[_Database.Database.PKSymbol]);
      }
      this[Keys] = new Set([...this[Keys], ...Object.keys(this), ...Object.keys(skeleton)]);
      for (var property of this[Keys]) {
        if (!override && this[Changed][property]) {
          continue;
        }
        if (keyProps.includes(property)) {
          continue;
        }
        if (property in skeleton) {
          setProp(property, skeleton[property]);
        }
      }
    }
  }, {
    key: "changed",
    value: function changed() {
      this[Saved] = false;
    }
  }, {
    key: "markDeleted",
    value: function markDeleted() {
      for (var property in this[Changed]) {
        this[Changed][property] = false;
      }
      this[Deleted] = true;
      this[Saved] = false;
    }
  }, {
    key: "markStored",
    value: function markStored() {
      for (var property in this) {
        this[Changed][property] = false;
      }
      this[Deleted] = false;
      this[Saved] = true;
    }
  }, {
    key: "isSaved",
    value: function isSaved() {
      return this[Saved];
    }
  }], [{
    key: "keyProps",
    get: function get() {
      return ['id', 'class'];
    }
  }, {
    key: "from",
    value: function from(skeleton, isSaved = false) {
      var keyProps = this.keyProps;
      var cacheProps = keyProps.map(prop => skeleton[prop]);
      cacheProps.unshift(this.name);
      var cacheKey = cacheProps.join('::');
      var bucket = 'models-by-type-and-publicId';
      var cached = _Cache.Cache.load(cacheKey, false, bucket);
      var instance = cached ? cached : new this();
      for (var keyProp of keyProps) {
        var _ref, _instance$keyProp;
        instance[keyProp] = (_ref = (_instance$keyProp = instance[keyProp]) !== null && _instance$keyProp !== void 0 ? _instance$keyProp : skeleton[keyProp]) !== null && _ref !== void 0 ? _ref : null;
      }
      instance.consume(skeleton);
      if (!cached) {
        _Cache.Cache.store(cacheKey, instance, 0, bucket);
        var changed = false;
        instance.bindTo((v, k, t, d) => {
          if (_typeof(k) === 'symbol') {
            return;
          }
          if (v === t[k]) {
            return;
          }
          instance[Changed][k] = changed;
          instance[Saved] = !!(changed ? false : instance[Saved]);
        });
        if (Object.keys(instance[Changed]).length === 0) {
          instance[Saved] = isSaved;
        }
        changed = true;
      }
      return instance;
    }
  }]);
  return Model;
}();
exports.Model = Model;
Object.defineProperty(Model, 'Changed', {
  value: Changed
});
Object.defineProperty(Model, 'Deleted', {
  value: Deleted
});
Object.defineProperty(Model, 'Saved', {
  value: Saved
});
  })();
});

require.register("curvature/net/Elicit.js", function(exports, require, module) {
  require = __makeRelativeRequire(require, {}, "curvature");
  (function() {
    "use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Elicit = void 0;
var _Mixin = require("curvature/base/Mixin");
var _EventTargetMixin = require("curvature/mixin/EventTargetMixin");
var _PromiseMixin = require("curvature/mixin/PromiseMixin");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var IterateDownload = Symbol('IterateDownload');
var Retry = Symbol('Retry');
var HandleFirstByte = Symbol('HandleFirstByte');
var HandleProgress = Symbol('HandleProgress');
var HandleComplete = Symbol('HandleComplete');
var HandleHeaders = Symbol('HandleHeaders');
var HandleClose = Symbol('HandleClose');
var HandleError = Symbol('HandleError');
var HandleOpen = Symbol('HandleOpen');
var HandleFail = Symbol('HandleFail');
var FetchDeferrer = Symbol('FetchDeferrer');
var LastChunkSize = Symbol('LastChunkSize');
var LastChunkTime = Symbol('LastChunkTime');
var Options = Symbol('Options');
var Fetch = Symbol('Fetch');
var Type = Symbol('Type');
var Url = Symbol('Url');
var RetriesLeft = Symbol('RetriesLeft');
var TimeoutLeft = Symbol('TimeoutLeft');
var Timeout = Symbol('Timeout');
var Timer = Symbol('Timer');
var Canceller = Symbol('Canecller');
var Cancelled = Symbol('Caneclled');
var Paused = Symbol('Paused');
var Received = Symbol('Received');
var Length = Symbol('Length');
var Opened = Symbol('Opened');
var Closed = Symbol('Closed');
var Start = Symbol('Start');
var First = Symbol('First');
var End = Symbol('End');
var Elicit = /*#__PURE__*/function (_Mixin$with) {
  _inherits(Elicit, _Mixin$with);
  var _super = _createSuper(Elicit);
  function Elicit(url, options = {}) {
    var _this2;
    _classCallCheck(this, Elicit);
    _this2 = _super.call(this);
    _this2[RetriesLeft] = options.retries || 5;
    _this2[Timeout] = options.timeout || 4500;
    _this2[TimeoutLeft] = options.maxTimeout || _this2[Timeout] * _this2[RetriesLeft];
    _this2[FetchDeferrer] = null;
    _this2[LastChunkTime] = 0;
    _this2[LastChunkSize] = 0;
    _this2[Cancelled] = false;
    _this2[Received] = 0;
    _this2[Paused] = false;
    _this2[Closed] = 0;
    _this2[Options] = Object.assign({}, options);
    _this2[Url] = url;
    if (!options.defer) {
      _this2.open();
    } else {
      _this2[Fetch] = new Promise(accept => _this2[FetchDeferrer] = accept);
    }
    return _this2;
  }
  _createClass(Elicit, [{
    key: "open",
    value: function open() {
      if (this[Opened] && !this[Closed]) {
        return;
      }
      if (!this[Start]) {
        this[Start] = Date.now();
      }
      this[Canceller] = new AbortController();
      this[Options].signal = this[Canceller].signal;
      this[Opened] = Date.now();
      this[Closed] = 0;
      this[First] = 0;
      this[Fetch] = fetch(this[Url], this[Options]).then(response => this[HandleOpen](response)).catch(error => this[HandleError](error));
      var onTimeout = () => {
        if (!this[First]) {
          this[Canceller].abort();
          this[HandleClose]();
          this[TimeoutLeft] = Math.max(0, this[TimeoutLeft] - this[Timeout]);
          if (this[TimeoutLeft]) {
            return;
          }
          this[HandleFail](new Error('Timed out.'));
        }
      };
      this[Timer] = setTimeout(onTimeout, this[Timeout]);
    }
  }, {
    key: "headers",
    value: function headers() {
      return this[Fetch].then(({
        response: response,
        stream: stream
      }) => response.headers);
    }
  }, {
    key: "json",
    value: function json() {
      return this[Fetch].then(({
        response: response,
        stream: stream
      }) => {
        var wrapped = new Response(stream, {
          headers: {
            'Content-Type': 'application/json'
          }
        });
        return wrapped.json();
      });
    }
  }, {
    key: "text",
    value: function text() {
      return this[Fetch].then(({
        response: response,
        stream: stream
      }) => {
        var wrapped = new Response(stream, {
          headers: {
            'Content-Type': this.type
          }
        });
        return wrapped.text();
      });
    }
  }, {
    key: "css",
    value: function css() {
      return this.text().then(css => {
        var sheet = new CSSStyleSheet();
        sheet.replace(css);
        return sheet;
      });
    }
  }, {
    key: "blob",
    value: function blob() {
      return this[Fetch].then(({
        response: response,
        stream: stream
      }) => {
        var wrapped = new Response(stream, {
          headers: {
            'Content-Type': response.headers.get('Content-Type')
          }
        });
        return wrapped.blob();
      });
    }
  }, {
    key: "objectUrl",
    value: function objectUrl() {
      return this.blob().then(blob => URL.createObjectURL(blob));
    }
  }, {
    key: "dataUri",
    value: function dataUri() {
      return this.blob().then(blob => new Promise((accept, reject) => {
        var reader = new FileReader();
        reader.onload = event => accept(reader.result);
        reader.onerror = event => reject(reader.error);
        reader.onabort = event => reject(new Error("Read aborted"));
        reader.readAsDataURL(blob);
      }));
    }
  }, {
    key: "buffer",
    value: function buffer() {
      return this[Fetch].then(({
        response: response,
        stream: stream
      }) => {
        var wrapped = new Response(stream, {
          headers: {
            'Content-Type': response.headers.get('Content-Type')
          }
        });
        return wrapped.arrayBuffer();
      });
    }
  }, {
    key: "bytes",
    value: function bytes() {
      return this.buffer().then(buffer => new Uint8Array(buffer));
    }
  }, {
    key: "cancel",
    value: function cancel() {
      if (!this.emitCancelEvent()) {
        return;
      }
      this[Canceller].abort();
      this[Cancelled] = true;
      this.emitCancelledEvent();
    }
  }, {
    key: "pause",
    value: function pause() {
      if (this[End] || this[Paused] || this[Closed]) {
        return;
      }
      if (!this.emitPauseEvent()) {
        return;
      }
      this[Paused] = true;
      this.emitPausedEvent();
    }
  }, {
    key: "unpause",
    value: function unpause() {
      if (this[End] || !this[Paused]) {
        return;
      }
      if (!this.emitUnpauseEvent()) {
        return;
      }
      this[Paused] = false;
      this.emitUnpausedEvent();
    }
  }, {
    key: "done",
    get: function get() {
      return !!this[End];
    }
  }, {
    key: "type",
    get: function get() {
      return this[Type];
    }
  }, {
    key: "totalTime",
    get: function get() {
      if (!this[End]) {
        return Date.now() - this[Start];
      }
      return this[End] - this[Start];
    }
  }, {
    key: "waitTime",
    get: function get() {
      if (!this[First]) {
        return Date.now() - this[Opened];
      }
      return this[First] - this[Opened];
    }
  }, {
    key: "loadTime",
    get: function get() {
      if (!this[Opened]) {
        return 0;
      }
      if (!this[Closed]) {
        return Date.now() - this[First];
      }
      return this[Closed] - this[First];
    }
  }, {
    key: "speed",
    get: function get() {
      if (!this[Opened]) {
        return 0;
      }
      var time;
      if (this[End]) {
        time = this[End] - this[LastChunkTime];
      } else {
        time = Date.now() - this[LastChunkTime];
      }
      if (!time) {
        time = 0.01;
      }
      return this[LastChunkSize] / time;
    }
  }, {
    key: "received",
    get: function get() {
      return this[Received];
    }
  }, {
    key: "length",
    get: function get() {
      return this[Length];
    }
  }, {
    key: "isPaused",
    get: function get() {
      return this[Paused];
    }
  }, {
    key: IterateDownload,
    value: function value(reader, controller, length) {
      this[HandleProgress](length, 0, null);
      var lastTime = Date.now();
      var lastSize = 1;
      var handleChunk = ({
        done: done,
        value: value
      }) => {
        if (done) {
          controller.close();
          return this[HandleComplete]();
        }
        controller.enqueue(value);
        this[Received] += value.length;
        if (!this[First]) {
          this[HandleFirstByte](value);
        }
        this[HandleProgress](length, this[Received], value);
        this[LastChunkTime] = lastTime;
        this[LastChunkSize] = lastSize;
        lastTime = Date.now();
        lastSize = value.length;
        return iterate();
      };
      var iterate = () => {
        if (this[Cancelled]) {
          return reader.cancel();
        }
        if (this[Paused]) {
          return new Promise(accept => {
            setTimeout(() => accept(iterate()), 100);
          });
        }
        return reader.read().then(chunk => handleChunk(chunk)).catch(error => this[HandleError](error));
      };
      return iterate();
    }
  }, {
    key: Retry,
    value: function value() {
      if (!this.emitRetryEvent()) {
        return;
      }
      if (this[RetriesLeft] <= 0) {
        return;
      }
      this[Canceller].abort();
      this[HandleClose]();
      this[Received] = 0;
      this[RetriesLeft]--;
      return this.open();
    }
  }, {
    key: HandleOpen,
    value: function value(response) {
      var reader = response.body.getReader();
      var length = this[Length] || Number(response.headers.get('Content-Length'));
      var type = this[type] || response.headers.get('Content-Type');
      this[Length] = length;
      this[Type] = type;
      this[HandleHeaders](response.headers);
      if (this[FetchDeferrer]) {
        this[FetchDeferrer](this[Fetch]);
      }
      var _this = this;
      var stream = new ReadableStream({
        start: function start(controller) {
          _this[IterateDownload](reader, controller, length);
        }
      });
      return {
        response: response,
        stream: stream
      };
    }
  }, {
    key: HandleClose,
    value: function value() {
      this[Closed] = Date.now();
      this.emitCloseEvent();
    }
  }, {
    key: HandleHeaders,
    value: function value(headers) {
      this.emitHeadersEvent(headers);
    }
  }, {
    key: HandleProgress,
    value: function value(length, received, _value) {
      this.emitProgressEvent(length, received, _value);
    }
  }, {
    key: HandleComplete,
    value: function value() {
      this[End] = Date.now();
      this[HandleClose]();
      this.emitCompleteEvent();
      this[_PromiseMixin.PromiseMixin.Accept]();
    }
  }, {
    key: HandleError,
    value: function value(error) {
      console.warn("[".concat(error.constructor.name, "] ").concat(error.code, ": ").concat(error.message), error);
      if (!this.emitErrorEvent(error)) {
        return this[Retry]();
      }
      return this[HandleFail](error);
    }
  }, {
    key: HandleFail,
    value: function value(error) {
      this[End] = Date.now();
      this[HandleClose]();
      this.emitFailEvent(error);
      return this[_PromiseMixin.PromiseMixin.Reject](error);
    }
  }, {
    key: HandleFirstByte,
    value: function value(received) {
      clearInterval(this[Timer]);
      this[First] = Date.now();
      this.emitFirstByteEvent(received);
    }
  }, {
    key: "emitProgressEvent",
    value: function emitProgressEvent(length, received, value) {
      var done = length ? received / length : 0;
      var totalTime = this.totalTime;
      var loadTime = this.loadTime;
      var waitTime = this.waitTime;
      var speed = this.speed;
      return this.dispatchEvent(new CustomEvent('progress', {
        detail: {
          length: length,
          received: received,
          done: done,
          speed: speed,
          loadTime: loadTime,
          waitTime: waitTime,
          totalTime: totalTime,
          value: value
        }
      }));
    }
  }, {
    key: "emitOpenEvent",
    value: function emitOpenEvent() {
      return this.dispatchEvent(new CustomEvent('open'));
    }
  }, {
    key: "emitCloseEvent",
    value: function emitCloseEvent() {
      return this.dispatchEvent(new CustomEvent('close'));
    }
  }, {
    key: "emitFirstByteEvent",
    value: function emitFirstByteEvent(received) {
      return this.dispatchEvent(new CustomEvent('firstByte', {
        detail: {
          received: received
        }
      }));
    }
  }, {
    key: "emitHeadersEvent",
    value: function emitHeadersEvent(headers) {
      return this.dispatchEvent(new CustomEvent('headers', {
        detail: {
          headers: headers
        }
      }));
    }
  }, {
    key: "emitCompleteEvent",
    value: function emitCompleteEvent() {
      return this.dispatchEvent(new CustomEvent('complete'));
    }
  }, {
    key: "emitErrorEvent",
    value: function emitErrorEvent() {
      return this.dispatchEvent(new CustomEvent('error', {
        cancelable: this[RetriesLeft] > 0
      }));
    }
  }, {
    key: "emitRetryEvent",
    value: function emitRetryEvent() {
      return this.dispatchEvent(new CustomEvent('retry', {
        cancelable: true
      }));
    }
  }, {
    key: "emitFailEvent",
    value: function emitFailEvent() {
      return this.dispatchEvent(new CustomEvent('fail'));
    }
  }, {
    key: "emitPauseEvent",
    value: function emitPauseEvent() {
      return this.dispatchEvent(new CustomEvent('pause', {
        cancelable: true
      }));
    }
  }, {
    key: "emitPausedEvent",
    value: function emitPausedEvent() {
      this.dispatchEvent(new CustomEvent('paused'));
    }
  }, {
    key: "emitUnpauseEvent",
    value: function emitUnpauseEvent() {
      return this.dispatchEvent(new CustomEvent('unpause', {
        cancelable: true
      }));
    }
  }, {
    key: "emitUnpausedEvent",
    value: function emitUnpausedEvent() {
      this.dispatchEvent(new CustomEvent('unpaused'));
    }
  }, {
    key: "emitCancelEvent",
    value: function emitCancelEvent() {
      return this.dispatchEvent(new CustomEvent('cancel', {
        cancelable: true
      }));
    }
  }, {
    key: "emitCancelledEvent",
    value: function emitCancelledEvent() {
      return this.dispatchEvent(new CustomEvent('cancelled'));
    }
  }], [{
    key: "pool",
    value: function pool(elicit) {
      var maxPool = 5;
      elicit.finally(() => {
        this.running.delete(elicit);
        if (!this.backlog.length) {
          return;
        }
        var next = this.backlog.shift();
        this.running.add(next);
        next.open();
      });
      if (this.running.size < maxPool) {
        this.running.add(elicit);
        elicit.open();
      } else {
        this.backlog.push(elicit);
      }
    }
  }]);
  return Elicit;
}(_Mixin.Mixin.with(_EventTargetMixin.EventTargetMixin, _PromiseMixin.PromiseMixin)); // elicit.addEventListener('open', event => console.log(event));
// elicit.addEventListener('close', event => console.log(event));
// elicit.addEventListener('firstByte', event => console.log(event));
// elicit.addEventListener('headers', event => console.log(event));
// elicit.addEventListener('complete', event => console.log(event));
// elicit.addEventListener('error', event => console.log(event));
// elicit.addEventListener('fail', event => console.log(event));
// elicit.addEventListener('pause', event => console.log(event));
// elicit.addEventListener('paused', event => console.log(event));
// elicit.addEventListener('unpause', event => console.log(event));
// elicit.addEventListener('unpaused', event => console.log(event));
// elicit.addEventListener('cancelled', event => console.log(event));
// elicit.addEventListener('cancel', event => console.log(event));
exports.Elicit = Elicit;
_defineProperty(Elicit, "backlog", []);
_defineProperty(Elicit, "running", new Set());
  })();
});

require.register("matrix-api/Matrix.js", function(exports, require, module) {
  require = __makeRelativeRequire(require, {}, "matrix-api");
  (function() {
    "use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Matrix = void 0;

var _Uuid = require("curvature/base/Uuid");

var _Mixin = require("curvature/base/Mixin");

var _EventTargetMixin = require("curvature/mixin/EventTargetMixin");

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var Matrix = function (_Mixin$with) {
  _inherits(Matrix, _Mixin$with);

  var _super = _createSuper(Matrix);

  function Matrix(baseUrl) {
    var _options$storage, _options$interval;

    var _this;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Matrix);

    _this = _super.call(this);

    _defineProperty(_assertThisInitialized(_this), "ssoUuid", String(new _Uuid.Uuid()));

    _defineProperty(_assertThisInitialized(_this), "isLoggedIn", false);

    _defineProperty(_assertThisInitialized(_this), "loggingIn", null);

    _this.baseUrl = baseUrl || 'https://matrix.org/_matrix';
    _this.clientUrl = "".concat(_this.baseUrl, "/client/v3");
    _this.mediaUrl = "".concat(_this.baseUrl, "/media/v3");
    _this.profileCache = new Map();
    _this.mediaCache = new Map();
    _this.storage = (_options$storage = options.storage) !== null && _options$storage !== void 0 ? _options$storage : globalThis.sessionStorage;
    _this.interval = (_options$interval = options.interval) !== null && _options$interval !== void 0 ? _options$interval : false;
    return _this;
  }

  _createClass(Matrix, [{
    key: "isLoggedIn",
    get: function get() {
      if (this.isLoggedIn) {
        this.dispatchEvent(new CustomEvent('logged-in'));
      }

      var tokenJson = this.storage.getItem('matrix:access-token') || 'false';
      var token = JSON.parse(tokenJson);
      return this.storage.getItem('matrix:access-token');
    }
  }, {
    key: "initSso",
    value: function initSso(redirectUri) {
      var _this2 = this;

      var windowRef = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : window;

      if (this.storage.getItem('matrix:access-token')) {
        this.isLoggedIn = true;
        this.dispatchEvent(new CustomEvent('logged-in'));
        return;
      }

      var query = new URLSearchParams({
        redirectUrl: redirectUri
      });
      var path = "login/sso/redirect?".concat(query);
      var width = 400;
      var height = 600;
      var left = window.screenX + window.outerWidth / 2 + width / 2;
      var top = window.screenY + window.outerHeight / 2 - height / 2;
      var options = "width=".concat(width, ",height=").concat(height, ",screenX=").concat(left, ",screenY=").concat(top);
      var ssoPopup = windowRef.open("".concat(this.clientUrl, "/").concat(path), "matrix-login-".concat(this.ssoUuid), options);

      var ssoListener = function ssoListener(event) {
        if (event.origin !== location.origin) {
          return;
        }

        if (event.source === window) {
          return;
        }

        if (typeof event.data !== 'string') {
          return;
        }

        var request = JSON.parse(event.data);

        if (request.type !== 's.sso.complete') {
          return;
        }

        _this2.storage.setItem('matrix:access-token', JSON.stringify(request.data));

        _this2.isLoggedIn = true;

        _this2.dispatchEvent(new CustomEvent('logged-in'));

        windowRef.removeEventListener('message', ssoListener);
      };

      windowRef.addEventListener('message', ssoListener);
    }
  }, {
    key: "completeSso",
    value: function completeSso(loginToken) {
      var path = 'login';
      var body = {
        type: "m.login.token",
        token: loginToken,
        txn_id: (1 / Math.random()).toString(36)
      };
      fetch("".concat(this.clientUrl, "/").concat(path), {
        method: 'POST',
        body: JSON.stringify(body)
      }).then(function (response) {
        return response.json();
      }).then(function (response) {
        window.opener.postMessage(JSON.stringify({
          type: 's.sso.complete',
          data: response
        }), location.origin);
        window.close();
      });
    }
  }, {
    key: "logIn",
    value: function logIn(redirectUri) {
      var _this3 = this;

      var windowRef = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : window;

      if (!this.loggingIn) {
        this.loggingIn = new Promise(function (accept) {
          _this3.loggingIn = null;

          _this3.addEventListener('logged-in', function (event) {
            accept(event);
          }, {
            once: true
          });
        });
      }

      this.initSso(redirectUri, windowRef);
      return this.loggingIn;
    }
  }, {
    key: "logOut",
    value: function logOut() {
      this.storage.removeItem('matrix:access-token');
      this.isLoggedIn = false;
      this.loggingIn = null;
      this.dispatchEvent(new CustomEvent('logged-out'));
    }
  }, {
    key: "getGuestToken",
    value: function getGuestToken() {
      var _this4 = this;

      var tokenJson = this.storage.getItem('matrix:access-token') || 'false';
      var token = JSON.parse(tokenJson);

      if (token && token.isGuest) {
        return Promise.resolve(token);
      }

      var query = new URLSearchParams({
        kind: 'guest'
      });
      var getToken = fetch("".concat(this.clientUrl, "/register?").concat(query), {
        method: 'POST',
        body: '{}'
      }).then(function (response) {
        return response.json();
      });
      getToken.then(function (token) {
        token.isGuest = true;
        _this4.isLoggedIn = true;

        _this4.storage.setItem('matrix:access-token', JSON.stringify(token));
      });
      return getToken;
    }
  }, {
    key: "getToken",
    value: function getToken() {
      var tokenJson = this.storage.getItem('matrix:access-token') || 'false';
      var token = JSON.parse(tokenJson);

      if (token) {
        return Promise.resolve(token);
      }

      return matrix.getGuestToken();
    }
  }, {
    key: "listenForServerEvents",
    value: function listenForServerEvents() {
      var _this5 = this;

      var token = JSON.parse(this.storage.getItem('matrix:access-token') || 'false');

      if (!token) {
        return Promise.reject('No access token found.');
      }

      var query = new URLSearchParams({
        access_token: token.access_token
      });
      var listener = "".concat(this.clientUrl, "/events?").concat(query);
      fetch(listener).then(function (response) {
        return response.json();
      }).then(function (response) {
        return _this5.streamServerEvents(response);
      });
    }
  }, {
    key: "listenForRoomEvents",
    value: function listenForRoomEvents(room_id, controller) {
      var _this6 = this;

      var from = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';

      if (controller && controller.cancelled) {
        return;
      }

      var token = JSON.parse(this.storage.getItem('matrix:access-token') || 'false');

      if (!token) {
        return Promise.reject('No access token found.');
      }

      var query = new URLSearchParams({
        access_token: token.access_token,
        room_id: room_id,
        from: from
      });
      var listener = "".concat(this.clientUrl, "/events?").concat(query);
      controller = controller || {
        cancelled: false
      };
      fetch(listener).then(function (response) {
        return response.json();
      }).then(function (response) {
        return _this6.streamServerEvents(response, room_id, controller);
      });
      return controller;
    }
  }, {
    key: "streamServerEvents",
    value: function streamServerEvents(chunkList, room_id, controller) {
      var _this7 = this;

      if (controller && controller.cancelled) {
        return;
      }

      if (!this.interval) {
        if (room_id) {
          this.listenForRoomEvents(room_id, controller, chunkList.end);
        } else {
          this.listenForServerEvents();
        }
      } else {
        setTimeout(function () {
          if (room_id) {
            _this7.listenForRoomEvents(room_id, controller, chunkList.end);
          } else {
            _this7.listenForServerEvents();
          }
        }, this.interval);
      }

      chunkList.chunk && chunkList.chunk.forEach(function (event) {
        var detail = {};

        if (!event.event_id) {
          event.event_id = "local:".concat(new _Uuid.Uuid());
        }

        Object.assign(detail, event);

        _this7.dispatchEvent(new CustomEvent('matrix-event', {
          detail: detail
        }));

        _this7.dispatchEvent(new CustomEvent(detail.type, {
          detail: detail
        }));
      });
    }
  }, {
    key: "getUserProfile",
    value: function getUserProfile(userId) {
      if (this.profileCache.has(userId)) {
        return this.profileCache.get(userId);
      }

      var getProfile = fetch("".concat(this.clientUrl, "/profile/").concat(userId)).then(function (response) {
        return response.json();
      });
      this.profileCache.set(userId, getProfile);
      return getProfile;
    }
  }, {
    key: "getUserData",
    value: function getUserData(type) {
      var token = JSON.parse(this.storage.getItem('matrix:access-token') || 'false');

      if (!token) {
        return Promise.reject('No access token found.');
      }

      var query = new URLSearchParams({
        access_token: token.access_token
      });
      return fetch("".concat(this.clientUrl, "/user/").concat(token.user_id, "/account_data/").concat(type, "?").concat(query)).then(function (response) {
        return response.json();
      });
    }
  }, {
    key: "putUserData",
    value: function putUserData(type, body) {
      var token = JSON.parse(this.storage.getItem('matrix:access-token') || 'false');

      if (!token) {
        return;
      }

      var query = new URLSearchParams({
        access_token: token.access_token
      });
      var endpoint = "".concat(this.clientUrl, "/user/").concat(token.user_id, "/account_data/").concat(type, "?").concat(query);
      return fetch(endpoint, {
        method: 'PUT',
        body: body
      }).then(function (response) {
        if (!response.ok) {
          var error = new Error("HTTP status code: " + response.status);
          error.status = response.status;
          error.response = response;
          throw error;
        }

        return response;
      }).then(function (response) {
        return response.json();
      });
    }
  }, {
    key: "getMediaUrl",
    value: function getMediaUrl(mxcUrl) {
      var url = new URL(mxcUrl);
      return "".concat(this.mediaUrl, "/download/").concat(url.pathname.substr(2));
    }
  }, {
    key: "getMedia",
    value: function getMedia(mxcUrl) {
      if (this.mediaCache.has(mxcUrl)) {
        return this.mediaCache.get(mxcUrl);
      }

      var getUrl = fetch(this.getMediaUrl(mxcUrl)).then(function (response) {
        return Promise.all([response.arrayBuffer(), response.headers.get('Content-type')]);
      }).then(function (_ref) {
        var _ref2 = _slicedToArray(_ref, 2),
            buffer = _ref2[0],
            type = _ref2[1];

        return URL.createObjectURL(new Blob([buffer], {
          type: type
        }));
      });
      this.mediaCache.set(mxcUrl, getUrl);
      return getUrl;
    }
  }, {
    key: "postMedia",
    value: function postMedia(body, filename) {
      var tokenJson = this.storage.getItem('matrix:access-token') || 'false';
      var token = JSON.parse(tokenJson);

      if (!token) {
        return;
      }

      var query = new URLSearchParams({
        access_token: token.access_token
      });
      var url = "".concat(this.mediaUrl, "/upload?").concat(query);
      var headers = new Headers({
        'Content-Type': body.type
      });
      var method = 'POST';
      var options = {
        method: method,
        headers: headers,
        body: body
      };
      return fetch(url, options).then(function (response) {
        return response.json();
      });
    }
  }, {
    key: "putEvent",
    value: function putEvent(roomId, type, body) {
      var tokenJson = this.storage.getItem('matrix:access-token') || 'false';
      var token = JSON.parse(tokenJson);

      if (!token) {
        return;
      }

      var query = new URLSearchParams({
        access_token: token.access_token
      });
      var url = "".concat(this.clientUrl, "/rooms/").concat(roomId, "/send/").concat(type, "/").concat(Math.random().toString(36), "?").concat(query);
      var headers = new Headers({
        'Content-Type': 'application/json'
      });
      var method = 'PUT';
      var keepalive = true;

      var options = _defineProperty({
        method: method,
        headers: headers,
        keepalive: keepalive,
        body: JSON.stringify(body)
      }, "keepalive", keepalive);

      return fetch(url, options).then(function (response) {
        return response.json();
      });
    }
  }, {
    key: "getEvent",
    value: function getEvent(roomId, eventId) {
      var tokenJson = this.storage.getItem('matrix:access-token') || 'false';
      var token = JSON.parse(tokenJson);

      if (!token) {
        return;
      }

      var query = new URLSearchParams({
        access_token: token.access_token
      });
      var url = "".concat(this.clientUrl, "/rooms/").concat(roomId, "/event/").concat(eventId, "?").concat(query);
      var headers = new Headers({
        'Content-Type': 'application/json'
      });
      var method = 'GET';
      var options = {
        method: method,
        headers: headers
      };
      return fetch(url, options).then(function (response) {
        return response.json();
      });
    }
  }, {
    key: "sync",
    value: function sync() {
      var tokenJson = this.storage.getItem('matrix:access-token') || 'false';
      var token = JSON.parse(tokenJson);

      if (!token) {
        return Promise.resolve();
      }

      var query = new URLSearchParams({
        full_state: true,
        access_token: token.access_token
      });
      var syncer = "".concat(this.clientUrl, "/sync?").concat(query);
      return fetch(syncer).then(function (response) {
        return response.json();
      });
    }
  }, {
    key: "getRoomState",
    value: function getRoomState(room_id) {
      var tokenJson = this.storage.getItem('matrix:access-token') || 'false';
      var token = JSON.parse(tokenJson);

      if (!token) {
        return Promise.resolve();
      }

      var query = new URLSearchParams({
        access_token: token.access_token
      });
      var syncer = "".concat(this.clientUrl, "/rooms/").concat(room_id, "/state?").concat(query);
      return fetch(syncer).then(function (response) {
        return response.json();
      });
    }
  }, {
    key: "syncRoom",
    value: function syncRoom(room_id) {
      var from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var filter = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

      if (!this.isLoggedIn) {
        return Promise.reject('Logged out.');
      }

      var token = JSON.parse(this.storage.getItem('matrix:access-token') || 'false');

      if (!token) {
        return Promise.reject('No access token found.');
      }

      var query = new URLSearchParams({
        access_token: token.access_token,
        room_id: room_id,
        dir: 'b',
        from: from ? from : '',
        filter: filter ? JSON.stringify(filter) : ''
      });
      var syncer = "".concat(this.clientUrl, "/rooms/").concat(room_id, "/messages?").concat(query);
      var controller = new AbortController();
      var signal = controller.signal;

      var abort = function abort() {
        return controller.abort();
      };

      this.addEventListener('logged-out', abort, {
        once: true
      });
      var fetchFrame = fetch(syncer, {
        signal: signal
      }).then(function (response) {
        return response.json();
      });
      fetchFrame["finally"](this.removeEventListener('logged-out', abort));
      return fetchFrame;
    }
  }, {
    key: "syncRoomHistory",
    value: function syncRoomHistory(room) {
      var _this8 = this;

      var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var to = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var from = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      var filter = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
      return this.syncRoom(room, from, filter).then(function (frame) {
        if (!_this8.isLoggedIn) {
          return Promise.reject('Logged out.');
        }

        var cancelable = true;
        var detail = {
          frame: frame
        };
        var event = new CustomEvent('roomSyncFrame', {
          detail: detail,
          cancelable: cancelable
        });

        if (!_this8.dispatchEvent(event)) {
          return;
        }

        if (callback && frame.chunk) {
          var _iterator = _createForOfIteratorHelper(frame.chunk),
              _step;

          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var message = _step.value;

              if (!_this8.isLoggedIn) {
                return Promise.reject('Logged out.');
              }

              if (to && message.origin_server_ts <= to) {
                return Promise.resolve();
              }

              if (callback(message) === false) {
                return Promise.resolve();
              }
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        }

        return new Promise(function (accept) {
          var _this8$interval;

          return setTimeout(function () {
            return accept(frame.chunk.length && _this8.syncRoomHistory(room, callback, to, frame.end, filter));
          }, (_this8$interval = _this8.interval) !== null && _this8$interval !== void 0 ? _this8$interval : 0);
        });
      });
    }
  }, {
    key: "getCurrentUserId",
    value: function getCurrentUserId() {
      var tokenJson = this.storage.getItem('matrix:access-token') || 'false';
      var token = JSON.parse(tokenJson);

      if (!token) {
        return;
      }

      return token.user_id;
    }
  }, {
    key: "createRoom",
    value: function createRoom(name, topic, visibility) {
      var initial_state = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
      var body = JSON.stringify({
        name: name,
        topic: topic,
        visibility: visibility,
        initial_state: initial_state
      });
      var token = JSON.parse(this.storage.getItem('matrix:access-token') || 'false');

      if (!token) {
        return Promise.resolve();
      }

      var query = new URLSearchParams({
        access_token: token.access_token
      });
      var url = "".concat(this.clientUrl, "/createRoom?").concat(query);
      var method = 'POST';
      return fetch(url, {
        body: body,
        method: method
      }).then(function (response) {
        return response.json();
      });
    }
  }, {
    key: "joinRoom",
    value: function joinRoom(room_id) {
      var token = JSON.parse(this.storage.getItem('matrix:access-token') || 'false');

      if (!token) {
        return Promise.reject('No access token found.');
      }

      var query = new URLSearchParams({
        access_token: token.access_token
      });
      fetch("".concat(this.clientUrl, "/rooms/").concat(room_id, "/join?").concat(query), {
        method: 'POST'
      }).then(function (response) {
        return response.json();
      });
    }
  }, {
    key: "leaveRoom",
    value: function leaveRoom(room_id) {
      var token = JSON.parse(this.storage.getItem('matrix:access-token') || 'false');

      if (!token) {
        return Promise.reject('No access token found.');
      }

      var query = new URLSearchParams({
        access_token: token.access_token
      });
      fetch("".concat(this.clientUrl, "/rooms/").concat(room_id, "/leave?").concat(query), {
        method: 'POST'
      }).then(function (response) {
        return response.json();
      });
    }
  }, {
    key: "whoAmI",
    value: function whoAmI() {
      var token = JSON.parse(this.storage.getItem('matrix:access-token') || 'false');

      if (!token) {
        return Promise.reject('No access token found.');
      }

      var query = new URLSearchParams({
        access_token: token.access_token
      });
      return fetch("".concat(this.clientUrl, "/account/whoami?").concat(query)).then(function (response) {
        return response.json();
      });
    }
  }]);

  return Matrix;
}(_Mixin.Mixin["with"](_EventTargetMixin.EventTargetMixin));

exports.Matrix = Matrix;
  })();
});

require.register("sixgram/Actions.js", function(exports, require, module) {
  require = __makeRelativeRequire(require, {}, "sixgram");
  (function() {
    "use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.HOME = exports.LEAVE = exports.ENTER = exports.INSERT = exports.IGNORE = void 0;
var IGNORE = 0;
exports.IGNORE = IGNORE;
var INSERT = 1;
exports.INSERT = INSERT;
var ENTER = 2;
exports.ENTER = ENTER;
var LEAVE = 3;
exports.LEAVE = LEAVE;
var HOME = 4;
exports.HOME = HOME;
  })();
});

require.register("sixgram/Chunk.js", function(exports, require, module) {
  require = __makeRelativeRequire(require, {}, "sixgram");
  (function() {
    "use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Chunk = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Chunk = function Chunk() {
  _classCallCheck(this, Chunk);

  this.depth = 0;
  this.match = null;
  this.type = 'normal';
  this.list = [];
};

exports.Chunk = Chunk;
  })();
});

require.register("sixgram/Parser.js", function(exports, require, module) {
  require = __makeRelativeRequire(require, {}, "sixgram");
  (function() {
    "use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Parser = void 0;

var _Chunk = require("./Chunk");

var _Actions = require("./Actions");

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Parser = /*#__PURE__*/function () {
  function Parser(tokens, modes) {
    _classCallCheck(this, Parser);

    this.tokens = tokens || {};
    this.modes = modes || {};
  }

  _createClass(Parser, [{
    key: "parse",
    value: function parse(source) {
      this.index = 0;
      this.mode = 'normal';
      this.stack = [];

      if (!(this.mode in this.modes)) {
        throw new Error("Mode ".concat(this.mode, " does not exist on parser."), this);
      }

      var chunk = new _Chunk.Chunk();
      var mode = this.modes[this.mode];
      chunk.type = this.mode;

      while (this.index < source.length) {
        var matched = false;

        for (var tokenName in mode) {
          var token = this.tokens[tokenName];
          var search = token.exec(source.substr(this.index));

          if (!search || search.index > 0) {
            continue;
          }

          if (!mode[tokenName]) {
            throw new Error("Invalid token type \"".concat(tokenName, "\" found in mode \"").concat(this.mode, "\"."));
            continue;
          }

          var value = search[0];
          var actions = _typeof(mode[tokenName]) === 'object' ? mode[tokenName] : [mode[tokenName]];
          matched = true;
          this.index += value.length;
          var type = 'normal';

          for (var i in actions) {
            var action = actions[i];

            if (typeof action === 'string') {
              if (!(action in this.modes)) {
                throw new Error("Mode \"".concat(action, "\" does not exist."));
              }

              this.mode = action;
              mode = this.modes[this.mode];
              type = action;
              continue;
            }

            switch (action) {
              case _Actions.INSERT:
                chunk.list.push(value);
                break;

              case _Actions.ENTER:
                var newChunk = new _Chunk.Chunk();
                newChunk.depth = chunk.depth + 1;
                newChunk.match = value;
                newChunk.groups = _toConsumableArray(value.match(token)).slice(1);
                newChunk.mode = type;
                newChunk.type = tokenName;
                chunk.list.push(newChunk);
                this.stack.push(chunk);
                chunk = newChunk; // this.mode = chunk.type;

                break;

              case _Actions.LEAVE:
                if (!this.stack.length) {// throw new Warning(`Already at the top of the stack.`)
                } else {
                  chunk = this.stack.pop();
                  this.mode = chunk.type;
                  mode = this.modes[this.mode];
                }

                break;

              case _Actions.HOME:
                this.stack.splice(0);
                mode = this.modes['normal'];
                break;
            }
          }

          break;
        }

        if (!matched) {
          break;
        }
      }

      if (this.stack.length) {
        throw new Error('Did not return to top of stack!');
      }

      return this.stack.shift() || chunk;
    }
  }]);

  return Parser;
}();

exports.Parser = Parser;
  })();
});

require.register("sixgram/Renderer.js", function(exports, require, module) {
  require = __makeRelativeRequire(require, {}, "sixgram");
  (function() {
    "use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Renderer = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Renderer = /*#__PURE__*/function () {
  function Renderer(ops) {
    _classCallCheck(this, Renderer);

    this.ops = ops || {};
  }

  _createClass(Renderer, [{
    key: "process",
    value: function process(tree) {
      var output = '';

      for (var i in tree.list) {
        var chunk = tree.list[i];

        if (this.ops[tree.type]) {
          var processed = this.ops[tree.type](chunk, tree);

          if (processed !== false) {
            output += processed;
          }
        } else if (chunk !== false) {
          output += chunk;
        }
      }

      return output;
    }
  }]);

  return Renderer;
}();

exports.Renderer = Renderer;
  })();
});

require.register("subspace-client/Channel.js", function(exports, require, module) {
  require = __makeRelativeRequire(require, {}, "subspace-client");
  (function() {
    "use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Channel = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Channel = /*#__PURE__*/function () {
  function Channel() {
    _classCallCheck(this, Channel);
  }

  _createClass(Channel, null, [{
    key: "scalar",
    value: function scalar(data, type) {
      var buffer = new Uint8Array(data).buffer;

      if (type == 'float') {
        return new Float64Array(buffer)[0];
      } else if (type == 'Int32') {
        return new Int32Array(buffer)[0];
      }
    }
  }, {
    key: "namePart",
    value: function namePart(name, part) {
      return name.split(':')[part] || null;
    }
  }, {
    key: "isWildcard",
    value: function isWildcard(name) {
      return /\*/.exec(name);
    }
  }, {
    key: "isRange",
    value: function isRange(name) {// return /\*/.exec(name);
    }
  }, {
    key: "containsRange",
    value: function containsRange(name) {// return /\*/.exec(name);
    }
  }, {
    key: "compareNames",
    value: function compareNames(a, b) {
      var rangeForm = /^(\d+)\-?(\d+)?$/;
      var result = [];
      var splitA = a.toString().split(':');
      var splitB = b.toString().split(':');
      var nodes = splitA.length;
      var cmpA;
      var cmpB;

      if (nodes < splitB.length) {
        nodes = splitB.length;
      }

      for (var i = 0; i < nodes; i++) {
        if (splitA.length > i) {
          cmpA = splitA[i];
        } else if (splitA[splitA.length - 1] == '*') {
          cmpA = splitA[splitA.length - 1];
        } else {
          return false;
        }

        if (splitB.length > i) {
          cmpB = splitB[i];
        } else if (splitB[splitB.length - 1] == '*') {
          cmpB = splitB[splitB.length - 1];
        } else {
          return false;
        }

        var returnNode = cmpA !== '*' ? cmpA : cmpB;

        if (cmpA !== cmpB) {
          if (cmpA !== '*' && cmpB !== '*') {
            var mA = rangeForm.exec(cmpA);
            var mB = rangeForm.exec(cmpB);

            if (mA && mB) {
              var a1 = mA[1];
              var a2 = mA[1];
              var b1 = mB[1];
              var b2 = mB[1];

              if (mA[2]) {
                a2 = mA[2];
              }

              if (mB[2]) {
                b2 = mB[2];
              }

              if (a1 >= b1 && a2 <= b2) {
                returnNode = "".concat(a1, "-").concat(a2);
              } else if (a1 <= b1 && a2 > b2) {
                returnNode = "".concat(b1, "-").concat(b2);
              } else if (a2 <= b2 && a2 >= b1) {
                returnNode = "".concat(b1, "-").concat(a2);
              } else if (a1 <= b2 && a1 >= b1) {
                returnNode = "".concat(a1, "-").concat(b2);
              }

              if (b2 <= a2 && b2 >= a1) {
                returnNode = "".concat(a1, "-").concat(b2);
              } else if (b1 <= a2 && b1 >= a1) {
                returnNode = "".concat(b1, "-").concat(a2);
              } else {
                return false;
              }
            } else {
              return false;
            }
          }
        }

        result.push(returnNode);
      }

      return result.join(':');
    }
  }]);

  return Channel;
}();

exports.Channel = Channel;
  })();
});

require.register("subspace-client/Socket.js", function(exports, require, module) {
  require = __makeRelativeRequire(require, {}, "subspace-client");
  (function() {
    "use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Socket = void 0;

var _Channel = require("./Channel");

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Socket = /*#__PURE__*/function () {
  _createClass(Socket, null, [{
    key: "get",
    value: function get(url) {
      var refresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (!this.sockets) {
        this.sockets = {};
      }

      if (refresh || !this.sockets[url]) {
        this.sockets[url] = new this(new WebSocket(url));
      }

      return this.sockets[url];
    }
  }]);

  function Socket(socket) {
    _classCallCheck(this, Socket);

    this.socket = socket;
    socket.binaryType = 'arraybuffer';
    this.data = {};
    this.listenerCount = {};
    this.openQueue = [];
    this._onSend = [];
  }

  _createClass(Socket, [{
    key: "subscribe",
    value: function subscribe(type, wildType, callback) {
      var splitType = type.split(':');
      var mainType = splitType.shift();
      var channel = splitType.join(':');

      if (wildType instanceof Function) {
        callback = wildType;
        wildType = channel;
      }

      if (channel) {
        if (!(channel in this.listenerCount)) {
          this.listenerCount[channel] = 0;
        }

        this.listenerCount[channel]++;
        this.send("sub ".concat(channel));
      }

      var finalCallback = function (mainType, wildType, channel, callback) {
        return function (event) {
          var packet = {};

          try {
            if (typeof event.data == 'string') {
              packet = JSON.parse(event.data);
            } else if (event.data instanceof ArrayBuffer) {
              var channelNumber = new Uint16Array(event.data, 4, 1)[0];

              if (!wildType || _Channel.Channel.compareNames(wildType, channelNumber)) {
                callback(event, event.data.slice(6), channelNumber, new Uint16Array(event.data, 0, 1)[0] ? 'user' : 'server', new Uint16Array(event.data, 2, 1)[0], null, {});
                return;
              }
            } else if (mainType !== 'message') {
              callback(event);
              return;
            }
          } catch (e) {
            if (mainType !== 'message') {
              callback(event);
            }

            return;
          }

          if (_typeof(packet) !== 'object') {
            if (channel === '') {
              callback(event, event.data, null, 'server', 0, null, packet);
            }

            return;
          }

          if (!wildType) {
            callback(event, packet.message, null, packet.origin, packet.originId, null, packet);
          }

          if (wildType && 'channel' in packet) {
            if (_Channel.Channel.compareNames(wildType, packet.channel)) {
              callback(event, packet.message, packet.channel, packet.origin, packet.originId, packet.originalChannel, packet);
            }
          }
        };
      }(mainType, wildType, channel, callback);

      this.socket.addEventListener(mainType, finalCallback);
      return finalCallback;
    }
  }, {
    key: "unsubscribe",
    value: function unsubscribe(type, callback) {
      var splitType = type.split(':');
      var mainType = splitType.shift();
      var channel = splitType.join(':');

      if (!channel) {
        return;
      }

      this.listenerCount[channel]--;

      if (channel in this.listenerCount && this.listenerCount[channel] > 0) {} else {
        this.socket.removeEventListener(mainType, callback);
        this.send("unsub ".concat(channel));
      }
    }
  }, {
    key: "publish",
    value: function publish(channel, message) {
      if (channel == parseInt(channel)) {
        if (message instanceof ArrayBuffer) {
          message = new Uint8Array(message);
        } else if (message.byteLength) {
          message = new Uint8Array(message.buffer);
        } else if (!Array.isArray(message)) {
          message = [message];
        }

        var channelBytes = new Uint8Array(new Uint16Array([channel]).buffer);
        var sendBuffer = new Uint8Array(channelBytes.byteLength + message.byteLength);
        sendBuffer.set(channelBytes, 0);
        sendBuffer.set(message, channelBytes.byteLength);
        this.send(sendBuffer);
        return;
      }

      this.send("pub ".concat(channel, " ").concat(message));
    }
  }, {
    key: "say",
    value: function say(channel, users, message) {
      var cc = [];
      var bcc = [];

      if (Array.isArray(users)) {
        Object.assign(cc, users);
      } else if (users.cc || users.bcc) {
        if (Array.isArray(users.cc)) {
          Object.assign(cc, users.cc);
        }

        if (Array.isArray(users.bcc)) {
          Object.assign(bcc, users.bcc);
        }
      }

      if (!cc && !bcc) {
        var userListString = 'CANNOT STRINGIFY USERLIST';

        try {
          userListString = JSON.stringify(users);
        } catch (error) {
          userlistString += ' ' + error.message;
        }

        throw error('Invalid userlist provided:' + userListString);
      }

      var ccString = cc.length ? "".concat(cc.length, " ").concat(cc.join(' ')) : "0";
      var bccString = bcc.length ? "".concat(bcc.length, " ").concat(bcc.join(' ')) : "0";
      this.send("say ".concat(channel, " ").concat(ccString, " ").concat(bccString, " ").concat(message));
    }
  }, {
    key: "send",
    value: function send(message) {
      var _this = this;

      if (this.socket.readyState !== this.socket.OPEN) {
        return new Promise(function (accept, reject) {
          var connectionOpened = function (c) {
            return function (event) {
              while (_this.openQueue.length) {
                var _message = _this.openQueue.shift();

                _this.send(_message);
              }

              _this.socket.removeEventListener('open', c);

              accept();
            };
          }(connectionOpened);

          _this.socket.addEventListener('open', connectionOpened);

          _this.openQueue.unshift(message);
        });
      }

      for (var i in this._onSend) {
        this._onSend[i](message);
      }

      this.socket.send(message);
      return Promise.resolve();
    }
  }, {
    key: "onSend",
    value: function onSend(callback) {
      this._onSend.push(callback);
    }
  }, {
    key: "close",
    value: function close(message) {
      this.socket.close();
    }
  }, {
    key: "ping",
    value: function ping() {// this.socket.ping();
    }
  }, {
    key: "pong",
    value: function pong() {// this.socket.pong();
    }
  }]);

  return Socket;
}();

exports.Socket = Socket;
  })();
});

require.register("subspace-console/Console.js", function(exports, require, module) {
  require = __makeRelativeRequire(require, {}, "subspace-console");
  (function() {
    "use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Console = void 0;

var _View2 = require("curvature/base/View");

var _Bag = require("curvature/base/Bag");

var _MeltingText = require("./view/MeltingText");

var _EchoMessage = require("./view/EchoMessage");

var _Task = require("./Task");

var _Path = require("./Path");

var _Renderer = require("./ansi/Renderer");

var _Parser = require("./ansi/Parser");

function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var Console = /*#__PURE__*/function (_View) {
  _inherits(Console, _View);

  var _super = _createSuper(Console);

  function Console() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Console);

    _this = _super.call(this, args);
    var defaults = {
      init: false,
      path: _Path.Path
    };
    var allOptions = Object.assign({}, defaults, options);
    _this.template = "<div class = \"terminal [[inverted]]\" cv-on = \"click:focus(event)\">\n\t<div class = \"output\" cv-each = \"output:line:l\" cv-ref = \"output:curvature/base/Tag\">\n\t\t<p>[[line]]</p>\n\t</div>\n\t<div class = \"bottom\">\n\t\t<div>[[prompt]]&nbsp;</div>\n\t\t<div>\n\t\t\t<form cv-on = \"submit:cancel(event)\">\n\t\t\t\t<textarea\n\t\t\t\t\tcv-bind = \"input\"\n\t\t\t\t\tcv-on   = \":keydown(event);:keyup(event)\"\n\t\t\t\t\tcv-ref  = \"input:curvature/base/Tag\"\n\t\t\t\t\trow     = \"1\"\n\t\t\t\t></textarea>\n\t\t\t</form>\n\n\t\t\t<form cv-on = \"submit:cancel(event)\">\n\t\t\t\t<input\n\t\t\t\t\tautocomplete = \"one-time-code\"\n\t\t\t\t\tname    = \"pw-input\"\n\t\t\t\t\ttype    = \"password\"\n\t\t\t\t\tcv-bind = \"input\"\n\t\t\t\t\tcv-ref  = \"password:curvature/base/Tag\"\n\t\t\t\t\tcv-on   = \":keydown(event,false);:keyup(event,false)\"\n\t\t\t\t/>\n\t\t\t</form>\n\n\t\t\t<input\n\t\t\t\tcv-on  = \"input:fileLoaded(event)\"\n\t\t\t\tcv-ref = \"file:curvature/base/Tag\"\n\t\t\t\tname   = \"file-input\"\n\t\t\t\ttype   = \"file\"\n\t\t\t\tstyle  = \"display: none\"\n\t\t\t/>\n\t\t</div>\n\t</div>\n</div>\n\n<div class = \"scanlines\"></div>\n";
    _this.args.input = '';
    _this.args.output = [];
    _this.args.inverted = '';
    _this.localEcho = true;
    _this.postToken = null;
    _this.args.prompt = '::';
    _this.routes = {};
    _this.args.passwordMode = false;
    _this.tasks = [];
    _this.external = options.external || [];
    _this.taskList = new _Bag.Bag();
    _this.taskList.type = _Task.Task;
    _this.max = 10;
    _this.historyCursor = -1;
    _this.history = [];
    _this.env = new Map();

    _this.args.output.___after(function (t, k, o, a) {
      if (k !== 'push') {
        return;
      }

      _this.onNextFrame(function () {
        return _this.scrollToBottom();
      });
    });

    if (allOptions.init) {
      _this.runScript(allOptions.init);
    }

    _this.scroller = allOptions.scroller || document.body;
    _this.path = allOptions.path || {};
    _this.originalInput = '';
    return _this;
  }

  _createClass(Console, [{
    key: "runCommand",
    value: function runCommand(command) {
      var _this2 = this;

      if (this.historyCursor != 0) {
        this.history.unshift(command);
      }

      return new Promise(function (accept) {
        var task;

        if (command.substring(0, 1) === '/') {
          if (!_this2.args.passwordMode) {
            var output = new _EchoMessage.EchoMessage({
              message: command
            });

            _this2.args.output.push(output);
          }

          var unescaped = _this2.unescape(command.substr(1));

          task = _this2.interpret(unescaped);
        } else if (_this2.tasks.length) {
          if (!_this2.args.passwordMode) {
            var _output = new _EchoMessage.EchoMessage({
              message: command,
              prompt: _this2.tasks[0].prompt
            });

            _this2.args.output.push(_output);
          }

          var _unescaped = _this2.unescape(command);

          task = _this2.tasks[0].write(_unescaped) || Promise.resolve();
        } else {
          if (!_this2.args.passwordMode) {
            _this2.args.output.push(":: ".concat(command));
          }

          var _unescaped2 = _this2.unescape(command);

          task = _this2.interpret(_unescaped2);
        }

        if (!(task instanceof _Task.Task) && !(task instanceof Promise)) {
          task = Promise.resolve(task);
        }

        _this2.historyCursor = -1;
        _this2.originalInput = _this2.args.input = '';
        task.then(function (result) {
          return accept(result);
        });
      })["catch"](function (error) {
        _this2.args.output.push("Unexpected error: ".concat(error));
      });
    }
  }, {
    key: "runScript",
    value: function runScript(url) {
      var _this3 = this;

      fetch(url + '?api=txt').then(function (response) {
        return response.text();
      }).then(function (init) {
        var lines = init.split("\n");

        var process = function process(lines) {
          if (!lines.length) {
            return;
          }

          var line = lines.shift();

          if (line && line[0] == '!') {
            _this3.args.output.push(line.substring(1));

            process(lines);
          } else if (line) {
            _this3.runCommand(line).then(function () {
              return process(lines);
            });
          } else {
            process(lines);
          }
        };

        process(lines);
      });
    }
  }, {
    key: "postRender",
    value: function postRender() {
      var _this4 = this;

      var inputBox = this.tags.input.element;
      var passwordBox = this.tags.password.element;
      this.args.bindTo('input', function (v) {
        inputBox.style.height = 'auto';
        inputBox.style.height = inputBox.scrollHeight + 'px';
      }, {
        frame: 1
      });
      this.args.bindTo('passwordMode', function (v) {
        if (v) {
          inputBox.style.display = 'none';
          passwordBox.style.display = 'unset';
        } else {
          inputBox.style.display = 'unset';
          passwordBox.style.display = 'none';
        }
      });
      this.args.bindTo('passwordMode', function (v) {
        _this4.focus(null, v);
      }, {
        frame: 1
      });
    }
  }, {
    key: "focus",
    value: function focus() {
      var event = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var passwordMode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      if (event) {
        event.preventDefault();
      }

      if (event && event.target && event.target.matches('input,textarea')) {
        return;
      }

      if (window.getSelection().toString()) {
        return;
      }

      if (passwordMode || this.args.passwordMode) {
        this.tags.password.element.focus();
        return;
      }

      this.tags.input.element.focus();
    }
  }, {
    key: "interpret",
    value: function interpret(input) {
      var _this5 = this;

      this.historyCursor = -1;
      var expressions = input.split(/\s*\;\s*/);
      var lastTask = null;

      var _iterator = _createForOfIteratorHelper(expressions),
          _step;

      try {
        var _loop = function _loop() {
          var expression = _step.value;

          var task = _this5.pipe(expression.split(/\s*\|\s*/));

          if (task) {
            _this5.tasks.unshift(task);

            var output = function output(event) {
              var line = event.detail;

              if (_typeof(line) === 'object') {
                _this5.args.output.push(line);
              } else {
                var prompt = task.outPrompt || task.prompt || _this5.args.prompt || '::';

                var rendered = _this5.parseAnsi(line, prompt);

                _this5.args.output.push(rendered);
              }
            };

            var error = function error(event) {
              console.error(event);
              var line = event.detail;
              var errorPrompt = task.errorPrompt || '!!';

              var rendered = _this5.parseAnsi(line, errorPrompt);

              _this5.args.output.push(rendered);
            };

            task.addEventListener('output', output);
            task.addEventListener('error', error);
            task.execute();
            task["catch"](function (error) {
              return console.error(error);
            });
            task["catch"](function (error) {
              return _this5.args.output.push("!! ".concat(error));
            });
            _this5.args.prompt = task.prompt;
            task["finally"](function (done) {
              task.removeEventListener('error', error);
              task.removeEventListener('output', output);

              _this5.tasks.shift();

              if (_this5.tasks.length) {
                _this5.args.prompt = _this5.tasks[0].prompt;
              } else {
                _this5.args.prompt = '::';
              }
            });
          }

          lastTask = task;
        };

        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          _loop();
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      return lastTask;
    }
  }, {
    key: "pipe",
    value: function pipe(commands, previousTask) {
      var task = null;
      var commandString = commands.shift();
      var args = commandString.trim().split(' ');
      var command = args.shift().trim();

      if (command.length > 1 && command.substr(-1) == "?") {
        command = command.substr(0, command.length - 1);

        if (command in this.path) {
          this.args.output.push("?? ".concat(this.path[command].helpText));
          this.args.output.push("?? ".concat(this.path[command].useText));
        }

        return;
      }

      if (command in this.path) {
        var cmdClass = this.path[command];
        task = _construct(cmdClass, [args, previousTask, this].concat(_toConsumableArray(this.external)));
      } else {
        switch (command) {
          case 'clear':
            this.args.output.splice(0);
            break;

          case 'z':
            this.args.output.splice(0);
            this.args.output.push(new _MeltingText.MeltingText({
              input: '!!!'
            }));
            break;

          case 'commands':
          case '?':
            this.args.output.push("   Subspace Console 0.29a \xA92018-2021 Sean Morris");

            for (var cmd in this.path) {
              this.args.output.push(" * ".concat(cmd, " - ").concat(this.path[cmd].helpText));
              this.path[cmd].useText && this.args.output.push("   ".concat(this.path[cmd].useText));
              this.args.output.push("  ");
            }

            break;

          default:
            this.args.output.push("!! Bad command: ".concat(command));
        }
      }

      if (commands.length) {
        return this.pipe(commands, task);
      }

      return task;
    }
  }, {
    key: "keydown",
    value: function keydown(event, autocomplete) {
      switch (event.key) {
        case 'Tab':
          if (autocomplete) {
            break;
          }

          event.preventDefault();
          break;

        case 'Enter':
          if (!event.ctrlKey) {
            event.preventDefault();
          }

          break;
      }
    }
  }, {
    key: "keyup",
    value: function keyup(event, autocomplete) {
      var _this6 = this;

      switch (event.key) {
        case 'ArrowDown':
          this.historyCursor--;

          if (this.historyCursor <= -1) {
            this.historyCursor = -1;
            this.args.input = this.originalInput;
            return;
          }

          this.args.input = this.history[this.historyCursor];
          this.onNextFrame(function () {
            var element = _this6.tags.input.element;
            element.selectionStart = element.value.length;
            element.selectionEnd = element.value.length;
          });
          break;

        case 'ArrowUp':
          if (this.historyCursor == -1) {
            this.originalInput = this.args.input;
          }

          this.historyCursor++;

          if (this.historyCursor >= this.history.length) {
            this.historyCursor--;
            return;
          }

          this.args.input = this.history[this.historyCursor];
          this.onNextFrame(function () {
            var element = _this6.tags.input.element;
            element.selectionStart = element.value.length;
            element.selectionEnd = element.value.length;
          });
          break;

        case 'Escape':
          if (this.tasks.length) {
            this.tasks[0]["finally"](function () {
              return _this6.args.output.push(":: Killed.");
            });
            this.tasks[0].signal(_Task.Task.KILL);
          }

          this.args.passwordMode = false;
          break;

        case 'Tab':
          event.preventDefault();

          if (!this.args.input) {
            break;
          }

          var search = this.args.input;
          var sigil = '';

          if (this.args.input[0] === '/') {
            search = this.args.input.substr(1);
            sigil = this.args.input.substr(0, 1);
            break;
          }

          for (var cmd in this.path) {
            if (cmd.length < search.length) {
              continue;
            }

            if (search === cmd.substr(0, search.length)) {
              this.args.input = sigil + cmd;
              break;
            }
          }

          break;

        case 'Enter':
          if (!event.ctrlKey) {
            event.preventDefault();
          } else {
            return;
          }

          this.runCommand(this.args.input);
          this.args.input = '';
          break;

        default:
          this.historyCursor = -1;
          this.scrollToBottom();
          break;
      }
    }
  }, {
    key: "cancel",
    value: function cancel(event) {
      event.preventDefault();
      event.stopPropagation();
    }
  }, {
    key: "scrollToBottom",
    value: function scrollToBottom() {
      var scroller = (this.scroller === document.body ? window : this.scroller) || window;
      var scrollTo = this.scroller.scrollHeight;
      this.onNextFrame(function () {
        scroller.scrollTo({
          behavior: 'smooth',
          left: 0,
          top: scrollTo
        });
      });
    }
  }, {
    key: "parseAnsi",
    value: function parseAnsi(line, prompt) {
      line = line.replace(/</g, '&lt;').replace(/>/g, '&gt;');
      var renderer = new _Renderer.Renderer();

      var parsed = _Parser.Parser.parse(line);

      var wrapped = renderer.process(parsed);

      if (!prompt) {
        return _View2.View.from("<span class =\"ansi\">".concat(wrapped, "</span>"));
      }

      var promptEsc = prompt.replace(/</g, '&lt;').replace(/>/g, '&gt;');

      var rendered = _View2.View.from("".concat(promptEsc, " <span class =\"ansi\">").concat(wrapped, "</span>"));

      return rendered;
    }
  }, {
    key: "unescape",
    value: function unescape(string) {
      return string.replace(/\\n/gm, '\n').replace(/\\r/gm, '\r').replace(/\\t/gm, '\t').replace(/\\e/gm, "\x1B").replace(/\\u001b/gm, "\x1B");
    }
  }, {
    key: "write",
    value: function write() {
      for (var _len = arguments.length, lines = new Array(_len), _key = 0; _key < _len; _key++) {
        lines[_key] = arguments[_key];
      }

      for (var _i = 0, _lines = lines; _i < _lines.length; _i++) {
        var line = _lines[_i];

        if (typeof line === 'string') {
          var unescaped = this.unescape(line);
          var parsed = this.parseAnsi(unescaped);
          this.args.output.push(parsed);
          continue;
        }

        this.args.output.push(line);
      }
    }
  }]);

  return Console;
}(_View2.View);

exports.Console = Console;
  })();
});

require.register("subspace-console/Path.js", function(exports, require, module) {
  require = __makeRelativeRequire(require, {}, "subspace-console");
  (function() {
    "use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Path = void 0;

var _Task = require("subspace-console/Task");

var Path = {};
exports.Path = Path;
  })();
});

require.register("subspace-console/Task.js", function(exports, require, module) {
  require = __makeRelativeRequire(require, {}, "subspace-console");
  (function() {
    "use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Task = void 0;

var _Bindable = require("curvature/base/Bindable");

var _Mixin = require("curvature/base/Mixin");

var _Target = require("./mixin/Target");

var _TaskSignals = require("./mixin/TaskSignals");

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var taskId = 0;
var target = Symbol('target');
var Accept = Symbol('accept');
var Reject = Symbol('reject');
var Execute = Symbol('execute');

var Task = /*#__PURE__*/function (_Mixin$with) {
  _inherits(Task, _Mixin$with);

  var _super = _createSuper(Task);

  function Task() {
    var _this;

    var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var prev = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var term = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

    _classCallCheck(this, Task);

    _this = _super.call(this);

    _defineProperty(_assertThisInitialized(_this), "title", 'Generic Task');

    _defineProperty(_assertThisInitialized(_this), "prompt", '::');

    _this.args = args;
    _this.prev = prev;
    _this.term = term;
    _this.status = -1;
    _this.thread = new Promise(function (accept, reject) {
      _this[Accept] = accept;
      _this[Reject] = reject;
    });
    _this.id = taskId++;
    return _possibleConstructorReturn(_this, _assertThisInitialized(_this));
  }

  _createClass(Task, [{
    key: "then",
    value: function then(callback) {
      return this.thread.then(callback);
    }
  }, {
    key: "catch",
    value: function _catch(callback) {
      return this.thread["catch"](callback);
    }
  }, {
    key: "finally",
    value: function _finally(callback) {
      return this.thread["finally"](callback);
    }
  }, {
    key: "print",
    value: function print(detail) {
      this.dispatchEvent(new CustomEvent('output', {
        detail: detail
      }));
    }
  }, {
    key: "printErr",
    value: function printErr(detail) {
      this.dispatchEvent(new CustomEvent('error', {
        detail: detail
      }));
    }
  }, {
    key: "write",
    value: function write(line) {
      return this.main(line);
    }
  }, {
    key: "signal",
    value: function signal(signalName) {
      if (this["signal::".concat(signalName)]) {
        this["signal::".concat(signalName)]();
      }

      switch (signalName) {
        case 'close':
          if (this.dispatchEvent(new CustomEvent('close'))) {
            this.status > 0 ? this[Reject]() : this[Accept]();
          }

          break;

        case 'kill':
          this.status > 0 ? this[Reject]() : this[Accept]();
          break;
      }
    }
  }, {
    key: "execute",
    value: function execute() {
      return this[Execute](this.prev);
    }
  }, {
    key: Execute,
    value: function value() {
      var _this2 = this;

      var onOutputEvent = function onOutputEvent(_ref) {
        var detail = _ref.detail;
        return _this2.write(detail);
      };

      var init = this.init.apply(this, _toConsumableArray(this.args));
      var prev = this.prev;

      if (prev) {
        prev.addEventListener('output', onOutputEvent);
      }

      if (!(init instanceof Promise)) {
        init = Promise.resolve(init);
      }

      if (prev) {
        prev[Execute]();
        return Promise.allSettled([prev, init])["finally"](function () {
          prev.then(function (r) {
            return _this2[Accept](r);
          });
          prev["catch"](function (e) {
            return _this2[Reject](r);
          });
          prev.removeEventListener('output', onOutputEvent);
          return _this2.done();
        });
      } else {
        return Promise.allSettled([init]).then(function (result) {
          try {
            _this2.main(undefined);

            _this2[Accept]();
          } catch (_unused) {
            _this2[Reject]();
          }

          _this2.done();
        });
      }
    }
  }, {
    key: "init",
    value: function init() {}
  }, {
    key: "main",
    value: function main() {
      var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    }
  }, {
    key: "done",
    value: function done(results) {
      return this.status;
    }
  }]);

  return Task;
}(_Mixin.Mixin["with"](_Target.Target, _TaskSignals.TaskSignals));

exports.Task = Task;
  })();
});

require.register("subspace-console/ansi/Colors255.js", function(exports, require, module) {
  require = __makeRelativeRequire(require, {}, "subspace-console");
  (function() {
    "use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Colors255 = void 0;
var Colors255 = {
  "0": {
    "r": 0,
    "g": 0,
    "b": 0
  },
  "1": {
    "r": 128,
    "g": 0,
    "b": 0
  },
  "2": {
    "r": 0,
    "g": 128,
    "b": 0
  },
  "3": {
    "r": 128,
    "g": 128,
    "b": 0
  },
  "4": {
    "r": 0,
    "g": 0,
    "b": 128
  },
  "5": {
    "r": 128,
    "g": 0,
    "b": 128
  },
  "6": {
    "r": 0,
    "g": 128,
    "b": 128
  },
  "7": {
    "r": 192,
    "g": 192,
    "b": 192
  },
  "8": {
    "r": 128,
    "g": 128,
    "b": 128
  },
  "9": {
    "r": 255,
    "g": 0,
    "b": 0
  },
  "10": {
    "r": 0,
    "g": 255,
    "b": 0
  },
  "11": {
    "r": 255,
    "g": 255,
    "b": 0
  },
  "12": {
    "r": 0,
    "g": 0,
    "b": 255
  },
  "13": {
    "r": 255,
    "g": 0,
    "b": 255
  },
  "14": {
    "r": 0,
    "g": 255,
    "b": 255
  },
  "15": {
    "r": 255,
    "g": 255,
    "b": 255
  },
  "16": {
    "r": 0,
    "g": 0,
    "b": 0
  },
  "17": {
    "r": 0,
    "g": 0,
    "b": 95
  },
  "18": {
    "r": 0,
    "g": 0,
    "b": 135
  },
  "19": {
    "r": 0,
    "g": 0,
    "b": 175
  },
  "20": {
    "r": 0,
    "g": 0,
    "b": 215
  },
  "21": {
    "r": 0,
    "g": 0,
    "b": 255
  },
  "22": {
    "r": 0,
    "g": 95,
    "b": 0
  },
  "23": {
    "r": 0,
    "g": 95,
    "b": 95
  },
  "24": {
    "r": 0,
    "g": 95,
    "b": 135
  },
  "25": {
    "r": 0,
    "g": 95,
    "b": 175
  },
  "26": {
    "r": 0,
    "g": 95,
    "b": 215
  },
  "27": {
    "r": 0,
    "g": 95,
    "b": 255
  },
  "28": {
    "r": 0,
    "g": 135,
    "b": 0
  },
  "29": {
    "r": 0,
    "g": 135,
    "b": 95
  },
  "30": {
    "r": 0,
    "g": 135,
    "b": 135
  },
  "31": {
    "r": 0,
    "g": 135,
    "b": 175
  },
  "32": {
    "r": 0,
    "g": 135,
    "b": 215
  },
  "33": {
    "r": 0,
    "g": 135,
    "b": 255
  },
  "34": {
    "r": 0,
    "g": 175,
    "b": 0
  },
  "35": {
    "r": 0,
    "g": 175,
    "b": 95
  },
  "36": {
    "r": 0,
    "g": 175,
    "b": 135
  },
  "37": {
    "r": 0,
    "g": 175,
    "b": 175
  },
  "38": {
    "r": 0,
    "g": 175,
    "b": 215
  },
  "39": {
    "r": 0,
    "g": 175,
    "b": 255
  },
  "40": {
    "r": 0,
    "g": 215,
    "b": 0
  },
  "41": {
    "r": 0,
    "g": 215,
    "b": 95
  },
  "42": {
    "r": 0,
    "g": 215,
    "b": 135
  },
  "43": {
    "r": 0,
    "g": 215,
    "b": 175
  },
  "44": {
    "r": 0,
    "g": 215,
    "b": 215
  },
  "45": {
    "r": 0,
    "g": 215,
    "b": 255
  },
  "46": {
    "r": 0,
    "g": 255,
    "b": 0
  },
  "47": {
    "r": 0,
    "g": 255,
    "b": 95
  },
  "48": {
    "r": 0,
    "g": 255,
    "b": 135
  },
  "49": {
    "r": 0,
    "g": 255,
    "b": 175
  },
  "50": {
    "r": 0,
    "g": 255,
    "b": 215
  },
  "51": {
    "r": 0,
    "g": 255,
    "b": 255
  },
  "52": {
    "r": 95,
    "g": 0,
    "b": 0
  },
  "53": {
    "r": 95,
    "g": 0,
    "b": 95
  },
  "54": {
    "r": 95,
    "g": 0,
    "b": 135
  },
  "55": {
    "r": 95,
    "g": 0,
    "b": 175
  },
  "56": {
    "r": 95,
    "g": 0,
    "b": 215
  },
  "57": {
    "r": 95,
    "g": 0,
    "b": 255
  },
  "58": {
    "r": 95,
    "g": 95,
    "b": 0
  },
  "59": {
    "r": 95,
    "g": 95,
    "b": 95
  },
  "60": {
    "r": 95,
    "g": 95,
    "b": 135
  },
  "61": {
    "r": 95,
    "g": 95,
    "b": 175
  },
  "62": {
    "r": 95,
    "g": 95,
    "b": 215
  },
  "63": {
    "r": 95,
    "g": 95,
    "b": 255
  },
  "64": {
    "r": 95,
    "g": 135,
    "b": 0
  },
  "65": {
    "r": 95,
    "g": 135,
    "b": 95
  },
  "66": {
    "r": 95,
    "g": 135,
    "b": 135
  },
  "67": {
    "r": 95,
    "g": 135,
    "b": 175
  },
  "68": {
    "r": 95,
    "g": 135,
    "b": 215
  },
  "69": {
    "r": 95,
    "g": 135,
    "b": 255
  },
  "70": {
    "r": 95,
    "g": 175,
    "b": 0
  },
  "71": {
    "r": 95,
    "g": 175,
    "b": 95
  },
  "72": {
    "r": 95,
    "g": 175,
    "b": 135
  },
  "73": {
    "r": 95,
    "g": 175,
    "b": 175
  },
  "74": {
    "r": 95,
    "g": 175,
    "b": 215
  },
  "75": {
    "r": 95,
    "g": 175,
    "b": 255
  },
  "76": {
    "r": 95,
    "g": 215,
    "b": 0
  },
  "77": {
    "r": 95,
    "g": 215,
    "b": 95
  },
  "78": {
    "r": 95,
    "g": 215,
    "b": 135
  },
  "79": {
    "r": 95,
    "g": 215,
    "b": 175
  },
  "80": {
    "r": 95,
    "g": 215,
    "b": 215
  },
  "81": {
    "r": 95,
    "g": 215,
    "b": 255
  },
  "82": {
    "r": 95,
    "g": 255,
    "b": 0
  },
  "83": {
    "r": 95,
    "g": 255,
    "b": 95
  },
  "84": {
    "r": 95,
    "g": 255,
    "b": 135
  },
  "85": {
    "r": 95,
    "g": 255,
    "b": 175
  },
  "86": {
    "r": 95,
    "g": 255,
    "b": 215
  },
  "87": {
    "r": 95,
    "g": 255,
    "b": 255
  },
  "88": {
    "r": 135,
    "g": 0,
    "b": 0
  },
  "89": {
    "r": 135,
    "g": 0,
    "b": 95
  },
  "90": {
    "r": 135,
    "g": 0,
    "b": 135
  },
  "91": {
    "r": 135,
    "g": 0,
    "b": 175
  },
  "92": {
    "r": 135,
    "g": 0,
    "b": 215
  },
  "93": {
    "r": 135,
    "g": 0,
    "b": 255
  },
  "94": {
    "r": 135,
    "g": 95,
    "b": 0
  },
  "95": {
    "r": 135,
    "g": 95,
    "b": 95
  },
  "96": {
    "r": 135,
    "g": 95,
    "b": 135
  },
  "97": {
    "r": 135,
    "g": 95,
    "b": 175
  },
  "98": {
    "r": 135,
    "g": 95,
    "b": 215
  },
  "99": {
    "r": 135,
    "g": 95,
    "b": 255
  },
  "100": {
    "r": 135,
    "g": 135,
    "b": 0
  },
  "101": {
    "r": 135,
    "g": 135,
    "b": 95
  },
  "102": {
    "r": 135,
    "g": 135,
    "b": 135
  },
  "103": {
    "r": 135,
    "g": 135,
    "b": 175
  },
  "104": {
    "r": 135,
    "g": 135,
    "b": 215
  },
  "105": {
    "r": 135,
    "g": 135,
    "b": 255
  },
  "106": {
    "r": 135,
    "g": 175,
    "b": 0
  },
  "107": {
    "r": 135,
    "g": 175,
    "b": 95
  },
  "108": {
    "r": 135,
    "g": 175,
    "b": 135
  },
  "109": {
    "r": 135,
    "g": 175,
    "b": 175
  },
  "110": {
    "r": 135,
    "g": 175,
    "b": 215
  },
  "111": {
    "r": 135,
    "g": 175,
    "b": 255
  },
  "112": {
    "r": 135,
    "g": 215,
    "b": 0
  },
  "113": {
    "r": 135,
    "g": 215,
    "b": 95
  },
  "114": {
    "r": 135,
    "g": 215,
    "b": 135
  },
  "115": {
    "r": 135,
    "g": 215,
    "b": 175
  },
  "116": {
    "r": 135,
    "g": 215,
    "b": 215
  },
  "117": {
    "r": 135,
    "g": 215,
    "b": 255
  },
  "118": {
    "r": 135,
    "g": 255,
    "b": 0
  },
  "119": {
    "r": 135,
    "g": 255,
    "b": 95
  },
  "120": {
    "r": 135,
    "g": 255,
    "b": 135
  },
  "121": {
    "r": 135,
    "g": 255,
    "b": 175
  },
  "122": {
    "r": 135,
    "g": 255,
    "b": 215
  },
  "123": {
    "r": 135,
    "g": 255,
    "b": 255
  },
  "124": {
    "r": 175,
    "g": 0,
    "b": 0
  },
  "125": {
    "r": 175,
    "g": 0,
    "b": 95
  },
  "126": {
    "r": 175,
    "g": 0,
    "b": 135
  },
  "127": {
    "r": 175,
    "g": 0,
    "b": 175
  },
  "128": {
    "r": 175,
    "g": 0,
    "b": 215
  },
  "129": {
    "r": 175,
    "g": 0,
    "b": 255
  },
  "130": {
    "r": 175,
    "g": 95,
    "b": 0
  },
  "131": {
    "r": 175,
    "g": 95,
    "b": 95
  },
  "132": {
    "r": 175,
    "g": 95,
    "b": 135
  },
  "133": {
    "r": 175,
    "g": 95,
    "b": 175
  },
  "134": {
    "r": 175,
    "g": 95,
    "b": 215
  },
  "135": {
    "r": 175,
    "g": 95,
    "b": 255
  },
  "136": {
    "r": 175,
    "g": 135,
    "b": 0
  },
  "137": {
    "r": 175,
    "g": 135,
    "b": 95
  },
  "138": {
    "r": 175,
    "g": 135,
    "b": 135
  },
  "139": {
    "r": 175,
    "g": 135,
    "b": 175
  },
  "140": {
    "r": 175,
    "g": 135,
    "b": 215
  },
  "141": {
    "r": 175,
    "g": 135,
    "b": 255
  },
  "142": {
    "r": 175,
    "g": 175,
    "b": 0
  },
  "143": {
    "r": 175,
    "g": 175,
    "b": 95
  },
  "144": {
    "r": 175,
    "g": 175,
    "b": 135
  },
  "145": {
    "r": 175,
    "g": 175,
    "b": 175
  },
  "146": {
    "r": 175,
    "g": 175,
    "b": 215
  },
  "147": {
    "r": 175,
    "g": 175,
    "b": 255
  },
  "148": {
    "r": 175,
    "g": 215,
    "b": 0
  },
  "149": {
    "r": 175,
    "g": 215,
    "b": 95
  },
  "150": {
    "r": 175,
    "g": 215,
    "b": 135
  },
  "151": {
    "r": 175,
    "g": 215,
    "b": 175
  },
  "152": {
    "r": 175,
    "g": 215,
    "b": 215
  },
  "153": {
    "r": 175,
    "g": 215,
    "b": 255
  },
  "154": {
    "r": 175,
    "g": 255,
    "b": 0
  },
  "155": {
    "r": 175,
    "g": 255,
    "b": 95
  },
  "156": {
    "r": 175,
    "g": 255,
    "b": 135
  },
  "157": {
    "r": 175,
    "g": 255,
    "b": 175
  },
  "158": {
    "r": 175,
    "g": 255,
    "b": 215
  },
  "159": {
    "r": 175,
    "g": 255,
    "b": 255
  },
  "160": {
    "r": 215,
    "g": 0,
    "b": 0
  },
  "161": {
    "r": 215,
    "g": 0,
    "b": 95
  },
  "162": {
    "r": 215,
    "g": 0,
    "b": 135
  },
  "163": {
    "r": 215,
    "g": 0,
    "b": 175
  },
  "164": {
    "r": 215,
    "g": 0,
    "b": 215
  },
  "165": {
    "r": 215,
    "g": 0,
    "b": 255
  },
  "166": {
    "r": 215,
    "g": 95,
    "b": 0
  },
  "167": {
    "r": 215,
    "g": 95,
    "b": 95
  },
  "168": {
    "r": 215,
    "g": 95,
    "b": 135
  },
  "169": {
    "r": 215,
    "g": 95,
    "b": 175
  },
  "170": {
    "r": 215,
    "g": 95,
    "b": 215
  },
  "171": {
    "r": 215,
    "g": 95,
    "b": 255
  },
  "172": {
    "r": 215,
    "g": 135,
    "b": 0
  },
  "173": {
    "r": 215,
    "g": 135,
    "b": 95
  },
  "174": {
    "r": 215,
    "g": 135,
    "b": 135
  },
  "175": {
    "r": 215,
    "g": 135,
    "b": 175
  },
  "176": {
    "r": 215,
    "g": 135,
    "b": 215
  },
  "177": {
    "r": 215,
    "g": 135,
    "b": 255
  },
  "178": {
    "r": 215,
    "g": 175,
    "b": 0
  },
  "179": {
    "r": 215,
    "g": 175,
    "b": 95
  },
  "180": {
    "r": 215,
    "g": 175,
    "b": 135
  },
  "181": {
    "r": 215,
    "g": 175,
    "b": 175
  },
  "182": {
    "r": 215,
    "g": 175,
    "b": 215
  },
  "183": {
    "r": 215,
    "g": 175,
    "b": 255
  },
  "184": {
    "r": 215,
    "g": 215,
    "b": 0
  },
  "185": {
    "r": 215,
    "g": 215,
    "b": 95
  },
  "186": {
    "r": 215,
    "g": 215,
    "b": 135
  },
  "187": {
    "r": 215,
    "g": 215,
    "b": 175
  },
  "188": {
    "r": 215,
    "g": 215,
    "b": 215
  },
  "189": {
    "r": 215,
    "g": 215,
    "b": 255
  },
  "190": {
    "r": 215,
    "g": 255,
    "b": 0
  },
  "191": {
    "r": 215,
    "g": 255,
    "b": 95
  },
  "192": {
    "r": 215,
    "g": 255,
    "b": 135
  },
  "193": {
    "r": 215,
    "g": 255,
    "b": 175
  },
  "194": {
    "r": 215,
    "g": 255,
    "b": 215
  },
  "195": {
    "r": 215,
    "g": 255,
    "b": 255
  },
  "196": {
    "r": 255,
    "g": 0,
    "b": 0
  },
  "197": {
    "r": 255,
    "g": 0,
    "b": 95
  },
  "198": {
    "r": 255,
    "g": 0,
    "b": 135
  },
  "199": {
    "r": 255,
    "g": 0,
    "b": 175
  },
  "200": {
    "r": 255,
    "g": 0,
    "b": 215
  },
  "201": {
    "r": 255,
    "g": 0,
    "b": 255
  },
  "202": {
    "r": 255,
    "g": 95,
    "b": 0
  },
  "203": {
    "r": 255,
    "g": 95,
    "b": 95
  },
  "204": {
    "r": 255,
    "g": 95,
    "b": 135
  },
  "205": {
    "r": 255,
    "g": 95,
    "b": 175
  },
  "206": {
    "r": 255,
    "g": 95,
    "b": 215
  },
  "207": {
    "r": 255,
    "g": 95,
    "b": 255
  },
  "208": {
    "r": 255,
    "g": 135,
    "b": 0
  },
  "209": {
    "r": 255,
    "g": 135,
    "b": 95
  },
  "210": {
    "r": 255,
    "g": 135,
    "b": 135
  },
  "211": {
    "r": 255,
    "g": 135,
    "b": 175
  },
  "212": {
    "r": 255,
    "g": 135,
    "b": 215
  },
  "213": {
    "r": 255,
    "g": 135,
    "b": 255
  },
  "214": {
    "r": 255,
    "g": 175,
    "b": 0
  },
  "215": {
    "r": 255,
    "g": 175,
    "b": 95
  },
  "216": {
    "r": 255,
    "g": 175,
    "b": 135
  },
  "217": {
    "r": 255,
    "g": 175,
    "b": 175
  },
  "218": {
    "r": 255,
    "g": 175,
    "b": 215
  },
  "219": {
    "r": 255,
    "g": 175,
    "b": 255
  },
  "220": {
    "r": 255,
    "g": 215,
    "b": 0
  },
  "221": {
    "r": 255,
    "g": 215,
    "b": 95
  },
  "222": {
    "r": 255,
    "g": 215,
    "b": 135
  },
  "223": {
    "r": 255,
    "g": 215,
    "b": 175
  },
  "224": {
    "r": 255,
    "g": 215,
    "b": 215
  },
  "225": {
    "r": 255,
    "g": 215,
    "b": 255
  },
  "226": {
    "r": 255,
    "g": 255,
    "b": 0
  },
  "227": {
    "r": 255,
    "g": 255,
    "b": 95
  },
  "228": {
    "r": 255,
    "g": 255,
    "b": 135
  },
  "229": {
    "r": 255,
    "g": 255,
    "b": 175
  },
  "230": {
    "r": 255,
    "g": 255,
    "b": 215
  },
  "231": {
    "r": 255,
    "g": 255,
    "b": 255
  },
  "232": {
    "r": 8,
    "g": 8,
    "b": 8
  },
  "233": {
    "r": 18,
    "g": 18,
    "b": 18
  },
  "234": {
    "r": 28,
    "g": 28,
    "b": 28
  },
  "235": {
    "r": 38,
    "g": 38,
    "b": 38
  },
  "236": {
    "r": 48,
    "g": 48,
    "b": 48
  },
  "237": {
    "r": 58,
    "g": 58,
    "b": 58
  },
  "238": {
    "r": 68,
    "g": 68,
    "b": 68
  },
  "239": {
    "r": 78,
    "g": 78,
    "b": 78
  },
  "240": {
    "r": 88,
    "g": 88,
    "b": 88
  },
  "241": {
    "r": 98,
    "g": 98,
    "b": 98
  },
  "242": {
    "r": 108,
    "g": 108,
    "b": 108
  },
  "243": {
    "r": 118,
    "g": 118,
    "b": 118
  },
  "244": {
    "r": 128,
    "g": 128,
    "b": 128
  },
  "245": {
    "r": 138,
    "g": 138,
    "b": 138
  },
  "246": {
    "r": 148,
    "g": 148,
    "b": 148
  },
  "247": {
    "r": 158,
    "g": 158,
    "b": 158
  },
  "248": {
    "r": 168,
    "g": 168,
    "b": 168
  },
  "249": {
    "r": 178,
    "g": 178,
    "b": 178
  },
  "250": {
    "r": 188,
    "g": 188,
    "b": 188
  },
  "251": {
    "r": 198,
    "g": 198,
    "b": 198
  },
  "252": {
    "r": 208,
    "g": 208,
    "b": 208
  },
  "253": {
    "r": 218,
    "g": 218,
    "b": 218
  },
  "254": {
    "r": 228,
    "g": 228,
    "b": 228
  },
  "255": {
    "r": 238,
    "g": 238,
    "b": 238
  }
};
exports.Colors255 = Colors255;
  })();
});

require.register("subspace-console/ansi/Parser.js", function(exports, require, module) {
  require = __makeRelativeRequire(require, {}, "subspace-console");
  (function() {
    "use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Parser = void 0;

var _Actions = require("sixgram/Actions");

var _Parser = require("sixgram/Parser");

var tokens = {
  reset: /\u001b\[(0);?m/,
  graphics: /\u001b\[(\d+);?(\d+)?;?([\d;]*)?./,
  escaped: /\\([^e])/,
  characters: /[\s\S]+?(?=\x1B|$)/
};
var modes = {
  normal: {
    reset: [_Actions.IGNORE, _Actions.ENTER, _Actions.LEAVE],
    escaped: [_Actions.IGNORE, _Actions.ENTER, _Actions.LEAVE],
    graphics: [_Actions.IGNORE, _Actions.ENTER, _Actions.LEAVE],
    characters: [_Actions.INSERT]
  }
};
var Parser = new _Parser.Parser(tokens, modes);
exports.Parser = Parser;
  })();
});

require.register("subspace-console/ansi/Renderer.js", function(exports, require, module) {
  require = __makeRelativeRequire(require, {}, "subspace-console");
  (function() {
    "use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Renderer = void 0;

var _Renderer = require("sixgram/Renderer");

var _pallete = require("./pallete");

var _Colors = require("./Colors255");

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var audio = typeof window.AudioContext === 'function' ? new window.AudioContext() : false;

if (audio) {
  var _gainNode = audio.createGain();

  _gainNode.connect(audio.destination);

  _gainNode.gain.value = 10 * 0.01;
}

var Renderer = /*#__PURE__*/function (_BaseRenderer) {
  _inherits(Renderer, _BaseRenderer);

  var _super = _createSuper(Renderer);

  function Renderer() {
    var _this;

    _classCallCheck(this, Renderer);

    _this = _super.call(this, {
      normal: function normal(chunk, parent) {
        return _this.setGraphicsMode(chunk, parent);
      }
    });

    _defineProperty(_assertThisInitialized(_this), "style", {});

    return _this;
  }

  _createClass(Renderer, [{
    key: "reset",
    value: function reset() {
      for (var _i = 0, _Object$entries = Object.entries(this.style); _i < _Object$entries.length; _i++) {
        var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 1),
            k = _Object$entries$_i[0];

        delete this.style[k];
      }
    }
  }, {
    key: "beep",
    value: function beep() {
      if (!audio) {
        return;
      }

      var oscillator = audio.createOscillator();
      oscillator.connect(gainNode);
      oscillator.frequency.value = 840;
      oscillator.type = "square";
      oscillator.start(audio.currentTime);
      oscillator.stop(audio.currentTime + 200 * 0.001);
    }
  }, {
    key: "setGraphicsMode",
    value: function setGraphicsMode(chunk, parent) {
      if (typeof chunk === 'string') {
        if (chunk === '') {
          return false;
        }

        var styleString = '';

        for (var _i2 = 0, _Object$entries2 = Object.entries(this.style); _i2 < _Object$entries2.length; _i2++) {
          var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i2], 2),
              key = _Object$entries2$_i[0],
              val = _Object$entries2$_i[1];

          styleString += "".concat(key, ": ").concat(val, "; ");
        }

        return "<span class = \"ansi\" style = \"".concat(styleString, "\">").concat(chunk, "</span>");
      }

      if (_typeof(chunk) === 'object') {
        if (chunk.type === 'escaped' && chunk.groups[0] === 'a') {
          this.beep();
        }

        if (chunk.type === 'graphics' || chunk.type === 'reset') {
          for (var g = 0; g < chunk.groups.length; g++) {
            var group = Number(chunk.groups[g]);

            if (chunk.groups[g] === '') {
              return false;
            }

            switch (group) {
              case 0:
                for (var _key in this.style) {
                  delete this.style[_key];
                }

                break;

              case 1:
                this.style['filter'] = 'contrast(1.25)'; // this.style['text-shadow'] = '1px 1px 1px rgba(0,0,0,0.25), 0px 0px 1px rgba(0,0,0,0.125)';

                this.style['font-weight'] = 'bold';
                this.style['opacity'] = 1;
                break;

              case 2:
                this.style['filter'] = 'brightness(0.85)';
                this.style['font-weight'] = 'light';
                this.style['opacity'] = 0.75;
                break;

              case 3:
                this.style['font-style'] = 'italic';
                break;

              case 4:
                this.style['text-decoration'] = 'underline';
                break;

              case 5:
                this.style['animation'] = 'var(--ansiBlink)';
                break;

              case 7:
                this.style['filter'] = 'invert(1)';
                break;

              case 8:
                this.style['filter'] = 'contrast(0.5)';
                this.style['opacity'] = 0.1;
                break;

              case 9:
                this.style['text-decoration'] = 'line-through';
                break;

              case 10:
                this.style['font-family'] = 'var(--base-font))';
                break;

              case 11:
              case 12:
              case 13:
              case 14:
              case 15:
              case 16:
              case 17:
              case 18:
              case 19:
                this.style['font-family'] = "var(--alt-font-no-".concat(group, ")");
                break;

              case 20:
                this.style['font-family'] = 'var(--alt-font-fraktur)';
                this.style['font-size'] = '1.1rem';
                break;

              case 21:
                this.style['font-weight'] = 'initial';
                break;

              case 22:
                this.style['font-weight'] = 'initial';
                break;

              case 23:
                this.style['font-weight'] = 'initial';
                this.style['font-style'] = 'initial';
                break;

              case 24:
                this.style['text-decoration'] = 'none';
                this.style['font-family'] = 'sans-serif';
                this.style['font-size'] = '12pt';
                break;

              case 25:
                this.style['animation'] = 'none';
                break;

              case 26:
                this.style['text-transform'] = 'full-width';
                break;

              case 27:
                this.style['filter'] = 'initial';
                break;

              case 28:
                this.style['opacity'] = 'initial';
                break;

              case 29:
                this.style['text-decoration'] = 'initial';
                break;

              case 30:
                this.style['color'] = _pallete.pallete.black;
                break;

              case 31:
                this.style['color'] = _pallete.pallete.red;
                break;

              case 32:
                this.style['color'] = _pallete.pallete.green;
                break;

              case 33:
                this.style['color'] = _pallete.pallete.yellow;
                break;

              case 34:
                this.style['color'] = _pallete.pallete.blue;
                break;

              case 35:
                this.style['color'] = _pallete.pallete.magenta;
                break;

              case 36:
                this.style['color'] = _pallete.pallete.cyan;
                break;

              case 37:
                this.style['color'] = _pallete.pallete.white;
                break;

              case 38:
                if (chunk.groups[1 + g] == 2) {
                  var _chunk$groups$split = chunk.groups[2 + g].split(';'),
                      _chunk$groups$split2 = _slicedToArray(_chunk$groups$split, 3),
                      rd = _chunk$groups$split2[0],
                      gr = _chunk$groups$split2[1],
                      bl = _chunk$groups$split2[2];

                  this.style['color'] = "rgb(".concat(rd, ",").concat(gr, ",").concat(bl, ")");
                }

                if (chunk.groups[1 + g] == 5) {
                  var _Colors255$Number = _Colors.Colors255[Number(chunk.groups[2 + g])],
                      _rd = _Colors255$Number.r,
                      _gr = _Colors255$Number.g,
                      _bl = _Colors255$Number.b;

                  this.style['color'] = "rgb(".concat(_rd, ",").concat(_gr, ",").concat(_bl, ")");
                }

                g += 2;
                break;

              case 39:
                this.style['color'] = 'var(--fgColor)';
                break;

              case 40:
                this.style['background-color'] = _pallete.pallete.black;
                break;

              case 41:
                this.style['background-color'] = _pallete.pallete.red;
                break;

              case 42:
                this.style['background-color'] = _pallete.pallete.green;
                break;

              case 43:
                this.style['background-color'] = _pallete.pallete.yellow;
                break;

              case 44:
                this.style['background-color'] = _pallete.pallete.blue;
                break;

              case 45:
                this.style['background-color'] = _pallete.pallete.magenta;
                break;

              case 46:
                this.style['background-color'] = _pallete.pallete.cyan;
                break;

              case 47:
                this.style['background-color'] = _pallete.pallete.white;
                break;

              case 48:
                if (chunk.groups[1 + g] == 2) {
                  var _chunk$groups$split3 = chunk.groups[2 + g].split(';'),
                      _chunk$groups$split4 = _slicedToArray(_chunk$groups$split3, 3),
                      _rd2 = _chunk$groups$split4[0],
                      _gr2 = _chunk$groups$split4[1],
                      _bl2 = _chunk$groups$split4[2];

                  this.style['background-color'] = "rgb(".concat(_rd2, ",").concat(_gr2, ",").concat(_bl2, ")");
                }

                if (chunk.groups[1 + g] == 5) {
                  var _Colors255$Number2 = _Colors.Colors255[Number(chunk.groups[2 + g])],
                      _rd3 = _Colors255$Number2.r,
                      _gr3 = _Colors255$Number2.g,
                      _bl3 = _Colors255$Number2.b;

                  this.style['background-color'] = "rgb(".concat(_rd3, ",").concat(_gr3, ",").concat(_bl3, ")");
                }

                g += 2;
                break;

              case 49:
                this.style['background-color'] = 'var(--bgColor)';
                break;

              case 50:
                this.style['text-transform'] = 'initial';
                break;

              case 51:
                this.style['border'] = '1px solid currentColor';
                break;

              case 52:
                this.style['border'] = '1px solid currentColor';
                this.style['border-radius'] = '1em';
                break;

              case 53:
                this.style['text-decoration'] = 'overline';
                break;

              case 54:
                this.style['border'] = 'initial';
                break;

              case 55:
                this.style['border'] = 'initial';
                break;
            }
          }
        }

        return false;
      }
    }
  }]);

  return Renderer;
}(_Renderer.Renderer);

exports.Renderer = Renderer;
  })();
});

require.register("subspace-console/ansi/pallete.js", function(exports, require, module) {
  require = __makeRelativeRequire(require, {}, "subspace-console");
  (function() {
    "use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.pallete = void 0;
var pallete = {
  black: 'var(--ansi-black, #000000)',
  dBlack: 'var(--ansi-black-dark, #343434)',
  bBlack: 'var(--ansi-black-light, #888888)',
  red: 'var(--ansi-red, #c0002c)',
  dRed: 'var(--ansi-red-dark, #4a132b)',
  bRed: 'var(--ansi-red-light, #ff7869)',
  green: 'var(--ansi-green, #80a763)',
  dGreen: 'var(--ansi-green-dark, #326f38)',
  bGreen: 'var(--ansi-green-light, #93d393)',
  yellow: 'var(--ansi-yellow, #e3c651)',
  dYellow: 'var(--ansi-yellow-dark, #baa447)',
  bYellow: 'var(--ansi-yellow-light, #fdc253)',
  blue: 'var(--ansi-blue, #5485c0)',
  dBlue: 'var(--ansi-blue-dark, #38577d)',
  bBlue: 'var(--ansi-blue-light, #77aff2)',
  magenta: 'var(--ansi-magenta, #C61B6E)',
  dMagenta: 'var(--ansi-magenta-dark, #935894)',
  bMagenta: 'var(--ansi-magenta-light, #bf83c0)',
  cyan: 'var(--ansi-cyan, #57c2c0)',
  dCyan: 'var(--ansi-cyan-dark, #2d5695)',
  bCyan: 'var(--ansi-cyan-light, #cef6f5)',
  white: 'var(--ansi-cyan, #e0e0e0)',
  dWhite: 'var(--ansi-cyan-dark, #b0b0b0)',
  bWhite: 'var(--ansi-cyan-light, #ffffff)'
};
exports.pallete = pallete;
  })();
});

require.register("subspace-console/mixin/Target.js", function(exports, require, module) {
  require = __makeRelativeRequire(require, {}, "subspace-console");
  (function() {
    "use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Target = void 0;

var _Mixin = require("curvature/base/Mixin");

var _Target;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var target = Symbol('target');
var index = 0;
var Target = (_Target = {}, _defineProperty(_Target, _Mixin.Mixin.Constructor, function () {
  try {
    this[target] = new EventTarget();
  } catch (error) {
    this[target] = document.createDocumentFragment();
  }

  this[target].x = index++;
}), _defineProperty(_Target, "dispatchEvent", function dispatchEvent() {
  var _this$target;

  (_this$target = this[target]).dispatchEvent.apply(_this$target, arguments);
}), _defineProperty(_Target, "addEventListener", function addEventListener() {
  var _this$target2;

  (_this$target2 = this[target]).addEventListener.apply(_this$target2, arguments);
}), _defineProperty(_Target, "removeEventListener", function removeEventListener() {
  var _this$target3;

  (_this$target3 = this[target]).removeEventListener.apply(_this$target3, arguments);
}), _Target);
exports.Target = Target;
  })();
});

require.register("subspace-console/mixin/TaskSignals.js", function(exports, require, module) {
  require = __makeRelativeRequire(require, {}, "subspace-console");
  (function() {
    "use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TaskSignals = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var TaskSignals = /*#__PURE__*/function () {
  function TaskSignals() {
    _classCallCheck(this, TaskSignals);
  }

  _createClass(TaskSignals, [{
    key: 'signal::kill',
    value: function signalKill() {
      console.log('KILL!');
      this.status > 0 ? this[Reject]() : this[Accept]();
    }
  }, {
    key: 'signal::close',
    value: function signalClose() {
      if (this.dispatchEvent(new CustomEvent('error', {
        detail: detail
      }))) {
        this.status > 0 ? this[Reject]() : this[Accept]();
      }
    }
  }]);

  return TaskSignals;
}();

exports.TaskSignals = TaskSignals;

_defineProperty(TaskSignals, "KILL", 'kill');

_defineProperty(TaskSignals, "CLOSE", 'close');
  })();
});

require.register("subspace-console/view/EchoMessage.js", function(exports, require, module) {
  require = __makeRelativeRequire(require, {}, "subspace-console");
  (function() {
    "use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EchoMessage = void 0;

var _View2 = require("curvature/base/View");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var EchoMessage = /*#__PURE__*/function (_View) {
  _inherits(EchoMessage, _View);

  var _super = _createSuper(EchoMessage);

  function EchoMessage() {
    var _this;

    var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, EchoMessage);

    _this = _super.call(this, args);
    _this.args.prompt = _this.args.prompt || '<<';
    _this.template = "<span>[[prompt]]&nbsp;</span><span class = \"text\">[[message]]</span>";
    return _this;
  }

  return EchoMessage;
}(_View2.View);

exports.EchoMessage = EchoMessage;
  })();
});

require.register("subspace-console/view/MeltingText.js", function(exports, require, module) {
  require = __makeRelativeRequire(require, {}, "subspace-console");
  (function() {
    "use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MeltingText = void 0;

var _View = require("curvature/base/View");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var MeltingText = /*#__PURE__*/function (_BaseView) {
  _inherits(MeltingText, _BaseView);

  var _super = _createSuper(MeltingText);

  function MeltingText(args) {
    var _this;

    _classCallCheck(this, MeltingText);

    _this = _super.call(this, args);
    _this.last = _this.init = Date.now();
    _this.charUp = [// '\u030d', /*     ̍     */		'\u030e', /*     ̎     */		'\u0304', /*     ̄     */		'\u0305', /*     ̅     */
    // '\u033f', /*     ̿     */		'\u0311', /*     ̑     */		'\u0306', /*     ̆     */		'\u0310', /*     ̐     */
    // '\u0352', /*     ͒     */		'\u0357', /*     ͗     */		'\u0351', /*     ͑     */		'\u0307', /*     ̇     */
    // '\u0308', /*     ̈     */		'\u030a', /*     ̊     */		'\u0342', /*     ͂     */		'\u0343', /*     ̓     */
    "\u0344",
    /*     ̈́     */

    /*	'\u034a', /*     ͊     */

    /*	'\u034b', /*     ͋     */

    /*	'\u034c', /*     ͌     */
    "\u0303",
    /*     ̃     */

    /*	'\u0302', /*     ̂     */

    /*	'\u030c', /*     ̌     */

    /*	'\u0350', /*     ͐     */
    "\u0300"
    /*     ̀     */
    //	'\u0301', /*     ́     */		'\u030b', /*     ̋     */		'\u030f', /*     ̏     */
    // '\u0312', /*     ̒     */		'\u0313', /*     ̓     */		'\u0314', /*     ̔     */		'\u033d', /*     ̽     */
    // '\u0309', /*     ̉     */		'\u0363', /*     ͣ     */		'\u0364', /*     ͤ     */		'\u0365', /*     ͥ     */
    // '\u0366', /*     ͦ     */		'\u0367', /*     ͧ     */		'\u0368', /*     ͨ     */		'\u0369', /*     ͩ     */
    // '\u036a', /*     ͪ     */		'\u036b', /*     ͫ     */		'\u036c', /*     ͬ     */		'\u036d', /*     ͭ     */
    // '\u036e', /*     ͮ     */		'\u036f', /*     ͯ     */		'\u033e', /*     ̾     */		'\u035b', /*     ͛     */
    ];
    _this.charMid = ["\u0315",
    /*     ̕     */
    "\u031B",
    /*     ̛     */
    "\u0340",
    /*     ̀     */
    "\u0341",
    /*     ́     */
    "\u0358",
    /*     ͘     */
    "\u0321",
    /*     ̡     */
    "\u0322",
    /*     ̢     */
    "\u0327",
    /*     ̧     */
    "\u0328",
    /*     ̨     */
    "\u0334",
    /*     ̴     */
    "\u0335",
    /*     ̵     */
    "\u0336",
    /*     ̶     */
    "\u034F",
    /*     ͏     */
    "\u035C",
    /*     ͜     */
    "\u035D",
    /*     ͝     */
    "\u035E",
    /*     ͞     */
    "\u035F",
    /*     ͟     */
    "\u0360",
    /*     ͠     */

    /*'\u0362',      ͢     */
    "\u0338",
    /*     ̸     */
    "\u0337",
    /*     ̷     */
    "\u0361"
    /*     ͡     */

    /*'\u0489'     ҉_     */
    ];
    _this.charDown = [// '\u0316', /*     ̖     */		'\u0317', /*     ̗     */		'\u0318', /*     ̘     */		'\u0319', /*     ̙     */
    // '\u0316', /*     ̖     */		'\u0317', /*     ̗     */		'\u0318', /*     ̘     */		'\u0319', /*     ̙     */
    // '\u0320', /*     ̠     */		'\u0324', /*     ̤     */		'\u0325', /*     ̥     */		'\u0326', /*     ̦     */
    // '\u0329', /*     ̩     */		'\u032a', /*     ̪     */		'\u032b', /*     ̫     */		'\u032c', /*     ̬     */
    // '\u032d', /*     ̭     */		'\u032e', /*     ̮     */		'\u032f', /*     ̯     */		'\u0330', /*     ̰     */
    // '\u0331', /*     ̱     */		'\u0332', /*     ̲     */		'\u0333', /*     ̳     */		'\u0339', /*     ̹     */
    "\u033A",
    /*     ̺     */
    "\u033B",
    /*     ̻     */
    "\u033C",
    /*     ̼     */
    "\u0345"
    /*     ͅ     */
    //'\u0347', /*     ͇     */		'\u0348', /*     ͈     */		'\u0349', /*     ͉     */		'\u034d', /*     ͍     */
    //'\u034e', /*     ͎     */		'\u0353', /*     ͓     */		'\u0354', /*     ͔     */		'\u0355', /*     ͕     */
    // '\u0356', /*     ͖     */		'\u0359', /*     ͙     */		'\u035a', /*     ͚     */		'\u0323' /*     ̣     */
    ];
    _this.template = "\n\t\t\t<div cv-bind = \"output\" class = \"melting\"></div>\n\t\t";
    _this.args.input = "Magic is no more than the art of employing consciously invisible means to produce visible effects. Will, love, and imagination are magic powers that everyone possesses; and whoever knows how to develop them to their fullest extent is a magician. Magic has but one dogma, namely, that the seen is the measure of the unseen\n"; // this.args.input      = 'anything';

    _this.args.output = 'uh.';
    _this.corruptors = [];
    _this.maxMaxCorrupt = 25;
    _this.maxCorrupt = 0;
    _this.type = '';

    _this.onFrame(function () {
      _this.typewriter(_this.args.input);
    });

    _this.onInterval(16 * 4, function () {
      var selection = window.getSelection();

      if (selection.anchorOffset !== selection.focusOffset) {
        return;
      }

      if (selection.anchorNode !== selection.focusNode) {
        return;
      }

      _this.args.output = _this.corrupt(_this.type); // this.args.output = this.type;
    });

    _this.args.bindTo('input', function (v) {
      _this.type = '';
      _this.corruptors = [];
    });

    return _this;
  }

  _createClass(MeltingText, [{
    key: "age",
    value: function age() {
      return this.init - Date.now();
    }
  }, {
    key: "lastFrame",
    value: function lastFrame() {
      return this.last - Date.now();
    }
  }, {
    key: "corrupt",
    value: function corrupt(v) {
      if (v.length * 1.15 < this.args.input.length) {
        return this.type;
      }

      var chars = v.split('');

      var random = function random(x) {
        return parseInt(Math.random() * x);
      };

      if (random(1024) < 256 && this.maxCorrupt < this.maxMaxCorrupt) {
        this.maxCorrupt += 5;
      }

      for (var _i in chars) {
        this.corruptors[_i] = this.corruptors[_i] || [];

        if (chars[_i].match(/\W/)) {
          continue;
        }

        var charSets = [// this.charDown // Melt Slow
        this.charDown, this.charMid // Melt
        // this.charDown, this.charUp,   this.charMid, // Boil
        // this.charMid, this.charUp, // Burn
        // this.charMid // Simmer
        // this.charUp // Rain
        ];
        var charSet = charSets[random(charSets.length)];

        if (random(8192) < 1) {
          this.corruptors[_i].unshift(charSet[random(charSet.length)]);
        }

        if (this.corruptors[_i].length < this.maxCorrupt) {
          this.corruptors[_i].unshift(charSet[random(charSet.length)]);
        }

        if (random(2048) < 1 && this.maxCorrupt > 25) {
          this.corruptors[_i].splice(5 * random(5));
        }

        this.corruptors[_i].push(this.corruptors[_i].shift());
      }

      for (var i in chars) {
        if (this.corruptors[i]) {
          chars[i] += this.corruptors[i].join('');
        }
      }

      return chars.join('');
    }
  }, {
    key: "typewriter",
    value: function typewriter(v) {
      this.type = this.type || '';

      if (this.type !== v) {
        this.type += v.substr(this.type.length, 1);
        this.onTimeout(150, function () {
          var max = window.scrollY + window.innerHeight;

          if (document.body.scrollHeight > max) {
            window.scrollTo({
              top: document.body.scrollHeight,
              left: 0,
              behavior: 'smooth'
            });
          }
        });
      } else {
        return true;
      }

      return false;
    }
  }]);

  return MeltingText;
}(_View.View);

exports.MeltingText = MeltingText;
  })();
});
require.register("BackdropPalette.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BackdropPalette = void 0;
var _MarbleGarden = require("backdrop/MarbleGarden");
var _ProtoLabrynth = require("backdrop/ProtoLabrynth");
var _Industrial = require("backdrop/Industrial");
var _MysticCave = require("backdrop/MysticCave");
var _WestSideCloudy = require("backdrop/WestSideCloudy");
var _WestSideDay = require("backdrop/WestSideDay");
var _WestSide = require("backdrop/WestSide");
var _AngelIsland = require("backdrop/AngelIsland");
var _Wood = require("backdrop/Wood");
var _Underground = require("backdrop/Underground");
var _Moon = require("backdrop/Moon");
var _SouthRidge = require("backdrop/SouthRidge");
var _MushroomHill = require("backdrop/MushroomHill");
var _IceCap = require("backdrop/IceCap");
var _City = require("backdrop/City");
var _DarkClouds = require("backdrop/DarkClouds");
var _Overcast = require("backdrop/Overcast");
var _ScrapBrainDark = require("backdrop/ScrapBrainDark");
var _PhazonMines = require("backdrop/PhazonMines");
var _Desert = require("backdrop/Desert");
const BackdropPalette = {
  'west-side-cloudy': _WestSideCloudy.WestSideCloudy,
  'west-side-day': _WestSideDay.WestSideDay,
  'west-side': _WestSide.WestSide,
  'angel-island': _AngelIsland.AngelIsland,
  'wood': _Wood.Wood,
  'moon': _Moon.Moon,
  'south-ridge': _SouthRidge.SouthRidge,
  'proto-labrynth': _ProtoLabrynth.ProtoLabrynth,
  'marble-garden': _MarbleGarden.MarbleGarden,
  'industrial': _Industrial.Industrial,
  'mystic-cave': _MysticCave.MysticCave,
  'underground': _Underground.Underground,
  'mushroom-hill': _MushroomHill.MushroomHill,
  'ice-cap': _IceCap.IceCap,
  'city': _City.City,
  'dark-clouds': _DarkClouds.DarkClouds,
  'overcast': _Overcast.Overcast,
  'scrap-brain-dark': _ScrapBrainDark.ScrapBrainDark,
  'phazon-mines': _PhazonMines.PhazonMines,
  'desert': _Desert.Desert
};
exports.BackdropPalette = BackdropPalette;
});

;require.register("Classifier.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Classifier = void 0;
var _Mixin = require("curvature/base/Mixin");
var _EventTargetMixin = require("curvature/mixin/EventTargetMixin");
class Classifier extends _Mixin.Mixin.with(_EventTargetMixin.EventTargetMixin) {
  constructor(criteria) {
    let comparator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : (criterion, item) => item instanceof criterion;
    super();
    this.compare = comparator;
    this.index = new Map();
    this.reverseIndex = new Map();
    for (const i in criteria) {
      this.index.set(criteria[i], new Set());
    }
  }
  add(object) {
    const before = new CustomEvent('adding', {
      detail: {
        object
      }
    });
    if (!this.dispatchEvent(before)) {
      return;
    }
    if (!this.reverseIndex.has(object)) {
      this.reverseIndex.set(object, new Set());
    }
    const reverseIndex = this.reverseIndex.get(object);
    const indexes = new Set();
    for (const [index, list] of this.index.entries()) {
      if (this.compare(index, object)) {
        indexes.add(index);
        reverseIndex.add(index);
        list.add(object);
      }
    }
    const after = new CustomEvent('added', {
      detail: {
        object,
        indexes
      }
    });
    this.dispatchEvent(after);
  }
  remove(object) {
    if (!this.reverseIndex.has(object)) {
      return;
    }
    const before = new CustomEvent('removing', {
      detail: {
        object
      }
    });
    if (!this.dispatchEvent(before)) {
      return;
    }

    // const indexes = new Set;
    const reverseIndex = this.reverseIndex.get(object);
    for (const index of reverseIndex) {
      this.index.get(index).delete(object);
      reverseIndex.delete(index);
    }

    // for(const [index,list] of this.index.entries())
    // {
    // 	if(this.compare(index, object))
    // 	{
    // 		indexes.add(index);

    // 		list.delete(object);
    // 	}
    // }

    const after = new CustomEvent('added', {
      detail: {
        object,
        reverseIndex
      }
    });
    this.dispatchEvent(after);
  }
  clear() {
    this.reverseIndex.clear();
    this.index.clear();
  }
  get(key) {
    return this.index.get(key);
  }
  count(key) {
    return this.index.has(key) && this.get(key).size;
  }
  has(key) {
    return !!this.count(key);
  }
}
exports.Classifier = Classifier;
});

;require.register("Menu/ButtonSelect.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ButtonSelect = void 0;
var _View = require("curvature/base/View");
var _CharacterString = require("../ui/CharacterString");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class ButtonSelect extends _View.View {
  constructor() {
    super(...arguments);
    _defineProperty(this, "template", '<div class = "button-select">[[prompt]] [[_button]] <button cv-on = "click:remove">exit</button></div>');
    // buttons  = ['⓿', '❶', '❷', '❸', '❹', '❺', '❻', '❼', '❽', '❾', '❿', '⓫', '↑', '↓', '←', '→'];
    _defineProperty(this, "buttons", ['⓿', '❶', '❷', '❸', '❹', '❺', '❽', '❾', '❽', '❿', '⓫', null, '↑', '↓', '←', '→']);
  }
  onRendered(event) {
    this.args.prompt = new _CharacterString.CharacterString({
      value: 'Select a button!',
      font: 'small-menu-font'
    });
    this.args._button = new _CharacterString.CharacterString({
      value: '',
      font: 'small-menu-font'
    });
  }
  input(controller) {
    for (const b in controller.buttons) {
      if (b > 100) {
        continue;
      }
      const button = controller.buttons[b];
      if (!button.pressure) {
        continue;
      }
      this.args._button.args.value = this.buttons[b];
      this.args.button = b;
    }
  }
}
exports.ButtonSelect = ButtonSelect;
});

;require.register("Menu/CharacterPreview.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CharacterPreview = void 0;
var _View = require("curvature/base/View");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class CharacterPreview extends _View.View {
  constructor() {
    super(...arguments);
    _defineProperty(this, "preserve", true);
    _defineProperty(this, "template", `<div class = "character-preview" data-character = "[[setting]]">
	<div class = "character"></div>
	<div class = "emeralds" cv-each = "emeralds:emerald">
		<img style = "--x:[[emerald.x]];--y:[[emerald.y]];" src = "/Sonic/emerald-[[emerald.type|suffix]][[emerald.color]]-mini.png" />
	</div>
	<div class = "rings"></div>
	<div class = "score"></div>
</div>`);
  }
  onAttached() {
    const type = 'super';

    // const emeralds = this.args.emeralds = [
    //       {x: 0, y: 0, type, color: 'red-alt'}
    // 	, {x: 0, y: 0, type, color: 'yellow' }
    // 	, {x: 0, y: 0, type, color: 'green'  }
    // 	, {x: 0, y: 0, type, color: 'cyan'   }
    // 	, {x: 0, y: 0, type, color: 'white'  } //
    // 	, {x: 0, y: 0, type, color: 'purple' } //
    // 	, {x: 0, y: 0, type, color: 'pink'   } //
    // ];

    const emeralds = this.args.emeralds = [];
    if (this.parent && this.parent.currentSave) for (const storedEmerald of this.parent.currentSave.emeralds) {
      // this.args.emeralds.push({x: 0, y: 0, type, color: storedEmerald});
      this.args.emeralds.push({
        x: 0,
        y: 0,
        color: storedEmerald
      });
    }
    const spacing = emeralds.length;
    this.onFrame(() => {
      let e = 0;
      if (spacing) for (const emerald of emeralds) {
        const time = Date.now() / 400;
        const roll = e++ * (Math.PI * 2) / spacing + time;
        emerald.x = Math.cos(roll);
        emerald.y = Math.sin(roll);
      }
    });
  }
  suffix(type) {
    return type ? `${type}-` : ``;
  }
}
exports.CharacterPreview = CharacterPreview;
});

;require.register("Menu/DemoMenu.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DemoMenu = void 0;
var _ReplayDatabase = require("../replay/ReplayDatabase");
var _Replay = require("../replay/Replay");
var _Router = require("curvature/base/Router");
const startDemo = function (parent, menu, replay) {
  let offset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
  parent.reset();
  parent.replayFrames = replay.getIndexedFrames();
  parent.replayStart = parent.replayFrames.get(offset || replay.firstFrame) || {};
  parent.replay = replay;
  parent.maxReplayFrame = replay.lastFrame;
  parent.replayOffset = -1 + replay.firstFrame + offset;
  _Router.Router.setQuery('demo', replay.uuid);
  parent.loadMap({
    mapUrl: replay.map
  }).then(() => {
    parent.args.paused = true;
    parent.playback();
  });
};
const loadChildren = function (parent, menu) {
  let offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  return _ReplayDatabase.ReplayDatabase.open('replays', 3).then(database => {
    const store = 'replays';
    const limit = 10;
    const type = _Replay.Replay;
    const direction = 'prev';
    let index = 'id';
    let range = [];
    if (parent.baseMap) {
      index = 'map-id';
      range = [[parent.baseMap, 0], [parent.baseMap, Infinity]];
    }
    const query = {
      store,
      index,
      direction,
      limit,
      offset,
      type,
      range
    };
    const children = {};
    if (!offset) {
      children['Import'] = {
        callback: () => {
          const fileInput = document.createElement('input');
          fileInput.setAttribute('type', 'file');
          fileInput.click();
          fileInput.addEventListener('change', event => {
            const files = event.target.files;
            for (const file of files) file.text().then(json => {
              const skel = JSON.parse(json);
              delete skel.id;
              delete skel.uuid;
              const replay = _Replay.Replay.from(skel);
              delete replay.id;
              database.insert('replays', replay);
            });
          }, {
            once: true
          });
        }
      };
    }
    return database.select(query).each(replay => {
      const duration = replay.lastFrame - replay.firstFrame;

      // if(duration < 120)
      // {
      // 	database.delete('replays', replay);
      // }

      const min = String(Math.trunc(duration / (60 * 60))).padStart(1, '0');
      const sec = String(Math.trunc(duration / 60) % 60).padStart(2, '0');
      const durationLabel = `${min}:${sec}`;
      let childName = `${durationLabel}] ${new Date(replay.created).toLocaleString('en-US')}`;
      let subtext = replay.map;
      if (replay.name) {
        childName = durationLabel + '] ' + replay.name;
        subtext = new Date(replay.created).toLocaleString('en-US') + ' ' + replay.map;
      }
      children[childName] = {
        subtext,
        color: replay.color,
        children: {
          'Replay': {
            callback: () => startDemo(parent, menu, replay)
          },
          'Skip to': {
            children: () => {
              const subchildren = {};
              for (const offset of replay.keyFrames) {
                const min = String(Math.trunc(offset / (60 * 60))).padStart(2, '0');
                const sec = String(Math.trunc(offset / 60) % 60).padStart(2, '0');
                const time = `${min}:${sec}`;
                subchildren[time] = {
                  callback: () => startDemo(parent, menu, replay, offset)
                };
              }
              console.log(subchildren);
              return subchildren;
            }
          },
          'Options': {
            children: {
              Banners: {
                input: 'boolean',
                revert: () => parent.args.replayBanners = true,
                set: value => parent.args.replayBanners = value,
                get: () => parent.args.replayBanners
              },
              'Quick Exit': {
                input: 'boolean',
                revert: () => parent.args.replayQuickExit = false,
                set: value => parent.args.replayQuickExit = value,
                get: () => parent.args.replayQuickExit
              }
            }
          },
          'Export': {
            callback: () => {
              const fileContents = new Blob([JSON.stringify(replay)], {
                type: 'text/json'
              });
              const fileUrl = URL.createObjectURL(fileContents);
              const fileLink = document.createElement('a');
              fileLink.href = fileUrl;
              fileLink.download = `${replay.name || replay.uuid}.json`;
              fileLink.click();
            }
          },
          'Rename': {
            children: {
              name: {
                input: 'string',
                set: value => {
                  replay.name = value;
                  database.update('replays', replay);
                },
                get: () => replay.name
              },
              color: {
                input: 'string',
                set: value => {
                  replay.color = value;
                  database.update('replays', replay);
                },
                get: () => replay.color
              }
            }
          },
          'Delete': {
            children: {
              No: {
                callback: () => {
                  menu.back(1);
                }
              },
              Yes: {
                callback: () => {
                  delete children[childName];
                  database.delete('replays', replay);
                  // database.select({query, limit: 1, offset: -1 + limit + offset}).each(replay => {
                  // 	children[ childName ];
                  // });
                  menu.back(2);
                }
              }
            }
          }
        }
      };
    }).then(results => {
      if (results.mapped) {
        children['Next ' + limit] = {
          children: () => loadChildren(parent, menu, offset + limit)
        };
      }
      return children;
    });
  });
};
const DemoMenu = {
  subtext: 'View error log.',
  children: loadChildren
};
exports.DemoMenu = DemoMenu;
});

require.register("Menu/MainMenu.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MainMenu = void 0;
var _Bindable = require("curvature/base/Bindable");
var _Router = require("curvature/base/Router");
var _Bgm = require("../audio/Bgm");
var _Card = require("../intro/Card");
var _Cylinder = require("../effects/Cylinder");
var _Pinch = require("../effects/Pinch");
var _Twist = require("../effects/Twist");
var _Menu = require("./Menu");
var _SavestateMenu = require("./SavestateMenu");
var _SettingsMenu = require("./SettingsMenu");
var _TileMap = require("../tileMap/TileMap");
var _CharacterString = require("../ui/CharacterString");
var _CharacterPreview = require("./CharacterPreview");
var _ZoneSuffix = require("./ZoneSuffix");
var _Lobby = require("../network/Lobby");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class MainMenu extends _Menu.Menu {
  constructor(args, parent) {
    super(args, parent);
    _defineProperty(this, "template", require('./main-menu.html'));
    if (!this.args.initialPath.length && _Router.Router.query.menuPath) {
      this.args.initialPath = JSON.parse(_Router.Router.query.menuPath);
    }
    this.loggingIn = null;
    this.args.cardName = 'main-menu';
    this.args.haveToken = false;
    this.args.listening = false;
    this.args.joinGame = false;
    this.args.hostGame = false;
    this.args.copy = 'copy';
    this.font = 'small-menu-font';
    // this.font = 'font';

    this.args.title = new _CharacterString.CharacterString({
      font: this.font,
      value: 'Sonic 3000'
    });
    this.args.ok = new _CharacterString.CharacterString({
      font: this.font,
      value: '⓿ ok'
    });
    this.args.back = new _CharacterString.CharacterString({
      font: this.font,
      value: '❶ back'
    });
    this.args.revert = new _CharacterString.CharacterString({
      font: this.font,
      value: '❸ default (hold)'
    });
    this.args.select = new _CharacterString.CharacterString({
      font: this.font,
      value: '✚ select'
    });
    this.actsCleared = {};
    const Character = {
      input: 'select',
      options: ['Sonic', 'Tails', 'Knuckles'
      // , 'Robotnik'
      // , 'EggRobo'
      // , 'Mecha-Sonic'
      // , 'Seymour'
      // , 'Chalmers'
      // , 'Sean'
      ],

      locked: ['Robotnik', 'EggRobo', 'Mecha-Sonic', 'Seymour', 'Chalmers', 'Sean'],
      default: 'Sonic',
      set: value => this.parent.args.selectedChar = value,
      get: () => this.parent.args.selectedChar || 'Sonic'
    };
    const Follower = {
      input: 'select',
      options: ['Sonic', 'Tails', 'Knuckles'
      // , 'Robotnik'
      // , 'EggRobo'
      // , 'Mecha-Sonic'
      // , 'Seymour'
      // , 'Chalmers'
      // , 'Sean'
      ],

      locked: ['Robotnik', 'EggRobo', 'Mecha-Sonic', 'Seymour', 'Chalmers', 'Sean'],
      set: value => this.parent.args.followerChar = value,
      get: () => {
        var _this$parent$args$fol;
        return (_this$parent$args$fol = this.parent.args.followerChar) !== null && _this$parent$args$fol !== void 0 ? _this$parent$args$fol : 'Tails';
      }
    };
    const Pallet = _Bindable.Bindable.make({
      input: 'select',
      tags: 'inline',
      options: [],
      set: value => this.parent.args.mainPallet = value,
      get: () => {
        var _this$parent$args$mai;
        return (_this$parent$args$mai = this.parent.args.mainPallet) !== null && _this$parent$args$mai !== void 0 ? _this$parent$args$mai : null;
      }
    });
    Pallet.set(this.parent.args.mainPallet || 'Normal');
    const CustomColor = _Bindable.Bindable.make({
      Hue: {
        input: 'number',
        tags: 'inline',
        min: -180,
        max: +180,
        subtext: 'Rotate the color wheel.',
        revert: () => parent.customColor.h = 0,
        set: value => parent.customColor.h = Number(value).toFixed(2),
        get: () => parent.customColor.h
      },
      Saturation: {
        input: 'number',
        tags: 'inline',
        min: 0,
        max: 2,
        step: 0.01,
        subtext: 'Change the amount of color.',
        revert: () => parent.customColor.s = 1,
        set: value => parent.customColor.s = Number(value).toFixed(2),
        get: () => parent.customColor.s
      },
      Value: {
        input: 'number',
        tags: 'inline',
        min: 0,
        max: 2,
        step: 0.01,
        subtext: 'change the brightness.',
        revert: () => parent.customColor.v = 1,
        set: value => parent.customColor.v = Number(value).toFixed(2),
        get: () => parent.customColor.v
      }
    });
    this.onRemove(parent.args.bindTo('selectedChar', v => {
      parent.loadSaves().then(() => {
        switch (v) {
          case 'Sonic':
            Pallet.options = ['Normal', 'Santiago', 'Sequel', 'RedHot', 'White', 'Custom'];
            break;
          case 'Tails':
            Pallet.options = ['SkyCamo', 'Copper', 'Patina', 'Arctic', 'Custom'];
            break;
          case 'Knuckles':
            Pallet.options = ['Tails', 'Enerjak', 'Pink', 'Wechnia', 'Custom'];
            break;
          default:
            Pallet.options = [];
            break;
        }
        if (v) {
          const charState = parent.getCharacterState(v);
          Pallet.options.length = Pallet.options.length ? 1 + Math.min(Pallet.options.length, Object.keys(charState.cleared).length) : 0;
        } else {
          Pallet.options = [];
        }
        if (Pallet.options.length) {
          Pallet.available = 'available';
        } else {
          Pallet.available = 'hidden';
        }
      });
    }));
    this.onRemove(parent.args.bindTo('mainPallet', v => {
      if (v === 'Custom') {
        CustomColor.Hue.available = CustomColor.Saturation.available = CustomColor.Value.available = 'available';
        return;
      }
      CustomColor.Hue.available = CustomColor.Saturation.available = CustomColor.Value.available = 'hidden';
    }));
    Character.prefix = new _CharacterPreview.CharacterPreview(Character, this.parent);
    // Follower.prefix = new CharacterPreview(Follower);

    this.onRemove(() => Character.prefix.remove());
    this.items = this.args.items = {
      'Single Player': {
        available: 'available',
        children: {
          Character

          // , Follower
          // , Pallet
          // , ...CustomColor
          ,

          'Brooklyn Breakout Zone Act 1': {
            characters: ['Sonic', 'Tails', 'Knuckles', 'Robotnik'],
            suffix: new _ZoneSuffix.ZoneSuffix({
              map: '/map/brooklyn-zone.json'
            }, this.parent),
            callback: () => {
              this.parent.loadMap({
                mapUrl: '/map/brooklyn-zone.json'
              });
              this.accept();
            }
          },
          'Brooklyn Breakout Zone Act 2': {
            characters: ['Sonic', 'Tails', 'Knuckles', 'Robotnik'],
            suffix: new _ZoneSuffix.ZoneSuffix({
              map: '/map/brooklyn-zone-2.json'
            }, this.parent),
            callback: () => {
              this.parent.loadMap({
                mapUrl: '/map/brooklyn-zone-2.json'
              });
              this.accept();
            }
          },
          'Manic Harbor Zone Act 1': {
            characters: ['Sonic', 'Tails', 'Knuckles', 'Robotnik'],
            suffix: new _ZoneSuffix.ZoneSuffix({
              map: '/map/manic-harbor-zone.json'
            }, this.parent),
            callback: () => {
              this.parent.loadMap({
                mapUrl: '/map/manic-harbor-zone.json'
              });
              this.accept();
            }
          },
          'Manic Harbor Zone Act 2': {
            characters: ['Sonic', 'Tails', 'Knuckles', 'Robotnik'],
            suffix: new _ZoneSuffix.ZoneSuffix({
              map: '/map/manic-harbor-zone-2.json'
            }, this.parent),
            callback: () => {
              this.parent.loadMap({
                mapUrl: '/map/manic-harbor-zone-2.json'
              });
              this.accept();
            }
          },
          'Agorapolis Zone Act 1 Preview': {
            characters: ['Sonic', 'Tails', 'Knuckles', 'Robotnik'],
            suffix: new _ZoneSuffix.ZoneSuffix({
              map: '/map/emerald-isle.json'
            }, this.parent),
            callback: () => {
              this.parent.loadMap({
                mapUrl: '/map/emerald-isle.json'
              });
              this.accept();
            }
          },
          'Agorapolis Zone Act 2 Preview': {
            characters: ['Sonic', 'Tails', 'Knuckles', 'Robotnik'],
            suffix: new _ZoneSuffix.ZoneSuffix({
              map: '/map/emerald-isle-2.json'
            }, this.parent),
            callback: () => {
              this.parent.loadMap({
                mapUrl: '/map/emerald-isle-2.json'
              });
              this.accept();
            }
          },
          'Radical City Zone Act 1': {
            characters: ['Sonic', 'Tails', 'Knuckles', 'Robotnik'],
            suffix: new _ZoneSuffix.ZoneSuffix({
              map: '/map/empty-zone.json'
            }, this.parent),
            callback: () => {
              this.parent.loadMap({
                mapUrl: '/map/empty-zone.json'
              });
              this.accept();
            }
          },
          'Radical City Zone Act 2': {
            characters: ['Sonic', 'Tails', 'Knuckles', 'Robotnik'],
            suffix: new _ZoneSuffix.ZoneSuffix({
              map: '/map/empty-zone-2.json'
            }, this.parent),
            callback: () => {
              this.parent.loadMap({
                mapUrl: '/map/empty-zone-2.json'
              });
              this.accept();
            }
          },
          'Seaview Park Zone Act 1': {
            characters: ['Sonic', 'Tails', 'Knuckles', 'Robotnik'],
            suffix: new _ZoneSuffix.ZoneSuffix({
              map: '/map/west-side-zone.json'
            }, this.parent),
            callback: () => {
              this.parent.loadMap({
                mapUrl: '/map/west-side-zone.json'
              });
              this.accept();
            }
          },
          'Seaview Park Zone Act 2': {
            characters: ['Sonic', 'Tails', 'Knuckles', 'Robotnik'],
            suffix: new _ZoneSuffix.ZoneSuffix({
              map: '/map/west-side-zone-2.json'
            }, this.parent),
            callback: () => {
              this.parent.loadMap({
                mapUrl: '/map/west-side-zone-2.json'
              });
              this.accept();
            }
          },
          'Misty Ruins Zone Preview': {
            characters: ['Sonic', 'Tails', 'Knuckles', 'Robotnik'],
            subtext: 'Testing art, layout and physics for Misty Ruins Zone',
            callback: () => {
              this.parent.loadMap({
                mapUrl: '/map/ruins-test.json'
              });
              this.accept();
            }
          },
          'StratoRail Zone Preview': {
            characters: ['Sonic', 'Tails', 'Knuckles', 'Robotnik'],
            tags: 'new',
            subtext: 'Testing art for Moon Zone',
            callback: () => {
              this.parent.loadMap({
                mapUrl: '/map/pumpkin-test.json'
              });
              this.accept();
            }
          },
          'Toxin Refinery Zone Preview': {
            characters: ['Sonic', 'Tails', 'Knuckles', 'Robotnik'],
            subtext: 'Testing art for Moon Zone',
            callback: () => {
              this.parent.loadMap({
                mapUrl: '/map/chemical-test.json'
              });
              this.accept();
            }
          },
          'Underground Zone Preview': {
            characters: ['Sonic', 'Tails', 'Knuckles', 'Robotnik'],
            subtext: 'Testing art, layout and physics for Underground Zone',
            callback: () => {
              this.parent.loadMap({
                mapUrl: '/map/underground-test.json'
              });
              this.accept();
            }
          }

          // , 'Peak Vape Test Zone': {
          // 	characters: ['Sonic', 'Tails', 'Knuckles', 'Robotnik']
          // 	, subtext: 'Testing art for Peak Vape Zone'
          // 	, callback: () => {
          // 		this.parent.loadMap({mapUrl: '/map/quartz-test.json'});
          // 		this.accept();
          // 	}
          // }
          ,

          'Phazon Crater Preview': {
            characters: ['Sonic', 'Tails', 'Knuckles', 'Robotnik'],
            subtext: 'Testing art for Phazon Crater Zone',
            callback: () => {
              this.parent.loadMap({
                mapUrl: '/map/phazon-test.json'
              });
              this.accept();
            }
          },
          'Moon Zone Preview': {
            characters: ['Sonic', 'Tails', 'Knuckles', 'Robotnik'],
            subtext: 'Testing art for Moon Zone',
            callback: () => {
              this.parent.loadMap({
                mapUrl: '/map/moon-test.json'
              });
              this.accept();
            }
          }

          // , 'Flickie Test': {
          // 	characters: ['Sonic', 'Tails', 'Knuckles', 'Robotnik']
          // 	, subtext: 'Flickie stress test'
          // 	, callback: () => {
          // 		this.parent.loadMap({mapUrl: '/map/flickie-test.json'});
          // 		this.accept();
          // 	}
          // }
        }
      },

      'Multiplayer': {
        tags: '',
        children: {
          'Matrix Lobby': {
            tags: 'new',
            callback: () => {
              this.refreshConnection();
              if (!this.loggingIn) {
                this.loggingIn = this.parent.matrixConnect(true);
                this.loggingIn.finally(() => this.loggingIn = null);
                this.loggingIn.then(matrix => {
                  const lobby = new _Lobby.Lobby({
                    roomId: this.parent.settings.matrixRoom
                  }, this.parent);
                  this.args.override = lobby;
                  this.args.override.onRemove(() => {
                    this.args.override = null;
                    this.onNextFrame(() => this.focusFirst());
                  });
                  this.onRemove(() => lobby.remove());
                });
              } else {
                this.parent.matrixConnect();
              }
            }
          },
          'Peer to Peer': {
            children: {
              'Host a game': {
                callback: () => {
                  this.refreshConnection();
                  this.args.hostOutput = '';
                  this.args.hostGame = true;
                  this.args.copy = 'copy';
                }
              },
              'Join a game': {
                callback: () => {
                  this.refreshConnection();
                  this.args.joinOutput = '';
                  this.args.joinGame = true;
                  this.args.copy = 'copy';
                  this.client.fullOffer().then(token => {
                    const tokenString = JSON.stringify(token);
                    const encodedToken = `s3ktp://request/${btoa(tokenString)}`;
                    this.args.joinOutput = encodedToken;
                    this.args.haveToken = true;
                  });
                }
              }
            }
          }
        }
      },
      Settings: (0, _SettingsMenu.SettingsMenu)(parent),
      Graphics: {
        input: 'select',
        tags: 'inline',
        options: ['High', 'Medium', 'Low', 'Very Low'],
        set: value => parent.settings.graphicsLevel = value,
        get: () => parent.settings.graphicsLevel
      },
      About: {
        callback: () => {
          window.open('/about.html');
        }
      }
    };
  }
  clear() {
    this.args.input = '';
    this.args.joinOutput = '';
    this.args.hostOutput = '';
  }
  input(controller) {
    super.input(controller);
    let xEffect = 2;
    let yEffect = 3;

    // if(controller.axes[7])
    // {
    // 	xEffect = 3;
    // 	yEffect = 4;
    // }

    // if(this.args.twist)
    // {
    // 	const xAxis = (controller.axes[xEffect] ? controller.axes[xEffect].magnitude : 0);
    // 	const yAxis = (controller.axes[yEffect] ? controller.axes[yEffect].magnitude : 0);

    // 	let pressure = 0;

    // 	if(controller.buttons[6])
    // 	{
    // 		pressure = controller.buttons[6].pressure - controller.buttons[7].pressure;
    // 	}

    // 	this.args.twist.args.scale = pressure * -256;

    // 	this.args.twist.args.dx = 64*1.618 * xAxis;
    // 	this.args.twist.args.dy = 64*1.000 * yAxis;
    // }

    // if(this.args.pinch)
    // {
    // 	const xAxis = (controller.axes[xEffect] ? controller.axes[xEffect].magnitude : 0) + (controller.axes[0] ? controller.axes[0].magnitude : 0) * 0.1;
    // 	const yAxis = (controller.axes[yEffect] ? controller.axes[yEffect].magnitude : 0) + (controller.axes[1] ? controller.axes[1].magnitude : 0) * 0.1;

    // 	this.args.pinch.args.dx = 64*1.618 * xAxis;
    // 	this.args.pinch.args.dy = 64*1.000 * yAxis;
    // }
  }

  disconnect() {
    this.server && this.server.close();
    this.client && this.client.close();
    this.server = null;
    this.client = null;
    this.parent.args.networked = false;
    this.parent.args.chatBox = null;
    this.args.connected = false;
    this.args.hostGame = false;
    this.args.joinGame = false;
    this.clear();
  }

  // onRendered(event)
  // {
  // 	super.onRendered(event);

  // 	this.args.twist = new Twist({
  // 		id:'menu-twist', scale:  64, width: Math.floor(64 * 1.618), height: 64
  // 	});

  // 	this.args.pinch = new Pinch({
  // 		id:'menu-pinch', scale:  64, width: Math.floor(64 * 1.618), height: 64
  // 	});
  // }

  back() {
    let levels = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    super.back(levels);
    this.disconnect();
  }
  answer() {
    let offerString = this.args.input;
    const isEncoded = /^s3ktp:\/\/request\/(.+)/.exec(offerString);
    if (isEncoded) {
      offerString = atob(isEncoded[1]);
    }
    const offer = JSON.parse(offerString);
    const answer = this.server.fullAnswer(offer);
    answer.then(token => {
      const tokenString = JSON.stringify(token);
      const encodedToken = `s3ktp://accept/${btoa(tokenString)}`;
      this.args.hostOutput = encodedToken;
      this.args.haveToken = true;
    });
    return answer;
  }
  acceptRtp() {
    let answerString = this.args.input;
    const isEncoded = /^s3ktp:\/\/accept\/(.+)/.exec(answerString);
    if (isEncoded) {
      answerString = atob(isEncoded[1]);
    }
    const answer = JSON.parse(answerString);
    this.client.fullAccept(answer);
  }
  select() {
    if (this.args.hostGame) {
      this.tags.hostOutput.select();
    } else if (this.args.joinGame) {
      this.tags.joinOutput.select();
    }
  }
  copy() {
    if (this.args.hostGame) {
      if (!this.args.input) {
        return;
      }
      this.tags.hostOutput.select();
    } else if (this.args.joinGame) {
      if (!this.args.joinOutput) {
        return;
      }
      this.tags.joinOutput.select();
    }
    document.execCommand("copy");
    this.args.copy = 'copied!';
  }
  paste(event) {
    navigator.clipboard.readText().then(copied => {
      if (this.args.hostGame && copied.match(/^s3ktp:\/\/request\//)) {
        this.args.input = copied;
        this.answer().then(token => {
          this.copy();
        });
      }
      if (this.args.joinGame && copied.match(/^s3ktp:\/\/accept\//)) {
        this.args.input = copied;
        this.acceptRtp();
      }
    });
  }
  refreshConnection() {
    this.server = this.parent.getServer(true);
    this.client = this.parent.getClient(true);
    const server = this.server;
    const client = this.client;
    const onOpen = event => {
      console.log('Peer connection opened!');
      this.parent.loadMap({
        mapUrl: '/map/emerald-isle.json',
        networked: true
      }).then(() => console.log('Level started!'));
    };
    const onClose = event => {
      this.disconnect(event);
      if (this.server && this.server.peerServer && this.server.peerServer.connectionState === 'closed') {
        console.log({
          server: this.server
        });
        this.server = null;
      }
      if (this.client && this.client.peerClient && this.client.peerClient.connectionState === 'closed') {
        console.log({
          client: this.client
        });
        this.client = null;
      }
    };
    this.listen(server, 'open', onOpen, {
      once: true
    });
    this.listen(client, 'open', onOpen, {
      once: true
    });
    this.listen(server, 'close', onClose, {
      once: true
    });
    this.listen(client, 'close', onClose, {
      once: true
    });
  }
  play() {
    super.play();
    _Bgm.Bgm.play('MENU_THEME', {
      loop: true,
      interlude: true
    });
    const done = this.done;
    done.then(() => this.onTimeout(250, () => this.remove()));
    return done;
  }
}
exports.MainMenu = MainMenu;
});

;require.register("Menu/Menu.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Menu = void 0;
var _Bindable = require("curvature/base/Bindable");
var _Card = require("../intro/Card");
var _Cylinder = require("../effects/Cylinder");
var _Pinch = require("../effects/Pinch");
var _CharacterString = require("../ui/CharacterString");
var _Sfx = require("../audio/Sfx");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
const Bindings = Symbol('bindings');
class Menu extends _Card.Card {
  constructor(args, parent) {
    args[_Bindable.Bindable.NoGetters] = true;
    super(args, parent);
    _defineProperty(this, "template", require('./main-menu.html'));
    this[_Bindable.Bindable.NoGetters] = true;
    this.font = 'small-menu-font';
    // this.font = 'font';

    this.args.initialPath = [];
    this.args.cardName = 'menu';
    this.args.items = {};
    this.args.pageLoop = false;
    this.args.pageJump = 7;
    this.currentItem = null;
    this.include = 'a, button, input, textarea, select, details, [tabindex]';
    this.exclude = '[tabindex="-1"], .hidden';
    this.elements = new Map();
    this.onRemove(() => parent.focus());
  }
  onRendered(event) {
    this.listen(window, 'focus', event => this.refocus(event));
    this.args.bindTo('items', v => {
      for (const i in this.args.items) {
        const item = this.args.items[i];
        if (item[Bindings]) {
          [...item[Bindings]].forEach(b => b());
        }
      }
      let index = 0;
      for (const i in v) {
        var _item$Bindings;
        const item = v[i];
        item[Bindings] = (_item$Bindings = item[Bindings]) !== null && _item$Bindings !== void 0 ? _item$Bindings : new Set();
        item.color = item.color || 'var(--default-color)';
        item._index = index++;
        item._key = i;
        item._title = new _CharacterString.CharacterString({
          value: i,
          font: this.font
        });
        item._value = new _CharacterString.CharacterString({
          value: 'default',
          font: this.font
        });
        const setView = item => {
          if (item.input === 'boolean') {
            item._value.args.value = item.setting ? 'ON' : 'OFF';
            item._boolValue = item._value;
          } else if (item.input === 'number') {
            var _item$subType;
            const bindable = _Bindable.Bindable.make(item);
            item.subType = (_item$subType = item.subType) !== null && _item$subType !== void 0 ? _item$subType : 'number';
            item[Bindings].add(bindable.bindTo('setting', v => item._value.args.value = v));
          } else if (item.input === 'string') {} else if (item.input === 'select') {
            item._value.args.value = item.setting;
            item._selectValue = item._value;
          } else if (item.input === 'output') {
            const bindable = _Bindable.Bindable.make(item);
            item[Bindings].add(bindable.bindTo('setting', v => item._value.args.value = v));
            item[Bindings].add(bindable.bindTo('setting', console.trace));

            // if(item.bind)
            // {
            // 	item[Bindings].add(item.bind(Bindable.make(item)));
            // }
          }

          const bindable = _Bindable.Bindable.make(item);
          item[Bindings].add(bindable.bindTo('setting', v => item.set && item.set(v)));
        };
        if (item.watch) {
          item[Bindings].add(item.watch[0].bindTo(item.watch[1], v => {
            item.setting = item.watch[2] ? item.watch[2](v) : v;
            if (item.input === 'number') {
              _Sfx.Sfx.play('SWITCH_HIT');
            }
            setView(item);
          }));
        } else if (item.get) {
          item.setting = item.get();
          setView(item);
        }
      }
    });
    this.args.bindTo('items', v => {
      if (!v || !Object.keys(v).length) {
        return;
      }
      if (this.args.items) {
        this.currentItem = null;
      }
      if (this.tags.bound) {
        const next = this.findNext(this.currentItem, this.tags.bound.node);
        if (next) {
          this.focus(next);
        }
      }
    }, {
      wait: 0
    });
  }
  onAttached(event) {
    const autoNav = () => {
      if (this.args.initialPath.length) {
        const item = this.args.initialPath.shift();
        if (item in this.args.items) {
          this.onTimeout(0, () => this.run(this.args.items[item]));
          if (this.args.initialPath.length) {
            this.onTimeout(0, () => autoNav());
          }
        }
      } else {
        this.onNextFrame(() => this.focusFirst());
      }
    };
    this.onTimeout(0, () => autoNav());
  }
  focusFirst() {
    if (!this.tags.bound) {
      return;
    }
    const element = this.findNext(null, this.tags.bound);
    element && this.focus(element);
  }
  refocus(event) {
    this.onNextFrame(() => {
      if (!this.currentItem) {
        this.focusFirst();
      }
      this.focus(this.currentItem, true);
    });
  }
  findNext(current, bounds) {
    let jump = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    const elements = bounds.querySelectorAll(this.include);
    if (!elements.length) {
      return;
    }
    const items = [];
    let c = 0,
      i = 0;
    for (const element of elements) {
      if (element.matches(this.exclude)) {
        continue;
      }
      items.push(element);
      if (element === current) {
        c = i;
      }
      i++;
    }
    if (!current) {
      return items[0];
    }
    if (Math.abs(jump) > 1 && !this.args.pageLoop) {
      if (jump + c < 0) {
        return items[0];
      } else if (jump + c >= items.length) {
        return items[items.length + -1];
      }
    }
    if (jump === -Infinity) {
      return items[0];
    } else if (jump === Infinity) {
      return items[items.length + -1];
    }
    let s = (c + jump) % items.length;
    while (s < 0) {
      s += items.length;
    }
    return items[s];
  }
  handleFocus(event) {
    this.focus(event.target, true);
  }
  focus(element) {
    let quick = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    if (this.currentItem && this.currentItem.contains(element) && this.currentItem !== element || document.activeElement === element && this.currentItem === element) {
      return;
    }
    if (this.currentItem) {
      this.blur(this.currentItem);
    }
    if (element) {
      this.currentItem = element;
      element.focus({
        preventScroll: true
      });
      element.scrollIntoView({
        behavior: quick ? 'instant' : 'smooth',
        block: 'center'
      });
      element.classList.add('focused');
      element.addEventListener('blur', () => this.blur(element), {
        once: true
      });
    }
  }
  blur(element) {
    element.classList.remove('focused');
    element.blur();
  }
  input(controller) {
    this.zeroMe = controller;
    if (!this.tags.bound) {
      return;
    }
    if (this.args.override) {
      this.args.override.input(controller);
      return;
    }
    let next,
      quick = false;
    if (controller.buttons[0] && controller.buttons[0].time === 1) {
      this.currentItem && this.currentItem.click();
      this.args.last = 'A';
      if (this.currentItem && !this.currentItem.contains(document.activeElement)) {
        next = this.currentItem;
      }
      this.beep();
    } else if (controller.buttons[1] && controller.buttons[1].time === 1) {
      if (document.activeElement && document.activeElement.tagName === 'INPUT') {
        document.activeElement.closest('li').focus();
      } else {
        this.back();
      }
      this.args.last = 'B';
      this.beep();
    } else if (controller.buttons[3] && controller.buttons[3].time === 30) {
      this.currentItem && this.currentItem.dispatchEvent(new MouseEvent('auxclick', {
        button: 1
      }));
      this.args.last = 'Y';
      this.beep();
    }
    const repeatCheck = button => controller.buttons[button] && (controller.buttons[button].time === 1 || controller.buttons[button].time >= 90 && controller.buttons[button].time % 3 === 1 || controller.buttons[button].time > 30 && controller.buttons[button].time < 90 && controller.buttons[button].time % 15 === 1);
    if (repeatCheck(12) || controller.axes[7] && controller.axes[7].magnitude < 0 && controller.axes[7].delta) {
      if (this.currentItem && this.currentItem.previousElementSibling) {
        quick = true;
      }
      next = this.findNext(this.currentItem, this.tags.bound.node, -1);
      this.beep();
    } else if (repeatCheck(13) || controller.axes[7] && controller.axes[7].magnitude > 0 && controller.axes[7].delta) {
      if (this.currentItem && this.currentItem.nextElementSibling) {
        quick = true;
      }
      next = this.findNext(this.currentItem, this.tags.bound.node, 1);
      this.beep();
    }
    if (repeatCheck(1022)) {
      next = this.findNext(this.currentItem, this.tags.bound.node, -this.args.pageJump);
      this.beep();
    } else if (repeatCheck(1023)) {
      next = this.findNext(this.currentItem, this.tags.bound.node, this.args.pageJump);
      this.beep();
    }
    if (repeatCheck(1024)) {
      next = this.findNext(this.currentItem, this.tags.bound.node, -Infinity);
      this.beep();
    } else if (repeatCheck(1025)) {
      next = this.findNext(this.currentItem, this.tags.bound.node, Infinity);
      this.beep();
    } else if (repeatCheck(14) || controller.axes[6] && controller.axes[6].magnitude < 0 && controller.axes[6].delta) {
      this.currentItem && this.contract(this.currentItem);
      this.beep();
    } else if (repeatCheck(15) || controller.axes[6] && controller.axes[6].magnitude > 0 && controller.axes[6].delta) {
      this.currentItem && this.expand(this.currentItem);
      this.beep();
    }
    next && this.focus(next, quick);
  }
  beep() {
    if (!this.parent.args.audio) {
      return;
    }
    _Sfx.Sfx.play('SWITCH_HIT');
  }
  run(item, event) {
    let element;
    if (event && event.target) {
      element = event.target;
      while (element && element.matches) {
        if (element.matches('[data-click-barrier]')) {
          return;
        }
        if (element.matches('li')) {
          break;
        }
        element = element.parentNode;
      }
    }
    if (this.zeroMe) {
      this.zeroMe.zero();
    }
    if (item.available === 'unavailable' || item.available === 'hidden') {
      return;
    }
    if (event && item.input) {
      const li = event.target.closest('li');
      if (item.input === 'boolean') {
        this.toggle(event, item);
        return;
      } else if (item.input === 'string') {
        this.subFocusing = true;
        const input = element.querySelector('input');
        if (document.activeElement !== input) {
          input.focus();
        } else {
          li.focus();
        }
        return;
      }
      this.onNextFrame(() => this.focus(li));
    }
    if (item.callback) {
      item.callback(item, this);
    }
    if (item.children) {
      let getChildren = item.children;
      this.args.classes = item.classes || '';
      if (typeof item.children === 'function') {
        getChildren = item.children(this.parent, this);
      }
      if (!(getChildren instanceof Promise)) {
        getChildren = Promise.resolve(getChildren);
      }
      const lastSelected = item._key;
      const prev = this.args.items;
      const back = {
        _title: new _CharacterString.CharacterString({
          value: 'back',
          font: 'small-menu-font'
        }),
        callback: () => {
          this.args.items = prev;
          this.args.classes = prev.classes || '';
          this.args.currentKey = prev._title ? prev._title.args.value : '';
          // this.onNextFrame(()=>this.focusFirst());
          const lastIndex = Object.keys(prev).indexOf(lastSelected);
          this.onNextFrame(() => {
            this.focusFirst();
            this.onNextFrame(() => {
              if (this.tags.bound) {
                const next = this.findNext(this.currentItem, this.tags.bound.node, lastIndex > 0 ? lastIndex : 0);
                this.focus(next);
              }
            });
          });
        },
        _prev: prev['back'],
        color: 'var(--back-color, var(--default-color))'
      };
      this.args.items = {};
      getChildren.catch(error => {
        this.args.items['back'] = this.args.items['back'] || back;
      });
      getChildren.then(children => {
        this.args.items = children;
        this.args.currentKey = item._title.args.value;
        this.args.items['back'] = this.args.items['back'] || back;
        this.onNextFrame(() => this.focusFirst());
      });
    }
  }
  altRun(item, event) {
    if (!event || event.button !== 1) {
      return;
    }
    if (item.revert) {
      item.revert(item, this);
      if (item.get) {
        item.setting = item.get();
      }
      if (item.input === 'boolean') {
        item._value.args.value = item.setting ? 'ON' : 'OFF';
      }
      item.set && item.set(item.setting);
    }
  }
  back() {
    let levels = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    let target = this.args.items['back'];
    for (let i = 1; i < levels; i++) {
      console.log(target);
      if (target._prev) {
        target = target._prev;
      } else {
        break;
      }
    }
    target && target.callback && target.callback();
  }
  expand(element) {
    const input = element.querySelector('input');
    const title = element.getAttribute('data-title');
    const item = this.args.items[title];
    if (!item) {
      return;
    }
    if (item.input === 'number') {
      let newVal = Number(item.setting) + (item.step || 1);
      if (item.max !== undefined && newVal > item.max) {
        newVal = item.max;
      }
      if (item.min !== undefined && newVal < item.min) {
        newVal = item.min;
      }
      item.setting = newVal;

      // item.set && item.set(item.setting);
    } else if (item.input === 'boolean') {
      item.setting = !item.setting;
      item._value.args.value = item.setting ? 'ON' : 'OFF';
      // item.set && item.set(item.setting);
    } else if (item && item.input === 'select') {
      this.cycleSelect(item, title, 1);
    } else if (input) {
      input.focus();
    }
  }
  contract(element) {
    const title = element.getAttribute('data-title');
    const item = this.args.items[title];
    if (!item) {
      return;
    }
    if (item.input === 'number') {
      item.setting = Number(item.setting) - (item.step || 1);
      if (item.setting < item.min) {
        item.setting = item.min;
      }

      // item.set && item.set(item.setting);
    } else if (item.input === 'boolean') {
      item.setting = !item.setting;
      item._value.args.value = item.setting ? 'ON' : 'OFF';
      // item.set && item.set(item.setting);
    } else if (item && item.input === 'select') {
      this.cycleSelect(item, title, -1);
    } else {
      this.focus(element);
    }
  }
  keyup(event, item) {
    if (event.key === 'Enter' || event.key === 'Escape') {
      if (!this.subFocusing) {
        this.currentItem.focus();
      }
      this.subFocusing = false;
      return;
    }
    if (['ArrowUp', 'ArrowDown'].includes(event.key)) {
      event.preventDefault();
      event.stopPropagation();
      event.stopImmediatePropagation();
      const jump = {
        ArrowUp: -1,
        ArrowDown: 1
      }[event.key];
      if (event.target.tagName === 'INPUT') {
        const next = this.findNext(this.currentItem, this.tags.bound.node, jump);
        if (next) {
          this.focus(next);
          return;
        }
      }
    }
  }
  change(event, title) {
    const item = this.args.items[title];
    if (!item) {
      return;
    }
    item.setting = event.target.value;
    this.selectListChanged(item, title);
    item.set(item.setting);
  }
  toggle(event, item) {
    event && event.preventDefault();
    item.setting = !item.setting;
    item._value.args.value = item.setting ? 'ON' : 'OFF';
    // item.set && item.set(item.setting);
  }

  cancel(event) {
    event.preventDefault();
  }
  cycleSelect(item, title) {
    let direction = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    let found = false;
    let first = undefined;
    let last = undefined;
    const options = [];
    Object.assign(options, item.options);
    if (direction === -1) {
      options.reverse();
    } else if (direction !== 1) {
      return;
    }
    for (const option of options) {
      var _first;
      first = (_first = first) !== null && _first !== void 0 ? _first : option;
      if (option === item.setting) {
        found = true;
        continue;
      }
      if (found) {
        item.setting = option;
        last = undefined;
        break;
      }
      last = option;
    }
    if (last !== undefined) {
      item.setting = first;
    }
    this.selectListChanged(item, title);
    item.set(item.setting);
  }
  selectListRendered(event, item, title, $view, $subview, $parent) {
    if (item.input === 'select') {
      var _ref;
      item.setting = (_ref = item.get ? item.get() : item.default) !== null && _ref !== void 0 ? _ref : undefined;
      let selectedIndex = 0;
      for (const i in item.options) {
        if (item.options[i] === item.setting) {
          selectedIndex = i;
        }
      }
      if (item.setting === undefined && item.options.length) {
        selectedIndex = 0;
        item.setting = item.options[0];
      }
      const selectTag = $subview.findTag('select');
      const optionTag = $subview.findTag('option');
      selectTag.selectedIndex = selectedIndex;
      item._value.args.value = item.setting;
      this.selectListChanged(item, title, true);
    } else if (item.input === 'boolean') {
      if (item.element) {
        item.element.selectedIndex = item.setting ? 0 : 1;
        item._value.args.value = item.setting ? 'ON' : 'OFF';
      }
    }
  }
  selectListChanged(item, title) {
    let silent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    if (item.input === 'boolean') {
      item._value.args.value = item.setting ? 'ON' : 'OFF';
      this.selectListChanged(item, title, true);
    } else if (item.input === 'select') {
      if (item._value) {
        if (item.locked && item.locked.includes(item.setting)) {
          item._value.args.value = 'Locked';
        } else {
          item._value.args.value = item.setting;
        }
      }
    }
    if (title === 'Character') {
      for (const _item of Object.values(this.args.items)) {
        var _ref2, _item$_available;
        _item._available = (_ref2 = (_item$_available = _item._available) !== null && _item$_available !== void 0 ? _item$_available : _item.available) !== null && _ref2 !== void 0 ? _ref2 : 'available';
        if (_item.characters && !_item.characters.includes(item.setting)) {
          _item.available = 'unavailable';
        } else {
          _item.available = _item._available;
        }
      }
    }
    if (this.parent.args.audio && !silent) {
      this.beep();
    }
  }
}
exports.Menu = Menu;
});

;require.register("Menu/PauseMenu.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PauseMenu = void 0;
var _Card = require("../intro/Card");
var _Cylinder = require("../effects/Cylinder");
var _Pinch = require("../effects/Pinch");
var _Menu = require("./Menu");
var _SettingsMenu = require("./SettingsMenu");
var _CharacterString = require("../ui/CharacterString");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class PauseMenu extends _Menu.Menu {
  constructor(args, parent) {
    super(args, parent);
    _defineProperty(this, "template", require('./pause-menu.html'));
    this.args.cardName = 'pause-menu';
    this.args.animation = '';
    this.args.title = new _CharacterString.CharacterString({
      value: 'Sonic 3000',
      font: 'small-menu-font'
    });
    this.items = this.args.items = {
      Continue: {
        subtext: 'Return to gameplay.',
        callback: () => parent.unpauseGame()
      },
      Mute: {
        input: 'boolean',
        subtext: 'Mute all audio',
        revert: () => parent.args.audio = true,
        watch: [parent.args, 'audio', v => !v],
        set: value => parent.args.audio = !value
        // , get: () => !parent.args.audio
      },

      Settings: (0, _SettingsMenu.SettingsMenu)(parent),
      Graphics: {
        input: 'select',
        options: ['High', 'Medium', 'Low', 'Very Low'],
        set: value => parent.settings.graphicsLevel = value,
        get: () => parent.settings.graphicsLevel
      }
      // , Save: SaveMenu(parent)
      ,
      Reset: {
        subtext: 'Reset the run.',
        children: {
          'Last Checkpoint': {
            subtext: 'Restart from the last checkpoint.',
            children: {
              'No': {
                callback: () => this.args.items.back.callback()
              },
              'Yes': {
                callback: () => {
                  parent.unpauseGame();
                  parent.reset();
                  parent.startLevel();
                }
              }
            }
          },
          'Level Start': {
            subtext: 'Restart from the beginning of the act.',
            children: {
              'No': {
                callback: () => this.args.items.back.callback()
              },
              'Yes': {
                callback: () => {
                  parent.clearCheckpoints();
                  parent.unpauseGame();
                  parent.reset();
                  parent.startLevel();
                }
              }
            }
          }
        }
      },
      Quit: {
        subtext: 'Quit to the title screen.',
        children: {
          'No': {
            callback: () => this.args.items.back.callback()
          },
          'Yes': {
            callback: () => {
              this.args.items.back.callback();
              parent.clearCheckpoints();
              parent.unpauseGame();
              parent.quit();
              // parent.playCards();
            }
          }
        }
      }
    };
  }

  run(item, event) {
    event.stopPropagation();
    event.stopImmediatePropagation();
    super.run(item, event);
  }
  input(controller) {
    if (controller.buttons[1011] && controller.buttons[1011].active) {
      const time = controller.buttons[1011].time;
      if (time === 1 || time > 30 && time % 15 === 1) {
        this.parent.focus();
        this.parent.args.paused = 1;
        this.args.hideMenu = 'pause-menu-hide';
      }
    }
    const pauseButton = 9;
    if (!this.args.hideMenu) {
      super.input(controller);
    } else if (controller.buttons[pauseButton] && controller.buttons[pauseButton].active) {
      this.args.hideMenu = '';
    }
    if (controller.buttons[1012] && controller.buttons[1012].time > 0) {
      this.parent.focus();
      this.args.hideMenu = 'pause-menu-hide';
    } else if (controller.buttons[1020] && controller.buttons[1020].time > 0) {
      this.args.hideMenu = '';
    }
  }
  reset() {
    // this.args.items = {};
    // Object.assign(this.args.items, this.items);
    this.args.items = this.items;
    this.args.classes = '';
  }
}
exports.PauseMenu = PauseMenu;
});

;require.register("Menu/SaveMenu.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SaveMenu = void 0;
var _SaveDatabase = require("../save/SaveDatabase");
const SaveMenu = parent => {
  return {
    children: {
      Save: {
        callback: () => {
          if (!parent.controlActor) {
            return;
          }
          const controlActor = parent.controlActor;
          const currentMap = parent.currentMap;
          const character = controlActor.args.canonical;
          const checkpoint = parent.getCheckpoint(controlActor.args.id);
          const savestate = {
            currentMap,
            character,
            checkpoint
          };
          console.log(savestate);
          SavestateDatabase.open('savestates', 1).then(database => {
            const store = 'savestates';
            database.insert(store, savestate).then(result => {
              console.log(result);
              const index = 'id';
              const query = {
                store,
                index
              };
              database.select(query).each(savestate => console.log(savestate)).then(results => console.log(results));
            });
          });
        }
      }
    }
  };
};
exports.SaveMenu = SaveMenu;
});

require.register("Menu/SavestateMenu.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SavestateMenu = void 0;
var _SaveDatabase = require("../save/SaveDatabase");
const SavestateMenu = parent => {
  const children = {};
  _SaveDatabase.SaveDatabase.open('saves', 1).then(database => {
    const store = 'saves';
    const index = 'created';
    const query = {
      store,
      index
    };
    database.select(query).each(savestate => {
      const id = savestate.id;
      const character = savestate.character;
      children[`${id} ${character}`] = {
        callback: () => {
          console.log(savestate);
          parent.setCheckpoint(savestate.currentMap, {
            [character]: savestate.checkpoint
          });
          parent.loadMap({
            mapUrl: savestate.currentMap
          });
        }
      };
    }).then(results => console.log(results));
  });
  return {
    children
  };
};
exports.SavestateMenu = SavestateMenu;
});

require.register("Menu/SettingsMenu.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SettingsMenu = void 0;
var _TraceMenu = require("./TraceMenu");
var _GamepadConfig = require("../controller/GamepadConfig");
var _Series = require("../intro/Series");
var _ButtonSelect = require("./ButtonSelect");
var _DemoMenu = require("./DemoMenu");
const videoMenu = parent => ({
  classes: 'right-align',
  subtext: 'Video settings.',
  children: {
    // 'Tile Scale': {
    // 	input: 'number'
    // 	, subtext: 'Scale.'
    // 	, revert: () => parent.args.tileScale = 1
    // 	, set: value => parent.args.tileScale = value
    // 	, get: () => parent.args.tileScale
    // 	, min: 0.1
    // 	, step: 0.1
    // }

    'Motion Blur Effects': {
      input: 'boolean',
      subtext: 'Enable/Disable Motion Blur Effects',
      available: parent.args.agent === 'firefox' ? 'unavailable hidden' : 'available',
      revert: () => parent.settings.blur = true,
      set: value => parent.settings.blur = value,
      get: () => parent.settings.blur
    },
    'Displacement Effects': {
      input: 'boolean',
      subtext: 'Enable/Disable Displacement Effects',
      available: parent.args.agent === 'firefox' ? 'unavailable hidden' : 'available',
      revert: () => parent.settings.displace = true,
      set: value => parent.settings.displace = value,
      get: () => parent.settings.displace
    },
    'Scaling': {
      input: 'boolean',
      subtext: 'Enable/Disable Scaling',
      revert: value => parent.settings.scaling = true,
      set: value => parent.settings.scaling = value,
      get: () => parent.settings.scaling
    },
    'Smoothing': {
      input: 'boolean',
      subtext: 'Enable/Disable Smoothing',
      revert: value => parent.settings.smoothing = false,
      set: value => parent.settings.smoothing = value,
      get: () => parent.settings.smoothing
    },
    'Outline Thickness': {
      input: 'number',
      subtext: 'Change the Outline Thickness',
      revert: value => parent.settings.outline = 1,
      set: value => parent.settings.outline = value,
      get: () => parent.settings.outline,
      step: 0.5,
      max: 15,
      min: 0
    }

    // , 'Frameskip': {
    // 	input: 'number'
    // 	, subtext: 'Change the frameskip'
    // 	, set: value => parent.settings.frameSkip = value
    // 	, get: () => parent.settings.frameSkip
    // 	, max: 8
    // 	, min: 0
    // }
    ,

    'Display HUD': {
      input: 'boolean',
      subtext: 'Enable/Disable the HUD',
      revert: value => parent.settings.showHud = true,
      set: value => parent.settings.showHud = value,
      get: () => parent.settings.showHud
    }

    // , 'Debug OSD': {
    // 	input: 'boolean'
    // 	, subtext: 'Enable/Disable Debug OSD'
    // 	, set: value => parent.settings.debugOsd = value
    // 	, get: () => parent.settings.debugOsd
    // }
    ,

    'FPS Meter': {
      input: 'boolean',
      subtext: 'Enable/Disable the FPS Meter',
      revert: value => parent.settings.showFps = true,
      set: value => parent.settings.showFps = value,
      get: () => parent.settings.showFps
    },
    'Mute/Fullscreen': {
      input: 'boolean',
      subtext: 'Show the mute & fullscreen controls in the bottom right.',
      revert: value => parent.settings.shortcuts = true,
      set: value => parent.settings.shortcuts = value,
      get: () => parent.settings.shortcuts
    }
  }
});
const audioMenu = parent => ({
  subtext: 'Audio settings.',
  children: {
    'Mute': {
      input: 'boolean',
      subtext: 'Mute all audio',
      revert: () => parent.args.audio = true,
      watch: [parent.args, 'audio', v => !v],
      set: value => parent.args.audio = !value
      // , get: () => !parent.args.audio
    },

    'Music Volume': {
      input: 'number',
      subType: 'range',
      subtext: 'Background music volume - 0% - 100%'
      // , available: 'unavailable'
      ,
      revert: () => parent.settings.musicVol = parent.defaults.musicVol,
      set: value => parent.settings.musicVol = value,
      get: () => parent.settings.musicVol,
      max: 100,
      min: 0
    },
    'SFX': {
      input: 'number',
      subType: 'range',
      subtext: 'Sound effect music volume - 0% - 100%'
      // , available: 'unavailable'
      ,
      revert: () => parent.settings.sfxVol = parent.defaults.sfxVol,
      set: value => parent.settings.sfxVol = value,
      get: () => parent.settings.sfxVol,
      max: 100,
      min: 0
    }
    // , 'Mono / Stereo': {
    // 	available: 'unavailable'
    // }
  }
});

const inputMenu = parent => ({
  subtext: 'Input settings.',
  children: {
    // 'Gamepad Test': {
    // 	callback: (item,menu) => {
    // 		menu.args.override = new GamepadConfig({}, parent);
    // 		menu.args.override.onRemove(() => {
    // 			menu.args.override = null;
    // 			menu.onNextFrame(()=>menu.focusFirst());
    // 		});
    // 		// const cards = [
    // 		// 	new GamepadConfig({timeout: -1}, parent)
    // 		// 	, ...parent.homeCards()
    // 		// ];

    // 		// parent.args.titlecard = new Series({cards}, parent);

    // 		// parent.args.titlecard.play();
    // 	}
    // }

    // 'Select A Button': {
    // 	callback: (item,menu) => {
    // 		console.log('Select a button!');
    // 		menu.args.override = new ButtonSelect({},menu);
    // 		menu.args.override.onRemove(() => {
    // 			menu.args.override = null;
    // 			menu.onNextFrame(()=>menu.focusFirst());
    // 		});
    // 	}
    // }

    'Output test': {
      input: 'output'
      // , bind: i => {
      // 	console.trace(i);
      // 	return parent.settings.bindTo('buttonTest', v => {
      // 		i.setting = v
      // 	})
      // }
      ,
      watch: [parent.settings, 'buttonTest'],
      set: value => parent.settings.buttonTest = value
      // , get: () => parent.settings.buttonTest
    },

    'Button Font Test': {
      input: 'select',
      options: ['', '⓿', '❶', '❷', '❸', '❹', '❺', '❻', '❼', '❽', '❾', '❿', '⓫', '✚', '←', '→', '↑', '↓'
      // , '▦', '🡠', '🡢', '🡡', '🡣'
      , '⬲', '🡨', '🡪', '🡩', '🡫', '⟴', '🡰', '🡲', '🡱', '🡳'],
      set: value => parent.settings.buttonTest = value,
      get: () => parent.settings.buttonTest
    },
    'Rumble': {
      input: 'boolean',
      subtext: 'Enable/Disable controller vibration',
      set: value => parent.settings.rumble = value,
      get: () => parent.settings.rumble
    }
  }
});
const networkMenu = parent => ({
  subtext: 'Network settings.',
  children: {
    // 'Username': {
    // 	input: 'string'
    // 	, subtext: 'Name to display in online games'
    // 	, revert: () => parent.settings.username = parent.defaults.username
    // 	, set: value => parent.settings.username = value
    // 	, get: () => parent.settings.username
    // }
    'Matrix Settings': {
      children: {
        'Matrix URL': {
          input: 'string',
          subtext: 'Matrix Server URL for lobby.',
          revert: () => parent.settings.matrixUrl = parent.defaults.matrixUrl,
          set: value => parent.settings.matrixUrl = value,
          get: () => parent.settings.matrixUrl
        },
        'Lobby': {
          input: 'string',
          subtext: 'Matrix Room for lobby.',
          revert: () => parent.settings.matrixRoom = parent.defaults.matrixRoom,
          set: value => parent.settings.matrixRoom = value,
          get: () => parent.settings.matrixRoom
        }
      }
    }

    // , 'Subspace Hub Servers': {}
    ,

    'ICE Servers': {
      children: {
        'ICE Server #1': {
          input: 'string',
          subtext: 'ICE candidate server.',
          revert: () => parent.settings.iceServer1 = parent.defaults.iceServer1,
          set: value => parent.settings.iceServer1 = value,
          get: () => parent.settings.iceServer1
        },
        'ICE Server #2': {
          input: 'string',
          subtext: 'ICE candidate server.',
          revert: () => parent.settings.iceServer2 = parent.defaults.iceServer2,
          set: value => parent.settings.iceServer2 = value,
          get: () => parent.settings.iceServer2
        }
      }
    }
  }
});
const SettingsMenu = parent => {
  return {
    subtext: 'Edit your configuration.',
    children: () => {
      const children = {
        Video: videoMenu(parent),
        Audio: audioMenu(parent),
        Input: inputMenu(parent),
        Network: networkMenu(parent),
        Traces: _TraceMenu.TraceMenu
      };
      if (parent.args.debugEnabled) {
        children['Demos'] = _DemoMenu.DemoMenu;
        children['Costume'] = {
          children: {
            'Hue': {
              input: 'number',
              min: -180,
              max: +180,
              subtext: 'Rotate the color wheel.',
              subType: 'range',
              revert: () => parent.customColor.h = 0,
              set: value => parent.customColor.h = Number(value).toFixed(2),
              get: () => Number(parent.customColor.h).toFixed(2)
            },
            'Saturation': {
              input: 'number',
              min: 0,
              max: 2,
              step: 0.01,
              subType: 'range',
              subtext: 'Rotate the color wheel.',
              revert: () => parent.customColor.s = 1,
              set: value => parent.customColor.s = Number(value).toFixed(2),
              get: () => Number(parent.customColor.s).toFixed(2)
            },
            'Value': {
              input: 'number',
              min: 0,
              max: 2,
              step: 0.01,
              subType: 'range',
              subtext: 'Rotate the color wheel.',
              revert: () => parent.customColor.v = 1,
              set: value => parent.customColor.v = Number(value).toFixed(2),
              get: () => Number(parent.customColor.v).toFixed(2)
            }
          }
        };
      }
      return children;
    }
  };
};
exports.SettingsMenu = SettingsMenu;
});

;require.register("Menu/TraceMenu.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TraceMenu = void 0;
var _TraceDatabase = require("../trace/TraceDatabase");
var _ReplayDatabase = require("../replay/ReplayDatabase");
var _Replay = require("../replay/Replay");
const loadChildren = function (parent, menu) {
  let offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  return _TraceDatabase.TraceDatabase.open('traces', 1).then(database => {
    const store = 'traces';
    const index = 'id';
    const limit = 10;
    const direction = 'prev';
    const query = {
      store,
      index,
      direction,
      limit,
      offset
    };
    const children = {};
    return database.select(query).each(trace => {
      const subchildren = {
        'Export Trace': {
          callback: () => {
            // const shiftedDate = new Date(trace.created);
            const traceWin = window.open();
            traceWin.document.write(`${trace.uuid}\n` + `${trace.message}\n${trace.local}\n` + `${trace.buildTime}\n` + `${trace.created}\n\n` + `${trace.stack}\n`);
            traceWin.document.body.style.whiteSpace = 'pre';
            traceWin.document.body.style.fontFamily = 'monospace';
          }
        },
        'Export Replay': {
          callback: () => {
            _ReplayDatabase.ReplayDatabase.open('replays', 3).then(database => {
              const store = 'replays';
              const index = 'uuid';
              const type = _Replay.Replay;
              const range = trace.replay;
              const query = {
                store,
                index,
                offset,
                type,
                range
              };
              const children = {};
              database.select(query).one(replay => {
                const fileContents = new Blob([JSON.stringify(replay)], {
                  type: 'text/json'
                });
                const fileUrl = URL.createObjectURL(fileContents);
                const fileLink = document.createElement('a');
                fileLink.href = fileUrl;
                fileLink.download = `${replay.name || replay.uuid}.json`;
                fileLink.click();
              });
            });
          }
        }
      };
      if (parent.args.debugEnabled) {
        subchildren['View Replay'] = {
          callback: () => {
            _ReplayDatabase.ReplayDatabase.open('replays', 3).then(database => {
              const store = 'replays';
              const index = 'uuid';
              const type = _Replay.Replay;
              const range = trace.replay;
              const query = {
                store,
                index,
                offset,
                type,
                range
              };
              const children = {};
              console.log(trace.replay);
              parent.replayStart = parent.replayFrames.get(replay.firstFrame);
              database.select(query).one(replay => {
                parent.loadMap({
                  mapUrl: replay.map
                }).then(() => {
                  parent.replay = replay;
                  parent.replayFrames = replay.getIndexedFrames();
                  parent.maxReplayFrame = replay.lastFrame;
                  parent.args.paused = -1;
                  parent.args.frameId = -1;
                  parent.args.started = false;
                  parent.args.running = false;
                  parent.playback();
                  parent.replayOffset = -1 + replay.firstFrame;
                  if (loaded) {
                    menu.back();
                  }
                });
              });
            });
          }
        };
      }
      children[`${trace.id})${new Date(trace.created).toLocaleString('en-US')}`] = {
        subtext: trace.message,
        children: subchildren
      };
    }).then(results => {
      if (results.mapped) {
        children['Next ' + limit] = {
          children: () => loadChildren(parent, menu, offset + limit)
        };
      }
      return children;
    });
  });
};
const TraceMenu = {
  subtext: 'View error log.',
  children: loadChildren
};
exports.TraceMenu = TraceMenu;
});

require.register("Menu/ZoneSuffix.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ZoneSuffix = void 0;
var _View = require("curvature/base/View");
var _CharacterString = require("../ui/CharacterString");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class ZoneSuffix extends _View.View {
  constructor(args, parent) {
    super(args, parent);
    _defineProperty(this, "preserve", true);
    _defineProperty(this, "template", `<div class = "zone-suffix">
	<div class = "row">
		<!-- <div class = "checkpoint"></div> -->
		<div class = "rings">[[rings]]</div>
		<div class = "time">[[time]]</div>
		<div class = "score">[[score]]</div>
	</div>
	<div class = "row">
		<div class = "emblems" cv-each = "emblems:emblem">
			<img src = "/custom/hud-emblem.png" />
		</div>
	</div>
</div>`);
    _defineProperty(this, "font", 'small-menu-font');
    parent.loadSaves().then(saves => {
      const state = parent.getZoneState(this.args.map);
      const totalSeconds = Math.floor(state.time / 60);
      const ticks = String(Math.ceil(state.time % 60 * 1.67)).padEnd(2, '0');
      const seconds = String(state.time ? totalSeconds % 60 : 0).padStart(2, '0');
      const minutes = state.time ? Math.floor(totalSeconds / 60) : 0;
      this.args.emblems = state.emblems.slice(0, 5);
      this.args.rings = new _CharacterString.CharacterString({
        value: state.rings || 0,
        font: this.font
      });
      this.args.time = new _CharacterString.CharacterString({
        value: `${minutes}:${seconds}.${ticks}` || '--',
        font: this.font
      });
      this.args.air = new _CharacterString.CharacterString({
        value: (Number(state.air || 0) * 100).toFixed(2) + '%',
        font: this.font
      });
      this.args.score = new _CharacterString.CharacterString({
        value: state.score || 0,
        font: this.font
      });
      console.log();
    });
  }
}
exports.ZoneSuffix = ZoneSuffix;
});

;require.register("Menu/main-menu.html", function(exports, require, module) {
module.exports = "<div class = \"screen-card screen-card-[[cardName]] [[animation]]\">\n\n\t<div class = \"menu-scroller\"></div>\n\n\t[[pinch]]\n\t[[twist]]\n\n\t<section class = \"buttons\">\n\t\t<span>[[select]]</span>\n\t\t<span>[[ok]]</span>\n\t\t<span>[[back]]</span>\n\t\t<span>[[revert]]</span>\n\t</section>\n\n\t<section class = \"contents\" cv-if = \"!connected\">\n\t\t<div class = \"menu-container [[classes]]\" data-current-menu = \"[[currentKey]]\">\n\t\t\t<div>[[title]]</div>\n\t\t\t<div>\n\t\t\t\t<ul cv-ref = \"bound\" cv-each = \"items:item:title\">\n\n\t\t\t\t\t<li data-title = \"[[title]]\" class = \"[[item.available]]\" cv-on = \"click:run(item, event); auxclick:altRun(item, event); keyup(event, item):c\" tabindex=\"0\" data-tags = \"[[item.tags]]\">\n\t\t\t\t\t\t[[item.prefix]]\n\t\t\t\t\t\t<span class = \"title\">[[item._title]]</span>\n\t\t\t\t\t\t<span class = \"subtext\">[[item.subtext]]</span>\n\t\t\t\t\t\t<span cv-if = \"item.input\" cv-is = \"output\">\n\t\t\t\t\t\t\t<span data-wraps = \"output\">\n\t\t\t\t\t\t\t\t[[item._value]]\n\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t</span>\n\t\t\t\t\t\t<span cv-if = \"item.input\" cv-is = \"string\" class = \"field\">\n\t\t\t\t\t\t\t<span data-wraps = \"string\" data-click-barrier><input cv-ref = \"string\" cv-bind = \"item.setting\" cv-on = \"keyup(event, item);input:change(event, title)\" tabindex=\"-1\" /></span>\n\t\t\t\t\t\t</span>\n\t\t\t\t\t\t<span cv-if = \"item.input\" cv-is = \"number\" class = \"field\">\n\t\t\t\t\t\t\t<span data-wraps = \"number\" data-click-barrier><input cv-ref = \"number\" cv-bind = \"item.setting\" type = \"[[item.subType]]\" cv-on = \"keyup(event, item);change(event, title)\" tabindex=\"-1\" max = \"[[item.max]]\" min = \"[[item.min]]\" step = \"[[item.step]]\" title = \"[[item.setting]]\" /></span>\n\t\t\t\t\t\t\t<span cv-if = \"item.subType\" cv-is = \"range\">\n\t\t\t\t\t\t\t\t[[item._value]]\n\t\t\t\t\t\t\t\t<!-- <span data-wraps = \"number\" data-click-barrier><input cv-ref = \"number\" cv-bind = \"item.setting\" type = \"number\" cv-on = \"keyup(event, item);change(event, title)\" tabindex=\"-1\" max = \"[[item.max]]\" min = \"[[item.min]]\" step = \"[[item.step]]\" title = \"[[item.setting]]\" /></span> -->\n\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t</span>\n\t\t\t\t\t\t<span cv-if = \"item.input\" cv-is = \"boolean\" class = \"field\">\n\t\t\t\t\t\t\t<span data-wraps = \"select\">\n\t\t\t\t\t\t\t\t[[item._boolValue]]\n\t\t\t\t\t\t\t\t<select\n\t\t\t\t\t\t\t\t\tcv-on    = \"cvDomAttached:selectListRendered(event, item, title, $view, $subview, $parent);mousedown:cancel(event);input:change(event, title)\" cv-ref = \"boolean\"\n\t\t\t\t\t\t\t\t\tcv-bind = \"item.setting\"\n\t\t\t\t\t\t\t\t\ttabindex=\"-1\">\n\t\t\t\t\t\t\t\t<option value = \"1\">on</option>\n\t\t\t\t\t\t\t\t<option value = \"0\">off</option>\n\t\t\t\t\t\t\t</select></span>\n\t\t\t\t\t\t</span>\n\t\t\t\t\t\t<span cv-if = \"item.input\" cv-is = \"select\" class = \"field\">\n\t\t\t\t\t\t\t<span data-wraps = \"select\">\n\t\t\t\t\t\t\t\t[[item._selectValue]]\n\t\t\t\t\t\t\t\t<select\n\t\t\t\t\t\t\t\t\tcv-on    = \"input:change(event, title); listRendered:selectListRendered(event, item, title, $view, $subview, $parent);\"\n\t\t\t\t\t\t\t\t\tcv-ref   = \"options\"\n\t\t\t\t\t\t\t\t\tcv-bind  = \"item.setting\"\n\t\t\t\t\t\t\t\t\ttabindex = \"-1\"\n\t\t\t\t\t\t\t\t\tcv-each  = \"item.options:option\">\n\t\t\t\t\t\t\t\t\t<option value = \"[[option]]\">[[option]]</option>\n\t\t\t\t\t\t\t\t</select>\n\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t</span>\n\t\t\t\t\t\t[[item.suffix]]\n\t\t\t\t\t</li>\n\t\t\t\t</ul>\n\t\t\t</div>\n\t\t</div>\n\t</section>\n\n\t<section class = \"contents\" cv-if = \"!connected\">\n\t\t<section class = \"contents\" cv-if = \"lobby\">[[lobby]]</section>\n\t\t<section class = \"contents\" cv-if = \"hostGame\">\n\t\t\t<div class = \"token-exchange\" data-have-token = \"[[haveToken]]\">\n\t\t\t\t<label>\n\t\t\t\t\t<p>Input the token from your friend here.</p>\n\t\t\t\t\t<textarea cv-bind = \"input\" cv-on = \"click:paste(event)\"></textarea>\n\t\t\t\t\t<button cv-on = \"click:answer\">go!</button>\n\t\t\t\t</label>\n\n\t\t\t\t<label>\n\t\t\t\t\t<p>Send this token to your friend to get started.</p>\n\t\t\t\t\t<textarea cv-on = \"click:copy\" cv-ref = \"hostOutput\" cv-bind = \"hostOutput\" readonly = \"true\"></textarea>\n\t\t\t\t\t<button cv-on = \"click:copy\">[[copy]]</button>\n\t\t\t\t\t<div class = \"close\" cv-on = \"click:disconnect\"></div>\n\t\t\t\t</label>\n\t\t\t</div>\n\t\t</section>\n\n\t\t<section class = \"contents\" cv-if = \"joinGame\">\n\t\t\t<div class = \"token-exchange\">\n\t\t\t\t<label cv-if = \"haveToken\">\n\t\t\t\t\t<p>Send this token to your friend to get started.</p>\n\t\t\t\t\t<textarea cv-on = \"click:copy\" cv-ref = \"joinOutput\" cv-bind = \"joinOutput\" readonly = \"true\"></textarea>\n\t\t\t\t\t<button cv-on = \"click:copy\">[[copy]]</button>\n\t\t\t\t</label>\n\n\t\t\t\t<label cv-if = \"haveToken\">\n\t\t\t\t\t<p>Input the token they send back here.</p>\n\t\t\t\t\t<textarea cv-bind = \"input\" cv-on = \"click:paste(event)\"></textarea>\n\t\t\t\t\t<button cv-on = \"click:acceptRtp\">go!</button>\n\t\t\t\t\t<div class = \"close\" cv-on = \"click:disconnect\"></div>\n\t\t\t\t</label>\n\t\t\t</div>\n\t\t</section>\n\t</section>\n\t<section class = \"override\">[[override]]</section>\n</div>\n"
});

;require.register("Menu/menu.html", function(exports, require, module) {
module.exports = "<div class = \"screen-card screen-card-[[cardName]] [[animation]]\">\n\t<div class = \"menu-scroller\"></div>\n\t[[warp]]\n\t<div class = \"menu-container\" data-current-menu = \"[[currentKey]]\">\n\t\t<ul cv-ref = \"bound\" cv-each = \"items:item:title\">\n\t\t\t<li data-title = \"[[title]]\" class = \"[[item.available]]\" data-type = \"[[item.input]]\" data-sub-type = \"[[item.subType]]\" cv-on = \"click:run(item, event);cvDomDetached:removeItem(item);focus:handleFocus(event)\" tabindex=\"0\">\n\t\t\t\t<span class = \"title\">[[item._title]]</span>\n\t\t\t\t<span class = \"subtext\">[[item.subtext]]</span>\n\t\t\t\t<span cv-if = \"item.input\" cv-is = \"output\">\n\t\t\t\t\t: <span data-wraps = \"output\"><span cv-ref = \"output\" cv-bind = \"item.setting\"></span></span>\n\t\t\t\t</span>\n\t\t\t\t<span cv-if = \"item.input\" cv-is = \"string\">\n\t\t\t\t\t: <span data-wraps = \"string\"><input cv-ref = \"string\" cv-bind = \"item.setting\" cv-on = \"keyup(event);input:change(event)\" tabindex=\"-1\" /></span>\n\t\t\t\t</span>\n\t\t\t\t<span cv-if = \"item.input\" cv-is = \"number\">\n\t\t\t\t\t: <span data-wraps = \"number\"><input cv-ref = \"number\" cv-bind = \"item.setting\" type = \"[[item.subType]]\" cv-on = \"keyup(event);change(event)\" tabindex=\"-1\" max = \"[[item.max]]\" min = \"[[item.min]]\" step = \"[[item.step]]\" title = \"[[item.setting]]\" /></span>\n\t\t\t\t</span>\n\t\t\t\t<span cv-if = \"item.input\" cv-is = \"boolean\">\n\t\t\t\t\t: <span data-wraps = \"select\"><select cv-on = \"mousedown:cancel(event);change(event)\" cv-ref = \"boolean\" cv-bind = \"item.setting\" tabindex=\"-1\">\n\t\t\t\t\t\t<option value = \"1\">on</option>\n\t\t\t\t\t\t<option value = \"0\">off</option>\n\t\t\t\t\t</select></span>\n\t\t\t\t</span>\n\t\t\t\t<span cv-if = \"item.input\" cv-is = \"select\">\n\t\t\t\t\t: <span data-wraps = \"select\"><select cv-on = \"change(event)\" cv-ref = \"select\" cv-bind = \"item.setting\" tabindex=\"-1\" cv-each = \"options:option:o\">\n\t\t\t\t\t\t<option value = \"[[o]]\">[[o]]</option>\n\t\t\t\t\t</select></span>\n\t\t\t\t</span>\n\t\t\t</li>\n\t\t</ul>\n\t</div>\n</div>\n"
});

;require.register("Menu/pause-menu.html", function(exports, require, module) {
module.exports = "<div class = \"screen-card screen-card-[[cardName]] [[animation]] [[hideMenu]]\">\n\n\t<div class = \"menu-scroller\"></div>\n\n\t[[warp]]\n\n\t<section class = \"contents\" cv-if = \"!connected\">\n\n\t\t<div class = \"menu-container [[classes]]\" data-current-menu = \"[[currentKey]]\">\n\n\t\t\t<div>[[title]]</div>\n\n\t\t\t<ul cv-ref = \"bound\" cv-each = \"items:item:title\">\n\n\t\t\t\t<li data-title = \"[[title]]\" class = \"[[item.available]]\" data-type = \"[[item.input]]\" data-sub-type = \"[[item.subType]]\" style = \"--color:[[item.color]];\" cv-on = \"click:run(item, event):c; auxclick:altRun(item, event); keyup(event, item):c; focus:handleFocus(event);\" tabindex=\"0\">\n\t\t\t\t\t[[item.prefix]]\n\t\t\t\t\t<span class = \"title\">[[item._title]]</span>\n\t\t\t\t\t<span class = \"subtext\">[[item.subtext]]</span>\n\t\t\t\t\t<span cv-if = \"item.input\" cv-is = \"output\">\n\t\t\t\t\t\t: <span data-wraps = \"output\"><span cv-ref = \"output\" cv-bind = \"item.setting\"></span></span>\n\t\t\t\t\t</span>\n\t\t\t\t\t<span cv-if = \"item.input\" cv-is = \"string\" data-click-barrier>\n\t\t\t\t\t\t: <input cv-ref = \"string\" cv-bind = \"item.setting\" cv-on = \"keyup(event, item);input:change(event)\" tabindex=\"-1\" />\n\t\t\t\t\t</span>\n\t\t\t\t\t<span cv-if = \"item.input\" cv-is = \"number\">\n\t\t\t\t\t\t: <span data-wraps = \"number\" data-click-barrier>\n\t\t\t\t\t\t\t<input cv-ref = \"number\" cv-bind = \"item.setting\" type = \"[[item.subType]]\" cv-on = \"keyup(event, item);change(event)\" tabindex=\"-1\" max = \"[[item.max]]\" min = \"[[item.min]]\" step = \"[[item.step]]\" title = \"[[item.setting]]\"/>\n\t\t\t\t\t\t</span>\n\t\t\t\t\t</span>\n\t\t\t\t\t<span cv-if = \"item.input\" cv-is = \"boolean\">\n\t\t\t\t\t\t:\n\t\t\t\t\t\t<span data-wraps = \"select\">\n\t\t\t\t\t\t\t[[item._boolValue]]\n\t\t\t\t\t\t\t<select cv-on = \"click:mousedown:cancel(event);change(event)\" cv-ref = \"boolean\" cv-bind = \"item.setting\" tabindex=\"-1\">\n\t\t\t\t\t\t\t\t<option value = \"1\">on</option>\n\t\t\t\t\t\t\t\t<option value = \"0\">off</option>\n\t\t\t\t\t\t\t</select>\n\t\t\t\t\t\t</span>\n\t\t\t\t\t</span>\n\t\t\t\t\t<span cv-if = \"item.input\" cv-is = \"select\" class = \"field\">\n\t\t\t\t\t\t:\n\t\t\t\t\t\t<span data-wraps = \"select\">\n\t\t\t\t\t\t\t[[item._selectValue]]\n\t\t\t\t\t\t\t<select\n\t\t\t\t\t\t\t\tcv-on    = \"input:change(event, title); listRendered:selectListRendered(event, item, title, $view, $subview, $parent);\"\n\t\t\t\t\t\t\t\tcv-ref   = \"options\"\n\t\t\t\t\t\t\t\tcv-bind  = \"item.setting\"\n\t\t\t\t\t\t\t\ttabindex = \"-1\"\n\t\t\t\t\t\t\t\tcv-each  = \"item.options:option\">\n\t\t\t\t\t\t\t\t<option value = \"[[option]]\">[[option]]</option>\n\t\t\t\t\t\t\t</select>\n\t\t\t\t\t\t</span>\n\t\t\t\t\t</span>\n\t\t\t\t\t[[item.suffix]]\n\t\t\t\t</li>\n\t\t</ul>\n\n\t\t</div>\n\n\t</section>\n\n\t<section class = \"override\">[[override]]</section>\n\n</div>\n"
});

;require.register("ObjectPalette.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ObjectPalette = void 0;
var _PointActor = require("./actor/PointActor");
var _LayerSwitch = require("./actor/LayerSwitch");
var _Region = require("./region/Region");
var _ShadeRegion = require("./region/ShadeRegion");
var _BgShadeRegion = require("./region/BgShadeRegion");
var _FgShadeRegion = require("./region/FgShadeRegion");
var _WaterRegion = require("./region/WaterRegion");
var _DarkRegion = require("./region/DarkRegion");
var _LavaRegion = require("./region/LavaRegion");
var _ToxicRegion = require("./region/ToxicRegion");
var _PhazonRegion = require("./region/PhazonRegion");
var _RollingRegion = require("./region/RollingRegion");
var _SlidingRegion = require("./region/SlidingRegion");
var _GrindingRegion = require("./region/GrindingRegion");
var _ForceRegion = require("./region/ForceRegion");
var _FrictionRegion = require("./region/FrictionRegion");
var _CorkscrewRegion = require("./region/CorkscrewRegion");
var _BossRegion = require("./region/BossRegion");
var _ExitRegion = require("./region/ExitRegion");
var _LoadingRegion = require("./region/LoadingRegion");
var _ExplodingRegion = require("./region/ExplodingRegion");
var _SwitchRegion = require("./region/SwitchRegion");
var _RainRegion = require("./region/RainRegion");
var _DebrisRegion = require("./region/DebrisRegion");
var _WaterfallRegion = require("./region/WaterfallRegion");
var _KillRegion = require("./region/KillRegion");
var _VerticalRegion = require("./region/VerticalRegion");
var _VehicleRegion = require("./region/VehicleRegion");
var _DropVehicleRegion = require("./region/DropVehicleRegion");
var _PerspectiveRegion = require("./region/PerspectiveRegion");
var _CompanionBlock = require("./actor/CompanionBlock");
var _QuestionBlock = require("./actor/QuestionBlock");
var _MarbleBlock = require("./actor/MarbleBlock");
var _BreakableBlock = require("./actor/BreakableBlock");
var _Stopper = require("./actor/Stopper");
var _Zipline = require("./actor/Zipline");
var _Block3d = require("./actor/Block3d");
var _Block = require("./actor/Block");
var _Tree = require("./actor/Tree");
var _Coconut = require("./actor/Coconut");
var _Mushroom = require("./actor/Mushroom");
var _Door = require("./actor/Door");
var _PlatformFlare = require("./actor/PlatformFlare");
var _GravityPad = require("./actor/GravityPad");
var _Monitor = require("./actor/Monitor");
var _WebMonitor = require("./actor/monitor/WebMonitor");
var _RingMonitor = require("./actor/monitor/RingMonitor");
var _TripleRingMonitor = require("./actor/monitor/TripleRingMonitor");
var _InfoMonitor = require("./actor/monitor/InfoMonitor");
var _SheildStarMonitor = require("./actor/monitor/SheildStarMonitor");
var _SheildNormalMonitor = require("./actor/monitor/SheildNormalMonitor");
var _SheildFireMonitor = require("./actor/monitor/SheildFireMonitor");
var _SheildWaterMonitor = require("./actor/monitor/SheildWaterMonitor");
var _SheildElectricMonitor = require("./actor/monitor/SheildElectricMonitor");
var _Bumper = require("./actor/Bumper");
var _Flipper = require("./actor/Flipper");
var _SeeSaw = require("./actor/SeeSaw");
var _Windmill = require("./actor/Windmill");
var _Fan = require("./actor/Fan");
var _Cinematic = require("./actor/Cinematic");
var _Tumbler = require("./actor/Tumbler");
var _Flickie = require("./actor/Flickie");
var _Bubbles = require("./actor/Bubbles");
var _Redz = require("./actor/Redz");
var _GuardBot = require("./actor/GuardBot");
var _Sping = require("./actor/Sping");
var _CrabMeat = require("./actor/CrabMeat");
var _BuzzBomber = require("./actor/BuzzBomber");
var _MechaFroggy = require("./actor/MechaFroggy");
var _DrainFly = require("./actor/DrainFly");
var _GohlaBall = require("./actor/GohlaBall");
var _Voltorb = require("./actor/Voltorb");
var _Balkiry = require("./actor/Balkiry");
var _Jawz = require("./actor/Jawz");
var _SnailBot = require("./actor/SnailBot");
var _Motobug = require("./actor/Motobug");
var _BFish = require("./actor/BFish");
var _Grounder = require("./actor/Grounder");
var _Scratch = require("./actor/Scratch");
var _TechnoSqueak = require("./actor/TechnoSqueak");
var _Blastoid = require("./actor/Blastoid");
var _Meanie = require("./actor/Meanie");
var _SpringTurtle = require("./actor/SpringTurtle");
var _Sparkle = require("./actor/Sparkle");
var _Splats = require("./actor/Splats");
var _Relief = require("./actor/Relief");
var _Barnacle = require("./actor/Barnacle");
var _Skorp = require("./actor/Skorp");
var _RhinoBot = require("./actor/RhinoBot");
var _Gator = require("./actor/Gator");
var _ButterDroid = require("./actor/ButterDroid");
var _Catakiller = require("./actor/Catakiller");
var _CatakillerSegment = require("./actor/CatakillerSegment");
var _EggTroid = require("./actor/EggTroid");
var _SpitFire = require("./actor/SpitFire");
var _SpitSteam = require("./actor/SpitSteam");
var _Explosion = require("./actor/Explosion");
var _StarPost = require("./actor/StarPost");
var _ArrowSign = require("./actor/ArrowSign");
var _Emerald = require("./actor/Emerald");
var _FakeEmerald = require("./actor/FakeEmerald");
var _Window = require("./actor/Window");
var _Spring = require("./actor/Spring");
var _NotchSpring = require("./actor/NotchSpring");
var _BrokenMonitor = require("./actor/BrokenMonitor");
var _BoostRing = require("./actor/BoostRing");
var _Ring = require("./actor/Ring");
var _Coin = require("./actor/Coin");
var _Emblem = require("./actor/Emblem");
var _Apple = require("./actor/Apple");
var _AntiRing = require("./actor/AntiRing");
var _DropCage = require("./actor/DropCage");
var _SlotMachine = require("./actor/SlotMachine");
var _WaterFall = require("./actor/WaterFall");
var _WaterJet = require("./actor/WaterJet");
var _WaterSpout = require("./actor/WaterSpout");
var _PowerupGlow = require("./actor/PowerupGlow");
var _Projectile = require("./actor/Projectile");
var _TextActor = require("./actor/TextActor");
var _EggMobile = require("./actor/EggMobile");
var _SnowBoard = require("./actor/SnowBoard");
var _SkateBoard = require("./actor/SkateBoard");
var _DrillCar = require("./actor/DrillCar");
var _Tornado = require("./actor/Tornado");
var _RailCar = require("./actor/RailCar");
var _EggWalker = require("./actor/EggWalker");
var _EggShuttle = require("./actor/EggShuttle");
var _PogoSpring = require("./actor/PogoSpring");
var _NuclearSuperball = require("./actor/NuclearSuperball");
var _Platformer = require("./actor/Platformer");
var _MechaSonic = require("./actor/MechaSonic");
var _Eggrobo = require("./actor/Eggrobo");
var _Eggman = require("./actor/Eggman");
var _Sonic = require("./actor/Sonic");
var _Tails = require("./actor/Tails");
var _Knuckles = require("./actor/Knuckles");
var _Seymour = require("./actor/Seymour");
var _Chalmers = require("./actor/Chalmers");
var _Sean = require("./actor/Sean");
var _Big = require("./actor/Big");
var _Rocks = require("./actor/Rocks");
var _Switch = require("./actor/Switch");
var _HeavyDutySwitch = require("./actor/HeavyDutySwitch");
var _Balloon = require("./actor/Balloon");
var _StarBalloon = require("./actor/StarBalloon");
var _Spinner = require("./actor/Spinner");
var _HallBooster = require("./actor/HallBooster");
var _Springboard = require("./actor/Springboard");
var _GrapplePoint = require("./actor/GrapplePoint");
var _WoodenCrate = require("./actor/WoodenCrate");
var _SteelCrate = require("./actor/SteelCrate");
var _ChaoCrate = require("./actor/ChaoCrate");
var _UnbreakableCrate = require("./actor/UnbreakableCrate");
var _Rocket = require("./actor/Rocket");
var _Booster = require("./actor/Booster");
var _WindStone = require("./actor/WindStone");
var _Skull = require("./actor/Skull");
var _Pumpkin = require("./actor/Pumpkin");
var _RoadBarrier = require("./actor/RoadBarrier");
var _CautionPanel = require("./actor/CautionPanel");
var _Spikes = require("./actor/Spikes");
var _SpikesSmall = require("./actor/SpikesSmall");
var _Cone = require("./actor/Cone");
var _Fountain = require("./actor/Fountain");
var _CautionSign = require("./actor/CautionSign");
var _RollingSign = require("./actor/RollingSign");
var _Bell = require("./actor/Bell");
var _Torch = require("./actor/Torch");
var _LightSource = require("./actor/LightSource");
var _Signpost = require("./actor/Signpost");
var _Umbrella = require("./actor/Umbrella");
var _Dish = require("./actor/Dish");
var _RedEyeJet = require("./actor/RedEyeJet");
var _MiniMace = require("./actor/MiniMace");
var _MegaMace = require("./actor/MegaMace");
var _Beelzebub = require("./actor/Beelzebub");
var _MiniBoss = require("./actor/MiniBoss");
var _PogoEgg = require("./actor/PogoEgg");
var _Magnet = require("./actor/Magnet");
var _Pulley = require("./actor/Pulley");
var _PulleySmall = require("./actor/PulleySmall");
var _Orb = require("./actor/Orb");
var _OrbSmall = require("./actor/OrbSmall");
var _Egg = require("./actor/Egg");
var _Chao = require("./actor/Chao");
var _EggShellTop = require("./actor/EggShellTop");
var _EggShellBottom = require("./actor/EggShellBottom");
var _BackdropSwapper = require("./actor/BackdropSwapper");
var _LayerController = require("./actor/LayerController");
var _WaterController = require("./actor/WaterController");
var _TilesetSwapper = require("./actor/TilesetSwapper");
var _CutScene = require("./actor/CutScene");
var _HtmlFrame = require("./actor/HtmlFrame");
var _Panel = require("./actor/Panel");
var _Tester = require("./actor/Tester");
var _Cursor = require("./actor/Cursor");
var _MouseIndicator = require("./actor/MouseIndicator");
var _Spawner = require("./actor/Spawner");
var _NeverBetter = require("./actor/NeverBetter");
var _AsteroidLarge = require("./actor/AsteroidLarge");
var _AsteroidMedium = require("./actor/AsteroidMedium");
var _AsteroidSmall = require("./actor/AsteroidSmall");
var _Asteroid = require("./actor/Asteroid");
var _RocketPlatform = require("./actor/RocketPlatform");
var _PropellerPlatform = require("./actor/PropellerPlatform");
var _HexNut = require("./actor/HexNut");
var _SpinningFloat = require("./actor/SpinningFloat");
var _Turtloid = require("./actor/Turtloid");
var _CrossCannon = require("./actor/CrossCannon");
var _ChaoDetailer = require("./actor/ChaoDetailer");
var _Angel = require("./actor/Angel");
var _Flag = require("./actor/Flag");
var _GiantTire = require("./actor/GiantTire");
var _TruckBody = require("./actor/TruckBody");
var _TruckCab = require("./actor/TruckCab");
var _Dolphin = require("./actor/Dolphin");
var _Herculad = require("./actor/Herculad");
var _Chopper = require("./actor/Chopper");
var _TrickRamp = require("./actor/TrickRamp");
var _TwistRamp = require("./actor/TwistRamp");
var _AirBomb = require("./actor/AirBomb");
var _EggCapsule = require("./actor/EggCapsule");
var _SpikeRing = require("./actor/SpikeRing");
var _ToxicBarrel = require("./actor/ToxicBarrel");
var _SpinBridge = require("./actor/SpinBridge");
var _StoneAltar = require("./actor/StoneAltar");
var _BouncyMushroom = require("./actor/BouncyMushroom");
var _NitroBooster = require("./actor/NitroBooster");
var _LavaBall = require("./actor/LavaBall");
var _Propeller = require("./actor/Propeller");
var _GlassSphere = require("./actor/GlassSphere");
var _DropTarget = require("./actor/DropTarget");
var _BoostPole = require("./actor/BoostPole");
var _BallSwitch = require("./actor/BallSwitch");
var _ChainPull = require("./actor/ChainPull");
var _Crusher = require("./actor/Crusher");
var _Parachute = require("./actor/Parachute");
var _WallSwitch = require("./actor/WallSwitch");
// Newtron
// Bomb

// import { SuperRing }   from './actor/SuperRing';

const ObjectPalette = {
  player: _NuclearSuperball.NuclearSuperball,
  cinematic: _Cinematic.Cinematic,
  spring: _Spring.Spring,
  'layer-switch': _LayerSwitch.LayerSwitch,
  'layer-controller': _LayerController.LayerController,
  'water-controller': _WaterController.WaterController,
  'backdrop-swapper': _BackdropSwapper.BackdropSwapper,
  'tileset-swapper': _TilesetSwapper.TilesetSwapper,
  'star-post': _StarPost.StarPost,
  'arrow-sign': _ArrowSign.ArrowSign,
  'projectile': _Projectile.Projectile,
  'block3d': _Block3d.Block3d,
  'block': _Block.Block,
  'tree': _Tree.Tree,
  'coconut': _Coconut.Coconut,
  'mushroom': _Mushroom.Mushroom,
  'door': _Door.Door,
  'platform-flare': _PlatformFlare.PlatformFlare,
  'gravity-pad': _GravityPad.GravityPad,
  'q-block': _QuestionBlock.QuestionBlock,
  'marble-block': _MarbleBlock.MarbleBlock,
  'companion-block': _CompanionBlock.CompanionBlock,
  'breakable-block': _BreakableBlock.BreakableBlock,
  'stopper': _Stopper.Stopper,
  'zipline': _Zipline.Zipline,
  'bumper': _Bumper.Bumper,
  'flipper': _Flipper.Flipper,
  'see-saw': _SeeSaw.SeeSaw,
  'propeller': _Propeller.Propeller,
  'windmill': _Windmill.Windmill,
  'fan': _Fan.Fan,
  'drill-car': _DrillCar.DrillCar,
  'rail-car': _RailCar.RailCar,
  'tornado': _Tornado.Tornado,
  'egg-walker': _EggWalker.EggWalker,
  'snow-board': _SnowBoard.SnowBoard,
  'skate-board': _SkateBoard.SkateBoard,
  'egg-mobile': _EggMobile.EggMobile,
  'egg-shuttle': _EggShuttle.EggShuttle,
  'pogo-spring': _PogoSpring.PogoSpring,
  'rocks-tall': _Rocks.Rocks,
  'rocks-med': _Rocks.Rocks,
  'rocks-short': _Rocks.Rocks,
  'mecha-sonic': _MechaSonic.MechaSonic,
  'platformer': _Platformer.Platformer,
  'sonic': _Sonic.Sonic,
  'tails': _Tails.Tails,
  'knuckles': _Knuckles.Knuckles,
  'eggman': _Eggman.Eggman,
  'robotnik': _Eggman.Eggman,
  'eggrobo': _Eggrobo.Eggrobo,
  'seymour': _Seymour.Seymour,
  'chalmers': _Chalmers.Chalmers,
  'sean': _Sean.Sean,
  'big': _Big.Big,
  'switch': _Switch.Switch,
  'heavy-duty-switch': _HeavyDutySwitch.HeavyDutySwitch,
  'window': _Window.Window,
  'emerald': _Emerald.Emerald,
  'fake-emerald': _FakeEmerald.FakeEmerald,
  'base-region': _Region.Region,
  'region': _WaterRegion.WaterRegion,
  'lava-region': _LavaRegion.LavaRegion,
  'toxic-region': _ToxicRegion.ToxicRegion,
  'phazon-region': _PhazonRegion.PhazonRegion,
  'dark-region': _DarkRegion.DarkRegion,
  'shade-region': _ShadeRegion.ShadeRegion,
  'force-region': _ForceRegion.ForceRegion,
  'friction-region': _FrictionRegion.FrictionRegion,
  'corkscrew-region': _CorkscrewRegion.CorkscrewRegion,
  'rolling-region': _RollingRegion.RollingRegion,
  'sliding-region': _SlidingRegion.SlidingRegion,
  'grinding-region': _GrindingRegion.GrindingRegion,
  'exploding-region': _ExplodingRegion.ExplodingRegion,
  'boss-region': _BossRegion.BossRegion,
  'exit-region': _ExitRegion.ExitRegion,
  'loading-region': _LoadingRegion.LoadingRegion,
  'switch-region': _SwitchRegion.SwitchRegion,
  'rain-region': _RainRegion.RainRegion,
  'debris-region': _DebrisRegion.DebrisRegion,
  'waterfall-region': _WaterfallRegion.WaterfallRegion,
  'kill-region': _KillRegion.KillRegion,
  'vertical-region': _VerticalRegion.VerticalRegion,
  'vehicle-region': _VehicleRegion.VehicleRegion,
  'drop-vehicle-region': _DropVehicleRegion.DropVehicleRegion,
  'perspective-region': _PerspectiveRegion.PerspectiveRegion,
  'boost-ring': _BoostRing.BoostRing,
  'ring': _Ring.Ring,
  'antiring': _AntiRing.AntiRing
  // , 'super-ring':   SuperRing
  ,
  'coin': _Coin.Coin,
  'emblem': _Emblem.Emblem,
  'notch-spring': _NotchSpring.NotchSpring,
  'apple': _Apple.Apple,
  'drop-cage': _DropCage.DropCage,
  'slot-machine': _SlotMachine.SlotMachine,
  'powerup-glow': _PowerupGlow.PowerupGlow,
  'explosion': _Explosion.Explosion,
  'text-actor': _TextActor.TextActor,
  'water-jet': _WaterJet.WaterJet,
  'water-fall': _WaterFall.WaterFall,
  'water-spout': _WaterSpout.WaterSpout,
  'balloon': _Balloon.Balloon,
  'chain-pull': _ChainPull.ChainPull,
  'crusher': _Crusher.Crusher,
  'parachute': _Parachute.Parachute,
  'star-balloon': _StarBalloon.StarBalloon,
  'web-monitor': _WebMonitor.WebMonitor,
  'ring-monitor': _RingMonitor.RingMonitor,
  'triple-ring-monitor': _TripleRingMonitor.TripleRingMonitor,
  'info-monitor': _InfoMonitor.InfoMonitor,
  'sheild-fire-monitor': _SheildFireMonitor.SheildFireMonitor,
  'sheild-normal-monitor': _SheildNormalMonitor.SheildNormalMonitor,
  'sheild-star-monitor': _SheildStarMonitor.SheildStarMonitor,
  'sheild-water-monitor': _SheildWaterMonitor.SheildWaterMonitor,
  'sheild-electric-monitor': _SheildElectricMonitor.SheildElectricMonitor,
  'flickie': _Flickie.Flickie,
  'crabmeat': _CrabMeat.CrabMeat,
  'redz': _Redz.Redz,
  'guard-bot': _GuardBot.GuardBot,
  'sping': _Sping.Sping,
  'mecha-froggy': _MechaFroggy.MechaFroggy,
  'buzz-bomber': _BuzzBomber.BuzzBomber,
  'bubbles': _Bubbles.Bubbles,
  'drainfly': _DrainFly.DrainFly,
  'gohla-ball': _GohlaBall.GohlaBall,
  'voltorb': _Voltorb.Voltorb,
  'balkiry': _Balkiry.Balkiry,
  'jawz': _Jawz.Jawz,
  'snailbot': _SnailBot.SnailBot,
  'motobug': _Motobug.Motobug,
  'b-fish': _BFish.BFish,
  'grounder': _Grounder.Grounder,
  'scratch': _Scratch.Scratch,
  'techno-squeak': _TechnoSqueak.TechnoSqueak,
  'blastoid': _Blastoid.Blastoid,
  'meanie': _Meanie.Meanie,
  'spring-turtle': _SpringTurtle.SpringTurtle,
  'sparkle': _Sparkle.Sparkle,
  'splats': _Splats.Splats,
  'relief': _Relief.Relief,
  'barnacle': _Barnacle.Barnacle,
  'skorp': _Skorp.Skorp,
  'rhino-bot': _RhinoBot.RhinoBot,
  'gator': _Gator.Gator,
  'butter-droid': _ButterDroid.ButterDroid,
  'catakiller': _Catakiller.Catakiller,
  'catakiller-segment': _CatakillerSegment.CatakillerSegment,
  'eggtroid': _EggTroid.EggTroid,
  'spitfire': _SpitFire.SpitFire,
  'spitsteam': _SpitSteam.SpitSteam,
  'grapple-point': _GrapplePoint.GrapplePoint,
  'rocket': _Rocket.Rocket,
  'booster': _Booster.Booster,
  'spinner': _Spinner.Spinner,
  'hall-booster': _HallBooster.HallBooster,
  'springboard': _Springboard.Springboard,
  'wooden-crate': _WoodenCrate.WoodenCrate,
  'steel-crate': _SteelCrate.SteelCrate,
  'chao-crate': _ChaoCrate.ChaoCrate,
  'unbreakable-crate': _UnbreakableCrate.UnbreakableCrate,
  'road-barrier': _RoadBarrier.RoadBarrier,
  'caution-panel': _CautionPanel.CautionPanel,
  'signpost': _Signpost.Signpost,
  'umbrella': _Umbrella.Umbrella,
  'dish': _Dish.Dish,
  'red-eye-jet': _RedEyeJet.RedEyeJet,
  'beelzebub': _Beelzebub.Beelzebub,
  'pogo-egg': _PogoEgg.PogoEgg,
  'mini-boss': _MiniBoss.MiniBoss,
  'mini-mace': _MiniMace.MiniMace,
  'mega-mace': _MegaMace.MegaMace,
  'magnet': _Magnet.Magnet,
  'pulley': _Pulley.Pulley,
  'pulley-small': _PulleySmall.PulleySmall,
  'spikes': _Spikes.Spikes,
  'spikes-small': _SpikesSmall.SpikesSmall,
  'cone': _Cone.Cone,
  'wind-stone': _WindStone.WindStone,
  'skull': _Skull.Skull,
  'pumpkin': _Pumpkin.Pumpkin,
  'fountain': _Fountain.Fountain,
  'caution-sign': _CautionSign.CautionSign,
  'rolling-sign': _RollingSign.RollingSign,
  'bell': _Bell.Bell,
  'torch': _Torch.Torch,
  'glass-sphere': _GlassSphere.GlassSphere,
  'drop-target': _DropTarget.DropTarget,
  'boost-pole': _BoostPole.BoostPole,
  'ball-switch': _BallSwitch.BallSwitch,
  'wall-switch': _WallSwitch.WallSwitch,
  'light-source': _LightSource.LightSource,
  'orb': _Orb.Orb,
  'orb-small': _OrbSmall.OrbSmall,
  'chao': _Chao.Chao,
  'egg': _Egg.Egg,
  'egg-shell-top': _EggShellTop.EggShellTop,
  'egg-shell-bottom': _EggShellBottom.EggShellBottom,
  'cut-scene': _CutScene.CutScene
  // , 'html-frame': HtmlFrame
  ,
  'panel': _Panel.Panel,
  'tester': _Tester.Tester,
  'cursor': _Cursor.Cursor,
  'mouse-indicator': _MouseIndicator.MouseIndicator,
  'spawner': _Spawner.Spawner,
  'never-better': _NeverBetter.NeverBetter,
  'asteroid-large': _AsteroidLarge.AsteroidLarge,
  'asteroid-medium': _AsteroidMedium.AsteroidMedium,
  'asteroid-small': _AsteroidSmall.AsteroidSmall,
  'asteroid': _Asteroid.Asteroid,
  'rocket-platform': _RocketPlatform.RocketPlatform,
  'propeller-platform': _PropellerPlatform.PropellerPlatform,
  'hex-nut': _HexNut.HexNut,
  'spinning-float': _SpinningFloat.SpinningFloat,
  'turtloid': _Turtloid.Turtloid,
  'angel': _Angel.Angel,
  'chao-detailer': _ChaoDetailer.ChaoDetailer,
  'cross-cannon': _CrossCannon.CrossCannon,
  'tumbler': _Tumbler.Tumbler,
  'flag': _Flag.Flag,
  'giant-tire': _GiantTire.GiantTire,
  'truck-body': _TruckBody.TruckBody,
  'truck-cab': _TruckCab.TruckCab,
  'dolphin': _Dolphin.Dolphin,
  'herculad': _Herculad.Herculad,
  'chopper': _Chopper.Chopper,
  'trick-ramp': _TrickRamp.TrickRamp,
  'twist-ramp': _TwistRamp.TwistRamp,
  'air-bomb': _AirBomb.AirBomb,
  'egg-capsule': _EggCapsule.EggCapsule,
  'spike-ring': _SpikeRing.SpikeRing,
  'toxic-barrel': _ToxicBarrel.ToxicBarrel,
  'spin-bridge': _SpinBridge.SpinBridge,
  'stone-altar': _StoneAltar.StoneAltar,
  'bouncy-mushroom': _BouncyMushroom.BouncyMushroom,
  'nitro-booster': _NitroBooster.NitroBooster,
  'lava-ball': _LavaBall.LavaBall
};
exports.ObjectPalette = ObjectPalette;
});

require.register("QuadCell.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.QuadCell = void 0;
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
const CellRef = Symbol('CellRef');
class QuadCell {
  constructor(minSize) {
    let position = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
      x: 0,
      y: 0
    };
    let size = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
      x: 0,
      y: 0
    };
    let parent = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    _defineProperty(this, "position", {});
    _defineProperty(this, "size", {});
    _defineProperty(this, "divided", false);
    _defineProperty(this, "parent", null);
    _defineProperty(this, "leafPoint", {
      x: null,
      y: null
    });
    _defineProperty(this, "leafRefs", null);
    _defineProperty(this, "ld", null);
    _defineProperty(this, "rd", null);
    _defineProperty(this, "lu", null);
    _defineProperty(this, "ru", null);
    _defineProperty(this, "cells", []);
    _defineProperty(this, "minSize", 0);
    this.parent = parent;
    this.position.x = position.x;
    this.position.y = position.y;
    this.size.x = size.x;
    this.size.y = size.y;
    this.minSize = minSize;
    Object.seal(this);
  }
  empty() {
    let depth = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    if (!this.divided) {
      if (!this.leafRefs) {
        return true;
      }
      return !this.leafRefs.size;
    }
    for (const c in this.cells) {
      if (!this.cells[c].empty(depth + 1)) {
        return false;
      }
    }
    return true;
  }
  insert(object) {
    let point = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
      x: 0,
      y: 0
    };
    if (!this.contains(point)) {
      return false;
    }
    if (!this.leafRefs && !this.divided) {
      this.leafRefs = new Set();
      this.leafPoint.x = point.x;
      this.leafPoint.y = point.y;
      this.leafRefs.add(object);
      object[CellRef] = this;
      return true;
    } else if (this.size.x <= this.minSize) {
      this.leafRefs.add(object);
      object[CellRef] = this;
      return true;
    } else if (this.leafRefs && point.x === this.leafPoint.x && point.y === this.leafPoint.y) {
      this.leafRefs.add(object);
      object[CellRef] = this;
      return true;
    } else if (!this.divided) {
      this.divide();
    }
    for (const cell of this.cells) {
      if (cell.insert(object, point)) {
        return true;
      }
    }
    return false;
  }
  move(object, point) {
    const cell = object[CellRef];
    if (cell) {
      if (cell.leafPoint.x === point.x && cell.leafPoint.y === point.y) {
        return;
      }
      object[CellRef] = null;
      cell.leafRefs.delete(object);
      if (cell.parent) {
        cell.parent.join();
      }
    }
    this.insert(object, point);
  }
  remove(object) {
    const cell = object[CellRef];
    if (!cell) {
      return;
    }
    object[CellRef] = null;
    cell.leafRefs.delete(object);
    if (cell.parent) {
      cell.parent.join();
    }
  }
  join() {
    if (!this.empty()) {
      return false;
    }
    let nonEmpty = null;
    for (const cell of this.cells) {
      if (!cell.empty()) {
        if (nonEmpty) {
          return false;
        }
        nonEmpty = cell;
      }
    }
    this.ld = null;
    this.rd = null;
    this.lu = null;
    this.ru = null;
    this.cells = [];
    this.divided = false;
    if (nonEmpty) {
      nonEmpty.leafRefs.forEach(l => this.insert(l));
    }
    if (this.parent) {
      this.parent.join();
    }
  }
  divide() {
    if (this.divided) {
      return false;
    }
    const p = this.position;
    const s = this.size;
    const m = this.minSize;
    this.ld = new this.constructor(m, {
      x: p.x - s.x / 4,
      y: p.y - s.y / 4
    }, {
      x: s.x / 2,
      y: s.y / 2
    }, this);
    this.rd = new this.constructor(m, {
      x: p.x + s.x / 4,
      y: p.y - s.y / 4
    }, {
      x: s.x / 2,
      y: s.y / 2
    }, this);
    this.lu = new this.constructor(m, {
      x: p.x - s.x / 4,
      y: p.y + s.y / 4
    }, {
      x: s.x / 2,
      y: s.y / 2
    }, this);
    this.ru = new this.constructor(m, {
      x: p.x + s.x / 4,
      y: p.y + s.y / 4
    }, {
      x: s.x / 2,
      y: s.y / 2
    }, this);
    this.cells.push(this.ld, this.rd, this.lu, this.ru);
    this.divided = true;
    if (!this.leafRefs.size) {
      return true;
    }
    refs: for (const ref of this.leafRefs) {
      cells: for (const cell of this.cells) {
        const inserted = cell.insert(ref, this.leafPoint);
        if (inserted) {
          this.leafRefs.delete(ref);
          continue refs;
        }
      }
    }
  }
  contains() {
    let point = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
      x: 0,
      y: 0
    };
    const xMin = this.position.x - this.size.x / 2;
    const xMax = this.position.x + this.size.x / 2;
    if (point.x < xMin || point.x > xMax) {
      return false;
    }
    const yMin = this.position.y - this.size.y / 2;
    const yMax = this.position.y + this.size.y / 2;
    if (point.y < yMin || point.y > yMax) {
      return false;
    }
    return true;
  }
  select(xPos, yPos, xSize, ySize) {
    let depth = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
    if (this.empty()) {
      return [];
    }
    const xMax = xSize / 2 + this.size.x / 2;
    if (xMax < Math.abs(xPos - this.position.x)) {
      return [];
    }
    const yMax = ySize / 2 + this.size.y / 2;
    if (yMax < Math.abs(yPos - this.position.y)) {
      return [];
    }
    if (this.divided) {
      const results = new Set();
      for (const cell of this.cells) {
        for (const result of cell.select(xPos, yPos, xSize, ySize, depth + 1)) {
          results.add(result);
        }
      }
      return results;
    }
    return this.leafRefs ? this.leafRefs : [];
  }
}
exports.QuadCell = QuadCell;
});

;require.register("ScriptPalette.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ScriptPalette = void 0;
const ScriptPalette = {
  'infinite-ruin': require('./zoneScripts/InfiniteRuin').InfiniteRuin,
  'chao-garden': require('./zoneScripts/ChaoGarden').ChaoGarden
};
exports.ScriptPalette = ScriptPalette;
});

;require.register("World.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.World = void 0;
var _Bag = require("curvature/base/Bag");
var _Bindable = require("curvature/base/Bindable");
var _TileMap = require("tileMap/TileMap");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class World {
  constructor() {
    _defineProperty(this, "tileMap", new _TileMap.TileMap());
    this.viewports = new _Bag.Bag((i, s, a) => {
      switch (a) {
        case BAG.ITEM_ADDED:
          i.world = this;
          break;
        case BAG.ITEM_REMOVED:
          i.world = null;
          break;
      }
    });
    this.actors = new _Bag.Bag((i, s, a) => {
      switch (a) {
        case BAG.ITEM_ADDED:
          i.world = this;
          break;
        case BAG.ITEM_REMOVED:
          i.world = null;
          break;
      }
    });
  }
  getOnScreenObjects(tolerance) {}
  update() {}
}
exports.World = World;
_defineProperty(World, "globals", _Bindable.Bindable.make({}));
});

;require.register("abilities/LightDash.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LightDash = void 0;
class LightDash {}
exports.LightDash = LightDash;
});

;require.register("actor/AirBomb.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AirBomb = void 0;
var _PointActor = require("./PointActor");
var _Sfx = require("../audio/Sfx");
var _Tag = require("curvature/base/Tag");
class AirBomb extends _PointActor.PointActor {
  constructor() {
    super(...arguments);
    this.args.width = 22;
    this.args.height = 32;
    this.args.type = 'actor-item actor-air-bomb';
    this.args.decel = 0;
    this.explosions = new Set();
  }
  update() {
    if (!this.args.falling && !this.explosions.size) {
      this.explode();
    }
    super.update();
    for (const explosion of this.explosions) {
      explosion.style({
        '--x': this.args.x,
        '--y': this.args.y + -16
      });
    }
  }
  collideA(other) {
    if (!other.controllable) {
      return;
    }
    other.damage(this);
    this.explode();
    this.args.float = -1;
    this.args.xSpeed = 0;
    this.args.ySpeed = 0;
  }
  explode() {
    if (this.exploded) {
      return;
    }
    this.exploded = true;
    this.args.type = 'actor-item actor-air-bomb hide';
    const explosionTag = document.createElement('div');
    explosionTag.classList.add('particle-huge-explosion');
    const explosion = new _Tag.Tag(explosionTag);
    this.explosions.add(explosion);
    const viewport = this.viewport;
    this.viewport.particles.add(explosion);
    this.viewport.onFrameOut(30, () => {
      viewport.particles.remove(explosion);
      viewport.actors.remove(this);
      this.explosions.delete(explosion);
    });
    _Sfx.Sfx.play('OBJECT_DESTROYED');
  }
}
exports.AirBomb = AirBomb;
});

;require.register("actor/Angel.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Angel = void 0;
var _PointActor = require("./PointActor");
var _Liftable = require("../behavior/Liftable");
class Angel extends _PointActor.PointActor {
  constructor() {
    super(...arguments);
    this.args.type = 'actor-item actor-angel';
    this.args.width = 45;
    this.args.height = 80;
  }
}
exports.Angel = Angel;
});

;require.register("actor/AntiRing.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AntiRing = void 0;
var _PointActor = require("./PointActor");
var _Sfx = require("../audio/Sfx");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class AntiRing extends _PointActor.PointActor {
  constructor() {
    var _this$args$static, _this$args$dropped, _this$args$delay;
    super(...arguments);
    _defineProperty(this, "template", `<div class  = "point-actor [[type]]">
		<div class = "sprite" cv-ref = "sprite"></div>
	</div>`);
    _defineProperty(this, "float", -1);
    this.args.type = 'actor-item actor-anti-ring';
    this.args.width = 15;
    this.args.height = 15;
    this.args.static = (_this$args$static = this.args.static) !== null && _this$args$static !== void 0 ? _this$args$static : true;
    this.args.dropped = (_this$args$dropped = this.args.dropped) !== null && _this$args$dropped !== void 0 ? _this$args$dropped : true;
    this.args.gone = false;
    this.args.gravity = 0.40;
    this.args.delay = (_this$args$delay = this.args.delay) !== null && _this$args$delay !== void 0 ? _this$args$delay : 48;
  }
  update() {
    if (!this.viewport) {
      return;
    }
    const currentFrame = this.viewport.args.frameId;
    const startFrame = this.startFrame;
    const age = currentFrame - startFrame;
    if (this.args.noClip) {
      this.noClip = true;
    } else if (!this.args.decoration) {
      if (this.args.ySpeed < 0) {
        this.noClip = true;
      } else if (!this.attract) {
        this.noClip = false;
      }
    } else {
      this.noClip = true;
    }
    if (this.args.decoration) {
      this.args.type = 'actor-item actor-anti-ring decoration';
      this.args.gravity = 0.36;
    }
    if (this.dropped) {
      this.args.type = 'actor-item actor-anti-ring dropped';
      this.args.height = 14;
    }
    const viewport = this.viewport;
    if (this.dropped && this.viewport && !this.viewport.actorIsOnScreen(this, 256)) {
      viewport.onFrameOut(15, () => {
        viewport.actors.remove(this);
      });
    }
    if (this.args.reward && this.args.gone) {
      viewport.onFrameOut(15, () => {
        viewport.actors.remove(this);
      });
    }
    super.update();
    if (this.args.reward) {
      return;
    }
    if (this.getMapSolidAt(this.x + this.args.xSpeed * this.args.direction, this.y + -8)) {
      this.args.xSpeed *= -1;
    }
    if ((this.dropped || this.scattered) && (!this.args.falling || !this.args.ySpeed)) {
      this.args.xSpeed = this.args.xSpeed || this.xSpeedLast || Math.random() - 0.5;
      this.args.ySpeed = Math.min(-Math.abs(this.args.ySpeed || this.ySpeedLast || 0) * 0.75, -5);
      this.args.gSpeed = 0;
      this.args.x += this.args.xSpeed;
      this.args.y += this.args.ySpeed;
      this.args.falling = true;
      this.args.groundAngle = 0;
    }
  }
  callCollideHandler(other) {
    if (other instanceof AntiRing) {
      return false;
    }
    return super.callCollideHandler(other);
  }
  collideA(other) {
    if (other instanceof this.constructor) {
      return;
    }
    if (!this.viewport || this.args.gone || this.args.ignore) {
      return false;
    }
    if (!other.controllable && !other.occupant && !other.args.owner) {
      return false;
    }
    const age = this.viewport.args.frameId - this.startFrame;
    if (this.dropped && age < this.args.delay) {
      return false;
    }
    super.collideA(other);
    if (other.args.owner) {
      other = other.args.owner;
    }
    if (other.occupant) {
      other = other.occupant;
    }
    if (other.controllable) {
      other.args.rings -= 1;
    }
    this.args.gone = true;
    this.viewport.auras.delete(this);

    // this.args.xSpeed = 0;
    // this.args.ySpeed = 0;
    this.args.static = true;
    this.args.float = -1;
    this.args.type = 'actor-item actor-anti-ring collected';
    this.args.xSpeed = 0;
    this.args.ySpeed = 0;
    if (this.viewport.args.audio) {
      _Sfx.Sfx.play('SPIKE_DAMAGE');
    }
    this.viewport.onFrameOut(5, () => {
      this.args.type = 'actor-item actor-anti-ring collected gone';
    });
    const x = this.x;
    const y = this.y;
    const viewport = this.viewport;
    this.viewport.onFrameOut(1200, () => {
      this.restore = true;
    });
    if (other.collect) {
      this.onNextFrame(() => {
        other.collect(this);
      });
    }

    // this.args.xSpeed = 0;
    // this.args.ySpeed = 0;
  }

  wakeUp() {
    if (this.def && this.restore) {
      this.args.x = this.def.get('x');
      this.args.y = this.def.get('y');
      // this.args.float = -1;

      this.args.gone = this.restore = false;
      this.args.type = 'actor-item actor-anti-ring';
    }
  }
  get solid() {
    return false;
  }
  get rotateLock() {
    return true;
  }
}
exports.AntiRing = AntiRing;
});

;require.register("actor/Apple.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Apple = void 0;
var _PointActor = require("./PointActor");
var _Sfx = require("../audio/Sfx");
class Apple extends _PointActor.PointActor {
  constructor() {
    super(...arguments);
    this.args.width = 11;
    this.args.height = 11;
    this.args.type = 'actor-item actor-apple';
    this.args.float = -1;
    this.collected = false;
  }
  onRendered(event) {
    // const zoneState = this.viewport.getZoneState();
    // if(zoneState.apples.includes(this.args.id))
    // {
    // 	this.args.type = 'actor-item actor-apple actor-apple-collected';
    // 	this.collected = true;
    // }

    return super.onRendered(event);
  }
  collideA(other) {
    if (!other.controllable || this.gone) {
      return;
    }
    const viewport = this.viewport;
    const zoneState = viewport.getZoneState();
    if (!this.collected) {
      // other.args.apples.push(this);
      // zoneState.apples.push(this.args.id);
      this.args.type = 'actor-item actor-apple actor-apple-gone';
    } else {
      this.args.type = 'actor-item actor-apple actor-apple-gone actor-apple-collected';
    }
    this.gone = true;
    viewport.onFrameOut(20, () => {
      viewport.actors.remove(this);
    });
    viewport.currentSave.save();
    if (this.viewport.args.audio) {
      _Sfx.Sfx.play('apple_COLLECTED');
    }
  }
}
exports.Apple = Apple;
});

;require.register("actor/ArrowSign.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ArrowSign = void 0;
var _PointActor = require("./PointActor");
var _Tag = require("curvature/base/Tag");
var _Projectile = require("../actor/Projectile");
var _Monitor = require("./Monitor");
var _RingMonitor = require("./monitor/RingMonitor");
var _SheildFireMonitor = require("./monitor/SheildFireMonitor");
var _SheildWaterMonitor = require("./monitor/SheildWaterMonitor");
var _SheildElectricMonitor = require("./monitor/SheildElectricMonitor");
class ArrowSign extends _PointActor.PointActor {
  static fromDef(objDef) {
    const obj = super.fromDef(objDef);
    obj.args.rotation = objDef.rotation;
    obj.args.height = objDef.height;
    return obj;
  }
  constructor() {
    var _this$args$float, _this$args$static;
    let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let parent = arguments.length > 1 ? arguments[1] : undefined;
    super(args, parent);
    this.args.type = 'actor-item actor-arrow-sign';
    this.args.float = (_this$args$float = this.args.float) !== null && _this$args$float !== void 0 ? _this$args$float : -1;
    this.args.static = (_this$args$static = this.args.static) !== null && _this$args$static !== void 0 ? _this$args$static : true;
    this.args.width = args.width || 32;
    this.args.height = args.height || 64;
  }
  onRendered(event) {
    super.onRendered(event);
    if (this.headBox) {
      return;
    }
    this.headBox = new _Tag.Tag('<div class = "arrow-sign-head-box">');
    this.post = new _Tag.Tag('<div class = "arrow-sign-post">');
    this.head = new _Tag.Tag('<div class = "arrow-sign-head">');
    this.sprite.appendChild(this.post.node);
    this.headBox.appendChild(this.head.node);
    this.sprite.appendChild(this.headBox.node);
    this.args.bindTo(['point', 'height'], (v, k) => {
      this.headBox.style({
        ['--' + k]: v
      });
    });
  }
  get solid() {
    return false;
  }
}
exports.ArrowSign = ArrowSign;
});

;require.register("actor/Asteroid.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Asteroid = void 0;
var _PointActor = require("./PointActor");
var _Block = require("./Block");
var _Sfx = require("../audio/Sfx");
var _AsteroidLarge = require("./AsteroidLarge");
class Asteroid extends _PointActor.PointActor {
  constructor() {
    super(...arguments);
    this.args.width = 80;
    this.args.height = 80;
    this.args.type = 'actor-item actor-asteroid';
    this.args.float = -1;
    this.args.static = 1;
    this.args.spawned = false;
    this.args.firedAt = 0;
  }
  sleep() {
    this.args.spawned = false;
  }
  update() {
    if (!this.viewport) {
      return;
    }
    const viewport = this.viewport;
    if (viewport.controlActor) {
      if (viewport.controlActor.args.respawning) {
        return;
      }
      if (viewport.controlActor.args.y < this.args.y) {
        return;
      }
      if (Math.abs(viewport.controlActor.args.y - this.args.y) < 128) {
        return;
      }
    }
    if (viewport.args.frameId - this.args.firedAt < 90) {
      super.update();
      return;
    }
    if (this.args.spawned) {
      this.args.spawned = Math.random() >= 0.01;
      super.update();
      return;
    }
    if (viewport.actorIsOnScreen(this, 128)) {
      viewport.spawn.add({
        object: new _AsteroidLarge.AsteroidLarge({
          xSpeed: this.args.xSpeed,
          ySpeed: this.args.ySpeed,
          x: this.args.x,
          y: this.args.y
        })
      });
      this.args.spawned = true;
      this.args.firedAt = viewport.args.frameId;
    } else {
      this.args.spawned = false;
    }
    super.update();
  }

  // get solid() { return true };
}
exports.Asteroid = Asteroid;
});

;require.register("actor/AsteroidBase.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AsteroidBase = void 0;
var _PointActor = require("./PointActor");
var _Block = require("./Block");
var _Sfx = require("../audio/Sfx");
class AsteroidBase extends _PointActor.PointActor {
  constructor() {
    super(...arguments);
    this.args.width = 80;
    this.args.height = 80;
    this.args.type = 'actor-item actor-asteroid';
    this.args.broken = false;
    this.args.decel = 0;
  }
  sleep() {
    this.viewport && this.viewport.actors.remove(this);
  }
  update() {
    if (!this.viewport || this.args.broken) {
      super.update();
      this.args.groundAngle = 0;
      return;
    }
    const viewport = this.viewport;
    if (!this.args.falling) {
      this.break();
    }
    super.update();
    this.args.groundAngle = 0;
    if (!this.viewport.actorIsOnScreen(this, 128)) {
      this.viewport && this.viewport.actors.remove(this);
    }
  }
  get rotateLock() {
    return true;
  }
}
exports.AsteroidBase = AsteroidBase;
});

;require.register("actor/AsteroidLarge.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AsteroidLarge = void 0;
var _Tag = require("curvature/base/Tag");
var _PointActor = require("./PointActor");
var _Block = require("./Block");
var _Sfx = require("../audio/Sfx");
var _AsteroidMedium = require("./AsteroidMedium");
var _AsteroidBase = require("./AsteroidBase");
class AsteroidLarge extends _AsteroidBase.AsteroidBase {
  constructor() {
    super(...arguments);
    this.args.type = `${this.args.type} actor-asteroid-large`;
    this.args.gravity = 0.45;
    this.args.width = 64;
    this.args.height = 80;
  }
  update() {
    super.update();
    if (!this.viewport || this.viewport.args.frameId % 3) {
      return;
    }
    const dustParticle = new _Tag.Tag(document.createElement('div'));
    dustParticle.classList.add('particle-dust');
    dustParticle.style({
      '--x': this.args.x,
      '--y': this.args.y + -this.args.height - 0.75,
      'z-index': 0,
      opacity: Math.random() * 0.25 + 0.5
    });
    viewport.particles.add(dustParticle);
    viewport.onFrameOut(30, () => {
      viewport.particles.remove(dustParticle);
    });
  }
  collideA(other) {
    if (!other.controllable || this.args.broken || other.args.mercy) {
      return;
    }
    if (other.args.y < this.args.y + -this.args.height * 0.75) {
      return;
    }
    this.args.xSpeed = 0;
    other.damage(this, 'rock');
    _Sfx.Sfx.play('ROCK_BREAK_1');
    this.break();
  }
  break() {
    const xSpeed = this.xSpeedLast || this.gSpeedLast || 0;
    const ySpeed = this.ySpeedLast || 0;
    const pieces = [new _AsteroidMedium.AsteroidMedium({
      falling: true,
      x: this.args.x - 20,
      y: this.args.y - 20,
      xSpeed,
      ySpeed: -ySpeed * 0.25 + -1.5,
      xSpeed: xSpeed * 0.333 - 0.5
    }), new _AsteroidMedium.AsteroidMedium({
      falling: true,
      x: this.args.x + 20,
      y: this.args.y - 20,
      xSpeed,
      ySpeed: -ySpeed * 0.25 + -1.5,
      xSpeed: xSpeed * 0.333 + 0.5
    }), new _AsteroidMedium.AsteroidMedium({
      falling: true,
      x: this.args.x + 0,
      y: this.args.y - 4,
      xSpeed,
      ySpeed: -ySpeed * 0.25 + -1.0,
      xSpeed: xSpeed * 0.333 + 0.0
    }), new _AsteroidMedium.AsteroidMedium({
      falling: true,
      x: this.args.x + 0,
      y: this.args.y - 40,
      xSpeed,
      ySpeed: -ySpeed * 0.25 + -2.0,
      xSpeed: xSpeed * 0.333 + 0.0
    })];
    pieces.forEach(object => viewport.spawn.add({
      object
    }));
    viewport.onFrameOut(1, () => viewport.actors.remove(this));
    this.args.broken = true;
    _Sfx.Sfx.play('ROCK_BREAK_1');
  }
}
exports.AsteroidLarge = AsteroidLarge;
});

;require.register("actor/AsteroidMedium.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AsteroidMedium = void 0;
var _PointActor = require("./PointActor");
var _Block = require("./Block");
var _Sfx = require("../audio/Sfx");
var _AsteroidSmall = require("./AsteroidSmall");
var _AsteroidBase = require("./AsteroidBase");
class AsteroidMedium extends _AsteroidBase.AsteroidBase {
  constructor() {
    super(...arguments);
    this.args.type = `${this.args.type} actor-asteroid-medium`;
    this.args.gravity = 0.50;
    this.args.width = 48;
    this.args.height = 48;
  }
  collideA(other) {
    if (!other.controllable || this.args.broken || other.args.mercy) {
      return;
    }
    if (other.args.y < this.args.y + -this.args.height * 0.75) {
      return;
    }

    // this.args.xSpeed = 0;

    other.damage(this, 'rock');
    _Sfx.Sfx.play('ROCK_BREAK_2');
  }
  break() {
    const xSpeed = this.xSpeedLast || this.gSpeedLast || 0;
    const ySpeed = this.ySpeedLast || 0;
    const pieces = [new _AsteroidSmall.AsteroidSmall({
      falling: true,
      x: this.args.x + 0,
      y: this.args.y - 24,
      ySpeed: ySpeed * -0.5 - 1,
      xSpeed: xSpeed + 0.00
    }), new _AsteroidSmall.AsteroidSmall({
      falling: true,
      x: this.args.x + 0,
      y: this.args.y + 0,
      ySpeed: ySpeed * -0.5 - 1,
      xSpeed: xSpeed + 0.00
    }), new _AsteroidSmall.AsteroidSmall({
      falling: true,
      x: this.args.x - 14,
      y: this.args.y - 12,
      ySpeed: ySpeed * -0.5 - 1,
      xSpeed: xSpeed - 0.15
    }), new _AsteroidSmall.AsteroidSmall({
      falling: true,
      x: this.args.x + 14,
      y: this.args.y - 12,
      ySpeed: ySpeed * -0.5 - 1,
      xSpeed: xSpeed + 0.15
    })];
    pieces.forEach(object => viewport.spawn.add({
      object
    }));
    viewport.onFrameOut(1, () => viewport.actors.remove(this));
    this.args.broken = true;
    _Sfx.Sfx.play('ROCK_BREAK_2');
  }
}
exports.AsteroidMedium = AsteroidMedium;
});

;require.register("actor/AsteroidSmall.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AsteroidSmall = void 0;
var _PointActor = require("./PointActor");
var _Block = require("./Block");
var _Sfx = require("../audio/Sfx");
class AsteroidSmall extends _PointActor.PointActor {
  constructor() {
    super(...arguments);
    this.args.width = 32;
    this.args.height = 32;
    // this.args.gravity = 0.85;
    this.args.type = 'actor-item actor-asteroid-small';
    this.noClip = true;
    // this.args.float = -1;
  }

  sleep() {
    this.viewport && this.viewport.actors.remove(this);
  }
  collideA(other) {
    if (!other.controllable || other.args.mercy) {
      return;
    }
    this.args.xSpeed = 0;
    other.damage(this, 'rock');
    _Sfx.Sfx.play('ROCK_BREAK_2');
  }
  damage() {}
  get rotateLock() {
    return true;
  }
} // get solid() { return true };
exports.AsteroidSmall = AsteroidSmall;
});

;require.register("actor/BFish.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BFish = void 0;
var _Flickie = require("./Flickie");
var _Mixin = require("curvature/base/Mixin");
var _Tag = require("curvature/base/Tag");
var _PointActor = require("./PointActor");
var _SkidDust = require("../behavior/SkidDust");
var _Patrol = require("../behavior/Patrol");
var _CanPop = require("../mixin/CanPop");
class BFish extends _Mixin.Mixin.from(_PointActor.PointActor, _CanPop.CanPop) {
  constructor() {
    let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let parent = arguments.length > 1 ? arguments[1] : undefined;
    const jumpForce = args.jumpForce || 14;
    super(args, parent);
    this.behaviors.add(new _SkidDust.SkidDust());
    this.behaviors.add(new _Patrol.Patrol());
    this.args.type = 'actor-item actor-b-fish';
    this.args.animation = 'standing';

    // this.args.accel     = 0.1;
    // this.args.decel     = 0.5;

    this.noClip = true;
    this.args.gSpeedMax = 5;
    this.args.jumpForce = jumpForce || 14;
    this.args.jumpDelay = this.args.jumpDelay || 0;
    this.args.gravity = 0.5;
    this.args.width = 24;
    this.args.height = 32;
    this.willStick = false;
    this.stayStuck = false;
  }
  update() {
    const yStart = this.def.get('y');
    if (this.age <= this.args.jumpDelay) {
      this.args.float = -1;
    } else {
      this.args.float = false;
    }
    if (this.age > this.args.jumpDelay && this.args.y > yStart) {
      this.viewport.onNextFrame(() => this.args.ySpeed = -this.args.jumpForce);
    }
    super.update();
  }
  get solid() {
    return false;
  }
  get isEffect() {
    return false;
  }
  // get controllable() { return true; }
}
exports.BFish = BFish;
});

;require.register("actor/BackdropController.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BackdropController = void 0;
var _PointActor = require("./PointActor");
var _BackdropPalette = require("../BackdropPalette");
class BackdropController extends _PointActor.PointActor {
  constructor(args, parent) {
    super(args, parent);
    this.args.hidden = true;
  }
  activate(other, button) {
    // this.viewport.tilemap.replacements.set(
    // 	this.args.original//'../Sonic/tiles/azure-lake/azure-lake.png'
    // 	, this.args.replacement//'../Sonic/tiles/azure-lake/azure-lake-burnt.png'
    // );
  }
}
exports.BackdropController = BackdropController;
});

;require.register("actor/BackdropSwapper.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BackdropSwapper = void 0;
var _PointActor = require("./PointActor");
var _BackdropPalette = require("../BackdropPalette");
class BackdropSwapper extends _PointActor.PointActor {
  constructor(args, parent) {
    super(args, parent);
    this.args.hidden = true;
  }
  activate(other, button) {
    // this.viewport.tilemap.replacements.set(
    // 	this.args.original//'../Sonic/tiles/azure-lake/azure-lake.png'
    // 	, this.args.replacement//'../Sonic/tiles/azure-lake/azure-lake-burnt.png'
    // );
  }
}
exports.BackdropSwapper = BackdropSwapper;
});

;require.register("actor/Balkiry.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Balkiry = void 0;
var _Flickie = require("./Flickie");
var _Spring = require("./Spring");
var _Mixin = require("curvature/base/Mixin");
var _Tag = require("curvature/base/Tag");
var _PointActor = require("./PointActor");
var _SkidDust = require("../behavior/SkidDust");
var _CanPop = require("../mixin/CanPop");
var _Explosion = require("../actor/Explosion");
var _Projectile = require("../actor/Projectile");
class Balkiry extends _Mixin.Mixin.from(_PointActor.PointActor, _CanPop.CanPop) {
  constructor() {
    super(...arguments);
    this.args.type = 'actor-item actor-balkiry';
    this[_Spring.Spring.WontSpring] = true;
    this.args.animation = 'standing';
    this.args.accel = 0.1;
    this.args.decel = 0.5;
    this.args.gSpeedMax = 5;
    this.args.jumpForce = 5;
    this.args.gravity = 0.5;
    this.args.width = 32;
    this.args.height = 16;
    this.willStick = false;
    this.stayStuck = false;
    this.args.float = -1;
    this.noClip = true;
  }
  onRendered() {
    super.onRendered();
    this.flame = new _Tag.Tag('<div class = "balkiry-flame">');
    this.sprite.appendChild(this.flame.node);
    this.box.setAttribute('data-animation', 'standing');
  }
  update() {
    // this.args.facing  = 'right';
    this.args.facing = 'left';
    if (this.args.xSpeed > -12) {
      this.args.xSpeed -= 0.1;
    }
    this.args.ySpeed = 0;
    this.args.falling = true;
    this.args.flying = true;
    super.update();
  }
  effect(other) {
    super.effect(other);

    // this.viewport.spawn.add({object:new Flickie({
    // 	x: this.args.x,
    // 	y: this.args.y,
    // })});
  }

  wakeUp() {}
  sleep() {
    // this.args.x = this.def.get('x');
    // this.args.y = this.def.get('y');
  }
  get solid() {
    return false;
  }
  // get controllable() { return true; }
  get isEffect() {
    return false;
  }
}
exports.Balkiry = Balkiry;
});

;require.register("actor/BallSwitch.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BallSwitch = void 0;
var _Sfx = require("../audio/Sfx");
var _PointActor = require("./PointActor");
class BallSwitch extends _PointActor.PointActor {
  constructor() {
    super(...arguments);
    this.args.width = this.args.width || 20;
    this.args.height = this.args.height || 32;
    this.args.type = 'actor-item actor-ball-switch';
    this.args.z = 100;
    this.args.xShift = 0;
    this.args.timeout = this.args.timeout || -1;
    this.activeTimer = 0;
  }
  onRendered(event) {
    super.onRendered(event);
    this.autoStyle.get(this.box)['--xShift'] = 'xShift';
    this.autoStyle.get(this.box)['--yShift'] = 'yShift';
  }
  collideA(other) {
    const speed = other.args.gSpeed || other.args.xSpeed;
    this.args.xShift += speed * 1.5;
    if (Math.abs(this.args.xShift) > 10) {
      this.args.xShift = 10 * Math.sign(this.args.xShift);
    }
    this.args.yShift = 4 * Math.cos(this.args.xShift / 10);
  }
  sleep() {
    this.args.active = false;
  }
  update() {
    super.update();
    if (this.args.colliding) {
      return;
    }
    this.args.xShift *= 0.925;
    if (Math.abs(this.args.xShift) <= 1) {
      this.args.xShift = 0;
    }
    if (this.activeTimer > 0) {
      this.activeTimer--;
      if (!this.activeTimer) {
        this.args.active = false;
      }
    }
    if (Math.abs(this.args.xShift) > 6) {
      if (!this.args.active) {
        _Sfx.Sfx.play('BALL_SWITCH');
      }
      this.args.active = true;
      if (this.args.timeout > 0) {
        this.activeTimer = this.args.timeout;
      }
    }
    this.args.yShift = 4 * Math.cos(this.args.xShift / 12);
  }
  get solid() {
    return false;
  }
}
exports.BallSwitch = BallSwitch;
});

;require.register("actor/Balloon.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Balloon = void 0;
var _PointActor = require("./PointActor");
class Balloon extends _PointActor.PointActor {
  constructor() {
    super(...arguments);
    this.args.type = 'actor-item actor-balloon';
    this.args.width = 32;
    this.args.height = 33;
    this.args.float = -1;
    this.args.airAngle = -Math.PI;
  }
  collideA(other) {
    if (!other.controllable) {
      return;
    }
  }
}
exports.Balloon = Balloon;
});

;require.register("actor/Barnacle.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Barnacle = void 0;
var _Mixin = require("curvature/base/Mixin");
var _PointActor = require("./PointActor");
var _Patrol = require("../behavior/Patrol");
var _CanPop = require("../mixin/CanPop");
var _BarnacleTrap = require("./BarnacleTrap");
class Barnacle extends _Mixin.Mixin.from(_PointActor.PointActor, _CanPop.CanPop) {
  constructor() {
    var _this$args$patrolPaus, _this$args$patrolBeat, _this$args$patrolSpee, _this$args$showOff;
    super(...arguments);

    // this.behaviors.add(new Patrol);

    this.args.type = 'actor-item actor-barnacle';
    this.args.animation = 'standing';
    this.args.accel = 0.1;
    this.args.decel = 0.5;
    this.args.gSpeedMax = 5;
    this.args.gravity = 0.75;
    this.args.width = 34;
    this.args.height = 32;
    this.args.float = -1;
    this.willStick = false;
    this.stayStuck = false;
    this.args.patrolPause = (_this$args$patrolPaus = this.args.patrolPause) !== null && _this$args$patrolPaus !== void 0 ? _this$args$patrolPaus : 10;
    this.args.patrolBeat = (_this$args$patrolBeat = this.args.patrolBeat) !== null && _this$args$patrolBeat !== void 0 ? _this$args$patrolBeat : 200;
    this.args.patrolSpeed = (_this$args$patrolSpee = this.args.patrolSpeed) !== null && _this$args$patrolSpee !== void 0 ? _this$args$patrolSpee : 1;
    this.args.showOff = (_this$args$showOff = this.args.showOff) !== null && _this$args$showOff !== void 0 ? _this$args$showOff : false;
    this.args.state = 'waiting';
    if (this.args.showOff) {
      this.args.state = 'intro';
    }
    this.args.bindTo('state', () => this.args.stateAge = 0);
  }
  update() {
    super.update();
    if (!this.trap) {
      this.mountPoint = new _PointActor.PointActor();
      this.trap = new _BarnacleTrap.BarnacleTrap();
      this.trap.owner = this;
      this.mountPoint.args.x = this.trap.args.x = this.args.x;
      this.mountPoint.args.y = this.trap.args.y = this.args.y;
      this.mountPoint.args.y -= 24;
      this.mountPoint.noClip = true;
      this.mountPoint.args.float = -1;
      this.mountPoint.args.hidden = true;
      this.trap.others.tiedTo = this.mountPoint;
      if (!this.args.showOff) {
        this.trap.args.y += this.findRopeLength();
        this.trap.args.ropeLength = this.findRopeLength();
        this.trap.args.xSpeed += 2 * Math.sign(Math.random() + -0.5);
      }

      // this.trap.render();
      // this.trap.initialize();

      this.viewport.spawn.add({
        object: this.trap
      });
      // this.viewport.spawn.add({object:this.mountPoint});
    }

    if (this.trap.stuck.size && this.trap.args.ySpeed <= 0) {
      this.trap.args.xSpeed *= 0.85;
    }
    const state = this.args.state;
    if (typeof this['state_' + state]) {
      this['state_' + state]();
    }
  }
  pop(other) {
    this.viewport.actors.remove(this.trap);
    this.viewport.actors.remove(this.mountPoint);
    super.pop(other);
  }
  updateEnd() {
    super.updateEnd();
    this.args.stateAge++;
  }
  state_intro() {
    this.trap.args.ropeLength = 2;
    if (this.args.stateAge > 45) {
      this.args.state = 'spitting';
    }
  }
  state_waiting() {
    this.args.animation = 'idle';
    if (this.args.stateAge > 40 && this.trap.stuck.size) {
      this.args.state = 'feeding';
    }
    if (this.trap.args.ropeLength <= 0) {
      this.args.state = 'spitting';
    }
  }
  state_carriage() {
    this.args.animation = 'idle';
    if (typeof this.trap.args.ropeLength === 'undefined') {
      this.trap.args.ropeLength = 0;
    }
    if (this.args.stateAge > 40) {
      this.args.state = 'feeding';
    }
  }
  state_feeding() {
    this.args.animation = 'feeding';
    if (this.args.stateAge > 15) {
      if (this.trap.args.ropeLength > 48) {
        this.trap.args.ropeLength -= 5;
      } else {
        this.trap.args.ropeLength -= 3;
      }
      this.trap.args.falling = true;
    }
    if (this.args.stateAge > 25) {
      this.args.state = 'carriage';
    }
    if (this.trap.args.ropeLength <= 0) {
      this.trap.args.ropeLength = 0;
      this.trap.args.float = -1;
      this.args.state = 'spitting';
      this.trap.args.xSpeed = 0;
      this.trap.args.ySpeed = 0;
      for (const [other] of this.trap.stuck) {
        if (typeof other.pop === 'function') {
          this.viewport.onFrameOut(10, () => {
            this.trap.stuck.delete(other);
            this.trap.ignores.set(other, 60);
            other.pop();
          });
        }
      }
    }
  }
  state_spitting() {
    if (this.args.stateAge === 60) {
      this.trap.args.xSpeed += 2 * Math.sign(Math.random() + -0.5);
      // this.trap.args.xSpeed = 3;
    }

    if (this.args.stateAge > 40) {
      const length = this.findRopeLength();
      this.trap.args.ropeLength = length + -0;
      this.args.animation = 'spit';
      this.trap.args.float = 0;
      this.trap.args.ySpeed = Math.max(2, this.trap.args.ySpeed);
    } else {
      // this.trap.args.xSpeed = 0;
      // this.trap.args.ySpeed = 0;
    }
    if (this.args.stateAge > 70) {
      this.args.state = 'waiting';
    }
  }
  findRopeLength() {
    if (!this.viewport) {
      return 0;
    }
    const endpoint = this.viewport.tileMap.castRay(this.args.x, this.args.y, Math.PI / 2, 2048);
    return Math.hypot(this.args.x - endpoint[0], this.args.y - endpoint[1]) || 128;
  }
  get solid() {
    return false;
  }
  get isEffect() {
    return false;
  }
}
exports.Barnacle = Barnacle;
});

;require.register("actor/BarnacleTrap.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BarnacleTrap = void 0;
var _PointActor = require("./PointActor");
var _Mixin = require("curvature/base/Mixin");
var _Constrainable = require("../mixin/Constrainable");
class BarnacleTrap extends _Mixin.Mixin.from(_PointActor.PointActor, _Constrainable.Constrainable) {
  constructor() {
    super(...arguments);
    this.args.type = 'actor-item actor-barnacle-trap';
    this.args.width = 8;
    this.args.height = 8;
    this.args.ropeLength = 0;
    // this.args.float  = -1;

    // this.args.airAngle = -Math.PI;

    this.stuck = new Map();
    this.noClip = true;
    this.onRemove(() => {
      for (const [other, entry] of this.stuck) {
        other.args.float = 0;
        other.args.stuck = false;
      }
    });
  }
  update() {
    if (!this.others.tiedTo) {
      super.update();
    }
  }
  updateEnd() {
    super.update();
    if (!this.viewport) {
      return;
    }
    for (const [other, entry] of this.stuck) {
      if (this.viewport.args.frameId % 25 === 0) {
        entry.wiggles = Math.min(8, 1 + entry.wiggles);
      }
    }
    const tiedTo = this.others.tiedTo;
    if (tiedTo) {
      this.setPos();
    }
    for (const [other, entry] of this.stuck) {
      other.args.xSpeed = other.xAxis;
      other.args.ySpeed = 0;
      if (other.args.mercy || other.args.dead || entry.wiggles <= 0) {
        this.stuck.delete(other);
        this.ignores.set(other, 15);
        other.args.stuck = false;
        if (!other.args.dead) {
          other.args.float = 0;
        }
      } else {
        this.args.xSpeed += other.xAxis * 0.1;
        if (Math.abs(this.args.xSpeed) > 3) {
          this.args.xSpeed = 3 * Math.sign(this.args.xSpeed);
        }
        other.args.x = this.args.x;
        other.args.y = this.args.y + other.args.height + -this.args.height;
        other.args.float = -1;
        other.args.falling = true;
        other.dashed = false;
        other.args.stuck = true;
        other.args.jumping = false;
        other.args.spinning = false;
        other.args.cameraBias = 0.2;
        if (other.controllable) {
          other.args.animation = 'walking';
        }
      }
      if (other.xAxis) {
        if (Math.sign(entry.xAxisLast) !== Math.sign(other.xAxis)) {
          entry.wiggles--;
        }
        entry.xAxisLast = other.xAxis;
      }
    }
    if (Math.abs(this.args.xSpeed) < 2 && this.args.ySpeed > 0 && this.args.ySpeed < 2 && this.args.rope > 32) {
      this.args.xSpeed = 2 * Math.sign(this.args.xSpeed);
    }
    super.updateEnd();
  }
  collideA(other) {
    if (other === this.owner) {
      return;
    }
    if (!other.controllable && typeof other.pop !== 'function') {
      return;
    }
    if (other.args.mercy || other.args.dead || this.stuck.size) {
      return;
    }
    if (!this.stuck.has(other)) {
      this.stuck.set(other, {
        xAxisLast: 0,
        wiggles: 8,
        yDiff: other.args.y - this.args.y
      });
      this.args.falling = true;
      this.args.xSpeed = other.args.xSpeed || other.args.gSpeed;
      this.args.x = other.args.x;
    }
  }
  get solid() {
    return false;
  }
}
exports.BarnacleTrap = BarnacleTrap;
});

;require.register("actor/Beelzebub.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Beelzebub = void 0;
var _Tag = require("curvature/base/Tag");
var _PointActor = require("./PointActor");
var _Platformer = require("../behavior/Platformer");
var _Mixin = require("curvature/base/Mixin");
var _CanPop = require("../mixin/CanPop");
var _CutScene = require("./CutScene");
var _EggCapsule = require("./EggCapsule");
var _Sfx = require("../audio/Sfx");
var _Analytic = require("../lib/Analytic");
class Beelzebub extends _Mixin.Mixin.from(_PointActor.PointActor) {
  constructor(args, parent) {
    super(args, parent);
    this.args.type = 'actor-item actor-beelzebub';
    this.args.width = 64;
    this.args.height = 32;
    this.args.float = -1;
    this.args.damagers = new Map();
    this.args.phase = 'idle';
    this.args.hitPoints = 8;
    this.args.noseAngle = Math.PI / 2 * 3;
    this.args.drillPush = 0;
    this.args.phaseFrameId = 0;
    this.args.frameId = 0;
    this.args.direction = -1;
    this.args.facing = 'left';
    this.args.bindTo('phase', v => this.args.phaseFrameId = 0);

    // this.clearScene = new CutScene({src: '/cutscenes/clear-seaview.json'});
  }

  onRendered(event) {
    super.onRendered(event);
    this.autoStyle.get(this.box)['--nose-angle'] = 'noseAngle';
    this.autoStyle.get(this.box)['--drill-push'] = 'drillPush';
    this.autoAttr.get(this.box)['data-phase'] = 'phase';
    this.drill = new _Tag.Tag(`<div class = "drill">`);
    this.body = new _Tag.Tag(`<div class = "body">`);
    this.nose = new _Tag.Tag(`<div class = "nose">`);
    this.eyeBack = new _Tag.Tag(`<div class = "eye-back">`);
    this.eyeFore = new _Tag.Tag(`<div class = "eye-fore">`);
    this.body.appendChild(this.eyeBack.node);
    this.body.appendChild(this.eyeFore.node);
    this.body.appendChild(this.nose.node);
    this.sprite.appendChild(this.body.node);
    this.nose.appendChild(this.drill.node);
    this.attractor = null;

    // this.clearScene.viewport = this.viewport;
  }

  update() {
    this.args.phaseFrameId++;
    this.args.frameId++;
    if (!this.viewport) {
      return;
    }
    const viewport = this.viewport;
    viewport.auras.add(this);
    const mainChar = this.viewport.controlActor;
    if (!mainChar || mainChar.args.respawning) {
      return;
    }
    if (!this.attractor) {
      this.attractor = {};
      this.attractor.x = this.x;
      this.attractor.y = this.y;
    }
    const xDiff = Math.abs(this.x - this.attractor.x);
    const yDiff = Math.abs(this.y - this.attractor.y);
    const xSign = Math.sign(this.x - this.attractor.x);
    const ySign = Math.sign(this.y - this.attractor.y);
    switch (this.args.phase) {
      case 'idle':
        this.args.xSpeed = 0;
        this.args.ySpeed = 0;
        break;
      case 'intro':
        if (this.args.phaseFrameId > 30) {
          this.args.phase = 'stalking';
        }
        break;
      case 'alert':
        if (this.args.phaseFrameId > 4) {
          this.args.drillPush = 1;
          this.args.falling = true;
          this.args.float = -1;
          if (this.y > this.args.alertTo) {
            this.args.ySpeed--;
          } else {
            this.args.y = this.args.alertTo;
            this.args.ySpeed = 0;
          }
        }
        if (this.args.phaseFrameId > 0) {
          this.args.phase = 'stalking';
        }
        break;
      case 'damaged':
        if (this.args.hitPoints > 0) {
          if (this.args.phaseFrameId > 20) {
            this.args.phase = 'stalking';
          }
        } else {
          if (this.args.phaseFrameId > 6) {
            this.args.phase = 'dead';
          }
        }
        break;
      case 'knocked':
        this.args.xSpeed = 0;
        if (this.args.phaseFrameId > 30) {
          this.args.phase = 'stalking';
        }
        break;
      case 'dead':
        this.args.float = 0;
        break;
      case 'stalking':
        {
          this.args.xSpeed = -xSign * Math.max(1, xDiff / 25);
          this.args.ySpeed = -ySign * Math.max(1, yDiff / 25);
          this.args.ySpeed += Math.sin(this.args.frameId / 3) * 3;
          if (this.pointIsSafe(mainChar.x, mainChar.y - 128)) {
            this.attractor.x = mainChar.x;
            this.attractor.y = mainChar.y - 128;
          }
          this.args.noseAngle = Math.PI / 2 * 3;
          this.args.drillPush = 0;
          if (this.args.phaseFrameId > 10) {
            this.args.noseAngle = this.angleTo({
              x: mainChar.x,
              y: Math.max(this.y, mainChar.y)
            });
          }
          if (this.args.phaseFrameId > 20) {
            this.args.drillPush = 0.5;
          }
          if (this.args.phaseFrameId > 25) {
            this.args.phase = 'ready';
          }
          break;
        }
      case 'buzzing':
        {
          if (this.pointIsSafe(mainChar.x, mainChar.y + -mainChar.args.height + -34)) {
            this.attractor.x = mainChar.x;
            this.attractor.y = mainChar.y + -mainChar.args.height + -34;
          }
          this.args.xSpeed = -xSign * Math.max(1, xDiff / 15);
          this.args.ySpeed = -ySign * Math.max(1, yDiff / 15);
          this.args.noseAngle = Math.PI / 2 * 3;
          this.args.drillPush = 1;
          if (this.args.phaseFrameId > 10) {
            this.args.drillPush = 0.5;
          }
          if (this.args.phaseFrameId > 20) {
            this.args.noseAngle = this.angleTo({
              x: mainChar.x,
              y: Math.max(this.y, mainChar.y)
            });
          }
          if (this.args.phaseFrameId > 30) {
            this.args.phase = 'ready';
          }
          break;
        }
      case 'ready':
        {
          if (this.args.phaseFrameId < 10) {
            this.readySide = Math.sign(mainChar.xSpeedLast || mainChar.gSpeedLast);
          }
          if (this.pointIsSafe(mainChar.x + 128 * this.readySide, mainChar.y + -mainChar.args.height + -128)) {
            this.attractor.x = mainChar.x + 128 * this.readySide;
            this.attractor.y = mainChar.y + -mainChar.args.height + -128;
          }
          this.args.xSpeed = -xSign * Math.max(1, xDiff / 15);
          this.args.ySpeed = -ySign * Math.max(1, yDiff / 15);
          this.args.ySpeed += Math.sin(this.args.frameId / 3) * 3;
          this.args.drillPush = 0.75;
          if (this.args.phaseFrameId > 30) {
            const dieRoll = Math.random();
            if (!mainChar.args.falling) {
              if (dieRoll > 0.5) {
                this.args.phase = 'swooping';
              } else {
                this.args.phase = 'attacking';
              }
            } else {
              if (dieRoll > 0.5) {
                this.args.phase = 'buzzing';
              } else {
                this.args.phase = 'stalking';
              }
            }
          }
          break;
        }
      case 'attacking':
        {
          this.args.float = -1;
          this.args.falling = true;
          if (this.args.phaseFrameId > 100) {
            this.args.phase = 'stalking';
          }
          if (this.args.phaseFrameId < 50) {
            if (this.pointIsSafe(mainChar.x + 256 * (this.readySide || 1), mainChar.y - 32)) {
              this.attractor.x = mainChar.x + 256 * (this.readySide || 1);
              this.attractor.y = mainChar.y - 32;
            }
            this.args.noseAngle = 0;
          } else {
            if (this.pointIsSafe(mainChar.x + 256 * (-this.readySide || -1), mainChar.y - 16)) {
              this.attractor.x = mainChar.x + 256 * (-this.readySide || -1);
              this.attractor.y = mainChar.y - 16;
            }
            this.args.noseAngle = this.angleTo({
              x: mainChar.x,
              y: Math.max(this.y, mainChar.y)
            });
          }
          this.args.drillPush = 1;
          this.args.float = -1;
          const mainSpeed = mainChar.args.xSpeed || mainChar.args.gSpeed;
          this.args.xSpeed = -xSign * Math.max(1, xDiff / 10) + mainSpeed * 1.1;
          this.args.ySpeed = -ySign * Math.max(1, yDiff / 10);
          break;
        }
      case 'swooping':
        {
          if (this.pointIsSafe(mainChar.x, mainChar.y - 32)) {
            this.attractor.x = mainChar.x;
            this.attractor.y = mainChar.y - 32;
          }
          this.args.xSpeed += -xSign * Math.max(1, xDiff / 10000);
          this.args.ySpeed += -ySign * Math.max(1, yDiff / 10000);
          this.args.noseAngle = this.angleTo({
            x: mainChar.x,
            y: Math.max(this.y, mainChar.y)
          });
          this.args.drillPush = 1;
          this.args.float = -1;
          if (this.args.phaseFrameId > 180) {
            this.args.phase = 'stalking';
          }
          const mainSpeed = mainChar.args.xSpeed || mainChar.args.gSpeed;
          break;
        }
      case 'exploding':
        if (this.args.phaseFrameId === 90) {
          this.args.falling = true;
          this.args.ySpeed = -14;
          this.args.xSpeed = 0;
          this.args.gSpeed = 0;
          this.noClip = true;
          this.viewport.auras.delete(this);
          this.args.phase = 'exploded';

          // this.clearScene.activate(mainChar, this, true);

          _Sfx.Sfx.play('OBJECT_DESTROYED');
          if (viewport && viewport.controlActor) {
            const other = viewport.controlActor;
            viewport.onFrameOut(60, () => {
              const capsule = new _EggCapsule.EggCapsule({
                x: other.args.x,
                y: other.args.y - 384,
                xSpeed: other.args.gSpeed || other.args.xSpeed
              });
              viewport.spawn.add({
                object: capsule
              });
            });
          }
        }
        if (this.args.phaseFrameId > 90) {
          return;
        }
        if (viewport && viewport.args.frameId % 3 === 0) {
          const explosion = new _Tag.Tag('<div class = "particle-explosion">');
          _Sfx.Sfx.play('BOSS_DAMAGED');
          const xOff = this.args.width * Math.random() - this.args.width / 2;
          const yOff = this.args.height * Math.random() - this.args.height / 2;
          explosion.style({
            '--x': this.x + xOff,
            '--y': this.y + yOff + -16
          });
          viewport.particles.add(explosion);
          setTimeout(() => viewport.particles.remove(explosion), 512);
        }
        break;
    }
    if (this.args.phase !== 'knocked') {
      if (this.args.ySpeed < 0 && !this.pointIsSafe(this.x, this.y + -this.args.height + this.args.ySpeed + -1)) {
        this.args.ySpeed = 0;
      }
    }
    super.update();
  }
  updateEnd() {
    super.updateEnd();
    if (!this.viewport) {
      return;
    }
    const mainChar = this.viewport.controlActor;
    if (!mainChar) {
      return;
    }
    if (this.args.hitPoints <= 0) {
      mainChar.cofocused = null;
    }
    const xDiff = Math.abs(this.args.x - mainChar.x);
    const yDiff = Math.abs(this.args.y - mainChar.y);
    const xSign = Math.sign(this.args.x - mainChar.x);
    const ySign = Math.sign(this.args.y - mainChar.y);
    switch (this.args.phase) {
      case 'attacking':
      case 'swooping':
      case 'stalking':
      case 'knocked':
      case 'damaged':
      case 'ready':
        {
          if (xDiff > 384) {
            this.args.x = mainChar.x + 384 * xSign;
          }
          if (yDiff > 192) {
            this.args.y = mainChar.y + 192 * ySign;
          }
          if (this.args.hitPoints <= 0) {
            this.viewport.auras.delete(this);
            this.args.phase = 'dead';
            this.noClip = false;
            this.args.float = 0;
            if (typeof ga === 'function') {
              _Analytic.Analytic.report({
                eventCategory: 'boss',
                eventAction: 'defeated',
                eventLabel: `${this.viewport.args.actName}::${this.args.id}`
              });
            }
          }
          break;
        }
    }
    if (this.args.xSpeed < 0) {
      this.args.facing = 'left';
    } else if (this.args.xSpeed > 0) {
      this.args.facing = 'right';
    }
    this.args.groundAngle = 0;
    switch (this.args.phase) {
      case 'attacking':
      case 'swooping':
      case 'stalking':
      case 'ready':
        {
          if (this.bMap('checkBelow', this.x, this.y).get(_Platformer.Platformer)) {
            this.args.falling = true;
            this.args.ySpeed = -4;
            this.args.y--;
          }
        }
        break;
    }
  }
  collideA(other, type) {
    if (this.args.phase === 'exploded' || other.args.mercy) {
      return false;
    }
    if (!other.controllable && !other.hazard) {
      return true;
    }
    if (type === -1) {
      return;
    }
    const xSign = Math.sign(this.x - other.x);
    const ySign = Math.sign(this.y - other.y);
    const impactSpeed = Math.max(Math.abs(other.args.xSpeed), 5);
    const impactSign = Math.sign(other.args.xSpeed);
    if (this.args.hitPoints > 0 && other.controllable) {
      if (!(other.args.jumping || other.args.rolling || other.dashed)) {
        other.damage();
        this.args.phase = 'ready';
        if (typeof ga === 'function') {
          _Analytic.Analytic.report({
            eventCategory: 'boss',
            eventAction: 'damaged-player',
            eventLabel: `${this.viewport.args.actName}::${this.args.id}::${other.args.id}`
          });
        }
        return true;
      }
    }
    if (this.args.phase === 'dead') {
      if (!(other.args.jumping || other.args.rolling || other.dashed)) {
        return true;
      }
      this.args.explodeFrame = this.viewport.args.frameId;
      this.args.phase = 'exploding';
    }
    if (type === 1 || type === 3)
      // Side collisions
      {
        if (other.args.falling) {
          this.ignores.set(other, 15);
        } else {
          other.args.gSpeed = 4 * -Math.sign(this.x - other.x);
          if (other.args.rolling) {
            this.onNextFrame(() => {
              other.args.gSpeed = -Math.sign(this.x - other.x);
              other.args.rolling = true;
              other.args.direction = Math.sign(other.args.gSpeed);
            });
          }
        }
        this.args.ySpeed = 0;
        if (this.args.hitPoints > 0) {
          this.damage(other);
        }
        if (this.args.hitPoints > 0) {
          other.args.xSpeed = -xSign * impactSpeed;
          this.args.xSpeed = xSign * impactSpeed;
        } else {
          other.args.xSpeed = -xSign * impactSpeed * 0.5;
          this.args.xSpeed = xSign * impactSpeed * 0.5;
        }
      }
    if (type === 2)
      // Collide from bottom
      {
        if (this.viewport.args.audio) {
          _Sfx.Sfx.play('BOSS_DUDHIT');
        }
        if (other.args.falling) {
          this.args.ySpeed = other.args.ySpeed * 2.5;
          if (other.args.controllable) {
            other.args.ySpeed = Math.max(7, Math.abs(other.args.ySpeed));
          }
        }
        this.args.xSpeed = 0;
        if (this.args.hitPoints > 0) {
          this.args.phase = 'knocked';
        }
        this.ignores.set(other, 15);
      }
    if (type === 0)
      // Collide from top
      {
        if (other.args.falling) {
          this.ignores.set(other, 15);
        }
        if (other.controllable) {
          other.args.y = this.y - this.args.height;
          const animation = other.args.animation;
          const ySpeed = other.args.ySpeed;
          this.onNextFrame(() => {
            other.args.ySpeed = -Math.floor(Math.abs(ySpeed)) || -4;
          });
        }
        this.args.xSpeed = 0;
        this.damage(other);
      }
    other.args.ignore = 1;
    if (!this.args.hitPoints) {
      other.args.ignore = -2;
    } else {
      // this.viewport.controlActor.cofocused = this;
    }
    return true;
  }
  damage(other) {
    let type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'normal';
    if (this.args.hitPoints <= 0) {
      return;
    }
    const lastHit = this.args.damagers.get(other);
    if (this.args.frameId - lastHit < 5) {
      return;
    }
    this.args.hitPoints--;
    this.args.damagers.set(other, this.args.frameId);
    this.args.phase = 'damaged';
    _Sfx.Sfx.play('BOSS_DAMAGED');
  }
  pointIsSafe(x, y) {
    const hazards = this.viewport.actorsAtPoint(x, y).filter(a => a.hazard);
    if (hazards.length) {
      return false;
    }
    return true;
  }

  // get solid() { return this.args.hitPoints > 0; }
  get solid() {
    return false;
  }
  get rotateLock() {
    return true;
  }
}
exports.Beelzebub = Beelzebub;
});

;require.register("actor/Bell.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Bell = void 0;
var _Mixin = require("curvature/base/Mixin");
var _PointActor = require("./PointActor");
var _Constrainable = require("../mixin/Constrainable");
var _Ring = require("./Ring");
class Bell extends _Mixin.Mixin.from(_PointActor.PointActor, _Constrainable.Constrainable) {
  constructor() {
    super(...arguments);
    this.args.z = 100;
    this.args.width = 64;
    this.args.height = 64;
    this.args.type = 'actor-item actor-bell';

    // this.args.ropeLength = this.args._tiedTo ? this.args.ropeLength : 0;

    this.cooldown = 0;
    this.noClip = true;
    this.args.gravity = 0.40;
  }
  update() {
    this.xLast = this.x;
    this.yLast = this.y;
    super.update();
    if (this.cooldown > 0) {
      this.cooldown--;
    }
    if (this.cooldown < 1) {
      this.cooldown = 0;
    }
    const tiedTo = this.args.tiedTo;
    this.setPos();
    this.args.falling = true;
    const moved = this.x - this.xLast;
    if (Math.abs(moved) > 1) {
      this.args.animation = ['ring-left', '', 'ring-right'][1 + Math.sign(this.x - this.xLast)];
    } else {
      this.args.animation = '';
    }
    if (!this.cooldown && (Math.abs(this.args.xSpeed) > 2 || Math.abs(this.args.ySpeed) > 6)) {
      const ring = new _Ring.Ring({
        x: this.x,
        y: this.y
      });
      ring.dropped = true;
      ring.delay = 5;
      ring.args.static = false;
      ring.args.ignore = 10;
      ring.args.xSpeed = this.args.xSpeed * 0.75;
      ring.args.ySpeed = this.args.ySpeed;
      const spawnOffset = this.rotatePoint(0, 32);
      ring.args.x += spawnOffset[0];
      ring.args.y += spawnOffset[1];
      this.viewport.spawn.add({
        object: ring
      });
      this.cooldown = 45 * Math.random() + 15;
      this.viewport.onFrameOut(120, () => {
        this.viewport.actors.remove(ring);
      });
    }
  }
  updateEnd() {
    if (Math.abs(this.args.xSpeed) < 3 && Math.abs(this.args.ySpeed) < 3) {
      if (this.viewport && !this.viewport.auras.has(this)) {
        this.viewport.auras.add(this);
      }
    } else {
      this.viewport.auras.delete(this);
    }

    // if(this.args.tiedTo)
    // {
    // 	super.update();

    // 	if(this.args.tiedTo && this.args._tiedTo.args.hitPoints)
    // 	{
    // 		this.setPos();
    // 	}
    // 	else
    // 	{
    // 		this.noClip = true;
    // 	}
    // }

    super.updateEnd();
  }
  collideB(other) {
    if (!other.controllable) {
      return;
    }
    this.args.xSpeed = other.args.xSpeed;
    this.args.ySpeed = other.args.ySpeed;
    other.args.xSpeed *= 0.99;
    this.viewport.args.backdrop.args.sunrise = 1;
  }
}
exports.Bell = Bell;
});

;require.register("actor/Big.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Big = void 0;
var _PointActor = require("./PointActor");
class Big extends _PointActor.PointActor {
  constructor() {
    super(...arguments);
    this.args.type = 'actor-item actor-big';
    this.args.width = 42;
    this.args.height = 46;
  }
  get solid() {
    return false;
  }
}
exports.Big = Big;
});

;require.register("actor/Blastoid.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Blastoid = void 0;
var _Flickie = require("./Flickie");
var _Mixin = require("curvature/base/Mixin");
var _PointActor = require("./PointActor");
var _Patrol = require("../behavior/Patrol");
var _CanPop = require("../mixin/CanPop");
var _Projectile = require("../actor/Projectile");
var _Block = require("./Block");
class Blastoid extends _Mixin.Mixin.from(_PointActor.PointActor, _CanPop.CanPop) {
  constructor() {
    var _this$args$color, _this$args$patrolBeat;
    super(...arguments);

    // this.behaviors.add(new Patrol);

    this.args.type = 'actor-item actor-blastoid';
    this.args.animation = 'standing';

    // this.args.accel     = 0.75;
    // this.args.decel     = 0.5;

    // this.args.gSpeedMax = 15;
    // this.args.jumpForce = 5;
    // this.args.gravity   = 0.5;

    this.args.width = 35;
    this.args.height = 21;
    this.args.flipped = false;
    this.args.careening = false;
    this.args.color = (_this$args$color = this.args.color) !== null && _this$args$color !== void 0 ? _this$args$color : 'blue';
    this.willStick = true;
    this.stayStuck = true;
    this.args.bounceCount = 0;

    // this.args.patrolPause   = this.args.patrolPause   ?? 20;
    this.args.patrolBeat = (_this$args$patrolBeat = this.args.patrolBeat) !== null && _this$args$patrolBeat !== void 0 ? _this$args$patrolBeat : 120;
    // this.args.patrolSpeed   = this.args.patrolSpeed   ?? 4;
  }

  onRendered(event) {
    super.onRendered(event);
    this.autoAttr.get(this.box)['data-color'] = 'color';
    this.autoAttr.get(this.box)['data-flipped'] = 'flipped';
  }
  update() {
    if (this.args.flipped) {
      super.update();
      this.args.pushing = false;
      const xMoved = this.args.x - this.xLast;
      const yMoved = this.args.y - this.yLast;
      this.args.facing = this.args.gSpeed > 0 ? 'left' : 'right';
      if (this.getMapSolidAt(this.args.x + 2 + this.args.width / 2, this.args.y - 8)) {
        this.args.gSpeed = -12;
        this.args.xSpeed = -12;
        this.args.bounceCount++;
      } else if (this.getMapSolidAt(this.args.x + -2 + -this.args.width / 2, this.args.y - 8)) {
        this.args.gSpeed = 12;
        this.args.xSpeed = 12;
        this.args.bounceCount++;
      }
      if (this.args.bounceCount > 5) {
        super.pop();
      }
      return;
    }

    // const direction = this.args.direction;
    const telegraph = this.args.shotTelegraph;
    const beat = this.args.patrolBeat;
    const frameId = this.viewport.args.frameId - 30;
    if (this.viewport.actorIsOnScreen(this, 0) && frameId % beat === 0) {
      const xSpeed = +2.5;
      const ySpeed = -3;
      const owner = this;
      const ball = new _Projectile.Projectile({
        x: this.x + 13 * this.args.direction,
        y: this.y + -8,
        xSpeed: xSpeed * this.args.direction,
        ySpeed,
        owner
      });
      this.viewport.spawn.add({
        object: ball
      });
    }
    super.update();

    // this.args.direction = Math.sign(this.args.gSpeed);
  }

  effect(other) {
    super.effect(other);

    // this.viewport.spawn.add({object:new Flickie({
    // 	x: this.args.x,
    // 	y: this.args.y,
    // })});
  }

  collideA(other, type) {
    if (this.args.careening) {
      if (typeof other.pop === 'function') {
        other.pop(this);
        super.pop(other);
      }
      if (typeof other.break === 'function') {
        if (!other.broken) {
          super.pop(other);
        }
        if (!other.args.strength || other.args.strength < 2) {
          other.break(this);
        }
      }
    }
    if (other.controllable) {
      if (other.args.careening || this.args.flipped && other.args.falling && other.args.ySpeed > 4) {
        other.args.ySpeed *= -1;
        this.args.gSpeed = 12 * Math.sign(this.args.x - other.args.x);
        this.args.careening = true;
        this.args.decel = 0;
      }
    }
    return super.collideA(other, type);
  }
  pop(other) {
    // if(other instanceof Blastoid)
    // {
    // 	return super.pop(other);
    // }

    if (!this.args.flipped) {
      if (other) {
        if (other.args.rolling) {
          other.args.ySpeed *= -1;
          this.args.gSpeed = 12 * Math.sign(other.args.gSpeed);
          this.args.careening = true;
          this.args.decel = 0;
          other.args.gSpeed = 0;
        } else {
          this.args.flipped = true;
          this.args.falling = true;
          this.args.ySpeed = -9;
          this.args.y--;
          this.ignores.set(other, 10);
          other.args.ySpeed *= -1;
        }
      }
      return;
    }

    // return super.pop(other);
  }

  get solid() {
    return false;
  }
  get isEffect() {
    return false;
  }
  // get controllable() { return true; }
}
exports.Blastoid = Blastoid;
});

;require.register("actor/Block.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Block = void 0;
var _PointActor = require("./PointActor");
var _Tag = require("curvature/base/Tag");
var _Ring = require("./Ring");
var _LayerSwitch = require("./LayerSwitch");
var _GrapplePoint = require("./GrapplePoint");
var _QuintInOut = require("curvature/animate/ease/QuintInOut");
var _CubicInOut = require("curvature/animate/ease/CubicInOut");
var _Platformer = require("../behavior/Platformer");
class Block extends _PointActor.PointActor {
  static fromDef(objDef) {
    const obj = super.fromDef(objDef);
    obj.args.width = objDef.width;
    obj.args.height = objDef.height;

    // obj.args.x = obj.originalX = objDef.x + Math.floor(objDef.width / 2);
    obj.args.y = obj.originalY = objDef.y;
    return obj;
  }
  constructor() {
    var _this$args$z, _args$convey, _this$args$solid, _args$collapse, _args$drop, _args$noClip;
    let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let parent = arguments.length > 1 ? arguments[1] : undefined;
    super(args, parent);
    this.hitBlocks = false;
    this.args.yForce = 0;
    this.args.yLean = 0;
    this.args.z = (_this$args$z = this.args.z) !== null && _this$args$z !== void 0 ? _this$args$z : 100;
    this.args.type = 'actor-item actor-block';
    this.args.width = args.width || 32;
    this.args.height = args.height || 32;
    this.args.convey = (_args$convey = args.convey) !== null && _args$convey !== void 0 ? _args$convey : 0;
    this.args.conveyed = 0;
    this.args.ySpeedMax = 32;
    this.originalX = this.args.x;
    this.originalY = this.args.y;
    this.args.solid = (_this$args$solid = this.args.solid) !== null && _this$args$solid !== void 0 ? _this$args$solid : true;
    this.args.gravity = 0.4;
    this.args.collapse = (_args$collapse = args.collapse) !== null && _args$collapse !== void 0 ? _args$collapse : false;
    this.args.drop = (_args$drop = args.drop) !== null && _args$drop !== void 0 ? _args$drop : false;
    this.args.active = -1;
    this.weighted = false;
    this.noClip = (_args$noClip = args.noClip) !== null && _args$noClip !== void 0 ? _args$noClip : false;
    this.activatedAt = null;
    this.originalModes = new Map();
    this.watching = new Set();
    if (this.args.master) {
      this.childBlocks = new Set();
    }

    // this.args.bindTo('spriteSheet', v => console.trace(v));
  }

  onRendered(event) {
    super.onRendered(event);
    if (!this.viewport) {
      return;
    }
    if (this.args.match) {
      this.match = this.viewport.actorsById[this.args.match];
    }

    // if(this.screen)
    // {
    // 	return;
    // }

    // this.screen = new Tag(`<input type = "text" placeholder = "this effect is dynamic">`);
    // this.screen2 = new Tag(`<input tabindex = "0" type = "button" value = "submit">`);

    // this.sprite.appendChild(this.screen.node);
    // this.sprite.appendChild(this.screen2.node);

    // this.screen.style({'pointer-events':'initial', 'z-index': 1000});

    // if(!this.viewport)
    // {
    // 	event.preventDefault();
    // 	return false;
    // }

    this.args.spriteSheet = this.args.spriteSheet || '/Sonic/marble-zone-block.png';
    if (this.args.droop) {
      this.droop(0);
    }
    this.args.collapse && this.tags.sprite.classList.add('collapse');
    this.args.platform && this.tags.sprite.classList.add('platform');
    this.args.drop && this.tags.sprite.classList.add('drop');
    if (this.args.hidden) {
      event && event.preventDefault();
      return false;
    }
    this.setTile();
  }
  initialize() {
    if (!this.otherDefs.path && !this.otherDefs.ridePath) {
      return;
    }
    this.pathReset();
  }
  pathReset() {
    if (this.args.master) {
      const path = this.otherDefs.path || this.otherDefs.ridePath;
      if (path) {
        this.pathNext = path;
        this.args.x = path.x;
        this.args.y = path.y;
        this.viewport.setColCell(this);
        for (const child of this.childBlocks) {
          const path = child.otherDefs.path || child.otherDefs.ridePath;
          child.pathNext = path;
          child.args.x = path.x;
          child.args.y = path.y;
          this.viewport.setColCell(child);
        }
      }
    } else if (this.others.childOf) {
      this.others.childOf.pathReset();
    }
  }
  wakeUp() {
    var _this$args$noClip;
    this.sleeping = false;
    if (this.otherDefs.path) {
      if (this.others.childOf) {
        this.others.childOf.childBlocks.add(this);
      }
    }
    this.pathReset();
    this.setTile();
    this.noClip = (_this$args$noClip = this.args.noClip) !== null && _this$args$noClip !== void 0 ? _this$args$noClip : false;
    if (!this.args.tiedTo) {
      return;
    }
    if (!this.args._tiedTo) {
      this.args._tiedTo = this.viewport.actorsById[this.args.tiedTo];
    }
    const _tiedTo = this.args._tiedTo;
    if (_tiedTo && !_tiedTo.hanging.has(this.constructor)) {
      _tiedTo.hanging.set(this.constructor, new Set());
      const hangList = _tiedTo.hanging.get(this.constructor);
      hangList.add(this);
      this.chain = new _Tag.Tag('<div class = "chain">');
      this.sprite.appendChild(this.chain.node);
      this.onRemove(() => hangList.delete(this));
    }
  }
  collideA(other, type) {
    if (other instanceof _LayerSwitch.LayerSwitch) {
      return;
    }
    if (other instanceof _GrapplePoint.GrapplePoint && this.args.platform) {
      return;
    }
    if (other instanceof this.constructor && !other.args.falling && !other.hitBlocks) {
      return false;
    }
    if (other.isRegion || other.noClip || other.args.static) {
      return false;
    }
    if (other.args.standingOn === this) {
      this.weighted = true;
    }
    if (this.objDef && this.args.platform && this.objDef.type === 'hex-nut' && other.objDef && other.objDef.type === 'hex-nut') {
      return false;
    }
    let xDist = 0.5 + (other.x - this.x) / this.args.width;
    if (other.args.gSpeed < 0) {
      xDist = -xDist + 1;
    }
    if (other.args.mode) {
      xDist = -xDist + 1;
    }
    if (this.args.hSwap && other.groundTime > 2 && Math.abs(other.args.gSpeed) > 8 && xDist < 0.2) {
      this.watching.add(other);
      if (!this.originalModes.has(other)) {
        this.originalModes.set(other, {
          mode: other.args.mode,
          rolling: other.args.rolling,
          gSpeed: other.args.gSpeed
        });
      }
      if (this.originalModes.has(other)) {
        other.args.gSpeed = this.originalModes.get(other).gSpeed;
      }
    }
    if ((!other.args.falling && !other.args.climbing || other.args.climbing && other.y < this.y - this.args.height) && this.args.droop && other.args.ySpeed >= 0 && other.args.standingOn !== this) {
      return true;
    }
    if (!other.args.climbing && this.args.droop && other.controllable && (type === 0 || type === 2) && other.args.ySpeed >= 0) {
      const blockTop = this.originalY + -this.args.height;
      const half = Math.floor(this.args.width / 2);
      const speed = other.args.gSpeed;
      const absSpeed = Math.abs(speed);
      if (absSpeed > half) {
        this.args.y = this.originalY;
        other.args.y = Math.trunc(blockTop + -1);
        this.args.yForce = 0;
        this.args.yLean = 0;
        return true;
      }
      const pos = (this.x + -other.x + -(speed * 2)) / half;
      const droop = Number(this.args.droop) * 0.9;
      const absPos = Math.abs(pos);

      // this.screen.placeholder = `drooping at ${pos.toFixed(2)}`;

      if (absPos >= 0.9) {
        this.args.yForce = 0;
        this.args.yLean = this.args.yLean / 100;
        return true;
      }
      const yForceMax = Math.round(droop * (1 - Math.abs(pos)) / 2);
      this.args.yForce += Math.max(other.ySpeedLast, 0);
      this.args.yForce = Math.min(yForceMax, this.args.yForce);
      this.args.yForce = Math.max(this.args.yForce, -yForceMax);
      this.droopPos = this.x - other.x;

      // if(this.args.output)
      // {
      // 	const output = this.viewport.actorsById[ this.args.output ];

      // 	if(output)
      // 	{
      // 		output.args.content = this.screen.value;
      // 	}
      // }
    }

    // if(!other.args.bouncing && (type === 0 || type === -1) && !this.args.platform && other.controllable && other.args.ySpeed)
    // {
    // 	// other.args.y = other.yLast;
    // 	if(other.args.y < this.args.y)
    // 	{
    // 		other.args.y = this.y + -this.args.height;
    // 		other.args.falling = false;
    // 		other.args.ySpeed = this.args.ySpeed;
    // 	}

    // 	return;
    // }

    if (this.args.platform && !other.args.dead && !(other instanceof _Ring.Ring)) {
      const otherTop = other.args.y - other.args.height;
      const blockTop = this.args.y - this.args.height;
      const halfWidth = this.args.width / 2;
      if (other.args.falling && Math.abs(other.args.y - blockTop) < 4 && other.args.ySpeed >= 0 && !other.args.float && (!other.args.dashed || other.args.ySpeed > other.args.xSpeed)) {
        if (other.controllable || other.args.npc) {
          other.args.y = -1 + blockTop;
        } else {
          other.args.y = blockTop;
        }
      }
      if (other.args.y <= blockTop && (other.args.falling === false || other.args.ySpeed > 0)) {
        return true;
      }
      if (other.args.falling === false && other.args.mode === 2) {
        return true;
      }
      if (other.args.npc && !other.args.falling && this.args.falling && !this.args.float) {
        other.startle();
        other.noClip = true;
      }
      return false;
    }
    if (!other.controllable && !other.isVehicle) {
      return true;
    }
    if (!this.switch && this.args.drop && (type === 0 || type === 2) && this.args.float <= 0) {
      this.args.float = 1;
      this.args.goBack = false;
    }
    if (!this.switch && this.args.collapse && (type === 0 || type === 2) && this.args.float <= 0) {
      if (other.args.ySpeed > 15) {
        this.args.float = 1;
        this.args.goBack = false;
        const ySpeed = other.args.ySpeed;
        this.onNextFrame(() => {
          if (this.args.falling || this.args.float) {
            this.args.ySpeed = ySpeed;
            this.args.float = 1;
          } else {
            this.args.ySpeed = -1;
            this.args.float = 1;
          }
          this.args.falling = true;
        });
      } else if (other.args.ySpeed > 0 || other.args.gSpeed) {
        this.args.float = this.args.float >= 0 ? this.args.float : this.args.delay || 0;
      }
      this.viewport.onFrameOut(1, () => this.args.falling = true);
    }
    return true;
  }
  activate() {
    this.args.active = true;
  }
  deactivate() {
    this.args.active = false;
  }
  update() {
    if (this.others.childOf) {
      return;
    } else if (this.args.master) {
      for (const child of this.childBlocks) {
        child._update();
      }
    }
    return this._update();
  }
  _update() {
    var _this$args$offset;
    if (!this.viewport) {
      return;
    }
    const frameId = this.viewport.args.frameId - this.viewport.args.startFrameId + ((_this$args$offset = this.args.offset) !== null && _this$args$offset !== void 0 ? _this$args$offset : 0);
    if (this.args.active > 0) {
      if (!this.activatedAt) {
        this.activatedAt = frameId;
      }
    }
    if (this.args.switch && !this.switch) {
      this.switch = this.viewport.actorsById[this.args.switch];
    }
    if (this.args.static) {
      super.update();
      return;
    }
    if (this.args.collapse) {
      this.args.gSpeed = 0;
      if (!this.switch && this.activatedAt && frameId - this.activatedAt > 25 || this.switch && this.switch.args.active) {
        this.args.float = this.args.float >= 0 ? this.args.float : this.args.delay || 0;
        if (!this.args.float) {
          this.args.ySpeed = this.args.ySpeed || 12;
        }
      }
    }
    if (this.args.drop) {
      this.args.gSpeed = 0;
      if (!this.switch && this.activatedAt && frameId - this.activatedAt > 25 || this.switch && this.switch.args.active) {
        this.args.float = this.args.float >= 0 ? this.args.float : this.args.delay || 0;
        this.noClip = true;
        this.args.active = false;
        this.args.falling = true;
      }
    }
    if (this.match) {
      this.args.convey = -this.match.args.convey;
    }
    this.xLast = this.args.x;
    this.yLast = this.args.y;
    if (this.otherDefs.path) {
      let next = this.pathNext || this.otherDefs.path;
      if (next) {
        var _this$args$pathSpeed;
        for (const prop of next.properties) {
          if (prop.name === 'next') {
            next = this.viewport.objDefs.get(prop.value);
          }
        }
        const speed = (_this$args$pathSpeed = this.args.pathSpeed) !== null && _this$args$pathSpeed !== void 0 ? _this$args$pathSpeed : 8;
        const xDiff = this.args.x - next.x;
        const yDiff = this.args.y - next.y;
        const angle = Math.atan2(yDiff, xDiff);
        if (Math.abs(xDiff) < speed && Math.abs(yDiff) < speed) {
          this.pathNext = next;
        }
        if (Math.abs(xDiff) < speed) {
          this.args.x = next.x;
        } else {
          this.args.x -= speed * Math.cos(angle);
        }
        if (Math.abs(yDiff) < speed) {
          this.args.y = next.y;
        } else {
          this.args.y -= speed * Math.sin(angle);
        }
      }
    }
    if (this.args.float && this.args.oscillateX && this.args.oscillateY) {
      var _this$args$offset2;
      const timeFrame = frameId + ((_this$args$offset2 = this.args.offset) !== null && _this$args$offset2 !== void 0 ? _this$args$offset2 : 0) * Math.PI;
      {
        const current = Math.sin(timeFrame / this.args.timeX);
        const moveX = current * this.args.oscillateX;
        this.args.x = this.originalX - moveX;
      }
      {
        const current = Math.cos(timeFrame / this.args.timeY);
        const moveY = -(current * this.args.oscillateY);
        this.args.y = this.originalY - moveY;
      }
    } else if (this.args.float && (this.args.oscillateX || this.args.oscillateY)) {
      const current = Math.cos(Math.sin(frameId / 90) ** 5) ** (5 * 3.333);
      if (this.args.oscillateX) {
        const moveX = Math.round(current * this.args.oscillateX);
        this.args.x = this.originalX - moveX;
      }
      if (this.args.oscillateY) {
        const moveY = Math.round(current * this.args.oscillateY);
        this.args.y = this.originalY - moveY;
      }
    }
    if (!this.switch && this.args.collapse) {
      // if(!this.reset && !this.args.once)
      // {
      // 	this.reset = true;

      // 	this.viewport.onFrameOut(300, () => {
      // 		this.args.groundAngle = 0;
      // 		this.args.falling = true;
      // 		this.args.goBack = true;
      // 		this.args.float = -1;
      // 		this.reset = false;
      // 	});
      // }

      // if(!this.args.worm && this.args.goBack)
      // {
      // 	this.args.float = -1;

      // 	this.noClip = true;

      // 	const distX = this.originalX - this.args.x;
      // 	const distY = this.originalY - this.args.y;

      // 	this.args.xSpeed = 0;
      // 	this.args.ySpeed = 0;
      // 	this.args.gSpeed = 0;

      // 	if(Math.abs(distX) > 3)
      // 	{
      // 		this.args.x += Math.sign(distX) * 3;
      // 	}
      // 	else
      // 	{
      // 		this.args.x	= this.originalX;
      // 	}

      // 	if(Math.abs(distY) > 3)
      // 	{
      // 		this.args.y += Math.sign(distY) * 3;
      // 	}
      // 	else
      // 	{
      // 		this.args.y	= this.originalY;
      // 	}

      // 	if(this.args.x === this.originalX && this.args.y === this.originalY)
      // 	{
      // 		this.args.goBack = false;
      // 		this.noClip = false;
      // 	}

      // 	this.args.groundAngle = 0;
      // 	this.args.airAngle = 0;
      // }
    } else if (this.args.droop) {
      this.snapBack = this.snapBack || false;
      if (!this.args.colliding && this.args.yForce && this.viewport) {
        this.viewport.onFrameOut(4, () => {
          if (!this.viewport) {
            return;
          }
          const colliding = this.viewport.collisions.has(this);
          const collisions = colliding ? [...this.viewport.collisions.get(this).keys()] : [];
          if (!colliding || !collisions.filter(a => a.controllable).length) {
            this.snapBack = true;
          }
        });
      }
      if (!this.args.colliding && this.args.yForce && this.snapBack) {
        this.args.yForce *= 0.15;
      }
      if (Math.abs(this.args.yForce) <= 1) {
        // this.screen.placeholder = `flat.`;
        this.snapBack = false;
      }
      if (this.args.yForce !== this.args.yLean) {
        const diff = this.args.yLean - this.args.yForce;
        const step = this.args.yForce > this.args.yLean ? Math.abs(diff) * 0.666 : Math.abs(diff) * 0.333;
        this.args.yLean -= Math.sign(diff) * step;
        if (Math.abs(diff) < step) {
          this.args.yLean = this.args.yForce;
        }
      }
      if (this.args.yLean < Number.EPSILON) {
        this.args.y = this.originalY;
      } else {
        this.args.y = Math.ceil(this.originalY + this.args.yLean) || this.originalY;
        this.droop(-1 * this.args.yLean, this.droopPos || 0);
        // this.onNextFrame(() => {
        // 	this.args.y = Math.ceil(this.originalY + this.args.yLean) || this.originalY;
        // 	this.droop(-1 * this.args.yLean, this.droopPos || 0);
        // });
      }
    }

    this.box && this.box.style({
      '--convey': Math.abs(this.args.convey)
    });
    this.box && this.box.style({
      '--conveyDir': Math.sign(this.args.conveyed)
    });
    this.args.conveyed += this.args.convey;
    this.box && this.box.style({
      '--conveyed': this.args.conveyed * 0.8
    });
    this.box && this.box.setAttribute('data-design', this.args.design);
    const _tiedTo = this.args._tiedTo;
    if (_tiedTo && this.chain) {
      const point = {
        x: this.args.x,
        y: this.args.y - this.args.height
      };
      this.chain.style({
        '--distance': _tiedTo.distanceFrom(point) + this.args.height,
        '--angle': _tiedTo.angleTo(point) + Math.PI / 2
      });
    }
    super.update();
  }
  updateStart() {
    if (this.args.float && this.args.settle) {
      if (this.weighted && this.args.y < this.def.get('y') + this.args.settle) {
        this.args.y += Math.min(Math.abs(this.args.settle), 64) / 8 * Math.sign(this.args.settle);
      }
      if (!this.weighted && this.y > this.def.get('y')) {
        this.args.y -= Math.min(Math.abs(this.args.settle), 32) / 8 * Math.sign(this.args.settle);
      }
    }
    this.weighted = false;
    for (const other of this.watching) {
      const {
        mode,
        rolling,
        gSpeed
      } = this.originalModes.get(other);
      let xDist = 0.5 + (other.x - this.x) / this.args.width;
      const direction = Math.sign(gSpeed);
      if (direction < 0) {
        xDist = -xDist + 1;
      }
      if (mode) {
        xDist = -xDist + 1;
      }
      const xMoved = other.args.x - other.xLast;
      if (xDist >= 1) {
        this.originalModes.delete(other);
        this.watching.delete(other);
        other.noClip = false;
      }
      if (xDist >= 0.75) {
        other.args.xSpeed = xMoved;
        other.args.float = 0;
        other.args.falling = false;
        other.args.rolling = rolling;
        other.args.ignore = 9;
        // other.xAxis = Math.sign(other.args.gSpeed);

        if (mode === 0) {
          other.args.gSpeed = -gSpeed;
          other.args.y = this.args.y + 1;
          other.args.mode = 2;
          other.args.facing = Math.sign(gSpeed) < 0 ? 'right' : 'left';
        }
        if (mode === 2) {
          other.args.gSpeed = -gSpeed;
          other.args.y = this.args.y + -this.args.height;
          other.args.mode = 0;
          other.args.facing = Math.sign(gSpeed) < 0 ? 'right' : 'left';
        }
      } else {
        const speed = xMoved;
        other.args.gSpeed = mode ? -speed : speed;
        other.args.xSpeed = speed;
        other.args.float = -1;
        other.noClip = true;
        other.args.antiSkid = 35;
        // other.xAxis = Math.sign(other.args.gSpeed);

        other.args.direction = -Math.sign(gSpeed);
        const shiftFactor = Math.min(Math.max(xDist * 1.333, 0), 1);
        if (!rolling) {
          other.args.corkscrew = Math.min(shiftFactor * 0.5, 0.375);
          other.args.animation = 'barrel-roll';
        } else {
          other.args.rolling = true;
        }
        if (mode === 0) {
          other.args.y = this.y + -this.args.height + this.args.height * shiftFactor * 2;
        }
        if (mode === 2) {
          other.args.y = this.y + -this.args.height * shiftFactor * 2;
        }
      }
    }
  }
  updateEnd() {
    super.updateEnd();
    if (!this.viewport || !this.viewport.collisions.has(this)) {
      return;
    }
    const collidees = this.viewport.collisions.get(this);
    if (this.args.treadmill) {
      this.args.convey = 0;
      let speedCount = 0;
      let speedSum = 0;
      for (const [collidee, type] of collidees) {
        if (collidee.args.standingOn !== this) {
          continue;
        }
        if (collidee.args.gSpeed) {
          speedCount++;
          speedSum += collidee.args.gSpeed;
        }
      }
      if (speedCount) {
        this.args.convey = -speedSum / speedCount;
      }
    }
    if (this.args.convey) {
      for (const [collidee, type] of collidees) {
        if (!collidee.controllable || collidee.args.falling) {
          continue;
        }
        const conveyTo = collidee.bMap('findNextStep', this.args.convey).get(_Platformer.Platformer);
        if (conveyTo[3]) {
          continue;
        }
        if (conveyTo[2]) {
          collidee.args.xSpeed = this.args.convey;
          collidee.args.ySpeed = 0;
          collidee.args.falling = true;
          collidee.args.y = -1 + this.y - this.args.height;
        }
        collidee.args.x += conveyTo[0];
        collidee.args.y += conveyTo[1];
      }
    }
    if (!this.args.platform) {
      return;
    }
    const moveUp = Math.min(this.args.ySpeed, this.args.y - this.yLast, 0);
    if (moveUp < 0) {
      for (let x = -this.args.width * 0.5 + 4; x < this.args.width * 0.5; x += 4) {
        const xx = this.args.x + x;
        const actors = this.viewport.actorsAtLine(xx, this.args.y + -this.args.height, xx, this.args.y + -moveUp + -this.args.height);
        for (const [actor, point] of actors) {
          if (!actor.controllable || !actor.args.falling || actor.args.y < this.args.y) {
            continue;
          }
          actor.args.y = this.args.y + moveUp + -this.args.height;
          actor.args.ySpeed = this.args.ySpeed;
          actor.args.falling = false;
        }
      }
    }
  }
  sleep() {
    this.sleeping = true;

    // if(this.others.childOf)
    // {
    // 	this.others.childOf.sleep();
    // }

    if (this.args.drop && this.args.once && !this.args.float) {
      this.viewport.actors.remove(this);
    }
    if (this.args.drop && this.args.float >= 0) {
      this.args.ySpeed = 0;
      this.args.float = -1;
      this.args.active = false;
      this.args.falling = false;
      this.viewport.onFrameOut(120, () => {
        this.args.y = this.originalY;
        this.activatedAt = null;
        this.args.goBack = false;
        this.noClip = false;
        this.args.ySpeed = 0;
        this.args.float = -1;
        this.args.active = false;
        this.args.falling = false;
        this.viewport.setColCell(this);
      });
    }
  }
  get rotateLock() {
    return true;
  }
  get canStick() {
    return !this.args.platform;
  }
  get solid() {
    return this.args.solid && (!this.args.collapse || this.args.float !== 0 || !this.args.goBack);
  }
}
exports.Block = Block;
});

;require.register("actor/Block3d.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Block3d = void 0;
var _Block = require("./Block");
var _Tag = require("curvature/base/Tag");
// import { MarbleBlock } from './MarbleBlock';

// import { LavaRegion } from '../region/LavaRegion';

class Block3d extends _Block.Block {
  constructor() {
    let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    super(args);
    this.args.type = 'actor-item actor-block actor-block-3d';
    this.args.solid = true;
    if (args.stretched) {
      this.args.type += ' actor-block-3d-stretched';
    }
  }
  onRendered(event) {
    super.onRendered(event);
    const front = new _Tag.Tag('<div class = "panel-3d front-3d">');
    const back = new _Tag.Tag('<div class = "panel-3d back-3d">');
    const left = new _Tag.Tag('<div class = "panel-3d right-3d">');
    const right = new _Tag.Tag('<div class = "panel-3d left-3d">');
    const top = new _Tag.Tag('<div class = "panel-3d top-3d">');
    const bottom = new _Tag.Tag('<div class = "panel-3d bottom-3d">');
    this.box.append(back.node);
    this.box.append(left.node);
    this.box.append(right.node);
    this.box.append(front.node);
    this.box.append(top.node);
    this.box.append(bottom.node);
  }
}
exports.Block3d = Block3d;
});

;require.register("actor/BoostPole.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BoostPole = void 0;
var _PointActor = require("./PointActor");
class BoostPole extends _PointActor.PointActor {
  constructor() {
    super(...arguments);
    this.args.width = 48;
    this.args.height = 8;
    this.args.type = 'actor-item actor-boost-pole';
    this.args.float = -1;
    this.args.platform = 1;
    this.args.bend = 0;
    this.args.z = 0;
  }
  onRendered(event) {
    super.onRendered(event);
    this.autoStyle.get(this.box)['--bend'] = 'bend';
  }
  updateStart() {
    this.args.bend = 0;
  }
  collideA(other) {
    if (other.args.static || other.isRegion || this.ignores.has(other) || other.noClip) {
      return;
    }
    if (other.args.float || other.args.ySpeed <= 0) {
      return;
    }
    if (other.args.ySpeed > 2) {
      other.args.ySpeed = 1;
      other.args.y = this.args.y + -7;
    }
    const yOther = other.args.y + -this.args.y + 8;
    const xOther = other.args.x + -this.args.x + 24 * this.args.direction;
    const force = Math.min(1, Math.max(0, xOther * this.args.direction / 48));
    other.args.animation = 'rolling';
    if (Math.abs(other.args.xSpeed) > 0.5) {
      other.args.xSpeed = Math.sign(other.args.xSpeed) * 0.5;
    }
    if (force > 0.45) {
      if (yOther > 10 * force) {
        other.args.ySpeed = -15 * force;
      } else if (yOther > 8 * force) {
        other.args.xSpeed *= 0.5;
        other.args.ySpeed = 0.25;
      } else {
        other.args.ySpeed = 0.5;
      }
      this.args.bend = Math.max(0, Math.min(3, Math.floor(yOther / 2)));
    } else {
      this.args.bend = 0;
      other.args.ySpeed = 0;
      other.args.xSpeed += 0.5 * this.args.direction;
      other.args.float = 1;
    }
    return false;
  }
  get solid() {
    return false;
  }
}
exports.BoostPole = BoostPole;
});

;require.register("actor/BoostRing.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BoostRing = void 0;
var _PointActor = require("./PointActor");
var _Sfx = require("../audio/Sfx");
class BoostRing extends _PointActor.PointActor {
  constructor() {
    var _this$args$pointing, _this$args$power;
    super(...arguments);
    this.args.type = 'actor-item actor-boost-ring';
    this.args.width = 16;
    this.args.height = 16;
    this.args.float = -1;
    this.args.pointing = (_this$args$pointing = this.args.pointing) !== null && _this$args$pointing !== void 0 ? _this$args$pointing : 0;
    this.args.power = (_this$args$power = this.args.power) !== null && _this$args$power !== void 0 ? _this$args$power : 15;
    this.shooting = new Set();
  }
  onRendered(event) {
    super.onRendered(event);
    this.autoStyle.get(this.box)['--pointing'] = 'pointing';
  }
  collideA(other) {
    if (!other.controllable || this.shooting.has(other) || other.args.mercy > 120) {
      return;
    }
    other.args.falling = true;
    other.args.rolling = true;
    other.args.jumping = true;
    other.dashed = false;
    other.args.x = this.args.x;
    other.args.y = this.args.y;
    other.args.xSpeed = 0;
    other.args.ySpeed = 0;
    other.args.float = 15;
    other.args.ignore = 15;
    other.args.cameraIgnore = 30;
    other.args.groundAngle = 0;
    other.args.cameraMode = 'boost-ring';
    other.args.angle = this.args.pointing;
    other.args.flying = false;
    this.shooting.add(other);
    this.viewport.onFrameOut(7, () => other.impulse(this.args.power, this.args.pointing, true));
    this.viewport.onFrameOut(2, () => _Sfx.Sfx.play('BOOST_RING'));
    this.viewport.onFrameOut(12, () => this.shooting.delete(other));
  }
  get solid() {
    return false;
  }
}
exports.BoostRing = BoostRing;
});

;require.register("actor/Booster.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Booster = void 0;
var _PointActor = require("./PointActor");
class Booster extends _PointActor.PointActor {
  constructor() {
    var _this$args$xMax, _this$args$yMax;
    super(...arguments);
    this.args.type = 'actor-item actor-booster';
    this.args.xMax = (_this$args$xMax = this.args.xMax) !== null && _this$args$xMax !== void 0 ? _this$args$xMax : 24;
    this.args.yMax = (_this$args$yMax = this.args.yMax) !== null && _this$args$yMax !== void 0 ? _this$args$yMax : 24;
    this.args.width = 64;
    this.args.height = 345;
    this.args.float = -1;
  }
  update() {
    if (!this.viewport) {
      return;
    }
    super.update();
    if (this.args.launched && Math.abs(this.args.xSpeed) < Math.abs(this.args.xMax)) {
      this.args.xSpeed += 0.5 * Math.sign(this.args.xMax);
    }
    if (this.args.launched && Math.abs(this.args.ySpeed) < Math.abs(this.args.yMax)) {
      this.args.ySpeed -= 5 * Math.sign(this.args.yMax);
    }
    if (this.args.launched) {
      this.args.falling = true;
    }
    if (this.args.launched && this.args.xSpeed === 0 && this.args.ySpeed === 0) {
      // this.explode();
    }
  }
  activate() {
    this.args.active = true;
    this.viewport.auras.add(this);
    this.args.launched = true;
    if (this.args.xMax) {
      this.args.xSpeed += 0.5;
    }
    if (this.args.yMax) {
      this.args.ySpeed -= 0.5;
    }
  }
  explode() {
    this.viewport.onFrameOut(60, () => {
      this.args.launched = false;
      this.args.active = false;
      this.viewport.auras.delete(this);
      this.args.x = this.def.get('x');
      this.args.y = this.def.get('y');
      this.args.xSpeed = 0;
      this.args.ySpeed = 0;
      this.args.gSpeed = 0;
      this.viewport.setColCell(this);
      const exploded = new CustomEvent('exploded', {
        detail: {
          actor: this
        }
      });
      this.dispatchEvent(exploded);
    });
  }
  sleep() {
    if (this.args.launched) {
      this.explode();
    }
  }
}
exports.Booster = Booster;
});

;require.register("actor/BouncyMushroom.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BouncyMushroom = void 0;
var _Block = require("./Block");
// import { PointActor } from './PointActor';
// import { Sfx } from '../audio/Sfx';
// import { Bgm } from '../audio/Bgm';
// import { Tag } from 'curvature/base/Tag';

class BouncyMushroom extends _Block.Block {
  constructor() {
    var _this$args$stemLength;
    super(...arguments);
    this.args.width = 64;
    this.args.height = 32;
    this.args.platform = true;
    this.args.float = -1;
    this.args.type = 'actor-item actor-bouncy-mushroom';
    this.args.stemLength = (_this$args$stemLength = this.args.stemLength) !== null && _this$args$stemLength !== void 0 ? _this$args$stemLength : 64;
    this.args.pressed = 0;
  }
  onRendered() {
    super.onRendered();
    this.autoStyle.get(this.box)['--stem-length'] = 'stemLength';
  }
  update() {
    super.update();
    if (!this.def.get('stemLength')) {
      const stemLengthL = this.castRayQuick(1024, Math.PI / 2, [-16, 0], true) || 32;
      const stemLengthR = this.castRayQuick(1024, Math.PI / 2, [+16, 0], true) || 32;
      this.args.stemLength = Math.min(stemLengthL, stemLengthR);
    }
    this.args.active = this.args.pressed > 0;
    if (this.args.pressed > 0) {
      this.args.pressed--;
    }
  }
  collideA(other, type) {
    if (type === 0 && other.args.ySpeed >= 0) {
      other.args.ySpeed = other.args.flying && other.flyTime > 2 ? -2 : -8;
      super.collideA(other, type);
      this.args.pressed = 6;
      return;
    }
    return super.collideA(other, type);
  }

  // get solid() {return this.groundTime > 15};
}
exports.BouncyMushroom = BouncyMushroom;
});

;require.register("actor/BreakableBlock.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BreakableBlock = void 0;
var _Block = require("./Block");
var _Orb = require("./Orb");
var _OrbSmall = require("./OrbSmall");
var _Tag = require("curvature/base/Tag");
var _Sfx = require("../audio/Sfx");
var _Platformer = require("../behavior/Platformer");
var _ObjectPalette = require("../ObjectPalette");
let lastPlay = 0;
class BreakableBlock extends _Block.Block {
  constructor() {
    var _this$args$static;
    let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let parent = arguments.length > 1 ? arguments[1] : undefined;
    super(args, parent);

    // this.behaviors.clear();

    this.args.type = 'actor-item actor-breakable-block';
    if (this.args.collapse) {
      this.args.type = 'actor-item actor-breakable-block collapsible-block';
    }
    this.args.static = (_this$args$static = this.args.static) !== null && _this$args$static !== void 0 ? _this$args$static : true;
    this.args.strength = 0 || Number(this.args.strength);
    this.fragmentsX = document.createElement('div');
    this.fragmentsY = document.createElement('div');
    this.fragmentsX.classList.add('fragmentsX');
    this.fragmentsY.classList.add('fragmentsY');
    this.fragmentTopLeft = document.createElement('div');
    this.fragmentTopRight = document.createElement('div');
    this.fragmentBottomLeft = document.createElement('div');
    this.fragmentBottomRight = document.createElement('div');
    this.fragmentTopLeft.classList.add('fragment');
    this.fragmentTopLeft.classList.add('fragment-top-left');
    this.fragmentTopRight.classList.add('fragment');
    this.fragmentTopRight.classList.add('fragment-top-right');
    this.fragmentBottomLeft.classList.add('fragment');
    this.fragmentBottomLeft.classList.add('fragment-bottom-left');
    this.fragmentBottomRight.classList.add('fragment');
    this.fragmentBottomRight.classList.add('fragment-bottom-right');
    this.fragmentsY.append(this.fragmentTopLeft);
    this.fragmentsY.append(this.fragmentTopRight);
    this.fragmentsY.append(this.fragmentBottomLeft);
    this.fragmentsY.append(this.fragmentBottomRight);
    this.fragmentsX.append(this.fragmentsY);
    this.broken = false;
  }
  updateStart() {
    super.updateStart();
    if (this.switch) {
      if (this.switch.args.active && !this.broken) {
        this.break();
      }
    }
  }
  update() {
    const regions = this.regions;
    for (const region of regions) {
      region.updateActor(this);
    }
    if (this.args.worm && !this.broken && !this.delay2 && this.viewport && this.viewport.controlActor) {
      if (this.viewport.controlActor.args.dead && this.args.x < this.viewport.controlActor.args.x + 32) {
        this.box.classList.add('will-break');
        this.box.classList.add('breaking');
        this.box.classList.add('worm');
        this.delayedBreak(1);
        if (!this.delay2) {
          this.delay2 = this.viewport.onFrameOut(1, () => {
            this.box.classList.add('broken');
            this.delay2 = false;
          });
        }
      }
      let offset = 0;
      if (this.viewport.controlActor.args.falling) {
        offset = -32;
      }
      if (this.viewport.controlActor.args.startled) {
        offset = 16;
      }
      if (this.args.x < this.viewport.controlActor.args.x + offset) {
        this.box.classList.add('will-break');
        this.box.classList.add('breaking');
        this.box.classList.add('worm');
        this.delayedBreak(1);
        if (!this.delay2) {
          this.delay2 = this.viewport.onFrameOut(1, () => {
            this.box.classList.add('broken');
            this.delay2 = false;
          });
        }
      }
    }
    super.update();
  }
  callCollideHandler() {
    if (this.broken) {
      return false;
    }
    return super.callCollideHandler(...arguments);
  }
  collideA(other, type) {
    if (this.broken) {
      return false;
    }
    if (other instanceof _Block.Block && (other.args.float || this.args.float)) {
      return false;
    }
    if (!(other instanceof _Orb.Orb) && !other.isVehicle && !other.controllable && !other.args.rolling) {
      return !this.broken;
    }
    if (this.args.collapse) {
      if (!this.broken && other.y <= this.y - this.args.height) {
        const up = this.viewport.actorsAtPoint(this.x, this.y + -this.args.height + -1, 0, 0, {
          ghosts: true
        });
        if (Array.isArray(up)) {
          for (const actor of up) {
            if (!(actor instanceof BreakableBlock)) {
              continue;
            }
            if (!actor.args.collapse) {
              continue;
            }
            if (actor.broken) {
              continue;
            }
            return false;
          }
        }
        this.fragmentsX.style.setProperty('--xSpeed', 0);
        if (!other.args.falling) {
          if (this.args.worm) {
            // this.box.classList.add('will-break');
            // this.box.classList.add('breaking');
            // this.box.classList.add('worm');
            // if(!this.delay2)
            // {
            // 	this.delay2 = this.viewport.onFrameOut(1, () => {
            // 		this.box.classList.add('broken');
            // 		this.delay2 = false;
            // 	});
            // }

            // this.delayedBreak(5);
          } else {
            this.delayedBreak(25);
          }
        }
        return true;
      }
      if (!this.broken) {
        if (!other.args.falling && !other.args.climbing || other.args.climbing && other.y < this.y - this.args.height || other.args.ySpeed > 0 && other.y < this.y - this.args.height) {
          return true;
        }
      }
      return false;
    }
    if (this.args.strength === -2) {
      if (other.args.falling || Math.abs(other.args.gSpeed) > 4) {
        this.broken || this.break(other);
        return false;
      }
    }
    if (this.args.strength === -1) {
      return true;
    }
    if (this.args.strength === 1 && other.args.name === 'knuckles') {
      if (other.args.falling || Math.abs(other.args.gSpeed) > 4) {
        const top = this.y - this.args.height;
        if (this.args.bounceBack && other.args.falling && other.y < top) {
          other.args.ySpeed = -this.args.bounceBack;
          other.args.y = top;
        }
        this.broken || this.break(other);
        return false;
      }
    }
    if (this.args.strength === 1) {
      if (other.args.name !== 'knuckles' && !other.isVehicle) {
        return true;
      } else if (other.args.name !== 'knuckles' || other.args.falling || Math.abs(other.args.gSpeed) > 4) {
        const top = this.y - this.args.height;
        if (this.args.bounceBack && other.args.falling && other.y < top) {
          other.args.ySpeed = -this.args.bounceBack;
          other.args.y = top;
        }
        this.broken || this.break(other);
        return false;
      }
    }
    if (this.args.strength === 2) {
      if (other.isVehicle || other.args.standingOn && other.args.standingOn.isVehicle) {
        if (type === 0) {
          this.viewport.onFrameOut(1, () => this.broken || this.break(other));
          return true;
        }
        const top = this.y - this.args.height;
        if (this.args.bounceBack && other.args.falling && other.y < top) {
          other.args.ySpeed = -this.args.bounceBack;
          other.args.y = top;
        }
        this.broken || this.break(other);
        return false;
      } else {
        return true;
      }
    }
    if (!(other.args.rolling && !other.dropDashCharge && other.args.mode) && !other.isVehicle && !other.args.spinning) {
      if (other.args.falling && !(other.dashed || other.args.jumping) || !other.args.falling && type === 0) {
        return !this.broken;
      }
    }
    if (!(other instanceof _Orb.Orb) && !other.falling && !other.isVehicle && !other.args.gSpeed && !other.args.falling) {
      return !this.broken;
    }
    if (other instanceof _Orb.Orb || other.isVehicle || other.args.spinning && !other.spinDashCharge || other.args.dashed || other.punching || other.dropDashCharge && other.args.ySpeed >= 0) {
      const top = this.y - this.args.height;
      if (this.args.bounceBack && other.args.falling && other.y < top) {
        other.args.ySpeed = -this.args.bounceBack;
        other.args.y = top;
      }
      this.break(other);
      return false;
    }
    return !this.broken;
  }
  sleep() {
    if (!this.viewport) {
      return;
    }
    if (this.args.dontRestore) {
      return;
    }
    if (this.args.collapse) {
      this.args.static = true;
      this.args.falling = false;
      this.args.float = -1;
      this.noClip = false;
      this.args.ySpeed = 0;
      this.box.classList.remove('broken');
      this.box.classList.remove('breaking');
      this.box.classList.remove('will-break');
      this.fragmentsX.remove();
      this.broken = false;
    }
    if (this.args.worm) {
      this.args.x += this.args.worm;
    } else if (this.def) {
      this.args.x = this.def.get('x');
    }
    if (this.def) {
      this.args.y = this.def.get('y') + 1;
    } else {
      this.viewport.actors.remove(this);
      return;
    }
    if (this.broken) {
      this.box.classList.remove('broken');
      this.box.classList.remove('breaking');
      this.box.classList.remove('will-break');
      this.fragmentsX.remove();
    }

    // this.args.y = this.def.get('y') + 1;

    if (!this.args.latch) {
      this.args.active = 0;
    }
    this.broken = false;
    this.viewport.setColCell(this);
  }
  delayedBreak() {
    let delay = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 30;
    let other = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    let silent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    if (this.delay || other && other.args.falling) {
      return;
    }
    this.box.append(this.fragmentsX);
    this.delay = this.viewport.onFrameOut(delay, () => {
      this.break(other, silent, true);
      this.delay = false;
    });
  }
  break(other) {
    let silent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    let appended = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    const wasBroken = this.broken;
    if (!this.broken) {
      if (!appended) {
        this.box.append(this.fragmentsX);
      }
      this.broken = true;
      if (this.box) {
        const viewport = this.viewport;
        if (!this.args.worm || other && other.noClip) {
          this.box.classList.add('will-break');
          this.box.classList.add('breaking');
          if (!this.delay3) {
            this.delay3 = viewport.onFrameOut(3, () => {
              this.box.classList.add('broken');
              this.delay3 = false;
            });
          }
        }
      }
      if (!silent && Date.now() - lastPlay > 100) {
        if (this.args.worm) {
          this.viewport.onFrameOut(Math.trunc(Math.random() * 3), () => _Sfx.Sfx.play('WORM_BLOCK_DESTROYED'));
          lastPlay = Date.now();
        } else {
          this.viewport.onFrameOut(Math.trunc(Math.random() * 3), () => _Sfx.Sfx.play(this.breakSound || 'BLOCK_DESTROYED'));
        }
      }
      const o = other && other.occupant || other;
      if (o && o.controllable) {
        if (o.args.popChain.length) {
          const reward = {
            label: this.args.name,
            points: 10,
            multiplier: 1
          };
          o.args.popCombo += 1;
          o.args.popChain.push(reward);
        }
        const scoreNode = document.createElement('div');
        scoreNode.classList.add('particle-score');
        scoreNode.classList.add('score-10');
        const scoreTag = new _Tag.Tag(scoreNode);
        scoreTag.style({
          '--x': this.args.x,
          '--y': this.args.y - this.args.height
        });
        this.viewport.particles.add(scoreTag);
        setTimeout(() => this.viewport && this.viewport.particles.remove(scoreTag), 768);
        o.args.score += 10;
      }
      if (this.args.contains && _ObjectPalette.ObjectPalette[this.args.contains]) {
        const object = new _ObjectPalette.ObjectPalette[this.args.contains]();
        object.args.x = this.args.x;
        object.args.y = this.args.y - this.args.height * 0.5;
        object.args.falling = true;
        object.args.xSpeed = this.xSpeedLast || this.gSpeedLast;
        object.args.ySpeed = this.args.ySpeed;
        object.args.ySpeed = -6;
        this.viewport.spawn.add({
          object
        });
      }
    }
    if (!this.delay4) {
      this.delay4 = this.viewport.onFrameOut(20, () => {
        this.box && this.box.classList.remove('breaking');
        this.fragmentsX.remove();
        this.delay4 = false;
      });
    }
    if (!this.args.collapse && other && other.args.mode % 2 === 0) {
      const speed = other.args.xSpeed || other.args.gSpeed;
      const dir = Math.sign(speed);
      const mag = Math.abs(speed);
      const x = Math.min(512, mag) * dir;
      if (other.isVehicle) {
        this.fragmentsX.style.setProperty('--xSpeed', Math.round(x * 1.1));
      } else if (other.controllable) {
        this.fragmentsX.style.setProperty('--xSpeed', Math.round(x * 1.5));
      } else {
        this.fragmentsX.style.setProperty('--xSpeed', Math.round(x) * 2);
      }
    }
    if (!this.refresher) {
      this.refresher = true;
    }
    this.args.active = 1;
    if (this.args.collapse && !wasBroken) {
      const left = this.viewport.actorsAtPoint(this.x - this.args.width, this.y, 0, 0, {
        ghosts: true
      });
      const right = this.viewport.actorsAtPoint(this.x + this.args.width, this.y, 0, 0, {
        ghosts: true
      });
      const down = this.viewport.actorsAtPoint(this.x, this.y + 1, 0, 0, {
        ghosts: true
      });
      if (Array.isArray(left) && !Math.sign(this.args.worm)) {
        for (const actor of left) {
          if (!(actor instanceof BreakableBlock)) {
            continue;
          }
          if (!actor.args.collapse) {
            continue;
          }
          if (actor.broken) {
            continue;
          }
          actor.delayedBreak(8, null, silent);
        }
      }
      if (Array.isArray(right) && !Math.sign(this.args.worm)) {
        for (const actor of right) {
          if (!(actor instanceof BreakableBlock)) {
            continue;
          }
          if (!actor.args.collapse) {
            continue;
          }
          if (actor.broken) {
            continue;
          }
          actor.delayedBreak(8, null, silent);
        }
      }
      if (Array.isArray(down) && !Math.sign(this.args.worm)) {
        for (const actor of down) {
          if (!(actor instanceof BreakableBlock)) {
            continue;
          }
          if (!actor.args.collapse) {
            continue;
          }
          if (actor.broken) {
            continue;
          }
          actor.delayedBreak(8, null, true);
        }
      }
    } else if (!wasBroken) {
      const up = this.viewport.actorsAtPoint(this.x, this.y + -this.args.height, 0, 0, {
        ghosts: true
      });
      if (Array.isArray(up) && !Math.sign(this.args.worm)) {
        for (const actor of up) {
          if (!(actor instanceof BreakableBlock)) {
            continue;
          }
          if (!actor.args.collapse) {
            continue;
          }
          if (actor.broken) {
            continue;
          }
          actor.delayedBreak(8, null, silent);
        }
      }
    }
    if (this.viewport && this.viewport.settings.rumble && !this.broken && other && other.controller && other.controller.rumble) {
      other.controller && other.controller.rumble && other.controller.rumble({
        duration: 140,
        strongMagnitude: 1.0,
        weakMagnitude: 1.0
      });
      this.onTimeout(140, () => {
        other.controller.rumble({
          duration: 100,
          strongMagnitude: 0.0,
          weakMagnitude: 0.25
        });
      });
    }
    this.broken = true;
  }
  damage(other) {
    let type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'normal';
    this.break(other);
  }
  get solid() {
    return this.args.solid && !this.broken && this.args.strength !== -2;
  }
}
exports.BreakableBlock = BreakableBlock;
});

;require.register("actor/BrokenMonitor.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BrokenMonitor = void 0;
var _PointActor = require("./PointActor");
var _Explosion = require("../actor/Explosion");
var _Monitor = require("../actor/Monitor");
class BrokenMonitor extends _PointActor.PointActor {
  constructor() {
    super(...arguments);
    this.args.type = 'actor-item actor-monitor actor-monitor-broken';
    this.args.width = 28;
    this.args.height = 32;
  }
  collideA(other) {
    // if(other instanceof Monitor)
    // {
    // 	this.viewport && this.viewport.actors.remove(this);
    // 	return false;
    // }

    super.collideA(other);
    return true;
  }
  get canStick() {
    return false;
  }
  get solid() {
    return false;
  }
}
exports.BrokenMonitor = BrokenMonitor;
});

;require.register("actor/Bubbles.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Bubbles = void 0;
var _Mixin = require("curvature/base/Mixin");
var _Tag = require("curvature/base/Tag");
var _Flickie = require("./Flickie");
var _PointActor = require("./PointActor");
var _SkidDust = require("../behavior/SkidDust");
var _CanPop = require("../mixin/CanPop");
var _Explosion = require("../actor/Explosion");
var _Projectile = require("../actor/Projectile");
var _ElectricSheild = require("../powerups/ElectricSheild");
class Bubbles extends _Mixin.Mixin.from(_PointActor.PointActor, _CanPop.CanPop) {
  constructor() {
    super(...arguments);
    this.behaviors.add(new _SkidDust.SkidDust());
    this.args.type = 'actor-item actor-bubbles';
    this.args.animation = 'standing';
    this.args.accel = 0.1;
    this.args.decel = 0.5;
    this.args.gSpeedMax = 5;
    this.args.jumpForce = 5;
    this.args.gravity = 0.5;
    this.args.width = 32;
    this.args.height = 32;
    this.willStick = false;
    this.stayStuck = false;
    this.args.float = -1;
    this.args.static = true;
    this.aiming = false;
  }
  onRendered(event) {
    super.onRendered(event);
    this.shield = new _ElectricSheild.ElectricSheild();
    if (this.args.electric) {
      this.inventory.add(this.shield);
      this.args.currentSheild = this.shield;
    }
    this.autoAttr.get(this.box)['data-gold'] = 'gold';
    this.autoAttr.get(this.box)['data-fade'] = 'fade';
    this.chain = new _Tag.Tag('<div class = "bubbles-flame">');
    this.sprite.appendChild(this.chain.node);
  }
  update() {
    if (!this.viewport || !this.viewport.controlActor) {
      return;
    }
    if (this.args.gold && !this.args.fading) {
      if (Math.abs(this.viewport.controlActor.x - this.x) < 256 && Math.abs(this.viewport.controlActor.y - this.y) < 128) {
        this.args.fading = true;
        const viewport = this.viewport;
        viewport.onFrameOut(25, () => this.args.fade = true);
        viewport.onFrameOut(55, () => viewport.actors.remove(this));
      }
    }
    const frameId = this.viewport.args.frameId - this.viewport.args.startFrameId;
    if (this.viewport && this.args.electric && frameId % 100 === 0) {
      this.args.currentSheild = this.args.currentSheild ? null : this.shield;
    }

    // this.args.ySpeed = this.yAxis;

    if (this.box) {
      this.box.setAttribute('data-animation', 'standing');
    }
    this.args.falling = true;
    this.args.flying = true;
    super.update();
  }
  hold_1() {
    this.aiming = true;
  }
  release_1() {
    this.aiming = false;
  }
  effect(other) {
    super.effect(other);

    // this.viewport.spawn.add({object:new Flickie({
    // 	x: this.args.x,
    // 	y: this.args.y,
    // })});
  }

  get solid() {
    return false;
  }
  get isEffect() {
    return false;
  }
  // get controllable() { return true; }
}
exports.Bubbles = Bubbles;
});

;require.register("actor/Bumper.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Bumper = void 0;
var _PointActor = require("./PointActor");
var _Sfx = require("../audio/Sfx");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class Bumper extends _PointActor.PointActor {
  constructor() {
    super(...arguments);
    _defineProperty(this, "float", -1);
    this.args.type = 'actor-item actor-bumper';
    this.args.width = 16;
    this.args.height = 16;
    this.ignores = new Map();
  }
  collideA(other) {
    if (other.args.static || other.isRegion || this.ignores.has(other) || other.noClip) {
      return;
    }
    this.args.type = 'actor-item actor-bumper actor-bumper-active';
    this.viewport.onFrameOut(3, () => this.args.type = 'actor-item actor-bumper');
    if (other.args.falling) {
      _Sfx.Sfx.play('BUMPER_BOUNCE');
      const xDiff = this.x - other.x;
      const yDiff = this.y - other.y;
      const speed = Math.max(other.args.ySpeed > 0 ? 14 : 7, Math.hypot(other.args.xSpeed, other.args.ySpeed));
      const angle = Math.atan2(yDiff, xDiff);
      const otherRadius = other.args.width / 2;
      other.args.x = this.x + -Math.cos(angle) * 10;
      other.args.y = this.y + -Math.sin(angle) * 10;
      other.args.xSpeed = -speed * Math.cos(angle);
      other.args.ySpeed = -speed * Math.sin(angle);
      other.args.ignore = other.args.ignore || 4;
    } else {
      other.args.gSpeed *= -1;
      if (Math.abs(other.args.gSpeed) < 7) {
        other.args.gSpeed = 7 * Math.sign(other.args.gSpeed);
      }
    }
    this.ignores.set(other, 8);
    if (this.viewport.settings.rumble && other && other.controller && other.controller.rumble) {
      other.controller.rumble({
        duration: 120,
        strongMagnitude: 1.0,
        weakMagnitude: 1.0
      });
      this.onTimeout(120, () => {
        other.controller.rumble({
          duration: 120,
          strongMagnitude: 0.0,
          weakMagnitude: 1.0
        });
      });
    }
  }
  get canStick() {
    return false;
  }
  get rotateLock() {
    return true;
  }
  get solid() {
    return true;
  }
}
exports.Bumper = Bumper;
});

;require.register("actor/ButterDroid.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ButterDroid = void 0;
var _PointActor = require("./PointActor");
var _Mixin = require("curvature/base/Mixin");
var _CanPop = require("../mixin/CanPop");
class ButterDroid extends _Mixin.Mixin.from(_PointActor.PointActor, _CanPop.CanPop) {
  constructor(args, parent) {
    super(args, parent);
    this.args.type = 'actor-item actor-butter-droid';
    this.args.width = 24;
    this.args.height = 24;
    this.args.float = -1;
    this.args.gravity = 0;
    this.args.phase = 'idle';
  }
  update() {
    if (!this.viewport || !this.viewport.actorIsOnScreen(this)) {
      return;
    }
    const viewport = this.viewport;
    this.args.xSpeed = 0.8 * Math.sign(Math.sin(this.age / 60));
    super.update();
    const mainChar = viewport.controlActor;
    if (!mainChar) {
      this.args.phase = 'idle';
      return;
    }
    this.args.facing = this.args.xSpeed > 0 ? 'left' : 'right';
    this.args.float = -1;
  }
  get solid() {
    return false;
  }
  get rotateLock() {
    return true;
  }
}
exports.ButterDroid = ButterDroid;
});

;require.register("actor/BuzzBomber.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BuzzBomber = void 0;
var _Flickie = require("./Flickie");
var _Mixin = require("curvature/base/Mixin");
var _Tag = require("curvature/base/Tag");
var _PointActor = require("./PointActor");
var _SkidDust = require("../behavior/SkidDust");
var _CanPop = require("../mixin/CanPop");
var _Explosion = require("../actor/Explosion");
var _Projectile = require("../actor/Projectile");
class BuzzBomber extends _Mixin.Mixin.from(_PointActor.PointActor, _CanPop.CanPop) {
  constructor() {
    super(...arguments);
    this.behaviors.add(new _SkidDust.SkidDust());
    this.args.type = 'actor-item actor-buzz-bomber';
    this.args.animation = 'standing';
    this.args.accel = 0.1;
    this.args.decel = 0.5;
    this.args.gSpeedMax = 2;
    this.args.jumpForce = 5;
    this.args.gravity = 0.5;
    this.args.width = 32;
    this.args.height = 16;
    this.willStick = false;
    this.stayStuck = false;
    this.args.float = -1;
    this.aiming = false;
  }
  onRendered() {
    super.onRendered();
    this.flame = new _Tag.Tag('<div class = "buzz-bomber-flame">');
    this.wings = new _Tag.Tag('<div class = "buzz-bomber-wings">');
    this.sprite.appendChild(this.flame.node);
    this.sprite.appendChild(this.wings.node);
    if (this.aiming) {
      this.box.setAttribute('data-animation', 'aiming');
    } else {
      const direction = this.args.direction;
      if (Math.sign(this.args.gSpeed) !== direction && Math.abs(this.args.gSpeed - direction) > 5) {
        this.box.setAttribute('data-animation', 'skidding');
      } else if (this.args.moving && this.args.gSpeed) {
        this.box.setAttribute('data-animation', 'walking');
      } else {
        this.box.setAttribute('data-animation', 'standing');
      }
    }
  }
  update() {
    this.args.ySpeed = this.yAxis;
    if (!this.flame) {}
    if (this.args.xSpeed === 0 && this.viewport) {
      this.viewport.onFrameOut(10, () => {
        this.attack();
      });
    }
    this.args.falling = true;
    this.args.flying = true;
    super.update();
  }
  command_1() {
    this.aiming = !this.aiming;

    // if(this.aiming)
    // {
    // 	this.args.xSpeed = 0;
    // 	this.args.ySpeed = 0;
    // }
  }

  command_2() {
    if (!this.aiming || !this.viewport) {
      return;
    }
    const offset = [0, -24];
    const projectile = new _Projectile.Projectile({
      direction: this.args.direction,
      x: this.args.x + offset[0] + (this.args.xSpeed || this.args.gSpeed),
      y: this.args.y + offset[1],
      owner: this,
      xSpeed: this.args.xSpeed || this.args.gSpeed,
      YSpeed: this.args.YSpeed
    });
    projectile.impulse(6, 1.57 + Math.PI / 4 * 1);
    this.viewport.auras.add(projectile);
    this.viewport.spawn.add({
      object: projectile
    });
  }
  effect(other) {
    super.effect(other);

    // this.viewport.spawn.add({object:new Flickie({
    // 	x: this.args.x,
    // 	y: this.args.y,
    // })});
  }

  wakeUp() {
    if (!this.viewport) {
      return;
    }
    const viewport = this.viewport;
    this.sleeping = false;
    this.attack();
  }
  attack() {
    if (this.sleeping || this.attacking) {
      return;
    }
    if (!this.viewport) {
      return;
    }
    const viewport = this.viewport;
    this.args.direction = -1;
    this.args.facing = 'left';
    this.args.xSpeed = -10;
    this.aiming = false;
    this.attacking = true;
    viewport.onFrameOut(5, () => {
      this.aiming = true;
      viewport.onFrameOut(5, () => {
        let shots = 2;
        const cancelInterval = viewport.onFrameInterval(5, () => {
          this.command_2();
          shots-- || cancelInterval();
        });
      });
    });
    viewport.onFrameOut(50, () => {
      const xSpeed = this.args.xSpeed;
      this.args.xSpeed = 0.5 * -xSpeed;
      viewport.onFrameOut(100, () => {
        this.aiming = false;
        this.attacking = false;
        this.args.xSpeed = 0;
        this.args.ySpeed = 0;
      });
    });
  }
  sleep() {
    this.args.x = this.def.get('x');
    this.args.y = this.def.get('y');
    this.onNextFrame(() => {
      if (!this.viewport) {
        return;
      }
      this.args.x = this.def.get('x');
      this.args.y = this.def.get('y');
      this.viewport.setColCell(this);
      this.args.xSpeed = 0;
      this.args.ySpeed = 0;
      this.args.pushed = 0;
      this.args.float = 0;
      this.attacking = false;
      this.sleeping = true;
    });
  }
  get solid() {
    return false;
  }
  // get controllable() { return true; }
  get isEffect() {
    return false;
  }
}
exports.BuzzBomber = BuzzBomber;
});

;require.register("actor/Catakiller.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Catakiller = void 0;
var _PointActor = require("./PointActor");
var _Mixin = require("curvature/base/Mixin");
var _CanPop = require("../mixin/CanPop");
var _CatakillerSegment = require("./CatakillerSegment");
class Catakiller extends _Mixin.Mixin.from(_PointActor.PointActor, _CanPop.CanPop) {
  constructor(args, parent) {
    super(args, parent);
    this.args.type = 'actor-item actor-catakiller';
    this.args.width = 16;
    this.args.height = 24;
    this.args.phase = 'idle';
    this.args.scootSpeed = this.args.scootSpeed || 2;
    this.args.segments = this.args.segments || 6;
    this.args.pauseTime = this.args.pauseTime || 45;
    this.args.phaseTime = this.args.phaseTime || 600;
    this.segments = [];
  }
  update() {
    if (this.segments.length < this.args.segments) {
      const segment = new _CatakillerSegment.CatakillerSegment({
        leader: this.segments.length ? this.segments[this.segments.length - 1] : this,
        position: this.segments.length,
        following: true,
        head: this,
        x: this.args.x + 10 * (this.segments.length + 1),
        y: this.args.y,
        z: this.args.z - (this.segments.length + 1)
      });
      this.segments.push(segment);
      this.viewport.spawn.add({
        object: segment
      });
    }
    if (!this.viewport || !this.viewport.actorIsOnScreen(this)) {
      super.update();
      return;
    }
    const viewport = this.viewport;
    const interval = this.args.phaseTime;
    const half = interval * 0.5;
    const scootInterval = 30;
    const scoot = this.age % scootInterval;
    const direction = this.age % interval < half ? 1 : -1;
    const phase = this.age % half;
    const moveTime = half - this.args.pauseTime;
    if (phase < moveTime) {
      if (scoot > scootInterval * 0.5) {
        this.args.gSpeed = this.args.scootSpeed * direction;
        this.args.animation = 'mouth-open';
        if (Math.round(this.args.gSpeed) !== 0) {
          this.args.facing = this.args.gSpeed > 0 ? 'left' : 'right';
        }
      } else {
        this.args.animation = 'mouth-closed';
        this.args.gSpeed = 0;
      }
    } else {
      this.args.animation = 'mouth-closed';
      this.args.gSpeed = 0;
    }
    super.update();
  }
  pop() {
    if (this.segments) {
      this.segments.forEach(s => {
        s.args.popped = true;
        s.args.falling = true;
        s.args.xSpeed = 2 * -Math.sign(this.gSpeedLast) * (s.args.position - this.segments.length / 2);
        s.args.ySpeed = -14;
        if (!s.viewport) {
          return;
        }
        s.viewport.onFrameOut(160, () => s.noClip = true);
      });
    }
    super.pop(...arguments);
  }
  get solid() {
    return false;
  }
  get rotateLock() {
    return true;
  }
}
exports.Catakiller = Catakiller;
});

;require.register("actor/CatakillerSegment.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CatakillerSegment = void 0;
var _PointActor = require("./PointActor");
var _Mixin = require("curvature/base/Mixin");
var _CanPop = require("../mixin/CanPop");
class CatakillerSegment extends _Mixin.Mixin.from(_PointActor.PointActor) {
  constructor(args, parent) {
    super(args, parent);
    this.args.type = 'actor-item actor-catakiller-segment';
    this.args.width = 16;
    this.args.height = 16;
    this.args.following = this.args.following || false;
    this.args.willMove = true;
    this.args.popped = false;
    this.args.bounces = 1;
  }
  collideA(other, type) {
    // if(!other.controllable || (this.args.popped && this.args.ySpeed < 0))
    if (!other.controllable || this.args.popped) {
      return;
    }
    if (this.args.position === 0 && this.args.head) {
      this.args.head.collideA(other, type);
    } else {
      other.damage(this);
    }
  }
  onRendered() {
    super.onRendered();
    if (this.box && this.args.position % 2 === 0) {
      this.autoStyle.get(this.box)['--space'] = 'space';
    }
  }
  update() {
    if (this.args.leader && this.args.head && !this.args.popped) {
      const leaderX = this.args.leader.args.x;
      const space = Math.abs(this.args.x - leaderX);
      let speed = Math.abs(this.args.head.gSpeedLast || 0);
      this.args.space = space;
      if (space < 9.5) {
        this.args.willMove = false;
      } else if (space > 13) {
        this.args.willMove = true;
        // speed *= 1.5;
      }

      if (this.args.willMove) {
        this.args.gSpeed = speed * -Math.sign(this.args.x - leaderX);
      } else {
        this.args.gSpeed = 0;
      }
      if (this.args.gSpeed !== 0) {
        this.args.facing = this.args.gSpeed > 0 ? 'left' : 'right';
      }
      this.args.groundAngle = 0;
    }
    const yLast = this.args.y;
    super.update();
    if (this.args.popped && this.args.y === yLast) {
      if (this.args.bounces > 0) {
        this.args.ySpeed = -Math.max(this.ySpeedLast || 5);
        this.args.xSpeed = (this.gSpeedLast || this.xSpeedLast || 0) + Math.sign(this.xSpeedLast || 0);
        this.args.falling = true;
        this.args.bounces--;
      } else {
        this.noClip = true;
        this.args.ySpeed = Math.max(this.ySpeedLast || 5);
        this.args.falling = true;
      }
    }
  }
  get solid() {
    return false;
  }
  get rotateLock() {
    return true;
  }
}
exports.CatakillerSegment = CatakillerSegment;
});

;require.register("actor/CautionPanel.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CautionPanel = void 0;
var _PointActor = require("./PointActor");
class CautionPanel extends _PointActor.PointActor {
  constructor() {
    super(...arguments);
    this.args.width = 80;
    this.args.height = 48;
    this.args.type = 'actor-item actor-caution-panel';
    this.args.z = 0;
  }
  get solid() {
    return false;
  }
}
exports.CautionPanel = CautionPanel;
});

;require.register("actor/CautionSign.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CautionSign = void 0;
var _PointActor = require("./PointActor");
class CautionSign extends _PointActor.PointActor {
  constructor() {
    super(...arguments);
    this.args.width = 20;
    this.args.height = 60;
    this.args.type = 'actor-item actor-caution-sign';
  }
  get solid() {
    return false;
  }
}
exports.CautionSign = CautionSign;
});

;require.register("actor/ChainPull.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ChainPull = void 0;
var _PointActor = require("./PointActor");
class ChainPull extends _PointActor.PointActor {
  constructor() {
    super(...arguments);
    this.args.type = 'actor-item actor-chain-pull';
    this.args.width = 31;
    this.args.height = 12;
    this.args.float = -1;
    this.args.maxDrop = this.args.maxDrop || 280;
    this.args.pullTo = this.args.pullTo || 96;
  }
  update() {
    for (const [type, hangers] of this.hanging) {
      for (const hanger of hangers) {
        this.viewport.auras.add(hanger);
        if (hanger.args.falling) {
          if (this.others.switch && this.others.switch.args.active) {
            if (Math.abs(hanger.args.ropeLength - this.args.pullTo) >= 2) {
              if (hanger.args.ropeLength < this.args.pullTo) {
                hanger.args.y -= 2 * Math.sign(hanger.args.ropeLength - this.args.pullTo);
              }
              hanger.args.ropeLength -= 2 * Math.sign(hanger.args.ropeLength - this.args.pullTo);
            }
          } else if (hanger.args.ropeLength < this.args.maxDrop) {
            hanger.args.ropeLength = this.castRayQuick(this.args.maxDrop, Math.PI / 2, [0, 0], false) || this.args.maxDrop;
          } else {
            hanger.args.ropeLength -= 2 * Math.sign(hanger.args.ropeLength - this.args.maxDrop);
          }
        }
      }
    }
  }
  wakeUp() {
    for (const [type, hangers] of this.hanging) {
      for (const hanger of hangers) {
        this.viewport.auras.add(hanger);
      }
    }
  }
  sleep() {
    for (const [type, hangers] of this.hanging) {
      for (const hanger of hangers) {
        this.viewport.auras.delete(hanger);
      }
    }
  }
}
exports.ChainPull = ChainPull;
});

;require.register("actor/ChainShot.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ChainShot = void 0;
var _PointActor = require("./PointActor");
var _Sfx = require("../audio/Sfx");
var _Tag = require("curvature/base/Tag");
class ChainShot extends _PointActor.PointActor {
  constructor() {
    super(...arguments);
    this.args.width = 16;
    this.args.height = 128;
    this.args.type = 'actor-item actor-chain-shot';
    this.args.float = -1;
    this.args.shooting = false;
    this.args.animation = 'idle';
  }
  update() {
    super.update();
    if (this.args.animation === 'shooting' && this.viewport.args.frameId % 5 === 0) {
      _Sfx.Sfx.play('CHOPPER_GUN', {});
    }
  }
  collideA(other) {
    if (!this.args.shooting || !other.controllable) {
      return;
    }
    other.damage(this);
  }
}
exports.ChainShot = ChainShot;
});

;require.register("actor/Chalmers.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Chalmers = void 0;
var _PointActor = require("./PointActor");
var _Tag = require("curvature/base/Tag");
var _SkidDust = require("../behavior/SkidDust");
class Chalmers extends _PointActor.PointActor {
  constructor() {
    super(...arguments);
    this.behaviors.add(new _SkidDust.SkidDust());
    this.args.type = 'actor-item actor-chalmers';
    this.args.normalHeight = 45;
    this.args.rollingHeight = 23;
    this.args.accel = 0.25;
    this.args.decel = 0.4;
    this.args.gSpeedMax = 18;
    this.args.jumpForce = 11;
    this.args.gravity = 0.5;
    this.args.width = 18;
    this.args.height = 32;
  }
  onRendered(event) {
    super.onRendered(event);
    this.box = this.findTag('div');
  }
  update() {
    const falling = this.args.falling;
    if (!this.box) {
      super.update();
      return;
    }
    if (!falling) {
      if (this.yAxis > 0) {
        this.args.crouching = true;
      } else {
        this.args.crouching = false;
      }
      const direction = this.args.direction;
      const gSpeed = this.args.gSpeed;
      const speed = Math.abs(gSpeed);
      const maxSpeed = this.args.gSpeedMax;
      if (this.args.rolling) {
        this.box.setAttribute('data-animation', 'rolling');
      } else if (Math.sign(this.args.gSpeed) !== direction && Math.abs(this.args.gSpeed - direction) > 5) {
        this.box.setAttribute('data-animation', 'standing');
      } else if (speed > maxSpeed * 0.25) {
        this.box.setAttribute('data-animation', 'running');
      } else if (this.args.moving && gSpeed) {
        this.box.setAttribute('data-animation', 'walking');
      }
      // else if(this.args.crouching || (this.args.standingOn && this.args.standingOn.isVehicle))
      // {
      // 	this.box.setAttribute('data-animation', 'crouching');
      // }
      else {
        this.box.setAttribute('data-animation', 'standing');
      }
    } else if (this.args.standingOn && this.args.standingOn.isVehicle) {
      this.box.setAttribute('data-animation', 'standing');
    } else if (this.args.jumping) {
      this.box.setAttribute('data-animation', 'jumping');
    }
    super.update();
  }
  get solid() {
    return false;
  }
  get canRoll() {
    return true;
  }
  get isEffect() {
    return false;
  }
  get controllable() {
    return true;
  }
}
exports.Chalmers = Chalmers;
});

;require.register("actor/Chao.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Chao = void 0;
var _Png = require("../sprite/Png");
var _PointActor = require("./PointActor");
var _Mushroom = require("./Mushroom");
var _Coconut = require("./Coconut");
var _Tree = require("./Tree");
var _Uuid = require("curvature/base/Uuid");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class Chao extends _PointActor.PointActor {
  constructor() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    super(...args);
    _defineProperty(this, "png", new _Png.Png('/DBurraki/chao-normal.png'));
    this.args.type = 'actor-item actor-chao';
    this.args.particleScale = 0.75;
    this.args.spriteSheet = this.spriteSheet = '/DBurraki/chao-normal.png';
    this.args.width = 14;
    this.args.height = 18;
    this.args.uuid = args.uuid || String(new _Uuid.Uuid());
    this.xHold = 8;
    this.yHold = 0;
    this.maxFlight = 270;
    this.emotes = ['normal', 'alert', 'inquire', 'like', 'love', 'angry'];
    this.emoteIndex = 0;

    // this.animations = ['standing', 'thinking', 'walking', 'flying', 'sitting', 'searching', 'swimming', 'flying'];
    // this.animationIndex = 0;

    this.args.animation = 'standing';
    this.args.inWater = false;
    this.bindTo('carriedBy', carrier => {
      if (this.cX) {
        this.cX();
        this.cX = null;
      }
      if (this.cY) {
        this.cY();
        this.cY = null;
      }
      if (carrier) {
        this.cX = carrier.args.bindTo('x', v => this.args.x = v + carrier.args.direction * 8);
        this.cY = carrier.args.bindTo('y', v => this.args.y = v + -16);
        carrier.carrying.add(this);
        this.args.float = -1;
        this.args.groundAngle = 0;
      } else if (this.carriedBy) {
        const carrier = this.carriedBy;
        this.carriedBy = null;
        this.args.xSpeed = carrier.args.xSpeed;
        this.args.ySpeed = carrier.args.ySpeed;
        this.args.xSpeed += Math.sign(carrier.args.gSpeed || carrier.args.xSpeed) * 4;
        this.args.ySpeed -= 4;
        carrier.carrying.delete(this);
        this.args.falling = true;
        this.args.float = 0;
      }
    });
    this.args.direction = 1;
    this.args.currentState = this.args.currentState || 'sitting';
    this.args.bindTo('currentState', () => {
      this.args.stateTime = 0;
    });
    this.args.alignment = 'neutral';
    this.stats = {
      intelligence: 0,
      stamina: 0,
      luck: 0,
      run: 0,
      swim: 0,
      fly: 0,
      power: 0
    };
    this.traits = {
      appetite: 0,
      sociable: 0,
      restless: 0
    };
    this.mood = {
      attitude: 0,
      happy: 1,
      hunger: 0,
      health: 1,
      social: 0
    };
    this.defaultColors = ['addef8', '2ebee9', '0e6d89', 'ecde2f', 'dcb936', '985000', 'f8b0c0', 'f85080', 'e4e0e4', 'e0e0e0', 'f8f820', '606080'];
    this.customColors = [null, null, null, null, null, null, null, null, null, null, null, null];
    this.customColors.bindTo(() => {
      const colorMap = {};
      for (const i in this.defaultColors) {
        var _this$customColors$i;
        colorMap[this.defaultColors[i]] = (_this$customColors$i = this.customColors[i]) !== null && _this$customColors$i !== void 0 ? _this$customColors$i : this.defaultColors[i];
      }
      this.png.ready.then(() => {
        const customSheet = this.png.recolor(colorMap).toUrl();
        this.args.spriteSheet = customSheet;
      });
    }, {
      wait: 0
    });
    this.chaoAge = 0;
  }
  onAttached(event) {
    // super.onRendered(event);

    if (!this.listening) {
      this.box.addEventListener('click', event => this.onClick(event));
      this.box.addEventListener('contextmenu', event => this.onRightClick(event));
      this.listening = true;
    }
    this.setAutoAttr('currentState', 'data-current-state');
    this.setAutoAttr('alignment', 'data-alignment');
    this.setAutoAttr('direction', 'data-direction');
    this.setAutoAttr('emote', 'data-emote');
    const viewport = this.viewport;
    this.onRemove(() => clearInterval(viewport.onInterval(1500, () => {
      if (this.emoteIndex >= this.emotes.length) {
        this.emoteIndex = 0;
      }
      this.args.emote = this.emotes[this.emoteIndex];
      this.emoteIndex++;
      this.onRemove(() => viewport.onTimeout(500, () => {
        this.args.emote = 'normal';
      }));
    })));

    // this.viewport.onInterval(3000, () => {
    // 	if(this.animationIndex >= this.animations.length)
    // 	{
    // 		this.animationIndex = 0;
    // 	}

    // 	this.args.animation = this.animations[this.animationIndex];

    // 	console.log(this.animations[this.animationIndex]);

    // 	this.animationIndex++;
    // });

    const heroColors = {
      'addef8': 'e4e0e4',
      '2ebee9': 'c0bde4',
      '0e6d89': '9c99c0',
      'ecde2f': 'addef8',
      'dcb936': '2ebee9',
      '985000': '0e6d89',
      'ffa3b1': 'ffa3b1',
      'fa6379': 'fa6379',
      'e4e0e4': 'cdeef8',
      'f8f820': '9c99c0'

      // '606080': '606080',
    };

    const darkColors = {
      'addef8': '485070',
      '2ebee9': '303058',
      '0e6d89': '202020',
      'ecde2f': 'b70000',
      'dcb936': '770000',
      '985000': '420000',
      'ffa3b1': 'ffa3b1',
      'fa6379': 'fa6379',
      'e4e0e4': 'e4e0e4',
      'f8f820': 'bf999c',
      '606080': '202020'
    };
    const rubyColors = {
      'addef8': 'ff7575',
      '2ebee9': 'e00000',
      '0e6d89': '800000',
      'ecde2f': 'b70000',
      'dcb936': '770000',
      '985000': '420000',
      'ffa3b1': 'ffa3b1',
      'fa6379': 'fa6379',
      'e4e0e4': 'e4e0e4',
      '606080': '202020'
    };
    const tangyColors = {
      'addef8': 'e08000',
      '2ebee9': 'b76900',
      '0e6d89': '7d4800',
      'ecde2f': 'b44800',
      'dcb936': '844221',
      '985000': '630000',
      'ffa3b1': 'ffa3b1',
      'fa6379': 'fa6379',
      'e4e0e4': 'e4e0e4',
      '606080': '202020'
    };
    const limeColors = {
      'addef8': '80e000',
      '2ebee9': '69b700',
      '0e6d89': '487d00',
      'ecde2f': '48b400',
      'dcb936': '428421',
      '985000': '006300',
      'ffa3b1': 'ffa3b1',
      'fa6379': 'fa6379',
      'e4e0e4': 'e4e0e4',
      '606080': '202020'
    };
    const coalColors = {
      'addef8': '485070',
      '2ebee9': '303058',
      '0e6d89': '202020',
      'ecde2f': 'c0bde4',
      'dcb936': '9c99c0',
      '985000': '606080',
      'ffa3b1': 'ffa3b1',
      'fa6379': 'fa6379',
      'e4e0e4': 'e4e0e4',
      'f8f820': '9c99c0',
      '606080': '202020'
    };
    const mimeColors = {
      'addef8': 'c0bde4',
      '2ebee9': '9c99c0',
      '0e6d89': '606080',
      'ecde2f': '485070',
      'dcb936': '303058',
      '985000': '202020',
      'ffa3b1': 'ffa3b1',
      'fa6379': 'fa6379',
      'e4e0e4': 'e4e0e4',
      'f8f820': '9c99c0',
      '606080': '202020'
    };
    const whiteColors = {
      'addef8': 'c0bde4',
      '2ebee9': '9c99c0',
      '0e6d89': '606080',
      'ecde2f': 'e4e0e4',
      'dcb936': 'c0bde4',
      '985000': '9c99c0',
      'ffa3b1': 'ffa3b1',
      'fa6379': 'fa6379',
      'e4e0e4': 'e4e0e4',
      'f8f820': '9c99c0',
      '606080': '202020'
    };
    const limeRubyColors = {
      'addef8': '80e000',
      '2ebee9': '69b700',
      '0e6d89': '487d00',
      'ecde2f': 'b70000',
      'dcb936': '770000',
      '985000': '420000',
      'ffa3b1': 'ffa3b1',
      'fa6379': 'fa6379',
      'e4e0e4': 'e4e0e4',
      '606080': '202020'
    };
    this.png.ready.then(() => {
      this.heroSheet = this.png.recolor(heroColors).toUrl();
      this.darkSheet = this.png.recolor(darkColors).toUrl();
      this.rubySheet = this.png.recolor(rubyColors).toUrl();
      this.tangySheet = this.png.recolor(tangyColors).toUrl();
      this.limeSheet = this.png.recolor(limeColors).toUrl();
      this.coalSheet = this.png.recolor(coalColors).toUrl();
      this.mimeSheet = this.png.recolor(mimeColors).toUrl();
      this.whiteSheet = this.png.recolor(whiteColors).toUrl();
      this.limeRubySheet = this.png.recolor(limeRubyColors).toUrl();
    });
  }
  generate() {
    Object.assign(this.stats, {
      intelligence: 0,
      stamina: 0,
      luck: 0,
      run: 0,
      swim: 0,
      fly: 0,
      power: 0
    });
    Object.assign(this.traits, {
      appetite: 0,
      sociable: 0,
      restless: 0
    });
    Object.assign(this.mood, {
      attitude: 0,
      happy: 1,
      hunger: 0,
      health: 1,
      social: 0
    });
  }
  lift(actor) {
    if (this.carriedBy === actor) {
      this.carriedBy = null;
      this.args.currentState = 'standing';
      return;
    }
    this.carriedBy = actor;
    this.args.currentState = 'held';
  }
  get solid() {
    return false;
  }
  update() {
    if (viewport.meta.fieldType === 'garden' && this.chaoAge % 120 === 0) {
      const zoneState = viewport.getZoneState();
      const stored = zoneState.chao.find(c => c.uuid === this.args.uuid);
      if (!stored) {
        zoneState.chao.push(this.store());
      } else {
        Object.assign(stored, this.store());
      }
      viewport.currentSave.save();
    }
    for (const carried of this.carrying) {
      carried.args.x = this.args.x + this.args.direction * this.xHold;
      carried.args.y = this.args.y + this.yHold;
    }
    this.args.inWater = false;
    const floatRegions = [...this.regions].filter(r => r.args.density >= 1);
    if (floatRegions.length) {
      if (this.args.ySpeed >= 0) {
        const floatTarget = floatRegions[0].args.y - floatRegions[0].args.height + 6;
        const snapSpace = 3;
        if (this.args.currentState !== 'walking' && this.args.currentState !== 'flying') {
          this.args.xSpeed = this.args.xSpeed * 0.95;
        }
        if (this.args.y > floatTarget) {
          this.args.falling = true;
          this.args.ySpeed += -2;
          this.args.float = -1;
          if (this.args.ySpeed > snapSpace) {
            this.args.ySpeed = snapSpace;
          }
          if (this.args.ySpeed < -snapSpace) {
            this.args.ySpeed = -snapSpace;
          }
        } else if (!this.args.currentState !== 'flying') {
          if (this.args.ySpeed > 0 && Math.abs(this.args.y - floatTarget) < snapSpace) {
            this.args.y = floatTarget;
          }
          this.args.ySpeed = 0;
          this.args.float = 1;
        }
        this.args.groundAngle = 0;
      }
      this.args.inWater = true;
    } else {
      if (this.args.currentState !== 'flying') {
        this.args.float = 0;
      }
    }
    if (this.mood.hunger < 1) {
      if (this.traits.appetite < 0.333) {
        this.mood.hunger += 0.00002;
      } else if (this.traits.appetite < 0.666) {
        this.mood.hunger += 0.00004;
      } else {
        this.mood.hunger += 0.00006;
      }
    }
    if (this.mood.social < 1) {
      if (this.traits.sociable < 0.333) {
        this.mood.social += 0.0002;
      } else if (this.traits.sociable < 0.666) {
        this.mood.social += 0.0004;
      } else {
        this.mood.social += 0.0006;
      }
    }
    if (!['eating', 'holding'].includes(this.args.currentState)) {
      if (this.carrying.size) {
        this.args.currentState = 'holding';
      }
    }
    const state = String(this.args.currentState).charAt(0).toUpperCase() + String(this.args.currentState).slice(1);
    if (typeof this['state' + state] === 'function') {
      this['state' + state]();
    }
    if (this.mood.hunger < 0.3) {
      this.selectedFood = null;
      this.selectedTree = null;
    }
    if (this.selectedFood && this.selectedFood.carriedBy) {
      this.selectedThing = null;
      this.selectedFood = null;
    }
    if (this.selectedTree && this.selectedTree.args.shaking && this.args.currentState !== 'shakingTree') {
      this.selectedThing = null;
      this.selectedTree = null;
    }
    if (!this.selectedTree || !this.selectedTree.args.shaking) {
      this.args.z = 2;
    }
    super.update();
    this.args.stateTime++;
    this.chaoAge++;
  }
  collideA(other, type) {
    super.collideA(other, type);
    if (this.selectedFriend === other && !this.carriedBy && this.args.currentState !== 'flying') {
      this.args.currentState = 'fun';
    }
    if (other.carriedBy || this.carrying.size) {
      return;
    }
    if (other instanceof _Coconut.Coconut || other instanceof _Mushroom.Mushroom) {
      if (other.args.size && other.args.falling === this.args.falling) {
        other.lift(this);
      }
    }
    if (this.selectedFood === other) {
      this.selectedThing = null;
      this.selectedFood = null;
    }
    if (this.selectedTree === other && Math.abs(this.args.x - other.args.x) < 8 && this.args.y <= other.args.y + 3) {
      this.args.currentState = 'shakingTree';
    }
  }
  stateStanding() {
    this.args.animation = 'standing';
    if (!this.args.falling) {
      this.args.xSpeed = 0;
      this.args.ySpeed = 0;
    }
    if (this.args.stateTime > 120) {
      this.args.currentState = 'thinking';
    }
  }
  stateThinking() {
    if (!this.args.falling) {
      this.args.xSpeed = 0;
      this.args.ySpeed = 0;
    }
    this.args.animation = 'thinking';
    if (this.args.stateTime > 60) {
      this.args.currentState = 'searching';
    } else if (this.args.stateTime == 0) {
      this.args.emote = 'inquire';
    }
  }
  stateSearching() {
    this.args.animation = 'searching';
    this.args.emote = 'inquire';
    if (this.args.stateTime > 90) {
      this.args.emote = 'alert';
    } else {
      this.args.emote = 'inquire';
    }
    if (this.args.stateTime > 120) {
      this.args.direction = Math.sign(Math.random() - 0.5);
      if (this.getMapSolidAt(this.args.x + this.args.direction * 8, this.args.y)) {
        this.args.direction *= -1;
      }
      if (this.mood.hunger > 0.5) {
        this.args.currentState = 'seekingFood';
      } else if (this.mood.social > 0.75) {
        this.args.currentState = 'seekingFriend';
      } else if (Math.random() > 0.15 * this.traits.restless) {
        if (this.args.groundAngle || this.args.inWater) {
          this.args.currentState = 'walking';
        } else {
          this.args.currentState = 'sitting';
        }
      } else {
        this.args.currentState = 'walking';
      }
    }
  }
  stateWalking() {
    if (this.args.inWater) {
      this.args.animation = 'flying';
    } else {
      this.args.animation = 'walking';
    }
    if (this.args.stateTime < 15) {
      this.args.emote = 'alert';
    } else if (this.args.stateTime === 16) {
      this.args.emote = 'normal';
    }
    if (this.args.inWater) {
      this.args.xSpeed = 1 * this.args.direction;
    } else {
      this.args.gSpeed = 0.01 * this.args.direction;
    }
    if (this.args.stateTime > 40) {
      if (!this.args.inWater && Math.random() > 0.9) {
        this.args.currentState = 'tripping';
      }
      if (!this.selectedThing && Math.random() > 0.95) {
        this.args.currentState = 'flying';
      } else if (this.selectedThing && this.selectedThing.args.y < this.args.y) {
        this.args.currentState = 'flying';
      } else if (!this.selectedThing && Math.random() > 0.98) {
        this.args.currentState = 'searching';
      }
    }
  }
  stateTripping() {
    this.args.animation = 'tripping';
    if (this.args.stateTime > 10) {
      this.args.gSpeed = 0;
    } else {
      this.args.gSpeed = 1 * this.args.direction;
    }
    if (this.args.stateTime > 20) {
      if (this.args.stateTime < 30 && Math.random() > 0.6) {
        this.args.emote = 'angry';
      }
    } else {
      this.args.emote = 'alert';
    }
    if (this.args.stateTime > 120) {
      this.args.currentState = 'sitting';
    }
  }
  stateFlying() {
    this.args.animation = 'flying';

    // if(this.args.inWater)
    // {
    // 	// this.args.ySpeed--;
    // }

    if (this.args.stateTime === 1) {
      this.flightTime = this.maxFlight / 2 + Math.round(this.maxFlight / 2 * Math.random());
    }
    if (this.args.xSpeed && this.getMapSolidAt(this.args.x + Math.sign(this.args.xSpeed) * 8, this.args.y)) {
      this.args.direction *= -1;
      this.args.xSpeed *= -1;
    }
    if (this.getMapSolidAt(this.args.x, this.args.y + 2)) {
      this.args.falling = true;
      this.args.float = -1;
    }
    if (!this.selectedThing && this.args.stateTime > 120 && this.args.ySpeed < 0) {
      this.args.ySpeed *= 0.4;
    } else if (this.selectedThing && this.args.y < this.selectedThing.args.y - 96) {
      this.args.ySpeed *= 0.4;
    }
    if (this.selectedThing && this.selectedThing.args.y - 32 < this.args.y) {
      if (this.selectedThing && Math.abs(this.selectedThing.args.x - this.args.x) > 32) {
        this.args.direction = Math.sign(this.selectedThing.args.x - this.args.x);
      }
      this.args.xSpeed = 1.25 * this.args.direction;
      if (this.args.ySpeed > -1.5) {
        this.args.ySpeed -= 0.1;
      }
    } else if (this.selectedThing && Math.abs(this.selectedThing.args.x - this.args.x) < 32) {
      this.args.direction = Math.sign(this.selectedThing.args.x - this.args.x);
      this.args.currentState = 'walking';
    }
    if (this.args.stateTime < this.flightTime) {
      this.args.groundAngle = 0;
      if (!this.args.ySpeed || !this.args.falling) {
        if (!this.args.xSpeed && !this.args.gSpeed && !this.selectedThing) {
          this.args.direction = Math.sign(Math.random() - 0.5);
        }
        this.args.falling = true;
        this.args.ySpeed = -1;
        this.args.xSpeed = 1.25 * this.args.direction;
        this.args.float = -1;
      } else if (this.args.ySpeed >= 0) {
        this.args.currentState = 'flying';
      }
    } else if (!this.selectedThing) {
      this.args.currentState = 'thinking';
    }
  }
  stateHatching() {
    this.stateSitting();
  }
  stateSitting() {
    this.args.xSpeed = 0;
    if (this.args.inWater) {
      this.args.animation = 'standing';
    } else {
      this.args.animation = 'sitting';
    }
    if (this.args.stateTime > 120) {
      if (this.mood.hunger > 0.5) {
        this.args.currentState = 'seekingFood';
      } else if (this.mood.social > 0.75) {
        this.args.currentState = 'seekingFriend';
      } else if (Math.random() > 0.35 * this.traits.restless) {
        this.args.currentState = 'walking';
      } else {
        this.args.currentState = 'thinking';
      }
    }
  }
  stateWaiting() {
    this.args.xSpeed = 0;
    if (Math.trunc(this.args.stateTime / 15) % 2) {
      if (Math.random() < 0.2) {
        this.args.emote = 'inquire';
      } else {
        this.args.emote = 'normal';
      }
    }
    if (this.args.inWater) {
      this.args.animation = 'standing';
    } else {
      this.args.animation = 'sitting';
    }
  }
  stateSwimming() {}
  stateFlyingLooking() {}
  stateHolding() {
    if (this.args.stateTime < 60) {
      this.args.animation = 'thinking';
      this.args.emote = 'inquire';
      return;
    }
    for (const carrying of this.carrying) {
      carrying.args.gSpeed = 0;
      carrying.args.xSpeed = 0;
      carrying.args.ySpeed = 0;
      if (carrying instanceof _Coconut.Coconut || carrying instanceof _Mushroom.Mushroom) {
        if (this.mood.hunger > 0.5 || this.mood.hunger > 0.25 && Math.random() < 0.5) {
          this.args.emote = 'love';
          this.args.currentState = 'eating';
          carrying.carriedBy = this;
          carrying.noClip = true;
        } else {
          this.args.currentState = 'walking';
          carrying.noClip = false;
          carrying.carriedBy = null;
          this.carrying.delete(carrying);
          carrying.args.falling = true;
          carrying.args.x = this.args.x;
          carrying.args.y = this.args.y;
          carrying.args.xSpeed = this.args.direction * -3 + Math.random();
          carrying.args.ySpeed = -3 + Math.random();
          carrying.args.float = 0;
          this.ignores.set(carrying, 60);
        }
      }
    }
  }
  stateEating() {
    const eating = new Set();
    for (const carrying of this.carrying) {
      if (carrying instanceof _Coconut.Coconut || carrying instanceof _Mushroom.Mushroom) {
        eating.add(carrying);
      }
    }
    if (!this.args.falling) {
      this.args.ySpeed = 0;
    }
    if (!this.carriedBy) {
      this.args.float = 0;
    } else {
      this.args.float = -1;
    }
    this.args.xSpeed = 0;
    this.args.animation = 'eating';
    this.args.emote = 'love';
    if (this.selectedThing !== this.selectedFriend) {
      this.selectedThing = null;
    }
    this.selectedFood = null;
    this.selectedTree = null;
    if (this.args.stateTime && this.args.stateTime % 75 === 0) {
      for (const e of eating) {
        e.args.size--;
        this.mood.hunger -= e.args.nourishment;
        if (!e.args.size) {
          if (!this.carriedBy) {
            this.args.currentState = 'thinking';
          } else {
            this.args.currentState = 'held';
          }
          e.lift(this);
          this.viewport.actors.remove(e);
        }
      }
    }
  }
  stateHeld() {
    this.args.falling = false;
    if (this.args.stateTime < 15) {
      this.args.emote = 'like';
    } else if (this.args.stateTime < 60) {
      this.args.emote = 'love';
      this.args.animation = 'walking';
    } else if (this.args.stateTime === 61) {
      this.args.emote = 'normal';
      this.args.animation = 'searching';
    }
  }
  stateFun() {
    const [closest, minDist] = this.nearestFriend();
    if (!closest) {
      this.args.currentState = 'searching';
      return;
    }
    const dir = Math.sign(this.args.x - closest.args.x);
    this.args.direction = -dir;
    if (Math.abs(this.args.x - closest.args.x) < 16) {
      this.args.x -= (this.args.x - (closest.args.x + 16 * dir)) * 0.1;
    }
    if (minDist > 25) {
      this.args.currentState = 'searching';
      return;
    }
    if (this.mood.social < 0.5) {
      this.args.direction *= -1;
      this.args.currentState = 'walking';
      this.selectedFriend = null;
      this.selectedThing = null;
      return;
    }
    if (this.args.stateTime < 45) {
      this.args.emote = 'alert';
    } else {
      this.args.emote = 'love';
    }
    this.args.animation = 'walking';
    let factor = 1;
    if (this.selectedThing && this.selectedThing.args.currentState === 'fun') {
      factor = 0.4;
    }
    if (this.traits.sociable < 0.333) {
      this.mood.social -= 0.004 * factor;
    } else if (this.traits.sociable < 0.666) {
      this.mood.social -= 0.003 * factor;
    } else {
      this.mood.social -= 0.002 * factor;
    }
  }
  stateSeekingFriend() {
    if (this.viewport.args.frameId % 60 === 0) {
      const [closest, minDist] = this.nearestFriend();
      this.selectedThing = closest;
      this.selectedFriend = closest;
      if (!closest) {
        this.args.currentState = 'thinking';
        return;
      }
      this.args.direction = Math.sign(closest.args.x - this.args.x);
      if (closest.args.y < this.args.y) {
        this.args.currentState = 'flying';
      } else {
        this.args.currentState = 'walking';
      }
    }
  }
  stateSeekingFood() {
    this.selectedFriend = null;
    if (this.viewport.args.frameId % 60 === 0) {
      const [closest, minDist] = this.nearestFood();
      this.selectedThing = closest;
      this.selectedFood = closest;
      if (closest) {
        this.args.direction = Math.sign(closest.args.x - this.args.x);
        if (closest.args.y < this.args.y) {
          this.args.currentState = 'flying';
        } else {
          this.args.currentState = 'walking';
        }
      } else {
        this.selectedThing = null;
        this.selectedFood = null;
        this.args.currentState = 'thinking';
        const [closest, minDist] = this.nearestTree();
        this.selectedThing = closest;
        this.selectedTree = closest;
        if (!closest) {
          this.selectedThing = null;
          this.selectedTree = null;
          this.args.currentState = 'thinking';
          return;
        }
        this.args.direction = Math.sign(closest.args.x - this.args.x);
        if (closest.args.y < this.args.y) {
          this.args.currentState = 'flying';
        } else {
          this.args.currentState = 'walking';
        }
      }
    }
  }
  stateShakingTree() {
    if (!this.selectedTree) {
      this.args.currentState = 'thinking';
      return;
    }
    if (!this.selectedTree.args.coconutCount) {
      this.args.currentState = 'thinking';
      return;
    }
    if (this.args.stateTime % 45 === 0 && Math.random() > 0.75) {
      this.args.selectedThing = null;
      this.args.selectedTree = null;
      this.args.currentState = 'seekingFood';
      this.args.animation = 'standing';
      return;
    }
    const dir = Math.sign(this.args.x - this.selectedTree.args.x);
    this.args.direction = -dir;
    this.args.x = this.selectedTree.args.x + 8 * dir;
    this.args.z = this.selectedTree.args.z - 1;
    this.args.gSpeed = 0;
    this.args.animation = 'shaking';
  }
  store() {
    const frozen = {
      stateTime: this.args.stateTime,
      state: this.args.currentState,
      name: this.args.name,
      colors: this.customColors,
      align: this.args.alignment,
      position: [this.args.x, this.args.y],
      traits: this.traits,
      uuid: this.args.uuid,
      stats: this.stats,
      mood: this.mood,
      age: this.chaoAge
    };
    return frozen;
  }
  load(frozen) {
    var _frozen$name;
    if (typeof frozen === 'string') {
      frozen = JSON.parse(frozen);
    }
    this.args.name = (_frozen$name = frozen.name) !== null && _frozen$name !== void 0 ? _frozen$name : '';
    if (frozen.align) {
      this.args.alignment = frozen.align;
    }
    if (frozen.position) {
      this.args.x = frozen.position[0];
      this.args.y = frozen.position[1];
    }
    if (frozen.state) {
      var _frozen$stateTime;
      this.args.currentState = frozen.state;
      this.args.stateTime = (_frozen$stateTime = frozen.stateTime) !== null && _frozen$stateTime !== void 0 ? _frozen$stateTime : 0;
    }
    if (frozen.uuid) {
      this.args.uuid = frozen.uuid;
    }
    if (frozen.age) {
      this.chaoAge = frozen.age;
    }
    frozen.colors && Object.assign(this.customColors, frozen.colors);
    frozen.traits && Object.assign(this.stats, frozen.traits);
    frozen.stats && Object.assign(this.stats, frozen.stats);
    frozen.mood && Object.assign(this.mood, frozen.mood);
  }
  nearestFriend() {
    const actors = this.viewport.nearbyActors(this.args.x, this.args.y);
    let closest = null;
    let minDist = Infinity;
    for (const actor of actors) {
      if (actor === this) {
        continue;
      }

      // if(!(actor instanceof this.constructor) && !actor.controllable)
      if (!(actor instanceof this.constructor)) {
        continue;
      }
      if (actor.args.gSpeed || actor.args.currentState === 'eating') {
        continue;
      }
      const dist = this.distanceTo(actor);
      if (this.canSee(actor) && dist < minDist) {
        closest = actor;
        minDist = dist;
      }
    }
    return [closest, minDist];
  }
  nearestFood() {
    const actors = this.viewport.nearbyActors(this.args.x, this.args.y);
    let closest = null;
    let minDist = Infinity;
    for (const actor of actors) {
      if (actor === this) {
        continue;
      }
      if (!(actor instanceof _Coconut.Coconut)) {
        continue;
      }
      if (actor.carriedBy) {
        continue;
      }
      const dist = this.distanceTo(actor);
      if (this.canSee(actor) && dist < minDist) {
        closest = actor;
        minDist = dist;
      }
    }
    return [closest, minDist];
  }
  nearestTree() {
    const actors = this.viewport.nearbyActors(this.args.x, this.args.y);
    let closest = null;
    let minDist = Infinity;
    for (const actor of actors) {
      if (actor === this) {
        continue;
      }
      if (!(actor instanceof _Tree.Tree)) {
        continue;
      }
      if (!actor.args.coconutCount) {
        continue;
      }
      if (actor.args.shaking) {
        continue;
      }
      const dist = this.distanceTo(actor);
      if (this.canSee(actor) && dist < minDist) {
        closest = actor;
        minDist = dist;
      }
    }
    return [closest, minDist];
  }
}
exports.Chao = Chao;
});

;require.register("actor/ChaoCrate.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ChaoCrate = void 0;
var _BreakableBlock = require("./BreakableBlock");
var _Egg = require("./Egg");
class ChaoCrate extends _BreakableBlock.BreakableBlock {
  constructor() {
    super(...arguments);
    this.args.type = 'actor-item actor-breakable-block actor-chao-crate';
    this.args.width = 60;
    this.args.height = 60;
    this.args.static = false;
    this.args.spriteSheet = '/Sonic/chao-crate.png';

    // this.args.bindTo('spriteSheet', v => console.trace(v));
  }

  setTile() {}
  sleep() {}
  wakeUp() {}
  collideA(other, type) {
    if (type === 0 && other.controllable) {
      return true;
      // return super.collideA(other, type);
    }

    // if(other.spindashCharge)
    // {
    // 	this.break();
    // 	return true;
    // }

    if (type === -1 && !other.args.gSpeed && !other.args.falling && other.controllable) {
      this.break();
      return false;
    }
    if (type !== 1 && type !== 3 || other.y <= this.y - this.args.height) {
      return true;
    }
    if (other.args.rolling || type === 2) {
      this.break();
      return false;
    }
    if (!this.viewport) {
      return false;
    }
    if (type === -1 || other.args.rolling) {
      return super.collideA(other, type);
    }
    return true;
  }
  break() {
    if (this.broken) {
      return;
    }
    if (this.viewport.meta.fieldType !== 'garden') {
      // this.viewport.args.inventory.push('/DBurraki/chao-icon.png');
      this.viewport.args.inventory.push({
        points: 10000,
        tallyIcon: '/DBurraki/chao-icon.png',
        icon: '/DBurraki/chao-icon.png',
        id: this.oid
      });
      super.break();
      return;
    }
    for (let i = 0; i < 5; i++) {
      const egg = new _Egg.Egg({
        x: this.x,
        y: this.y - 3
      });
      this.viewport.spawn.add({
        object: egg
      });
      egg.args.falling = true;
      egg.args.xSpeed = (-0.5 + Math.random()) * 6;
      egg.args.ySpeed = -7;
    }
    super.break();
    this.viewport.onTimeout(1000, () => {
      this.viewport && this.viewport.actors.remove(this);
    });
  }
}
exports.ChaoCrate = ChaoCrate;
});

;require.register("actor/ChaoDetailer.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ChaoDetailer = void 0;
var _Block = require("./Block");
var _Chao = require("./Chao");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class ChaoDetailer extends _Block.Block {
  constructor() {
    super(...arguments);
    _defineProperty(this, "chaoStats", new WeakMap());
  }
  updateEnd() {
    let found = false;
    if (this.viewport.collisions.has(this)) for (const [other, type] of this.viewport.collisions.get(this)) {
      if (type !== 0) {
        continue;
      }
      if (other.args.falling) {
        continue;
      }
      if (!(other instanceof _Chao.Chao)) {
        continue;
      }
      this.viewport.args.quickForm = JSON.stringify({
        name: other.args.name,
        alignment: other.args.alignment
      }, null, 4) + "\n" + JSON.stringify(other.mood, null, 4) + "\n" + JSON.stringify(other.traits, null, 4) + "\n" + JSON.stringify(other.stats, null, 4);
      other.args.currentState = 'waiting';
      found = true;
    }
    if (!found) {
      this.viewport.args.quickForm = null;
    }
    super.update();
  }
}
exports.ChaoDetailer = ChaoDetailer;
});

;require.register("actor/Chopper.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Chopper = void 0;
var _PointActor = require("./PointActor");
var _Tag = require("curvature/base/Tag");
var _Mixin = require("curvature/base/Mixin");
var _Sfx = require("../audio/Sfx");
var _AirBomb = require("./AirBomb");
var _ChainShot = require("./ChainShot");
var _EggCapsule = require("./EggCapsule");
var _SkateBoard = require("./SkateBoard");
var _TitleScreenCard = require("../intro/TitleScreenCard");
class Chopper extends _Mixin.Mixin.from(_PointActor.PointActor) {
  constructor() {
    super(...arguments);
    this.args.type = 'actor-item actor-chopper';
    this.args.width = 80;
    this.args.height = 48;
    this.args.gravity = 0.25;
    this.args.float = -1;
    this.args.direction = 1;
    this.exploded = false;
    this.explosions = new Set();
    this.contains = new Set();
    this.args.xSpeed = 8;
    this.args.ySpeed = 6;
    this.args.attacker = this.args.attacker || false;
    this.args.color = 3; //Math.trunc(8 * Math.random());

    this.playingSound = false;
    this.activated = false;
    this.targetPoint = [0, 0];
    this.damageTimer = 0;
    if (this.args.attacker) {
      this.args.hitPoints = 8;
    }
    this.bombs = new Set();
    this.bombCount = 0;
  }
  collideA(other, type) {
    if (this.damageTimer || !this.args.attacker) {
      return;
    }
    if (other.args.jumping || other.args.rolling) {
      const avgSpeed = (other.args.xSpeed + this.args.xSpeed) * 0.5;
      _Sfx.Sfx.play('BOSS_DAMAGED');
      this.damageTimer = 30;
      this.args.hitPoints--;
      other.args.xSpeed = avgSpeed;
      other.args.ySpeed *= -1;
      if (other.args.ySpeed > 0) {
        other.args.ySpeed = -3;
      }
      if (this.args.hitPoints <= 0) {
        this.destroy();
        this.noClip = true;
        viewport.onFrameOut(60, () => {
          viewport.actors.remove(this);
          viewport.onFrameOut(60, () => {
            const capsule = new _EggCapsule.EggCapsule({
              x: other.args.x,
              y: other.args.y - 384,
              xSpeed: other.args.gSpeed || other.args.xSpeed
            });
            viewport.spawn.add({
              object: capsule
            });
          });
        });
      } else {
        this.args.xSpeed = 0;
        // this.args.ySpeed = 4;
      }
    }
  }

  onRendered(event) {
    super.onRendered(event);
    this.autoStyle.get(this.box)['--color'] = 'color';
  }
  update() {
    if (this.damageTimer) {
      this.args.type = 'actor-item actor-chopper actor-chopper-damaged';
    } else {
      this.args.type = 'actor-item actor-chopper';
    }
    if (this.args.attacker) {
      if (this.damageTimer > 0) {
        this.damageTimer--;
      }

      // this.attackUpdate();
    } else {
      this.introUpdate();
    }
  }
  updateEnd() {
    if (this.args.attacker) {
      this.attackUpdate();
    } else {
      super.updateEnd();
      // this.introUpdate();
    }

    for (const bomb of this.bombs) {
      bomb.args.x = this.args.x + bomb.xOffset;
    }
  }
  introUpdate() {
    if (this.viewport.currentMap !== this.mapUrl) {
      return;
    }
    if (this.viewport.controlActor) {
      this.contains.add(this.viewport.controlActor);
    }
    if (this.viewport.controlActor) {
      const actor = this.viewport.controlActor;

      // this.args.xSpeed += 0.1 * actor.xAxis;
      // this.args.ySpeed += 0.1 * actor.yAxis;
    }

    if (this.args.ySpeed > -4) {
      this.args.ySpeed -= 0.025;
    }
    for (const explosion of this.explosions) {
      explosion.style({
        '--x': this.args.x + explosion.x * this.args.direction,
        '--y': this.args.y
      });
    }
    if (!this.exploded) {
      if (!this.playingSound && this.viewport.args.audio, this.viewport.args.frameId - this.playingSound > 10) {
        this.playingSound = this.viewport.args.frameId;
        _Sfx.Sfx.play('COPTER_SPIN', {});
      }
      for (const actor of this.contains) {
        actor.args.float = -1;
        actor.args.x = this.args.x; // + 24 * this.args.direction;
        actor.args.y = this.args.y;
        actor.args.hidden = true;
        actor.args.xSpeed = this.args.xSpeed;
        actor.args.ySpeed = this.args.ySpeed;
      }
    } else {
      if (this.args.float) {
        _Sfx.Sfx.stop('COPTER_SPIN', false);
        this.viewport.onFrameOut(120, () => _Sfx.Sfx.play('RADIO_CHATTER_1'));
        this.args.float = 0;
      }
      super.update();
      return;
    }
    super.update();
    if (this.viewport && this.age && this.age % 300 === 0) {
      const explosionTag = document.createElement('div');
      explosionTag.classList.add('particle-huge-explosion');
      const explosion = new _Tag.Tag(explosionTag);
      explosion.style({
        '--x': this.args.x + 18 * this.args.direction,
        '--y': this.args.y - 16
      });
      _Sfx.Sfx.play('OBJECT_DESTROYED');
      const viewport = this.viewport;
      this.viewport.onFrameOut(200, () => {
        viewport.actors.remove(this);
      });
      this.viewport.onFrameOut(10, () => {
        this.noClip = true;
        this.args.xSpeed *= 0.50;
        this.args.ySpeed = 2;
        this.args.gravity = 0.35;

        // viewport.actors.remove(this)
        for (const actor of this.contains) {
          actor.args.ySpeed = -12;
          actor.args.xSpeed = 0;
          actor.args.hidden = false;
          actor.args.float = 0;
        }
      });
      this.args.animation = 'exploded';
      explosion.x = +18;
      this.explosions.add(explosion);
      this.exploded = true;
      this.viewport.particles.add(explosion);
      this.viewport.onFrameOut(30, () => {
        viewport.particles.remove(explosion);
        this.explosions.delete(explosion);
      });
      const board = new _SkateBoard.SkateBoard({
        x: this.args.x,
        y: this.args.y,
        ySpeed: -10,
        xSpeed: 4 * Math.sign(this.args.xSpeed),
        groundAngle: Math.PI / 4,
        ignore: -2
      });
      this.viewport.controlActor.args.standingOn = board;
      this.viewport.spawn.add({
        object: board
      });
    }
    if (this.viewport && this.age && this.age % 290 === 0) {
      const explosionTag = document.createElement('div');
      explosionTag.classList.add('particle-huge-explosion');
      const explosion = new _Tag.Tag(explosionTag);
      this.explosions.add(explosion);
      explosion.style({
        '--x': this.args.x + 36 * this.args.direction,
        '--y': this.args.y - 32
      });
      explosion.x = 36;
      _Sfx.Sfx.play('OBJECT_DESTROYED');
      this.viewport.particles.add(explosion);
      this.viewport.onFrameOut(30, () => viewport.particles.remove(explosion));
    }
    if (this.viewport && this.age && this.age % 295 === 0) {
      const explosionTag = document.createElement('div');
      explosionTag.classList.add('particle-huge-explosion');
      const explosion = new _Tag.Tag(explosionTag);
      this.explosions.add(explosion);
      explosion.style({
        '--x': this.args.x + 0 * this.args.direction,
        '--y': this.args.y - 24
      });
      explosion.x = 0;
      _Sfx.Sfx.play('OBJECT_DESTROYED');
      this.viewport.particles.add(explosion);
      this.viewport.onFrameOut(30, () => viewport.particles.remove(explosion));
    }
    this.args.falling = true;
  }
  attackUpdate() {
    if (this.args.hitPoints <= 0) {
      this.args.falling = true;
      this.args.float = 0;
      super.update();
      super.updateEnd();
      return;
    }
    this.args.groundAngle = 0;
    const other = this.viewport.controlActor;
    if (!this.playingSound && this.viewport.args.audio, this.viewport.args.frameId - this.playingSound > 10) {
      this.playingSound = this.viewport.args.frameId;
      _Sfx.Sfx.play('COPTER_SPIN', {});
    }
    if (other.args.mode !== 0) {
      super.update();
      super.updateEnd();
      return;
    }
    if (!this.activated) {
      if (other.args.x > this.args.x + 64) {
        const other = this.viewport.controlActor;
        this.args.xSpeed = other.args.gSpeed || other.args.xSpeed;

        // other.cofocused = this;

        this.viewport.auras.add(this);
        this.activated = this.viewport.args.frameId;
      }
      super.update();
      super.updateEnd();
      return;
    }
    if (!this.chainShot) {
      this.chainShot = new _ChainShot.ChainShot();
      this.viewport.spawn.add({
        object: this.chainShot
      });
      this.chainShot.args.x = this.args.x;
      this.chainShot.args.y = this.args.y;
    }
    if (other.dashed) {
      super.update();
      super.updateEnd();
      this.chainShot.args.animation = 'idle';
      return;
    }
    const activeTime = this.viewport.args.frameId - this.activated;
    if (activeTime > 120) {
      if (Math.floor(activeTime / 240) % 2 === 0) {
        this.bombModeUpdate();
      } else {
        this.gunModeUpdate();
      }
    } else {
      this.initModeUpdate();
    }
  }
  initModeUpdate() {
    const other = this.viewport.controlActor;
    if (this.chainShot) {
      this.chainShot.args.animation = 'idle';
    }
    if (!this.viewport || !this.viewport.controlActor || this.damageTimer) {
      if (this.damageTimer) {
        this.args.xSpeed = 0;
        this.args.ySpeed = 0;
      }
      super.update();
      super.updateEnd();
      this.lockPosition();
      return;
    }
    if (Math.abs(other.args.gSpeed) > 4 || other.args.falling) {
      this.targetPoint[0] = other.args.x + (-0 + -Math.min(64, Math.abs(other.args.gSpeed * 4))) * Math.sign(other.args.gSpeed);
      this.targetPoint[1] = other.args.y + -128;
    }
    let factor = 1;
    if (other.args.x < this.args.x) {
      this.args.facing = 'left';
    } else {
      this.args.facing = 'right';
    }
    this.args.xSpeed = factor * Math.min(25, Math.abs(0.35 * (this.args.x - this.targetPoint[0]))) * -Math.sign(this.args.x - this.targetPoint[0]);
    this.args.ySpeed = factor * Math.min(25, Math.abs(0.10 * (this.args.y - this.targetPoint[1]))) * -Math.sign(this.args.y - this.targetPoint[1]);
    this.args.falling = true;
    this.args.direction = this.args.facing === 'left' ? -1 : 1;
    super.update();
    super.updateEnd();
    this.lockPosition();
  }
  gunModeUpdate() {
    const other = this.viewport.controlActor;
    if (other.args.dead) {
      this.args.xSpeed = 0;
      this.args.ySpeed = 0;
      super.update();
      super.updateEnd();
      this.fireChaingun();
      this.chainShot.args.animation = 'shooting';
      return;
    }
    if (!this.viewport || !this.viewport.controlActor || this.damageTimer) {
      if (this.damageTimer) {
        this.args.xSpeed = 0;
        this.args.ySpeed = 0;
        this.chainShot.args.animation = 'idle';
      }
      super.update();
      super.updateEnd();
      this.lockPosition();
      // this.fireChaingun();
      this.chainShot.args.animation = 'idle';
      return;
    }
    if (Math.abs(other.args.gSpeed) > 4 || other.args.falling) {
      this.targetPoint[0] = other.args.x + (-96 + -Math.min(64, Math.abs(other.args.gSpeed * 4))) * Math.sign(other.args.gSpeed);
      this.targetPoint[1] = other.args.y + (-40 + -Math.min(0, Math.abs(other.args.gSpeed)));
    }
    let factor = 1;
    if (other.args.jumping && Math.abs(other.args.xSpeed) < 15 && Math.sign(other.args.xSpeed) === Math.sign(this.args.x - other.args.x)) {
      console.log(Math.sign(other.args.xSpeed), Math.sign(this.args.x - other.args.x));
      factor = 0.25;
    }
    if (other.args.x < this.args.x) {
      this.args.facing = 'left';
    } else {
      this.args.facing = 'right';
    }
    this.args.xSpeed = factor * Math.min(25, Math.abs(0.35 * (this.args.x - this.targetPoint[0]))) * -Math.sign(this.args.x - this.targetPoint[0]);
    this.args.ySpeed = factor * Math.min(25, Math.abs(0.20 * (this.args.y - this.targetPoint[1]))) * -Math.sign(this.args.y - this.targetPoint[1]);
    this.args.falling = true;
    this.args.direction = this.args.facing === 'left' ? -1 : 1;
    super.update();
    super.updateEnd();
    this.lockPosition();
    if (Math.abs(other.args.y - this.args.y) < 48 && !other.args.falling) {
      this.fireChaingun();
      this.chainShot.args.animation = 'shooting';
    } else {
      this.chainShot.args.animation = 'idle';
    }
  }
  bombModeUpdate() {
    const other = this.viewport.controlActor;
    if (this.chainShot) {
      this.chainShot.args.animation = 'idle';
    }
    if (!this.viewport || !this.viewport.controlActor || this.damageTimer) {
      if (this.damageTimer) {
        this.args.xSpeed = 0;
        this.args.ySpeed = 0;
      }
      super.update();
      super.updateEnd();
      this.lockPosition();
      return;
    }
    if (Math.abs(other.args.gSpeed) > 4 || other.args.falling) {
      this.targetPoint[0] = other.args.x + (-0 + -Math.min(64, Math.abs(other.args.gSpeed * 4))) * Math.sign(other.args.gSpeed);
      this.targetPoint[1] = other.args.y + -128;
    }
    let factor = 1;
    if (other.args.x < this.args.x) {
      this.args.facing = 'left';
    } else {
      this.args.facing = 'right';
    }
    this.args.xSpeed = factor * Math.min(25, Math.abs(0.35 * (this.args.x - this.targetPoint[0]))) * -Math.sign(this.args.x - this.targetPoint[0]);
    this.args.ySpeed = factor * Math.min(25, Math.abs(0.10 * (this.args.y - this.targetPoint[1]))) * -Math.sign(this.args.y - this.targetPoint[1]);
    this.args.falling = true;
    if (this.viewport.args.frameId % 30 === 0) {
      const offset = 16 * Math.sign(this.args.direction) + (-0.5 + this.bombCount % 2) * 16;
      const bomb = new _AirBomb.AirBomb({
        x: this.args.x + offset,
        y: this.args.y,
        xSpeed: this.args.xSpeed,
        ySpeed: this.args.ySpeed
      });
      this.bombCount++;
      bomb.xOffset = offset;
      this.bombs.add(bomb);
      this.viewport.spawn.add({
        object: bomb
      });
    }
    this.args.direction = this.args.facing === 'left' ? -1 : 1;
    super.update();
    super.updateEnd();
    this.lockPosition();
  }
  fireChaingun() {
    this.args.direction = this.args.direction || Math.sign(this.xSpeedLast);
    const shotX = 56 * Math.sign(this.args.direction);
    const shotY = 0;
    this.chainShot.args.x = this.args.x + shotX;
    this.chainShot.args.y = this.args.y + shotY;
    this.chainShot.args.xSpeed = this.args.xSpeed;
    this.chainShot.args.ySpeed = this.args.ySpeed;
    this.viewport.setColCell(this.chainShot);
    if (this.args.direction > 0) {
      this.chainShot.args.groundAngle = Math.PI * -0.65;
    } else {
      this.chainShot.args.groundAngle = Math.PI * 0.65;
    }
    this.chainShot.args.shooting = true;
    const length = this.chainShot.castRayQuick(786, -Math.PI * 0.5 - this.chainShot.args.groundAngle);
    this.chainShot.args.shooting = false;
    this.chainShot.args.height = length || 786;
  }
  lockPosition() {
    {
      const diff = this.args.x - this.targetPoint[0];
      const dist = Math.abs(diff);
      const sign = Math.sign(diff);
      if (dist > 386) {
        this.args.x = this.targetPoint[0] + 386 * sign;
      }
    }
    {
      const diff = this.args.y - this.targetPoint[1];
      const dist = Math.abs(diff);
      const sign = Math.sign(diff);
      if (dist > 386) {
        this.args.y = this.targetPoint[1] + 386 * sign;
      }
    }
  }
  destroy() {
    const viewport = this.viewport;
    _Sfx.Sfx.stop('COPTER_SPIN', false);
    viewport.onFrameOut(20, () => {
      const explosionTag = document.createElement('div');
      explosionTag.classList.add('particle-huge-explosion');
      const explosion = new _Tag.Tag(explosionTag);
      explosion.style({
        '--x': this.args.x + 18 * this.args.direction,
        '--y': this.args.y - 16
      });
      _Sfx.Sfx.play('OBJECT_DESTROYED');

      // this.noClip = true;

      this.args.animation = 'exploded';
      explosion.x = +18;
      this.explosions.add(explosion);
      this.exploded = true;
      viewport.particles.add(explosion);
      viewport.onFrameOut(30, () => {
        viewport.particles.remove(explosion);
        this.explosions.delete(explosion);
      });
      const other = viewport.controlActor;
      other.cofocused = null;
    });
    viewport.onFrameOut(0, () => {
      const explosionTag = document.createElement('div');
      explosionTag.classList.add('particle-huge-explosion');
      const explosion = new _Tag.Tag(explosionTag);
      this.explosions.add(explosion);
      explosion.style({
        '--x': this.args.x + 36 * this.args.direction,
        '--y': this.args.y - 32
      });
      explosion.x = 36;
      _Sfx.Sfx.play('OBJECT_DESTROYED');
      viewport.particles.add(explosion);
      viewport.onFrameOut(30, () => viewport.particles.remove(explosion));
    });
    viewport.onFrameOut(10, () => {
      const explosionTag = document.createElement('div');
      explosionTag.classList.add('particle-huge-explosion');
      const explosion = new _Tag.Tag(explosionTag);
      this.explosions.add(explosion);
      explosion.style({
        '--x': this.args.x + 0 * this.args.direction,
        '--y': this.args.y - 24
      });
      explosion.x = 0;
      _Sfx.Sfx.play('OBJECT_DESTROYED');
      viewport.particles.add(explosion);
      viewport.onFrameOut(30, () => viewport.particles.remove(explosion));
    });
  }
}
exports.Chopper = Chopper;
});

;require.register("actor/Cinematic.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Cinematic = void 0;
var _PointActor = require("./PointActor");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class Cinematic extends _PointActor.PointActor {
  constructor(args, parent) {
    super(args, parent);
    _defineProperty(this, "noClip", true);
    _defineProperty(this, "panSpeed", 9);
    this.args.isGhost = true;
    this.args.float = -1;
    this.target = null;
    this.targets = [[250, 6500], [5900, 6600], [250, 6500], [7700, 7800], [6800, 4200], [6800, 4200], [8000, 4300], [1450, 1800]];
  }
  setCameraMode() {
    this.args.cameraMode = 'cinematic';
  }
  update() {
    super.update();
    if (!this.args.selected) {
      return;
    }
    if (!this.target || this.x === this.target[0] && this.y === this.target[1]) {
      if (!this.targets.length) {
        this.remove();
      }
      this.target = this.targets.shift();
      return;
    }
    const target = this.target;
    if (this.x !== target[0]) {
      const space = target[0] - this.x;
      this.args.x += Math.sign(space) * this.panSpeed;
      if (Math.abs(space) < this.panSpeed) {
        this.args.x = target[0];
      }
    }
    if (this.y !== target[1]) {
      const space = target[1] - this.y;
      this.args.y += Math.sign(space) * this.panSpeed;
      if (Math.abs(space) < this.panSpeed) {
        this.args.y = target[1];
      }
    }
  }
  get controllable() {
    return true;
  }
}
exports.Cinematic = Cinematic;
});

;require.register("actor/Coconut.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Coconut = void 0;
var _PointActor = require("./PointActor");
class Coconut extends _PointActor.PointActor {
  constructor() {
    super(...arguments);
    this.args.type = 'actor-item actor-coconut';
    this.args.width = 12;
    this.args.height = 13;
    this.args.size = 4;
    this.args.nourishment = 0.05;
    this.bindTo('carriedBy', carrier => {
      if (this.cX) {
        this.cX();
        this.cX = null;
      }
      if (this.cY) {
        this.cY();
        this.cY = null;
      }
      if (this.carriedBy) {
        const carrier = this.carriedBy;
        this.carriedBy = null;
        this.args.xSpeed = carrier.args.xSpeed;
        this.args.ySpeed = carrier.args.falling ? carrier.args.ySpeed : 0;
        this.args.xSpeed += Math.sign(carrier.args.gSpeed || carrier.args.xSpeed) * 4;
        this.args.ySpeed -= 4;
        carrier.carrying.delete(this);
        this.args.falling = true;
        this.args.float = 0;
      }
      if (carrier) {
        this.cX = carrier.args.bindTo('x', v => this.args.x = v + carrier.args.direction * carrier.xHold);
        this.cY = carrier.args.bindTo('y', v => this.args.y = v + -carrier.yHold);
        this.args.xSpeed = 0;
        this.args.ySpeed = 0;
        carrier.carrying.add(this);
        this.args.float = -1;
      }
    });
  }
  onRendered(event) {
    super.onRendered(event);
    this.autoStyle.get(this.box)['--size'] = 'size';
  }
  lift(actor) {
    if (this.carriedBy === actor) {
      this.carriedBy = null;
      return;
    }
    this.carriedBy = actor;
  }
  get solid() {
    return false;
  }
  get rotateLock() {
    return true;
  }
  sleep() {
    if (this.carriedBy) {
      return;
    }
    if (!this.viewport) {
      return;
    }
    this.viewport.actors.remove(this);
  }
}
exports.Coconut = Coconut;
});

;require.register("actor/Coin.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Coin = void 0;
var _PointActor = require("./PointActor");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class Coin extends _PointActor.PointActor {
  constructor() {
    super(...arguments);
    _defineProperty(this, "float", -1);
    this.args.type = 'actor-item actor-coin';
    this.args.width = 32;
    this.args.height = 32;
    this.args.gone = false;
  }
  update() {
    super.update();
    if (this.viewport.args.audio && !this.sample) {
      this.sample = new Audio('/mario/smw_coin.wav');
      this.sample.volume = 1;
    }
  }
  collideA(other) {
    super.collideA(other);
    if (this.args.gone) {
      return;
    }
    this.args.type = 'actor-item actor-coin collected';
    if (!this.args.gone) {
      if (this.viewport.args.audio && this.sample) {
        this.sample.play();
      }
      this.viewport.onFrameOut(40, () => {
        this.args.type = 'actor-item actor-coin collected gone';
      });
      this.viewport.onFrameOut(80, () => {
        this.viewport.actors.remove(this);
        this.remove();
      });
      const x = this.x;
      const y = this.y;

      // const viewport = this.viewport;

      // viewport.spawn.add({
      // 	time: Date.now() + 7500
      // 	, frame:  this.viewport.args.frameId + 450
      // 	, object: new Coin({x,y})
      // });

      if (other.args.owner) {
        other.args.owner.args.coins += 1;
      } else if (other.occupant) {
        other.occupant.args.coins += 1;
      } else {
        other.args.coins += 1;
      }
    }
    this.args.gone = true;
  }
  get solid() {
    return false;
  }
  get isEffect() {
    return true;
  }
}
exports.Coin = Coin;
});

;require.register("actor/CompanionBlock.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CompanionBlock = void 0;
var _MarbleBlock = require("./MarbleBlock");
var _LavaRegion = require("../region/LavaRegion");
var _Sfx = require("../audio/Sfx");
var _Analytic = require("../lib/Analytic");
class CompanionBlock extends _MarbleBlock.MarbleBlock {
  constructor() {
    let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    super(args);
    this.args.type = 'actor-item actor-marble-companion-block';
    this.played = false;
    this.args.density = this.args.density || 10;
  }
  collideA(other, type) {
    if (this.args.falling && other.y > 8 + this.y + -this.args.height) {
      // return false;
    } else if (this.args.falling && other.y > this.y - this.args.height) {
      // other.args.y = this.y - this.args.height
    } else if (this.args.falling && other.args.modeTime < 3) {
      other.args.gSpeed = 0;
    }
    return super.collideA(other, type);
  }
  update() {
    const preX = this.args.x;
    let isInLava = false;
    const regions = this.regions;
    let localDensity = 0,
      denseRegion = null;
    for (const region of regions) {
      if (region.args.density > localDensity) {
        localDensity = region.args.density;
        denseRegion = region;
      }
      this.args.y = Math.round(this.args.y);
      if (region instanceof _LavaRegion.LavaRegion) {
        isInLava = true;

        // if(this.args.height > 18)
        // {
        // 	this.args.height = 18;
        // }

        if (!this.played) {
          this.args.type = 'actor-item actor-marble-companion-block actor-marble-companion-block-dying';
          this.viewport.onFrameOut(80, () => {
            this.args.type = 'actor-item actor-marble-companion-block actor-marble-companion-block-dead';
            _Sfx.Sfx.play('PLAYER_DAMAGED');
          });
          if (typeof ga === 'function') {
            _Analytic.Analytic.report({
              eventCategory: 'companion-block',
              eventAction: 'pushed',
              eventLabel: `${this.viewport.args.actName}::${this.args.id}`
            });
          }
          this.played = true;
        }
      }
    }
    if (denseRegion && localDensity && this.args.density) {
      const thisBottom = this.args.y;
      const regionTop = denseRegion.args.y + -denseRegion.args.height;
      const yDiff = Math.min(this.args.height, thisBottom - regionTop);
      const pressure = this.args.gravity * (localDensity / this.args.density) * (yDiff / this.args.height);
      this.args.ySpeed -= pressure;
      if (!this.args.falling) {
        this.args.y--;
        this.args.falling = true;
      }
    }
    super.update();
    if (isInLava) {
      if (this.fallTime < 100) {
        this.args.xSpeed = 0;
      } else {
        this.args.xSpeed = Math.sign(this.gSpeedLast || this.xSpeedLast);
      }
    }
  }
  sleep() {
    this.args.x = this.def.get('x');
    this.args.y = this.def.get('y');
    this.onNextFrame(() => {
      this.args.x = this.def.get('x');
      this.args.y = this.def.get('y');
      this.viewport.setColCell(this);
      this.args.xSpeed = 0;
      this.args.ySpeed = 0;
      this.args.pushed = 0;
      this.args.float = 0;
    });
  }
}
exports.CompanionBlock = CompanionBlock;
});

;require.register("actor/Cone.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Cone = void 0;
var _PointActor = require("./PointActor");
class Cone extends _PointActor.PointActor {
  constructor() {
    super(...arguments);
    this.args.width = 16;
    this.args.height = 32;
    this.args.type = 'actor-item actor-cone';
  }
  get solid() {
    return false;
  }
}
exports.Cone = Cone;
});

;require.register("actor/CrabMeat.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CrabMeat = void 0;
var _Flickie = require("./Flickie");
var _Mixin = require("curvature/base/Mixin");
var _Tag = require("curvature/base/Tag");
var _PointActor = require("./PointActor");
var _SkidDust = require("../behavior/SkidDust");
var _Patrol = require("../behavior/Patrol");
var _CanPop = require("../mixin/CanPop");
var _Explosion = require("../actor/Explosion");
var _Projectile = require("../actor/Projectile");
class CrabMeat extends _Mixin.Mixin.from(_PointActor.PointActor, _CanPop.CanPop) {
  constructor() {
    super(...arguments);
    this.behaviors.add(new _SkidDust.SkidDust());
    this.behaviors.add(new _Patrol.Patrol());
    this.args.type = 'actor-item actor-crabmeat';
    this.args.animation = 'standing';
    this.args.accel = 0.1;
    this.args.decel = 0.5;
    this.args.gSpeedMax = 5;
    this.args.jumpForce = 5;
    this.args.gravity = 0.5;
    this.args.width = 32;
    this.args.height = 32;
    this.willStick = false;
    this.stayStuck = false;
    this.args.patrolBeat = this.args.patrolBeat || 90;
    this.args.patrolPause = this.args.patrolPause || 25;
    this.args.patrolSpeed = this.args.patrolSpeed || 0.25;
    this.args.shotTelegraph = this.args.shotTelegraph || 65;
  }
  update() {
    const direction = this.args.direction;
    super.update();
    const telegraph = this.args.shotTelegraph;
    const beat = this.args.patrolBeat;
    if (this.box) {
      if (Math.sign(this.args.gSpeed) !== direction && Math.abs(this.args.gSpeed - direction) > 5) {
        this.box.setAttribute('data-animation', 'skidding');
      } else if (this.args.moving && this.args.gSpeed) {
        this.box.setAttribute('data-animation', 'walking');
      } else if (this.age % beat < telegraph || this.age % beat > beat - 15) {
        this.box.setAttribute('data-animation', 'shooting');
      } else {
        this.box.setAttribute('data-animation', 'standing');
      }
    }
    if (this.age % beat === beat - 3) {
      const xA = this.x + 19;
      const xB = this.x + -19;
      const y = this.y + -19;
      const z = -1;
      const xSpeed = -1.5;
      const ySpeed = -3;
      const owner = this;
      const ballA = new _Projectile.Projectile({
        x: xA,
        y,
        z,
        owner
      });
      const ballB = new _Projectile.Projectile({
        x: xB,
        y,
        z,
        owner
      });
      this.viewport.onFrameOut(3, () => {
        Object.assign(ballA.args, {
          xSpeed: -xSpeed,
          ySpeed
        });
        Object.assign(ballB.args, {
          xSpeed,
          ySpeed
        });
      });
      this.viewport.spawn.add({
        object: ballA
      });
      this.viewport.spawn.add({
        object: ballB
      });
    }
  }
  effect(other) {
    super.effect(other);

    // this.viewport.spawn.add({object:new Flickie({
    // 	x: this.args.x,
    // 	y: this.args.y,
    // })});
  }

  get solid() {
    return false;
  }
  get isEffect() {
    return false;
  }
  // get controllable() { return true; }
}
exports.CrabMeat = CrabMeat;
});

;require.register("actor/CrossCannon.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CrossCannon = void 0;
var _PointActor = require("./PointActor");
var _Tag = require("curvature/base/Tag");
var _Sfx = require("../audio/Sfx");
class CrossCannon extends _PointActor.PointActor {
  constructor() {
    super(...arguments);
    this.args.width = 48;
    this.args.height = 40;
    this.args.type = 'actor-item actor-cross-cannon';
    this.args.float = -1;
    this.args.power = this.args.power || 20;
    this.holding = new Map();
    this.args.spinTime = 0;
    this.args.minHold = 9;
    this.args.z = 100;
    this.args.grabbing = null;
  }
  onRendered(event) {
    super.onRendered(event);
    this.autoAttr.get(this.box)['data-firing'] = 'firing';
    this.autoAttr.get(this.box)['data-aiming'] = 'aiming';
    this.autoAttr.get(this.box)['data-grabbing'] = 'grabbing';
    if (!this.barrelUp) {
      this.barrelUp = new _Tag.Tag(`<div class = "barrel barrel-up">`);
      this.box.appendChild(this.barrelUp.node);
    }
    if (!this.barrelDown) {
      this.barrelDown = new _Tag.Tag(`<div class = "barrel barrel-down">`);
      this.box.appendChild(this.barrelDown.node);
    }
    if (!this.barrelLeft) {
      this.barrelLeft = new _Tag.Tag(`<div class = "barrel barrel-left">`);
      this.box.appendChild(this.barrelLeft.node);
    }
    if (!this.barrelRight) {
      this.barrelRight = new _Tag.Tag(`<div class = "barrel barrel-right">`);
      this.box.appendChild(this.barrelRight.node);
    }
  }
  collideA(other, type) {
    if (!other.controllable) {
      return;
    }
    if (other.isVehicle) {
      other = other.occupant;
    }
    if (this.holding.has(other)) {
      return false;
    }
    const x = other.args.x;
    const y = other.args.y;
    if (!other.args.falling) {
      other.args.falling = true;
      other.args.float = 1;
      other.args.y -= 1;
    }
    if (other.args.standingOn) {
      other.args.standingOn = null;
      other.args.xSpeed = 0;
      other.args.ySpeed = 0;
    }
    _Sfx.Sfx.play('SS_BWIP');
    if (type === -1 || type % 2 === 0) {
      const xDiff = Math.abs(other.args.x - this.args.x);
      this.holding.set(other, this.viewport.args.frameId);
      other.args.xSpeed = 0;
      other.args.ySpeed = 0;
      other.args.float = -1;
      other.args.ignore = -1;
      return false;
    }
    return true;
  }
  dropDelay(other) {
    let waitFor = false;
    if (this.args.waitFor) {
      waitFor = this.viewport.actorsById[this.args.waitFor];
    }
    if (!waitFor) {
      return new Promise(accept => this.viewport.onFrameOut(240, () => accept()));
    }
    return waitFor.dropDelay(other);
  }
  update() {
    super.update();
    if (!this.holding.size) {
      this.args.spinTime = 0;
    }
    for (const [other, caughtAt] of this.holding) {
      const toX = this.args.x + -4;
      const toY = -6 + this.args.y;
      const stepX = (toX + -other.args.x) / 6;
      const stepY = (toY + -other.args.y) / 6;
      const holdTime = this.viewport.args.frameId - caughtAt;
      other.args.animation = 'jumping';
      if (Math.abs(other.args.y - toY) < stepY) {
        other.args.y = toY;
      } else {
        other.args.y += stepY;
      }
      if (Math.abs(other.args.x - toX) < stepX) {
        other.args.x = toX;
      } else {
        other.args.x += stepX;
      }
      other.args.groundAngle += -other.args.groundAngle * 0.05;
      if (holdTime < 5) {
        this.args.grabbing = 'grabbing';
      } else if (holdTime < 10) {
        this.args.grabbing = 'grabbed';
      } else {
        this.args.grabbing = null;
      }
      if (holdTime > 100) {
        // other.args.float  = 0;
        // other.args.ignore = 1;
        // this.ignores.set(other, 16);
        // this.holding.delete(other);
        // return;
      }
      other.canJump = true;
      other.args.jumping = false;
      if (other.willJump && this.args.spinTime < this.args.minHold) {
        this.args.spinTime = 0;
        this.args.aiming = '';
        return;
      } else if (other.willJump && this.args.aiming && this.args.spinTime >= this.args.minHold) {
        this.args.firing = 'firing';
        this.viewport.onFrameOut(6, () => {
          this.args.firing = 'fired';
        });
        this.viewport.onFrameOut(16, () => {
          this.args.firing = '';
        });
        this.viewport.onFrameOut(24, () => {
          this.args.aiming = '';
        });
        this.viewport.onFrameOut(6, () => {
          if (!this.args.aiming) {
            return;
          }
          _Sfx.Sfx.play('SPRING_SHOT');
          this.holding.delete(other);
          other.args.jumping = true;
          this.ignores.set(other, 2);
          other.args.ignore = 1;
          other.args.float = 0;
          if (other.yAxis > 0) {
            other.args.ySpeed = this.args.power;
          } else if (other.yAxis < 0) {
            other.args.ySpeed = -this.args.power;
          } else if (other.xAxis > 0) {
            other.args.xSpeed = this.args.power;
            other.args.ySpeed = 0;
            other.args.float = 8;
          } else if (other.xAxis < 0) {
            other.args.xSpeed = -this.args.power;
            other.args.ySpeed = 0;
            other.args.float = 8;
          }
        });
      }
      if (this.args.spinTime > 5) {
        other.args.cameraMode = 'cross-cannon-quick';
      } else {
        other.args.cameraMode = 'cross-cannon';
      }
      if (other.yAxis > 0) {
        this.args.aiming = 'down';
      } else if (other.yAxis < 0) {
        this.args.aiming = 'up';
      } else if (other.xAxis > 0) {
        this.args.aiming = 'right';
      } else if (other.xAxis < 0) {
        this.args.aiming = 'left';
      }
      if (!other.yAxis && !other.xAxis) {
        this.args.spinTime = 0;
        this.args.aiming = '';
      } else if (this.args.aiming) {
        if (this.args.spinTime === 0) {
          _Sfx.Sfx.play('QUICK_SLIDE');
        }
        this.args.spinTime++;
      }
      if (this.args.spinTime === this.args.minHold && this.args.aiming) {
        _Sfx.Sfx.play('PAD_BOUNCE');
      }

      // if(this.viewport.args.frameId % (60 * 3) === 0)
      // {
      // 	this.args.aiming = '';
      // }
    }
  }

  wakeUp() {
    this.args.aiming = '';
  }

  // get solid() { return !this.holding; }
}
exports.CrossCannon = CrossCannon;
});

;require.register("actor/Crusher.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Crusher = void 0;
var _PointActor = require("./PointActor");
var _Mixin = require("curvature/base/Mixin");
var _Constrainable = require("../mixin/Constrainable");
var _Block = require("./Block");
class Crusher extends _Mixin.Mixin.from(_PointActor.PointActor, _Constrainable.Constrainable) {
  constructor() {
    super(...arguments);
    this.args.width = 112;
    this.args.height = 24;
    this.args.type = 'actor-item actor-crusher';
    // this.args.ropeLength = this.args._tiedTo ? this.args.ropeLength : 8;
    this.args.gravity = 0.8;
    // this.args.stay = true;
    // this.args.float = -1;
  }

  update() {
    if (!this.others.tiedTo) {
      super.update();
    }
  }
  updateStart() {
    super.update();
    const tiedTo = this.others.tiedTo;
    if (tiedTo) {
      this.setPos();
    }
    super.updateStart();
  }
  get solid() {
    return true;
  }
}
exports.Crusher = Crusher;
});

;require.register("actor/Cursor.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Cursor = void 0;
var _PointActor = require("./PointActor");
class Cursor extends _PointActor.PointActor {
  update() {}
}
exports.Cursor = Cursor;
});

;require.register("actor/CutScene.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CutScene = void 0;
var _PointActor = require("./PointActor");
class CutScene extends _PointActor.PointActor {
  constructor() {
    let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let parent = arguments.length > 1 ? arguments[1] : undefined;
    super(args, parent);
    if (args.src) {
      this.fetcher = fetch(args.src).then(r => r.json());
    } else if (args.frames) {
      this.fetcher = Promise.resolve(args.frames);
    }
    this.args.hidden = true;
  }
  playSample(event) {
    const viewport = this.viewport;
    if (!viewport.args.audio) {
      return;
    }
    const tag = new Audio(event.source);
    tag.play();
  }
  activate(other, button) {
    let force = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    if (!other.controllable || other.args.falling && !force) {
      return;
    }
    if (!button && other.args.canonical !== 'Sonic') {
      return;
    }
    const viewport = this.viewport;
    if (!viewport || this.args.running) {
      return;
    }
    this.args.running = true;
    other.args.gSpeed = 0;
    viewport.args.cutScene = true;
    other.controller.zero();
    this.fetcher.then(scene => {
      let timer = 0;
      for (const frame of scene) {
        const frameCallback = () => {
          switch (frame.event) {
            case 'dialog':
              viewport.showDialog(frame.lines, frame.classes);
              break;
            case 'audio':
              this.playSample(frame);
              break;
            case 'face':
              other.args.direction = frame.direction;
              other.args.facing = frame.direction > 0 ? 'right' : 'left';
              break;
            case 'input':
              if (frame.axes) {
                other.controller.replay({
                  axes: frame.axes
                });
              }
              if (frame.buttons) {
                other.controller.replay({
                  buttons: frame.buttons
                });
              }
              other.readInput();
              break;
            case 'superdrop':
              other.dropDashCharge = 30;
              break;
            case 'clearAct':
              viewport.clearAct(frame.message);
              break;
            case 'clear':
              viewport.clearDialog();
              break;
            case 'message':
              viewport.showCenterMessage(frame.message);
              break;
            case 'hide':
              viewport.hideCenterMessage();
              viewport.hideDialog();
              break;
            case 'wait':
              viewport.args.cutScene = false;
              viewport.hideCenterMessage();
              viewport.hideDialog();
              break;
          }
        };
        if (timer) {
          viewport.onFrameOut(timer, frameCallback);
        } else {
          frameCallback();
        }
        timer += frame.time || 0;
      }
    });
  }
}
exports.CutScene = CutScene;
});

;require.register("actor/Dish.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Dish = void 0;
var _PointActor = require("./PointActor");
var _Mixin = require("curvature/base/Mixin");
var _CanPop = require("../mixin/CanPop");
class Dish extends _Mixin.Mixin.from(_PointActor.PointActor, _CanPop.CanPop) {
  static fromDef(objDef) {
    const obj = super.fromDef(objDef);
    obj.args.width = objDef.width;
    obj.args.height = objDef.height;
    return obj;
  }
  constructor() {
    super(...arguments);
    this.args.width = 46;
    this.args.height = 50;
    this.args.type = 'actor-item actor-dish';
  }
  get solid() {
    return false;
  }
}
exports.Dish = Dish;
});

;require.register("actor/Dolphin.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Dolphin = void 0;
var _PointActor = require("./PointActor");
var _Mixin = require("curvature/base/Mixin");
// import { Sfx } from '../audio/Sfx';

class Dolphin extends _Mixin.Mixin.from(_PointActor.PointActor) {
  constructor() {
    super(...arguments);
    this.args.type = 'actor-item actor-dolphin';
    this.args.width = 64;
    this.args.height = 64;
    this.args.gravity = 0.4;
    this.noClip = true;
    this.args.float = -1;
  }
  update() {
    if (!this.viewport || !this.viewport.controlActor) {
      return;
    }
    const controlActor = this.viewport.controlActor;
    if (this.args.ySpeed < -4) {
      this.args.type = 'actor-item actor-dolphin';
    } else {
      this.args.type = 'actor-item actor-dolphin actor-dolphin-downward';
    }
    if (!this.args.ySpeed && this.args.x < -128 + controlActor.args.x) {
      this.args.falling = true;
      this.args.xSpeed = 6 + (controlActor.args.xSpeed || controlActor.args.gSpeed);
      this.args.ySpeed = -16;
      this.args.float = 0;
    }
    super.update();
  }
}
exports.Dolphin = Dolphin;
});

;require.register("actor/Door.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Door = void 0;
var _PointActor = require("./PointActor");
class Door extends _PointActor.PointActor {
  constructor() {
    super(...arguments);
    this.behaviors.clear();
    this.args.type = 'actor-item actor-door';
    this.args.width = 32;
    this.args.height = 64;
    this.args.opened = false;
    this.args.opening = false;
  }
  onRendered() {
    super.onRendered(event);
    this.setAutoAttr('opening', 'data-opening');
    this.setAutoAttr('opened', 'data-opened');
  }
  open(other) {
    if (!other.controllable) {
      return;
    }
    if (this.others.waitFor && this.others.waitFor.args.opened) {
      this.args.opening = this.args.opened = false;
      return;
    }
    this.args.opening = true;
    this.viewport.onFrameOut(10, () => this.args.opened = true);
    this.viewport.onFrameOut(50, () => this.args.opening = false);
    this.viewport.onFrameOut(55, () => this.args.opened = false);
  }
  collideA(other, type) {
    if (this.args.opening) {
      return !this.args.opened;
    }
    if (!this.args.opened) {
      this.viewport.onFrameOut(20, () => this.open(other));
    }
    return !this.args.opened;
  }
  sleep() {
    if (!this.viewport) {
      return;
    }
    this.args.opening = this.args.opened = false;
  }
  get solid() {
    return !this.args.opened;
  }
  get rotateLock() {
    return true;
  }
}
exports.Door = Door;
});

;require.register("actor/DrainFly.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DrainFly = void 0;
var _PointActor = require("./PointActor");
var _Platformer = require("../behavior/Platformer");
var _Mixin = require("curvature/base/Mixin");
var _CanPop = require("../mixin/CanPop");
// import { Follower } from './Follower';

class DrainFly extends _Mixin.Mixin.from(_PointActor.PointActor, _CanPop.CanPop) {
  constructor(args, parent) {
    super(args, parent);
    this.args.type = 'actor-item actor-drainfly';
    this.args.width = 16;
    this.args.height = 16;
    this.args.float = -1;
    this.args.gravity = 0;
    this.args.phase = 'idle';
  }
  update() {
    if (!this.viewport || !this.viewport.actorIsOnScreen(this)) {
      return;
    }
    const viewport = this.viewport;
    super.update();
    const mainChar = viewport.controlActor;
    if (!mainChar) {
      this.args.phase = 'idle';
      return;
    }
    switch (this.args.phase) {
      case 'idle':
        this.args.alertTo = this.y - 64;
        if (mainChar.x + -this.x > -128) {
          this.args.phase = 'alert';
        }
        break;
      case 'alert':
        if (this.y > this.args.alertTo) {
          this.args.ySpeed--;
        } else {
          this.args.phase = 'attacking';
          this.args.y = this.args.alertTo;
          this.args.ySpeed = 0;
        }
        break;
      case 'attacking':
        {
          const drawX = Math.sign(mainChar.args.x + -this.args.x) || 0;
          const drawY = Math.sign(mainChar.args.y + -this.args.y + -24) || 0;
          this.args.xSpeed += drawX * 0.2 - Math.random() / 10 || 0;
          this.args.ySpeed += drawY * 0.5 - Math.random() / 10 || 0;
          if (Math.abs(this.args.xSpeed) > 6) {
            this.args.xSpeed = 4 * drawX;
          }
          if (Math.abs(this.args.ySpeed) > 8) {
            this.args.ySpeed = 4 * drawY;
          }
          if (this.bMap('checkBelow', this.x, this.y).get(_Platformer.Platformer)) {
            this.args.falling = true;
            this.args.ySpeed = -1;
            this.args.y -= 1;
          }
          break;
        }
    }

    // if(!this.args.ySpeed)
    // {
    // 	this.args.y -= 2;
    // }

    this.args.facing = this.args.xSpeed > 0 ? 'left' : 'right';
    this.args.float = -1;
  }
  get solid() {
    return false;
  }
  get rotateLock() {
    return true;
  }
}
exports.DrainFly = DrainFly;
});

;require.register("actor/DrillCar.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DrillCar = void 0;
var _Vehicle = require("./Vehicle");
var _Tag = require("curvature/base/Tag");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class DrillCar extends _Vehicle.Vehicle {
  constructor() {
    super(...arguments);
    _defineProperty(this, "instructions", ['Jump ⓿', 'Fly ⓿+⓿']);
    this.args.type = 'actor-item actor-drill-car';
    this.args.width = 38;
    this.args.height = 48;
    this.removeTimer = null;
    this.args.gSpeedMax = 26;
    this.args.decel = 0.30;
    this.args.accel = 0.75;
    this.args.seatHeight = 34;
    this.args.skidTraction = 0.95;
    this.dustCount = 0;
    this.args.particleScale = 2;
  }
  onRendered(event) {
    super.onRendered(event);
    this.box = this.findTag('div');
    this.sprite = this.findTag('div.sprite');
    this.backSprite = new _Tag.Tag('<div class = "sprite-back sprite">');
    this.drill = new _Tag.Tag('<div class = "drill-car-drill">');
    this.seat = new _Tag.Tag('<div class = "drill-car-seat">');
    this.windsheild = new _Tag.Tag('<div class = "drill-car-windsheild">');
    this.copterCap = new _Tag.Tag('<div class = "drill-car-copter-cap">');
    this.copterBladeA = new _Tag.Tag('<div class = "drill-car-copter-blade-a">');
    this.copterBladeB = new _Tag.Tag('<div class = "drill-car-copter-blade-b">');
    this.frontWheelA = new _Tag.Tag('<div class = "drill-car-tire drill-car-tire-front-a">');
    this.frontWheelB = new _Tag.Tag('<div class = "drill-car-tire drill-car-tire-front-b">');
    this.backWheelA = new _Tag.Tag('<div class = "drill-car-tire drill-car-tire-back-a">');
    this.backWheelB = new _Tag.Tag('<div class = "drill-car-tire drill-car-tire-back-b">');
    this.sprite.appendChild(this.drill.node);
    this.backSprite.appendChild(this.copterCap.node);
    this.backSprite.appendChild(this.copterBladeA.node);
    this.backSprite.appendChild(this.copterBladeB.node);
    this.sprite.appendChild(this.windsheild.node);
    this.backSprite.appendChild(this.seat.node);
    this.sprite.appendChild(this.frontWheelA.node);
    this.backSprite.appendChild(this.frontWheelB.node);
    this.sprite.appendChild(this.backWheelA.node);
    this.backSprite.appendChild(this.backWheelB.node);
    this.box.appendChild(this.backSprite.node);
  }
  update() {
    const falling = this.args.falling;
    if (this.viewport.args.audio && !this.flyingSound) {
      this.flyingSound = new Audio('/Sonic/drill-car-copter.wav');
      this.flyingSound.volume = 0.35 + Math.random() * -0.2;
      this.flyingSound.loop = true;
    }
    if (this.flyingSound) {
      if (!this.flyingSound.paused) {
        this.flyingSound.volume = 0.25 + Math.random() * -0.2;
      }
      if (this.flyingSound.currentTime > 0.2) {
        this.flyingSound.currentTime = 0.0;
      }
    }
    if (!this.box) {
      super.update();
      return;
    }
    if (!falling) {
      this.flyingSound && this.flyingSound.pause();
      const direction = this.args.direction;
      const gSpeed = this.args.gSpeed;
      const speed = Math.abs(gSpeed);
      const maxSpeed = this.args.gSpeedMax;
      if (this.dustCount > 0) {
        this.dustCount--;
      }
      if (Math.sign(this.args.gSpeed) !== direction && Math.abs(this.args.gSpeed - direction) > 5) {
        this.box.setAttribute('data-animation', 'skidding');
        const viewport = this.viewport;
        const particleA = new _Tag.Tag('<div class = "particle-dust">');
        const pointA = this.rotatePoint(this.args.gSpeed, 0);
        particleA.style({
          '--x': pointA[0] + this.x,
          '--y': pointA[1] + this.y,
          'z-index': 0,
          opacity: Math.random() * 2
        });
        const particleB = new _Tag.Tag('<div class = "particle-dust">');
        const pointB = this.rotatePoint(this.args.gSpeed + 40 * this.args.direction, 0);
        particleB.style({
          '--x': pointB[0] + this.x,
          '--y': pointB[1] + this.y,
          'z-index': 0,
          opacity: Math.random() * 2
        });
        viewport.particles.add(particleA);
        viewport.particles.add(particleB);
        setTimeout(() => {
          viewport.particles.remove(particleA);
          viewport.particles.remove(particleB);
        }, 350);
      } else if (this.args.moving && speed > maxSpeed * 0.75) {
        this.box.setAttribute('data-animation', 'running');
      } else if (this.args.moving && speed) {
        this.box.setAttribute('data-animation', 'walking');
      } else {
        this.box.setAttribute('data-animation', 'standing');
      }
    } else if (this.args.flying) {
      this.box.setAttribute('data-animation', 'flying');
    } else if (this.args.falling) {
      this.flyingSound && this.flyingSound.pause();
      this.box.setAttribute('data-animation', 'jumping');
    }
    if (this.args.copterCoolDown == 0) {
      if (this.args.ySpeed > 5) {
        this.flyingSound && this.flyingSound.pause();
        this.args.flying = false;
      }
    } else if (this.args.copterCoolDown > 0) {
      this.args.copterCoolDown--;
    }
    super.update();
  }
  command_0() {
    if (!this.args.falling) {
      this.args.copterCoolDown = 15;
      super.command_0();
      return;
    }
    if (this.args.copterCoolDown > 0) {
      return;
    }
    if (this.args.ySpeed > -16) {
      if (!this.args.flying) {
        this.flyingSound && this.flyingSound.play();
      }
      this.args.flying = true;
      if (this.args.copterCoolDown == 0) {
        this.args.copterCoolDown = 7;
      }
      this.args.ySpeed = -1;
      this.args.ySpeed = -4;
      this.args.float = 8;
    }
  }
  sleep() {
    this.flyingSound && this.flyingSound.pause();
  }
  get solid() {
    return !this.occupant;
  }
}
exports.DrillCar = DrillCar;
});

;require.register("actor/DropCage.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DropCage = void 0;
var _PointActor = require("./PointActor");
class DropCage extends _PointActor.PointActor {
  constructor() {
    super(...arguments);
    this.args.width = 48;
    this.args.height = 40;
    this.args.type = 'actor-item actor-drop-cage';
    this.args.float = -1;
    this.holding = false;
  }
  collideA(other, type) {
    if (this.holding || !other.controllable) {
      return false;
    }
    if (this.ignores.has(other)) {
      this.ignores.set(other, 60);
      return false;
    }
    if (type === -1 || type % 2 === 0) {
      const xDiff = Math.abs(other.args.x - this.args.x);
      other.args.xSpeed = 0;
      this.holding = other;
      other.args.ySpeed = 0;
      other.args.float = -1;
      other.args.ignore = -1;
      this.dropDelay(other).then(() => {
        other.args.float = 0;
        other.args.ignore = 5;
        this.ignores.set(other, 60);
        this.holding = false;
      });
      return false;
    }
    return true;
  }
  dropDelay(other) {
    let waitFor = false;
    if (this.args.waitFor) {
      waitFor = this.viewport.actorsById[this.args.waitFor];
    }
    if (!waitFor) {
      return new Promise(accept => this.viewport.onFrameOut(30, () => accept()));
    }
    return waitFor.dropDelay(other);
  }
  update() {
    super.update();
    if (this.holding) {
      const other = this.holding;
      const toX = this.x;
      const toY = -6 + this.y;
      const stepX = (toX + -other.args.x) / 3;
      const stepY = (toY + -other.args.y) / 3;
      if (Math.abs(other.args.x - toX) < 0.1) {
        other.args.x = toX;
        if (Math.abs(other.args.y - toY) < 0.1) {
          other.args.y = toY;
        } else {
          other.args.y += stepY;
        }
      } else {
        other.args.x += stepX;
      }
    }
  }
  get solid() {
    return !this.holding && !this.ignores.size;
  }
}
exports.DropCage = DropCage;
});

;require.register("actor/DropTarget.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DropTarget = void 0;
var _Sfx = require("../audio/Sfx");
var _PointActor = require("./PointActor");
class DropTarget extends _PointActor.PointActor {
  constructor() {
    super(...arguments);
    this.args.width = 48;
    this.args.height = this.args.height || 12;
    this.args.type = 'actor-item actor-drop-target';
    this.args.float = -1;
    this.args.z = 0;
    this.args.hits = 0;
  }
  onRendered(event) {
    super.onRendered(event);
    this.autoStyle.get(this.box)['--hits'] = 'hits';
  }
  collideA(other) {
    if (other.args.static || other.isRegion || this.ignores.has(other) || other.noClip) {
      return;
    }
    if (other.args.float || other.args.ySpeed <= 0) {
      return;
    }
    this.ignores.set(other, 8);
    other.args.ySpeed = -10;
    this.args.hits++;
    _Sfx.Sfx.play('PAD_BOUNCE');
    if (this.args.hits > 2) {
      this.viewport.actors.remove(this);
    }
  }
  get solid() {
    return false;
  }
}
exports.DropTarget = DropTarget;
false;
});

;require.register("actor/Egg.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Egg = void 0;
var _Png = require("../sprite/Png");
var _PointActor = require("./PointActor");
var _Platformer = require("../behavior/Platformer");
var _EggShellTop = require("./EggShellTop");
var _Chao = require("./Chao");
// import { Bindable } from 'curvature/base/Bindable';

class Egg extends _PointActor.PointActor {
  constructor() {
    super(...arguments);
    this.args.type = 'actor-item actor-egg';
    this.args.shell = 'normal';
    this.args.bindTo('shell', v => {
      switch (v) {
        case 'flat':
        case 'normal':
          this.args.spriteSheet = `/DBurraki/chao-egg-${v}.png`;
          break;
        default:
          this.args.spriteSheet = `/DBurraki/chao-egg-normal.png`;
          break;
      }
      this.png = new _Png.Png(this.args.spriteSheet);
    });
    this.args.width = 15;
    this.args.height = 20;
    this.broken = false;

    // this.defaultChaoColors = ['addef8', '2ebee9', '0e6d89', 'ecde2f', 'dcb936', '985000', 'f8b0c0', 'f85080', 'e4e0e4', 'e0e0e0', 'f8f820', '606080', 'e2e0e2'];

    this.customChaoColors = [null, null, null, null, null, null, null, null, null, null, null, null, null];
    const colorMap = [12, 0, 1, 2];
    this.defaultColors = ['e2e0e2', 'addef8', '2ebee9', '0e6d89'];
    this.customColors = [null, null, null, null];
    this.customColors.bindTo(() => {
      const colorMap = {};
      for (const i in this.defaultColors) {
        var _this$customColors$i;
        colorMap[this.defaultColors[i]] = (_this$customColors$i = this.customColors[i]) !== null && _this$customColors$i !== void 0 ? _this$customColors$i : this.defaultColors[i];
      }
      this.png.ready.then(() => {
        const customSheet = this.png.recolor(colorMap).toUrl();
        this.args.spriteSheet = customSheet;
      });
    }, {
      wait: 0
    });
    this.customChaoColors.bindTo((v, k) => {
      k = Number(k);
      if (!colorMap.includes(k)) {
        return;
      }
      const shellColorKey = colorMap.indexOf(k);
      this.customColors[shellColorKey] = v;
      if (v !== null) {
        this.args.shell = 'flat';
      }
    });
    const colorSelection = [[null, null, null, null, null, null, null, null, null, null, null, null, null]
    // blue + yellow (normal)
    , [null, null, null, "80e000", "69b700", "487d00", null, null, null, null, null, null, null]
    // blue + green
    , ["485070", "303058", "202020", null, null, null, null, null, null, null, null, "202020", "5f6994"]
    // black + yellow
    , ["e4e0e4", "c0bde4", "9c99c0", null, null, null, null, null, null, null, null, null, "e4e0e4"]
    // white + yellow
    , ["e4e0e4", "c0bde4", "9c99c0", "addef8", "2ebee9", "0e6d89", null, null, null, null, null, null, "e4e0e4"]
    // white + blue
    , ["485070", "303058", "202020", "b70000", "770000", "420000", null, null, null, null, "bf999c", "202020", "5f6994"]
    // black + red
    , ["ff7575", "e00000", "800000", "b70000", "770000", "420000", null, null, null, null, null, "202020", "ffaeae"]
    // ruby
    , ["ffc20e", "dd8604", "ad4d05", "b44800", "844221", "630000", null, null, null, null, null, "202020", "fae3af"]
    // tangy
    , ["80e000", "69b700", "487d00", "48b400", "428421", "006300", null, null, null, null, null, "202020", "cef00f"]
    // lime
    , ["485070", "303058", "202020", "c0bde4", "9c99c0", "606080", null, null, null, null, "9c99c0", "202020", "5f6994"]
    // black + white
    , ["c0bde4", "9c99c0", "606080", "485070", "303058", "202020", null, null, null, null, "9c99c0", "202020", "e4e0e4"]
    // white + black
    , ["c0bde4", "9c99c0", "606080", "e4e0e4", "c0bde4", "9c99c0", null, null, null, null, "9c99c0", "202020", "e4e0e4"]
    // white + white
    ];

    Object.assign(this.customChaoColors, colorSelection[Math.trunc(Math.random() * (-1 + colorSelection.length))]);
    this.args.bindTo('falling', falling => {
      const impact = this.ySpeedLast;
      if (falling || this.broken || impact < 12) {
        return;
      }
      ;
      this.hatch();
    });
    this.bindTo('carriedBy', carrier => {
      if (this.cX) {
        this.cX();
        this.cX = null;
      }
      if (this.cY) {
        this.cY();
        this.cY = null;
      }
      if (carrier) {
        this.cX = carrier.args.bindTo('x', v => this.args.x = v + carrier.args.direction * 12);
        this.cY = carrier.args.bindTo('y', v => this.args.y = v + -12);
        carrier.carrying.add(this);
        this.args.standingOn = null;
        this.args.falling = true;
        this.args.float = -1;
        this.args.groundAngle = 0;
      } else if (this.carriedBy) {
        const carrier = this.carriedBy;
        this.carriedBy = null;
        this.args.xSpeed = carrier.args.xSpeed;
        this.args.ySpeed = carrier.args.ySpeed;
        this.args.xSpeed += Math.sign(carrier.args.gSpeed || carrier.args.xSpeed) * 4;
        this.args.ySpeed -= 4;
        this.args.xSpeed += carrier.xAxis * 2;
        carrier.carrying.delete(this);
        this.args.falling = true;
        this.args.float = 0;
        this.args.groundAngle = 0;
      }
    });
  }
  onRendered(event) {
    super.onRendered(event);
    this.setAutoAttr('shell', 'data-shell');
  }
  lift(actor) {
    if (this.carriedBy === actor) {
      this.carriedBy = null;
      return;
    }
    this.carriedBy = actor;
  }
  sleep() {
    if (!this.broken) {
      return;
    }
    this.viewport.actors.remove(this);
  }
  hatch() {
    const impact = this.ySpeedLast;
    this.args.type = 'actor-item actor-egg actor-egg-shell-bottom';
    const shellTop = new _EggShellTop.EggShellTop({
      spriteSheet: this.args.spriteSheet,
      xSpeed: this.xSpeedLast * 0.6,
      ySpeed: -impact * 0.4,
      x: this.x,
      y: this.y - 10
    });
    const chao = new _Chao.Chao({
      currentState: 'hatching',
      xSpeed: this.xSpeedLast * 0.4,
      ySpeed: -impact * 0.4,
      x: this.x,
      y: this.y - 10
    });
    this.args.gSpeed = this.xSpeedLast * 0.2;
    this.viewport.spawn.add({
      object: shellTop
    });
    this.viewport.spawn.add({
      object: chao
    });
    Object.assign(chao.customColors, this.customChaoColors);
    Object.assign(chao.traits, {
      appetite: Math.random(),
      sociable: Math.random(),
      restless: Math.random()
    });
    chao.mood.hunger = 0.8;
    this.broken = true;
  }
  updateStart() {
    // if(this.args.static)
    // {
    // 	this.args.static = !!this.bMap('checkBelow', this.x, this.y + 1).get(Platformer);
    // }
    // else
    // {
    // 	this.args.static = !this.args.falling;
    // }

    // if(this.args.gSpeed || this.args.xSpeed)
    // {
    // 	this.args.static = false;
    // }

    super.updateStart();
  }
  update() {
    if (this.broken && !this.carriedBy) {
      this.args.startFrame = this.args.startFrame || this.viewport.args.frameId;
      if (this.viewport.args.frameId - this.args.startFrame > 120) {
        this.viewport.actors.remove(this);
        return;
      }
    }
    super.update();
  }
  get rotateLock() {
    return true;
  }
  get solid() {
    return false;
  }
}
exports.Egg = Egg;
});

;require.register("actor/EggCapsule.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EggCapsule = void 0;
var _PointActor = require("./PointActor");
var _Sfx = require("../audio/Sfx");
var _Bgm = require("../audio/Bgm");
var _Tag = require("curvature/base/Tag");
class EggCapsule extends _PointActor.PointActor {
  constructor() {
    super(...arguments);
    this.args.width = 64;
    this.args.height = 69;
    this.args.type = 'actor-item actor-egg-capsule';
    this.args.gravity = 0.4;
    this.args.bindTo('falling', v => {
      if (!v) this.viewport.args.shakeY = 7;
    });
    this.triggered = false;
  }
  collideA(other, type) {
    if (this.args.falling) {
      other.startle(this);
      return true;
    }
    if (!other.controllable || type !== 0) {
      return true;
    }
    if (this.triggered) {
      other.args.x += 0.1 * Math.sign(this.args.x - other.args.x);
      other.args.gSpeed = 0;
      this.args.active = true;
      return true;
    } else if (this.groundTime > 15 && type === 0 && !this.triggered) {
      other.args.ignore = 200;
      _Sfx.Sfx.play('WTF_BOOM');
      _Bgm.Bgm.fadeOut(1500);
      this.viewport.onFrameOut(107, () => {
        const explosionTag = document.createElement('div');
        explosionTag.classList.add('particle-huge-explosion');
        const explosion = new _Tag.Tag(explosionTag);
        this.viewport.controlActor.screenLock = null;
        explosion.style({
          '--x': this.args.x,
          '--y': this.args.y
        });
        this.viewport.particles.add(explosion);
        this.viewport.onFrameOut(15, () => this.viewport.particles.remove(explosion));
      });
      this.viewport.onFrameOut(240, () => this.triggered = false);
      this.viewport.onFrameOut(117, () => other.args.ySpeed = -65);
      this.viewport.onFrameOut(115, () => other.startle(this));
      this.triggered = true;
      return true;
    }
    return true;
  }
  get solid() {
    return this.groundTime > 15;
  }
}
exports.EggCapsule = EggCapsule;
});

;require.register("actor/EggMobile.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EggMobile = void 0;
var _Vehicle = require("./Vehicle");
var _Platformer = require("../behavior/Platformer");
class EggMobile extends _Vehicle.Vehicle {
  constructor() {
    super(...arguments);
    this.args.type = 'actor-item actor-vehicle actor-eggmobile';
    this.args.accel = 0.15;
    this.args.decel = 0.8;
    this.args.gSpeedMax = 15;
    this.args.xSpeedMax = 45;
    this.args.ySpeedMax = 45;
    this.args.jumpForce = 12;
    this.args.gravity = 0.6;
    this.args.width = 28;
    this.args.height = 20;
    this.args.yMargin = 42;
    this.args.falling = true;
    this.args.flying = true;
    this.args.float = -1;
  }
  update() {
    if (this.bMap('checkBelow', this.x, this.y).get(_Platformer.Platformer)) {
      this.args.y--;
    }
    if (Math.abs(this.yAxis) > 0.5) {
      if (Math.abs(this.args.ySpeed) < this.args.ySpeedMax) {
        let ySpeed = this.args.ySpeed;
        if (Math.sign(this.yAxis) === Math.sign(this.args.ySpeed)) {
          ySpeed += this.yAxis * this.args.accel * 3;
        } else {
          ySpeed += this.yAxis * this.args.accel * 6;
        }
        if (Math.abs(ySpeed) < 0.1) {
          ySpeed = 0;
        } else if (Math.abs(ySpeed) > 4) {
          ySpeed = 4 * Math.sign(ySpeed);
        }
        this.args.ySpeed = ySpeed;
      }
    } else {
      this.args.ySpeed = this.args.ySpeed * this.args.decel;
    }
    if (!this.xAxis) {
      if (Math.abs(this.args.xSpeed) <= 1) {
        this.args.xSpeed = 0;
      }
      if (this.args.xSpeed > 0) {
        this.args.xSpeed = Math.floor(this.args.xSpeed * this.args.decel);
      } else {
        this.args.xSpeed = Math.ceil(this.args.xSpeed * this.args.decel);
      }
    }
    // else
    // {
    // 	this.args.xSpeed = Math.ceil(this.args.xSpeed * this.args.decel);
    // }

    if (!this.occupant) {
      this.args.xSpeed = 0;
      this.args.ySpeed = 0;
    }
    this.args.falling = true;
    this.args.flying = true;
    this.args.mode = 0;
    this.args.cameraMode = 'aerial';
    super.update();
  }
  command_4() {
    this.args.direction = -1;
    this.args.facing = 'left';
  }
  command_5() {
    this.args.direction = 1;
    this.args.facing = 'right';
  }
  get solid() {
    return !this.occupant;
  }
}
exports.EggMobile = EggMobile;
});

;require.register("actor/EggShellBottom.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EggShellBottom = void 0;
var _PointActor = require("./PointActor");
class EggShellBottom extends _PointActor.PointActor {
  constructor() {
    super(...arguments);
    this.args.type = 'actor-item actor-egg-shell-bottom';
    this.args.width = 15;
    this.args.height = 20;

    // this.bindTo('carriedBy', carrier => {
    // 	if(this.cX) { this.cX(); this.cX = null; }
    // 	if(this.cY) { this.cY(); this.cY = null; }
    // 	if(carrier)
    // 	{
    // 		this.cX = carrier.args.bindTo('x', v => this.args.x = v + carrier.args.direction * 12);
    // 		this.cY = carrier.args.bindTo('y', v => this.args.y = v + -12);

    // 		carrier.carrying.add(this);

    // 		this.args.float = -1;
    // 	}
    // 	else if(this.carriedBy)
    // 	{
    // 		const carrier = this.carriedBy;

    // 		this.carriedBy = null;

    // 		this.args.xSpeed = carrier.args.xSpeed;
    // 		this.args.ySpeed = carrier.args.ySpeed;

    // 		this.args.xSpeed += Math.sign(carrier.args.gSpeed || carrier.args.xSpeed) * 4;
    // 		this.args.ySpeed -= 4;

    // 		carrier.carrying.delete(this);

    // 		this.args.falling = true;
    // 		this.args.float = 0;
    // 	}
    // });
  }

  update() {
    this.args.startFrame = this.args.startFrame || this.viewport.args.frameId;
    if (this.viewport.args.frameId - this.args.startFrame > 45) {
      this.viewport.actors.remove(this);
      return;
    }
    super.update();
  }

  // lift(actor)
  // {
  // 	if(this.carriedBy === actor)
  // 	{
  // 		this.carriedBy = null;

  // 		return;
  // 	}

  // 	this.carriedBy = actor;
  // }

  get solid() {
    return false;
  }
  sleep() {
    this.viewport.actors.remove(this);
    console.log(this);
  }
}
exports.EggShellBottom = EggShellBottom;
});

;require.register("actor/EggShellTop.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EggShellTop = void 0;
var _PointActor = require("./PointActor");
class EggShellTop extends _PointActor.PointActor {
  constructor() {
    super(...arguments);
    this.args.type = 'actor-item actor-egg-shell-top';
    this.args.width = 15;
    this.args.height = 20;

    // this.bindTo('carriedBy', carrier => {
    // 	if(this.cX) { this.cX(); this.cX = null; }
    // 	if(this.cY) { this.cY(); this.cY = null; }
    // 	if(carrier)
    // 	{
    // 		this.cX = carrier.args.bindTo('x', v => this.args.x = v + carrier.args.direction * 12);
    // 		this.cY = carrier.args.bindTo('y', v => this.args.y = v + -12);

    // 		carrier.carrying.add(this);

    // 		this.args.float = -1;
    // 	}
    // 	else if(this.carriedBy)
    // 	{
    // 		const carrier = this.carriedBy;

    // 		this.carriedBy = null;

    // 		this.args.xSpeed = carrier.args.xSpeed;
    // 		this.args.ySpeed = carrier.args.ySpeed;

    // 		this.args.xSpeed += Math.sign(carrier.args.gSpeed || carrier.args.xSpeed) * 4;
    // 		this.args.ySpeed -= 4;

    // 		carrier.carrying.delete(this);

    // 		this.args.falling = true;
    // 		this.args.float = 0;
    // 	}
    // });
  }

  update() {
    this.args.startFrame = this.args.startFrame || this.viewport.args.frameId;
    if (this.viewport.args.frameId - this.args.startFrame > 90) {
      this.viewport.actors.remove(this);
      return;
    }
    super.update();
  }

  // lift(actor)
  // {
  // 	if(this.carriedBy === actor)
  // 	{
  // 		this.carriedBy = null;

  // 		return;
  // 	}

  // 	this.carriedBy = actor;
  // }

  get solid() {
    return false;
  }
  sleep() {
    this.viewport.actors.remove(this);
  }
}
exports.EggShellTop = EggShellTop;
});

;require.register("actor/EggShuttle.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EggShuttle = void 0;
var _Tag = require("curvature/base/Tag");
var _Vehicle = require("./Vehicle");
class EggShuttle extends _Vehicle.Vehicle {
  constructor() {
    super(...arguments);
    this.args.type = 'actor-item actor-vehicle actor-egg-shuttle';
    this.args.accel = 0.15;
    this.args.decel = 0.8;
    this.args.gSpeedMax = 15;
    this.args.xSpeedMax = 15;
    this.args.ySpeedMax = 15;
    this.args.jumpForce = 3;
    this.args.gravity = 0.6;
    this.args.width = 96;
    this.args.height = 308;
    this.args.yMargin = 42;
    this.args.falling = true;
    this.args.flying = true;
    this.args.float = -1;
    this.args.seatHeight = this.args.height - 40;
    this.args.seatForward = -16;
    this.args.seatAngle = Math.PI / 2;
    this.args.thrustAngle = -Math.PI / 2;
    this.args.bindTo('boosting', v => {
      if (!this.boost) {
        return;
      }
      ;
      this.boost.setAttribute('data-active', !!v);
    });
    this.args.crashAngle = 0;
    this.args.bindTo('falling', v => {
      if (Math.abs(this.args.groundAngle) < Math.PI / 4) {
        return;
      }
      this.args.crashAngle = this.args.groundAngle;
    });
  }
  onRendered(event) {
    super.onRendered(event);
    this.autoStyle.get(this.box)['--crash-angle'] = 'crashAngle';
  }
  updateStart() {
    super.updateStart();
    if (this.args.falling) {
      this.args.groundAngle = -(this.args.thrustAngle + Math.PI / 2);
    }
  }
  updateEnd() {
    super.updateEnd();
    if (!this.args.falling) {
      this.args.groundAngle = 0;
    }
    if (this.args.crashAngle) {
      this.args.groundAngle = this.args.crashAngle;
      if (this.occupant) {
        const occupant = this.occupant;
        occupant.args.standingOn = false;
        occupant.args.falling = true;
        occupant.args.xSpeed = Math.sign(this.xSpeedLast) * 2;
        occupant.args.ySpeed = -12;
        occupant.args.y += -12;
      }
    }
  }
  update() {
    if (this.sprite && !this.windshield) {
      this.windshield = new _Tag.Tag('<div class = "shuttle-windshield">');
      this.boost = new _Tag.Tag('<div class = "shuttle-boost">');
      this.sprite.appendChild(this.windshield.node);
      this.sprite.appendChild(this.boost.node);
    }
    if (this.occupant) {
      this.args.type = 'actor-item actor-vehicle actor-egg-shuttle actor-egg-shuttle-occupied';
      this.args.float = 1;
    } else {
      this.args.type = 'actor-item actor-vehicle actor-egg-shuttle';
      this.args.float = 0;
    }
    this.args.gSpeed = 0;
    this.args.facing = 'right';
    super.update();
    if (this.args.falling) {
      this.args.cameraMode = 'rocket';

      // const maxBias = 0.06125;
      // this.args.cameraBias = Math.max(-maxBias, Math.min(maxBias, (this.args.ySpeed / this.args.ySpeedMax) * -maxBias));
      // console.log(this.args.cameraBias);

      this.args.thrustAngle += 0.02 * this.xAxis;
      if (this.args.thrustAngle < -Math.PI * 7 / 8) {
        this.args.thrustAngle = -Math.PI * 7 / 8;
      }
      if (this.args.thrustAngle > -Math.PI * 1 / 8) {
        this.args.thrustAngle = -Math.PI * 1 / 8;
      }
    } else {
      this.args.cameraMode = 'normal';
      this.args.cameraBias = 0;
      this.args.boosting = false;
      this.args.thrustAngle = -Math.PI / 2;
    }
  }
  processInputDirect() {}
  command_0(button) {}
  release_0(button) {
    this.args.boosting = false;
  }
  hold_0(button) {
    this.args.x += this.viewport.args.frameId % 2 ? -1 : 1;
    if (!this.args.falling && button.time < 60) {
      return;
    }
    this.args.falling = true;
    const impulse = this.args.gravity * (1 + 0.002 * Math.min(-60 + button.time, 150));
    this.args.xSpeed += impulse * Math.cos(this.args.thrustAngle);
    this.args.ySpeed += impulse * Math.sin(this.args.thrustAngle);
    if (Math.abs(this.args.xSpeed) > this.args.xSpeedMax) {
      this.args.xSpeed = this.args.xSpeedMax * Math.sign(this.args.xSpeed);
    }
    if (Math.abs(this.args.ySpeed) > this.args.ySpeedMax) {
      this.args.ySpeed = this.args.ySpeedMax * Math.sign(this.args.ySpeed);
    }
    this.args.boosting = true;
  }
  collideA(other, type) {
    if (this.args.crashAngle) {
      return false;
    }
    super.collideA(other, type);
  }
  get solid() {
    return !this.args.crashAngle && !this.occupant;
  }
}
exports.EggShuttle = EggShuttle;
});

;require.register("actor/EggTroid.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EggTroid = void 0;
var _PointActor = require("./PointActor");
var _Mixin = require("curvature/base/Mixin");
var _CanPop = require("../mixin/CanPop");
class EggTroid extends _Mixin.Mixin.from(_PointActor.PointActor, _CanPop.CanPop) {
  constructor(args, parent) {
    super(args, parent);
    this.args.type = 'actor-item actor-eggtroid';
    this.args.width = 40;
    this.args.height = 25;
    this.args.float = -1;
    this.args.gravity = 0.5;
    this.args.phase = 'idle';
  }
  update() {
    if (!this.viewport || !this.viewport.actorIsOnScreen(this)) {
      return;
    }
    const viewport = this.viewport;
    if (this.args.animation !== 'diving') {
      this.args.xSpeed = 0.8 * Math.sign(Math.sin(this.age / 60));
    }
    super.update();
    if (!this.viewport) {
      return;
    }
    const mainChar = viewport.controlActor;
    if (!mainChar) {
      this.args.phase = 'idle';
      return;
    }
    this.args.facing = this.args.xSpeed > 0 ? 'left' : 'right';
    this.args.float = -1;
    const downPoint = this.castRayQuick(128, Math.PI / 2, [0, 0], false) || 128;
    if (downPoint) {
      const actors = this.viewport.actorsAtLine(this.args.x, this.args.y, this.args.x, this.args.y + downPoint);
      const actorList = [...actors.keys()];
      if (actors.size && actorList.filter(a => a !== this && a.controllable && !a.args.dead).length) {
        console.log(actorList.filter(a => a !== this && a.controllable));
        this.args.animation = 'diving';
        this.args.xSpeed = 0;
        this.args.ySpeed = 6;
        this.args.float = 0;
      } else {
        // this.args.animation = 'idle';
      }
    }
    if (!this.args.falling) {
      this.pop();
    }
  }
  get solid() {
    return false;
  }
  get rotateLock() {
    return true;
  }
}
exports.EggTroid = EggTroid;
});

;require.register("actor/EggWalker.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EggWalker = void 0;
var _Vehicle = require("./Vehicle");
var _Platformer = require("../behavior/Platformer");
var _Projectile = require("./Projectile");
var _Tag = require("curvature/base/Tag");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class EggWalker extends _Vehicle.Vehicle {
  constructor() {
    super(...arguments);
    _defineProperty(this, "instructions", []);
    this.args.type = 'actor-item actor-egg-walker';
    this.args.width = 32;
    this.args.height = 64;
    this.args.weight = 1500;
    this.removeTimer = null;
    this.args.gSpeedMax = 2.5;
    this.args.decel = 0.05;
    this.args.accel = 0.10;
    this.args.seatHeight = 48;
    this.args.jumpForce = 12;
    this.args.skidTraction = 0.9;
    this.dustCount = 0;
    this.latchBooster = false;
    this.args.particleScale = 2;
    this.args.bindTo('falling', v => {
      if (v || !this.crouching || this.ySpeedLast < 8) {
        return;
      }
      this.viewport.args.shakeY = 7;
    });
  }
  onRendered(event) {
    super.onRendered(event);
    this.box = this.findTag('div');
    this.sprite = this.findTag('div.sprite');
    this.backSprite = new _Tag.Tag('<div class = "sprite-back sprite">');
    this.body = new _Tag.Tag('<div class = "egg-walker-body">');
    this.sprite.appendChild(this.body.node);
    this.punch = new _Tag.Tag('<div class = "egg-walker-punch">');
    this.sprite.appendChild(this.punch.node);
    this.legFront = new _Tag.Tag('<div class = "egg-walker-leg">');
    this.sprite.appendChild(this.legFront.node);
    this.boostFront = new _Tag.Tag('<div class = "egg-boost">');
    this.legFront.appendChild(this.boostFront.node);
    this.legBack = new _Tag.Tag('<div class = "egg-walker-leg egg-walker-leg-back">');
    this.backSprite.appendChild(this.legBack.node);
    this.boostBack = new _Tag.Tag('<div class = "egg-boost">');
    this.legBack.appendChild(this.boostBack.node);
    this.chair = new _Tag.Tag('<div class = "egg-walker-chair">');
    this.backSprite.appendChild(this.chair.node);
    this.gun = new _Tag.Tag('<div class = "egg-walker-gun">');
    this.backSprite.appendChild(this.gun.node);
    this.box.appendChild(this.backSprite.node);
  }
  update() {
    super.update();
    this.args.cameraMode = 'walker';
    if (this.boosting) {
      this.args.type = 'actor-item actor-egg-walker egg-walker-boosting';
      if (this.args.ySpeed > 0) {
        this.args.ySpeed -= (Math.sin(this.viewport.args.frameId / 10) + 0.9) / 2 + 0.5;
      }
    } else {
      this.args.type = 'actor-item actor-egg-walker';
    }
    if (this.yAxis > 0.55) {
      this.latchBooster = false;
    }
    if (!this.latchBooster) {
      this.boosting = false;
    }
    if (this.yAxis > 0.55 && (!this.xAxis || this.falling && this.args.ySpeed > 0)) {
      if (this.crouching) {
        this.args.y += 0.001;
        this.args.y -= 0.001;
      }
      if (this.args.falling && !this.crouching) {
        this.args.ySpeed += 4;
      }
      this.args.gSpeed = 0;
      this.args.animation = 'crouching';
      this.crouching = true;
      this.args.seatHeight = 30;
      this.args.height = 48;
    } else {
      if (!this.crouching) {
        this.args.y += 0.001;
        this.args.y -= 0.001;
      }
      this.crouching = false;
      this.args.seatHeight = 48;
      this.args.height = 64;
      if (this.args.falling) {
        this.args.animation = 'falling';
      } else if (Math.sign(this.args.gSpeed) === this.args.direction) {
        this.args.animation = 'walking';
      } else {
        this.args.animation = 'standing';
      }
    }
  }
  hold_0() {
    const below = this.bMap('checkBelow', this.x, this.y + 1).get(_Platformer.Platformer);
    if (!this.args.falling && this.args.ySpeed < 0 || below) {
      return;
    }
    if (this.yAxis > 0.55) {
      this.latchBooster = false;
      return;
    }
    if (this.yAxis < -0.55) {
      this.latchBooster = true;
    }
    this.boosting = true;
  }
  hold_2() {
    if (this.shooting) {
      return;
    }
    let offset, trajectory, spotAngle;
    const direction = Math.sign(this.args.direction);
    const groundAngle = this.args.groundAngle;
    switch (this.args.mode) {
      case 0:
        spotAngle = -groundAngle - Math.PI / 2 + Math.PI / 4 * direction;
        trajectory = -groundAngle;
        break;
      case 1:
        spotAngle = -groundAngle + Math.PI / 4 * direction;
        trajectory = -groundAngle + Math.PI / 2;
        break;
      case 2:
        spotAngle = -groundAngle + Math.PI / 2 + Math.PI / 4 * direction;
        trajectory = -groundAngle - Math.PI;
        break;
      case 3:
        spotAngle = -groundAngle - Math.PI + Math.PI / 4 * direction;
        trajectory = -groundAngle - Math.PI / 2;
        break;
    }
    offset = [32 * Math.cos(spotAngle), 120 * Math.sin(spotAngle)];

    // if(this.args.falling || this.args.crouching)
    // {
    // 	trajectory = 0;
    // 	offset = [-16 * direction, -96];
    // }

    const projectile = new _Projectile.Projectile({
      direction: this.args.direction,
      x: this.args.x + offset[0] + (this.args.xSpeed || this.args.gSpeed),
      y: this.args.y + offset[1] - (this.crouching ? -20 : 0),
      owner: this,
      xSpeed: this.args.xSpeed || this.args.gSpeed || this.args.direction
      // , ySpeed: this.args.ySpeed
      ,
      float: 0,
      strength: 2
    });
    if (!this.crouching) {
      projectile.impulse(4, trajectory + (direction < 0 ? Math.PI : 0), true);
      projectile.args.float = 6;
    } else {
      projectile.impulse(2, trajectory + (direction < 0 ? Math.PI : 0), true);
    }
    this.viewport.spawn.add({
      object: projectile
    });
    this.viewport.auras.add(projectile);
    projectile.update();
    this.box.setAttribute('data-shoot', 'true');
    this.shooting = true;
    this.viewport.onFrameOut(1, () => {
      this.box.setAttribute('data-shoot', 'false');
    });
    this.viewport.onFrameOut(6, () => {
      this.shooting = false;
    });
  }
  command_0() {
    this.latchBooster = false;
    if (!this.crouching) {
      super.command_0();
    }
  }
  command_1() {
    if (this.punching) {
      return;
    }
    this.box.setAttribute('data-punch', 'true');
    this.punching = true;
    this.viewport.onFrameOut(12, () => {
      this.box.setAttribute('data-punch', 'false');
    });
    this.viewport.onFrameOut(25, () => {
      this.punching = false;
    });
  }
  command_4() {
    this.args.direction = -1;
    this.args.facing = 'left';
  }
  command_5() {
    this.args.direction = 1;
    this.args.facing = 'right';
  }
  get solid() {
    return !this.occupant;
  }
}
exports.EggWalker = EggWalker;
});

;require.register("actor/Eggman.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Eggman = void 0;
var _PointActor = require("./PointActor");
var _Tag = require("curvature/base/Tag");
var _SkidDust = require("../behavior/SkidDust");
class Eggman extends _PointActor.PointActor {
  static fromDef(objDef) {
    const instance = super.fromDef(objDef);
    instance.args.name = 'Robotnik';
    return instance;
  }
  constructor() {
    super(...arguments);
    this.behaviors.add(new _SkidDust.SkidDust());
    this.args.type = 'actor-item actor-eggman';
    this.accelNormal = 0.12;
    this.accelSuper = 0.30;
    this.args.weight = 200;
    this.args.accel = 0.15;
    this.args.decel = 0.3;
    this.args.normalHeight = 40;
    this.args.rollingHeight = 28;
    this.gSpeedMaxNormal = 18;
    this.gSpeedMaxSuper = 28;
    this.args.gSpeedMax = this.gSpeedMaxNormal;
    this.args.normalHeight = 57;
    this.args.rollingHeight = 29;
    this.jumpForceNormal = 11;
    this.jumpForceSuper = 18;
    this.args.jumpForce = this.jumpForceNormal;
    this.args.gravity = 0.5;
    this.args.width = 18;
    this.args.height = 57;
    this.args.lookingUp = false;
    this.args.spriteSheet = this.spriteSheet = '/Sonic/eggman.png';
    this.superSpriteSheet = '/Sonic/eggman-super.png';
  }
  onRendered(event) {
    super.onRendered(event);
    this.box = this.findTag('div');
  }
  updateStart() {
    if (this.args.grinding && this.args.falling && this.args.ySpeed > 0) {
      this.args.animation = 'airdash';
      this.args.grinding = false;
    }
    super.updateStart();
    if (this.args.dead) {
      this.args.animation = 'dead';
      return;
    }
  }
  update() {
    const falling = this.args.falling;
    if (!this.box) {
      super.update();
      return;
    } else if (this.yAxis > 0.5 && !this.args.ignore) {
      this.args.crouching = true;
      this.args.lookTime--;
      if (this.args.lookTime < -45) {
        // this.args.cameraBias = -0.5;
      }
    } else if (this.yAxis < -0.5 && !this.args.ignore) {
      this.args.lookingUp = true;
      this.args.lookTime++;
      if (this.args.lookTime > 45) {
        // this.args.cameraBias = 0.25;
      }
    } else {
      this.args.lookingUp = this.args.crouching = false;
    }
    const direction = this.args.direction;
    const gSpeed = this.args.gSpeed;
    const speed = Math.abs(gSpeed);
    const maxSpeed = this.args.gSpeedMax;
    if (falling) {
      if (this.args.jumping) {
        this.args.animation = 'jumping';
      }
      this.args.height = this.args.rollingHeight;
    } else if (this.args.rolling) {
      this.args.height = this.args.rollingHeight;
      if (this.args.direction !== Math.sign(this.args.gSpeed)) {
        this.args.direction = Math.sign(this.args.gSpeed);
        if (this.args.direction < 0) {
          this.args.facing = 'left';
        } else {
          this.args.facing = 'right';
        }
      }
      this.args.animation = 'rolling';
    } else {
      this.args.height = this.args.normalHeight;
      if (Math.sign(this.args.gSpeed) !== direction && Math.abs(this.args.gSpeed - direction) > 5) {
        this.args.animation = 'skidding';
      } else if (speed > maxSpeed / 2) {
        this.args.animation = 'running';
      } else if (this.args.moving && gSpeed) {
        this.args.animation = 'walking';
      } else if (this.args.lookingUp) {
        this.args.animation = 'lookingUp';
      } else if (this.args.crouching || this.args.standingOn && this.args.standingOn.isVehicle) {
        this.args.animation = 'crouching';
      } else {
        this.args.animation = 'standing';
      }
    }
    if (this.args.hangingFrom) {
      this.args.animation = 'hanging';
    }
    if (this.args.grinding) {
      this.args.rolling = false;
      if (this.yAxis > 0.5) {
        this.args.animation = 'grinding-crouching';
      } else {
        this.args.animation = 'grinding';
      }
    }
    super.update();
  }
  command_3() {
    this.isSuper = !this.isSuper;
    this.onTimeout(150, () => {
      if (this.args.rings === 0) {
        // this.isSuper = false;
        this.setProfile();
      }
      ;
    });
    this.setProfile();
  }
  setProfile() {
    if (this.isSuper) {
      this.args.spriteSheet = this.superSpriteSheet;
      this.args.gSpeedMax = this.gSpeedMaxSuper;
      this.args.jumpForce = this.jumpForceSuper;
      this.args.accel = this.accelSuper;
    } else {
      this.args.spriteSheet = this.spriteSheet;
      this.args.gSpeedMax = this.gSpeedMaxNormal;
      this.args.jumpForce = this.jumpForceNormal;
      this.args.accel = this.accelNormal;
    }
  }
  get solid() {
    return false;
  }
  get canRoll() {
    return true;
  }
  get isEffect() {
    return false;
  }
  get controllable() {
    return true;
  }
}
exports.Eggman = Eggman;
});

;require.register("actor/Eggrobo.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Eggrobo = void 0;
var _PointActor = require("./PointActor");
var _Projectile = require("./Projectile");
var _Tag = require("curvature/base/Tag");
var _SkidDust = require("../behavior/SkidDust");
var _Sfx = require("../audio/Sfx");
class Eggrobo extends _PointActor.PointActor {
  constructor() {
    super(...arguments);
    this.behaviors.add(new _SkidDust.SkidDust());
    this.args.type = 'actor-item actor-eggrobo';
    this.args.accel = 0.125;
    this.args.decel = 0.3;
    this.args.gSpeedMax = 14;
    this.args.jumpForce = 11;
    this.args.gravity = 0.5;
    this.args.width = 18;
    this.args.height = 57;
  }
  onRendered(event) {
    super.onRendered(event);
    this.box = this.findTag('div');
    this.sprite = this.findTag('div.sprite');
    this.flame = new _Tag.Tag('<div class = "eggrobo-flame">');
    this.muzzleFlash = new _Tag.Tag('<div class = "eggrobo-muzzle-flash">');
    this.sprite.appendChild(this.flame.node);
    this.sprite.appendChild(this.muzzleFlash.node);
  }
  update() {
    const falling = this.args.falling;
    if (this.viewport.args.audio && !this.thrusterSound) {
      this.thrusterSound = new Audio('/Sonic/mecha-sonic-thruster.wav');
      this.thrusterSound.loop = true;
    }
    if (this.thrusterSound) {
      if (this.thrusterSound.currentTime > 0.4 + Math.random() / 10) {
        this.thrusterSound.currentTime = 0.05;
      }
      this.thrusterSound.volume = 0.2 + Math.random() * -0.05;
    }
    if (!this.box) {
      super.update();
      return;
    }
    if (!falling) {
      if (this.yAxis > 0) {
        this.args.crouching = true;
      } else {
        this.args.crouching = false;
      }
      const direction = this.args.direction;
      const gSpeed = this.args.gSpeed;
      const speed = Math.abs(gSpeed);
      const maxSpeed = this.args.gSpeedMax;
      if (Math.sign(this.args.gSpeed) !== direction && Math.abs(this.args.gSpeed - direction) > 5) {
        this.thrusterSound && this.thrusterSound.pause();
        this.box.setAttribute('data-animation', 'skidding');
      } else if (speed > maxSpeed / 2) {
        this.thrusterSound && this.thrusterSound.pause();
        this.box.setAttribute('data-animation', 'running');
      } else if (this.args.moving && gSpeed) {
        this.box.setAttribute('data-animation', 'walking');
      } else if (this.args.crouching || this.standingOn && this.standingOn.isVehicle) {
        this.box.setAttribute('data-animation', 'crouching');
      } else {
        this.box.setAttribute('data-animation', 'standing');
      }
    } else {
      this.args.crouching = false;
      if (this.args.jumping) {
        this.box.setAttribute('data-animation', 'jumping');
      }
    }
    if (!this.args.falling) {
      this.args.flying = false;
    }
    if (this.args.flying) {
      this.box.setAttribute('data-animation', 'flying');
    } else if (this.args.falling) {
      this.box.setAttribute('data-animation', 'jumping');
    }
    if (this.args.shotCoolDown > 0) {
      this.args.shotCoolDown--;
    }
    if (this.args.rocketCoolDown == 0) {
      this.thrusterSound && this.thrusterSound.pause();
    }
    if (this.args.rocketCoolDown > 0) {
      this.args.rocketCoolDown--;
    }
    if (this.args.rocketCoolDown == 0) {
      this.args.flying = false;
    }
    super.update();
  }
  get solid() {
    return true;
  }
  get isEffect() {
    return false;
  }
  hold_0() {
    if (!this.args.falling) {
      this.args.rocketCoolDown = 5;
      return;
    }
    if (this.args.ySpeed > 1 || this.args.flying) {
      this.args.flying = true;
      if (this.args.rocketCoolDown <= 1) {
        this.thrusterSound && this.thrusterSound.play();
        this.args.rocketCoolDown = 3;
      }
      this.args.ySpeed = this.args.ySpeed * 0.999;
      this.args.float = 3;
    }
  }
  hold_2() {
    if (this.args.shotCoolDown > 0) {
      return;
    }
    const direction = Math.sign(this.args.direction);
    const groundAngle = this.args.groundAngle;
    let offset, trajectory, spotAngle;
    switch (this.args.mode) {
      case 0:
        spotAngle = -groundAngle - Math.PI / 2 + Math.PI / 4 * direction;
        trajectory = -groundAngle;
        break;
      case 1:
        spotAngle = -groundAngle + Math.PI / 4 * direction;
        trajectory = -groundAngle + Math.PI / 2;
        break;
      case 2:
        spotAngle = -groundAngle + Math.PI / 2 + Math.PI / 4 * direction;
        trajectory = -groundAngle - Math.PI;
        break;
      case 3:
        spotAngle = -groundAngle - Math.PI + Math.PI / 4 * direction;
        trajectory = -groundAngle - Math.PI / 2;
        break;
    }
    offset = [50 * Math.cos(spotAngle), 50 * Math.sin(spotAngle)];
    if (this.args.falling || this.args.crouching) {
      trajectory = 0;
      offset = [26 * direction, -26];
    }
    const projectile = new _Projectile.Projectile({
      direction: this.args.direction,
      x: this.args.x + offset[0] + (this.args.xSpeed || this.args.gSpeed),
      y: this.args.y + offset[1],
      owner: this,
      xSpeed: this.args.xSpeed || this.args.gSpeed,
      YSpeed: this.args.YSpeed
    });
    projectile.impulse(20, trajectory + (direction < 0 ? Math.PI : 0), true);
    projectile.update();
    this.viewport.auras.add(projectile);
    this.viewport.spawn.add({
      object: projectile
    });
    this.box.setAttribute('data-shooting', 'true');
    this.onTimeout(140, () => {
      this.box.setAttribute('data-shooting', 'false');
    });
    _Sfx.Sfx.play('SHOT_FIRED');
    this.args.shotCoolDown = 4;
  }
  get canFly() {
    return true;
  }
  get solid() {
    return false;
  }
  get controllable() {
    return true;
  }
}
exports.Eggrobo = Eggrobo;
});

;require.register("actor/Emblem.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Emblem = void 0;
var _PointActor = require("./PointActor");
var _Tag = require("curvature/base/Tag");
var _Sfx = require("../audio/Sfx");
var _Analytic = require("../lib/Analytic");
class Emblem extends _PointActor.PointActor {
  constructor() {
    var _this$args$character;
    super(...arguments);
    this.args.width = 32;
    this.args.height = 32;
    this.args.type = 'actor-item actor-emblem';
    this.args.float = -1;
    this.args.static = true;
    this.collected = false;
    this.args.character = (_this$args$character = this.args.character) !== null && _this$args$character !== void 0 ? _this$args$character : 'sonic';
  }
  onRendered(event) {
    if (!this.viewport) {
      return super.onRendered(event);
    }
    const zoneState = this.viewport.getZoneState();
    if (zoneState && zoneState.emblems && zoneState.emblems.includes(this.oid)) {
      if (!this.viewport.replay) {
        this.args.type = 'actor-item actor-emblem actor-emblem-collected';
        this.collected = true;
      }
    }
    super.onRendered(event);
    this.autoAttr.get(this.box)['data-character'] = 'character';
  }
  collideA(other) {
    if (!other.controllable || this.gone) {
      return;
    }
    const viewport = this.viewport;
    const zoneState = viewport.getZoneState();
    other.args.emblemsCurrent.push(this);
    if (!this.collected) {
      other.args.emblems.push(this);
      zoneState.emblems.push(this.oid);
      this.args.type = 'actor-item actor-emblem actor-emblem-gone';
    } else {
      this.args.type = 'actor-item actor-emblem actor-emblem-gone actor-emblem-collected';
    }
    const scoreNode = document.createElement('div');
    scoreNode.classList.add('particle-score');
    const scoreTag = new _Tag.Tag(scoreNode);
    scoreTag.style({
      '--x': this.args.x,
      '--y': this.args.y - 16
    });
    let points;
    switch (other.args.emblemsCurrent && other.args.emblemsCurrent.length) {
      case 1:
        scoreNode.classList.add('score-100');
        points = 100;
        break;
      case 2:
        scoreNode.classList.add('score-200');
        points = 200;
        break;
      case 3:
        scoreNode.classList.add('score-500');
        points = 500;
        break;
      case 4:
        scoreNode.classList.add('score-1000');
        points = 1000;
        break;
      case 5:
        scoreNode.classList.add('score-10000');
        points = 10000;
        break;
    }
    viewport.particles.add(scoreTag);
    setTimeout(() => viewport.particles.remove(scoreTag), 768);
    other.args.score += points;
    this.gone = true;
    viewport.onFrameOut(20, () => viewport.actors.remove(this));
    this.viewport.args.inventory.push({
      tallyIcon: '/custom/hud-emblem.png',
      points: 1000,
      id: this.oid
    });
    viewport.currentSave.save();
    if (this.viewport.args.audio) {
      _Sfx.Sfx.play('EMBLEM_COLLECTED');
    }
    if (typeof ga === 'function') {
      _Analytic.Analytic.report({
        eventCategory: 'emblem',
        eventAction: 'collected',
        eventLabel: `${this.viewport.args.actName}::${this.oid}`
      });
    }
  }
}
exports.Emblem = Emblem;
});

;require.register("actor/Emerald.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Emerald = void 0;
var _PointActor = require("./PointActor");
var _Sfx = require("../audio/Sfx");
var _Analytic = require("../lib/Analytic");
class Emerald extends _PointActor.PointActor {
  constructor() {
    super(...arguments);
    this.args.type = 'actor-item actor-emerald emerald-' + (this.args.color || 'white');
    this.args.width = 12;
    this.args.height = 12;
  }

  // update()
  // {
  // 	super.update();

  // 	const viewport = this.viewport;

  // 	if(!viewport)
  // 	{
  // 		return;
  // 	}
  // }

  collideA(other) {
    super.collideA(other);
    if (this.args.gone || !other.controllable) {
      return;
    }
    this.args.type = 'actor-item actor-emerald collected emerald-' + (this.args.color || 'white');
    if (!this.args.gone) {
      _Sfx.Sfx.play('EMERALD_COLLECTED');
      this.args.type = 'actor-item actor-emerald collected gone emerald-' + (this.args.color || 'white');
      if (other.args.owner) {
        other.args.owner.args.emeralds += 1;
      } else if (other.occupant) {
        other.occupant.args.emeralds += 1;
      } else {
        other.args.emeralds += 1;
      }
      if (!this.viewport.args.emeralds.includes(this.args.color)) {
        this.viewport.args.emeralds.push(this.args.color);
      }
      const save = viewport.currentSave;
      if (!save.emeralds.includes(this.args.color)) {
        save.emeralds.push(this.args.color);
      }
      this.viewport.args.inventory.push({
        points: 10000,
        tallyIcon: `/Sonic/emerald-${this.args.color}-mini.png`,
        id: this.oid
      });
      save.save();
      _Analytic.Analytic.report({
        eventCategory: 'chaos-emerald',
        eventAction: 'collected',
        eventLabel: `${this.viewport.args.actName}::${this.args.color}::${this.args.id}`
      });
      this.viewport.actors.remove(this);
      this.remove();
    }
    this.args.gone = true;
  }
  get solid() {
    return false;
  }
  get effect() {
    return true;
  }
}
exports.Emerald = Emerald;
});

;require.register("actor/Explosion.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Explosion = void 0;
var _PointActor = require("./PointActor");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class Explosion extends _PointActor.PointActor {
  constructor() {
    super(...arguments);
    _defineProperty(this, "float", -1);
    this.args.type = 'actor-item actor-explosion';
    this.args.width = 48;
    this.args.height = 48;
    this.removeTimer = null;
  }
  update() {
    super.update();
    if (!this.removeTimer) {
      const viewport = this.viewport;
      this.removeTimer = this.onTimeout(360, () => {
        // viewport.actors.remove( this );
      });
    }
  }
  get solid() {
    return false;
  }
  get isEffect() {
    return false;
  }
}
exports.Explosion = Explosion;
});

;require.register("actor/FakeEmerald.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FakeEmerald = void 0;
var _BreakableBlock = require("./BreakableBlock");
class FakeEmerald extends _BreakableBlock.BreakableBlock {
  constructor() {
    super(...arguments);
    this.args.width = 64;
    this.args.height = 34;
    this.args.type = 'actor-item actor-breakable-block actor-fake-emerald';
    this.args.z = 128;
    this.args.float = -1;
    this.breakable = false;
  }
  updateStart() {}
  update() {
    super.update();
    if (this.switch && this.switch.args.active) {
      this.breakable = true;
    }
  }
  collideA(other, type) {
    if (!this.breakable) {
      return false;
    }
    return super.collideA(other, type);
  }
  get solid() {
    return this.breakable;
  }
}
exports.FakeEmerald = FakeEmerald;
});

;require.register("actor/Fan.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Fan = void 0;
var _PointActor = require("./PointActor");
class Fan extends _PointActor.PointActor {
  constructor() {
    var _this$args$direction;
    super(...arguments);
    this.args.width = 32;
    this.args.height = 32;
    this.args.type = 'actor-item actor-fan';
    this.args.float = -1;
    this.args.direction = (_this$args$direction = this.args.direction) !== null && _this$args$direction !== void 0 ? _this$args$direction : 1;
  }
  get solid() {
    return false;
  }
  update() {
    const actors = this.viewport.actorsAtPoint(this.args.x + 80 * this.args.direction, this.args.y, 160, 64);
    for (const actor of actors) {
      if (!actor.controllable) {
        continue;
      }
      if (Math.abs(actor.args.gSpeed) > 20) {
        actor.args.gSpeed = Math.sign(actor.args.gSpeed) * 20;
      }
      const distance = Math.abs(this.args.x - actor.args.x);
      const force = -20 * Math.min(1, 1 - (distance - 20) / 160) ** 3;
      if (!actor.args.falling) {
        if (actor.xAxis && Math.sign(actor.xAxis) !== this.args.direction && !actor.args.rolling) {
          actor.args.gForce = force;
        } else {
          actor.args.gSpeed += -force * this.args.direction;
          if (Math.abs(actor.args.gSpeed) > 25) {
            actor.args.gSpeed = 25 * this.args.direction;
          }
        }
      } else {
        actor.args.xSpeed += -force * this.args.direction;
        if (Math.abs(actor.args.xSpeed) > 25) {
          actor.args.gSpeed = 25 * this.args.direction;
        }
      }
    }
  }
}
exports.Fan = Fan;
});

;require.register("actor/Flag.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Flag = void 0;
var _PointActor = require("./PointActor");
class Flag extends _PointActor.PointActor {
  constructor() {
    super(...arguments);
    this.args.width = 45;
    this.args.height = 53;
    this.args.type = 'actor-item actor-flag';
    this.args.z = 0;
  }
  get solid() {
    return false;
  }
}
exports.Flag = Flag;
});

;require.register("actor/Flickie.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Flickie = void 0;
var _Follower = require("./Follower");
class Flickie extends _Follower.Follower {
  constructor(args, parent) {
    super(args, parent);
    this.args.type = 'actor-item actor-flickie';
    this.args.palletShift = Math.floor(Math.random() * 8);
  }
}
exports.Flickie = Flickie;
});

;require.register("actor/Flipper.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Flipper = void 0;
var _PointActor = require("./PointActor");
class Flipper extends _PointActor.PointActor {
  constructor(args, parent) {
    var _this$args$power;
    super(args, parent);
    this.args.width = 64;
    this.args.height = 48;
    this.noClip = true;
    this.args.float = -1;
    this.args.direction = this.args.direction || 1;
    this.args.power = (_this$args$power = this.args.power) !== null && _this$args$power !== void 0 ? _this$args$power : 12;
    this.args.type = 'actor-item actor-flipper';
    this.args.bindTo('direction', v => this.args.type = v < 0 ? 'actor-item actor-flipper actor-flipper-right' : 'actor-item actor-flipper actor-flipper-left');
    this.flipped = new WeakSet();
  }
  collideA(other, type) {
    if (other.y <= this.y - this.args.height) {
      return;
    }
    if (this.flipped.has(other)) {
      return;
    }
    const leftBound = this.x - this.args.direction * this.args.width;
    other.args.rolling = true;
    other.willJump = false;

    // if(other.x < leftBound + (this.args.width / 3))
    // {
    // 	other.args.gSpeed = 2;
    // }

    if (other.buttons[0] && other.buttons[0].time === 1) {
      // const rounded = this.roundAngle(-other.args.groundAngle + -Math.PI/2, 16, true);
      const rounded = -other.args.groundAngle + -Math.PI / 2;
      this.args.animation = 'flipping';
      other.args.xSpeed = 0;
      other.args.ySpeed = 0;
      other.args.gSpeed = 0;
      const flipFactor = (other.x - leftBound) / this.args.width * 0.5;
      const flipMagnitude = flipFactor * this.args.direction;
      other.impulse(this.args.power * flipMagnitude, rounded, true);
      const xImpulse = Number(Number(Math.cos(rounded) * 1).toFixed(3));
      const yImpulse = Number(Number(Math.sin(rounded) * 1).toFixed(3));
      other.args.y += -4;
      other.args.xSpeed = xImpulse;
      other.args.ySpeed = yImpulse;
      other.args.falling = true;
      this.viewport.onFrameOut(3, () => this.args.animation = 'unflipping');
      other.args.jumping = false;
      other.args.falling = true;
      this.flipped.add(other);
      this.viewport.onFrameOut(1, () => other.willJump = false);
      this.viewport.onFrameOut(3, () => other.args.jumping = false);
      this.viewport.onFrameOut(5, () => this.flipped.delete(other));
      return;
    }
    if (Math.abs(other.args.gSpeed) < 3) {
      other.args.gSpeed = Math.min(2, Math.abs(other.args.gSpeed) || 1) * Math.sign(other.args.gSpeed || this.args.direction);
    } else {
      other.args.gSpeed *= 0.5;
    }
  }
}
exports.Flipper = Flipper;
});

;require.register("actor/Follower.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Follower = void 0;
var _PointActor = require("./PointActor");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class Follower extends _PointActor.PointActor {
  constructor(args, parent) {
    super(args, parent);
    _defineProperty(this, "noClip", 1);
    this.args.isGhost = true;
    this.args.type = 'actor-item actor-follower';
    this.args.float = -1;
    this.args.width = 16;
    this.args.height = 16;
    this.stopSwapZ = 0;
    this.args.z = -1;
  }
  update() {
    super.update();
    if (this.stopSwapZ > 0) {
      this.stopSwapZ--;
    }
    this.args.standingOn = false;
    const host = this.viewport.controlActor;
    if (!host) {
      return;
    }
    this.args.falling = true;
    this.args.float = -1;
    const force = Math.random();
    let fudge = Math.random();
    const xDiff = host.x + -this.x;
    const yDiff = host.y + -this.y;
    const angle = Math.atan2(yDiff, xDiff);
    const distance = Math.hypot(yDiff, xDiff);
    const maxDistance = 256;
    const minDistance = 64;
    let minSpeed = 1;
    const airSpeed = Math.max(Math.abs(host.args.gSpeed), Math.abs(host.args.xSpeed), Math.abs(host.args.ySpeed), minSpeed) * 1.1;
    const xSpeedRelativeOriginal = this.args.xSpeed - (host.args.xSpeed || host.args.gSpeed);
    let maxSpeed = airSpeed + 3;
    let facing = null;
    if (distance < minDistance) {
      if (Math.abs(this.args.xSpeed) < minSpeed) {
        this.args.xSpeed = minSpeed * Math.sign(-0.5 + Math.random());
      }
      if (Math.abs(this.args.ySpeed) < minSpeed) {
        this.args.ySpeed = minSpeed * Math.sign(-0.5 + Math.random());
      }
    } else if (distance >= maxDistance) {
      this.args.x = Math.floor(host.x - Math.cos(angle) * maxDistance);
      this.args.y = Math.floor(host.y - Math.sin(angle) * maxDistance);
      this.args.xSpeed = xDiff / 60 + (host.args.xSpeed || host.args.gSpeed);
      this.args.ySpeed = 0;
      this.viewport.setColCell(this);
      if (this.x > host.x) {
        facing = 'left';
      } else {
        facing = 'right';
      }
      maxSpeed *= 4;
    } else {}
    const xDir = Math.sign(xDiff);
    const yDir = Math.sign(yDiff);
    const xSame = Math.sign(this.args.xSpeed) === xDir;
    const ySame = this.args.ySpeed && Math.sign(this.args.ySpeed) === yDir;
    const xMag = Math.max(force) * 0.35 * (xSame ? 0.85 : 0.55);
    const yMag = Math.max(force) * 0.10 * (xSame ? 0.75 : 1.50);
    if (!xSame || Math.abs(this.args.xSpeed) < maxSpeed) {
      const step = xMag * xDir * fudge;

      // if(!this.swapZ && this.args.xSpeed && Math.sign(this.args.xSpeed) !== Math.sign(step))
      // {
      // 	this.swapZ = this.viewport.onFrameOut(1, () => {

      // 		this.swapZ = false;
      // 	})
      // }

      let xSpeed = this.args.xSpeed + step;
      if (Math.abs(this.args.xSpeed) > maxSpeed) {
        xSpeed = maxSpeed * Math.sign(this.args.xSpeed);
      }
      this.args.xSpeed = xSpeed;
      if (distance >= maxDistance) {
        const xSpeed = host.args.xSpeed || host.args.gSpeed;
        const ySpeed = host.args.ySpeed;
        if (facing) {
          this.args.xSpeed = xDiff / 90 + xSpeed;
          this.args.ySpeed = yDiff / 90 + ySpeed;
        }
      }
    }
    if (!facing && this.args.xSpeed < 0) {
      facing = 'left';
    } else if (!facing) {
      facing = 'right';
    }
    if (!ySame || Math.abs(this.args.ySpeed) < maxSpeed) {
      let ySpeed = this.args.ySpeed + yMag * yDir;
      if (Math.abs(this.args.ySpeed) > maxSpeed) {
        ySpeed = maxSpeed * Math.sign(this.args.ySpeed);
      }
      this.args.ySpeed = ySpeed;
    }
    if (Math.sign(xSpeedRelativeOriginal) && Math.sign(host.args.xSpeed || host.args.gSpeed) !== Math.sign(xSpeedRelativeOriginal) && this.stopSwapZ === 0) {
      if (Math.abs(this.x - host.x) > minDistance || Math.abs(this.y - host.y) > minDistance) {
        this.args.z = this.args.z > -1000 ? -100000 : 100000;
        this.stopSwapZ = 30;
      }
    }
    if (facing) {
      this.args.facing = facing;
    }
  }
  updateEnd() {
    const host = this.viewport.controlActor;
    if (!host) {
      return;
    }
    let minSpeed = 1;
    const airSpeed = Math.max(Math.abs(host.args.gSpeed), Math.abs(host.args.xSpeed), Math.abs(host.args.ySpeed), minSpeed) * 1.1;
    super.updateEnd(host);
    if (this.args.ySpeed > 0) {
      if (this.args.ySpeed <= 0 || airSpeed < 1.5) {
        return;
      }
      if (this.box) {
        this.box.classList.remove('ascending');
      }
    } else if (this.box) {
      this.box.classList.add('ascending');
    }
  }
  get solid() {
    return false;
  }
  // get isGhost() { return true; }
}
exports.Follower = Follower;
});

;require.register("actor/Fountain.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Fountain = void 0;
var _PointActor = require("./PointActor");
class Fountain extends _PointActor.PointActor {
  constructor() {
    super(...arguments);
    this.args.width = 72;
    this.args.height = 120;
    this.args.float = -1;
    this.args.type = 'actor-item actor-fountain';
  }
  collideA(other) {
    if (!other.controllable || !other.args.falling) {
      return;
    }
    if (other.y > this.y + -this.args.height * 0.5) {
      other.args.x = this.x;
    }
    if (other.args.ySpeed > 0) {
      other.args.ySpeed *= 0.75;
    }
    if (other.args.ySpeed > -20 && Math.abs(this.x - other.x) < 8) {
      other.args.ySpeed -= 0.4;
    }
  }
  get solid() {
    return false;
  }
}
exports.Fountain = Fountain;
});

;require.register("actor/Gator.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Gator = void 0;
var _Flickie = require("./Flickie");
var _Mixin = require("curvature/base/Mixin");
var _PointActor = require("./PointActor");
var _Patrol = require("../behavior/Patrol");
var _CanPop = require("../mixin/CanPop");
class Gator extends _Mixin.Mixin.from(_PointActor.PointActor, _CanPop.CanPop) {
  constructor() {
    var _this$args$patrolPaus, _this$args$patrolBeat, _this$args$patrolSpee;
    super(...arguments);
    this.behaviors.add(new _Patrol.Patrol());
    this.args.type = 'actor-item actor-gator-bot';
    this.args.animation = 'standing';
    this.args.accel = 0.75;
    this.args.decel = 0.5;
    this.args.gSpeedMax = 15;
    this.args.jumpForce = 5;
    this.args.gravity = 0.5;
    this.args.width = 44;
    this.args.height = 32;
    this.args.patrolPause = (_this$args$patrolPaus = this.args.patrolPause) !== null && _this$args$patrolPaus !== void 0 ? _this$args$patrolPaus : 20;
    this.args.patrolBeat = (_this$args$patrolBeat = this.args.patrolBeat) !== null && _this$args$patrolBeat !== void 0 ? _this$args$patrolBeat : 110;
    this.args.patrolSpeed = (_this$args$patrolSpee = this.args.patrolSpeed) !== null && _this$args$patrolSpee !== void 0 ? _this$args$patrolSpee : 1;
    this.chasing = false;
  }
  onRendered(event) {
    super.onRendered(event);
  }
  update() {
    if (this.viewport && this.viewport.controlActor) {
      const space = Math.abs(this.viewport.controlActor.args.x - this.args.x);
      if (space < 64) {
        this.box.setAttribute('data-animation', 'chomping');
      } else {
        this.box.setAttribute('data-animation', 'standing');
      }
    }
    super.update();
    this.args.direction = Math.sign(this.args.gSpeed);
    this.args.facing = this.args.direction > 0 ? 'right' : 'left';
  }
  effect(other) {
    super.effect(other);

    // this.viewport.spawn.add({object:new Flickie({
    // 	x: this.args.x,
    // 	y: this.args.y,
    // })});
  }

  get solid() {
    return false;
  }
  get isEffect() {
    return false;
  }
  // get controllable() { return true; }
}
exports.Gator = Gator;
});

;require.register("actor/GiantTire.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GiantTire = void 0;
var _PointActor = require("./PointActor");
var _Mixin = require("curvature/base/Mixin");
var _TruckBody = require("./TruckBody");
var _TruckCab = require("./TruckCab");
var _Platformer = require("../behavior/Platformer");
var _Sfx = require("../audio/Sfx");
class GiantTire extends _Mixin.Mixin.from(_PointActor.PointActor) {
  constructor() {
    super(...arguments);
    this.args.type = 'actor-item actor-giant-tire';
    if (this.args.rear) {
      this.args.type += ' actor-giant-tire-back';
    }
    this.args.width = 64;
    this.args.height = 64;
    this.args.rolled = 0;
    this.gSpeedLast = 0;
    this.args.accel = 0.0;
    this.args.decel = 0.0;
    this.args.gravity = 0.6;
    this.args.driver = this.args.driver || null;
    this.args.partner = this.args.partner || null;
    this.args.idler = null;
    this.args.body = this.args.body || null;
  }
  spawnParts() {
    if (this.args.driver || this.args.idler) {
      return;
    }
    const idler = this.args.idler = new GiantTire({
      driver: this,
      x: this.args.x - 96,
      y: this.args.y
    });
    const partner = this.args.partner = new GiantTire({
      driver: this,
      rear: true,
      x: this.args.x + 32,
      y: this.args.y
    });
    const idlerPartner = this.args.idlerPartner = new GiantTire({
      driver: this,
      rear: true,
      x: this.args.x - 64,
      y: this.args.y
    });
    const body = this.args.body = new _TruckBody.TruckBody({
      driver: this,
      x: this.args.x - 32,
      y: this.args.y - 32
    });
    const cab = this.args.cab = new _TruckCab.TruckCab({
      driver: this,
      x: this.args.x + 48,
      y: this.args.y - 28
    });
    this.viewport.spawn.add({
      object: idler
    });
    this.viewport.spawn.add({
      object: partner
    });
    this.viewport.spawn.add({
      object: idlerPartner
    });
    this.viewport.spawn.add({
      object: body
    });
    this.viewport.spawn.add({
      object: cab
    });
    this.viewport.auras.add(this);
    this.viewport.auras.add(idler);
    this.viewport.auras.add(partner);
    this.viewport.auras.add(idlerPartner);
    this.viewport.auras.add(body);
    this.viewport.auras.add(cab);
  }
  onRendered(event) {
    super.onRendered(event);
    this.autoStyle.get(this.box)['--rolled'] = 'rolled';
  }
  updateStart() {
    if (!this.args.driver && !this.args.idler) {
      this.spawnParts();
    }
    if (this.args.destroyed && !this.args.falling) {
      this.args.type += ' actor-giant-tire-destroyed';
      this.args.idler.args.type += ' actor-giant-tire-destroyed';
      this.args.partner.args.type += ' actor-giant-tire-destroyed';
      this.args.idlerPartner.args.type += ' actor-giant-tire-destroyed';
      this.args.cab.args.type += ' actor-truck-cab-destroyed';
      this.args.body.args.type += ' actor-truck-body-destroyed';
      _Sfx.Sfx.play('ROCK_BREAK_1');
      _Sfx.Sfx.play('OBJECT_DESTROYED');
      this.viewport.onFrameOut(180, () => _Sfx.Sfx.play('RADIO_CHATTER_2'));
      if (!this.args.driver) {
        let other = this.viewport.controlActor;
        this.viewport.onFrameOut(15, () => other.cofocused = null);
        this.args.body.noClip = true;
        this.args.cab.noClip = true;
        this.args.body.args.destroyed = true;
        this.args.cab.args.destroyed = true;
        this.args.body.args.xSpeed = this.gSpeedLast * 1.2;
        this.args.cab.args.xSpeed = this.gSpeedLast * 1.3;
        this.args.body.args.ySpeed = -6;
        this.args.cab.args.ySpeed = -14;
        this.args.body.args.falling = true;
        this.args.cab.args.falling = true;
        this.args.body.args.float = 0;
        this.args.cab.args.float = 0;
      }
      this.args.ySpeed = -11;
      this.args.xSpeed = this.gSpeedLast * 1.4;
      this.args.falling = true;
    }
    if (this.args.destroyed) {
      if (this.args.idler && !this.args.idler.args.destroyed) {
        this.args.idler.args.destroyed = true;
        this.args.partner.args.destroyed = true;
        this.args.idlerPartner.args.destroyed = true;
        this.args.idler.args.falling = true;
        this.args.partner.args.falling = true;
        this.args.idlerPartner.args.falling = true;
        this.args.idler.args.xSpeed = this.gSpeedLast * 1.7;
        this.args.partner.args.xSpeed = this.gSpeedLast * 1.5;
        this.args.idlerPartner.args.xSpeed = this.gSpeedLast * 1.8;
        this.args.idler.args.ySpeed = -11;
        this.args.partner.args.ySpeed = -11;
        this.args.idlerPartner.args.ySpeed = -11;
        this.args.idler.args.float = 0;
        this.args.partner.args.float = 0;
        this.args.idlerPartner.args.float = 0;
        this.args.idler.noClip = true;
        this.args.partner.noClip = true;
        this.args.idlerPartner.noClip = true;
      }
      this.args.float = 0;
      this.noClip = true;
      return;
    }
    while (this.getMapSolidAt(this.args.x, this.args.y - 1)) {
      this.args.y--;
    }
    if (!this.args.idler || !this.viewport.controlActor || this.viewport.controlActor.args.dead) {
      super.updateStart();
      return;
    }
    let other = this.viewport.controlActor;
    if (this.age < 36 && this.args.x > -160 + other.args.x) {
      super.updateStart();
      return;
    }
    if (other.args.standingOn && other.args.standingOn.isVehicle) {
      other = other.args.standingOn;
    }
    if (!this.args.falling) {
      if (other.args.gSpeed && this.args.x > -160 + other.args.x) {
        this.args.gSpeed *= 0.99;
      } else {
        this.args.gSpeed = Math.max(this.args.gSpeed, other.args.gSpeed || other.args.xSpeed);
      }
    } else {
      if (this.args.x > -160 + other.args.x) {
        this.args.xSpeed *= 0.99;
      } else {
        this.args.xSpeed = Math.max(this.args.xSpeed, other.args.xSpeed || other.args.xSpeed);
      }
    }
    if (other.args.x < this.args.x || other.args.falling && other.args.xSpeed < 0) {
      this.args.gSpeed = Math.min(-8, 0.75 * other.args.xSpeed);
    } else if (other.args.gSpeed && other.args.gSpeed < 5) {
      this.args.gSpeed++;
    }
    const distance = this.args.body.distanceTo(other);
    if (distance < 768 && other.args.jumping && other.fallTime < 120) {
      this.args.gSpeed *= 0.9;
    }
    if (distance < 512) {
      other.cofocused = this.args.idler;
    } else {
      other.cofocused = null;
    }
  }
  updateEnd() {
    if (!this.args.idler || this.args.destroyed) {
      super.updateEnd();
      return;
    }
    for (const region of this.viewport.regionsAtPoint(this.args.x + 80, this.args.y)) {
      if (region.args.destroyTruck) {
        this.args.destroyed = true;
      }
    }
    const idler = this.args.idler;
    const partner = this.args.partner;
    const idlerPartner = this.args.idlerPartner;
    const bodyX = 0.5 * (this.args.x + idler.args.x);
    const bodyY = -32 + 0.5 * (this.args.y + idler.args.y);
    const bodyA = this.angleTo(idler);
    const bodyD = this.distanceTo(idler);
    this.ensureSpace(idler, 96);
    this.ensureSpace(partner, -16);
    this.ensureSpace(idlerPartner, 80);
    this.args.body.args.x = bodyX;
    this.args.body.args.y = bodyY;
    this.args.body.args.groundAngle = -bodyA;
    this.args.body.args.falling = true;
    this.args.body.args.mode = 0;
    this.args.body.args.xSpeed = this.args.xSpeed || this.args.gSpeed * Math.cos(bodyA);
    this.args.body.args.ySpeed = this.args.ySpeed || this.args.gSpeed * Math.sin(bodyA);
    this.args.cab.args.xSpeed = this.args.xSpeed || this.args.gSpeed * Math.cos(bodyA);
    this.args.cab.args.ySpeed = this.args.ySpeed || this.args.gSpeed * Math.sin(bodyA);
    this.args.cab.args.x = 0 + bodyX + 80 * Math.cos(bodyA);
    this.args.cab.args.y = 3 + bodyY + 80 * Math.sin(bodyA);
    this.args.cab.args.groundAngle = -bodyA * 1.1;
    this.args.cab.args.falling = true;
    this.args.cab.args.mode = 0;
    if (this.args.gSpeed) {
      this.args.animation = 'rolling';
      this.args.idler.args.animation = 'rolling';
      this.args.partner.args.animation = 'rolling';
      this.args.idlerPartner.args.animation = 'rolling';
    } else {
      this.args.animation = 'idle';
      this.args.idler.args.animation = 'idle';
      this.args.partner.args.animation = 'idle';
      this.args.idlerPartner.args.animation = 'idle';
    }
    super.updateEnd();
  }
  ensureSpace(other, spacing) {
    let idlerDist = this.distanceFrom(other);
    let absSpace = Math.abs(spacing);
    let offset = Math.abs(absSpace - idlerDist);
    let angle = this.angleTo(other);
    if (spacing > 0 && other.args.x > this.args.x) {
      other.args.x = this.args.x - 4;
      other.args.y = this.args.y;
    } else if (spacing < 0 && other.args.x < this.args.x) {
      other.args.x = this.args.x + 4;
      other.args.y = this.args.y;
    }
    if (this.args.falling) {
      other.args.gSpeed = this.args.xSpeed;
      other.args.xSpeed = this.args.xSpeed;
    } else if (idlerDist > absSpace) {
      other.args.gSpeed = this.args.gSpeed + offset * Math.cos(angle);
      other.args.xSpeed = this.args.xSpeed || other.args.gSpeed;
    } else if (idlerDist < absSpace) {
      other.args.gSpeed = this.args.gSpeed + -offset * Math.cos(angle);
      other.args.xSpeed = other.args.gSpeed;
    } else {
      other.args.gSpeed = this.args.gSpeed;
      other.args.xSpeed = other.args.gSpeed;
    }
    if (this.args.falling && other.args.falling) {
      other.args.xSpeed = this.args.xSpeed;
      other.args.ySpeed = this.args.ySpeed;
      const bodyD = this.distanceTo(other);
      const bodyA = this.angleTo(other);
      if (bodyD !== 96) {
        other.args.x = this.args.x - absSpace * Math.cos(bodyA);
        other.args.y = this.args.y - absSpace * Math.sin(bodyA);
      }
    }
  }
  collideA(other, type) {
    if (this.args.destroyed) {
      return;
    }
    if (other.break) {
      other.break(this);
      return;
    }
    if (other.pop) {
      other.pop(this);
      return;
    }
    if (!other.controllable) {
      return;
    }
    other.damage(this);
  }
}
exports.GiantTire = GiantTire;
});

;require.register("actor/GlassSphere.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GlassSphere = void 0;
var _PointActor = require("./PointActor");
var _Sfx = require("../audio/Sfx");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class GlassSphere extends _PointActor.PointActor {
  constructor() {
    super(...arguments);
    _defineProperty(this, "float", -1);
    this.args.type = 'actor-item actor-glass-sphere';
    this.args.width = 24;
    this.args.height = 24;
    this.ignores = new Map();
    this.broken = false;
  }
  collideA(other) {
    if (other.args.static || other.isRegion || this.ignores.has(other) || other.noClip) {
      return false;
    }
    if (this.broken) {
      return false;
    }
    this.args.type = 'actor-item actor-glass-sphere actor-glass-sphere-active';
    if (other.args.falling) {
      const xDiff = this.x - other.x;
      const yDiff = this.y - other.y;
      const speed = other.args.ySpeed >= 0 ? 11 : 7;
      const angle = Math.atan2(yDiff, xDiff);
      const otherRadius = other.args.width / 2;
      other.args.xSpeed = -speed * Math.cos(angle);
      other.args.ySpeed = -speed * Math.sin(angle);
      other.args.ignore = other.args.ignore || 4;
    } else {
      other.args.gSpeed *= -1;
      if (Math.abs(other.args.gSpeed) < 7) {
        other.args.gSpeed = 7 * Math.sign(other.args.gSpeed);
      }
    }
    this.ignores.set(other, 30);
    this.onTimeout(30, () => {
      // this.args.hidden = true;
    });
    this.broken = true;
    if (Math.random() > 0.5) {
      _Sfx.Sfx.play('BREAK_GLASS_1');
    } else {
      _Sfx.Sfx.play('BREAK_GLASS_2');
    }
    const viewport = this.viewport;
    if (viewport.settings.rumble && other && other.controller && other.controller.rumble) {
      other.controller.rumble({
        duration: 30,
        strongMagnitude: 0.25,
        weakMagnitude: 1.0
      });
      this.onTimeout(30, () => {
        other.controller.rumble({
          duration: 30,
          strongMagnitude: 0.0,
          weakMagnitude: 1.0
        });
      });
    }
  }
  sleep() {
    this.broken = false;
    this.args.type = 'actor-item actor-glass-sphere';
  }
  get canStick() {
    return false;
  }
  get rotateLock() {
    return true;
  }
  get solid() {
    return !this.broken;
  }
}
exports.GlassSphere = GlassSphere;
});

;require.register("actor/GohlaBall.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GohlaBall = void 0;
var _Flickie = require("./Flickie");
var _Mixin = require("curvature/base/Mixin");
var _Tag = require("curvature/base/Tag");
var _PointActor = require("./PointActor");
var _SkidDust = require("../behavior/SkidDust");
var _CanPop = require("../mixin/CanPop");
var _Explosion = require("../actor/Explosion");
var _Projectile = require("../actor/Projectile");
class GohlaBall extends _Mixin.Mixin.from(_PointActor.PointActor, _CanPop.CanPop) {
  constructor() {
    super(...arguments);
    this.behaviors.add(new _SkidDust.SkidDust());
    this.args.type = 'actor-item actor-gohla-ball';
    this.args.animation = 'standing';
    this.args.accel = 0.1;
    this.args.decel = 0.5;
    this.args.gSpeedMax = 5;
    this.args.jumpForce = 5;
    this.args.gravity = 0.5;
    this.args.width = 16;
    this.args.height = 16;
    this.willStick = false;
    this.stayStuck = false;
  }
  get solid() {
    return false;
  }
  get isEffect() {
    return false;
  }
}
exports.GohlaBall = GohlaBall;
});

;require.register("actor/GrapplePoint.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GrapplePoint = void 0;
var _PointActor = require("./PointActor");
var _Tag = require("curvature/base/Tag");
var _Spring = require("./Spring");
var _Mixin = require("curvature/base/Mixin");
var _Constrainable = require("../mixin/Constrainable");
class GrapplePoint extends _Mixin.Mixin.from(_PointActor.PointActor, _Constrainable.Constrainable) {
  constructor() {
    super(...arguments);

    // this.args.width  = this.args.width  || 32;
    // this.args.height = this.args.height || 32;

    this.args.width = 28;
    this.args.height = 16;
    this.args.type = 'actor-item actor-grapple-point';
    this.ignoreOthers = new Set();
    this.args.gravity = 0.6;

    // this.noClip = true;
    this[_Spring.Spring.WontSpring] = true;
    this.hooked = new Set();
  }
  updateEnd() {
    super.update();
    const tiedTo = this.others.tiedTo;
    if (tiedTo) {
      this.setPos();
    }
    if (!tiedTo) {
      this.unhookAll();
    }

    // if(!tiedTo || !tiedTo.args.falling)
    // {
    // 	return false;
    // }

    this.args.falling = true;
    if (this.args.noSwing && tiedTo) {
      this.args.xSpeed = 0;
      this.args.x = tiedTo.args.x;
    }
    if (this.hooked.size) {
      this.args.active = true;
      if (this.args.noSwing) {
        this.noClip = true;
      }
      if (this.viewport.args.theme === 'phazon') {
        if (!this.lightning) {
          this.lightning = new _Tag.Tag(`<div class = "particle-sparkle-lightning">`);
          viewport.particles.add(this.lightning);
          console.log(this.lightning);
        }
        this.lightning.style({
          '--x': (tiedTo.args.x + this.args.x) / 2,
          '--y': (tiedTo.args.y + this.args.y) / 2,
          'height': this.args.distance - this.args.height + 'px',
          '--angle': -this.args.groundAngle
        });
      }
      const hooked = [...this.hooked];
      const first = hooked[0];
      if (first.xAxis && !this.args.noSwing) {
        if (Math.sign(this.args.xSpeed) || Math.sign(this.args.xSpeed) === Math.sign(this.hooked.xAxis)) {
          if (this.y > tiedTo.y) {
            this.args.xSpeed += first.xAxis * 0.25;
          } else {
            this.args.xSpeed -= first.xAxis * 0.25;
          }
        }
      }
      for (const h of this.hooked) {
        h.args.x = this.x;
        h.args.y = this.y + first.args.height + -5;
        h.args.xSpeed = 0;
        h.args.ySpeed = 0;
        h.args.groundAngle = 0;
        if (h.xAxis > 0) {
          h.args.facing = 'right';
          h.args.direction = +1;
        } else if (h.xAxis < 0) {
          h.args.facing = 'left';
          h.args.direction = -1;
        }
        h.args.cameraMode = 'hooked';
      }
    } else {
      this.args.active = false;
      if (this.args.noSwing) {
        this.noClip = false;
      }
      if (this.lightning) {
        this.viewport.particles.remove(this.lightning);
        this.lightning = null;
      }
    }
    if (!tiedTo) {
      this.noClip = true;
    }
    super.updateEnd();
  }
  update() {}
  collideA(other) {
    if (!other.controllable) {
      return false;
    }
    const tiedTo = this.others.tiedTo;
    if (!tiedTo || tiedTo.noClip) {
      return false;
    }
    if (other.args.hangingFrom || this.ignoreOthers.has(other)) {
      return;
      false;
    }
    if (this.args.ignore) {
      return false;
    }

    // if((
    // 	(other.args.falling && Math.abs(other.args.y + -this.args.y + other.args.height) > 8)
    // 	&& (other.args.falling && Math.abs(other.args.y + -this.args.y) > 8)
    // )
    // || !other.controllable
    // || this.hooked)
    // {
    // 	return;
    // }

    other.args.falling = true;
    other.swing = true;
    this.hooked.add(other);
    this.viewport.auras.add(this);
    this.args.xSpeed = other.args.xSpeed || other.args.gSpeed;
    if (other.args.mode === 2) {
      this.args.xSpeed = other.args.xSpeed || -other.args.gSpeed;
    }
    if (!this.args.noSwing) {
      this.args.ySpeed = other.args.ySpeed;
    }
    other.args.xSpeed = 0;
    other.args.ySpeed = 0;
    other.args.gSpeed = 0;
    other.args.ignore = -4;
    other.args.float = -1;
    other.xLast = other.args.x;
    other.yLast = other.args.y;
    other.args.x = this.args.x;
    other.args.y = this.args.y + other.args.height;
    other.args.hangingFrom = this;
    other.args.jumping = false;
    if (this.others.tiedTo) {
      const tiedTo = this.others.tiedTo;
      tiedTo.dispatchEvent(new CustomEvent('hooked'), {
        detail: {
          hook: this,
          subject: other
        }
      });
      tiedTo.activate && tiedTo.activate(other);
      const drop = () => {
        if (!this.viewport) {
          return;
        }
        if (!this.hooked.size) {
          this.args.x = this.def.get('x');
          this.args.y = this.def.get('y');
          this.viewport.setColCell(this);
          return;
        }
        this.unhookAll();
        if (tiedTo.explode) {
          for (const h of this.hooked) {
            h.args.gSpeed = 0;
          }
          tiedTo.explode();
          this.args.x = this.def.get('x');
          this.args.y = this.def.get('y');
          this.viewport.setColCell(this);
        }
      };
      if (tiedTo.args.flightTime) {
        this.viewport.onFrameOut(tiedTo.args.flightTime, drop);
      }
      tiedTo.onRemove(drop);
      tiedTo.addEventListener('exploded', drop);
    }
  }
  unhook(hooked) {
    // const hooked = this.hooked;

    // this.hooked = null;

    // if(!hooked)
    // {
    // 	return;
    // }

    if (!this.hooked.has(hooked)) {
      return;
    }
    this.hooked.delete(hooked);
    const tiedTo = this.others.tiedTo;
    hooked.args.ignore = hooked.args.float = 0;
    hooked.args.y++;
    hooked.args.xSpeed += tiedTo.xSpeedLast || this.xSpeedLast || 0;
    hooked.args.ySpeed += tiedTo.ySpeedLast || this.ySpeedLast || 0;
    hooked.args.groundAngle = 0;
    hooked.args.hangingFrom = null;
    this.ignoreOthers.add(hooked);
    hooked.args.falling = true;
    hooked.args.jumping = true;
    const viewport = this.viewport;
    viewport.onFrameOut(15, () => {
      this.ignoreOthers.delete(hooked);
      viewport.auras.delete(this);
    });
  }
  unhookAll() {
    for (const hooked of this.hooked) {
      this.unhook(hooked);
    }
  }
}
exports.GrapplePoint = GrapplePoint;
});

;require.register("actor/GravityPad.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GravityPad = void 0;
var _PointActor = require("./PointActor");
var _Block = require("./Block");
var _Sfx = require("../audio/Sfx");
class GravityPad extends _PointActor.PointActor {
  static fromDef(objDef) {
    const obj = super.fromDef(objDef);
    obj.args.width = objDef.width;
    return obj;
  }
  constructor() {
    super(...arguments);
    this.args.width = this.args.width || 24;
    this.args.height = 32;
    this.args.type = 'actor-item actor-gravity-pad';
    this.args.float = -1;
  }
  collideA(other) {
    if (other.args.mode || other.args.float || other.args.static) {
      return;
    }
    other.args.float = 1;
    other.args.xSpeed = other.args.xSpeed || other.args.gSpeed;
    if (Math.abs(other.xLast - other.args.x) > 5) {
      other.args.ignore = 1;
    }
    other.args.ySpeed = Math.min(0, other.args.ySpeed);
    other.args.falling = true;
    if (other.args.y > this.args.y + -this.args.height) {
      other.args.y -= 1;
      other.args.ySpeed -= 0.50;
    } else {
      other.args.ySpeed *= 0.25;
    }
    if (other.args.y >= this.args.y + -(this.args.height * 0.5)) {
      other.args.ySpeed -= 1;
    }
    other.args.animation = 'flip';
    other.args.jumping = false;
    other.dashed = false;
  }
}
exports.GravityPad = GravityPad;
});

;require.register("actor/Grounder.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Grounder = void 0;
var _Flickie = require("./Flickie");
var _Mixin = require("curvature/base/Mixin");
var _PointActor = require("./PointActor");
var _Patrol = require("../behavior/Patrol");
var _CanPop = require("../mixin/CanPop");
class Grounder extends _Mixin.Mixin.from(_PointActor.PointActor, _CanPop.CanPop) {
  constructor() {
    var _this$args$color, _this$args$patrolPaus, _this$args$patrolBeat, _this$args$patrolSpee;
    super(...arguments);
    this.behaviors.add(new _Patrol.Patrol());
    this.args.type = 'actor-item actor-grounder';
    this.args.animation = 'standing';
    this.args.accel = 0.1;
    this.args.decel = 0.5;
    this.args.gSpeedMax = 5;
    this.args.jumpForce = 5;
    this.args.gravity = 0.5;
    this.args.width = 24;
    this.args.height = 32;
    this.args.color = (_this$args$color = this.args.color) !== null && _this$args$color !== void 0 ? _this$args$color : 'green';
    this.willStick = false;
    this.stayStuck = false;
    this.args.patrolPause = (_this$args$patrolPaus = this.args.patrolPause) !== null && _this$args$patrolPaus !== void 0 ? _this$args$patrolPaus : 20;
    this.args.patrolBeat = (_this$args$patrolBeat = this.args.patrolBeat) !== null && _this$args$patrolBeat !== void 0 ? _this$args$patrolBeat : 120;
    this.args.patrolSpeed = (_this$args$patrolSpee = this.args.patrolSpeed) !== null && _this$args$patrolSpee !== void 0 ? _this$args$patrolSpee : 1;
  }
  onRendered() {
    super.onRendered();
    this.autoAttr.get(this.box)['data-color'] = 'color';
  }
  update() {
    const direction = this.args.direction;
    const telegraph = this.args.shotTelegraph;
    const beat = this.args.patrolBeat;
    if (this.box) {
      if (this.args.moving && this.args.gSpeed) {
        this.box.setAttribute('data-animation', 'walking');
      } else {
        this.box.setAttribute('data-animation', 'standing');
      }
    }
    super.update();
    this.args.direction = Math.sign(this.args.gSpeed);
  }
  effect(other) {
    super.effect(other);

    // this.viewport.spawn.add({object:new Flickie({
    // 	x: this.args.x,
    // 	y: this.args.y,
    // })});
  }

  get solid() {
    return false;
  }
  get isEffect() {
    return false;
  }
  // get controllable() { return true; }
}
exports.Grounder = Grounder;
});

;require.register("actor/GuardBot.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GuardBot = void 0;
var _Flickie = require("./Flickie");
var _Mixin = require("curvature/base/Mixin");
var _Tag = require("curvature/base/Tag");
var _PointActor = require("./PointActor");
var _SkidDust = require("../behavior/SkidDust");
var _CanPop = require("../mixin/CanPop");
var _Explosion = require("../actor/Explosion");
var _Projectile = require("../actor/Projectile");
class GuardBot extends _Mixin.Mixin.from(_PointActor.PointActor, _CanPop.CanPop) {
  constructor() {
    super(...arguments);
    this.behaviors.add(new _SkidDust.SkidDust());
    this.args.type = 'actor-item actor-guard-bot';
    this.args.animation = 'standing';
    this.args.accel = 0.1;
    this.args.decel = 0.5;
    this.args.gSpeedMax = 5;
    this.args.jumpForce = 5;
    this.args.gravity = 0.5;
    this.args.width = 24;
    this.args.height = 24;
    this.args.static = true;
    this.willStick = false;
    this.stayStuck = false;
  }
  get solid() {
    return false;
  }
  get isEffect() {
    return false;
  }
}
exports.GuardBot = GuardBot;
});

;require.register("actor/HallBooster.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.HallBooster = void 0;
var _PointActor = require("./PointActor");
var _Sfx = require("../audio/Sfx");
const Boosted = Symbol('Boosted');
class HallBooster extends _PointActor.PointActor {
  constructor() {
    super(...arguments);
    this.args.type = 'actor-item actor-hall-booster';
    this.args.width = 64;
    this.args.height = 24;
    this.args.direction = this.args.direction || 1;
    this.args.static = true;
  }
  update() {
    super.update();
  }
  collideA(other) {
    if (other.isRegion || other.args.static) {
      return;
    }
    if (other instanceof HallBooster) {
      return;
    }
    if (other.args.gSpeed === 0) {
      // return;
    }
    if (other.args.falling || other[Boosted]) {
      return;
    }
    this.viewport.onFrameOut(10, () => delete other[Boosted]);
    other[Boosted] = this;
    const toSpeed = this.args.toSpeed || 24;
    other.args.ignore = 2;
    other.args.direction = this.args.direction;
    other.args.facing = this.args.direction > 0 ? 'right' : 'left';
    other.args.gSpeed = toSpeed * this.args.direction;
    _Sfx.Sfx.play('HALLBOOSTER_HIT');
  }
}
exports.HallBooster = HallBooster;
});

;require.register("actor/HeavyDutySwitch.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.HeavyDutySwitch = void 0;
var _Switch = require("./Switch");
class HeavyDutySwitch extends _Switch.Switch {
  constructor() {
    super(...arguments);
    this.args.type = 'actor-item actor-switch actor-heavy-duty-switch';
    this.args.height = this.height = 19;
  }
}
exports.HeavyDutySwitch = HeavyDutySwitch;
});

;require.register("actor/Herculad.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Herculad = void 0;
var _PointActor = require("./PointActor");
var _Mixin = require("curvature/base/Mixin");
var _Sfx = require("../audio/Sfx");
class Herculad extends _Mixin.Mixin.from(_PointActor.PointActor) {
  constructor() {
    super(...arguments);
    this.args.type = 'actor-item actor-herculad';
    this.args.width = 32;
    this.args.height = 32;
    this.args.gravity = 0.4;
    this.args.collected = false;
  }
  onRendered(event) {
    super.onRendered(event);
    this.autoAttr.get(this.box)['data-collected'] = 'collected';
  }
  collideA(other, type) {
    if (other.controllable) {
      if (!this.args.collected) {
        _Sfx.Sfx.play('DOOT_DOOT');
        this.viewport.args.inventory.push({
          tallyIcon: '/secret/herculad-icon.png',
          icon: '/secret/herculad-icon.png',
          points: 10000,
          id: this.oid
        });
      }
      this.args.collected = 'collected';
    }
    super.collideA(other, type);
  }
}
exports.Herculad = Herculad;
});

;require.register("actor/HexNut.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.HexNut = void 0;
var _Block = require("./Block");
var _Sfx = require("../audio/Sfx");
class HexNut extends _Block.Block {
  constructor() {
    var _this$args$maxClimb;
    super(...arguments);
    this.args.maxClimb = (_this$args$maxClimb = this.args.maxClimb) !== null && _this$args$maxClimb !== void 0 ? _this$args$maxClimb : 262;
    this.args.width = 64;
    this.args.height = 24;
    this.args.platform = 1;
    this.args.float = -1;
    this.args.type = 'actor-item actor-hex-nut';
    this.args.static = 0;
    // this.args.gravity  = 0.20;
    this.args.spinning = 0;
    this.args.bouncing = 0;
    this.args.treadmill = true;
  }
  collideA(other, type) {
    if (other.args.platform) {
      return false;
    }
    return super.collideA(other, type);
  }
  update() {
    this.args.treadmill = true;
    this.standingUnder.forEach(a => {
      if (Math.abs(a.args.gSpeed) > 16) {
        a.args.gSpeed = 16 * Math.sign(a.args.gSpeed);
      }
    });
    const maxClimb = this.originalY + -this.args.maxClimb;
    if (this.args.convey > 0) {
      if (this.getMapSolidAt(this.args.x, this.args.y + 1)) {
        this.args.ySpeed = 0;
        this.args.treadmill = false;
        this.args.convey = 0;
      } else {
        this.args.y += 0.1 * this.args.convey;
      }
    } else if (this.args.convey < 0) {
      if (this.args.y <= maxClimb) {
        this.args.y = maxClimb;
        this.args.ySpeed = 0;
        this.args.treadmill = false;
        this.args.convey = 0;
      } else {
        this.args.y += 0.1 * this.args.convey;
      }
    }
    if (Math.abs(this.args.convey) > 8) {
      this.standingUnder.forEach(a => a.args.x = this.args.x);
    } else {
      this.standingUnder.forEach(a => {
        if (Math.abs(this.args.x - a.args.x) < 1) {
          a.args.x = this.args.x;
        }
        a.args.x += Math.sign(this.args.x - a.args.x);
      });
    }
    super.update();
  }
  sleep() {
    this.args.y = this.originalY;
  }
}
exports.HexNut = HexNut;
});

;require.register("actor/HtmlFrame.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.HtmlFrame = void 0;
var _PointActor = require("./PointActor");
var _Tag = require("curvature/base/Tag");
class HtmlFrame extends _PointActor.PointActor {
  static fromDef(objDef) {
    const obj = super.fromDef(objDef);
    obj.args.width = objDef.width;
    obj.args.height = objDef.height;
    obj.args.tileId = objDef.gid;

    // obj.args.x = obj.originalX = objDef.x + Math.floor(objDef.width / 2);
    obj.args.y = obj.originalY = objDef.y;
    return obj;
  }
  constructor() {
    var _args$collapse;
    let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let parent = arguments.length > 1 ? arguments[1] : undefined;
    super(args, parent);
    this.args.yForce = 0;
    this.args.yLean = 0;
    this.args.type = 'actor-item actor-html-frame';
    this.args.width = args.width || 32;
    this.args.height = args.height || 32;
    this.originalX = this.args.x;
    this.originalY = this.args.y;
    this.args.z = -1000;
    this.args.static = true;
    this.args.gravity = 0.5;
    this.args.collapse = (_args$collapse = args.collapse) !== null && _args$collapse !== void 0 ? _args$collapse : false;
    const urls = ['pxIofYrt0kE', 'aRsOBFhNjVM', 'obtGE_8NAp8', 'uRjoPlWWljk'];
    const ytUrt = v => `https://www.youtube.com/embed/${v}?controls=0&autoplay=1`;
    const random = Math.random();
    console.log(random);
    this.args.url = ytUrt(urls[Math.trunc(random * urls.length)]);
  }
  onRendered(event) {
    super.onRendered(event);

    // this.droop(0);

    if (this.screen) {
      return;
    }
    this.screen = new _Tag.Tag(`<iframe width="560" height="315" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>`);
    this.sprite.appendChild(this.screen.node);

    // this.screen.style({'pointer-events':'initial'});

    this.args.spriteSheet = this.args.spriteSheet || '/Sonic/marble-zone-block.png';
    this.args.bindTo('url', v => this.screen.src = v);
    this.args.bindTo('html', v => this.screen.srcDoc = v);
  }
}

// <iframe width="560" height="315" src="https://www.youtube.com/embed/lTsIO_bo2P8" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
exports.HtmlFrame = HtmlFrame;
});

;require.register("actor/Jawz.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Jawz = void 0;
var _Flickie = require("./Flickie");
var _Spring = require("./Spring");
var _Mixin = require("curvature/base/Mixin");
var _Tag = require("curvature/base/Tag");
var _PointActor = require("./PointActor");
var _CanPop = require("../mixin/CanPop");
class Jawz extends _Mixin.Mixin.from(_PointActor.PointActor, _CanPop.CanPop) {
  constructor() {
    super(...arguments);
    this.args.type = 'actor-item actor-jawz';
    this[_Spring.Spring.WontSpring] = true;
    this.args.animation = 'standing';
    this.args.accel = 0.1;
    this.args.decel = 0.5;
    this.args.gSpeedMax = 5;
    this.args.jumpForce = 5;
    this.args.gravity = 0.5;
    this.args.width = 56;
    this.args.height = 16;
    this.willStick = false;
    this.stayStuck = false;
    this.args.float = -1;
    this.noClip = true;
  }
  onRendered() {
    super.onRendered();
    this.box.setAttribute('data-animation', 'standing');
  }
  update() {
    // this.args.facing  = 'right';
    this.args.facing = 'left';
    if (this.args.xSpeed > -4) {
      this.args.xSpeed -= 0.2;
    }
    this.args.ySpeed = 0;
    this.args.falling = true;
    this.args.flying = true;
    super.update();
  }
  effect(other) {
    super.effect(other);

    // this.viewport.spawn.add({object:new Flickie({
    // 	x: this.args.x,
    // 	y: this.args.y,
    // })});
  }

  get solid() {
    return false;
  }
  get isEffect() {
    return false;
  }
}
exports.Jawz = Jawz;
});

;require.register("actor/Knuckles.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Knuckles = void 0;
var _PointActor = require("./PointActor");
var _Platformer = require("../behavior/Platformer");
var _Tag = require("curvature/base/Tag");
var _KnuxBomb = require("./KnuxBomb");
var _Spindash = require("../behavior/Spindash");
var _Spring = require("./Spring");
var _SkidDust = require("../behavior/SkidDust");
var _Crouch = require("../behavior/Crouch");
var _LookUp = require("../behavior/LookUp");
var _EmeraldHalo = require("../behavior/EmeraldHalo");
var _SuperForm = require("../behavior/SuperForm");
var _Color = require("../lib/Color");
var _Png = require("../sprite/Png");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class Knuckles extends _PointActor.PointActor {
  constructor(args, parent) {
    super(args, parent);
    _defineProperty(this, "png", new _Png.Png('/Sonic/knuckles.png'));
    this.args.canonical = 'Knuckles';
    window.knuckles = this;
    this.behaviors.add(new _SkidDust.SkidDust());
    this.behaviors.add(new _Spindash.Spindash());
    this.behaviors.add(new _Crouch.Crouch());
    this.behaviors.add(new _LookUp.LookUp());
    this.behaviors.add(new _SuperForm.SuperForm());
    this.behaviors.add(new _EmeraldHalo.EmeraldHalo());
    this.args.isHyper = this.args.isSuper = false;
    this.args.type = 'actor-item actor-knuckles';
    this.args.spriteSheet = this.spriteSheet = `url('/Sonic/knuckles.png')`;
    this.gSpeedMaxNormal = 18;
    this.gSpeedMaxSuper = 20;
    this.gSpeedMaxHyper = 23;
    this.climbSpeedMaxNormal = 4;
    this.climbSpeedMaxSuper = 6;
    this.climbSpeedMax = this.climbSpeedMaxNormal;
    this.jumpForceNormal = 9.5;
    this.jumpForceSuper = 10;
    this.jumpForceHyper = 11;
    this.accelNormal = 0.12;
    this.accelSuper = 0.24;
    this.args.accel = this.accelNormal;
    this.args.decel = 0.4;
    this.args.gSpeedMax = this.gSpeedMaxNormal;
    this.args.jumpForce = this.jumpForceNormal;
    this.args.gravity = 0.5;
    this.args.normalGravity = 0.5;
    this.args.slowGravity = 0.125;
    this.args.punchMomentum = 0;
    this.args.width = 15;
    this.args.height = 41;
    this.args.weight = 150;
    this.args.normalHeight = 41;
    this.args.rollingHeight = 28;
    this.punchTime = 0;
    this.punched = 0;
    this.beforePunch = 'standing';
    this.bombsDropped = 0;
    this.args.bellySliding = false;
    this.slideTime = 0;
    this.sparks = new Set();
    this.flyTime = 0;
    this.transformTime = 0;
    this.args.minRingsSuper = 50;
    this.args.minRingsHyper = 75;
    this.args.bindTo('punchMomentum', v => this.args.punchSpeed = Math.abs(v * 0.5));
    this.args.bindTo('falling', v => {
      if (v || !this.args.flying) {
        return;
      }
      if (this.args.mode === 1 || this.args.mode === 2 || this.args.mode === 3) {
        this.args.climbing = true;
        if (this.isHyper && Math.abs(this.args.xSpeed) > 5) {
          this.viewport.args.shakeX = 16;
          if (this.viewport && this.viewport.settings.rumble && this.controller && this.controller.rumble) {
            this.controller.rumble({
              duration: 800,
              strongMagnitude: 1.0,
              weakMagnitude: 1.0
            });

            // this.onTimeout(240, () => {
            // 	this.controller.rumble({
            // 		duration: 100,
            // 		strongMagnitude: 0.0,
            // 		weakMagnitude: 0.25
            // 	});
            // });
          }
        }

        this.args.gSpeed = 0;
        this.args.xSpeed = 0;
        this.args.ySpeed = 0;
      }
    });
    this.costumes = {
      Tails: {
        h: -125,
        s: 1.0,
        v: 1.00
      },
      Enerjak: {
        h: 120,
        s: 1.0,
        v: 0.55
      },
      Pink: {
        h: 0,
        s: 1.5,
        v: 1.50
      },
      Wechnia: {
        h: 0,
        s: 0.0,
        v: 0.85
      }
    };
  }
  onRendered(event) {
    if (this.box) {
      return;
    }
    super.onRendered(event);
    this.autoStyle.get(this.box)['--punchSpeed'] = 'punchSpeed';
    this.autoStyle.get(this.box)['--sprite-sheet'] = 'spriteSheet';
    this.punchAura = new _Tag.Tag('<div class = "punch-aura">');
    this.punchAura.style({
      display: 'none'
    });
    this.sprite.appendChild(this.punchAura.node);
    this.args.bindTo('animation', v => this.box.setAttribute('data-animation', v));
    this.addEventListener('jump', event => {
      if (this.willPunch) {
        this.punchTime = this.viewport.args.frameId;
        this.punched++;
      }
    });
    this.rotatedSpriteSheet = this.spriteSheet;
    const updateSprite = () => {
      var _this$viewport$custom, _this$viewport$custom2, _this$viewport$custom3;
      let h = Number((_this$viewport$custom = this.viewport.customColor.h) !== null && _this$viewport$custom !== void 0 ? _this$viewport$custom : 0);
      let s = Number((_this$viewport$custom2 = this.viewport.customColor.s) !== null && _this$viewport$custom2 !== void 0 ? _this$viewport$custom2 : 1);
      let v = Number((_this$viewport$custom3 = this.viewport.customColor.v) !== null && _this$viewport$custom3 !== void 0 ? _this$viewport$custom3 : 1);
      this.rotateMainColor(h, s, v);

      // this.args.spriteSheet = this.args.rotatedSpriteSheet;

      this.box.node.style.setProperty('--sprite-sheet', `url(${this.args.rotatedSpriteSheet})`);
    };
    const debindH = this.viewport.customColor.bindTo('h', updateSprite, {
      wait: 0
    });
    const debindS = this.viewport.customColor.bindTo('s', updateSprite, {
      wait: 0
    });
    const debindV = this.viewport.customColor.bindTo('v', updateSprite, {
      wait: 0
    });
    this.onRemove(debindH);
    this.onRemove(debindS);
    this.onRemove(debindV);
    if (this.viewport.args.mainPallet && this.costumes[this.viewport.args.mainPallet]) {
      Object.assign(this.viewport.customColor, this.costumes[this.viewport.args.mainPallet]);
    }
    this.superSheet = 0;
    const superColorsA = {
      'f1958e': 'cacaca',
      'd3565c': 'cacaca',
      'c00020': 'b0b0b0',
      '600020': '989898'
      // '900000': '464646',
    };

    const superColorsB = {
      'f1958e': 'faf1f1',
      'd3565c': 'faf1f1',
      'c00020': 'f5dfdf',
      '600020': 'eecaca'
      // '900000': 'f1d5d5',
    };

    if (!this.superSpriteSheetLoaders) {
      this.superSpriteSheetLoaders = this.png.ready.then(() => this.superSpriteSheets = [this.png.recolor(superColorsA).toUrl(), this.png.recolor(superColorsB).toUrl()]);
    }
    this.hyperSheet = 0;
    const hyperColorsRed = {
      'f1958e': 'fcfcfc',
      'd3565c': 'fcfcfc',
      'c00020': 'fcfcfc',
      '600020': 'fcd8d8'
      // '900000': 'fcb4b4',
    };

    const hyperColorsPurple = {
      'f1958e': 'fcfcfc',
      'd3565c': 'fcfcfc',
      'c00020': 'fcfcfc',
      '600020': 'fcd8fc'
      // '900000': 'd8b4d8',
    };

    const hyperColorsCyan = {
      'f1958e': 'd8fcfc',
      'd3565c': 'd8fcfc',
      'c00020': 'fcfcfc',
      '600020': 'b4d8fc'
      // '900000': '90b4fc',
    };

    const hyperColorsBlue = {
      'f1958e': 'd8d8ff',
      'd3565c': 'd8d8ff',
      'c00020': 'b4b4d8',
      '600020': 'a4a4d8'
      // '900000': '6c6cb4',
    };

    const hyperColorsGreen = {
      'f1958e': 'd8fcfc',
      'd3565c': 'd8fcfc',
      'c00020': 'd8fcd8',
      '600020': 'b4fcb4'
      // '900000': '00fc24',
    };

    const hyperColorsYellow = {
      'f1958e': 'd8fcfc',
      'd3565c': 'd8fcfc',
      'c00020': 'd8fcb4',
      '600020': 'd8fc48'
      // '900000': 'd8d800',
    };

    const hyperColorsWhite = {
      'f1958e': 'ffffff',
      'd3565c': 'ffffff',
      'c00020': 'fcfcfc',
      '600020': 'd8d8d8'
      // '900000': 'b4b4b4',
    };

    if (!this.hyperSpriteSheetLoader) {
      this.hyperSpriteSheetLoader = this.png.ready.then(() => this.hyperSpriteSheets = [this.png.recolor(hyperColorsRed).toUrl(), this.png.recolor(hyperColorsCyan).toUrl(), this.png.recolor(hyperColorsPurple).toUrl(), this.png.recolor(hyperColorsWhite).toUrl(), this.png.recolor(hyperColorsGreen).toUrl(), this.png.recolor(hyperColorsBlue).toUrl(), this.png.recolor(hyperColorsYellow).toUrl()]);
    }
  }
  update() {
    if (this.isSuper) {
      if (this.isHyper) {
        if (this.viewport.args.frameId % 15 === 0) {
          this.hyperSheet++;
          if (this.hyperSheet >= this.hyperSpriteSheets.length) {
            this.hyperSheet = 0;
          }
        }
        this.hyperSpriteSheet = this.hyperSpriteSheets[this.hyperSheet];
        this.args.spriteSheet = `url(${this.hyperSpriteSheet})`;
      } else {
        if (this.viewport.args.frameId % 15 === 0) {
          this.superSheet++;
          if (this.superSheet >= this.superSpriteSheets.length) {
            this.superSheet = 0;
          }
        }
        this.superSpriteSheet = this.superSpriteSheets[this.superSheet];
        this.args.spriteSheet = `url(${this.superSpriteSheet})`;
      }
      const tick = this.isHyper ? 30 : 60;
      if (this.viewport.args.frameId % tick === 0) {
        if (this.args.rings < 2) {
          this.isHyper = false;
          this.setProfile();
        }
        if (this.args.rings > 0) {
          this.args.rings--;
        } else {
          this.isSuper = false;
          this.isHyper = false;
          this.setProfile();
        }
      }
    }
    this.args.isSuper = this.isSuper;
    this.args.isHyper = this.isHyper;
    if (!this.args.falling && this.groundTime > 3 || this.args.falling && this.fallTime > 90) {
      this.args.twistRamp = false;
    }
    if (this.args.bellySliding) {
      this.xAxis = 0;
    }
    if (this.args.wasHanging) {
      this.args.flying = false;
    }
    if (this.args.flying) {
      const frontUpSolid = this.getMapSolidAt(this.args.x + this.args.xSpeed, this.args.y + -18);
      const frontSolid = this.getMapSolidAt(this.args.x + this.args.xSpeed, this.args.y);
      const downSolid = this.getMapSolidAt(this.args.x, this.args.y + 1);
      if (frontSolid && !frontUpSolid && !downSolid) while (this.getMapSolidAt(this.args.x + this.args.xSpeed, this.args.y)) {
        this.args.y--;
      }
      if (this.isHyper && this.yAxis < -0.55) {
        this.args.ySpeed -= this.args.slowGravity * 1.1;
      }
      this.args.gravity = this.args.slowGravity;
      this.flyTime++;
    } else {
      this.args.didBoost = false;
      this.args.gravity = this.args.normalGravity;
      this.flyTime = 0;
    }
    if (this.args.dead) {
      this.punching = false;
    }
    if (this.groundTime === 1 && this.punching) {
      this.punching = false;
      this.readyStart(0, 1);
    }
    const falling = this.args.falling;
    const wasMoving = this.args.gSpeed;
    if (!this.box) {
      super.update();
      return;
    }
    if (!this.args.falling && this.readyTime && this.viewport.args.frameId - this.readyTime > 36) {
      this.punched = false;
      this.readying = false;
      this.willPunch = false;
      this.punchTime = false;
      this.readyTime = false;
      this.punching = false;
      if (Math.sign(this.args.punchMomentum) === Math.sign(this.xAxis)) {
        this.args.gSpeed = this.args.punchMomentum;
      }
      this.args.punchMomentum = 0;
    } else if (this.readyTime && this.xAxis && Math.abs(this.args.punchMomentum) < 20) {
      this.args.punchMomentum += this.xAxis * 0.05;
    }
    if (this.throwing && this.viewport.args.frameId - this.throwing > 20) {
      this.throwing = false;
      this.holdBomb = false;
      const bomb = new _KnuxBomb.KnuxBomb({
        x: this.args.x,
        y: this.args.y - 16,
        owner: this,
        xSpeed: this.args.direction * 10 + (-1 + Math.random() * 2),
        ySpeed: Math.random() * -2
      });
      this.viewport.spawn.add({
        object: bomb
      });
    }
    this.readying = false;
    if (this.punchTime && this.viewport.args.frameId - this.punchTime > 15) {
      this.readying = true;
    }
    if (this.punchTime && this.viewport.args.frameId - this.punchTime > 10) {
      this.punching = true;
    }
    if (this.punching) {
      this.args.rolling = false;
    }
    if (this.punching && Math.abs(this.args.gSpeed) > 10) {
      this.auraVisible = true;
      this.viewport.onFrameOut(6, () => {
        this.punchAura.style({
          display: 'none'
        });
        this.auraVisible = false;
      });
      this.punchAura.style({
        display: 'initial'
      });
    } else {
      this.auraVisible = false;
      this.punchAura.style({
        display: 'none'
      });
    }
    this.stayStuck = false;
    this.willStick = false;
    if (this.args.mercy) {
      this.args.flying = false;
    }
    if (this.yAxis === 0) {
      this.args.lookTime = 0;
      this.args.cameraBias = 0;
    }
    if (!falling) {
      this.bombsDropped = 0;
      this.springing = false;
      const direction = this.args.direction;
      const gSpeed = this.args.gSpeed;
      const speed = Math.abs(gSpeed);
      const maxSpeed = this.args.gSpeedMax;
      this.args.knucklesFlyCoolDown = 15;
      this.args.flying = false;
      if (this.args.bellySliding) {
        this.args.animation = 'flying';
      } else if (!this.args.rolling) {
        if (this.args.climbing) {
          const climbDir = this.args.mode === 3 ? -1 : 1;
          if (!this.getMapSolidAt(this.args.x + -climbDir, this.args.y + 1)) {
            this.args.direction = -climbDir;
            this.args.climbing = false;
            this.args.facing = climbDir > 0 ? 'left' : 'rigjt';
            this.args.animation = 'dropping';
            this.args.x += this.args.width * 0.5 * climbDir;
            this.args.groundAngle = 0;
            this.args.falling = true;
            this.args.ySpeed = this.gSpeedLast * (this.args.mode === 3 ? -1 : 1);
            this.args.gSpeed = 0;
            this.args.mode = 0;
            return;
          }
          const ledgeDir = this.args.mode === 1 ? -1 : 1;
          const ledgeDist = 16;
          if (this.args.modeTime < 2 || this.yAxis === 0) {
            if (!this.climbOverCancel) {
              this.args.animation = 'climbing';
              this.args.gSpeed = 0;
            }
          } else if (this.yAxis < -0.55) {
            const isLedge = !this.getMapSolidAt(this.args.x + 1 * ledgeDir, this.args.y - ledgeDist);
            const overLedgeSolid = isLedge && !this.getMapSolidAt(this.args.x + 18 * ledgeDir, this.args.y - ledgeDist);
            if (overLedgeSolid) {
              this.args.animation = 'climbing-over';
              if (!this.climbOverCancel) {
                this.args.ignore = 12;
                this.args.gSpeed = 0;
                this.climbOverCancel = this.viewport.onFrameOut(12, () => {
                  if (this.args.falling) {
                    this.climbOverCancel = false;
                    return;
                  }
                  this.args.x += this.args.width * 0.5 * ledgeDir;
                  this.args.y -= ledgeDist;
                  this.args.direction = ledgeDir;
                  this.args.facing = ledgeDir > 0 ? 'right' : 'left';
                  this.args.climbing = false;
                  this.climbOverCancel = false;
                });
              }
            } else {
              this.args.animation = 'climbing-up';
              if (Math.abs(this.args.gSpeed) < this.climbSpeedMax) {
                const dir = [0, 1, 0, -1][this.args.mode];
                this.args.direction = dir;
                this.args.gSpeed += -dir;
              }
            }
          } else if (this.yAxis > 0.55) {
            this.args.animation = 'climbing-down';
            if (Math.abs(this.args.gSpeed) < this.climbSpeedMax) {
              this.args.direction = this.args.mode === 1 ? 1 : -1;
              this.args.gSpeed += this.args.direction;
            }
            if (this.getMapSolidAt(this.args.x + 8 * -ledgeDir, this.args.y + 16)) {
              this.args.x += this.args.width * 0.5 * -ledgeDir;
              this.args.facing = -ledgeDir > 0 ? 'right' : 'left';
              this.args.mode = 0;
              this.args.groundAngle = 0;
              this.args.falling = true;
              this.args.animation = 'standing';
              this.args.y += 8;
            }
          }
        } else if (Math.sign(this.args.gSpeed) !== direction && Math.abs(this.args.gSpeed - direction) > 5) {
          this.args.animation = 'skidding';
        } else if (this.holdBomb) {
          this.args.animation = 'hold-bomb';
        } else if (this.throwing) {
          this.args.animation = 'throw-bomb';
        } else if (this.readying || this.willPunch) {
          this.args.animation = 'readying';
        } else if (!this.readying && this.punched) {
          if (this.punched % 2) {
            this.args.animation = 'jabbing';
          } else {
            this.args.animation = 'punching';
          }
        } else if (speed > maxSpeed * 0.75) {
          this.args.animation = 'running';
        } else if (this.args.moving && this.args.gSpeed) {
          this.args.animation = 'walking';
        } else if (this.args.teeter) {
          this.args.animation = 'teeter';
          if (this.idleTime > 56) {
            this.args.animation = 'teeter-2';
          }
        } else {
          this.args.animation = 'standing';
        }
      } else {
        this.args.animation = 'rolling';
      }
      if (this.args.grinding) {
        this.args.rolling = false;
        this.args.animation = 'grinding';
      }
    } else {
      this.args.climbing = false;
      if (this.springing) {
        this.args.groundAngle = 0;
      }
      if (this.args.flying) {
        let inWater = false,
          topWater = false;
        const topRegions = this.viewport.regionsAtPoint(this.args.x, this.args.y - 36);
        for (const region of this.regions) {
          if (region.isWater) {
            inWater = true;
          }
        }
        if (Math.abs(this.args.xSpeed) > 6 || Math.abs(this.xAxis) < 0.55 || Math.sign(this.xAxis) === Math.sign(this.args.xSpeed)) {
          if (inWater) {
            this.args.animation = 'swimming';
          } else {
            this.args.animation = 'flying';
          }
        } else if (Math.sign(this.xAxis) !== Math.sign(this.args.xSpeed)) {
          if (Math.abs(this.args.xSpeed) > 3) {
            this.args.animation = 'flying-turning';
          } else {
            this.args.animation = 'flying-stalled';
          }
        }
        if (this.bMap('checkBelow', this.x, this.y).get(_Platformer.Platformer) && !this.args.climbing) {
          // this.args.flying  = false;
          this.args.bellySliding = true;
          this.args.float = 1;
        }
        if (this.yAxis > 0.55) {
          this.args.flying = false;
          this.args.ySpeed = 8;
          return;
        }
        if (this.xAxis) {
          this.args.flyDirection = Math.sign(this.xAxis);
        }
        this.args.direction = Math.sign(this.args.xSpeed);
        if (this.args.direction < 0) {
          this.args.facing = 'left';
        } else {
          this.args.facing = 'right';
        }
        const maxFlySpeed = (16 + 8 * Math.abs(this.xAxis)) * (inWater ? 0.5 : 1);
        if (this.args.flyDirection) {
          if (Math.abs(this.args.xSpeed) < maxFlySpeed) {
            if (this.args.flyDirection !== Math.sign(this.args.xSpeed)) {
              this.args.xSpeed += 0.15625 * Math.sign(this.args.flyDirection) * 4;
            } else {
              this.args.xSpeed += 0.15625 * Math.sign(this.args.flyDirection);
            }
          }
        }
        if (!this.args.didBoost && Math.abs(this.args.xSpeed) > maxFlySpeed) {
          this.args.xSpeed -= 0.1 * (this.args.xSpeed - maxFlySpeed * Math.sign(this.args.xSpeed));
        }
        if (this.args.ySpeed > 2 && Math.abs(this.args.xSpeed) < 4) {
          this.args.xSpeed += 0.1 * Math.sign(this.args.xSpeed);
        }
        if (inWater && this.args.ySpeed > 1) {
          this.args.ySpeed = 1;
        }
        if (!inWater && this.args.ySpeed > 0.5) {
          this.args.ySpeed = 0.5;
        }
        this.willStick = true;
        this.stayStuck = true;
        this.args.groundAngle = 0;
      } else if (this.args.jumping) {
        // if(!this.willPunch && this.punched && this.args.ySpeed > 0)
        // {
        // 	this.args.animation = 'kick';
        // }
        // else

        if ((Math.abs(this.args.punchMomentum) > 8 || this.readyTime) && (this.willPunch || this.punching)) {
          this.args.animation = 'uppercut';
          this.punched++;
          this.punchAura.style({
            display: 'initial'
          });
          this.auraVisible = true;
          this.viewport.onFrameOut(15, () => {
            this.punchAura.style({
              display: 'none'
            });
            this.auraVisible = false;
          });
        } else {
          this.punched = false;
          this.punching = false;
          if (!this.args.bellySliding) {
            this.args.animation = 'jumping';
          }
        }
      }
    }
    if (this.args.flying) {
      this.springing = false;
    } else if (this.args.mode % 2 === 0 || this.args.groundAngle) {
      this.args.flyDirection = 0;
    }
    if (this.args.knucklesFlyCoolDown > 0) {
      this.args.knucklesFlyCoolDown--;
    }
    super.update();
    if (this.willPunch && !wasMoving) {
      this.args.gSpeed = 0;
    }
    if (this.args.mode === 0 || this.args.mode === 2) {
      if (this.args.climbing && this.args.mode === 2) {
        this.args.groundAngle = 0;
        this.args.falling = true;
        this.args.y += this.args.height;
      }
      this.args.climbing = false;
    }
    if (this.args.grinding && !this.args.falling && this.args.gSpeed) {
      this.args.bellySliding = false;
      const sparkParticle = new _Tag.Tag(`<div class = "particle-sparks">`);
      const sparkEnvelope = new _Tag.Tag(`<div class = "envelope-sparks">`);
      sparkEnvelope.appendChild(sparkParticle.node);
      const sparkPoint = this.rotatePoint(-this.args.gSpeed * 1.75 * this.args.direction, 8);
      const flip = Math.sign(this.args.gSpeed);
      sparkEnvelope.style({
        '--x': sparkPoint[0] + this.x,
        '--y': sparkPoint[1] + this.y + Math.random * -3,
        'z-index': 0,
        'animation-delay': -Math.random() * 0.25 + 's',
        '--xMomentum': Math.max(Math.abs(this.args.gSpeed), 4) * flip,
        '--flip': flip,
        '--angle': this.realAngle,
        opacity: Math.random() * 2
      });
      sparkEnvelope.particle = sparkParticle;
      this.viewport.particles.add(sparkEnvelope);
      this.sparks.add(sparkEnvelope);
      this.viewport.onFrameOut(30, () => {
        this.viewport.particles.remove(sparkEnvelope);
        this.sparks.delete(sparkEnvelope);
      });
    }
    if (this.args.grinding) {
      this.args.rolling = false;
      this.args.animation = 'grinding';
    }
    if (this.args.falling && this.springing && this.args.ySpeed >= 0) {
      this.args.animation = 'dropping';
    } else if (this.args.falling && this.springing) {
      this.args.animation = 'springdash';
    }
    if (this.args.hangingFrom) {
      this.args.animation = 'hanging';
    }
    if (this.args.standingOn && this.args.standingOn.isVehicle) {
      this.args.animation = this.args.standingOn.ridingAnimation || 'standing';
    }
    if (this.sparks.size) {
      for (const spark of this.sparks) {
        const sparkPoint = this.rotatePoint(1.75 * this.args.direction, 8);
        spark.style({
          opacity: Math.random() * 2,
          '--x': sparkPoint[0] + this.x,
          '--y': sparkPoint[1] + this.y
        });
      }
    }
    if (this.args.dead) {
      this.args.animation = 'dead';
    }
    if (this.args.twistRamp) {
      this.args.animation = 'side-flip';
    }
  }
  updateEnd() {
    if (!this.args.falling && this.punchTime && this.viewport.args.frameId - this.punchTime > (this.willPunch ? 90 : 30)) {
      this.args.punchMomentum = 0;
      this.punchTime = false;
      this.willPunch = false;
      this.punching = false;
      this.punched = 0;
    }
    if (!this.args.falling) {
      if (this.args.bellySliding) {
        this.args.rolling = false;
        this.args.animation = 'sliding';
        this.alwaysSkidding = true;
        this.slideTime++;
      } else {
        this.alwaysSkidding = false;
        this.slideTime = 0;
      }
      if (Math.abs(this.args.gSpeed) < 1) {
        this.args.bellySliding = false;
      }
    }
    super.updateEnd();
    if (!this.args.falling) {
      this.dashed = false;
    }
  }
  startle() {
    this.args.climbing = false;
    this.willStick = false;
    this.stayStuck = false;
    super.startle();
    this.onNextFrame(() => this.args.animation = 'startle');
  }
  dropBomb() {
    if (this.args.falling) {
      this.args.ySpeed = -8;
    }
    const bomb = new _KnuxBomb.KnuxBomb({
      x: this.args.x,
      y: this.args.y - 16,
      owner: this,
      xSpeed: this.args.xSpeed,
      ySpeed: -3
    });
    ;
    this.viewport.spawn.add({
      object: bomb
    });
  }
  release_0() {
    if (this.args.flying) {
      this.args.flying = false;
      this.args.ySpeed *= 0.25;
    }

    // super.release_0();
  }

  command_0() {
    this.args.bellySliding = false;
    super.command_0();
    if (this.args.hangingFrom || !this.args.jumping || this.willPunch || !this.args.falling) {
      return;
    }
    if (this.args.wasHanging) {
      return;
    }
    if (this.args.falling) {
      this.args.punchMomentum = 0;
      this.punching = false;
    }
    if (this.args.ignore) {
      return;
    }
    this.args.direction = Math.sign(this.args.xSpeed) || (this.args.facing === 'left' ? -1 : 1);
    this.args.willJump = false;
    this.args.flying = true;
    this.args.xSpeed = Math.max(4, Math.abs(this.args.xSpeed)) * this.args.direction;
    this.args.ySpeed = Math.max(0, this.args.ySpeed);
  }
  readyStart() {
    let inputDirection = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    let button = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    if (this.readyTime && this.viewport.args.frameId - this.readyTime > 20) {
      return;
    }
    this.readyTime = this.viewport.args.frameId;
    if (this.args.flying || this.args.climbing || this.args.falling) {
      return;
    }
    this.readyButton = button;
    if (this.punchTime && this.viewport.args.frameId - this.punchTime < 9) {
      this.args.punchMomentum = 0;
      // this.args.ignore = 16;
      this.willPunch = false;
      this.punchTime = false;
      this.punched = 0;
      return;
    }
    this.willPunch = true;
    const direction = Math.sign(this.xAxis || inputDirection || this.args.direction);
    this.args.direction = Math.sign(direction || this.args.punchMomentum);
    if (direction < 0) {
      this.args.facing = 'left';
    } else {
      this.args.facing = 'right';
    }
    if (this.punchTime) {
      this.args.gSpeed = 0;
      this.punchTime = false;
      return;
    }
    this.args.punchMomentum = Math.abs(this.args.punchMomentum || this.args.gSpeed || 4) * Math.sign(direction || this.xAxis);
    this.args.gSpeed = 0;
  }
  damage(other, type) {
    if (this.readyTime) {
      return false;
    }
    super.damage(other, type);
  }
  readyStop(inputDirection, button) {
    this.readyTime = false;
    if (this.readyButton !== button) {
      return;
    }
    this.readyButton = false;
    if (this.args.flying || this.args.climbing || this.args.falling) {
      return;
    }
    if (this.punchTime && this.viewport.args.frameId - this.punchTime < 64) {
      this.willPunch = false;
      // this.args.punchMomentum = 0;
      this.punched = 0;
      return;
    }
    this.args.direction = this.args.facing === 'left' ? -1 : 1;
    const direction = this.args.direction;
    if (!direction || Math.sign(direction) === Math.sign(this.args.punchMomentum)) {
      this.args.gSpeed = direction ? Math.abs(this.args.punchMomentum) * direction : this.args.punchMomentum;
    } else if (direction) {
      this.args.punchMomentum = Math.abs(this.args.punchMomentum) * direction;
      this.args.gSpeed = 1 * (direction ? Math.abs(this.args.punchMomentum) * direction : this.args.punchMomentum);
    }
    this.args.direction = Math.sign(direction || this.args.punchMomentum);
    if (direction < 0) {
      this.args.facing = 'left';
    } else {
      this.args.facing = 'right';
    }
    this.punchTime = this.viewport.args.frameId;
    this.willPunch = false;
    if (!this.args.falling && this.args.gSpeed) {
      const dustParticle = new _Tag.Tag(`<div class = "particle-dust">`);
      const dustDist = Math.sign(this.args.gSpeed) * this.dustDist || 0;
      const dustPoint = this.rotatePoint(this.args.gSpeed, 0);
      dustParticle.style({
        '--x': dustPoint[0] + dustDist + this.x,
        '--y': dustPoint[1] + this.y,
        'z-index': 0,
        opacity: Math.random() ** 2 * 0.5 + 0.5
      });
      viewport.particles.add(dustParticle);
      viewport.onFrameOut(20, () => {
        viewport.particles.remove(dustParticle);
      });
    }
    if (this.throwing || this.args.climbing) {
      return;
    }
    this.punched++;
  }
  command_1() {
    if (this.args.climbing) {
      this.args.x += this.args.width / 2 * (this.args.mode === 1 ? 1 : -1);
      this.bMap('doJump', 0);
      return;
    }
    if (this.args.falling) {
      this.readyStart(0, 1);
      return;
    }
    if (this.cancelReady) {
      this.cancelReady();
      this.cancelReady = false;
    }
    this.args.direction = this.args.facing === 'left' ? -1 : 1;
    this.args.punchMomentum = this.args.punchMomentum || this.args.gSpeed || 3 * (this.args.direction || 1);
    if (!this.args.gSpeed || !this.punched) {
      this.readyButton = 1;
      this.punching = true;
      this.readyStop(Math.sign(this.args.punchMomentum), 1);
      this.cancelReady = this.viewport.onFrameOut(20, () => this.readyStart(this.args.direction, 1));
      return;
    }
    if (this.args.gSpeed > 10) {
      this.punchAura.style({
        display: 'initial'
      });
      this.auraVisible = true;
    }
    this.punched = this.punched || 1;
    this.args.gSpeed = 0;
    this.readyStart(0, 1);
  }
  release_1() {
    if (this.args.falling) {
      return;
    }
    if (this.willPunch) {
      this.readyStop(0, 1);
      return;
    }
    if (this.punchTime && this.viewport.args.frameId - this.punchTime < 220) {
      return;
    }
    if (this.punchTime && this.viewport.args.frameId - this.punchTime > 320) {
      return;
    }
    if (this.args.gSpeed) {
      return;
    }

    // this.args.gSpeed = 0;

    if (!this.cancelReady) {
      this.cancelReady = this.viewport.onFrameOut(40, () => this.readyStart(this.args.direction, 1));
    }
  }
  command_4() {
    this.readyStart(-1, 4);
  }
  release_4() {
    this.readyStop(-1, 4);
  }
  command_5() {
    this.readyStart(1, 5);
  }
  release_5() {
    this.readyStop(1, 5);
  }
  command_2() {
    // if(!this.args.ignore && this.args.falling && !this.args.flying && this.bombsDropped < 3)
    // {
    // 	this.dropBomb();

    // 	this.bombsDropped++;

    // 	return;
    // }

    // if(this.args.falling || this.args.climbing)
    // {
    // 	return;
    // }

    // if(Math.abs(this.args.gSpeed) > 3)
    // {
    // 	return;
    // }

    // if(this.punchTime || this.throwing)
    // {
    // 	return;
    // }

    // this.holdBomb = this.viewport.args.frameId;
    // this.args.ignore = -1;
    // this.args.gSpeed = 0;
  }
  release_2() {
    if (this.args.falling || this.args.climbing) {
      return;
    }
    if (Math.abs(this.args.gSpeed) > 3) {
      return;
    }
    if (!this.holdBomb) {
      return;
    }
    this.args.ignore = 4;
    this.holdBomb = false;
    this.throwing = this.viewport.args.frameId;
  }
  setCameraMode() {
    if (this.args.climbing) {
      this.args.cameraMode = 'climbing';
    } else {
      super.setCameraMode();
    }
  }
  collideA(other) {
    if (other instanceof _Spring.Spring) {
      this.onNextFrame(() => {
        if (!this.args.falling || this.args.hangingFrom) {
          return;
        }
        this.springing = true;
        this.args.animation = 'springdash';
      });
    }
    if (other.pop && this.isHyper) {
      other.pop(this);
    }
  }
  rotateMainColor() {
    let rH = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    let rS = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    let rV = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    const rotatedColors = {
      'f1958e': new _Color.Color('f1958e').rotate(rH, rS, rV).toString(),
      'd3565c': new _Color.Color('d3565c').rotate(rH, rS, rV).toString(),
      'c00020': new _Color.Color('c00020').rotate(rH, rS, rV).toString(),
      // // '900000': new Color('900000').rotate(rH, rS, rV).toString(),
      '600020': new _Color.Color('600020').rotate(rH, rS, rV).toString()
    };
    this.png.ready.then(() => {
      const newPng = this.png.recolor(rotatedColors);
      this.args.rotatedSpriteSheet = this.rotatedSpriteSheet = this.spriteSheet = newPng.toUrl();
      this.args.spriteSheet = `url('${this.args.rotatedSpriteSheet}')`;
    });
  }
  setProfile() {
    if (this.isHyper) {
      this.args.spriteSheet = `url('${this.hyperSpriteSheet}')`;
      this.args.gSpeedMax = this.gSpeedMaxHyper;
      this.args.jumpForce = this.jumpForceHyper;
      this.climbSpeedMax = this.climbSpeedMaxSuper;
      this.args.accel = this.accelSuper;
    } else if (this.isSuper) {
      this.args.spriteSheet = `url('${this.superSpriteSheet}')`;
      this.args.gSpeedMax = this.gSpeedMaxSuper;
      this.args.jumpForce = this.jumpForceSuper;
      this.climbSpeedMax = this.climbSpeedMaxSuper;
      this.args.accel = this.accelSuper;
    } else {
      this.args.spriteSheet = `url('${this.rotatedSpriteSheet}')`;
      this.args.gSpeedMax = this.gSpeedMaxNormal;
      this.args.jumpForce = this.jumpForceNormal;
      this.climbSpeedMax = this.climbSpeedMaxNormal;
      this.args.accel = this.accelNormal;
    }
  }
  command_3() {}
  get solid() {
    return false;
  }
  get canRoll() {
    return !this.args.climbing;
  }
  get canFly() {
    return true;
  }
  get isEffect() {
    return false;
  }
  get controllable() {
    return !this.args.npc;
  }
}
exports.Knuckles = Knuckles;
});

;require.register("actor/KnuxBomb.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KnuxBomb = void 0;
var _PointActor = require("./PointActor");
var _Explosion = require("../actor/Explosion");
var _Tag = require("curvature/base/Tag");
var _Region = require("../region/Region");
var _Spring = require("./Spring");
class KnuxBomb extends _PointActor.PointActor {
  constructor() {
    super(...arguments);
    this.args.type = 'actor-item actor-knux-bomb';
    this.args.width = 16;
    this.args.height = 16;
    this.removeTimer = null;
  }
  update() {
    if (this.removed) {
      return;
    }
    super.update();
    if (!this.args.xSpeed && !this.args.ySpeed && !this.args.gSpeed) {
      this.removeTimer = this.onTimeout(250, () => this.explode());
    }
    if (!this.removeTimer) {
      this.removeTimer = this.onTimeout(1500, () => this.explode());
    }
  }

  // collideA(other)
  // {
  // 	if(other === this.args.owner || other instanceof KnuxBomb || other instanceof Region || other instanceof Spring)
  // 	{
  // 		return false;
  // 	}

  // 	this.args.x += Math.cos(this.args.angle) * other.args.width / 2 * Math.sign(this.args.xSpeed);
  // 	this.args.y += Math.sin(this.args.angle) * other.args.width / 2 * Math.sign(this.args.xSpeed);

  // 	this.explode();

  // 	return false;
  // }

  explode() {
    const viewport = this.viewport;
    if (!viewport) {
      return;
    }
    const particle = new _Tag.Tag('<div class = "particle-explosion">');
    particle.style({
      '--x': this.x,
      '--y': this.y
    });
    viewport.particles.add(particle);
    setTimeout(() => viewport.particles.remove(particle), 350);
    this.viewport.actors.remove(this);
    this.remove();
  }
  get canStick() {
    return false;
  }
  get solid() {
    return false;
  }
}
exports.KnuxBomb = KnuxBomb;
});

;require.register("actor/LavaBall.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LavaBall = void 0;
var _PointActor = require("./PointActor");
class LavaBall extends _PointActor.PointActor {
  constructor() {
    super(...arguments);
    this.args.width = 16;
    this.args.height = 16;
    this.args.float = 0;
    this.args.type = 'actor-item actor-lava-ball';
    this.args.jumpForce = 7.25;
    this.args.gravity = 0.2;
    this.args.density = 25;
  }
  onRendered() {
    super.onRendered();
    this.autoAttr.get(this.box)['data-color'] = 'color';
  }
  update() {
    super.update();
    const age = this.viewport.args.frameId + (this.args.offset || 0);
    if (age % 45 === 0) {
      this.willJump = true;
    }
    this.args.hidden = !this.willJump && !this.args.falling;
  }
  collideA(other, type) {
    if (other.controllable && this.args.falling) {
      other.damage(this);
    }
    return super.collideA(other, type);
  }
}
exports.LavaBall = LavaBall;
});

;require.register("actor/LayerController.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LayerController = void 0;
var _PointActor = require("./PointActor");
class LayerController extends _PointActor.PointActor {
  constructor(args, parent) {
    var _this$args$fall, _this$args$yQuake;
    super(args, parent);
    this.args.activated = false;
    this.args.xLayer = 0;
    this.args.yLayer = 0;
    this.args.xLayerSpeed = 0;
    this.args.yLayerSpeed = 0;
    this.args.yLayerSpeedMax = this.args.yLayerSpeedMax || 9;
    this.args.fall = (_this$args$fall = this.args.fall) !== null && _this$args$fall !== void 0 ? _this$args$fall : true;
    this.args.xLayerLimit = this.args.xLayerLimit || null;
    this.args.yLayerLimit = this.args.yLayerLimit || null;
    this.args.yQuake = (_this$args$yQuake = this.args.yQuake) !== null && _this$args$yQuake !== void 0 ? _this$args$yQuake : 5;
    this.args.static = true;
    this.args.hidden = true;
  }
  updateStart() {
    if (!this.viewport) {
      return;
    }
    if (this.args.activated && this.args.fall) {
      this.args.yLayerSpeed += 0.25;
    }
    if (this.args.activated && this.args.swim) {
      this.args.xLayerSpeed += 1;
    }
    if (this.args.yLayerSpeed > this.args.yLayerSpeedMax && this.args.yLayerSpeedMax > 0) {
      this.args.yLayerSpeed = this.args.yLayerSpeedMax;
    }
    if (this.args.xLayerSpeed > this.args.xLayerSpeedMax && this.args.xLayerSpeedMax > 0) {
      this.args.xLayerSpeed = this.args.xLayerSpeedMax;
    }
    if (this.args.yLayerSpeed) {
      this.args.yLayer = Math.round(this.args.yLayer + this.args.yLayerSpeed || 0);
    }
    if (this.args.xLayerSpeed) {
      this.args.xLayer = Math.round(this.args.xLayer + this.args.xLayerSpeed || 0);
    }
    const tileSize = this.viewport.tileMap.mapData.tileheight;
    const xMapTiles = this.viewport.tileMap.mapData.width;
    const yMapTiles = this.viewport.tileMap.mapData.height;
    const mapWidth = this.viewport.tileMap.meta.wrapX ? Infinity : xMapTiles * tileSize;
    const mapHeight = this.viewport.tileMap.meta.wrapY ? Infinity : yMapTiles * tileSize;
    if (this.args.yLayerLimit > 0 && this.args.yLayer > mapHeight && this.args.yLayer > this.args.yLayerLimit) {
      this.args.yLayerSpeed = 0;
      this.args.yLayer = this.args.yLayerLimit;
      if (this.args.target) {
        const target = this.viewport.actorsById[this.args.target];
        this.viewport.auras.delete(target);
      }
      this.viewport.auras.delete(this);
    }
    if (this.args.xLayerLimit > 0 && (this.args.xLayer > mapWidth || this.args.xLayer > this.args.xLayerLimit)) {
      this.args.xLayerSpeed = 0;
      this.args.xLayer = this.args.xLayerLimit;
      if (this.args.target) {
        const target = this.viewport.actorsById[this.args.target];
        this.viewport.auras.delete(target);
      }
      this.viewport.auras.delete(this);
    }
  }
  activate(other, button) {
    var _this$args$yLayerLimi;
    if (this.args.activated) {
      return;
    }
    if (other) {
      this.args.x = other.x;
      this.args.y = other.y;
    }
    this.viewport.auras.add(this);
    this.viewport.args.shakeY = this.args.yQuake;
    this.viewport.onFrameOut(90, () => {
      this.args.activated = true;
    });
    this.args.yLayerLimit = (_this$args$yLayerLimi = this.args.yLayerLimit) !== null && _this$args$yLayerLimi !== void 0 ? _this$args$yLayerLimi : 4096;
    if (this.args.target && this.viewport.actorsById[this.args.target]) {
      const target = this.viewport.actorsById[this.args.target];
      this.viewport.auras.add(target);
      target.activate(other, this);
    }
  }
}
exports.LayerController = LayerController;
});

;require.register("actor/LayerSwitch.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LayerSwitch = void 0;
var _PointActor = require("./PointActor");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class LayerSwitch extends _PointActor.PointActor {
  static fromDef(objDef) {
    const obj = super.fromDef(objDef);
    obj.args.width = objDef.width;
    obj.args.height = objDef.height;
    return obj;
  }
  onAttach(event) {
    event && event.preventDefault();
    return false;
  }
  constructor() {
    var _this$args$fromLayer, _this$args$toLayer;
    super(...arguments);
    _defineProperty(this, "float", -1);
    this.args.type = 'actor-item actor-layer-switch';
    this.args.width = 32;
    this.args.height = 32;
    this.args.static = true;
    this.args.fromLayer = (_this$args$fromLayer = this.args.fromLayer) !== null && _this$args$fromLayer !== void 0 ? _this$args$fromLayer : 1;
    this.args.toLayer = (_this$args$toLayer = this.args.toLayer) !== null && _this$args$toLayer !== void 0 ? _this$args$toLayer : 2;
  }
  collideA(other, type) {
    let speed = other.args.gSpeed || other.args.xSpeed || other.args.direction || other.xAxis;
    let back = !!Number(this.args.back);
    let roll = !!Number(this.args.roll);
    other.collisionMapFrame = -1;
    const invert = other.args.mode === 2 || other.args.mode === 3 ? -1 : 1;
    const radius = this.args.width / 2;
    const otherRadius = 0; //other.args.width / 2;

    const thisX = this.args.x;
    const thisY = this.args.y;
    const otherX = other.args.x;
    const otherY = other.args.y;
    if (otherX < thisX + -radius + otherRadius || otherX > thisX + radius + -otherRadius) {
      return;
    }
    if (otherY < thisY + -this.args.height || other.y > thisY) {
      return;
    }
    if (this.args.allow || this.args.disallow) {
      if (this.args.allow) {
        other.doorMap.set(Number(this.args.allow), false);
      }
      if (this.args.disallow) {
        other.doorMap.set(Number(this.args.disallow), true);
      }
      return;
    }
    if (roll && (!other.args.rolling || other.args.height > 28)) {
      other.args.layer = toLayer === this.args.fromLayer ? this.args.toLayer : this.args.fromLayer;
      return false;
    }
    if (back && other.args.falling) {
      speed = other.args.xSpeed || other.args.direction;
      back = !back;
    }
    let toLayer = other.args.layer;
    let fromLayer = this.args.fromLayer;
    if (speed > 0) {
      toLayer = back ? this.args.fromLayer : this.args.toLayer;
      fromLayer = back ? this.args.toLayer : this.args.fromLayer;
    }
    if (speed < 0) {
      toLayer = back ? this.args.toLayer : this.args.fromLayer;
      fromLayer = back ? this.args.fromLayer : this.args.toLayer;
    }
    if (!this.viewport.tileMap.getSolid(otherX, otherY, toLayer)) {
      if (!other.args.layer || other.args.layer === fromLayer) {
        other.args.layer = toLayer;
      }
    } else {
      this.viewport.onFrameOut(1, () => {
        if (!this.viewport.tileMap.getSolid(otherX, otherY, toLayer)) {
          other.args.layer = toLayer;
        }
      });
    }
  }
  get solid() {
    return false;
  }
  get isEffect() {
    return true;
  }
}
exports.LayerSwitch = LayerSwitch;
});

;require.register("actor/LightSource.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LightSource = void 0;
var _PointActor = require("./PointActor");
class LightSource extends _PointActor.PointActor {
  static fromDef(objDef) {
    const obj = super.fromDef(objDef);
    if (objDef.polygon) {
      obj.args.polygon = objDef.polygon.map(p => Object.assign({}, p));
    }
    return obj;
  }
  constructor() {
    super(...arguments);
    this.args.type = 'actor-item actor-light-source';
    this.args.hidden = true;
    this.args.static = true;
    this.args.float = -1;
  }
  get solid() {
    return false;
  }
}
exports.LightSource = LightSource;
});

;require.register("actor/Magnet.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Magnet = void 0;
var _PointActor = require("./PointActor");
var _Mixin = require("curvature/base/Mixin");
var _Constrainable = require("../mixin/Constrainable");
class Magnet extends _Mixin.Mixin.from(_PointActor.PointActor, _Constrainable.Constrainable) {
  constructor() {
    super(...arguments);
    this.args.gravity = 0.8;
    this.args.width = 48;
    this.args.height = 28;
    this.args.type = 'actor-item actor-magnet';
  }
  collideA(other, type) {}
  collideB(other) {
    if (other.controllable) {
      // other.startle();
    }
  }
  update() {
    super.update();
    this.setPos();
  }
}
exports.Magnet = Magnet;
});

;require.register("actor/MarbleBlock.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MarbleBlock = void 0;
var _PointActor = require("./PointActor");
var _Platformer = require("../behavior/Platformer");
class MarbleBlock extends _PointActor.PointActor {
  constructor() {
    super(...arguments);
    this.args.type = 'actor-item actor-block-marble';
    this.args.width = 32;
    this.args.height = 32;
    this.args.spriteSheet = this.args.spriteSheet || '/Sonic/marble-zone-block.png';
  }
  collideA(other, type) {
    super.collideA(other, type);
    if (other.isEffect) {
      return false;
    }
    if (!this.isPushable) {
      return true;
    }
    const otherMag = Math.ceil(Math.abs(other.args.gSpeed || other.args.xSpeed));
    const otherDir = Math.sign(other.args.gSpeed || other.args.xSpeed);
    let otherSpeed = otherMag * otherDir;
    if (!this.args.falling && type === 1 && otherSpeed <= 0) {
      return false;
    }
    if (!this.args.falling && type === 3 && otherSpeed >= 0) {
      return false;
    }
    const blockTop = this.y - this.args.height;
    if ((type === 1 || type === 3) && (other.y >= this.y || other.y > blockTop)) {
      if (!otherSpeed) {
        return true;
      }
      this.args.pushed = Math.sign(other.args.gSpeed) || this.args.pushed;
      if (this.args.pushed < 0 && this.getMapSolidAt(this.x - Math.ceil(this.args.width / 2) + -1, this.y + -4)) {
        return true;
      }
      if (this.args.pushed > 0 && this.getMapSolidAt(this.x + Math.ceil(this.args.width / 2) + 1, this.y + -4)) {
        return true;
      }
      const tileMap = this.viewport.tileMap;
      const moveBy = type === 1 && 1 || type === 3 && -1;
      const blockers = tileMap.getSolid(this.x + Math.ceil(this.args.width / 2) * moveBy, this.y + -4);
      if (blockers) {
        return true;
      }
      const radius = this.args.width / 2;
      if (!this.args.falling) {
        const nextCenter = this.bMap('findNextStep', moveBy).get(_Platformer.Platformer);
        // const nextWall   = this.bMap('findNextStep', moveBy + (radius * Math.sign(moveBy))).get(Platformer);

        if (nextCenter[2]) {
          // this.args.xSpeed = moveBy;

          const scan = this.scanBottomEdge(moveBy);
          if (scan && scan <= (this.args.width + this.args.width % 2) * 0.5) {
            this.args.xSpeed = Math.sign(moveBy);
            this.args.x += scan * Math.sign(moveBy);
          }

          // this.args.falling = true;
        } else if (!nextCenter[3]) {
          const otherRadius = other.args.width / 2;
          const myRadius = this.args.width / 2;
          if (Math.trunc(Math.abs(this.x - other.x)) <= 1 + otherRadius + myRadius) {
            // this.args.x = other.args.x + (moveBy * (Math.abs(other.args.gSpeed) + myRadius + otherRadius));
            this.args.x += nextCenter[0];
            this.args.y -= nextCenter[1];
            const direction = Math.sign(other.args.gSpeed);
            if (Math.sign(this.x - other.x) === direction) {
              other.args.pushing = direction;
              // other.args.rolling = false;
            }

            const weightRatio = this.args.weight / other.args.weight;
            other.args.gSpeed -= weightRatio * 0.005 * Math.sign(other.args.gSpeed);
          }
          return false;
        }
        return true;
      }
    }
    if (other.args.ySpeed < 0) {
      return false;
    }
    return true;
  }
  onAttach() {
    this.args.spriteSheet = this.args.spriteSheet || '/Sonic/marble-zone-block.png';
    if (this.viewport) {
      this.setTile();
    }
  }
  get isPushable() {
    return true;
  }
  get canStick() {
    return false;
  }
  get solid() {
    return true;
  }
  get rotateLock() {
    return true;
  }
}
exports.MarbleBlock = MarbleBlock;
});

;require.register("actor/Marker.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Marker = void 0;
var _PointActor = require("./PointActor");
class Marker extends _PointActor.PointActor {
  constructor() {
    super(...arguments);
    this.args.type = 'actor-item actor-marker';
    this.args.width = 64;
    this.args.height = 64;
    this.args.float = -1;
  }
  get solid() {
    return false;
  }
}
exports.Marker = Marker;
});

;require.register("actor/Meanie.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Meanie = void 0;
var _Flickie = require("./Flickie");
var _Mixin = require("curvature/base/Mixin");
var _PointActor = require("./PointActor");
var _Patrol = require("../behavior/Patrol");
var _CanPop = require("../mixin/CanPop");
var _ObjectPalette = require("../ObjectPalette");
class Meanie extends _Mixin.Mixin.from(_PointActor.PointActor, _CanPop.CanPop) {
  constructor() {
    var _this$args$patrolPaus, _this$args$patrolBeat, _this$args$patrolSpee, _this$args$hatType;
    super(...arguments);
    this.behaviors.add(new _Patrol.Patrol());
    this.args.type = 'actor-item actor-meanie';
    this.args.animation = 'standing';
    this.args.accel = 0.1;
    this.args.decel = 0.5;
    this.args.gSpeedMax = 5;
    this.args.jumpForce = 5;
    this.args.gravity = 0.5;
    this.args.width = 16;
    this.args.height = 29;
    this.willStick = false;
    this.stayStuck = false;
    this.args.patrolPause = (_this$args$patrolPaus = this.args.patrolPause) !== null && _this$args$patrolPaus !== void 0 ? _this$args$patrolPaus : 40;
    this.args.patrolBeat = (_this$args$patrolBeat = this.args.patrolBeat) !== null && _this$args$patrolBeat !== void 0 ? _this$args$patrolBeat : 140;
    this.args.patrolSpeed = (_this$args$patrolSpee = this.args.patrolSpeed) !== null && _this$args$patrolSpee !== void 0 ? _this$args$patrolSpee : 1;

    // this.args.hatType = this.args.hatType ?? 'skull';
    this.args.hatType = (_this$args$hatType = this.args.hatType) !== null && _this$args$hatType !== void 0 ? _this$args$hatType : 'pumpkin';
    this.args.maxBoost = 0;
  }
  wakeUp(event) {
    if (!this.viewport) {
      return;
    }
    if (!this.hat && _ObjectPalette.ObjectPalette[this.args.hatType]) {
      this.hat = new _ObjectPalette.ObjectPalette[this.args.hatType]();
      this.viewport.spawn.add({
        object: this.hat
      });
      this.hat.args.float = -1;
      this.hat.noClip = true;
      this.hat.args.x = this.args.x;
      this.hat.args.y = this.args.y + 14;
      this.viewport.setColCell(this.hat);
      if (this.args.hatType) {
        this.hat.args.face = true;
      }
    }
  }
  update() {
    this.args.maxBoost = Math.max(this.args.ySpeed, this.args.maxBoost);
    const direction = this.args.direction;
    const telegraph = this.args.shotTelegraph;
    const beat = this.args.patrolBeat;
    if (this.box) {
      if (this.args.moving && this.args.gSpeed) {
        this.box.setAttribute('data-animation', 'walking');
      } else {
        this.box.setAttribute('data-animation', 'standing');
      }
    }
    super.update();
    this.args.groundAngle = 0;
    this.args.mode = 0;
    this.args.direction = Math.sign(this.args.xSpeed || this.args.gSpeed);
    if (!this.args.falling && !this.jumpTimer) {
      this.jumpTimer = this.viewport.onFrameOut(2, () => {
        this.args.ySpeed = -Math.min(this.args.maxBoost, 9);
        this.args.xSpeed = this.args.gSpeed;
        this.args.falling = true;
        this.fallTime = 0;
        this.jumpTimer = false;
      });
    }
    if (this.hat) {
      this.hat.args.direction = this.args.direction;
      this.hat.args.x = this.args.x;
      this.hat.args.y = this.args.y;
      if (this.fallTime > 9 || this.fallTime < 5) {
        this.hat.args.y += -14;
      } else {
        this.hat.args.y += -10;
      }
      this.hat.args.z = this.args.z + 1;
      if (this.viewport) {
        this.viewport.setColCell(this.hat);
      }
    }
  }
  effect(other) {
    super.effect(other);

    // this.viewport.spawn.add({object:new Flickie({
    // 	x: this.args.x,
    // 	y: this.args.y,
    // })});
  }

  pop(other) {
    if (other && !other.controllable) {
      return;
    }
    if (this.hat) {
      const hat = this.hat;
      this.viewport.onFrameOut(3, () => {
        if (other) {
          this.args.xSpeed += -2 * (Math.sign(other.args.xSpeed || other.args.gSpeed) || 1);
          hat.args.xSpeed = -4 * (Math.sign(other.args.xSpeed || other.args.gSpeed) || 1);
          hat.args.ySpeed = Math.min(-4, -Math.abs(other.args.ySpeed));
          hat.args.float = 1;
        } else {
          hat.args.float = 10;
        }
        hat.noClip = false;
        this.hat = null;
      });
      if (other && !other.args.rolling) {
        this.ignores.set(other, 10);
        other.args.gSpeed *= -1;
        other.args.xSpeed *= -1;
        other.args.ySpeed = -4;
        other.args.xSpeed = Math.min(Math.abs(other.args.xSpeed), 6) * Math.sign(other.args.xSpeed);
        return;
      }
    }
    return super.pop(other);
  }
  get solid() {
    return false;
  }
  get isEffect() {
    return false;
  }
  // get controllable() { return true; }
}
exports.Meanie = Meanie;
});

;require.register("actor/MechaFroggy.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MechaFroggy = void 0;
var _PointActor = require("./PointActor");
var _Tag = require("curvature/base/Tag");
var _SkidDust = require("../behavior/SkidDust");
var _Explosion = require("../actor/Explosion");
var _Projectile = require("../actor/Projectile");
class MechaFroggy extends _PointActor.PointActor {
  constructor() {
    super(...arguments);
    this.behaviors.add(new _SkidDust.SkidDust());
    this.args.type = 'actor-item actor-mecha-froggy';
    this.args.animation = 'standing';
    this.args.accel = 0.7;
    this.args.decel = 0.5;
    this.args.gSpeedMax = 10;
    this.args.jumpForce = 15;
    this.args.gravity = 0.5;
    this.args.width = 15;
    this.args.height = 32;
    this.willStick = false;
    this.stayStuck = false;
  }
  update() {
    const direction = this.args.direction;
    if (!this.flame) {
      this.flame = new _Tag.Tag('<div class = "mecha-froggy-flame">');
      this.sprite.appendChild(this.flame.node);
    }
    if (!this.args.jumping || this.args.falling) {
      if (Math.sign(this.args.gSpeed) !== direction && Math.abs(this.args.gSpeed - direction) > 5) {
        this.box.setAttribute('data-animation', 'skidding');
      } else if (this.args.moving && this.args.gSpeed && Math.abs(this.args.gSpeed) >= 10) {
        this.box.setAttribute('data-animation', 'running');
      } else if (this.args.moving && this.args.gSpeed && Math.abs(this.args.gSpeed)) {
        this.box.setAttribute('data-animation', 'walking');
      } else {
        this.box.setAttribute('data-animation', 'standing');
      }
    }
    if (this.args.jumping) {
      this.box.setAttribute('data-animation', 'jumping');
    }
    super.update();
  }
  get solid() {
    return false;
  }
  get isEffect() {
    return false;
  }
  get controllable() {
    return true;
  }
}
exports.MechaFroggy = MechaFroggy;
});

;require.register("actor/MechaSonic.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MechaSonic = void 0;
var _PointActor = require("./PointActor");
var _Platformer = require("../behavior/Platformer");
var _Vehicle = require("./Vehicle");
var _Tag = require("curvature/base/Tag");
var _Sfx = require("../audio/Sfx");
var _SkidDust = require("../behavior/SkidDust");
class MechaSonic extends _PointActor.PointActor {
  constructor() {
    super(...arguments);
    this.behaviors.add(new _SkidDust.SkidDust('particle-sparks'));
    this.args.type = 'actor-item actor-mecha-sonic';
    this.args.accel = 0.1;
    this.args.decel = 0.3;
    this.args.skidTraction = 2;
    this.args.gSpeedMax = 18;
    this.args.jumpForce = 11;
    this.args.gravity = 0.5;
    this.args.takeoffPlayed = false;
    this.args.rollingHeight = 28;
    this.args.normalHeight = 44;
    this.args.width = 18;
    this.args.height = this.args.normalHeight;
    this.args.bindTo('falling', v => {
      if (!v) {
        this.landSound();
      }
    });
  }
  onRendered(event) {
    super.onRendered(event);
    this.box = this.findTag('div');
    this.sprite = this.findTag('div.sprite');
  }
  update() {
    if (!this.sprite) {
      return;
    }
    const falling = this.args.falling;
    this.args.accel = 0.1;
    const direction = this.args.direction;
    const gSpeed = this.args.gSpeed;
    const speed = Math.abs(gSpeed);
    const maxSpeed = 100;
    const minRun = 100 * 0.1;
    const minRun2 = 0.5 * this.args.gSpeedMax;
    if (!this.flame) {
      this.sparks = new _Tag.Tag('<div class = "mecha-sonic-sparks">');
      this.flame = new _Tag.Tag('<div class = "mecha-sonic-flame">');
      this.sprite.appendChild(this.sparks.node);
      this.sprite.appendChild(this.flame.node);
    }
    if (this.viewport.args.audio && !this.thrusterSound) {
      this.thrusterSound = new Audio('/Sonic/mecha-sonic-thruster.wav');
      this.scrapeSound = new Audio('/Sonic/mecha-sonic-scrape.wav');
      this.scrapeSound.volume = 0.1;
      this.thrusterSound.loop = true;
      this.scrapeSound.loop = true;
    }
    if (this.thrusterSound) {
      this.thrusterSound.volume = 0.15 + Math.random() * -0.05;
      if (this.thrusterSound.currentTime > 1.5) {
        this.thrusterSound.currentTime = 0.5;
      }
      if (this.scrapeSound.currentTime > 1.5) {
        this.scrapeSound.currentTime = 0.5;
      }
    }
    if (!falling) {
      this.dashed = false;
    }
    if (!this.args.rolling && !falling) {
      if (this.yAxis > 0) {
        this.args.crouching = true;
      } else {
        this.args.crouching = false;
      }
      if (Math.sign(this.args.gSpeed) !== direction && Math.abs(this.args.gSpeed - direction) > 5) {
        this.scrapeSound && this.scrapeSound.play();
        this.args.animation = 'skidding';
      } else if (speed >= minRun2) {
        this.scrapeSound && this.scrapeSound.pause();
        this.args.animation = 'running2';
        this.thrusterSound && this.thrusterSound.play();
        if (!this.args.takeoffPlayed) {
          this.args.takeoffPlayed = true;
          _Sfx.Sfx.play('MECHASONIC_TAKEOFF');
        }
        this.args.accel = 0.75;
        if (speed > maxSpeed * 0.75) {
          this.args.accel = 0.03;
        }
      } else if (speed >= minRun) {
        this.scrapeSound && this.scrapeSound.play();
        this.args.animation = 'running';
      } else if (this.args.moving && gSpeed) {
        this.scrapeSound && this.scrapeSound.play();
        if (this.args.animation === 'curling' || this.args.animation === 'jumping' || this.args.animation === 'rolling') {
          this.args.animation = 'uncurling';
          this.onTimeout(128, () => {
            this.args.animation = 'walking';
          });
        } else if (this.args.animation === 'standing' || this.args.animation === 'running' || this.args.animation === 'running2') {
          this.args.animation = 'walking';
        }
      } else if (this.args.crouching || this.standingOn && this.standingOn.isVehicle) {
        this.args.animation = 'crouching';
      } else {
        this.scrapeSound && this.scrapeSound.pause();
        if (this.args.animation === 'curling' || this.args.animation === 'jumping' || this.args.animation === 'rolling') {
          this.args.animation = 'uncurling';
          this.onTimeout(128, () => {
            this.args.animation = 'standing';
          });
        } else if (this.args.animation === 'walking' || this.args.animation === 'running' || this.args.animation === 'running2' || this.args.animation === 'skidding' || this.args.animation === 'crouching' || this.args.animation === 'rolling') {
          this.args.animation = 'standing';
        }
      }
      if (speed < minRun2) {
        this.closeThruster();
      }
    } else if (this.args.rolling) {
      this.scrapeSound && this.scrapeSound.pause();
      if (this.args.animation !== 'curling' && this.args.animation !== 'uncurling' && this.args.animation !== 'rolling' && this.args.animation !== 'jumping') {
        this.args.animation = 'crouching';
        this.onTimeout(200, () => {
          if (this.args.rolling) {
            this.args.animation = 'rolling';
            this.closeThruster();
          }
        });
      }
    } else {
      this.scrapeSound && this.scrapeSound.pause();
      if (this.dashed) {
        this.args.animation = 'running2';
      } else if (this.args.animation !== 'rolling' && this.args.animation !== 'jumping' && this.args.animation !== 'uncurling' && this.args.animation !== 'curling' && this.args.animation !== 'crouching') {
        this.args.animation = 'curling';
        this.onTimeout(200, () => {
          _Sfx.Sfx.play('MECHASONIC_SLAP');
          if (this.args.falling) {
            if (this.dashed) {
              this.args.animation = 'running2';
            } else if (this.args.jumping) {
              this.args.animation = 'jumping';
            }
            this.closeThruster();
          }
        });
      } else if (!this.args.jumping) {
        this.args.animation = 'crouching';
      }
    }
    super.update();
  }
  closeThruster() {
    if (this.args.takeoffPlayed) {
      this.landSound();
    }
    this.args.takeoffPlayed = false;
    this.thrusterSound && this.thrusterSound.pause();
  }
  landSound() {
    _Sfx.Sfx.play('MECHASONIC_SLAP');
  }
  sleep() {
    this.thrusterSound && this.thrusterSound.pause();
    this.scrapeSound && this.scrapeSound.pause();
  }
  command_5() {
    if (this.args.falling) {
      this.airDash(1);
    }
  }
  command_4() {
    if (this.args.falling) {
      this.airDash(-1);
    }
  }
  airDash(direction) {
    if (this.dashed || this.args.ignore && this.args.ignore !== -2) {
      return;
    }
    if (direction < 0) {
      this.args.direction = -1;
      this.args.facing = 'left';
    } else {
      this.args.direction = 1;
      this.args.facing = 'right';
    }
    let dashSpeed = direction * 7;
    this.args.float = 3;
    this.args.mode = 0;
    this.args.float = 2;
    this.args.rolling = false;
    this.args.height = this.args.normalHeight;
    if (this.args.xSpeed && Math.sign(this.args.xSpeed) !== Math.sign(direction)) {
      dashSpeed = direction * 11;
      this.args.float = 6;
      this.args.xSpeed = 0;
    }
    this.args.falling = true;
    const finalSpeed = this.args.xSpeed + dashSpeed;
    const space = this.bMap('scanForward', dashSpeed, 0.5).get(_Platformer.Platformer);
    if (space && Math.abs(finalSpeed) > Math.abs(space)) {
      dashSpeed = space * Math.sign(finalSpeed);
    }
    this.args.xSpeed = finalSpeed;
    this.args.ySpeed = 0;
    this.dashTimer = 0;
    this.dashed = true;
    this.args.mode = 0;
    this.args.groundAngle = 0;
    this.args.takeoffPlayed = true;
    if (this.takeoffSound) {
      _Sfx.Sfx.play('MECHASONIC_TAKEOFF');
    }
  }

  // get solid() { return !this.occupant; }
  // get isVehicle() { return true; }
  get canRoll() {
    return true;
  }
  get controllable() {
    return true;
  }
}
exports.MechaSonic = MechaSonic;
});

;require.register("actor/MegaMace.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MegaMace = void 0;
var _PointActor = require("./PointActor");
var _Mixin = require("curvature/base/Mixin");
var _Constrainable = require("../mixin/Constrainable");
var _SkidDust = require("../behavior/SkidDust");
class MegaMace extends _Mixin.Mixin.from(_PointActor.PointActor, _Constrainable.Constrainable) {
  constructor() {
    super(...arguments);
    this.args.decel = 0.0;
    this.args.width = 64;
    this.args.height = 64 - 12;
    this.args.type = 'actor-item actor-mega-mace';

    // this.behaviors.add(new SkidDust('particle-dust'));

    this.args.ropeLength = this.args._tiedTo ? this.args.ropeLength : 8;
    this.args.gravity = 0.8;
    // this.alwaysSkidding  = true;

    this.args.xSpeedMax = 256;
    this.args.ySpeedMax = 256;
  }
  update() {
    if (!this.args.tiedTo) {
      super.update();
    }
  }
  updateEnd() {
    if (this.viewport && !this.viewport.auras.has(this)) {
      this.viewport.auras.add(this);
    }
    if (this.args.tiedTo) {
      super.update();
      if (!this.args._tiedTo) {
        this.args._tiedTo = this.viewport.actorsById[this.args.tiedTo];
      }
      if (this.args.tiedTo && this.args._tiedTo.args.hitPoints) {
        this.setPos();
      } else {
        this.noClip = true;
      }
    }
    super.updateEnd();
  }
  collideA(other) {
    if (this.args._tiedTo && !this.args._tiedTo === other) {
      return false;
    }
  }
  collideB(other) {
    const _tiedTo = this.others.tiedTo;
    if (_tiedTo && !_tiedTo === other) {
      return false;
    }
    if (_tiedTo && !_tiedTo.args.hitPoints) {
      return;
    }
    if (other.controllable || other.damage) {
      other.damage();
    }
  }
}
exports.MegaMace = MegaMace;
});

;require.register("actor/MiniBoss.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MiniBoss = void 0;
var _Tag = require("curvature/base/Tag");
var _Platformer = require("../behavior/Platformer");
var _PointActor = require("./PointActor");
var _Mixin = require("curvature/base/Mixin");
var _CanPop = require("../mixin/CanPop");
var _CutScene = require("./CutScene");
var _Sfx = require("../audio/Sfx");
var _EggCapsule = require("./EggCapsule");
var _SpikeBomb = require("./SpikeBomb");
class MiniBoss extends _Mixin.Mixin.from(_PointActor.PointActor) {
  constructor(args, parent) {
    super(args, parent);
    this.args.type = 'actor-item actor-mini-boss';
    this.args.width = 48;
    this.args.height = 48;
    this.args.float = -1;
    this.args.damagers = new Map();
    this.args.phase = 'idle';
    this.args.hitPoints = 8;
    this.args.noseAngle = Math.PI / 2 * 3;
    this.args.drillPush = 0;
    this.args.phaseFrameId = 0;
    this.args.frameId = 0;
    this.args.direction = -1;
    this.args.facing = 'left';
    this.args.bindTo('phase', v => this.args.phaseFrameId = 0);
  }
  onRendered(event) {
    super.onRendered(event);
    this.autoAttr.get(this.box)['data-phase'] = 'phase';
    this.attractor = null;
  }
  update() {
    this.args.phaseFrameId++;
    this.args.frameId++;
    if (!this.viewport) {
      return;
    }
    const viewport = this.viewport;
    viewport.auras.add(this);
    const mainChar = this.viewport.controlActor;
    if (!mainChar) {
      return;
    }
    if (!this.attractor) {
      this.attractor = {};
      this.attractor.x = this.x;
      this.attractor.y = this.y;
    }
    const xDiff = Math.abs(this.x - this.attractor.x);
    const yDiff = Math.abs(this.y - this.attractor.y);
    const xSign = Math.sign(this.x - this.attractor.x);
    const ySign = Math.sign(this.y - this.attractor.y);
    switch (this.args.phase) {
      case 'stalking':
        const diff = this.viewport.controlActor.args.x - this.args.x;
        this.args.xSpeed = Math.sign(diff) * Math.min(4.5, Math.abs(diff));
      case 'idle':
        if (this.args.phaseFrameId % 60 === 0) {
          const bomb = new _SpikeBomb.SpikeBomb({
            x: this.args.x,
            y: this.args.y + 16,
            owner: this,
            xSpeed: this.args.xSpeed
          });
          this.viewport.spawn.add({
            object: bomb
          });
        }
        break;
      case 'damaged':
      case 'knocked':
        if (this.args.hitPoints > 0) {
          if (this.args.phaseFrameId > 20) {
            this.args.phase = 'stalking';
          }
        } else {
          if (this.args.phaseFrameId > 6) {
            this.args.phase = 'dead';
          }
        }
        break;
      case 'dead':
        this.args.float = 0;
        break;
      case 'exploding':
        if (this.args.phaseFrameId === 90) {
          this.args.falling = true;
          this.args.ySpeed = -14;
          this.args.xSpeed = 0;
          this.args.gSpeed = 0;
          this.noClip = true;
          this.viewport.auras.delete(this);
          this.args.phase = 'exploded';
          _Sfx.Sfx.play('OBJECT_DESTROYED');
          const viewport = this.viewport;
          const other = viewport.controlActor;
          viewport.onFrameOut(60, () => {
            const capsule = new _EggCapsule.EggCapsule({
              x: other.args.x,
              y: other.args.y - 384,
              xSpeed: other.args.gSpeed || other.args.xSpeed
            });
            viewport.spawn.add({
              object: capsule
            });
          });
        }
        if (this.args.phaseFrameId > 90) {
          return;
        }
        if (viewport && viewport.args.frameId % 3 === 0) {
          const explosion = new _Tag.Tag('<div class = "particle-explosion">');
          _Sfx.Sfx.play('BOSS_DAMAGED');
          const xOff = this.args.width * Math.random() - this.args.width / 2;
          const yOff = this.args.height * Math.random() - this.args.height / 2;
          explosion.style({
            '--x': this.x + xOff,
            '--y': this.y + yOff + -16
          });
          viewport.particles.add(explosion);
          setTimeout(() => viewport.particles.remove(explosion), 512);
        }
        break;
    }
    if (this.args.phase !== 'knocked') {
      if (this.args.ySpeed < 0 && !this.pointIsSafe(this.x, this.y + -this.args.height + this.args.ySpeed + -1)) {
        this.args.ySpeed = 0;
      }
    }
    super.update();
  }
  updateEnd() {
    super.updateEnd();
    if (!this.viewport) {
      return;
    }
    const mainChar = this.viewport.controlActor;
    if (!mainChar) {
      return;
    }
    const xDiff = Math.abs(this.x - mainChar.x);
    const yDiff = Math.abs(this.y - mainChar.y);
    const xSign = Math.sign(this.x - mainChar.x);
    const ySign = Math.sign(this.y - mainChar.y);
    if (this.args.xSpeed < 0) {
      this.args.facing = 'left';
    } else if (this.args.xSpeed > 0) {
      this.args.facing = 'right';
    }
    this.args.groundAngle = 0;
    switch (this.args.phase) {
      case 'attacking':
      case 'swooping':
      case 'stalking':
      case 'ready':
        {
          if (this.bMap('checkBelow', this.x, this.y + 1).get(_Platformer.Platformer)) {
            this.args.falling = true;
            this.args.ySpeed = -4;
            this.args.y--;
          }
        }
        break;
    }
  }
  collideA(other, type) {
    if (!other.controllable) {
      return;
    }
    const xSign = Math.sign(this.x - other.x);
    const ySign = Math.sign(this.y - other.y);
    const impactSpeed = Math.max(Math.abs(other.args.xSpeed), 5);
    const impactSign = Math.sign(other.args.xSpeed);
    if (this.args.phase === 'dead') {
      if (other.args.rolling) {
        other.args.gSpeed = -xSign * Math.abs(other.args.gSpeed);
      }
      if (!(other.args.jumping || other.args.rolling || other.dashed)) {
        return true;
      }
      this.args.explodeFrame = this.viewport.args.frameId;
      this.args.phase = 'exploding';
    }
    if (type === 1 || type === 3)
      // Side collisions
      {
        this.onNextFrame(() => {
          other.args.xSpeed = -xSign * Math.max(5, Math.abs(other.xSpeedLast));
        });
        if (other.args.falling) {
          this.ignores.set(other, 15);
        } else {
          other.args.gSpeed = 4 * -Math.sign(this.x - other.x);
          if (other.args.rolling) {
            this.onNextFrame(() => {
              other.args.gSpeed = -Math.sign(this.x - other.x);
              other.args.rolling = true;
              other.args.direction = Math.sign(other.args.gSpeed);
            });
          }
        }
        this.args.ySpeed = Math.min(0, this.args.ySpeed);
        this.damage(other);
      }
    if (type === 2)
      // Collide from bottom
      {
        if (this.viewport.args.audio) {
          _Sfx.Sfx.play('BOSS_DUDHIT');
        }
        if (other.args.falling) {
          if (this.hitPoints <= 0) {
            this.args.ySpeed = -Math.abs(other.args.ySpeed) * 2.5;
          }
          if (other.controllable) {
            other.args.ySpeed = Math.max(7, Math.abs(other.args.ySpeed));
          }
        }
        this.args.xSpeed = 0;
        if (this.args.hitPoints > 0) {
          this.args.phase = 'knocked';
        }
        this.ignores.set(other, 15);
      }
    if (type === 0)
      // Collide from top
      {
        if (other.args.falling) {
          this.ignores.set(other, 15);
        }
        if (other.controllable) {
          other.args.y = this.y - this.args.height;
          const animation = other.args.animation;
          const ySpeed = other.args.ySpeed;
          this.onNextFrame(() => {
            other.args.ySpeed = -Math.floor(Math.abs(ySpeed)) || -4;
          });
        }
        this.args.xSpeed = 0;
        this.damage(other);
      }
    other.args.ignore = 6;
    if (!this.args.hitPoints) {
      other.args.ignore = -2;
    }
    return true;
  }
  damage(other) {
    let type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'normal';
    if (this.args.hitPoints <= 0) {
      // this.viewport.controlActor.screenLock = null;
      return;
    }
    const lastHit = this.args.damagers.get(other);
    if (this.args.frameId - lastHit < 45) {
      return;
    }
    this.args.hitPoints--;
    this.args.xSpeed = 0;
    if (this.args.hitPoints <= 0) {
      // this.viewport.controlActor.screenLock = null;
    }
    this.args.damagers.set(other, this.args.frameId);
    this.onNextFrame(() => this.args.phase = 'damaged');
    _Sfx.Sfx.play('BOSS_DAMAGED');
  }
  pointIsSafe(x, y) {
    const hazards = this.viewport.actorsAtPoint(x, y).filter(a => a.hazard);
    if (hazards.length) {
      return false;
    }
    return true;
  }
  wakeUp() {
    this.viewport.controlActor.screenLock = {
      xMin: this.args.x - 768,
      xMax: this.args.x + 768
    };
    if (this.args.phase === 'idle') {
      this.args.phase = 'stalking';
    }
  }
  get solid() {
    return this.args.hitPoints > 0;
  }
  get rotateLock() {
    return true;
  }
}
exports.MiniBoss = MiniBoss;
});

;require.register("actor/MiniMace.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MiniMace = void 0;
var _PointActor = require("./PointActor");
var _Mixin = require("curvature/base/Mixin");
var _Constrainable = require("../mixin/Constrainable");
class MiniMace extends _Mixin.Mixin.from(_PointActor.PointActor, _Constrainable.Constrainable) {
  constructor() {
    super(...arguments);
    this.args.width = 32;
    this.args.height = 32;
    this.args.type = 'actor-item actor-mini-mace';
    this.args.ropeLength = this.args._tiedTo ? this.args.ropeLength : 8;
    this.args.gravity = 0.6;
  }
  update() {
    if (!this.args.tiedTo) {
      super.update();
    }
  }
  updateEnd() {
    if (this.viewport && !this.viewport.auras.has(this)) {
      this.viewport.auras.add(this);
    }
    if (this.args.tiedTo) {
      super.update();
      if (!this.args._tiedTo) {
        this.args._tiedTo = this.viewport.actorsById[this.args.tiedTo];
      }
      if (this.args.tiedTo && this.args._tiedTo.args.hitPoints) {
        this.setPos();
      } else {
        this.noClip = true;
      }
    }
    super.updateEnd();
  }
  collideA(other) {
    if (this.args._tiedTo && !this.args._tiedTo === other) {
      return false;
    }
  }
  collideB(other) {
    if (this.args._tiedTo && !this.args._tiedTo === other) {
      return false;
    }
    if (this.args._tiedTo && !this.args._tiedTo.args.hitPoints) {
      return;
    }
    if (other.controllable) {
      other.damage();
    }
  }
}
exports.MiniMace = MiniMace;
});

;require.register("actor/Monitor.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Monitor = void 0;
var _PointActor = require("./PointActor");
var _Tag = require("curvature/base/Tag");
var _Explosion = require("../actor/Explosion");
var _Projectile = require("../actor/Projectile");
var _BrokenMonitor = require("../actor/BrokenMonitor");
var _Block = require("../actor/Block");
var _Marker = require("../actor/Marker");
var _Sfx = require("../audio/Sfx");
var _Analytic = require("../lib/Analytic");
class Monitor extends _PointActor.PointActor {
  constructor() {
    super(...arguments);
    this.args.type = 'actor-item actor-monitor';
    this.args.width = 30;
    this.args.height = 32;
    this.args.decel = 2;
    this.args.canHide = true;
    this.args.platform = true;
    this.args.gone = false;
  }
  onRendered(event) {
    super.onRendered(event);
    if (!this.screen && this.sprite) {
      this.screen = new _Tag.Tag(`<div class = "monitor-screen">`);
      this.sprite.appendChild(this.screen.node);
    }
  }
  update() {
    super.update();
    if (!this.viewport) {
      return;
    }
  }
  collideA(other, type) {
    if (other.knocked) {
      this.pop(other.knocked);
    }
    if (other.args.static) {
      return true;
    }
    if (other.punching) {
      this.pop(other);
      return false;
    }
    if (!other.args.moving && !other.args.falling) {
      return false;
    }
    if (other instanceof _Block.Block) {
      return false;
    }
    if (other instanceof _Marker.Marker) {
      other = other.owner;
    }
    super.collideA(other, type);
    if (other.passPop && other.occupant && !other.args.dead) {
      other = other.occupant;
      this.pop(other);
      return;
    }

    // if(type === 1 && !other.args.spinning)
    // {
    // 	return true;
    // }

    if (type === 2 && this.args.float && other.controllable) {
      other.args.ySpeed *= -1;
      this.args.ySpeed = -4;
      this.args.float = 0;
      this.ignores.set(other, 15);
      return true;
    }
    if (type !== 2 && (other.args.ySpeed > 0 && other.y < this.y || (other.args.rolling || other.args.bellySliding) && !other.args.grinding) && (!this.args.falling || this.args.float === -1) && !this.args.gone && this.viewport && other.args.spinning) {
      this.pop(other);
      return;
    }
    if ((type === 1 || type === 3
    // && (Math.abs(other.args.xSpeed) > 15 || other instanceof Projectile)
    ) && ((other.args.rolling || other.args.bellySliding) && !other.args.grinding || other instanceof _Projectile.Projectile) && !this.args.gone && this.viewport) {
      this.pop(other);
      return false;
    }
  }
  pop(other) {
    const viewport = this.viewport;
    if (!viewport || this.args.gone) {
      return;
    }
    const explosion = new _Tag.Tag('<div class = "particle-explosion">');
    if (other) {
      const reward = {
        label: this.name || this.args.name,
        points: 10,
        multiplier: 1
      };
      if (!other.isVehicle && other.args.ySpeed > 5 && other.args.ySpeed < 25 && Math.abs(other.args.ySpeed) > Math.abs(other.args.xSpeed)) {
        other.args.cameraMode = 'popping';
      }
      other.args.popChain.push(reward);
      other.args.popCombo += 1;
      if (other.args.ySpeed > 25 && !other.args.bouncing) {
        const reward = {
          label: 'BIG AIR!!!',
          points: 1000,
          multiplier: 1.5
        };
        other.args.popChain.push(reward);
        other.args.popCombo += 1;
        if (!other.airReward && Math.abs(other.args.xSpeed) > 10) {
          other.args.x = this.args.x - (this.args.gSpeed || this.args.xSpeed);
          other.args.y = this.args.y + -8;
          this.viewport.onFrameOut(1, () => this.viewport.args.frozen = 25);
          this.viewport.args.invert = 'invert';
          this.viewport.onFrameOut(25, () => this.viewport.args.invert = '');
          _Sfx.Sfx.play('SICK_TRICK');
          _Sfx.Sfx.play('SICK_TRICK');
        }
        other.airReward = reward;
      }
      _Sfx.Sfx.play('OBJECT_DESTROYED');
    }
    explosion.style({
      '--x': this.x,
      '--y': this.y - 16
    });
    const scoreNode = document.createElement('div');
    scoreNode.classList.add('particle-score');
    scoreNode.classList.add('score-10');
    const scoreTag = new _Tag.Tag(scoreNode);
    scoreTag.style({
      '--x': this.args.x,
      '--y': this.args.y - 16
    });
    viewport.particles.add(scoreTag);
    viewport.particles.add(explosion);
    setTimeout(() => viewport.particles.remove(explosion), 512);
    setTimeout(() => viewport.particles.remove(scoreTag), 768);
    setTimeout(() => this.screen && this.screen.remove(), 1024);
    this.args.gone = true;
    this.box && this.box.setAttribute('data-animation', 'broken');
    if (other) {
      if (other.occupant) {
        other = other.occupant;
      }
      if (other.args.owner) {
        other = other.args.owner;
      }
      if (other.controllable) {
        this.effect(other);
      }
    }
    if (typeof ga === 'function') {
      _Analytic.Analytic.report({
        eventCategory: 'monitor',
        eventAction: 'popped',
        eventLabel: `${this.viewport.args.actName}::${this.args.id}`
      });
    }
    if (other) {
      const ySpeed = Math.min(other.args.ySpeed, other.ySpeedLast);
      if (other.args.doubleSpin) {
        other.args.doubleSpin = 2;
      }
      other.dashed = false;
      if (other && other.dashed && Math.abs(other.args.xSpeed) > Math.abs(other.args.ySpeed)) {
        other.args.gSpeed = 0;
        other.args.xSpeed = -1.5 * Math.sign(other.args.xSpeed);
        other.args.ySpeed = -10;
      } else if (other && other.args.falling) {
        const spinning = other.args.spinning;
        const jumping = other.args.jumping;
        const flying = other.args.flying;
        const xSpeed = other.args.xSpeed || other.args.gSpeed;
        other.args.xSpeed = 0;
        other.args.ySpeed = 0;
        viewport.onFrameOut(1, () => {
          if (ySpeed >= 0) {
            if (other.flyTime < 5) {
              other.args.ySpeed = Math.min(-ySpeed, -7);
            } else {
              other.args.ySpeed = Math.min(-ySpeed, -2);
            }
          } else {
            other.args.ySpeed += 8;
          }
          other.args.spinning = other.args.spinning || spinning;
          other.args.jumping = other.args.jumping || jumping;
          other.args.flying = other.args.flying || flying;
          other.args.xSpeed = xSpeed;
          other.args.falling = true;
        });
      }
    }
    if (other && this.viewport.settings.rumble && other.controller && other.controller.rumble) {
      other.controller.rumble({
        duration: 40,
        strongMagnitude: 0.0,
        weakMagnitude: 1.0
      });
      this.viewport.onTimeout(40, () => {
        other.controller.rumble({
          duration: 110,
          strongMagnitude: 0.75,
          weakMagnitude: 1.0
        });
      });
    }
  }
  effect() {}
  get canStick() {
    return false;
  }
  get solid() {
    return false;
  }
}
exports.Monitor = Monitor;
});

;require.register("actor/Motobug.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Motobug = void 0;
var _Mixin = require("curvature/base/Mixin");
var _PointActor = require("./PointActor");
var _Patrol = require("../behavior/Patrol");
var _CanPop = require("../mixin/CanPop");
class Motobug extends _Mixin.Mixin.from(_PointActor.PointActor, _CanPop.CanPop) {
  constructor() {
    var _this$args$patrolPaus, _this$args$patrolBeat, _this$args$patrolSpee;
    super(...arguments);
    this.behaviors.add(new _Patrol.Patrol());
    this.args.type = 'actor-item actor-motobug';
    this.args.animation = 'standing';
    this.args.accel = 0.1;
    this.args.decel = 0.5;
    this.args.gSpeedMax = 3;
    this.args.gravity = 0.5;
    this.args.width = 24;
    this.args.height = 32;
    this.willStick = false;
    this.stayStuck = false;
    this.args.patrolPause = (_this$args$patrolPaus = this.args.patrolPause) !== null && _this$args$patrolPaus !== void 0 ? _this$args$patrolPaus : 10;
    this.args.patrolBeat = (_this$args$patrolBeat = this.args.patrolBeat) !== null && _this$args$patrolBeat !== void 0 ? _this$args$patrolBeat : 120;
    this.args.patrolSpeed = (_this$args$patrolSpee = this.args.patrolSpeed) !== null && _this$args$patrolSpee !== void 0 ? _this$args$patrolSpee : 1;
  }
  update() {
    super.update();
    if (this.args.moving && this.args.gSpeed) {
      this.args.animation = 'walking';
    } else {
      this.args.animation = 'standing';
    }
    this.args.direction = Math.sign(this.args.gSpeed);
  }
  get solid() {
    return false;
  }
  get isEffect() {
    return false;
  }
}
exports.Motobug = Motobug;
});

;require.register("actor/MouseIndicator.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MouseIndicator = void 0;
var _Cursor = require("./Cursor");
var _CharacterString = require("../ui/CharacterString");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class MouseIndicator extends _Cursor.Cursor {
  constructor() {
    super(...arguments);
    _defineProperty(this, "endPoint", null);
    _defineProperty(this, "lastMouseX", null);
    _defineProperty(this, "lastMouseY", null);
  }
  onRendered(event) {
    super.onRendered(event);
    this.args.type = 'point-actor actor-generic actor-mouse-indicator';
    this.autoStyle.get(this.box)['--magnitude'] = 'magnitude';
    this.magnitudeLabel = new _CharacterString.CharacterString({
      value: 0
    });
    this.angleLabel = new _CharacterString.CharacterString({
      value: 0
    });
    this.colorLabel = new _CharacterString.CharacterString({
      value: 0
    });
    Object.assign(this.args.charStrings, [this.magnitudeLabel, this.angleLabel, this.colorLabel]);
  }
  update() {
    if (this.viewport && !this.viewport.args.plot) {
      this.viewport.args.plot = new Plot();
    }
    const mouse = this.viewport.mouse;
    if (!mouse.buttons[0] && !this.endPoint) {
      this.args.x = mouse.position[0];
      this.args.y = mouse.position[1];
    } else if (mouse.buttons[0] === 1 && this.endPoint) {
      // this.viewport.actors.remove(this.endPoint);
      this.endPoint = null;
    } else if (mouse.buttons[0] === 1 && !this.endPoint) {
      this.endPoint = new _Cursor.Cursor({
        x: this.args.x,
        y: this.args.y
      });
      // this.viewport.spawn.add({object:this.endPoint});
    } else {
      const length = Math.hypot(this.args.y - mouse.position[1], this.args.x - mouse.position[0]);
      const angle = Math.atan2(mouse.position[1] - this.args.y, mouse.position[0] - this.args.x);
      this.args.airAngle = angle;

      // this.args.falling = false;

      if (this.lastMouseX !== mouse.position[0] || this.lastMouseY !== mouse.position[1]) {
        // this.viewport.args.plot.clearPoints();
        window.logPoints = (x, y, label) => this.viewport.args.plot.addPoint(x, y, 'main-scan ' + label);
        const magnitude = this.castRayQuick(length, angle);
        // window.logPoints = false;

        this.args.falling = true;
        this.endPoint.args.x = this.args.x + Math.cos(angle) * magnitude;
        this.endPoint.args.y = this.args.y + Math.sin(angle) * magnitude;
        const color = this.viewport.tileMap.getColor(Math.trunc(this.endPoint.args.x), Math.trunc(this.endPoint.args.y), 0);
        this.magnitudeLabel.args.value = magnitude === false ? false : Number(magnitude).toFixed(2);
        this.angleLabel.args.value = Number(angle).toFixed(2);
        this.colorLabel.args.value = Number(color).toString(16).padStart(8, '0');
      }
      this.lastMouseX = mouse.position[0];
      this.lastMouseY = mouse.position[1];
    }
  }
}
exports.MouseIndicator = MouseIndicator;
});

;require.register("actor/Mushroom.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Mushroom = void 0;
var _PointActor = require("./PointActor");
var _Liftable = require("../behavior/Liftable");
class Mushroom extends _PointActor.PointActor {
  constructor() {
    super(...arguments);
    this.args.type = 'actor-item actor-mushroom';
    this.args.width = 24;
    this.args.height = 24;
    this.args.size = 4;
    this.args.nourishment = 0.1;
    this.behaviors.add(new _Liftable.Liftable());
  }
  onRendered(event) {
    super.onRendered(event);
    const viewport = this.viewport;
    this.onRemove(() => viewport.spawnFromDef(this.objDef));
    this.autoStyle.get(this.box)['--size'] = 'size';
  }
  lift(actor) {
    if (this.carriedBy === actor) {
      this.carriedBy = null;
      return;
    }
    this.carriedBy = actor;
  }
  get solid() {
    return false;
  }
  get rotateLock() {
    return true;
  }
  sleep() {
    if (!this.viewport) {
      return;
    }
    this.viewport.actors.remove(this);
  }
}
exports.Mushroom = Mushroom;
});

;require.register("actor/NeverBetter.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NeverBetter = void 0;
var _PointActor = require("./PointActor");
class NeverBetter extends _PointActor.PointActor {
  constructor(args, parent) {
    super(args, parent);
    this.args.type = 'actor-item actor-never-better-sign';
    this.args.width = 84;
    this.args.height = 78;
  }
  get solid() {
    return false;
  }
}
exports.NeverBetter = NeverBetter;
});

;require.register("actor/NitroBooster.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NitroBooster = void 0;
var _PointActor = require("./PointActor");
// import { Sfx } from '../audio/Sfx';
// import { Bgm } from '../audio/Bgm';
// import { Tag } from 'curvature/base/Tag';
// import { Block } from './Block';

class NitroBooster extends _PointActor.PointActor {
  constructor() {
    super(...arguments);
    this.args.width = 64;
    this.args.height = 8;
    this.args.float = -1;
    this.args.type = 'actor-item actor-nitro-booster';
  }
  onRendered() {
    super.onRendered();
  }
  update() {
    super.update();
    if (Math.trunc(this.viewport.args.frameId / 6) % 6 < 2 && this.viewport.args.frameId % 3) {
      this.castRayQuick(60, -Math.PI / 2, [0, -16]);
      this.args.animation = 'boosting';
    } else {
      this.args.animation = 'idle';
    }
  }
  collideA(other, type) {
    if (!other.controllable) {
      return;
    }
    if (this.args.animation === 'boosting') {
      other.args.y -= 16;
      other.args.ySpeed = -16;
      other.args.falling = true;
    }

    // if(type === 0 && other.args.ySpeed >= 0)
    // {
    // 	other.args.ySpeed = (other.args.flying && other.flyTime > 2) ? -2 : -8;
    // 	super.collideA(other, type);
    // 	this.args.pressed = 6;
    // 	return;
    // }

    return super.collideA(other, type);
  }
  get solid() {
    return true;
  }
}
exports.NitroBooster = NitroBooster;
});

;require.register("actor/NotchSpring.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NotchSpring = void 0;
var _PointActor = require("./PointActor");
var _Block = require("./Block");
var _Sfx = require("../audio/Sfx");
class NotchSpring extends _PointActor.PointActor {
  constructor() {
    super(...arguments);
    this.args.width = 8;
    this.args.height = 32;
    this.args.type = 'actor-item actor-notch-spring';
    this.noClip = true;
    this.args.float = -1;
    this.args.animation = 'idle';
    this.launching = new Set();
  }
  collideA(other) {
    if (!other.controllable || !other.args.falling) {
      return;
    }
    this.launching.add(other);
    this.args.animation = 'springing';
    _Sfx.Sfx.play('NOTCH_SPRING_HIT');
    this.viewport.onFrameOut(1, () => this.args.animation = 'idle');
  }
  updateEnd() {
    super.updateEnd();
    this.launching.forEach(other => {
      other.args.animation = 'flip';
      other.args.jumping = false;
      other.dashed = false;
      other.args.x += this.args.direction;
      other.args.flying = false;
      other.impulse(12, -Math.PI / 2 + Math.PI / 4 * this.args.direction, true);
      other.args.xSpeed = 0;
      other.args.ySpeed = 0;
      other.args.ignore = 8;
      this.launching.delete(other);
    });
  }
  get solid() {
    return false;
  }
}
exports.NotchSpring = NotchSpring;
});

;require.register("actor/NuclearSuperball.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NuclearSuperball = void 0;
var _PointActor = require("./PointActor");
var _Tag = require("curvature/base/Tag");
class NuclearSuperball extends _PointActor.PointActor {
  constructor() {
    super(...arguments);
    this.args.gSpeedMax = 150;
    this.args.accel = 2;
    this.args.jumpForce = 20;
    this.willStick = true;
    this.stayStuck = true;
  }
  get solid() {
    return false;
  }
  get isEffect() {
    return false;
  }
  get controllable() {
    return true;
  }
}
exports.NuclearSuperball = NuclearSuperball;
});

;require.register("actor/Orb.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Orb = void 0;
var _PointActor = require("./PointActor");
var _Mixin = require("curvature/base/Mixin");
var _Pushable = require("../mixin/Pushable");
class Orb extends _Mixin.Mixin.from(_PointActor.PointActor) {
  constructor() {
    super(...arguments);
    this.args.type = 'actor-item actor-orb';
    this.args.width = 18;
    this.args.height = 48;
    this.args.rolled = 0;
    this.args.accel = 0.0;
    this.args.decel = 0;
    this.args.bindTo('x', (v, k, t, d, p) => this.args.rolled += 0.5 * Number(v - p || 0));
    this.args.gravity = 1.35;
    this.args.maxFollow = this.args.maxFollow || null;
  }
  onRendered(event) {
    super.onRendered(event);
    this.autoStyle.get(this.box)['--rolled'] = 'rolled';
  }
  updateStart() {
    super.updateStart();
    const other = this.viewport.controlActor;
    this.otherSpacing = this.distanceFrom(other);
    this.otherSpeed = other.args.gSpeed || other.args.xSpeed || other.gSpeedLast || other.xSpeedLast;
  }
  update() {}
  updateEnd() {
    if (!this.viewport || !this.viewport.controlActor) {
      return;
    }
    const other = this.viewport.controlActor;
    if (this.args.falling && other.args.fallTime < 15 && this.args.ySpeed < 0) {
      this.args.xSpeed = 0.995;
    }
    const viewport = this.viewport;
    if (this.args.falling) {
      this.viewport.onFrameOut(10, () => {
        if (this.args.falling) {
          viewport.auras.delete(this);
        }
      });
    } else {
      this.viewport.auras.add(this);
    }
    const speedMag = Math.max(0, this.otherSpeed);
    const speedSign = Math.sign(this.args.gSpeed || this.gSpeedLast || other.args.gSpeed || other.args.xSpeed);
    const moving = this.args.gSpeed || this.args.xSpeed;
    if ((moving || this.args.x < other.args.x - 160) && (!this.args.maxFollow || this.x < this.args.maxFollow)) {
      const maxSpace = 64;
      const spacing = this.otherSpacing;
      let gSpeed = speedMag * speedSign;
      if (spacing < maxSpace || other.args.falling && other.args.ySpeed >= 0) {
        gSpeed *= 0.975;
      }
      if (gSpeed && this.args.groundAngle > 0) {
        gSpeed += (other.args.rolling ? 1.25 : 0.5) * Math.sign(gSpeed);
      }
      this.args.gSpeed = gSpeed;
    }
    if (this.otherSpacing > 256 || moving && this.args.falling) {
      other.cofocused = null;
    } else if (other.args.x > this.args.x) {
      other.cofocused = this;
    }
    super.update();
    super.updateEnd();
  }
  collideA(other) {
    if (!other.isHyper && !other.isSuper) {
      other.controllable && other.loseRings();
    }
    other.controllable && other.die();
  }
  get controllable() {
    return false;
  }
  get solid() {
    return false;
  }
}
exports.Orb = Orb;
});

;require.register("actor/OrbSmall.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.OrbSmall = void 0;
var _PointActor = require("./PointActor");
var _Mixin = require("curvature/base/Mixin");
var _Sfx = require("../audio/Sfx");
class OrbSmall extends _Mixin.Mixin.from(_PointActor.PointActor) {
  constructor() {
    super(...arguments);
    this.args.type = 'actor-item actor-orb-small';
    this.args.width = 18;
    this.args.height = 24;
    this.args.rolled = 0;
    this.gSpeedLast = 0;
    this.args.accel = 0.2;
    this.args.decel = this.args.decel || 0.0;

    // this.args.bindTo('x', (v,k,t,d,p) => this.args.rolled += Math.PI * Number(v - p || 0));
    // this.args.bindTo('y', (v,k,t,d,p) => this.args.rolled += Math.abs(Number(v - p || 0)));

    this.args.gravity = 0.4;
    this.args.maxFollow = this.args.maxFollow || null;
    this.args.friction = this.args.friction || 0.75;
    this.args.bounce = this.args.bounce || 0.5;
    this.args.rollSpeed = 0;
    this.args.rolled = 0;
  }
  onRendered(event) {
    super.onRendered(event);
    this.autoStyle.get(this.box)['--rolled'] = 'rolled';
  }
  update() {
    if (!this.viewport || !this.viewport.controlActor) {
      return;
    }
    if (this.args.x < -16 + this.viewport.controlActor.args.x) {
      if (!this.args.falling) {
        this.args.xSpeed = this.args.gSpeed;
      }
      this.args.falling = true;
      this.noClip = true;
    }
    const ySpeed = this.ySpeedLast - this.args.gravity;
    super.update();
    if (!this.args.falling) {
      this.args.rollSpeed = this.args.gSpeed * Math.PI;
    } else if (this.args.ySpeed > 0) {
      this.args.rollSpeed *= 0.975;
    }
    this.args.rolled += this.args.rollSpeed;
    if (!this.args.falling && ySpeed > 3) {
      const volume = Math.max(0.5, Math.min(ySpeed, 16) / 16);
      _Sfx.Sfx.play('HEAVY_THUD', {
        volume
      });
      if (this.args.bounce) {
        this.args.xSpeed *= this.args.friction;
        this.args.x += this.args.xSpeed;
      }
      this.args.ySpeed = -ySpeed * this.args.bounce;
      this.args.falling = true;
      this.args.y -= 1;
    }
  }
  collideA(other) {
    // if(other instanceof this.constructor)
    // {
    // 	this.args.gSpeed = (this.args.gSpeed + other.args.gSpeed) * 0.5
    // 	this.args.xSpeed = (this.args.xSpeed + other.args.xSpeed) * 0.5
    // 	this.args.ySpeed = (this.args.ySpeed + other.args.ySpeed) * 0.5

    // 	this.args.gSpeed += Math.sign(this.args.x - other.args.x);
    // 	this.args.xSpeed += Math.sign(this.args.x - other.args.x);
    // 	this.args.ySpeed += Math.sign(this.args.y - other.args.y);

    // 	Sfx.play('HEAVY_THUD');

    // 	return;
    // }

    if (other.controllable) {
      const volume = Math.max(0.5, Math.min(this.args.ySpeed, 16) / 16);
      if (!other.args.startled) {
        this.args.gSpeed = 0;
        this.noClip = true;
        this.args.falling = true;
        this.args.xSpeed = 0;
        this.args.ySpeed = -3;
        this.args.float = 10;
        this.args.rollSpeed *= 2;
        _Sfx.Sfx.play('HEAVY_THUD', {
          volume
        });
      }
      if (other.args.rings) {
        other.damage();
      } else {
        other.startle();
      }
    }
    if (this.args.x < this.viewport.controlActor.args.x - 8) {
      this.noClip = true;
      return;
    }
    if (this.noClip && other.break && !other.broken) {
      this.args.ySpeed *= -1;
      _Sfx.Sfx.play('HEAVY_THUD');
      other.break(this);
    }
  }
  sleep() {
    this.viewport.actors.remove(this);
  }
  get controllable() {
    return false;
  }
  get solid() {
    return false;
  }
}
exports.OrbSmall = OrbSmall;
});

;require.register("actor/Panel.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Panel = void 0;
var _PointActor = require("./PointActor");
var _Bindable = require("curvature/base/Bindable");
class Panel extends _PointActor.PointActor {
  constructor(args, parent) {
    super(args, parent);
    this.args.type = 'actor-item actor-panel';
    this.args.width = 64;
    this.args.height = 8;
    this.args.static = 1;
    this.args.float = -1;
    this.leaving = new Set();
    this.holding = new Set();
    this.cancels = new Map();

    // this.args.bindTo('mode', (k,v) => console.trace(this.args.id,k,v));
  }

  collideA(other, type) {
    if (other.args.flying) {
      return false;
    }
    if (this.leaving.has(other)) {
      if (this.holding.has(other)) {
        other.stayStuck = false;
        other.willStick = false;
        other.willJump = false;
        other.args.gSpeed = 0;
        this.holding.delete(other);
      }
      if (this.cancels.has(other)) {
        this.cancels.get(other)();
        this.cancels.delete(other);
      }
      this.cancels.set(other, this.viewport.onFrameOut(25, () => {
        this.holding.delete(other);
        this.leaving.delete(other);
      }));
      return false;
    }
    if (!other.args.jumping && !this.holding.has(other)) {
      return false;
    }
    if (this.holding.has(other)) {
      other.args.mode = 0;
      other.args.groundAngle = this.args.groundAngle;
      other.lastAngles.length = 0;
      other.args.gSpeed = 0;
      other.args.xSpeed = 0;
      other.args.ySpeed = 0;
      other.args.falling = false;
      if ((this.args.next || this.args.mode) && this.holding.has(other) && other.willJump) {
        const nextPanel = this.viewport.actorsById[this.args.next];
        other.args.falling = true;
        if (nextPanel || this.args.mode) {
          other.stayStuck = true;
          other.willStick = true;
          // other.willJump = false;

          if (nextPanel) {
            const point = nextPanel.rotatePoint(0, 0);
            const angle = other.angleTo({
              x: point[0] + nextPanel.x,
              y: point[1] + nextPanel.y
            });
            other.args.x -= Math.cos(angle) * 16;
            other.args.y -= Math.sin(angle) * 16;
            other.args.xSpeed = -Math.cos(angle) * 42;
            other.args.ySpeed = -Math.sin(angle) * 42;
            other.args.ignore = -2;
          }
          other.args.gSpeed = 0;
          other.args.falling = true;
          other.args.jumping = true;
          other.args.float = nextPanel ? 45 : 0;
          this.leaving.add(other);
          this.holding.delete(other);
          other.args.ignore = nextPanel ? 45 : 0;
        } else {
          this.leaving.add(other);
          this.holding.delete(other);
          other.stayStuck = false;
          other.willStick = false;
          // other.willJump  = false;
          other.args.gSpeed = 0;
          other.args.xSpeed = 0;
          other.args.ySpeed = 0;
          other.args.falling = true;
          other.args.float = 0;
          other.args.ignore = 15;
        }
        return false;
      }
      const point = this.rotatePoint(0, 8);
      other.args.x = this.x + point[0];
      other.args.y = this.y + point[1];
      other.args.ignore = 0;
      return false;
    }
    const nextPanel = this.others.next;
    if (nextPanel || this.args.mode) {
      this.holding.add(other);
    } else {
      return true;
    }

    // other.args.gSpeed = 0;
    // other.args.xSpeed = 0;
    // other.args.ySpeed = 0;

    other.args.ignore = 10;
    if (this.cancels.has(other)) {
      this.cancels.get(other)();
      this.cancels.delete(other);
    }
    this.cancels.set(other, this.viewport.onFrameOut(20, () => {
      if (this.holding.has(other)) {
        this.holding.delete(other);
        this.leaving.add(other);
      }
    }));
    return false;
  }
  sleep() {
    this.leaving.clear();
    this.holding.clear();
  }
  get solid() {
    return false;
  }
}
exports.Panel = Panel;
});

;require.register("actor/Parachute.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Parachute = void 0;
var _PointActor = require("./PointActor");
class Parachute extends _PointActor.PointActor {
  constructor() {
    super(...arguments);
    this.args.width = 32;
    this.args.height = 22;
    this.args.type = 'actor-item actor-parachute';
    this.args.float = -1;
    this.args.z = -1;
    this.attachedTo = null;
  }
  get solid() {
    return false;
  }
  updateEnd() {
    if (this.attachedTo) {
      this.args.x = this.attachedTo.args.x + -8 * this.attachedTo.args.direction;
      this.args.y = this.attachedTo.args.y + -this.attachedTo.args.normalHeight * 1;
      if (this.attachedTo.args.ySpeed > 2) {
        this.attachedTo.args.ySpeed = 2;
        this.attachedTo.args.animation = 'dropping';
        this.args.hidden = false;
      } else {
        this.args.hidden = true;
      }
    }
    super.updateEnd();
  }
  collideA(other) {
    if (this.attachedTo || !other.controllable) {
      return;
    }
    this.attachedTo = other;
  }
}
exports.Parachute = Parachute;
});

;require.register("actor/PlatformFlare.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PlatformFlare = void 0;
var _PointActor = require("./PointActor");
var _Block = require("./Block");
var _Sfx = require("../audio/Sfx");
class PlatformFlare extends _PointActor.PointActor {
  constructor() {
    super(...arguments);
    this.args.width = 32;
    this.args.height = 8;
    this.args.power = this.args.power || 18;
    this.args.type = 'actor-item actor-platform-flare';
    this.args.static = 1;
  }
  collideA(other) {
    if (other.args.float || other.args.static) {
      return;
    }
    if (other.controllable && this.args.active) {
      other.damage(this, 'fire');
    }
    const frameId = this.viewport.args.frameId - this.viewport.args.startFrameId;
    if (frameId / 60 % 3) {
      return;
    }
    this.args.active = true;
    this.viewport.onFrameOut(30, () => this.args.active = false);
    if (other instanceof _Block.Block) {
      _Sfx.Sfx.play('LID_POP');
      other.args.ySpeed = -this.args.power;
      other.args.y += -1;
      other.args.falling = true;
    }
  }
}
exports.PlatformFlare = PlatformFlare;
});

;require.register("actor/Platformer.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Platformer = void 0;
var _PointActor = require("./PointActor");
class Platformer extends _PointActor.PointActor {
  get controllable() {
    return true;
  }
}
exports.Platformer = Platformer;
});

;require.register("actor/PogoEgg.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PogoEgg = void 0;
var _PointActor = require("./PointActor");
var _Sfx = require("../audio/Sfx");
var _Tag = require("curvature/base/Tag");
var _EggCapsule = require("./EggCapsule");
// import { Bgm } from '../audio/Bgm';

class PogoEgg extends _PointActor.PointActor {
  constructor() {
    super(...arguments);
    this.args.width = 65;
    this.args.height = 63;
    this.args.type = 'actor-item actor-pogo-egg';
    this.args.gravity = 0.5;
    this.args.jumpForce = 10;
    this.args.decel = 0;
    this.targetPoint = null;
    this.xTarget = 19216;
    this.yTarget = 1280;
    this.args.expectedAirTime = 0;
    this.args.hp = 8;
    this.args.bounceCount = 0;
  }
  onRendered() {
    super.onRendered();
    this.autoStyle.get(this.box)['--stem-length'] = 'stemLength';
  }
  update() {
    super.update();
    for (const a of this.standingUnder) {
      a.args.falling = true;
      a.args.ySpeed = -Math.abs(a.ySpeedLast);
      a.args.y--;
      if (this.args.ySpeed < 0) {
        a.args.ySpeed += this.args.ySpeed;
      }
    }
    const originX = this.def.get('x');
    this.screenLock = this.screenLock || {
      xMin: originX + -624,
      xMax: originX + 497
    };
    if (this.args.hp >= 0) {
      if (this.viewport.controlActor && Math.abs(this.viewport.controlActor.args.x - this.args.x) < 386) {
        if (!this.viewport.controlActor.args.dead) {
          this.viewport.controlActor.screenLock = this.viewport.controlActor.screenLock || {
            xMin: originX + -624,
            xMax: originX + 497
          };
        }
      }
      this.args.animation = 'idle';
      if (this.args.damaged > 0) {
        this.args.damaged--;
        this.args.animation = 'damaged';
      }
    }
    if (this.args.hp > 0) {
      const stemLengthL = this.castRayQuick(32, Math.PI / 2, [-16, 0], false) || 32;
      const stemLengthR = this.castRayQuick(32, Math.PI / 2, [+16, 0], false) || 32;
      this.args.stemLength = Math.min(stemLengthL, stemLengthR);
    } else {
      this.args.stemLength = 0;
    }
    const cycle = 800;
    let target = this.otherDefs.pointA;
    let phase = this.age % cycle;
    if (phase > cycle * 0.75) {
      target = this.otherDefs.pointB;
    } else if (phase > cycle * 0.5) {
      target = this.otherDefs.pointC;
    } else if (phase > cycle * 0.25) {
      target = this.otherDefs.pointB;
    }
    if (this.targetPoint !== target) {
      this.args.bounceCount = 0;
    }
    this.xTarget = target.x;
    this.yTarget = target.y;
    this.targetPoint = target;
    if (this.args.bounceCount) {
      if (this.args.bounceCount % 2) {
        this.xTarget = this.targetPoint.x - 32;
      } else {
        this.xTarget = this.targetPoint.x + 32;
      }
    }
    if (this.args.hp > 0) {
      if (!this.args.falling) {
        this.args.bounceCount++;
        this.willJump = true;
      } else if (this.fallTime === 0) {
        const g = this.args.gravity;
        const v = this.args.jumpForce;
        const h = -(this.yTarget - this.args.y);
        const b = g + 2 * v;
        const a = (-b - Math.sqrt(b ** 2 + 8 * g * -h)) / (-2 * g);
        if (!isNaN(a) && a > 0) {
          const d = this.xTarget - this.args.x;
          this.args.xSpeed = d / a;
          this.args.expectedAirTime = a;
        } else {
          this.args.xSpeed = 0;
        }
      }
    } else if (this.args.hp < 0 && this.args.animation !== 'exploding' && this.args.animation !== 'exploded') {
      this.args.xSpeed = 0;
      this.args.animation = 'exploding';
      viewport.onFrameOut(80, () => {
        this.args.animation = 'exploded';
        this.args.falling = true;
        this.args.ySpeed = -16;
        this.noClip = true;
        _Sfx.Sfx.play('OBJECT_DESTROYED');
      });
      viewport.onFrameOut(160, () => {
        const capsule = new _EggCapsule.EggCapsule({
          x: this.otherDefs.pointB.x,
          y: this.otherDefs.pointB.y - 384
        });
        viewport.spawn.add({
          object: capsule
        });
      });
    }
    if (this.args.animation === 'exploding') {
      viewport = this.viewport;
      if (viewport && viewport.args.frameId % 3 === 0) {
        const explosion = new _Tag.Tag('<div class = "particle-explosion">');
        _Sfx.Sfx.play('BOSS_DAMAGED');
        const xOff = this.args.width * Math.random() - this.args.width / 2;
        const yOff = this.args.height * Math.random() - this.args.height / 2;
        explosion.style({
          '--x': this.x + xOff,
          '--y': this.y + yOff + -32
        });
        viewport.particles.add(explosion);
        setTimeout(() => viewport.particles.remove(explosion), 512);
      }
    }
  }
  collideA(other, type) {
    if (!other.controllable) {
      return;
    }
    if (this.args.hp <= -1 && this.args.falling) {
      return false;
    }
    if (this.args.hp > 0 && !other.args.falling && other.groundTime > 1 && !this.args.damaged && !this.standingUnder.has(other) && !other.args.mercy) {
      other.damage(this);
      return false;
    }
    if (type === 0 && other.args.falling) {
      this.args.ySpeed = Math.abs(other.ySpeedLast);
      other.args.ySpeed = -Math.abs(other.ySpeedLast);
      other.args.y = this.args.y + -this.args.height;
      if (other.args.ySpeed > -6) {
        other.args.ySpeed = -6;
      }
      _Sfx.Sfx.play('BOSS_DAMAGED');
      if (!this.args.damaged) {
        // this.ignores.set(other, 30);
        this.args.damaged = 30;
        this.args.hp--;
      }
    } else if (type === 2 && other.args.falling) {
      this.args.ySpeed = Math.abs(other.args.ySpeed);
      other.args.ySpeed = -Math.abs(other.args.ySpeed);
      other.args.y = this.args.y + other.args.height;
      _Sfx.Sfx.play('BOSS_DUDHIT');
    } else if (Math.abs(this.args.x - other.args.x) > this.args.width / 2 && other.args.falling) {
      other.args.x = this.args.x + (this.args.width + other.args.width) * 0.5 * Math.sign(other.args.x - this.args.x || other.args.xSpeed);

      // other.args.xSpeed = -Math.sign(other.args.xSpeed) * 4;
      other.args.xSpeed *= -1;
      // this.args.xSpeed *= -1;

      if (Math.abs(other.args.xSpeed) < 4) {
        other.args.xSpeed = 4 * Math.sign(other.args.x - this.args.x);
      }
      if (Math.abs(this.args.xSpeed) < 4) {
        this.args.xSpeed = 4 * -Math.sign(other.args.x - this.args.x);
      }
      _Sfx.Sfx.play('BOSS_DAMAGED');
      if (!this.args.damaged) {
        // this.ignores.set(other, 30);
        this.args.damaged = 30;
        this.args.hp--;
      }
      this.args.ySpeed = -5 * Math.sign(other.args.y - this.args.y);
    }
    if (this.args.hp <= 0) {
      this.args.xSpeed = 0;
    }
    return super.collideA(other, type);
  }
  get solid() {
    return false;
  }
  get canStick() {
    return false;
  }
}
exports.PogoEgg = PogoEgg;
});

;require.register("actor/PogoSpring.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PogoSpring = void 0;
var _Vehicle = require("./Vehicle");
var _Sfx = require("../audio/Sfx");
var _Tag = require("curvature/base/Tag");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class PogoSpring extends _Vehicle.Vehicle {
  constructor() {
    super(...arguments);
    _defineProperty(this, "quickDrop", true);
    _defineProperty(this, "passPop", true);
    this.args.type = 'actor-item actor-pogo-spring';
    this.args.width = 32;
    this.args.height = 32;
    this.removeTimer = null;
    this.args.gSpeedMax = 20;
    this.args.decel = 0.45;
    this.args.accel = 0.45;
    this.args.gravity = 0.6;
    this.args.seatHeight = 16;
    this.args.seatForward = -2;
    this.args.skidTraction = 0.05;
    this.args.jumpForce = 8;
    this.dustCount = 0;
    this.args.particleScale = 2;
    this.args.started = false;
    this.args.cameraMode = 'locked';
    this.args.bound = 0;
    this.bindTo('occupant', (v, k, t, d, p) => {
      if (p && !v) {
        this.args.dead = true;
        this.args.gSpeed = 0;
        this.args.xSpeed = 0;
        this.args.ySpeed = 0;
      }
    });
  }
  onRendered(event) {
    super.onRendered(event);
    this.autoStyle.get(this.box)['--bound'] = 'bound';
  }
  update() {
    this.args.active = !!this.occupant;
    if (!this.args.falling && !this.occupant) {
      this.args.dead = false;
    }
    if (this.occupant && !this.args.falling && this.args.ySpeed > 0) {
      this.args.bound = -Math.floor(this.args.ySpeed || 0);
    }
    if (this.occupant && !this.frameout && !this.args.falling) {
      this.args.height = 16 + this.occupant.args.height;
      this.frameout = this.viewport.onFrameOut(1, () => {
        this.args.falling = true;
        this.frameout = false;
        this.args.ySpeed = this.args.bound;
        if (this.args.ySpeed > -3) {
          this.args.ySpeed -= 3;
        }
        if (this.args.ySpeed > -13) {
          this.args.ySpeed -= 3;
        }
        if (this.args.ySpeed < -24) {
          this.args.ySpeed = -24;
        }
      });
      this.args.xSpeed *= 0.3;
      const xDir = this.xAxis || this.xSpeedLast || 0;
      this.args.direction = Math.sign(xDir);
      this.args.facing = Math.sign(xDir) < 0 ? 'left' : 'right';
      _Sfx.Sfx.play('POGO_BOUNCE');
    } else if (!this.occupant) {
      this.args.gSpeed = 0;
      this.args.xSpeed = 0;
    }
    if (!this.occupant) {
      this.args.height = 32;
      this.args.bound = -4;
    }
    this.noClip = this.args.dead;
    super.update();
  }
  collideA(other, type) {
    if (other instanceof PogoSpring) {
      return;
    }
    if (other.args.falling && other.args.ySpeed > 0) {
      this.args.bound = -other.args.ySpeed;
    }
    super.collideA(other, type);
  }
  sleep() {
    this.args.x = this.def.get('x');
    this.args.y = this.def.get('y');
    this.viewport.setColCell(this);
    this.args.dead = false;
    this.args.gSpeed = 0;
    this.args.xSpeed = 0;
    this.args.ySpeed = 0;
    this.args.bound = 0;
    super.sleep();
    this.args.facing = 'right';
  }

  // wakeUp()
  // {
  // 	this.args.x = this.def.get('x');
  // 	this.args.y = this.def.get('y');

  // 	this.args.dead = false;

  // 	this.args.gSpeed = 0;
  // 	this.args.xSpeed = 0;
  // 	this.args.ySpeed = 0;

  // 	this.args.bound  = 0;

  // 	super.sleep();

  // 	this.args.facing = 'right';

  // 	if(!this.args.falling && !this.occupant)
  // 	{
  // 		this.args.dead = false;
  // 	}

  // 	super.wakeUp();
  // }

  get solid() {
    return !this.occupant;
  }
  get rotateLock() {
    return false;
  }
}
exports.PogoSpring = PogoSpring;
});

;require.register("actor/PointActor.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PointActor = void 0;
var _Bindable = require("curvature/base/Bindable");
var _View = require("curvature/base/View");
var _Tag = require("curvature/base/Tag");
var _Twist = require("../effects/Twist");
var _Droop = require("../effects/Droop");
var _Pinch = require("../effects/Pinch");
var _CharacterString = require("../ui/CharacterString");
var _Classifier = require("../Classifier");
var _Controller = require("../controller/Controller");
var _Sheild = require("../powerups/Sheild");
var _FireSheild = require("../powerups/FireSheild");
var _SuperSheild = require("../powerups/SuperSheild");
var _BubbleSheild = require("../powerups/BubbleSheild");
var _NormalSheild = require("../powerups/NormalSheild");
var _ElectricSheild = require("../powerups/ElectricSheild");
var _StarSheild = require("../powerups/StarSheild");
var _LayerSwitch = require("./LayerSwitch");
var _Layer = require("../viewport/Layer");
var _Platformer = require("../behavior/Platformer");
var _Sfx = require("../audio/Sfx");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
const MODE_FLOOR = 0;
const MODE_LEFT = 1;
const MODE_CEILING = 2;
const MODE_RIGHT = 3;
const WALKING_SPEED = 100;
const RUNNING_SPEED = Infinity;
const CRAWLING_SPEED = 1;
const JUMP_FORCE = 15;
const DEFAULT_GRAVITY = MODE_FLOOR;
const BOUNDS = Symbol('BOUNDS');
class PointActor extends _View.View {
  // ringDoc = new DocumentFragment;

  static fromDef(objDef) {
    var _instance$float;
    const objArgs = {
      x: objDef.x + Math.floor(objDef.width / 2),
      y: objDef.y - 1
      // , z:       objDef.id
      ,
      visible: objDef.visible,
      name: objDef.name,
      id: objDef.id
    };
    const def = new Map();
    for (const i in objArgs) {
      if (typeof objArgs[i] === 'object') {
        continue;
      }
      def.set(i, objArgs[i]);
    }
    const others = {};
    for (const i in objDef.properties) {
      const property = objDef.properties[i];
      if (objDef.properties[i].type === 'object') {
        others[property.name] = property.value;
        // continue;
      }

      objArgs[property.name] = property.value;
      def.set(property.name, property.value);
    }
    objArgs.tileId = objDef.gid;
    const instance = new this(Object.assign({}, objArgs));
    instance.others = others;
    instance.def = def;
    instance.objDef = objDef;
    instance.args.float = (_instance$float = instance.float) !== null && _instance$float !== void 0 ? _instance$float : instance.args.float;
    return instance;
  }
  constructor() {
    var _this$args$weight, _this$args$opacity, _this$args$layer, _this$args$active, _this$args$gravity, _this$args$name;
    let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let parent = arguments.length > 1 ? arguments[1] : undefined;
    args[_Bindable.Bindable.NoGetters] = true;
    super(args, parent);
    _defineProperty(this, "template", `<div class  = "point-actor [[type]]">
		<div class = "sprite" cv-ref = "sprite"></div>
	</div>`);
    _defineProperty(this, "profiles", {
      normal: {
        height: 1,
        width: 1,
        decel: 0.85,
        accel: 0.2,
        gravity: 0.65,
        airAccel: 0.3,
        jumpForce: 14,
        gSpeedMax: 100
        // , rollSpeedMax = 37;
      }
    });

    this[_Bindable.Bindable.NoGetters] = true;
    Object.defineProperty(this.nodes, _Bindable.Bindable.NoGetters, {
      value: true
    });
    this.defaultDisplay = 'initial';
    this.others = {};
    this.otherDefs = {};
    this.args.knocked = false;
    this.springing = false;
    this.isGhost = false;
    this.stepsTaken = 0;

    // this.stepCache = {};

    this.fallTime = 0;
    this.idleTime = 0;
    this.groundTime = 0;
    this.locked = 0;
    this.xHold = 12;
    this.yHold = 12;
    this.args.weight = (_this$args$weight = this.args.weight) !== null && _this$args$weight !== void 0 ? _this$args$weight : 100;
    this.args.score = 0;
    this.args.rings = 0;
    this.args.mercy = false;
    this.args.stuck = false;
    this.args.R = 0;
    this.args.popChain = [];
    this.args.canHide = false;
    this.collisionMap = null;
    this.collisionMapFrame = -1;
    this.doorMap = new Map();
    this.args.opacity = (_this$args$opacity = this.args.opacity) !== null && _this$args$opacity !== void 0 ? _this$args$opacity : 1;
    this.args.pushing = false;
    this.autoStyle = new Map();
    this.autoAttr = new Map();
    this.hanging = new Map();
    this.ignores = new Map();
    this.regions = new Set();
    this.powerups = new Set();
    this.behaviors = new Set();
    this.args.lookTime = 0;
    this.behaviors.add(new _Platformer.Platformer());
    this.carrying = new Set();
    this.inventory = new _Classifier.Classifier([_Sheild.Sheild, _FireSheild.FireSheild, _BubbleSheild.BubbleSheild, _ElectricSheild.ElectricSheild, _NormalSheild.NormalSheild]);
    this.splashes = new Set();
    this.noClip = false;
    this.sheild = null;
    this.inventory.addEventListener('adding', event => {
      let item = event.detail.object;
      if (this.inventory.has(item.constructor)) {
        if (!(this.args.currentSheild instanceof _StarSheild.StarSheild)) {
          item = [...this.inventory.get(item.constructor)][0];
          this.args.currentSheild = item;
          item.equip && item.equip(this);
        }
        event.preventDefault();
        return;
      }
      this.powerups.add(item);
      if (this.controllable) {
        const hasKey = `has${item.type[0].toUpperCase() + item.type.substr(1)}`;
        this.viewport.args[hasKey] = hasKey;
      }
      item.acquire && item.acquire(this);
      if (!(this.args.currentSheild instanceof _StarSheild.StarSheild)) {
        this.args.currentSheild = item;
        item.equip && item.equip(this);
      }
    });
    this.inventory.addEventListener('removing', event => {
      const item = event.detail.object;
      this.powerups.delete(item);
      if (this.controllable) {
        const hasKey = `has${item.type[0].toUpperCase() + item.type.substr(1)}`;
        this.viewport.args[hasKey] = null;
      }
      if (_Bindable.Bindable.make(item) === this.args.currentSheild) {
        this.args.currentSheild = null;
      }
    });
    this.args.bindTo('isGhost', (v, k, t, d, p) => this.isGhost = v);
    this.args.bindTo('currentSheild', (v, k, t, d, p) => {
      if (p) {
        p.unequip && p.unequip(this);
      }
      for (const shield of this.inventory.get(_Sheild.Sheild)) {
        if (shield instanceof _SuperSheild.SuperSheild) {
          continue;
        }
        shield.detach();
      }
      v && v.equip && v.equip(this);
      v && v.render(this.sprite);
    });

    // Object.defineProperty(this, 'public', {value: {}});

    // this.args.bindTo((v,k) => {
    // 	this.public[k] = v;
    // });

    this.args.type = 'actor-generic';
    this.args.modeTime = 0;
    this.args.charStrings = [];
    this.args.display = this.args.display || 'initial';
    this.args.rings = 0;
    this.args.coins = 0;
    this.args.emeralds = 0;
    this.args.emblems = [];
    this.args.emblemsCurrent = [];
    this.args.dead = false;
    this.args.respawning = false;
    this.ringSet = new Set();
    this.ringDoc = new DocumentFragment();
    this.args.yMargin = 0;
    this.args.cameraMode = 'normal';
    this.args.cameraBias = 0;
    this.args.layer = (_this$args$layer = this.args.layer) !== null && _this$args$layer !== void 0 ? _this$args$layer : 1;
    this.args.active = (_this$args$active = this.args.active) !== null && _this$args$active !== void 0 ? _this$args$active : false;
    this.args.moving = false;
    this.args.flySpeedMax = 40;
    this.args.x = this.args.x || 1024 + 256;
    this.args.y = this.args.y || 32;
    this.args.z = this.args.z || 0;
    this.args.xOff = 0;
    this.args.yOff = 0;
    this.args.jumpArced = false;
    this.args.width = this.args.width || 1;
    this.args.height = this.args.height || 1;
    this.args.direction = Number(this.args.direction) || 1;
    this.args.heading = 0;
    this.args.gSpeed = this.args.gSpeed || 0;
    this.args.gForce = this.args.gForce || 0;
    this.args.hSpeed = 0;
    this.args.xSpeed = this.args.xSpeed || 0;
    this.args.ySpeed = this.args.ySpeed || 0;
    this.args.angle = this.args.angle || 0;
    this.args.groundAngle = this.args.groundAngle || 0;
    this.args.displayAngle = 0;
    this.args.seatAngle = 0;
    this.args.airAngle = 0;
    const lastAngles = [];
    Object.defineProperty(lastAngles, _Bindable.Bindable.NoGetters, {
      value: true
    });
    this.lastAngles = lastAngles;
    this.angleAvg = 16;
    this.args.xSpeedMax = 512;
    this.args.ySpeedMax = 512;
    this.args.gSpeedMax = WALKING_SPEED;
    this.args.rollSpeedMax = 23;
    this.args.gravity = (_this$args$gravity = this.args.gravity) !== null && _this$args$gravity !== void 0 ? _this$args$gravity : 0.65;
    this.args.decel = 0.40;
    this.args.accel = 0.12;
    this.args.airAccel = 0.3;
    this.args.jumpForce = 14;
    this.args.airTimeTotal = 0;
    this.args.groundTimeTotal = 0;
    this.args.jumping = false;
    this.args.jumpedAt = null;
    this.args.deepJump = false;
    this.args.highJump = false;
    this.maxStep = 11;
    this.backStep = 0;
    this.frontStep = 0;
    this.args.rolling = false;
    this.args.sliding = false;
    this.args.skidTraction = 2.25;
    this.args.skidTraction = 5;
    this.args.fgFilter = 'none';
    this.args.bgFilter = 'none';
    this.args.falling = true;
    this.args.running = false;
    this.args.crawling = false;
    this.args.climbing = false;
    this.args.rotateFixed = false;
    this.args.mode = this.args.mode || MODE_FLOOR;
    this.xAxis = 0;
    this.yAxis = 0;
    this.aAxis = 0;
    this.bAxis = 0;
    this.lAxis = 0;
    this.rAxis = 0;
    this.buttons = {};
    this.stayStuck = false;
    this.willStick = false;
    this.args.startled = this.args.startled || 0;
    this.args.antiSkid = this.args.antiSkid || 0;
    this.args.halted = this.args.halted || 0;
    this.args.ignore = this.args.ignore || 0;
    this.args.float = this.args.float || 0;
    this.colliding = false;
    this.args.flyAngle = 0;
    this.standingUnder = new Set();
    this[BOUNDS] = false;
    this.args.bindTo(['mode', 'falling'], () => {
      this.args.modeTime = 0;
      this[BOUNDS] = false;
    });
    this.moved = false;
    this.args.bindTo(['x', 'y', 'direction'], (v, k, t) => {
      this[BOUNDS] = false;
      isNaN(v) && console.trace(k, v);
      // this.stepCache = {};
      this.idleTime = 0;
      this.moved = true;
    });
    this.args.bindTo(['width', 'height'], (v, k, t) => {
      this[BOUNDS] = false;
      this.moved = true;
    });
    this.args.bindTo(['xSpeed', 'ySpeed'], (v, k, t) => {
      isNaN(v) && console.trace(k, v);
    });
    this.args.bindTo('gSpeed', v => {
      this.gSpeedLast = v || this.gSpeedLast;
    });
    this.args.bindTo('xSpeed', v => {
      this.airAngle = this.args.airAngle = Math.atan2(this.args.ySpeed, v);
      this.xSpeedLast = v || this.xSpeedLast;
    });
    this.args.bindTo('ySpeed', v => {
      this.airAngle = this.args.airAngle = Math.atan2(v, this.args.xSpeed);
      this.ySpeedLast = v || this.ySpeedLast;
    });

    // this.controllable && this.args.bindTo('animation', v => console.trace(v));
    // this.controllable && this.args.bindTo('xSpeed', v => console.trace(v));
    // this.controllable && this.args.bindTo('ySpeed', v => console.trace(v));
    // this.controllable && this.args.bindTo('gSpeed', v => console.trace(v));
    // this.controllable && this.args.bindTo('falling', v => console.trace(v));

    this.impulseMag = null;
    this.impulseDir = null;
    this.args.stopped = 0;
    this.args.particleScale = 1;
    this.dropDashCharge = 0;
    const bindable = _Bindable.Bindable.make(this);
    this.debindGroundX = null;
    this.debindGroundY = null;
    this.debindGroundA = null;
    this.debindGroundL = null;
    this.args.name = (_this$args$name = this.args.name) !== null && _this$args$name !== void 0 ? _this$args$name : '';
    if (this.controllable) {
      this.controller = new _Controller.Controller({
        deadZone: 0.2
      });

      // this.args.charStrings = [
      // 	new CharacterString({value: this.args.name ?? ''})
      // ];

      this.controller.zero();
    }
    this.debindGroundX = new Set();
    this.debindGroundY = new Set();
    this.debindGroundA = new Set();
    this.debindGroundL = new Set();
    this.args.bindTo('standingOn', (groundObject, key, target, previous) => {
      if (this.isGhost) {
        return;
      }
      if (this.args.standingOn === groundObject) {
        return;
      }
      for (const debind of this.debindGroundX) {
        this.debindGroundX.delete(debind);
        debind();
      }
      for (const debind of this.debindGroundY) {
        this.debindGroundY.delete(debind);
        debind();
      }
      for (const debind of this.debindGroundA) {
        this.debindGroundA.delete(debind);
        debind();
      }
      for (const debind of this.debindGroundL) {
        this.debindGroundL.delete(debind);
        debind();
      }
      const prevGroundObject = target[key];
      if (prevGroundObject) {
        if (prevGroundObject.isVehicle) {
          prevGroundObject.occupant = null;
          prevGroundObject.stayStuck = false;
          prevGroundObject.willStick = false;
          prevGroundObject.xAxis = 0;
          prevGroundObject.yAxis = 0;

          // prevGroundObject.args.active = false;
        }

        prevGroundObject.standingUnder && prevGroundObject.standingUnder.delete(this);
      }
      if (!this.viewport) {
        return;
      }
      const Switch = this.viewport.objectPalette['switch'];
      if (this.controllable) {
        if (prevGroundObject && !(prevGroundObject instanceof Switch)) {
          // prevGroundObject.args.active = false;
          this.viewport.auras.delete(prevGroundObject);
        }

        // if(groundObject && !(groundObject instanceof Switch))
        // {
        // 	groundObject.args.active = true;
        // }
      }

      if (!groundObject) {
        this.viewport.auras.delete(this.args.standingOn);
        return;
      }
      groundObject.standingUnder.add(this);
      if (this.controllable && groundObject.isVehicle && !groundObject.dead) {
        if (!this.args.gSpeed) {
          this.args.pushing = false;
        }

        // groundObject.args.active = true;

        const debindGroundX = groundObject.args.bindTo('x', (vv, kk) => {
          const x = groundObject.args.direction * groundObject.args.seatForward || 0;
          const y = groundObject.args.seatHeight || groundObject.args.height || 0;
          const [xRot, yRot] = groundObject.rotatePoint(x, y);
          this.args.x = xRot + vv;
          this.args.y = yRot + groundObject.y;
          this.args.direction = groundObject.args.direction;
        });
        const debindGroundY = groundObject.args.bindTo('y', (vv, kk) => {
          if (this.args.jumping) {
            return;
          }
          const x = groundObject.args.direction * groundObject.args.seatForward || 0;
          const y = groundObject.args.seatHeight || groundObject.args.height || 0;
          const [xRot, yRot] = groundObject.rotatePoint(x, y);
          this.args.x = xRot + groundObject.x;
          this.args.y = yRot + vv;
        });

        // const debindGroundA = groundObject.args.bindTo('groundAngle', (vv,kk) => {

        // 	if(this.args.jumping)
        // 	{
        // 		return;
        // 	}

        // 	const x = groundObject.args.direction * groundObject.args.seatForward || 0;
        // 	const y = groundObject.args.seatHeight || groundObject.args.height || 0;

        // 	const [xRot, yRot] = groundObject.rotatePoint(x, y);

        // 	this.args.x = xRot + groundObject.x;
        // 	this.args.y = yRot + groundObject.y;
        // });

        const debindGroundL = groundObject.args.bindTo('layer', (vv, kk) => {
          this.args.layer = vv;
        });
        this.debindGroundX.add(debindGroundX);
        this.debindGroundY.add(debindGroundY);
        // this.debindGroundA.add(debindGroundA);
        this.debindGroundL.add(debindGroundL);
        const occupant = groundObject.occupant;
        groundObject.args.yMargin = this.args.height;
        if (occupant && occupant !== this) {
          occupant.args.standingOn = null;
          occupant.args.y -= 32;
          occupant.args.gSpeed = 0;
          occupant.args.xSpeed = -5 * this.args.direction;
          occupant.args.ySpeed = -8;
          occupant.args.falling = true;
        }
        this.args.gSpeed = 0;
        this.args.xSpeed = 0;
        this.args.ySpeed = 0;
        this.args.falling = false;
        groundObject.occupant = this;
      } else if (!groundObject.isVehicle) {
        if (this.args.y <= 1 + groundObject.args.y - groundObject.args.height)
          // if(this.args.y <= this.args.height + groundObject.args.y - groundObject.args.height)
          {
            const debindGroundX = groundObject.args.bindTo('x', (vv, kk) => {
              const solid = groundObject.getMapSolidAt(this.args.x + vv + -groundObject.args.x, this.args.y);
              if (solid) {
                return;
              }
              this.args.x += vv + -groundObject.args.x;
            });
            const debindGroundY = groundObject.args.bindTo('y', (vv, kk) => {
              const newY = vv + -groundObject.args.height + (!groundObject.args.falling && (this.controllable || this.isPushable) ? -1 : 0);
              const solid = groundObject.getMapSolidAt(this.args.x, newY);
              if (solid) {
                return;
              }
              this.args.y = newY;
            });
            const debindGroundL = groundObject.args.bindTo('layer', (vv, kk) => {
              this.args.layer = vv;
            });
            this.debindGroundX.add(debindGroundX);
            this.debindGroundY.add(debindGroundY);
            this.debindGroundL.add(debindGroundL);
            if (!groundObject.args.treadmill) {
              this.args.gSpeed -= groundObject.args.gSpeed;
            }
          }
      }
      if (prevGroundObject && prevGroundObject.isVehicle) {
        if (prevGroundObject.occupant === this) {
          prevGroundObject.occupant = null;
          prevGroundObject.stayStuck = false;
          prevGroundObject.willStick = false;
        }
        prevGroundObject.xAxis = 0;
        prevGroundObject.yAxis = 0;
      }
      groundObject.standBelow(this);
    });
    this.age = 0;
    return bindable;
  }
  onRendered() {
    this.sprite = this.findTag('div.sprite');
    this.box = this.findTag('div');
    this.autoStyle.set(this.box, {
      display: 'display',
      '--animation-bias': 'animationBias',
      '--bg-filter': 'bgFilter',
      '--sprite-sheet': 'spriteSheetUrl',
      '--direction': 'direction',
      '--sprite-x': 'spriteX',
      '--sprite-y': 'spriteY',
      '--angle': 'angle',
      '--palletShift': 'palletShift',
      '--fly-angle': 'flyAngle',
      '--display-angle': 'groundAngle8',
      '--ground-angle': 'groundAngle8',
      '--seat-angle': 'seatAngle',
      '--ground-angle8': 'groundAngle8',
      '--air-angle': 'airAngle',
      '--corkscrew': 'corkscrew',
      '--opacity': 'opacity',
      '--height': 'height',
      '--width': 'width',
      '--x': 'x',
      '--y': 'y',
      '--z': 'z'
    });
    this.autoAttr.set(this.box, {
      'data-camera-mode': 'cameraMode',
      'data-colliding': 'colliding',
      'data-direction': 'direction',
      'data-respawning': 'respawning',
      'data-animation': ' animation',
      'data-heading': 'heading',
      'data-super': 'isSuper',
      'data-hyper': 'isHyper',
      'data-mercy': 'mercy',
      'data-selected': 'selected',
      'data-following': 'following',
      'data-carrying': 'carrying',
      'data-reversing': 'reversing',
      'data-falling': 'falling',
      'data-moving': 'moving',
      'data-pushing': 'pushing',
      'data-facing': 'facing',
      'data-filter': 'filter',
      'data-angle': 'angleDeg',
      'data-driving': 'driving',
      'data-active': 'active',
      'data-knocked': 'knocked',
      'data-layer': 'layer',
      'data-dead': 'dead',
      'data-mode': 'mode',
      'data-condition': 'condition',
      'data-netplayer': 'netplayer',
      'data-id': 'id'
    });

    // data-camera-mode = "[[cameraMode]]"
    // data-colliding   = "[[colliding]]"
    // data-falling     = "[[falling]]"
    // data-facing      = "[[facing]]"
    // data-filter      = "[[filter]]"
    // data-angle       = "[[angle|rad2deg]]"
    // data-layer       = "[[layer]]"
    // data-mode        = "[[mode]]"
    // data-id          = "[[id]]"

    if (this.init || !this.viewport) {
      return;
    }

    // const regionClass = this.viewport.objectPalette['base-region']

    // this.isRegion = this instanceof regionClass;

    this.args.bindTo('spriteSheet', v => {
      if (v !== undefined) {
        this.args.spriteSheetUrl = this.urlWrap(v);
      } else {
        this.args.spriteSheetUrl = undefined;
      }
    });
    this.args.bindTo('angle', v => this.args.angleDeg = this.rad2deg(v));
    this.args.charStrings.bindTo(v => {
      if (!this.labels && this.args.charStrings.length) {
        this.labels = _View.View.from('<div class = "labels" cv-ref = "labels" cv-each = "charStrings:charString:c">[[charString]]</div>', {
          charStrings: this.args.charStrings
        });
        this.labels.render(this.sprite);
      } else if (this.labels && !this.args.charStrings.length) {
        this.labels.remove();
        this.labels = null;
      }
    }, {
      wait: 0
    });
    this.init = true;
    this.args.bindTo('animation', (v, k, t, d, p) => {
      // const animations = this.box.getAnimations({subtree:true});
      // animations.forEach(animation => animation.cancel());
      this.box.setAttribute('data-animation', v);
    });
    if (this.controllable) {
      this.sprite.parentNode.classList.add('controllable');
    }
    for (const behavior of this.behaviors) {
      behavior.rendered && behavior.rendered(_Bindable.Bindable.make(this));
    }
  }
  updateStart() {
    this.args.gForce = 0;
    if ((this.isSuper || this.isHyper) && !this.args.currentSheild instanceof _SuperSheild.SuperSheild) {
      const superSheild = new _SuperSheild.SuperSheild();
      superSheild.equip(this);
      this.inventory.add(superSheild);
    } else if (this.args.currentSheild && this.args.currentSheild instanceof _SuperSheild.SuperSheild) {
      const superSheild = this.args.currentSheild;
      superSheild && superSheild.unequip(this);
      this.args.currentSheild = null;
    }
    if (this.args.dead) {
      this.args.xSpeed = 0;
    }
    for (const behavior of this.behaviors) {
      behavior.updateStart && behavior.updateStart(this);
    }
  }
  updateEnd() {
    const speedDir = Math.sign(this.args.gSpeed || this.args.xSpeed || this.args.direction);
    if (speedDir > 0 && this.args.facing === 'left' || speedDir < 0 && this.args.facing === 'right') {
      this.args.reversing = true;
    } else {
      this.args.reversing = false;
    }
    for (const behavior of this.behaviors) {
      behavior.updateEnd && behavior.updateEnd(this);
    }
    if (this.viewport && this.viewport.args.frameId % this.viewport.settings.frameSkip !== 0) {
      return;
    }
    const lastFocus = this.focused;
    if (!this.args.falling) {
      // this.focused = false;
    }
    for (const region of this.regions) {
      if (region.focus) {
        this.viewport.auras.add(region.focus);
        this.focused = region.focus;
      }
    }
    if (lastFocus !== this && lastFocus !== this.focused) {
      this.viewport && this.viewport.auras.delete(lastFocus);
    }
    if (this.focused && this.focused.broken) {
      this.focused = null;
    }
    this.args.groundAngle8 = this.args.groundAngle;
    if (!this.isVehicle && !this.args.falling && !this.args.grinding && this.args.mode === 0 && Math.abs(this.args.groundAngle8) <= Math.PI / 8 + 0.01) {
      this.args.groundAngle8 = 0;
    }
    for (const [tag, cssArgs] of this.autoStyle) {
      const styles = {};
      for (const [prop, arg] of Object.entries(cssArgs)) {
        if (arg in this.args) {
          styles[prop] = this.args[arg];
        }
      }
      tag.style(styles);
    }
    for (const [tag, attrsArgs] of this.autoAttr) {
      const attrs = {};
      for (const [attr, arg] of Object.entries(attrsArgs)) {
        if (arg in this.args) {
          attrs[attr] = this.args[arg];
        }
      }
      tag.attr(attrs);
    }
    for (const splash of this.splashes) {
      splash.x += this.args.xSpeed * (1 - splash.age / 30);
      splash.style({
        '--x': splash.x
      });
      splash.age++;
    }
    if (this.viewport && this.startFrame !== undefined) {
      this.age++;
    } else {
      this.age = 0;
    }
    if (this.screenLock) {
      if (this.args.x < this.screenLock.xMin) {
        this.args.x = this.screenLock.xMin;
      }
      if (this.args.x > this.screenLock.xMax) {
        this.args.x = this.screenLock.xMax;
      }
    }
  }
  update() {
    if (this.locked > 0) {
      this.locked--;
    }
    for (const [object, timeout] of this.ignores) {
      if (timeout <= 0) {
        this.ignores.delete(object);
      } else {
        this.ignores.set(object, -1 + timeout);
      }
    }
    for (const behavior of this.behaviors) {
      behavior.update && behavior.update(this);
    }
  }
  getLocalDrag() {
    if (this.args.dead) {
      return 1;
    }
    let drag = 1;
    for (const region of this.regions) {
      if (region.skimmers.has(this) || region.skimmers.has(_Bindable.Bindable.make(this))) {
        continue;
      }
      if (!region.args.drag && region.args.drag !== 0) {
        continue;
      }
      if (region.args.drag < drag) {
        drag = region.args.drag;
      }
    }
    return drag;
  }
  getLocalFriction() {
    let friction = 1;
    for (const region of this.regions) {
      if (region.skimmers.has(this) || region.skimmers.has(_Bindable.Bindable.make(this))) {
        continue;
      }
      if (!region.args.friction && region.args.friction !== 0) {
        continue;
      }
      if (region.args.friction < friction) {
        friction = region.args.friction;
      }
    }
    return friction;
  }
  setCameraMode() {
    if (!this.viewport) {
      return;
    }
    if (this.args.cameraIgnore) {
      return;
    }
    if (this.args.cameraMode === 'popping' && Math.abs(this.args.xSpeed) > Math.abs(this.args.ySpeed)) {
      this.args.cameraMode = 'aerial';
    }
    if (this.focused) {
      this.args.cameraMode = 'panning';
      return;
    }
    if (this.viewport.args.cutScene) {
      this.args.cameraMode = 'cutScene';
      return;
    }
    if (this.args.bossMode) {
      this.args.cameraMode = 'boss';
      return;
    }
    if (this.args.standingOn && this.args.standingOn.isVehicle) {
      this.args.cameraMode = this.args.standingOn.args.cameraMode;
    } else if (this.args.localCameraMode) {
      this.args.cameraMode = this.args.localCameraMode;
    } else if (this.controllable) {
      if (this.args.mode && !this.args.falling && this.args.rolling && this.args.jumpBlocked) {
        this.args.cameraMode = 'tube';
      } else if (!this.args.falling || this.getMapSolidAt(this.args.x, this.args.y + 24)) {
        // const forwardSolid = this.getMapSolidAt(this.args.x + 32 * this.args.direction, this.args.y + 2);
        // const forwardDeepSolid = this.getMapSolidAt(this.args.x + 32 * this.args.direction, this.args.y + 96);
        // const underSolid   = this.getMapSolidAt(this.args.x + 0  * this.args.direction, this.args.y + 48);

        // if(this.args.mode === MODE_FLOOR && this.args.groundAngle === 0)
        // {
        // 	if(Math.abs(this.args.groundAngle) < Math.PI / 4)
        // 	{
        // 		const standBias = this.args.standingOn
        // 			? this.args.standingOn.args.cameraBias
        // 			: 0;

        // 		if(!standBias && !underSolid && forwardSolid && !this.args.grinding && !this.args.skimming)
        // 		{
        // 			// this.args.cameraMode = 'bridge';
        // 			this.args.cameraMode = 'normal';
        // 		}
        // 		else if(!standBias && !forwardSolid && !forwardDeepSolid && !this.args.grinding && !this.args.skimming)
        // 		{
        // 			// this.args.cameraMode = 'cliff';
        // 			this.args.cameraMode = 'normal';
        // 		}
        // 		else
        // 		{
        // 			this.args.cameraMode = 'normal';
        // 		}
        // 	}
        // 	else
        // 	{
        // 		this.args.cameraMode = 'normal';
        // 	}
        // }
        // else
        // {
        // 	this.args.cameraMode = 'normal';
        // }
        this.args.cameraMode = 'normal';
      } else {
        if (this.getMapSolidAt(this.args.x + 0 * this.args.direction, this.args.y + 64)) {
          if (!this.args.falling || this.args.cameraMode !== 'popping' || Math.abs(this.args.ySpeed) < Math.abs(this.args.xSpeed)) {
            this.args.cameraMode = 'normal';
          }
        } else if (this.fallTime > 45) {
          if (this.args.cameraMode !== 'panning' && (this.args.cameraMode !== 'popping' || this.args.ySpeed > 10)) {
            this.args.cameraMode = 'aerial';
          }
        }
        this.viewport.onFrameOut(45, () => {
          if (this.args.cameraMode === 'airplane') {
            return;
          }
          if (this.args.falling && this.isVehicle && Math.abs(this.args.xSpeed > 25) && !this.getMapSolidAt(this.args.x, this.args.y + 480)) {
            this.args.cameraMode = 'airplane';
          }
        });
      }
    }
  }
  callCollideHandler(other) {
    if (!this.viewport) {
      return;
    }
    const viewport = this.viewport;

    // if(viewport.collisionCache.has(this) && viewport.collisionCache.get(this).has(other))
    // {
    // 	return viewport.collisionCache.get(this).get(other);
    // }

    if (this.ignores.has(other)) {
      return false;
    }
    if (other.ignores.has(this)) {
      return false;
    }
    if (this.args.dead || other.args.dead) {
      return;
    }
    if (other === this.args.hangingFrom) {
      return false;
    }
    if (this.isGhost || other.isGhost) {
      return;
    }
    let type;
    if (other.args.y <= this.args.y - this.args.height) {
      this.args.collType = 'collision-top';
      type = 0;
    } else if (other.args.x < this.args.x - Math.floor(this.args.width / 2)) {
      this.args.collType = 'collision-left';
      type = 1;
    } else if (other.args.x >= this.args.x + Math.floor(this.args.width / 2)) {
      this.args.collType = 'collision-right';
      type = 3;
    } else if (other.args.y >= this.args.y) {
      this.args.collType = 'collision-bottom';
      type = 2;
    } else {
      this.args.collType = 'collision-intersect';
      type = -1;

      // this.solid && !this.isVehicle && this.popOut(other);
    }

    if (!viewport.collisions.has(this)) {
      viewport.collisions.set(this, new Map());
    }
    if (!viewport.collisions.has(other)) {
      viewport.collisions.set(other, new Map());
    }

    // if(!viewport.collisionCache.has(this))
    // {
    // 	viewport.collisionCache.set(this, new Map);
    // }

    // if(this.viewport.collisions.get(this).has(other))
    // {
    // 	return;
    // }

    const invertType = type > -1 ? (type + 2) % 4 : type;

    // other.pause(true);

    // this.viewport.collisions.set(other, collisionListB);

    this.collideB(other, type);
    other.collideB(this, invertType);
    const ab = this.collideA(other, type);
    const ba = other.collideA(this, invertType);
    const result = ab || ba;

    // viewport.collisionCache.get(this).set(other, result);

    this.args.colliding = this.colliding = this.colliding || result || false;
    if (result !== false) {
      const collisionListA = viewport.collisions.get(this, type);
      const collisionListB = viewport.collisions.get(other, invertType);
      collisionListA.set(other, type);
      collisionListB.set(this, invertType);
    }
    return result;
  }
  processInput() {
    if (this.controllable && this.args.standingOn && this.args.standingOn.isVehicle && this === _Bindable.Bindable.make(this.args.standingOn.occupant)) {
      if (this.args.modeTime < 5) {
        return;
      }
      this.viewport.auras.add(this.args.standingOn);
      const vehicle = this.args.standingOn;
      vehicle.xAxis = this.xAxis;
      vehicle.yAxis = this.yAxis;
      vehicle.stayStuck = this.stayStuck;
      vehicle.willStick = this.willStick;
      this.processInputVehicle();
      this.args.direction = vehicle.args.direction;
      this.args.facing = vehicle.args.facing;
      this.args.layer = vehicle.args.layer;
      this.args.mode = vehicle.args.mode;
      this.args.angle = vehicle.args.angle;

      // const seatX = (vehicle.args.seatX || 0) * this.args.direction;
      // const seatY = (vehicle.args.seatY || 0);

      // this.args.x = vehicle.args.x + seatX;
      // this.args.y = vehicle.args.y + vehicle.args.height + seatY;
    } else if (this.controllable) {
      this.processInputDirect();
    }
  }
  processInputDirect() {
    let xAxis = this.xAxis;
    let yAxis = this.yAxis;
    let gSpeedMax = this.args.gSpeedMax;
    if (this.running) {
      gSpeedMax = RUNNING_SPEED;
    } else if (this.crawling) {
      gSpeedMax = CRAWLING_SPEED;
    }
    const drag = this.getLocalDrag();
    if (this.noClip) {
      if (!this.args.ignore) {
        this.args.xSpeed += xAxis * this.args.airAccel * drag;
        this.args.ySpeed += yAxis * this.args.airAccel * drag;
        if (!xAxis) {
          this.args.xSpeed = 0;
        }
        if (!yAxis) {
          this.args.ySpeed = 0;
        }
      }
    } else if (!this.args.falling) {
      const grindInput = !this.args.grinding || Math.sign(this.args.gSpeed) === Math.sign(this.xAxis) || Math.abs(this.args.gSpeed) > 6 && Math.abs(this.args.gSpeed) < this.args.gSpeedMax * 2 || this.args.gSpeed === 0;
      if (!this.args.rolling && grindInput && this.yAxis < 0.55 && Math.abs(this.yAxis) <= Math.abs(this.xAxis) && !this.spindashCharge) {
        const axisSign = Math.sign(xAxis);
        let gSpeed = this.args.gSpeed;
        const sign = Math.sign(gSpeed);
        const friction = this.getLocalFriction();
        if (!this.args.ignore) {
          if (!this.args.rolling && !this.args.sliding && !this.args.climbing && !this.args.wallSticking) {
            if (axisSign === sign || !sign) {
              if (Math.abs(axisSign - sign) < 2) {
                gSpeed += xAxis * friction * this.args.accel * drag;
                // this.args.ignore = 10;
              }
            } else if (!this.args.ignore && !this.args.antiSkid && Math.abs(gSpeed) > 1) {
              gSpeed += xAxis * 0.5 * friction * this.args.accel * drag * this.args.skidTraction;
            }
          }
          if (!Math.sign(this.args.gSpeed) || Math.sign(this.args.gSpeed) === Math.sign(gSpeed)) {
            if (this.args.pushing && Math.sign(xAxis) !== Math.sign(this.args.pushing)) {
              this.args.gSpeed = 0;
            } else if (!xAxis || Math.abs(gSpeed) < gSpeedMax || Math.sign(gSpeed) !== Math.sign(xAxis)) {
              this.args.gSpeed = gSpeed;
            }
          } else {
            this.args.gSpeed = 0;
            return;
          }
        }
      }
    } else if (this.args.falling && xAxis && Math.abs(this.args.xSpeed) < this.args.xSpeedMax) {
      if (Math.abs(this.args.xSpeed) < this.args.gSpeedMax && !this.args.ignore) {
        this.args.xSpeed += xAxis * this.args.airAccel * drag;
      }

      // const tileMap = this.viewport.tileMap;

      // if(!this.noClip && this.getMapSolidAt(this.x + (this.args.width / 2) * Math.sign(this.args.xSpeed), this.y))
      // {
      // 	this.args.xSpeed = 0;
      // }
    }

    if (xAxis < 0 && (this.args.gSpeed || this.args.stuck) && !this.args.ignore) {
      if (!this.args.climbing) {
        this.args.facing = 'left';
      }
      if (!this.args.grinding || Math.abs(this.args.gSpeed) < 3) {
        this.args.direction = -1;
      }
    }
    if (xAxis > 0 && (this.args.gSpeed || this.args.stuck) && !this.args.ignore) {
      if (!this.args.climbing) {
        this.args.facing = 'right';
      }
      if (!this.args.grinding || Math.abs(this.args.gSpeed) < 3) {
        this.args.direction = 1;
      }
    }
    if (this.args.currentSheild instanceof _StarSheild.StarSheild) {
      return;
    }
    if (this.aAxis < -0.75) {
      if (this.inventory.has(_ElectricSheild.ElectricSheild)) {
        this.args.currentSheild = [...this.inventory.get(_ElectricSheild.ElectricSheild)][0];
      } else {
        this.args.currentSheild = '';
      }
    }
    if (this.aAxis > +0.75) {
      if (this.inventory.has(_FireSheild.FireSheild)) {
        this.args.currentSheild = [...this.inventory.get(_FireSheild.FireSheild)][0];
      } else {
        this.args.currentSheild = '';
      }
    }
    if (this.bAxis < -0.75) {
      if (this.inventory.has(_BubbleSheild.BubbleSheild)) {
        this.args.currentSheild = [...this.inventory.get(_BubbleSheild.BubbleSheild)][0];
      } else {
        this.args.currentSheild = '';
      }
    }
    if (this.bAxis > +0.75) {
      if (this.inventory.has(_NormalSheild.NormalSheild)) {
        this.args.currentSheild = [...this.inventory.get(_NormalSheild.NormalSheild)][0];
      } else {
        this.args.currentSheild = '';
      }
    }
  }
  processInputVehicle() {
    this.args.standingOn.processInputDirect();
  }
  collideA(other, type) {
    return this.solid;
  }
  collideB(other) {}
  castRay() {
    let length = 1;
    let callback = () => {};
    let angle = Math.PI / 2;
    let offset = [0, 0];
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    switch (args.length) {
      case 2:
        [length, callback] = args;
        break;
      case 3:
        [length, angle, callback] = args;
        break;
      case 4:
        [length, angle, offset, callback] = args;
        break;
    }
    const nearbyActors = new Set(viewport.actorsAtPoint(this.args.x, this.args.y + length, this.args.width + length, this.args.height + length * 2));
    let hit = false;
    for (let i = 0; i < Math.floor(length); i++) {
      const x = this.args.x + offset[0] + i * Math.cos(angle);
      const y = this.args.y + offset[1] + i * Math.sin(angle);

      // window.logPoints && window.logPoints(x, y, 'mode-' + this.args.mode);

      const bottom = [x, y];
      const retVal = callback(i, bottom, nearbyActors, this);
      if (retVal !== undefined) {
        return retVal;
      }
    }
    return false;
  }
  castRayQuick(length, angle) {
    let offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [0, 0];
    let collides = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
    if (!this.viewport || !this.viewport.tileMap) {
      return;
    }
    const thisPointX = this.args.x + offset[0];
    const thisPointY = this.args.y + offset[1];
    const solidPoint = this.viewport.tileMap.castRay(thisPointX, thisPointY, angle, length, this.getCollisionMap());
    let magnitude = length;
    if (solidPoint) {
      magnitude = Math.hypot(thisPointX - solidPoint[0], thisPointY - solidPoint[1]);
    }
    const endPointX = thisPointX + Math.cos(angle) * magnitude;
    const endPointY = thisPointY + Math.sin(angle) * magnitude;
    const actorsAtLine = this.viewport.actorsAtLine(thisPointX, thisPointY, endPointX, endPointY);
    actorsAtLine.delete(_Bindable.Bindable.make(this));
    actorsAtLine.delete(this);
    const collisions = new Map();
    if (collides) {
      for (const [actor, collision] of actorsAtLine) {
        if (actor.callCollideHandler(this) !== false) {
          collisions.set(actor, collision);
        }
      }
    }
    for (const [actor, collision] of collisions) {
      if (collision.distance > magnitude) {
        continue;
      }
      if (this.checkSolidActors(actor)) {
        return collision.distance;
      }
    }
    if (solidPoint) {
      return magnitude;
    }
    return false;
  }
  impulse(magnitude, direction) {
    let willFall = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    this.impulseMag = magnitude;
    this.impulseDir = direction;
    this.impulseFal = willFall;
  }
  rad2deg(rad) {
    const deg = 180 / Math.PI * rad;
    if (deg > 0) {
      return Math.round(Math.floor(deg * 10) / 10);
    }
    return Math.round(Math.ceil(deg * 10) / 10);
  }
  roundAngle(angle, segments) {
    segments /= 2;
    let rAngle = Math.round(angle / (Math.PI / segments)) * Math.PI / segments;
    return rAngle;
  }
  findNearestActor(selector, maxDistance) {
    let direction = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    const viewport = this.viewport;
    if (!viewport) {
      return;
    }
    const cells = viewport.getNearbyColCells(this.args.x, this.args.y);
    let closest = null;
    let minDist = Infinity;
    for (const cell of cells) {
      for (const actor of cell) {
        if (actor === this) {
          continue;
        }
        if (actor.args.gone) {
          continue;
        }
        if (!selector(actor)) {
          continue;
        }
        const distance = this.distanceFrom(actor);
        if (Math.abs(distance) > maxDistance) {
          continue;
        }
        if (distance < minDist) {
          closest = actor;
          minDist = distance;
        }
      }
    }
    return closest;

    // const actors = new Map;

    // cells.map(s => s.forEach(a =>{

    // 	if(a === this)
    // 	{
    // 		return;
    // 	}

    // 	if(a.args.gone)
    // 	{
    // 		return;
    // 	}

    // 	if(!selector(a))
    // 	{
    // 		return;
    // 	}

    // 	const distance = this.distanceFrom(a);
    // 	const angle    = Math.atan2(a.y - this.y, a.args.x - this.args.x);

    // 	if(Math.abs(distance) > maxDistance)
    // 	{
    // 		return;
    // 	}

    // 	actors.set(distance, a);
    // }));

    // const distances = [...actors.keys()];
    // const shortest  = Math.min(...distances);

    // const closest = actors.get(shortest);

    // return closest;
  }

  immune(other) {
    let type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'normal';
    // if(this.args.mercy)
    // {
    // 	return true;
    // }

    const shield = this.args.currentSheild;
    if (shield && shield.immune && shield.immune(this, other, type)) {
      return true;
    }
    return false;
  }
  totalCombo() {
    let fail = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    if (!this.args.popChain.length) {
      return;
    }
    if (this.eraseCombo) {
      this.eraseCombo();
      this.eraseCombo = false;
    }
    this.args.popCombo = 0;
    let multiply = 0;
    let base = 0;
    for (const pop of this.args.popChain) {
      multiply += pop.multiplier;
      base += pop.points;
    }
    const total = Math.ceil(base * multiply);
    this.args.popChain.length = 0;
    if (!total) {
      this.viewport.args.comboResult = null;
      this.viewport.args.comboFail = null;
      return;
    }
    this.eraseCombo = this.viewport.onFrameOut(360, () => {
      this.viewport.args.comboResult = null;
      this.viewport.args.comboFail = null;
    });
    if (fail) {
      this.viewport.args.comboFail = new _CharacterString.CharacterString({
        value: total,
        color: 'red-light'
      });
      this.viewport.args.comboResult = null;
      return;
    }
    this.viewport.args.comboResult = new _CharacterString.CharacterString({
      value: '+' + total,
      color: 'green-light'
    });
    this.viewport.args.comboFail = null;
    this.args.score += total;
  }
  sap() {
    let amount = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    let type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'normal';
    if (this.args.dead) {
      return;
    }
    this.totalCombo(true);
    _Sfx.Sfx.play('SAP_HEALTH');
    if (this.isSuper || this.isHyper) {
      return;
    }
    this.args.condition = 'sapped-' + type;
    if (this.viewport) {
      this.viewport.onFrameOut(5, () => this.args.condition = '');
    }
    if (this.args.rings > 0) {
      this.args.rings -= amount;
      if (this.viewport && this.viewport.settings.rumble) {
        if (this.controller && this.controller.rumble) {
          this.controller.rumble({
            duration: 100,
            strongMagnitude: 0.5,
            weakMagnitude: 1.0
          });
        }
      }
    } else if (this.controllable) {
      this.die();
      if (this.viewport.settings.rumble) {
        this.controller.rumble({
          duration: 450,
          strongMagnitude: 1.0,
          weakMagnitude: 1.0
        });
      }
    }
  }
  damage(other) {
    let type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'normal';
    if (this.args.mercy) {
      return;
    }
    this.dashed = this.args.jumping = this.args.spinning = false;
    const damageEvent = new CustomEvent('damage', {
      cancelable: true,
      detail: {
        other,
        type
      }
    });
    if (this.isHyper) {
      return;
    }
    if (this.isSuper) {
      this.onNextFrame(() => this.startle(other));
      this.args.mercy = 30;
      return;
    }
    if (!this.immune(other, type)) {
      if (!this.dispatchEvent(damageEvent)) {
        if (!damageEvent.detail.immune) {
          this.args.y -= 8;
          this.onNextFrame(() => this.startle(other));
          this.args.mercy = 180;
          if (this.viewport.settings.rumble) {
            this.controller.rumble({
              duration: 350,
              strongMagnitude: 1.0,
              weakMagnitude: 1.0
            });
          }
          this.totalCombo(true);
          this.lightDashReward = this.grindReward = this.airReward = null;
        }
        return;
      }
    } else {
      return;
    }
    if (this.args.rings) {
      this.loseRings();
      this.args.rings = 0;
      this.onNextFrame(() => this.startle(other));
      this.args.mercy = 180;
      this.totalCombo(true);
      if (this.viewport.settings.rumble) {
        this.controller.rumble({
          duration: 350,
          strongMagnitude: 1.0,
          weakMagnitude: 1.0
        });
        this.onTimeout(350, () => {
          this.controller.rumble({
            duration: 150,
            strongMagnitude: 0.5,
            weakMagnitude: 1.0
          });
        });
      }
    } else if (this.controllable) {
      this.die();
      this.totalCombo(true);
      if (this.viewport.settings.rumble) {
        this.controller.rumble({
          duration: 450,
          strongMagnitude: 1.0,
          weakMagnitude: 1.0
        });
      }
    }
  }
  startle(other) {
    if (this.noClip) {
      return;
    }
    this.args.startled = 0;
    const direction = Math.sign(other && (other.args.xSpeed || other.args.x - other.xLast || other.args.x - this.args.x) || this.x - this.xLast || this.args.xSpeed || this.args.gSpeed || this.args.direction);
    this.args.jumping = false;
    this.args.falling = true;
    this.args.startled = 180;
    this.args.ignore = 30;
    this.args.float = 1;
    this.args.xSpeed = -2.25 * direction;
    this.args.ySpeed = -8;
    this.args.x += this.args.xSpeed;
    this.args.flying = false;
    this.args.dashed = false;
    this.args.lightDashed = false;
    this.args.lightDashing = false;
    this.args.gSpeed = 0;
    this.args.standingOn = false;
    if (this.args.mode === MODE_CEILING) {
      this.args.mode = 0;
      this.args.y += this.args.height;
      this.args.ySpeed = 4;
    } else {
      this.args.y -= 4;
    }
  }
  checkSolidActors(x) {
    if (x.args === this.args) {
      return false;
    }
    if (!x.solid) {
      return false;
    }
    if (x.args.platform || x.isVehicle) {
      if (this.args.y <= x.args.y + -x.args.height && this.args.ySpeed >= 0) {
        return true;
      }
      return false;
    }
    return true;
  }

  // findSolid(i, point, actor)
  // {
  // 	if(!actor.viewport)
  // 	{
  // 		return;
  // 	}

  // 	const viewport = actor.viewport;
  // 	const tileMap  = viewport.tileMap;

  // 	const actors = viewport.actorsAtPoint(point[0], point[1]);

  // 	for(const a of actors)
  // 	{
  // 		if(actor.checkSolidActors(a))
  // 		{
  // 			return i;
  // 		}
  // 	}

  // 	const solid = tileMap.getSolid(point[0], point[1], actor.args.layer, Math.sign(this.args.ySpeed));

  // 	if(actor.upScan)
  // 	{
  // 		actor.lastLayer = solid;
  // 	}

  // 	if(solid)
  // 	{
  // 		return i;
  // 	}
  // }

  // findSolidTile(i, point, actor)
  // {
  // 	if(!actor.viewport)
  // 	{
  // 		return;
  // 	}

  // 	const viewport = actor.viewport;
  // 	const tileMap  = viewport.tileMap;

  // 	const solid = tileMap.getSolid(point[0], point[1], actor.args.layer, Math.sign(this.args.ySpeed));

  // 	if(actor.upScan)
  // 	{
  // 		actor.lastLayer = solid;
  // 	}

  // 	if(solid)
  // 	{
  // 		return i;
  // 	}
  // }

  scanBottomEdge() {
    let direction = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    const tileMap = this.viewport.tileMap;
    const radius = this.args.width / 2;
    const leftCorner = tileMap.getSolid(this.x - radius, this.y + 1, this.args.layer);
    const rightCorner = tileMap.getSolid(this.x + radius, this.y + 1, this.args.layer);
    if (leftCorner && rightCorner) {
      return;
    }
    return this.castRay(this.args.width, -direction < 0 ? Math.PI : 0, [direction * radius, 0], (i, point) => {
      let solids = this.getMapSolidAt(point[0], point[1] + 1);
      if (Array.isArray(solids)) {
        solids = solids.filter(s => s.callCollideHandler(this)).length;
      }
      if (solids) {
        return this.args.width - i;
      }
      // const actors = this.viewport
      // 	.actorsAtPoint(point[0], point[1])
      // 	.filter(a => a.args !== this.args);

      // if(!actors.length && !tileMap.getSolid(point[0], point[1] + 1, this.args.layer))
      // {
      // 	return i;
      // }
    });
  }

  get realAngle() {
    const args = this.args;
    if (args.standingOn && !args.mode) {
      return args.standingOn.realAngle;
    }
    if (args.falling) {
      return -args.groundAngle - Math.PI;
    }
    switch (args.mode) {
      case 0:
        return -args.groundAngle - Math.PI;
      case 1:
        return -args.groundAngle - Math.PI / 2;
      case 2:
        return -args.groundAngle;
      case 3:
        return -args.groundAngle + Math.PI / 2;
    }
  }
  get downAngle() {
    switch (this.args.mode) {
      case MODE_FLOOR:
        return Math.PI / 2;
        break;
      case MODE_RIGHT:
        return 0;
        break;
      case MODE_CEILING:
        return -Math.PI / 2;
        break;
      case MODE_LEFT:
        return Math.PI;
        break;
    }
  }
  get upAngle() {
    switch (this.args.mode) {
      case MODE_FLOOR:
        return -Math.PI / 2;
        break;
      case MODE_RIGHT:
        return Math.PI;
        break;
      case MODE_CEILING:
        return Math.PI / 2;
        break;
      case MODE_LEFT:
        return 0;
        break;
    }
  }
  get leftAngle() {
    switch (this.args.mode) {
      case MODE_FLOOR:
        return Math.PI;
        break;
      case MODE_RIGHT:
        return -Math.PI / 2;
        break;
      case MODE_CEILING:
        return 0;
        break;
      case MODE_LEFT:
        return Math.PI / 2;
        break;
    }
  }
  get rightAngle() {
    switch (this.args.mode) {
      case MODE_FLOOR:
        return 0;
        break;
      case MODE_RIGHT:
        return Math.PI / 2;
        break;
      case MODE_CEILING:
        return Math.PI;
        break;
      case MODE_LEFT:
        return -Math.PI / 2;
        break;
    }
  }
  get groundPoint() {
    switch (this.args.mode) {
      case MODE_FLOOR:
        return [this.args.x + 0, this.args.y + 1];
        break;
      case MODE_RIGHT:
        return [this.args.x + 1, this.args.y + 0];
        break;
      case MODE_CEILING:
        return [this.args.x + 0, this.args.y - 1];
        break;
      case MODE_LEFT:
        return [this.args.x - 1, this.args.y + 0];
        break;
    }
  }
  rotatePoint(x, y) {
    const xRot = x * Math.cos(this.realAngle) - y * Math.sin(this.realAngle);
    const yRot = y * Math.cos(this.realAngle) + x * Math.sin(this.realAngle);
    return [xRot, yRot];
  }
  standBelow(other) {}
  filterSolidActors(x) {
    if (x.args === this.args) {
      return false;
    }
    if (!x.solid) {
      return false;
    }
    if (x.args.platform || x.isVehicle) {
      if (this.args.y >= x.args.y && this.args.ySpeed >= 0 && this.args.mode === 2) {
        return true;
      }
      if (this.args.y <= x.args.y + -x.args.height + 1 && this.args.ySpeed >= 0) {
        return true;
      }
      return false;
    }
    return true;
  }
  getMapSolidAt(x, y) {
    let actors = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
    let nearbyActors = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    if (!this.viewport) {
      return;
    }
    if (this.screenLock) {
      if (x < this.screenLock.xMin || x > this.screenLock.xMax) {
        return true;
      }
    }
    if (actors) {
      const actors = this.viewport.actorsAtPoint(x, y, 0, 0, {
        nearbyActors
      }).filter(this.filterSolidActors.bind(this));
      if (actors.length > 0) {
        return actors;
      }
    }
    const tileMap = this.viewport.tileMap;
    return tileMap.getSolid(x, y, this.getCollisionMap());
  }
  get canRoll() {
    return false;
  }
  get canFly() {
    return false;
  }
  get canStick() {
    return false;
  }
  get canSpindash() {
    return false;
  }
  get isEffect() {
    return false;
  }
  // get isGhost() { return false; }
  get isPushable() {
    return false;
  }
  get isVehicle() {
    return false;
  }
  get solid() {
    return false;
  }
  get x() {
    return this.args.x;
  }
  get y() {
    return this.args.y;
  }
  get point() {
    return [this.args.x, this.args.y];
  }
  get rotateLock() {
    return false;
  }
  get controllable() {
    return false;
  }
  get skidding() {
    return Math.abs(this.args.gSpeed) && this.args.direction && !this.args.antiSkid && !this.args.grinding && Math.sign(this.args.gSpeed) !== this.args.direction;
  }
  effect(other) {}
  readInput() {
    if (!this.controller) {
      return;
    }
    const controller = this.controller;
    this.xAxis = 0;
    this.yAxis = 0;
    if (!controller.axes) {
      return;
    }
    if (controller.axes[0]) {
      this.xAxis = controller.axes[0].magnitude;
      if (Math.abs(this.xAxis) > 0.55) {
        this.xAxis = Math.sign(this.xAxis);
      }
      if (Math.abs(this.xAxis) < 0.1) {
        this.xAxis = 0;
      }
    }
    if (controller.axes[1]) {
      this.yAxis = controller.axes[1].magnitude;
      if (Math.abs(this.yAxis) > 0.55) {
        this.yAxis = Math.sign(this.yAxis);
      }
      if (Math.abs(this.yAxis) < 0.1) {
        this.yAxis = 0;
      }
    }

    // if(controller.axes[6] && controller.axes[6].magnitude)
    // {
    // 	this.xAxis = controller.axes[6].magnitude;
    // }
    // else if(controller.axes[0] && controller.axes[0].magnitude)
    // {
    // 	this.xAxis = controller.axes[0].magnitude;
    // }

    // if(controller.axes[7] && controller.axes[7].magnitude)
    // {
    // 	this.yAxis = controller.axes[7].magnitude;
    // }
    // else if(controller.axes[1] && controller.axes[1].magnitude)
    // {
    // 	this.yAxis = controller.axes[1].magnitude;
    // }

    if (0 && controller.axes[7]) {
      if (controller.axes[3]) {
        this.aAxis = controller.axes[3].magnitude;
      }
      if (controller.axes[4]) {
        this.bAxis = controller.axes[4].magnitude;
      }
    } else {
      if (controller.axes[2]) {
        this.aAxis = controller.axes[2].magnitude;
      }
      if (controller.axes[3]) {
        this.bAxis = controller.axes[3].magnitude;
      }
    }
    const buttons = controller.buttons;
    this.buttons = buttons;

    // if(this.args.ignore > 0)
    // {
    // 	this.xAxis = 0;
    // 	this.yAxis = 0;
    // }

    for (const i in buttons) {
      const button = buttons[i];
      const release = `release_${i}`;
      const press = `command_${i}`;
      const hold = `hold_${i}`;
      if (i == 0 && button.delta === 1 && (this.yAxis && this.args.falling || this.args.standingOn && this.args.standingOn.quickDrop) || !this.args.standingOn || !this.args.standingOn.isVehicle) {
        if (button.delta === 1) {
          let cancel = false;
          if (this.args.currentSheild && press in this.args.currentSheild) {
            if (this.args.currentSheild[press](this, button) === false) {
              cancel = true;
            }
          }
          if (!cancel) {
            for (const behavior of [...this.behaviors].reverse()) {
              if (behavior[press]) {
                if (behavior[press](this, button) === false) {
                  cancel = true;
                  break;
                }
              }
            }
          }
          if (!cancel) {
            this[press] && this[press](button);
          }
        } else if (button.delta === -1) {
          let cancel = false;
          for (const behavior of this.behaviors) {
            if (behavior[release]) {
              if (behavior[release](this, button) === false) {
                cancel = true;
              }
            }
          }
          if (!cancel) {
            if (this.args.currentSheild && release in this.args.currentSheild) {
              this.args.currentSheild[release](this, button);
            }
            this[release] && this[release](button);
          }
        } else if (button.active) {
          let cancel = false;
          for (const behavior of this.behaviors) {
            if (behavior[hold]) {
              if (behavior[hold](this, button) === false) {
                cancel = true;
              }
            }
          }
          if (!cancel) {
            if (this.args.currentSheild && hold in this.args.currentSheild) {
              this.args.currentSheild[hold](this, button);
            }
            this[hold] && this[hold](button);
          }
        }
      } else if (this.args.standingOn && this.args.standingOn.isVehicle) {
        this.args.jumping = false;
        this.args.flying = false;
        const vehicle = this.args.standingOn;
        if (button.delta === 1) {
          vehicle[press] && vehicle[press](button);
          for (const behavior of vehicle.behaviors) {
            if (behavior[press]) {
              behavior[press](vehicle, button);
            }
          }
        } else if (button.delta === -1) {
          vehicle[release] && vehicle[release](button);
          for (const behavior of vehicle.behaviors) {
            if (behavior[release]) {
              behavior[release](vehicle, button);
            }
          }
        } else if (button.active) {
          vehicle[hold] && vehicle[hold](button);
          for (const behavior of vehicle.behaviors) {
            if (behavior[hold]) {
              behavior[hold](vehicle, button);
            }
          }
        }
      }
    }
  }
  distanceFrom(_ref) {
    let {
      x,
      y
    } = _ref;
    return Math.hypot(this.x - x, this.y - y);
  }
  twist(warp) {
    if (!this.twister) {
      const filterContainer = this.viewport.tags.bgFilters;
      const html = `<div class = "point-actor-filter twist-filter">`;
      this.twistFilter = new _Tag.Tag(html);
      filterContainer.appendChild(this.twistFilter.node);
      this.twister = new _Twist.Twist({
        id: 'twist-' + this.args.id,
        scale: 60
      });
      this.twister.args.bindTo(['x', 'y', 'width', 'height', 'xOff', 'yOff'], (v, k) => {
        this.twistFilter.style({
          [`--${k}`]: v,
          filter: `url(#twist-${this.args.id})`
        });
      });
      this.twister.args.yOff = 16;
      this.twister.render(this.twistFilter.node);
      this.onRemove(() => this.twistFilter.remove());
    }
    this.twister.args.scale = warp;
  }
  pinch() {
    let warpBg = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    let warpFg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    if (!this.pincherBg) {
      const filterContainer = this.viewport.tags.bgFilters;
      const type = this.args.type.split(' ').shift();
      const html = `<div class = "point-actor-filter pinch-filter">`;
      this.pinchFilterBg = new _Tag.Tag(html);
      filterContainer.appendChild(this.pinchFilterBg.node);
      this.pincherBg = new _Pinch.Pinch({
        id: 'pinch-' + this.args.id,
        scale: 60
      });
      this.pincherBg.args.bindTo(['x', 'y', 'width', 'height', 'xOff', 'yOff'], (v, k) => {
        this.pinchFilterBg.style({
          [`--${k}`]: v,
          filter: `url(#pinch-${this.args.id})`
        });
      });
      this.pincherBg.render(this.pinchFilterBg);
      this.onRemove(() => this.pinchFilterBg.remove());
    }
    this.pincherBg.args.scale = warpBg;
  }
  droop() {
    let warpFactor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    let xPosition = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    let xMax = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    if (xMax === null) {
      xMax = xPosition;
    }
    const half = this.args.width / 2;
    if (!this.drooperFg) {
      this.drooperFg = new _Droop.Droop({
        id: 'droop-' + this.args.id,
        width: this.args.width * 3,
        height: this.args.height * 3,
        scale: 64
      });
      this.args.bindTo(['x', 'y'], (v, k) => {
        this.drooperFg.args[k] = Number(v);
      });
      this.onNextFrame(() => {
        this.drooperFg.args.scale = Number(warpFactor * 2);
        this.sprite.style({
          transform: `translate(-50%, calc(${warpFactor}px + calc(-100% + 1px)))`,
          filter: `url(#droop-${this.args.id})`
        });
        this.drooperFg.args.dx = -xPosition;
      });
      this.drooperFg.render(this.sprite);
      return;
    }
    this.drooperFg.args.scale = Number(warpFactor * 2);
    this.sprite.style({
      transform: `translate(-50%, calc(${warpFactor}px + calc(-100% + 1px)))`,
      filter: `url(#droop-${this.args.id})`
    });
    const droopCenter = 1 - xPosition / half;
    const posFactor = xPosition / this.args.width;
    this.drooperFg.args.droopWidthLeft = `${51 * droopCenter + 1}%`;
    this.drooperFg.args.droopRightStart = `${51 * droopCenter}%`;
    this.drooperFg.args.droopWidthRight = `${102 + -51 * droopCenter}%`;
  }
  crossRegionBoundary(region) {
    if (!region || this.args.static) {
      return;
    }

    // const drag = region.args.drag;

    // this.args.xSpeed *= drag;
    // this.args.ySpeed *= drag;
    // this.args.gSpeed *= drag;

    if (this.viewport) {
      const viewport = this.viewport;
      if (!this.args.gone && this.args.moving && Math.abs(this.args.y - (region.args.y + -region.args.height)) <= Math.abs(this.args.ySpeed || this.args.gSpeed) && region.entryParticle) {
        const splash = new _Tag.Tag(region.entryParticle);
        if (splash.node) {
          splash.age = 0;
          splash.x = this.args.x;
          splash.style({
            '--x': this.args.x,
            '--y': region.args.y + -region.args.height + -8,
            'z-index': 5,
            opacity: Math.random,
            '--particleScale': this.args.particleScale,
            '--time': 320
          });
          this.splashes.add(splash);
          viewport.particles.add(splash);
          viewport.onFrameOut(20, () => {
            splash.node && viewport.particles.remove(splash);
            this.splashes.delete(splash);
          });
        }
      }
    }
  }
  die() {
    if (this.args.dead) {
      return;
    }
    this.viewport.args.inventory.splice(0);
    this.args.currentSheild = null;
    this.totalCombo(true);
    this.args.groundAngle = 0;
    this.args.ySpeed = 0;
    this.args.xSpeed = 0;
    this.args.jumping = false;
    this.args.falling = true;
    this.args.ignore = -1;
    this.args.mercy = 0;
    this.args.float = 0;
    this.args.rings = 0;
    this.args.standingLayer = null;
    this.args.standingOn = null;
    this.lastLayer = null;
    this.args.dead = true;
    this.noClip = true;
    this.args.ySpeed = -12;
    this.focused = this.cofocused = null;
    if (this.y > this.viewport.meta.deathLine) {
      this.args.ySpeed = -14;
    }
    this.args.xSpeed = 0;

    // this.onNextFrame(()=>{
    // 	this.args.ySpeed = -8;
    // 	this.args.xSpeed = 0;
    // });

    this.viewport.onFrameOut(120, () => {
      if (!this.args.dead) {
        return;
      }
      this.respawn();
    });
  }
  respawn() {
    if (!this.viewport) {
      return;
    }
    this.screenLock = null;
    this.args.xSpeed = 0;
    this.args.ySpeed = 0;
    this.args.gSpeed = 0;
    this.args.respawning = true;
    this.args.display = 'none';
    this.args.x = -this.viewport.args.x;
    this.args.y = -this.viewport.args.y;
    this.args.standingLayer = null;
    this.args.standingOn = null;
    this.lastLayer = null;
  }
  sleep() {}
  wakeUp() {}
  urlWrap(url) {
    return `url(${url})`;
  }
  get facePoint() {
    return this.rotatePoint(-5 * this.args.direction, -14 + this.args.height);
  }
  registerDebug(name) {
    window[name] = this;
  }
  loseRings() {
    let count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    let age = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    const Ring = this.viewport.objectPalette['ring'];
    this.spawnRings = this.spawnRings || 0;
    const maxSpawn = count || Math.min(this.args.rings, 16);
    let current = 0;
    const toSpawn = maxSpawn - this.spawnRings;
    const circles = Math.floor(maxSpawn / 8);
    this.viewport.onFrameOut(4, () => {
      while (this.spawnRings < maxSpawn) {
        const ring = new Ring();
        const circle = Math.ceil(current / 8);
        const angle = current % 8 * (Math.PI / 4) + Math.PI / 4;
        const radius = 1 * circle;
        const cos = Math.cos(angle);
        const sin = Math.sin(angle);
        ring.args.x = this.x - cos * (circle * 8);
        ring.args.y = this.y - sin * (circle * 8) - this.args.height / 4;
        ring.args.xSpeed = 0;
        ring.args.ySpeed = 0;
        ring.noClip = true;
        ring.args.static = false;
        ring.args.float = 18;
        ring.args.ignore = 30;
        ring.args.width = 16;
        ring.args.height = 16;
        ring.args.spinSpeed = 0.25;
        ring.dropped = true;
        this.viewport.onFrameOut((1 + circle) * 2, () => {
          this.viewport.spawn.add({
            object: ring
          });
        });
        this.spawnRings++;
        current++;

        // ring.args.xSpeed = this.args.xSpeed || this.args.gSpeed;
        // ring.args.ySpeed = this.args.ySpeed;

        this.viewport.onFrameOut(circle * 2 + 6, () => {
          ring.args.xSpeed += -cos * 3;
          ring.args.ySpeed += -sin * 3;
          ring.args.ySpeed += -(circle + 1) * 0.75;
        });
        if (current % 3 === 2) {
          ring.args.decoration = true;
          ring.noClip = true;
          this.viewport.onFrameOut(100, () => {
            this.viewport.actors.remove(ring);
            if (this.spawnRings > 0) {
              this.spawnRings--;
            }
          });
        } else {
          ring.args.decoration = false;
          ring.noClip = false;
          this.viewport.onFrameOut(age || 360 - current % 5 * 35, () => {
            this.viewport.actors.remove(ring);
            if (this.spawnRings > 0) {
              this.spawnRings--;
            }
          });
        }
      }
    });
  }
  collect(pickup) {
    if (pickup.dropped) {
      if (this.spawnRings) {
        this.spawnRings--;
      }
      pickup.dropped = false;
    }
  }
  angleTo(actor) {
    return Math.atan2(this.y - actor.y, this.x - actor.x);
  }
  distanceTo(actor) {
    return Math.hypot(this.y - actor.y, this.x - actor.x);
    // return Math.sqrt((this.y - actor.y)**2 + (this.x - actor.x)**2);
  }

  canSee(actor) {
    const cast = this.castRayQuick(this.distanceTo(actor), actor.angleTo({
      x: this.args.x,
      y: this.args.y - this.args.height
    }), [0, -this.args.height], false);
    if (cast === false) {
      return true;
    }
  }
  setTile() {
    const tileMap = this.viewport.tileMap;
    tileMap.ready.then(event => {
      const tile = tileMap.getTile(this.args.tileId - 1);
      if (!tile) {
        return;
      }
      this.args.spriteX = tile[0];
      this.args.spriteY = tile[1];
      this.args.spriteSheet = tile[2] || this.args.spriteSheet;
    });
  }
  halt(frameOut) {
    const hSpeed = this.args.hSpeed = this.args.gSpeed;
    this.args.gSpeed = 0;
    this.viewport.onFrameOut(frameOut, () => {
      this.args.gSpeed = hSpeed;
      this.args.hSpeed = 0;
    });
  }
  setAutoAttr(property, attribute) {
    const attrMap = this.autoAttr.get(this.box);
    attrMap[attribute] = property;
  }
  invoke(methodName) {
    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }
    this.behaviors.forEach(b => {
      if (typeof b[methodName] !== 'function') {
        return;
      }
      b[methodName](this, ...args);
    });
  }
  bMap(methodName) {
    const result = new Map();
    for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
      args[_key3 - 1] = arguments[_key3];
    }
    for (const b of this.behaviors) {
      if (typeof b[methodName] !== 'function') {
        continue;
      }
      result.set(b.constructor, b[methodName](this, ...args));
    }
    return result;
  }
  getBoundingLines() {
    if (this[BOUNDS]) {
      return this[BOUNDS];
    }
    let bounds, left, right, top, bottom;
    switch (this.args.mode) {
      case MODE_FLOOR:
        left = this.args.x - (this.isRegion ? 0 : this.args.width / 2);
        right = this.args.x + (this.isRegion ? this.args.width : this.args.width / 2);
        top = this.args.y - this.args.height;
        bottom = this.args.y;
        bounds = [[right, top, right, bottom], [left, top, left, bottom], [right, top, left, top], [right, bottom, left, bottom]];
        break;
      case MODE_CEILING:
        left = this.args.x - this.args.width / 2;
        right = this.args.x + this.args.width / 2;
        top = this.args.y;
        bottom = this.args.y + this.args.height;
        bounds = [[right, top, right, bottom], [left, top, left, bottom], [right, top, left, top], [right, bottom, left, bottom]];
        break;
      case MODE_LEFT:
        left = this.args.x;
        right = this.args.x + this.args.height;
        top = this.args.y - this.args.width / 2;
        bottom = this.args.y + this.args.width / 2;
        bounds = [[right, top, right, bottom], [left, top, left, bottom], [right, top, left, top], [right, bottom, left, bottom]];
        break;
      case MODE_RIGHT:
        left = this.args.x - this.args.height;
        right = this.args.x;
        top = this.args.y - this.args.width / 2;
        bottom = this.args.y + this.args.width / 2;
        bounds = [[right, top, right, bottom], [left, top, left, bottom], [right, top, left, top], [right, bottom, left, bottom]];
        break;
    }
    Object.freeze(bounds);
    return this[BOUNDS] = bounds;
  }
  filterSolids(a) {
    return a.args !== this.args && a.callCollideHandler(this) && a.solid;
  }
  onSpawned(viewport) {
    for (const behavior of this.behaviors) {
      behavior.onSpawned && behavior.onSpawned(this, viewport);
    }
  }
  onDespawned(viewport) {
    for (const behavior of this.behaviors) {
      behavior.onDespawned && behavior.onDespawned(this, viewport);
    }
  }
  getCollisionMap() {
    if (!this.collisionMap) {
      this.collisionMap = this.viewport.tileMap.getCollisionMap();
      for (const layer of this.collisionMap.keys()) {
        if (layer.name.substr(0, 3) === 'Art') {
          this.collisionMap.delete(layer);
        } else if (layer.name.substr(0, 10) === 'Moving Art') {
          this.collisionMap.delete(layer);
        }
      }
    }
    if (!this.viewport) {
      return this.collisionMap;
    }
    if (this.collisionMapFrame === this.viewport.args.frameId) {
      return this.collisionMap;
    }
    this.collisionMapFrame = this.viewport.args.frameId;
    for (const layer of this.collisionMap.keys()) {
      if (layer.name === 'Collision 0') {
        this.collisionMap.set(layer, true);
      } else if (layer.name === 'Collision ' + this.args.layer) {
        this.collisionMap.set(layer, true);
      } else if (layer.name.substr(0, 4) === 'Door') {
        if (this.doorMap.has(layer.index)) {
          this.collisionMap.set(layer, this.doorMap.get(layer.index));
        }
      } else if (layer.name.substr(0, 8) === 'Platform' || layer.name.substr(0, 8) === 'Grinding') {
        if (this.args.ySpeed < 0 || this.args.mode === 3 && this.args.gSpeed > 0 || this.args.mode === 1 && this.args.gSpeed < 0) {
          this.collisionMap.set(layer, false);
        } else {
          this.collisionMap.set(layer, true);
        }
        if (this.viewport.tileMap.getSolid(this.args.x + 16, this.args.y + -16, layer.index) && this.viewport.tileMap.getSolid(this.args.x - 16, this.args.y + -16, layer.index)) {
          this.collisionMap.set(layer, false);
        } else if (layer.layer && layer.layer.meta.vertical) {
          if (!this.args.xSpeed || Math.sign(layer.layer.meta.vertical) === Math.sign(this.args.xSpeed)) {
            this.collisionMap.set(layer, true);
          }
        }
        if (this.args.climbing && this.viewport.tileMap.getSolid(this.args.x, this.args.y, layer.index) || this.args.flying && layer.layer.meta.vertical !== Math.sign(this.args.xSpeed) && !this.viewport.tileMap.getSolid(this.args.x + this.args.xSpeed, this.args.y + -8, layer.index) && this.viewport.tileMap.getSolid(this.args.x, this.args.y, layer.index)) {
          this.collisionMap.set(layer, false);
        }
        if (!layer.layer.meta.vertical && !this.args.mode && this.viewport.tileMap.getSolid(this.args.x, this.args.y + -16, layer.index)) {
          this.collisionMap.set(layer, false);
        }
      } else if (layer.name.substr(0, 6) === 'Moving' && layer.name.substr(0, 10) !== 'Moving Art') {
        this.collisionMap.set(layer, true);
      } else {
        this.collisionMap.set(layer, false);
      }
    }
    return this.collisionMap;
  }
  command_0() {}
  command_1() {}
}
exports.PointActor = PointActor;
_defineProperty(PointActor, "lastClick", 0);
});

;require.register("actor/PowerupGlow.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PowerupGlow = void 0;
var _PointActor = require("./PointActor");
var _Tag = require("curvature/base/Tag");
class PowerupGlow extends _PointActor.PointActor {
  constructor() {
    super(...arguments);
    this.args.type = 'actor-item actor-powerup-glow';
    this.args.width = 64;
    this.args.height = 64;
  }
  onRendered(event) {
    super.onRendered(event);
    this.autoAttr.get(this.box)['data-closed'] = 'closed';
    this.icon = new _Tag.Tag('<div class = "powerup-icon">');
    this.halo = new _Tag.Tag('<div class = "powerup-halo">');
    this.tags.sprite.appendChild(this.icon.node);
    this.box.appendChild(this.halo.node);
  }
  collideA(other) {
    super.collideA(other);
    if (!other.controllable) {
      return;
    }
    this.onTimeout(125, () => this.args.closed = 'closed');
    this.onTimeout(4500, () => this.args.closed = '');
  }
  get canStick() {
    return false;
  }
  get solid() {
    return false;
  }
  get isEffect() {
    return true;
  }
}
exports.PowerupGlow = PowerupGlow;
});

;require.register("actor/Projectile.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Projectile = void 0;
var _PointActor = require("./PointActor");
var _Platformer = require("../behavior/Platformer");
var _Marker = require("../actor/Marker");
var _Explosion = require("../actor/Explosion");
var _Tag = require("curvature/base/Tag");
var _Region = require("../region/Region");
var _Spring = require("./Spring");
var _BreakableBlock = require("./BreakableBlock");
var _Block = require("./Block");
// import { StarPost } from './StarPost';

class Projectile extends _PointActor.PointActor {
  constructor() {
    var _this$args$damageType;
    let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let parent = arguments.length > 1 ? arguments[1] : undefined;
    const gravity = args.gravity;
    super(args, parent);
    this.args.type = 'actor-item actor-projectile';
    if (this.args.subType) {
      this.args.type = this.args.type + ' ' + this.args.subType;
    }
    this.args.damageType = (_this$args$damageType = this.args.damageType) !== null && _this$args$damageType !== void 0 ? _this$args$damageType : 'normal';
    this.behaviors.add(new _Platformer.Platformer());
    this.args.width = 8;
    this.args.height = 8;
    this.args.strength = this.args.strength || 1;
    this.args.gravity = gravity !== null && gravity !== void 0 ? gravity : 0.15;
    this.removeTimer = null;
    this.noClip = true;
    this.deflected = false;
  }
  update() {
    if (this.removed || !this.viewport) {
      return;
    }
    if (!this.args.falling) {
      this.args.gSpeed = 0;
      this.args.xSpeed = 0;
      this.args.ySpeed = 0;
    }
    super.update();
    if (!this.args.xSpeed && !this.args.ySpeed && this.age > 1) {
      this.explode();
    }
    if (this.viewport && !this.removeTimer) {
      this.removeTimer = this.viewport.onFrameOut(200, () => this.explode());
    }
  }
  collideA(other) {
    if (other instanceof Projectile) {
      return;
    }
    if (other === this.args.owner || other instanceof _Region.Region || other instanceof _Spring.Spring) {
      return false;
    }
    if (!(other instanceof _Marker.Marker) && !this.args.owner.controllable && !other.controllable) {
      return;
    }
    if (this.args.strength <= 1 && other instanceof _BreakableBlock.BreakableBlock) {
      return false;
    }
    if (other.args.gone || this.deflected) {
      return false;
    }
    if (other instanceof _Marker.Marker || other.args.currentSheild && other.args.currentSheild.immune(other, this, 'projectile')) {
      this.args.xSpeed *= -1;
      this.args.ySpeed *= -1;
      this.deflected = true;
      return;
    }
    if (!other.solid && !other.controllable) {
      return false;
    }
    this.args.xSpeed = 0;
    this.args.ySpeed = 0;
    this.args.float = -1;
    if (this.args.owner && !this.args.owner.args.gone) {
      (other.controllable || other instanceof _BreakableBlock.BreakableBlock) && other.damage(this, this.args.damageType);
    }

    // this.args.x += Math.cos(this.args.angle) * (other.args.width / 2) * Math.sign(this.args.xSpeed);
    // this.args.y += Math.sin(this.args.angle) * (other.args.width / 2) * Math.sign(this.args.xSpeed);

    this.explode();
    return false;
  }
  explode() {
    const viewport = this.viewport;
    if (!viewport) {
      return;
    }
    const particle = new _Tag.Tag('<div class = "particle-explosion">');
    particle.style({
      '--x': this.x,
      '--y': this.y
    });
    viewport.particles.add(particle);
    this.viewport.onFrameOut(20, () => viewport.particles.remove(particle));
    this.viewport.actors.remove(this);
    this.remove();
  }
  get canStick() {
    return false;
  }
  get solid() {
    return false;
  }
}
exports.Projectile = Projectile;
});

;require.register("actor/Propeller.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Propeller = void 0;
var _PointActor = require("./PointActor");
class Propeller extends _PointActor.PointActor {
  constructor() {
    super(...arguments);
    this.args.width = 128;
    this.args.height = 16;
    this.args.type = 'actor-item actor-propeller';
    this.args.float = -1;
  }
  get solid() {
    return false;
  }
  update() {
    const hover = 160;
    const actors = this.viewport.actorsAtPoint(this.args.x, this.args.y, this.args.width, hover);
    for (const actor of actors) {
      if (actor.args.float || actor.args.ySpeed < -8 || !actor.args.falling) {
        continue;
      }
      const yOther = this.args.y - actor.args.y;
      const magnitude = ((hover + -yOther) / hover) ** 4;
      actor.args.ySpeed -= magnitude * Math.max(1.5, actor.args.ySpeed);
      actor.args.animation = 'hovering';
      actor.args.jumping = false;
      actor.args.groundAngle = 0;
    }
  }
}
exports.Propeller = Propeller;
});

;require.register("actor/PropellerPlatform.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PropellerPlatform = void 0;
var _Block = require("./Block");
var _Sfx = require("../audio/Sfx");
class PropellerPlatform extends _Block.Block {
  constructor() {
    var _this$args$maxClimb;
    super(...arguments);
    this.args.maxClimb = (_this$args$maxClimb = this.args.maxClimb) !== null && _this$args$maxClimb !== void 0 ? _this$args$maxClimb : 256;
    this.args.width = 64;
    this.args.height = 53;
    this.args.platform = 1;
    this.args.type = 'actor-item actor-propeller-platform';
    this.args.static = 0;
    this.args.gravity = 0.20;
    this.args.spinning = 0;
    this.args.bouncing = 0;
  }
  onRendered() {
    super.onRendered();
    this.autoAttr.get(this.box)['data-spinning'] = 'spinning';
    this.autoAttr.get(this.box)['data-bouncing'] = 'bouncing';
  }
  update() {
    this.args.cameraBias = -0.2;
    if (this.args.spinning > 0) {
      this.args.spinning--;
    } else {
      this.args.spinning = 0;
    }
    if (this.args.bouncing > 0) {
      this.args.bouncing--;
    } else {
      this.args.bouncing = 0;
    }
    const maxClimb = this.originalY + -this.args.maxClimb;
    if (this.args.y > this.originalY) {
      this.args.y = this.originalY;
      this.args.ySpeed = 0;
      this.args.float = -1;
    }
    if (this.args.y < maxClimb) {
      this.args.float = 30;
      this.args.y = maxClimb;
      this.args.ySpeed = Math.max(0, this.args.ySpeed);
    }
    super.update();
  }
  collideA(other, type) {
    if (other.args.static) {
      return;
    }
    if (other.args.falling && other.args.y > this.args.y + -this.args.height && other.args.y < this.args.y + -(this.args.height * 0.75)) {
      other.args.y = this.args.y + -this.args.height + this.args.ySpeed + 3;
      return super.collideA(other, type);
    }
    if (!other.args.falling || other.args.ySpeed < 0) {
      return super.collideA(other, type);
    }

    // if(!other.controllable)
    // {
    // 	return super.collideA(other, type);
    // }

    this.args.ySpeed += Math.min(-4, -Math.abs(other.args.ySpeed) * 0.5);
    this.args.float = 10;
    this.args.spinning = 30;
    this.args.bouncing = 10;
    other.args.xSpeed *= 0.5;
    other.doubleSpin = false;
    if (other.dashed) {
      other.dashed = false;
      other.args.xSpeed = 0;
      other.args.ySpeed = -other.args.airSpeed;
      other.args.ySpeed *= 1.25;
      this.args.ySpeed *= 1.75;
    } else {
      if (other.args.ySpeed > 0) {
        other.args.ySpeed = Math.min(-4, Math.max(-6, -Math.abs(other.args.ySpeed)));
        other.args.ySpeed += this.args.ySpeed;
      }
      if (other.args.ySpeed > this.args.ySpeed) {
        other.args.ySpeed = this.args.ySpeed + -6;
      }
    }
    _Sfx.Sfx.play('PROP_PLAT');
    if (this.viewport.settings.rumble && other.controller && other.controller.rumble) {
      other.controller.rumble({
        duration: 100,
        strongMagnitude: 1.0,
        weakMagnitude: 0.0
      });
    }
    this.args.y--;
    this.args.falling = true;
    if (other.args.animation === 'airdash') {
      other.args.animation = 'flip';
    }
    return super.collideA(other, type);
  }
}
exports.PropellerPlatform = PropellerPlatform;
});

;require.register("actor/Pulley.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Pulley = void 0;
var _PointActor = require("./PointActor");
var _Ring = require("./Ring");
class Pulley extends _PointActor.PointActor {
  constructor() {
    super(...arguments);
    this.args.width = 64;
    this.args.height = 64;
    this.args.type = 'actor-item actor-pulley';
    this.args.convey = 0;
    this.args.conveyed = 0;
    this.args.float = -1;
    this.noClip = true;
  }
  update() {
    if (this.match) {
      this.args.convey = -this.match.args.convey;
    } else {
      this.match = this.viewport.actorsById[this.args.match];
    }
    this.box && this.box.style({
      '--convey': Math.abs(this.args.convey)
    });
    this.box && this.box.style({
      '--conveyDir': Math.sign(this.args.convey)
    });
    this.args.conveyed += this.match.args.convey;
    this.box && this.box.style({
      '--conveyed': this.args.conveyed
    });

    // if(Math.abs(this.args.convey) > 10
    // 	&& Math.sign(this.args.convey) === this.args.reward
    // 	&& this.viewport.args.frameId % 60 === 0
    // ){
    // 	const ring = new Ring({
    // 		static:   false
    // 		, float:  10
    // 		, ySpeed: 1
    // 		, x:this.x
    // 		, y:this.y - 192,

    // 	});

    // 	ring.scattered = true;
    // 	ring.noClip = false;

    // 	this.viewport.spawn.add({object: ring});

    // 	this.viewport.onFrameOut(100, () => {
    // 		this.viewport.actors.remove(ring);
    // 	});
    // }

    // super.update();
  }

  get isEffect() {
    return true;
  }
}
exports.Pulley = Pulley;
});

;require.register("actor/PulleySmall.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PulleySmall = void 0;
var _Pulley = require("./Pulley");
class PulleySmall extends _Pulley.Pulley {
  constructor() {
    super(...arguments);
    this.args.width = 32;
    this.args.height = 32;
    this.args.type = 'actor-item actor-pulley-small';
    this.args.convey = 0;
    this.args.float = -1;
    this.noClip = true;
  }
}
exports.PulleySmall = PulleySmall;
});

;require.register("actor/Pumpkin.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Pumpkin = void 0;
var _PointActor = require("./PointActor");
class Pumpkin extends _PointActor.PointActor {
  constructor() {
    var _this$args$face;
    super(...arguments);
    this.args.face = (_this$args$face = this.args.face) !== null && _this$args$face !== void 0 ? _this$args$face : false;
    this.args.width = 17;
    this.args.height = 15;
    this.args.type = 'actor-item actor-pumpkin';
    this.bindTo('carriedBy', carrier => {
      if (this.cX) {
        this.cX();
        this.cX = null;
      }
      if (this.cY) {
        this.cY();
        this.cY = null;
      }
      if (carrier) {
        this.cX = carrier.args.bindTo('x', v => this.args.x = v + carrier.args.direction * 8);
        this.cY = carrier.args.bindTo('y', v => this.args.y = v + -16);
        carrier.carrying.add(this);
        this.args.float = -1;
      } else if (this.carriedBy) {
        const carrier = this.carriedBy;
        this.carriedBy = null;
        this.args.xSpeed = carrier.args.xSpeed;
        this.args.ySpeed = carrier.args.ySpeed;
        this.args.xSpeed += Math.sign(carrier.args.gSpeed || carrier.args.xSpeed) * 4;
        this.args.ySpeed -= 4;
        carrier.carrying.delete(this);
        this.args.falling = true;
        this.args.float = 0;
      }
    });
  }
  onRendered() {
    super.onRendered();
    this.autoAttr.get(this.box)['data-face'] = 'face';
  }
  lift(actor) {
    if (this.carriedBy === actor) {
      this.carriedBy = null;
      return;
    }
    this.carriedBy = actor;
  }
  get solid() {
    return false;
  }
}
exports.Pumpkin = Pumpkin;
});

;require.register("actor/QuestionBlock.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.QuestionBlock = void 0;
var _PointActor = require("./PointActor");
var _RingMonitor = require("./monitor/RingMonitor");
var _SheildWaterMonitor = require("./monitor/SheildWaterMonitor");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class QuestionBlock extends _PointActor.PointActor {
  static fromDef(objDef) {
    const obj = super.fromDef(objDef);
    obj.args.x = obj.originalX = objDef.x + Math.floor(objDef.width / 2);
    obj.args.y = obj.originalY = objDef.y;
    return obj;
  }
  constructor() {
    super(...arguments);
    _defineProperty(this, "maxBounce", 4);
    _defineProperty(this, "float", -1);
    _defineProperty(this, "template", `<div
		class = "point-actor [[type]] [[collType]]"
		style = "
			display:[[display]];
			--angle:[[angle]];
			--airAngle:[[airAngle]];
			--display-angle:[[_angle]];
			--height:[[height]];
			--width:[[width]];
			--x:[[x]];
			--y:[[y]];
		"
		data-colliding = "[[colliding]]"
		data-falling   = "[[falling]]"
		data-facing    = "[[facing]]"
		data-angle     = "[[angle|rad2deg]]"
		data-mode      = "[[mode]]"
		data-empty     = "[[empty]]"
		cv-ref = "box"
	><div cv-ref = "sprite" class = "sprite"></div></div>`);
    this.args.type = 'actor-question-block actor-item';
    this.args.width = 32;
    this.args.height = 32;
    this.initY = null;
    this.empty = false;
  }
  collideA(other, type) {
    super.collideA(other);
    if (this.initY === null) {
      this.initY = this.y;
    }
    if (type === 2) {
      const impulse = Math.abs(other.args.ySpeed);
      other.args.falling = true;
      if (other.args.ySpeed > 0) {
        other.args.ySpeed += this.args.ySpeed;
      } else {
        this.args.y -= impulse;
        other.args.y += impulse;
      }
      if (this.args.ySpeed > 0 && this.args.ySpeed > other.args.ySpeed) {
        other.args.ySpeed = Math.abs(other.args.ySpeed);
        other.args.y += this.args.ySpeed;
      }
      if (this.args.ySpeed < 0) {
        this.args.ySpeed = -Math.abs(this.args.ySpeed);
      }
      if (this.args.ySpeed) {
        return true;
      }
      const ySpeedMax = this.maxBounce;
      let speed = type === 2 ? -Math.abs(other.args.ySpeed) : other.args.ySpeed;
      if (Math.abs(speed) > ySpeedMax) {
        speed = ySpeedMax * Math.sign(speed);
      }
      this.args.ySpeed = speed;
      other.args.ySpeed = -other.args.ySpeed;
    }
    if (type === 2 && !this.args.empty) {
      if (!this.args.empty) {
        const monitor = new _SheildWaterMonitor.SheildWaterMonitor({
          x: this.x,
          y: this.y - 96
        });
        this.viewport.spawn.add({
          object: monitor
        });
        monitor.onRemove(() => this.args.empty = false);
        this.args.empty = true;
      }
    }
    return true;
  }
  update() {
    if (this.initY !== null) {
      if (this.initY > this.y) {
        this.args.ySpeed += 0.75;
      } else if (this.initY < this.y) {
        this.args.ySpeed -= 0.75;
      }
      if (Math.abs(this.args.y - this.initY) < 1 && Math.abs(this.args.ySpeed) < 1) {
        this.args.ySpeed = 0;
        this.args.y = this.initY;
      }
    }
    this.args.ySpeed *= 0.9;
    this.args.ySpeed = Math.floor(this.args.ySpeed * 100) / 100;
    this.args.y = Math.round(this.args.y);
    const ySpeedMax = this.maxBounce;
    if (Math.abs(this.args.ySpeed) > ySpeedMax) {
      this.args.ySpeed = ySpeedMax * Math.sign(this.args.ySpeed);
    }
    super.update();
  }
  get canStick() {
    return false;
  }
  get solid() {
    return true;
  }
}
exports.QuestionBlock = QuestionBlock;
});

;require.register("actor/RailCar.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RailCar = void 0;
var _Vehicle = require("./Vehicle");
var _Tag = require("curvature/base/Tag");
class RailCar extends _Vehicle.Vehicle {
  constructor() {
    super(...arguments);
    this.args.type = 'actor-item actor-rail-car';
    this.args.width = 32;
    this.args.height = 48;
    this.removeTimer = null;
    this.args.cartSpeed = this.args.cartSpeed || 15;
    this.args.gSpeedMax = 20;
    this.args.decel = 0.00;
    this.args.accel = 0.75;
    this.args.gravity = 1;
    // this.args.ignore    = -1;

    this.args.seatHeight = 44;
    this.args.skidTraction = 0.05;
    this.args.jumpForce = 12;
    this.dustCount = 0;
    this.args.particleScale = 2;
    this.args.started = false;
  }
  onRendered(event) {
    super.onRendered(event);
    this.box = this.findTag('div');
    this.sprite = this.findTag('div.sprite');
    this.frontWheel = new _Tag.Tag('<div class = "rail-car-wheel rail-car-wheel-front">');
    this.backWheel = new _Tag.Tag('<div class = "rail-car-wheel rail-car-wheel-back">');
    this.frontFrag = new _Tag.Tag('<div class = "rail-car-frag rail-car-frag-front">');
    this.backFrag = new _Tag.Tag('<div class = "rail-car-frag rail-car-frag-back">');
    this.sprite.appendChild(this.frontWheel.node);
    this.sprite.appendChild(this.backWheel.node);
    this.sprite.appendChild(this.frontFrag.node);
    this.sprite.appendChild(this.backFrag.node);
  }
  update() {
    this.originalSpeed = this.args.gSpeed || this.args.xSpeed;
    const lastX = this.args.x;
    const lastY = this.args.y;
    super.update();
    if (!this.sprite) {
      return;
    }
    const nowX = this.x;
    if (this.args.gSpeed !== 0 || this.args.hSpeed !== 0 || this.args.xSpeed !== 0) {
      this.sprite.classList.add('moving');
      this.args.started = true;
    }
    if (nowX === lastX && !this.args.broken && !this.args.hSpeed) {
      this.sprite.classList.remove('moving');
      if (this.args.started) {
        const viewport = this.viewport;
        if (this.args.falling && !this.args.xSpeed && !this.args.ySpeed) {
          this.breakApart();
        } else if (!this.args.falling && !this.args.hSpeed && this.args.x === lastX && this.args.y === lastY) {
          this.breakApart();
        }
      }
    }
    if (this.occupant && !this.args.falling) {
      const speed = this.args.hSpeed || this.args.gSpeed;
      if (Math.abs(speed) < Math.abs(this.args.cartSpeed) || Math.sign(speed) !== Math.sign(this.args.cartSpeed)) {
        if (this.args.hSpeed) {
          this.args.hSpeed += Math.sign(this.args.cartSpeed) * 0.125;
        } else {
          this.args.gSpeed += Math.sign(this.args.cartSpeed) * 0.125;
        }
        if (Math.abs(this.args.gSpeed) < 1) {
          this.args.gSpeed = Math.sign(this.args.gSpeed);
        }
      }
      this.args.direction = Math.sign(this.args.hSpeed || this.args.gSpeed);
    } else {
      if (this.args.hSpeed) {
        this.args.hSpeed = this.args.xSpeed;
      } else if (this.args.xSpeed) {
        this.args.gSpeed = this.args.xSpeed;
      }
    }
  }
  breakApart() {
    if (!this.args.broken) {
      const viewport = this.viewport;

      // viewport.onFrameOut(140, () => viewport && viewport.actors.remove(this));
      // viewport.onFrameOut(120, () => this.sprite.classList.add('broken'));

      if (this.occupant) {
        this.occupant.startle();
      }
      this.sprite.classList.add('breaking');
      this.args.broken = true;
      this.args.groundAngle = 0;
      this.args.mode = 0;
      this.args.dead = true;
    }
  }
  sleep() {
    this.args.x = this.def.get('x');
    this.args.y = this.def.get('y');
    this.args.dead = false;
    this.args.groundAngle = 0;
    this.args.gSpeed = 0;
    this.args.xSpeed = 0;
    this.args.ySpeed = 0;
    this.sprite.classList.remove('breaking');
    this.sprite.classList.remove('broken');
    this.args.broken = false;
    this.args.started = false;
    super.sleep();
  }
  processInputDirect() {
    // Don't process input at all.
  }

  // jump()
  // {
  // 	// Don't process input at all.
  // }

  get solid() {
    return !this.args.broken && !this.occupant;
  }
}
exports.RailCar = RailCar;
});

;require.register("actor/Red.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Red = void 0;
var _PointActor = require("./PointActor");
class Red extends _PointActor.PointActor {
  constructor() {
    super(...arguments);
    this.behaviors.add(new SkidDust());
    this.args.type = 'actor-item actor-red';
    this.args.animation = 'standing';
    this.args.accel = 0.1;
    this.args.decel = 0.5;
    this.args.width = 16;
    this.args.height = 16;
    this.args.float = -1;
  }
}
exports.Red = Red;
});

;require.register("actor/RedBomb.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RedBomb = void 0;
var _PointActor = require("./PointActor");
var _Sfx = require("../audio/Sfx");
var _Tag = require("curvature/base/Tag");
class RedBomb extends _PointActor.PointActor {
  constructor() {
    super(...arguments);
    this.args.width = 8;
    this.args.height = 8;
    this.args.type = 'actor-item actor-red-bomb';
    this.args.decel = 0;
    this.noClip = true;
    this.explosions = new Set();
  }
  update() {
    if (!this.args.falling && !this.explosions.size) {
      this.explode();
    }
    super.update();
    for (const explosion of this.explosions) {
      explosion.style({
        '--x': this.args.x,
        '--y': this.args.y + -16
      });
    }
  }
  collideA(other) {
    if (!other.controllable) {
      return;
    }
    other.damage(this);
    this.explode();
    this.args.float = -1;
    this.args.xSpeed = 0;
    this.args.ySpeed = 0;
  }
  explode() {
    if (this.exploded) {
      return;
    }
    this.exploded = true;
    this.viewport.actors.remove(this);
    _Sfx.Sfx.play('OBJECT_DESTROYED');
  }
}
exports.RedBomb = RedBomb;
});

;require.register("actor/RedEyeJet.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RedEyeJet = void 0;
var _Tag = require("curvature/base/Tag");
var _Bgm = require("../audio/Bgm");
var _Sfx = require("../audio/Sfx");
var _PointActor = require("./PointActor");
var _Projectile = require("./Projectile");
var _MiniMace = require("./MiniMace");
var _MegaMace = require("./MegaMace");
var _Analytic = require("../lib/Analytic");
class RedEyeJet extends _PointActor.PointActor {
  constructor(args, parent) {
    super(args, parent);
    this.args.gravity = 0.4;
    this.args.width = 96;
    this.args.height = 32;
    this.args.type = 'actor-item actor-red-eye-jet';
    this.args.float = -1;
    this.args.phase = 'idle';
    this.args.hitPoints = this.args.hitPoints || 8;
    this.args.maxSpeed = 9;
    this.args.bindTo('phase', v => this.args.phaseFrameId = 0);
  }
  wakeUp() {
    for (const [type, others] of this.hanging) {
      for (const other of others) {
        other.setPos();
      }
    }
  }
  collideA(other, type) {
    let name;
    if (this.hanging.has(other)) {
      return false;
    }
    if (this.hanging.has(_MiniMace.MiniMace)) {
      name = 'MINI-MACE';
    } else if (this.hanging.has(_MegaMace.MegaMace)) {
      name = 'MEGA-MACE';
    }
    if (!other.controllable && !(other instanceof _Projectile.Projectile)) {
      return;
    }
    if (other instanceof _Projectile.Projectile) {}
    if (this.args.hitPoints > 0) {
      if (!(other.args.jumping || other.args.rolling || other.dashed) && !(other instanceof _Projectile.Projectile)) {
        // other.args.xSpeed = -other.args.xSpeed * 1.5;

        other.damage();
        return true;
      }
    }
    if (!this.args.falling && this.args.phase !== 'exploding') {
      if (!(other.args.jumping || other.args.rolling || other.dashed)) {
        return true;
      }
      this.box.setAttribute('data-phase', 'exploding');
      this.args.phase = 'exploding';
      this.viewport.clearCheckpoints();
      const viewport = this.viewport;
      viewport.onFrameOut(80, () => {
        this.box.setAttribute('data-phase', 'exploded');
        this.args.falling = true;
        this.args.ySpeed = -12;
        this.noClip = true;
        _Sfx.Sfx.play('OBJECT_DESTROYED');
      });

      // viewport.onFrameOut(100, () => {
      // 	viewport.clearAct(`${other.args.name} BEAT THE ${name}`);
      // });

      viewport.onFrameOut(100, () => {
        this.viewport.args.cutScene = true;
      });
      viewport.onFrameOut(150, () => {
        this.viewport.controlActor.controller.replay({
          axes: [1, 0, 0, 1]
        });
        this.viewport.controlActor.readInput();
      });
      viewport.onFrameOut(210, () => {
        this.viewport.controlActor.controller.replay({
          buttons: [1]
        });
        this.viewport.controlActor.readInput();
      });
      viewport.onFrameOut(211, () => {
        this.viewport.controlActor.dropDashCharge = 30;
      });
      viewport.onFrameOut(285, () => {
        this.viewport.controlActor.controller.replay({
          buttons: [0, 0, 0, 0, 0, 0]
        });
        this.viewport.controlActor.readInput();
        this.args.phase = 'done';
      });
      viewport.onFrameOut(500, () => {
        this.args.xSpeed = 0;
        this.args.ySpeed = 0;
        this.args.y = -1024;
      });
    }
    this.ignores.set(other, 15);
    if (type === 2) {
      _Sfx.Sfx.play('BOSS_DUDHIT');
      other.args.ySpeed = Math.max(7, Math.abs(other.args.ySpeed));
    }
    const xBounce = Math.max(Math.abs(other.args.xSpeed), Math.abs(this.args.xSpeed));
    if (this.args.hitPoints > 1 && this.args.falling) {
      this.args.xSpeed = other.args.xSpeed;
    } else {
      this.args.xSpeed = 0;
    }
    let damaged = false;
    if (type === 1) {
      this.handleDamage(other);
      damaged = true;

      // other.args.x = this.x - (this.args.width / 2) * Math.sign(other.x - this.x);

      if (this.args.hitPoints > 0) {
        other.args.xSpeed = -xBounce * 1.25;
        other.args.xSpeed = Math.min(-7, -this.args.xSpeed);
        this.args.hitPoints--;
      } else {
        other.args.xSpeed = -2;
        other.args.ignore = -2;
      }
    }
    if (type === 3) {
      this.handleDamage(other);
      damaged = true;

      // other.args.x = this.x + (this.args.width / 2) * Math.sign(other.x - this.x);

      if (this.args.hitPoints > 0) {
        other.args.xSpeed = xBounce * 1.25;
        other.args.xSpeed = Math.max(7, -this.args.xSpeed);
        this.args.hitPoints--;
      } else {
        other.args.xSpeed = 2;
        other.args.ignore = -2;
      }
    }
    if (damaged && other && other.controller && other.controller.rumble) {
      if (this.viewport.settings.rumble) {
        other.controller.rumble({
          duration: 120,
          strongMagnitude: 1.0,
          weakMagnitude: 1.0
        });
        this.onTimeout(100, () => {
          other.controller.rumble({
            duration: 100,
            strongMagnitude: 0.0,
            weakMagnitude: 0.5
          });
        });
      }
    }
    if (other instanceof _Projectile.Projectile || type === 1 || type === 3 || type === 0) {
      if (!['dead', 'exploding', 'damaged', 'done'].includes(this.args.phase)) {
        this.args.phase = 'damaged';
        this.args.animation = '';
        this.args.animation = 'damaged';
        if (this.args.hitPoints === 0 && this.args.phase !== 'exploding') {
          this.box.setAttribute('data-phase', 'dead');
          this.args.animation = '';
          this.args.phase = 'dead';
          if (typeof ga === 'function') {
            _Analytic.Analytic.report({
              eventCategory: 'boss',
              eventAction: 'defeated',
              eventLabel: `${this.viewport.args.actName}::${this.args.id}`
            });
          }
        }
        this.viewport.onFrameOut(20, () => {
          if (this.args.phase === 'intro') {
            return;
          }
          if (this.args.hitPoints > 0) {
            this.args.animation = 'attacking';
            this.args.phase = 'attacking';
          } else if (!['dead', 'exploding', 'done'].includes(this.args.phase)) {
            this.box.setAttribute('data-phase', 'dead');
            this.args.animation = 'dead';
            this.args.phase = 'dead';
            this.args.xSpeed = 0;
            other.args.score += 20000;
          }
        });
      }
      if (type === 0) {
        other.args.y = this.y - this.args.height;
        const animation = other.args.animation;
        const ySpeed = other.args.ySpeed;
        this.onNextFrame(() => {
          other.args.animation = animation;
          other.args.falling = true;
          other.args.xSpeed = -4 * Math.sign(this.x - other.x);
          other.args.ySpeed = -Math.floor(Math.abs(ySpeed)) || -4;
        });
        _Sfx.Sfx.play('BOSS_DAMAGED');
      }
      const gSpeed = other.args.gSpeed;
      other.args.gSpeed = -gSpeed;
      if (other.args.rolling) {
        this.onNextFrame(() => {
          other.args.gSpeed = -gSpeed;
          other.args.rolling = true;
          other.args.direction - Math.sign(gSpeed);
        });
      }
    }
    other.args.ignore = 1;
    if (!this.args.hitPoints) {
      _Bgm.Bgm.stop('ZONE-BOSS');
      _Bgm.Bgm.stop('ACT-BOSS');
      other.args.ignore = -2;
    }
    return true;
  }
  handleDamage(other) {
    _Sfx.Sfx.play('BOSS_DAMAGED');
    if (other) {
      const label = ['LUCKY SHOT', 'IM GOING EASY', 'OKAY', 'NICE', 'WOW', 'JEEZ', 'DAMN!', 'STOP!'][other.args.popChain.length];
      const reward = {
        label,
        points: 1000 * other.args.popChain.length,
        multiplier: 1
      };
      other.args.popChain.push(reward);
      other.args.popCombo += 1;
    }
  }
  update() {
    this.args.phaseFrameId++;
    this.args.frameId++;
    if (this.args.phase === 'idle') {
      if (this.args.phaseFrameId > 120) {
        this.args.phase = 'intro';
      }
      return;
    }
    if (!this.viewport) {
      return;
    }
    if (this.args.phase === 'intro') {
      if (this.hanging.has(_MiniMace.MiniMace)) {
        for (const mace of this.hanging.get(_MiniMace.MiniMace)) {
          mace.args.ropeLength = 80;
        }
        _Bgm.Bgm.play('ACT-BOSS', {
          loop: true,
          interlude: true
        });
      }
      if (this.hanging.has(_MegaMace.MegaMace)) {
        for (const mace of this.hanging.get(_MegaMace.MegaMace)) {
          mace.args.ropeLength = 96;
        }
        _Bgm.Bgm.play('ZONE-BOSS', {
          loop: true,
          interlude: true
        });
      }
      this.args.maxSpeed = 12;
      if (this.args.phaseFrameId > 240) {
        this.args.phase = 'attacking';
      }
    } else if (this.hanging.has(_MiniMace.MiniMace)) {
      this.viewport.onFrameOut(45, () => {
        for (const mace of this.hanging.get(_MiniMace.MiniMace)) {
          mace.args.ropeLength = 128;
        }
      });
    } else if (this.hanging.has(_MegaMace.MegaMace)) {
      this.viewport.onFrameOut(45, () => {
        for (const mace of this.hanging.get(_MegaMace.MegaMace)) {
          mace.args.ropeLength = 176;
        }
      });
    }
    if (this.args.phase === 'attacking') {
      this.args.maxSpeed = 9;
      if (this.hanging.has(_MiniMace.MiniMace)) {
        for (const mace of this.hanging.get(_MiniMace.MiniMace)) {
          mace.args.float = 0;
        }
      }
      if (this.hanging.has(_MegaMace.MegaMace)) {
        for (const mace of this.hanging.get(_MegaMace.MegaMace)) {
          mace.args.float = 0;
        }
      }
      if (Math.abs(this.viewport.controlActor.x - this.x) > 255) {
        this.args.phase = 'chasing';
      }
    }
    if (this.args.phase === 'chasing') {
      if (Math.abs(this.viewport.controlActor.x - this.x) < 8 && this.y < this.viewport.controlActor.y) {
        this.args.phase = 'attacking';
      }
    }
    if (this.args.phase === 'exploding') {
      const viewport = this.viewport;
      if (viewport && viewport.args.frameId % 3 === 0) {
        const explosion = new _Tag.Tag('<div class = "particle-explosion">');
        _Sfx.Sfx.play('BOSS_DAMAGED');
        const xOff = this.args.width * Math.random() - this.args.width / 2;
        const yOff = this.args.height * Math.random() - this.args.height / 2;
        explosion.style({
          '--x': this.x + xOff,
          '--y': this.y + yOff + -16
        });
        viewport.particles.add(explosion);
        setTimeout(() => viewport.particles.remove(explosion), 512);
      }
      super.update();
      return;
    }
    if (this.args.phase === 'damaged') {
      this.args.xSpeed *= 0.999;
    }
    if (this.box) {
      if (this.x - this.viewport.controlActor.x > 0) {
        if (Math.abs(this.x - this.viewport.controlActor.x) > 128) {
          this.box.setAttribute('data-looking', 'far-left');
        } else if (this.viewport.controlActor.args.direction === -1) {
          this.box.setAttribute('data-looking', 'far-left');
        } else {
          this.box.setAttribute('data-looking', 'left');
        }
      } else if (this.x - this.viewport.controlActor.x < 0) {
        this.box.setAttribute('data-looking', 'far-right');
        if (Math.abs(this.x - this.viewport.controlActor.x) > 128) {
          this.box.setAttribute('data-looking', 'far-right');
        } else if (this.viewport.controlActor.args.direction === 1) {
          this.box.setAttribute('data-looking', 'far-right');
        } else {
          this.box.setAttribute('data-looking', 'right');
        }
      }
      if (32 > this.y - this.viewport.controlActor.y) {
        this.box.setAttribute('data-ducking', 'true');
      } else {
        this.box.setAttribute('data-ducking', 'false');
      }
    }
    if (this.args.hitPoints) {
      if (['attacking', 'intro', 'chasing'].includes(this.args.phase)) {
        if (Math.abs(this.x - this.viewport.controlActor.x) > 384) {
          this.args.x = this.viewport.controlActor.x + Math.sign(this.x - this.viewport.controlActor.x) * 384;
        }
        this.args.xSpeed += -Math.sign(this.x - this.viewport.controlActor.x) * 0.35;
      }
    }
    if (this.args.hitPoints) {
      this.args.falling = true;
      this.args.float = -1;
    } else {
      this.args.float = 0;
    }
    if (this.args.phase === 'intro' || this.args.phase === 'attacking') {
      this.args.maxSpeed = 11;
    }
    if (this.args.phase === 'chasing') {
      if (Math.abs(this.x - this.viewport.controlActor.x) < 128) {
        this.args.maxSpeed = Math.max(this.args.maxSpeed, this.viewport.controlActor.args.xSpeed);
      }
    } else if (Math.abs(this.args.xSpeed) > this.args.maxSpeed) {
      this.args.xSpeed = Math.sign(this.args.xSpeed) * this.args.maxSpeed;
    }
    super.update();
  }
  onRendered(event) {
    super.onRendered(event);
    this.body = new _Tag.Tag(`<div class = "body-center">`);
    this.bodyL = new _Tag.Tag(`<div class = "body-left">`);
    this.bodyR = new _Tag.Tag(`<div class = "body-right">`);
    this.fireA = new _Tag.Tag(`<div class = "boost-fire boost-fire-left">`);
    this.fireB = new _Tag.Tag(`<div class = "boost-fire boost-fire-right">`);
    this.eye = new _Tag.Tag(`<div class = "orange-eye">`);
    this.box.appendChild(this.body.node);
    this.box.appendChild(this.bodyL.node);
    this.box.appendChild(this.bodyR.node);
    this.box.appendChild(this.fireA.node);
    this.box.appendChild(this.fireB.node);
    this.box.appendChild(this.eye.node);
  }
  get solid() {
    return false;
  }
}
exports.RedEyeJet = RedEyeJet;
});

;require.register("actor/Redz.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Redz = void 0;
var _Flickie = require("./Flickie");
var _Mixin = require("curvature/base/Mixin");
var _Tag = require("curvature/base/Tag");
var _PointActor = require("./PointActor");
var _SkidDust = require("../behavior/SkidDust");
var _Patrol = require("../behavior/Patrol");
var _CanPop = require("../mixin/CanPop");
var _Explosion = require("../actor/Explosion");
var _SpitFire = require("../actor/SpitFire");
class Redz extends _Mixin.Mixin.from(_PointActor.PointActor, _CanPop.CanPop) {
  constructor() {
    super(...arguments);
    this.behaviors.add(new _SkidDust.SkidDust());
    this.behaviors.add(new _Patrol.Patrol());
    this.args.type = 'actor-item actor-redz';
    this.args.animation = 'standing';

    // this.args.accel     = 0.1;
    // this.args.decel     = 0.5;

    this.args.gSpeedMax = 5;
    this.args.jumpForce = 5;
    this.args.gravity = 0.5;
    this.args.width = 18;
    this.args.height = 32;
    this.willStick = false;
    this.stayStuck = false;
    this.args.patrolBeat = this.args.patrolBeat || 160;
    this.args.patrolPause = this.args.patrolPause || 60;
    this.args.patrolSpeed = this.args.patrolSpeed || 0.25;
  }
  update() {
    super.update();
    const direction = this.args.direction = Math.sign(this.args.gSpeed) || this.args.direction;
    if (this.box) {
      if (Math.sign(this.args.gSpeed) !== direction && Math.abs(this.args.gSpeed - direction) > 5) {
        this.box.setAttribute('data-animation', 'skidding');
      } else if (this.args.moving && this.args.gSpeed) {
        this.box.setAttribute('data-animation', 'walking');
      } else {
        this.box.setAttribute('data-animation', 'shooting');
      }
    }
    if (this.age % this.args.patrolBeat === this.args.patrolBeat - this.args.patrolPause) {
      const spitFire = new _SpitFire.SpitFire({
        owner: this,
        direction,
        x: this.x + 59 * direction,
        y: this.y - 3,
        z: this.z + 1
      });
      const viewport = this.viewport;
      viewport.spawn.add({
        object: spitFire
      });
      this._onRemove.add(() => viewport.actors.remove(spitFire));
    }
  }
  effect(other) {
    super.effect(other);

    // this.viewport.spawn.add({object:new Flickie({
    // 	x: this.args.x,
    // 	y: this.args.y,
    // })});
  }

  get solid() {
    return false;
  }
  get isEffect() {
    return false;
  }
  // get controllable() { return true; }
}
exports.Redz = Redz;
});

;require.register("actor/Relief.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Relief = void 0;
var _PointActor = require("./PointActor");
var _Block = require("./Block");
var _Sfx = require("../audio/Sfx");
var _ObjectPalette = require("../ObjectPalette");
class Relief extends _PointActor.PointActor {
  constructor() {
    var _this$args$offset, _this$args$shoots;
    super(...arguments);
    this.args.width = 24;
    this.args.height = 80;
    this.args.type = 'actor-item actor-relief';
    this.noClip = true;
    this.args.float = -1;
    this.args.offset = (_this$args$offset = this.args.offset) !== null && _this$args$offset !== void 0 ? _this$args$offset : 45;
    this.args.animation = 'idle';
    this.args.shoots = (_this$args$shoots = this.args.shoots) !== null && _this$args$shoots !== void 0 ? _this$args$shoots : 'spitsteam';
    this.launching = new Set();
  }
  update() {
    super.update();
    const frame = this.viewport.args.frameId + -this.args.offset;
    if (frame % 60) {
      return;
    }
    if (!this.shoots && _ObjectPalette.ObjectPalette[this.args.shoots]) {
      var _this$args$direction;
      const type = _ObjectPalette.ObjectPalette[this.args.shoots];
      const direction = (_this$args$direction = this.args.direction) !== null && _this$args$direction !== void 0 ? _this$args$direction : 1;
      this.shoots = new type({
        owner: this,
        direction,
        x: this.x,
        y: this.y + -24,
        z: this.z + 1
      });
      this.shoots.args.x += this.shoots.args.width * 0.5 * direction + this.args.width * 0.3 * direction;
      this.shoots.args.y += this.shoots.args.height * 0.5;
      this.viewport.spawn.add({
        object: this.shoots
      });
    }
    if (this.shoots.args.gone) {
      this.shoots = null;
    }
  }
  collideA(other) {
    return true;
  }
  get solid() {
    return true;
  }
}
exports.Relief = Relief;
});

;require.register("actor/RhinoBot.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RhinoBot = void 0;
var _Flickie = require("./Flickie");
var _Mixin = require("curvature/base/Mixin");
var _PointActor = require("./PointActor");
var _Patrol = require("../behavior/Patrol");
var _CanPop = require("../mixin/CanPop");
class RhinoBot extends _Mixin.Mixin.from(_PointActor.PointActor, _CanPop.CanPop) {
  constructor() {
    super(...arguments);

    // this.behaviors.add(new Patrol);

    this.args.type = 'actor-item actor-rhino-bot';
    this.args.animation = 'standing';
    this.args.accel = 0.75;
    this.args.decel = 0.5;
    this.args.gSpeedMax = 15;
    this.args.jumpForce = 5;
    this.args.gravity = 0.5;
    this.args.width = 44;
    this.args.height = 32;

    // this.args.patrolPause   = this.args.patrolPause   ?? 20;
    // this.args.patrolBeat    = this.args.patrolBeat    ?? 120;
    // this.args.patrolSpeed   = this.args.patrolSpeed   ?? 4;

    // this.args.tailOffset = 0;

    this.chasing = false;
  }
  onRendered(event) {
    super.onRendered(event);
  }
  update() {
    // const direction = this.args.direction;
    const telegraph = this.args.shotTelegraph;
    const beat = this.args.patrolBeat;
    const moved = this.args.x - this.xLast;
    this.args.tailOffset += isNaN(moved) ? 0 : moved;
    if (this.box) {
      if (this.args.moving && this.args.gSpeed) {
        this.box.setAttribute('data-animation', 'walking');
      } else {
        this.box.setAttribute('data-animation', 'standing');
      }
    }
    if (this.viewport && this.viewport.controlActor) {
      if (Math.abs(this.viewport.controlActor.args.x - this.args.x) < 768) {
        this.chasing = this.viewport.controlActor;
      }
    }
    if (this.chasing) {
      this.args.gSpeed += (this.chasing.args.x - this.args.x) * 0.1;
      const diff = Math.abs(this.chasing.args.x - this.chasing.args.x);
      const maxSpeed = Math.max(6, Math.abs(this.chasing.args.gSpeed || this.chasing.args.xSpeed) * (diff > 256 ? 1.2 : 1));
      if (Math.abs(this.args.gSpeed) > maxSpeed) {
        this.args.gSpeed = Math.sign(this.args.gSpeed) * maxSpeed;
      }
    }
    super.update();
    this.args.direction = Math.sign(this.args.gSpeed);
    this.args.facing = this.args.direction > 0 ? 'right' : 'left';
  }
  effect(other) {
    super.effect(other);

    // this.viewport.spawn.add({object:new Flickie({
    // 	x: this.args.x,
    // 	y: this.args.y,
    // })});
  }

  get solid() {
    return false;
  }
  get isEffect() {
    return false;
  }
  // get controllable() { return true; }
}
exports.RhinoBot = RhinoBot;
});

;require.register("actor/Ring.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Ring = void 0;
var _PointActor = require("./PointActor");
var _Spring = require("./Spring");
var _Sfx = require("../audio/Sfx");
var _Analytic = require("../lib/Analytic");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class Ring extends _PointActor.PointActor {
  constructor() {
    var _this$args$static, _this$args$dropped, _this$args$delay;
    super(...arguments);
    _defineProperty(this, "template", `<div class  = "point-actor [[type]]">
		<div class = "sprite" cv-ref = "sprite" style = "--spinSpeed:[[spinSpeed]]"></div>
	</div>`);
    _defineProperty(this, "float", -1);
    this[_Spring.Spring.WontSpring] = true;
    this.args.type = 'actor-item actor-ring';
    this.args.width = 32;
    this.args.height = 32;
    this.args.static = (_this$args$static = this.args.static) !== null && _this$args$static !== void 0 ? _this$args$static : true;
    this.args.dropped = (_this$args$dropped = this.args.dropped) !== null && _this$args$dropped !== void 0 ? _this$args$dropped : true;
    this.args.gone = false;
    this.args.gravity = 0.40;
    this.args.delay = (_this$args$delay = this.args.delay) !== null && _this$args$delay !== void 0 ? _this$args$delay : 48;
    this.args.spinSpeed = 1;
  }
  update() {
    if (!this.viewport) {
      return;
    }
    const currentFrame = this.viewport.args.frameId;
    const startFrame = this.startFrame;
    const age = currentFrame - startFrame;
    if (this.args.noClip) {
      this.noClip = true;
    } else if (!this.args.decoration) {
      if (this.args.ySpeed < 0) {
        this.noClip = true;
      } else if (!this.attract) {
        this.noClip = false;
      }
    } else {
      this.noClip = true;
    }
    if (this.args.decoration) {
      this.args.type = 'actor-item actor-ring decoration';
      this.args.gravity = 0.36;
    }
    if (this.dropped) {
      this.args.type = 'actor-item actor-ring dropped';
      this.args.height = 14;
    }
    const viewport = this.viewport;
    if (this.dropped && this.viewport && !this.viewport.actorIsOnScreen(this, 256)) {
      viewport.onFrameOut(15, () => {
        viewport.actors.remove(this);
      });
    }
    if (this.args.reward && this.args.gone) {
      viewport.onFrameOut(15, () => {
        viewport.actors.remove(this);
      });
    }
    if (this.args.reward || this.dropped || this.attract) {
      super.update();
    }
    if (this.args.reward) {
      return;
    }
    if (this.dropped && !this.attract && this.getMapSolidAt(this.args.x, this.args.y + -this.args.height) && !this.getMapSolidAt(this.args.x, this.args.y)) {
      this.args.y += this.args.height + 1;
      this.args.ySpeed = Math.abs(this.args.ySpeed) || 8;
    } else if (this.dropped && !this.attract && this.getMapSolidAt(this.args.x + (this.args.xSpeed || this.xSpeedLast), this.args.y + -8, false)) {
      this.args.xSpeed *= -1;
    }
    if (this.dropped && age === 30) {
      this.args.spinSpeed += 0.25;
    }
    if ((this.dropped || this.scattered) && (!this.args.falling || !this.args.ySpeed)) {
      // this.args.xSpeed = this.args.xSpeed || this.xSpeedLast || (Math.random() - 0.5);
      this.args.ySpeed = Math.min(-Math.abs(this.args.ySpeed || this.ySpeedLast || 0) * 0.75, age > 6 ? -2 : 0);
      this.args.gSpeed = 0;
      this.args.x += this.args.xSpeed;
      this.args.y += this.args.ySpeed;
      this.args.groundAngle = 0;
      if (!this.args.falling && this.args.spinSpeed < 2.5) {
        this.args.spinSpeed += 0.25;
      }
      this.args.falling = true;
    }
  }
  callCollideHandler(other) {
    if (other instanceof Ring) {
      return false;
    }
    return super.callCollideHandler(other);
  }
  collideA(other) {
    if (other instanceof this.constructor) {
      return;
    }
    if (!this.viewport || this.args.gone || this.args.ignore) {
      return false;
    }
    const age = this.viewport.args.frameId - this.startFrame;
    if (this.dropped && age < this.args.delay) {
      return false;
    }
    if (other.args.owner) {
      other = other.args.owner;
    }
    if (other.occupant) {
      other = other.occupant;
    }
    if (!other.controllable && !other.occupant && !other.args.owner) {
      return false;
    }
    super.collideA(other);
    if (other.controllable) {
      other.args.rings += 1;
    }
    this.args.gone = true;
    this.viewport.auras.delete(this);

    // this.args.xSpeed = 0;
    // this.args.ySpeed = 0;
    this.args.static = true;
    this.args.float = -1;
    this.args.type = 'actor-item actor-ring collected';
    this.args.xSpeed = 0;
    this.args.ySpeed = 0;
    if (this.viewport.args.audio) {
      _Sfx.Sfx.play('RING_COLLECTED');
    }
    this.viewport.onFrameOut(5, () => {
      this.args.type = 'actor-item actor-ring collected gone';
    });
    const x = this.args.x;
    const y = this.args.y;
    const viewport = this.viewport;
    this.viewport.onFrameOut(4200, () => {
      this.restore = true;
    });
    if (other.collect) {
      if (typeof ga === 'function') {
        _Analytic.Analytic.report({
          eventCategory: 'ring',
          eventAction: 'collected',
          eventLabel: `${this.viewport.args.actName}::${this.args.id}`
        });
      }
      this.viewport.onFrameOut(1, () => {
        other.collect(this);
      });
    }

    // this.args.xSpeed = 0;
    // this.args.ySpeed = 0;
  }

  wakeUp() {
    if (this.def && this.restore) {
      this.args.x = this.def.get('x');
      this.args.y = this.def.get('y');
      // this.args.float = -1;

      this.args.gone = this.restore = false;
      this.args.type = 'actor-item actor-ring';
    }
  }
  get solid() {
    return false;
  }
  get rotateLock() {
    return true;
  }
}
exports.Ring = Ring;
});

;require.register("actor/RoadBarrier.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RoadBarrier = void 0;
var _PointActor = require("./PointActor");
class RoadBarrier extends _PointActor.PointActor {
  constructor() {
    super(...arguments);
    this.args.width = this.args.width || 64;
    this.args.height = this.args.height || 32;
    this.args.type = 'actor-item actor-road-barrier';
    this.args.z = 0;
  }
  get solid() {
    return false;
  }
}
exports.RoadBarrier = RoadBarrier;
});

;require.register("actor/Rocket.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Rocket = void 0;
var _PointActor = require("./PointActor");
var _Tag = require("curvature/base/Tag");
var _Sfx = require("../audio/Sfx");
class Rocket extends _PointActor.PointActor {
  constructor() {
    var _this$args$xMax, _this$args$yMax;
    super(...arguments);

    // this.args.width  = this.args.width  || 32;
    // this.args.height = this.args.height || 32;

    this.args.width = 64;
    this.args.height = 16;
    this.args.xMax = (_this$args$xMax = this.args.xMax) !== null && _this$args$xMax !== void 0 ? _this$args$xMax : 24;
    this.args.yMax = (_this$args$yMax = this.args.yMax) !== null && _this$args$yMax !== void 0 ? _this$args$yMax : 24;
    this.args.type = 'actor-item actor-rocket';
    this.args.launched = false;
    this.args.bindTo(['xSpeed', 'ySpeed'], v => {
      if (v || !this.args.launched) {
        return;
      }
      ;
      this.explode();
    });
  }
  update() {
    if (!this.viewport) {
      return;
    }
    if (!this.thrusterSound) {
      this.thrusterSound = new Audio('/Sonic/mecha-sonic-thruster.wav');
    } else {
      this.thrusterSound.volume = 0.2 + Math.random() * -0.05;
      if (this.thrusterSound.currentTime > 1.5) {
        this.thrusterSound.currentTime = 0.5;
      }
    }
    super.update();
    if (this.args.launched && Math.abs(this.args.xSpeed) < Math.abs(this.args.xMax)) {
      this.args.xSpeed += 0.5 * Math.sign(this.args.xMax);
    }
    if (this.args.launched && Math.abs(this.args.ySpeed) < Math.abs(this.args.yMax)) {
      this.args.ySpeed -= 0.5 * Math.sign(this.args.yMax);
    }
    if (this.args.launched && this.args.xSpeed === 0 && this.args.ySpeed === 0) {
      this.explode();
    }
  }
  activate() {
    this.viewport.auras.add(this);
    this.viewport.args.audio && this.thrusterSound && this.thrusterSound.play();
    this.args.launched = true;
    if (this.args.xMax) {
      this.args.xSpeed += 0.5;
    }
    if (this.args.yMax) {
      this.args.ySpeed -= 0.5;
    }
  }
  sleep() {
    if (this.args.launched) {
      this.explode();
    }
  }
  wakeUp() {
    // this.args.xSpeed = 0;
    // this.args.ySpeed = 0;
    // this.args.x = this.def.get('x');
    // this.args.y = this.def.get('y');
  }
  explode() {
    const viewport = this.viewport;
    if (!viewport) {
      return;
    }
    _Sfx.Sfx.play('OBJECT_DESTROYED');
    this.thrusterSound && this.thrusterSound.pause();
    const explosion = new _Tag.Tag('<div class = "particle-explosion">');
    explosion.style({
      '--x': this.x,
      '--y': this.y - 8
    });
    viewport.particles.add(explosion);
    setTimeout(() => viewport.particles.remove(explosion), 512);
    this.args.xSpeed = 0;
    this.args.ySpeed = 0;
    this.args.opacity = 0;
    this.args.launched = false;

    // this.args.xSpeed = 0;
    // this.args.ySpeed = 0;

    // this.args.x = this.def.get('x');
    // this.args.y = this.def.get('y');

    this.viewport.setColCell(this);
    this.viewport.onFrameOut(60, () => {});
    const exploded = new CustomEvent('exploded', {
      detail: {
        actor: this
      }
    });
    this.dispatchEvent(exploded);
    this.args.launched = false;
    this.args.opacity = 1;
    this.args.x = this.def.get('x');
    this.args.y = this.def.get('y');
    this.viewport.setColCell(this);
    this.viewport.auras.delete(this);
  }
}
exports.Rocket = Rocket;
});

;require.register("actor/RocketPlatform.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RocketPlatform = void 0;
var _Block = require("./Block");
var _Sfx = require("../audio/Sfx");
class RocketPlatform extends _Block.Block {
  constructor() {
    super(...arguments);
    this.args.width = 96;
    this.args.height = 64;
    this.args.platform = 1;
    this.args.type = 'actor-item actor-rocket-platform';
    this.args.static = 0;
    this.args.activeTime = 0;
  }
  update() {
    this.args.cameraBias = 0.25;
    if (this.standingUnder.size) {
      this.args.activeTime++;
      this.args.active = true;
    } else {
      this.args.activeTime = 0;
      this.args.active = false;
    }
    for (const other of this.standingUnder) {
      if (other.args.dead) {
        // this.args.y += -this.args.ySpeed;
        this.args.ySpeed = 0;
        this.standingUnder.delete(other);
      } else if (!this.args.falling) {
        other.args.y = Math.round(other.args.y);
      }
    }
    super.update();
    if (this.args.activeTime > 1) {
      this.args.ySpeed -= 0.1;
      this.args.float = 1;
      if (!this.args.falling) {
        this.args.falling = true;
        this.args.ySpeed = -1;
        this.args.y--;
      }
    }
  }
  collideA(other, type) {
    if (type !== 0) {
      return super.collideA(other, type);
    }
    if (!other.controllable) {
      return super.collideA(other, type);
    }
    this.args.ySpeed -= 0.1;
    this.args.float = 1;
    if (this.args.ySpeed < -3) {
      this.args.ySpeed = -3;
    }
    return super.collideA(other, type);
  }
}
exports.RocketPlatform = RocketPlatform;
});

;require.register("actor/Rocks.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Rocks = void 0;
var _PointActor = require("./PointActor");
var _Projectile = require("../actor/Projectile");
var _Tag = require("curvature/base/Tag");
var _Sfx = require("../audio/Sfx");
class Rocks extends _PointActor.PointActor {
  constructor(args, parent) {
    super(args, parent);
    this.args.type = 'actor-item actor-rocks-tall';
    this.args.width = 48;
    this.args.height = 80;
    this.gone = false;
    this.particleA = new _Tag.Tag('<div class = "particle-rock">');
    this.particleB = new _Tag.Tag('<div class = "particle-rock">');
    this.particleC = new _Tag.Tag('<div class = "particle-rock">');
    this.particleD = new _Tag.Tag('<div class = "particle-rock">');
    this.particleE = new _Tag.Tag('<div class = "particle-rock">');
    this.particleF = new _Tag.Tag('<div class = "particle-rock">');
    this.particleG = new _Tag.Tag('<div class = "particle-rock">');
    this.particleH = new _Tag.Tag('<div class = "particle-rock">');
  }
  onRendered(event) {
    super.onRendered(event);

    // const direction = Math.sign(other.args.gSpeed || other.args.xSpeed);

    let direction = -1;
    const fuzzFactor = 20;
    const fallSpeed = 1550;
    const xForce = 60;
    const yForce = 40;
    const particleA = this.particleA;
    const particleB = this.particleB;
    const particleC = this.particleC;
    const particleD = this.particleD;
    const particleE = this.particleE;
    const particleF = this.particleF;
    const particleG = this.particleG;
    const particleH = this.particleH;
    particleA.style({
      '--x': this.x - 8,
      '--y': this.y - 8,
      '--fallSpeed': fallSpeed + fuzzFactor * Math.random(),
      '--xMomentum': xForce * direction + fuzzFactor * Math.random(),
      '--yMomentum': yForce,
      'z-index': 0
    });
    direction *= -1;
    particleB.style({
      '--x': this.x + 8,
      '--y': this.y - 0,
      '--fallSpeed': fallSpeed + fuzzFactor * Math.random(),
      '--xMomentum': xForce * direction + fuzzFactor * Math.random(),
      '--yMomentum': yForce,
      'z-index': 0
    });
    direction *= -1;
    particleC.style({
      '--x': this.x,
      '--y': this.y - 18,
      '--fallSpeed': fallSpeed + fuzzFactor * Math.random(),
      '--xMomentum': xForce * direction + fuzzFactor * Math.random(),
      '--yMomentum': yForce * 1.1,
      'z-index': 0
    });
    direction *= -1;
    particleD.style({
      '--x': this.x + 8,
      '--y': this.y - 10,
      '--fallSpeed': fallSpeed + fuzzFactor * Math.random(),
      '--xMomentum': xForce * direction + fuzzFactor * Math.random(),
      '--yMomentum': yForce * 1.1,
      'z-index': 0
    });
    direction *= -1;
    particleE.style({
      '--x': this.x - 8,
      '--y': this.y - 28,
      '--fallSpeed': fallSpeed + fuzzFactor * Math.random(),
      '--xMomentum': xForce * direction + fuzzFactor * Math.random(),
      '--yMomentum': yForce * 1.2,
      'z-index': 0
    });
    direction *= -1;
    particleF.style({
      '--x': this.x + 8,
      '--y': this.y - 20,
      '--fallSpeed': fallSpeed + fuzzFactor * Math.random(),
      '--xMomentum': xForce * direction + fuzzFactor * Math.random(),
      '--yMomentum': yForce * 1.2,
      'z-index': 0
    });
    direction *= -1;
    particleG.style({
      '--x': this.x - 8,
      '--y': this.y - 30,
      '--fallSpeed': fallSpeed + fuzzFactor * Math.random(),
      '--xMomentum': xForce * direction + fuzzFactor * Math.random(),
      '--yMomentum': yForce * 1.2,
      'z-index': 0
    });
    direction *= -1;
    particleH.style({
      '--x': this.x + 8,
      '--y': this.y - 30,
      '--fallSpeed': fallSpeed + fuzzFactor * Math.random(),
      '--xMomentum': xForce * direction + fuzzFactor * Math.random(),
      '--yMomentum': 50 * 1.3,
      'z-index': 0
    });
  }
  collideA(other, type) {
    if (this.args.gone) {
      return false;
    }
    super.collideA(other, type);
    if (other.occupant || other.args.rolling || other.punching) {
      this.pop(other);
      return false;
    }
    if (type !== 2 && (!this.args.falling || this.args.float === -1) && other.args.ySpeed > 0 && other.y < this.y && this.viewport && !this.args.gone) {
      if (this.args.falling && Math.abs(other.args.ySpeed) > 0) {
        other.args.xSpeed *= -1;
      }
      this.pop(other);
      return false;
    }
    if ((type === 1 || type === 3) && other instanceof _Projectile.Projectile && this.viewport && !this.args.gone) {
      this.pop(other);
      return false;
    }
    return true;
  }

  // collideB(other)
  // {
  // 	if(other.args.falling && this.args.gone)
  // 	{
  // 		other.args.ySpeed *= -1;
  // 		other.args.falling = true;
  // 	}

  // 	return false;
  // }

  pop(other) {
    this.args.gone = true;
    const viewport = this.viewport;
    if (!viewport) {
      return;
    }
    _Sfx.Sfx.play('ROCKS_DESTROYED');
    const particleA = this.particleA;
    const particleB = this.particleB;
    const particleC = this.particleC;
    const particleD = this.particleD;
    const particleE = this.particleE;
    const particleF = this.particleF;
    const particleG = this.particleG;
    const particleH = this.particleH;
    viewport.particles.add(particleA);
    viewport.particles.add(particleB);
    viewport.particles.add(particleC);
    viewport.particles.add(particleD);
    viewport.particles.add(particleE);
    viewport.particles.add(particleF);
    viewport.particles.add(particleG);
    viewport.particles.add(particleH);
    setTimeout(() => {
      viewport.particles.remove(particleA);
      viewport.particles.remove(particleB);
      viewport.particles.remove(particleC);
      viewport.particles.remove(particleD);
      viewport.particles.remove(particleE);
      viewport.particles.remove(particleF);
      viewport.particles.remove(particleG);
      viewport.particles.remove(particleH);
    }, 2500);
    this.onNextFrame(() => viewport.actors.remove(this));
  }
  get canStick() {
    return false;
  }
  get solid() {
    return !this.args.gone;
  }
}
exports.Rocks = Rocks;
});

;require.register("actor/RollingSign.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RollingSign = void 0;
var _PointActor = require("./PointActor");
class RollingSign extends _PointActor.PointActor {
  static fromDef(objDef) {
    const obj = super.fromDef(objDef);
    obj.args.width = objDef.width;
    obj.args.height = objDef.height;
    return obj;
  }
  constructor() {
    var _this$args$height;
    super(...arguments);
    this.args.width = 20;
    this.args.height = (_this$args$height = this.args.height) !== null && _this$args$height !== void 0 ? _this$args$height : 80;
    this.args.type = 'actor-item actor-rolling-sign';
  }
  get solid() {
    return false;
  }
}
exports.RollingSign = RollingSign;
});

;require.register("actor/Scratch.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Scratch = void 0;
var _Flickie = require("./Flickie");
var _Mixin = require("curvature/base/Mixin");
var _PointActor = require("./PointActor");
var _Patrol = require("../behavior/Patrol");
var _CanPop = require("../mixin/CanPop");
class Scratch extends _Mixin.Mixin.from(_PointActor.PointActor, _CanPop.CanPop) {
  constructor() {
    var _this$args$patrolPaus, _this$args$patrolBeat, _this$args$patrolSpee;
    super(...arguments);
    this.behaviors.add(new _Patrol.Patrol());
    this.args.type = 'actor-item actor-scratch';
    this.args.animation = 'standing';
    this.args.accel = 0.1;
    this.args.decel = 0.5;
    this.args.gSpeedMax = 5;
    this.args.jumpForce = 5;
    this.args.gravity = 0.5;
    this.args.width = 32;
    this.args.height = 39;
    this.willStick = false;
    this.stayStuck = false;
    this.args.patrolPause = (_this$args$patrolPaus = this.args.patrolPause) !== null && _this$args$patrolPaus !== void 0 ? _this$args$patrolPaus : 20;
    this.args.patrolBeat = (_this$args$patrolBeat = this.args.patrolBeat) !== null && _this$args$patrolBeat !== void 0 ? _this$args$patrolBeat : 120;
    this.args.patrolSpeed = (_this$args$patrolSpee = this.args.patrolSpeed) !== null && _this$args$patrolSpee !== void 0 ? _this$args$patrolSpee : 1;
  }
  onRendered() {
    super.onRendered();
    this.autoAttr.get(this.box)['data-color'] = 'color';
  }
  update() {
    const direction = this.args.direction;
    const telegraph = this.args.shotTelegraph;
    const beat = this.args.patrolBeat;
    if (this.box) {
      if (this.args.moving && this.args.gSpeed) {
        this.box.setAttribute('data-animation', 'walking');
      } else {
        this.box.setAttribute('data-animation', 'standing');
      }
    }
    super.update();
    this.args.direction = Math.sign(this.args.gSpeed);
  }
  effect(other) {
    super.effect(other);

    // this.viewport.spawn.add({object:new Flickie({
    // 	x: this.args.x,
    // 	y: this.args.y,
    // })});
  }

  get solid() {
    return false;
  }
  get isEffect() {
    return false;
  }
  // get controllable() { return true; }
}
exports.Scratch = Scratch;
});

;require.register("actor/Sean.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Sean = void 0;
var _PointActor = require("./PointActor");
var _Tag = require("curvature/base/Tag");
var _SkidDust = require("../behavior/SkidDust");
class Sean extends _PointActor.PointActor {
  constructor() {
    super(...arguments);
    this.behaviors.add(new _SkidDust.SkidDust());
    this.args.type = 'actor-item actor-sean';
    this.args.normalHeight = 35;
    this.args.rollingHeight = 28;
    this.args.accel = 0.25;
    this.args.decel = 0.4;
    this.args.gSpeedMax = 18;
    this.args.jumpForce = 11;
    this.args.gravity = 0.5;
    this.args.width = 18;
    this.args.height = 35;
  }
  onRendered(event) {
    super.onRendered(event);
    this.box = this.findTag('div');
  }
  update() {
    const falling = this.args.falling;
    if (!this.box) {
      super.update();
      return;
    }
    if (!falling) {
      if (this.yAxis > 0) {
        this.args.crouching = true;
      } else {
        this.args.crouching = false;
      }
      const direction = this.args.direction;
      const gSpeed = this.args.gSpeed;
      const speed = Math.abs(gSpeed);
      const maxSpeed = this.args.gSpeedMax;
      if (this.args.rolling) {
        this.box.setAttribute('data-animation', 'rolling');
      } else if (Math.sign(this.args.gSpeed) !== direction && Math.abs(this.args.gSpeed - direction) > 5) {
        this.box.setAttribute('data-animation', 'standing');
      } else if (speed > maxSpeed * 0.25) {
        this.box.setAttribute('data-animation', 'running');
      } else if (this.args.moving && gSpeed) {
        this.box.setAttribute('data-animation', 'walking');
      }
      // else if(this.args.crouching || (this.args.standingOn && this.args.standingOn.isVehicle))
      // {
      // 	this.box.setAttribute('data-animation', 'crouching');
      // }
      else {
        this.box.setAttribute('data-animation', 'standing');
      }
    } else if (this.args.jumping) {
      this.box.setAttribute('data-animation', 'jumping');
    }
    super.update();
  }
  get solid() {
    return false;
  }
  get canRoll() {
    return true;
  }
  get isEffect() {
    return false;
  }
  get controllable() {
    return true;
  }
}
exports.Sean = Sean;
});

;require.register("actor/SeeSaw.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SeeSaw = void 0;
var _PointActor = require("./PointActor");
var _Ring = require("./Ring");
var _Tag = require("curvature/base/Tag");
const Side = Symbol('Side');
class SeeSaw extends _PointActor.PointActor {
  constructor(args, parent) {
    var _this$args$power, _this$args$power2;
    super(args, parent);
    this.args.width = 96;
    this.args.height = 32;
    this.noClip = true;
    this.args.float = -1;
    this.args.power = (_this$args$power = this.args.power) !== null && _this$args$power !== void 0 ? _this$args$power : 20;
    this.tiltTime = 0;

    // this.args.direction = this.args.direction || 1;

    this.args.power = (_this$args$power2 = this.args.power) !== null && _this$args$power2 !== void 0 ? _this$args$power2 : 12;
    this.args.type = 'actor-item actor-see-saw';
    this.args.bindTo('tilt', v => {
      this.args.type = `actor-item actor-see-saw ${v}`;
      this.tiltTime = 0;
    });
  }
  onRendered(event) {
    super.onRendered(event);
    if (!this.hub) {
      this.hub = new _Tag.Tag('<div class = "see-saw-hub">');
      this.box.appendChild(this.hub.node);
    }
  }
  collideA(other, type) {
    if (other instanceof _Ring.Ring) {
      return;
    }
    if (!other.args.falling || other.args.ySpeed <= 0) {
      return;
    }
    other.args.groundAngle = 0;
    if (Math.abs(other.x - this.x) > 4) {
      const newTilt = Math.sign(other.x - this.x);
      this.reflectImpulse(other, newTilt * other.args.weight * Math.abs(other.args.ySpeed));
      if (other.x < this.x) {
        this.tiltClass = 'tilt-left';
        this.tilt = -1;
      } else if (other.x > this.x) {
        this.tiltClass = 'tilt-right';
        this.tilt = 1;
      }
      this.args.tilt = this.tiltClass;
    }
  }
  reflectImpulse(other, direction) {
    if (this.reflectObject && this.reflectObject.args.falling && !other.args.falling) {
      return;
    }
    if (this.tilt === Math.sign(direction)) {
      return;
    }
    this.reflectObject = other;
    this.reflectForce = direction;
  }
  update() {
    this.tiltTime++;
    super.update();
  }
  updateEnd() {
    super.updateEnd();
    const collisions = this.viewport.collisions.get(this);
    if (!collisions) {
      this.reflectObject = null;
      this.reflectForce = 0;
      return;
    }
    for (const other of collisions.keys()) {
      if (other.args.falling) {
        continue;
      }
      other.args.groundAngle = 0;
      const armDist = other.x - this.x;
      const hang = Math.abs(armDist / (this.args.width / 2));
      const otherSide = Math.sign(armDist);
      if (!this.reflectForce || otherSide === Math.sign(this.reflectForce)) {
        continue;
      }
      if (Math.abs(armDist) < 4) {
        continue;
      }
      if (hang < 0.75) {
        other.args.x += armDist / 2;
        other.args.y -= 8;
      }
      const power = Math.abs(this.reflectForce / other.args.weight);
      const torque = Math.min(1, Math.ceil(hang * 3) / 3);
      other.args.gSpeed = 0;
      other.args.xSpeed = 0;
      other.args.ySpeed = Math.min(-6.5, -power * torque * 1.2);
      other.args.y -= 16;
      other.args.falling = true;
    }
    this.reflectObject = null;
    this.reflectForce = 0;
  }
}
exports.SeeSaw = SeeSaw;
});

;require.register("actor/Seymour.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Seymour = void 0;
var _PointActor = require("./PointActor");
var _Tag = require("curvature/base/Tag");
var _Spring = require("./Spring");
var _SkidDust = require("../behavior/SkidDust");
class Seymour extends _PointActor.PointActor {
  constructor() {
    super(...arguments);
    this.behaviors.add(new _SkidDust.SkidDust());
    this.args.type = 'actor-item actor-seymour';
    this.args.spriteSheet = this.spriteSheet = '/secret/seymour-color-corrected.png';
    this.superSpriteSheet = '/secret/super-seymour.png';
    this.args.normalHeight = 44;
    this.args.rollingHeight = 23;
    this.args.accel = 0.25;
    this.args.decel = 0.4;
    this.args.gSpeedMax = 18;
    this.args.jumpForce = 11;
    this.args.gravity = 0.5;
    this.args.width = 18;
    this.args.height = 32;
  }
  onRendered(event) {
    super.onRendered(event);
    this.box = this.findTag('div');
  }
  update() {
    const falling = this.args.falling;
    if (!this.box) {
      super.update();
      return;
    }
    if (!falling) {
      this.springing = false;
      if (this.yAxis > 0) {
        this.args.crouching = true;
      } else {
        this.args.crouching = false;
      }
      const direction = this.args.direction;
      const gSpeed = this.args.gSpeed;
      const speed = Math.abs(gSpeed);
      const maxSpeed = this.args.gSpeedMax;
      if (this.args.rolling) {
        this.args.animation = 'rolling';
      } else if (Math.sign(this.args.gSpeed) !== direction && Math.abs(this.args.gSpeed - direction) > 5) {
        this.args.animation = 'standing';
      } else if (speed > maxSpeed * 0.5) {
        this.args.animation = 'running';
      } else if (this.args.moving && gSpeed) {
        this.args.animation = 'walking';
      }
      // else if(this.args.crouching || (this.args.standingOn && this.args.standingOn.isVehicle))
      // {
      // 	this.box.setAttribute('data-animation', 'crouching');
      // }
      else {
        this.args.animation = 'standing';
      }
    } else if (this.args.jumping) {
      this.args.animation = 'jumping';
    }
    if (this.args.falling && this.springing) {
      this.args.groundAngle = 0;
      this.args.animation = 'springing';
    }
    super.update();
  }
  command_3() {
    this.isSuper = !this.isSuper;
    this.onTimeout(150, () => {
      if (this.args.rings === 0) {
        // this.isSuper = false;
        this.setProfile();
      }
      ;
    });
    this.setProfile();
  }
  setProfile() {
    if (this.isSuper) {
      this.args.spriteSheet = this.superSpriteSheet;

      // this.args.gSpeedMax = this.gSpeedMaxSuper;
      // this.args.jumpForce = this.jumpForceSuper;
      // this.args.accel     = this.accelSuper;
    } else {
      this.args.spriteSheet = this.spriteSheet;

      // this.args.gSpeedMax = this.gSpeedMaxNormal;
      // this.args.jumpForce = this.jumpForceNormal;
      // this.args.accel     = this.accelNormal;
    }
  }

  collideA(other) {
    if (other instanceof _Spring.Spring) {
      this.onNextFrame(() => {
        if (!this.args.falling) {
          return;
        }
        this.springing = true;
        this.args.animation = 'springing';
      });
    }
  }
  get solid() {
    return false;
  }
  get canRoll() {
    return true;
  }
  get isEffect() {
    return false;
  }
  get controllable() {
    return true;
  }
}
exports.Seymour = Seymour;
});

;require.register("actor/Signpost.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Signpost = void 0;
var _CharacterString = require("../ui/CharacterString");
var _PointActor = require("./PointActor");
var _Tag = require("curvature/base/Tag");
class Signpost extends _PointActor.PointActor {
  constructor() {
    super(...arguments);
    this.args.type = 'actor-item actor-signpost';
    this.args.width = 48;
    this.args.height = 256;
    this.args.active = false;
    this.args.follow = false;
    this.args.activeTime = 0;
    this.cleared = false;
    this.willActivate = false;
    this.clearedBy = null;
  }
  collideA(other) {
    if (!other.controllable || this.args.active) {
      return;
    }
    this.willActivate = true;
    this.viewport.onFrameOut(10, () => {
      this.args.active = true;
      this.clearedBy = other;
    });
    if (this.following) {
      return;
    }
    this.viewport.clearCheckpoints();
    if (!this.finishReward && other.args.popChain.length) {
      this.finishReward = {
        label: 'Big Finish',
        points: 1000,
        multiplier: 1,
        color: 'orange'
      };
      other.args.popChain.push(this.finishReward);
    }
    const yardsPerFrame = (other.args.gSpeed || other.args.xSpeed) / 32;
    const feetPerSecond = yardsPerFrame * 60 * 3;
    other.args.clearSpeed = Math.abs(feetPerSecond);
    this.args.charStrings.push(new _CharacterString.CharacterString({
      value: `Speed: ${feetPerSecond.toFixed(2)} ft/sec`
    }));
    this.following = other;
    this.args.falling = true;
    this.args.follow = true;
    this.args.xSpeed = (other.args.gSpeed || other.args.xSpeed) * 1.1;
    this.args.ySpeed = -7;
    this.args.y--;
  }
  clear(other) {
    let showZonecard = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    this.cleared = true;
    other.totalCombo();
    this.box.setAttribute('data-cleared-by', other.args.name);
    this.tally = this.viewport.clearAct(`${other.args.name} GOT THROUGH\n${this.viewport.args.actName}`, showZonecard);
    this.viewport.onFrameOut(30, () => {
      this.args.follow = false;
      if (!this.args.boss) {
        return;
      }
    });
    this.viewport.onFrameOut(600, () => {
      if (!this.args.boss) {
        return;
      }
      const boss = this.viewport.actorsById[this.args.boss];
      this.viewport.auras.add(boss);
      boss.args.x = this.x + (this.x < 125000 ? 768 : -768);
      boss.args.y = this.y - 144;
      if (this.viewport.controlActor && this.viewport.controlActor.args.jumpForce < 10.5) {
        boss.args.y += 48;
      }
      boss.args.phase = 'intro';
      other.args.clearSpeed = 0;
    });
  }
  update() {
    if (this.args.active) {
      this.args.activeTime++;
    }
    if (this.args.follow) {
      const other = this.following;
      if (other.skidding && !other.args.rolling && !other.args.falling) {
        if (!this.args.xStart) {
          this.skidLabel = new _CharacterString.CharacterString({
            value: `Skid: 0`
          });
          this.args.xStart = this.x;
          this.args.charStrings.push(this.skidLabel);
        }
        this.args.dragged = Math.trunc(Math.abs(this.args.xStart - this.x));
        this.skidLabel.args.value = `Skid: ${this.args.dragged}`;
        other.args.dragBonus = this.args.dragged;
      }
      const toX = Math.max(this.x, this.viewport.controlActor.x + -160);
      if (toX !== this.x) {
        if (!this.args.falling) {
          const dustParticle = new _Tag.Tag(`<div class = "particle-dust">`);
          const dustPoint = this.rotatePoint(this.args.gSpeed, 0);
          dustParticle.style({
            '--x': dustPoint[0] + this.x + -4,
            '--y': dustPoint[1] + this.y,
            'z-index': 0,
            opacity: Math.random() * 2
          });
          const viewport = this.viewport;
          viewport.particles.add(dustParticle);
          viewport.onFrameOut(30, () => viewport.particles.remove(dustParticle));
        }
        other.args.rolling = false;
        this.args.x = toX;
        while (this.getMapSolidAt(this.x, this.y - 1)) {
          this.args.y--;
        }
      }
    }
    super.update();
    if (this.args.active && !this.cleared) {
      this.clear(this.clearedBy);
    }
  }
  get rotateLock() {
    return true;
  }
}
exports.Signpost = Signpost;
});

;require.register("actor/SkateBoard.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SkateBoard = void 0;
var _SnowBoard = require("./SnowBoard");
var _Tag = require("curvature/base/Tag");
class SkateBoard extends _SnowBoard.SnowBoard {
  constructor() {
    super(...arguments);
    this.args.height = 10;
    this.args.width = 12;
    this.args.seatHeight = 12;
    this.sparks = new Set();
    this.args.accelOrig = 0.5;
    this.args.decelOrig = 0.6;
    this.args.decel = 0.6;
    this.args.accel = 0.8;
    this.args.gravity = 0.65;
    this.args.skidTraction = 0.85;
    this.args.jumpForce = 12.5;
    this.args.type = 'actor-item actor-snow-board actor-skate-board';
    this.args.trick = null;
    this.args.seatAngle = 0;
    this.args.gSpeedMax = 36;
    this.trickTimer = 0;
    this.flipReward = false;
    this.args.rotated = 0;
    this.canGrind = true;
    this.fakie = false;
    this.silentSkid = true;

    // this.args.gravity = 0.1;

    this.bindTo('occupant', v => {
      if (!v) return;
      this.args.gSpeed = v.xSpeedLast || 0;
    });
    this.args.bindTo('trick', v => {
      if (!this.args.falling && v !== 'manual') {
        return;
      }
      if (!v || this.args.grinding) {
        return;
      }
      const reward = {
        label: '',
        points: 100,
        multiplier: 1
      };
      switch (v) {
        case 'insult':
          reward.label = (this.fakie ? 'fakie ' : '') + 'leanback';
          this.occupant.args.popChain.push(reward);
          this.occupant.args.popCombo += 1;
          break;
        case 'handstand':
          reward.label = (this.fakie ? 'fakie ' : '') + 'handstand';
          this.occupant.args.popChain.push(reward);
          this.occupant.args.popCombo += 1;
          break;
        case 'manual':
          if (this.occupant.args.popCombo) {
            reward.label = (this.fakie ? 'fakie ' : '') + 'manual';
            this.occupant.args.popChain.push(reward);
            this.occupant.args.popCombo += 1;
          }
          break;
      }
    });
  }
  update() {
    if (!this.args.falling) {
      this.args.rolling = this.args.mode === 1 && this.args.gSpeed > 0 || this.args.mode === 3 && this.args.gSpeed < 0 || Math.sign(this.args.gSpeed) === Math.sign(this.args.direction) && !this.xAxis;

      // this.args.hLock = false;
    } else {
      if (this.args.jumping && this.fallTime === 1) {
        this.args.groundAngle += Math.PI / 8;
      }

      // this.args.hLock   = this.modeLast === 0;
      this.args.rolling = false;
    }
    if (!this.args.falling) {
      this.flipReward = false;
    }
    if (!this.occupant) {
      this.args.width = 64;
      this.args.height = 12;
    } else {
      this.args.width = 24;
      this.args.height = 40;
    }
    if (this.trickTimer > 0) {
      this.trickTimer--;
    } else {
      this.args.trick = null;
      this.trickTimer = 0;
    }

    // if(this.args.falling && Math.abs(this.yAxis) > 0.55)
    // {
    // 	const dir = (this.args.facing === 'left'?-1:1);

    // 	if(this.yAxis)
    // 	{
    // 		this.args.groundAngle += 0.1 * this.yAxis * dir;
    // 	}

    // 	if(this.yAxis > 0 && Math.abs(this.args.groundAngle) > Math.PI * 2)
    // 	{
    // 		const reward = {label:(this.fakie ? 'fakie ' : '') + 'backflip', points:100, multiplier:1};
    // 		this.occupant.args.popChain.push(reward);
    // 		this.occupant.args.popCombo += 1;
    // 		this.flipReward = true;

    // 		console.log(reward);

    // 		this.args.groundAngle = 0;
    // 	}
    // 	else if(this.yAxis < 0 && Math.abs(this.args.groundAngle) > Math.PI * 2)
    // 	{
    // 		const reward = {label:(this.fakie ? 'fakie ' : '') + 'frontflip', points:100, multiplier:1};
    // 		this.occupant.args.popChain.push(reward);
    // 		this.occupant.args.popCombo += 1;
    // 		this.flipReward = true;

    // 		console.log(reward);

    // 		this.args.groundAngle = 0;
    // 	}
    // }

    super.update();
    if (this.args.falling) {
      this.args.rotated = this.args.groundAngle;
    } else {
      this.fakie = this.args.reversing;

      // if(this.groundTime === 2 && this.occupant)
      // {
      // 	const occupant = this.occupant;

      // 	let dropAngle = this.realAngle;
      // 	let rotated = this.args.rotated;

      // 	while(rotated < 0)
      // 	{
      // 		rotated += Math.PI * 2;
      // 	}

      // 	while(rotated > Math.PI * 2)
      // 	{
      // 		rotated -= Math.PI * 2;
      // 	}

      // 	while(dropAngle < 0)
      // 	{
      // 		dropAngle += Math.PI * 2;
      // 	}

      // 	while(dropAngle > Math.PI * 2)
      // 	{
      // 		dropAngle -= Math.PI * 2;
      // 	}

      // 	// console.log(this.args.rotated, rotated, dropAngle);

      // 	// const diff = Math.abs(rotated - dropAngle);
      // 	// const upsidedown = Math.abs(rotated - Math.PI);

      // 	// if((rotated && (diff > Math.PI)) || upsidedown < Math.PI * 0.25)
      // 	// {
      // 	// 	this.ignores.set(occupant, 30);
      // 	// 	occupant.args.standingOn  = null;
      // 	// 	occupant.args.groundAngle = 0;
      // 	// 	occupant.args.y -= Math.max(0, occupant.args.height * Math.cos(this.args.groundAngle));
      // 	// 	occupant.startle();

      // 	// 	occupant.totalCombo(false);
      // 	// }

      // 	// console.log({rotated, dropAngle, diff, upsidedown, a: (diff > Math.PI), b: upsidedown < Math.PI * 0.35});

      // 	// this.args.rotated = 0;
      // }
    }

    if (this.occupant && !this.trickTimer && !this.args.grinding && this.groundTime > 1 && this.args.trick !== 'manual') {
      this.occupant.totalCombo();
      this.args.trick = null;
    }
    this.ridingAnimation = this.args.gSpeed || this.args.xSpeed || this.args.ySpeed ? 'grinding' : 'standing';
    if (this.idleTime > 30) {
      this.ridingAnimation = 'idle';
    }
    this.crouching = false;
    if (this.yAxis > 0.55 && !this.args.falling) {
      this.ridingAnimation = 'grinding-crouching';
      this.crouching = true;
    }
    this.args.accel = this.args.accelOrig;
    this.args.decel = this.args.decelOrig;
    if (this.crouching) {
      // this.args.accel = accelOrig;
      this.args.decel = 0.1;
    }
    this.args.animation = 'idle-2';
    if (this.args.trick === 'handstand') {
      this.ridingAnimation = 'handstand';
      if (this.trickTimer > 20 || this.trickTimer < 10) {
        this.ridingAnimation = 'flip';
      }
    }
    if (!this.args.grinding && this.grindReward) {
      this.grindReward = null;
    }
    if (this.args.grinding) {
      this.ridingAnimation = 'board-grinding';
      this.args.animation = 'grinding';
      if (this.occupant && this.occupant.args.popCombo) {
        if (!this.grindReward) {
          const reward = {
            label: (this.fakie ? 'fakie ' : '') + 'rail grind',
            points: 100,
            multiplier: 1
          };
          this.grindReward = reward;
          this.occupant.args.popChain.push(reward);
          this.occupant.args.popCombo += 1;
        } else {
          this.grindReward.points += 10;
        }
      }
    } else if (this.args.trick === 'manual' && !this.args.falling) {
      this.ridingAnimation = 'manual';
      this.args.animation = 'manual';
    } else if (this.args.trick === 'insult') {
      this.ridingAnimation = 'insult';
    }
    if (this.args.grinding && !this.args.falling) {
      // `<div class = "particle-sparks">`

      const sparkTag = document.createElement('div');
      sparkTag.classList.add('particle-sparks');
      const sparkParticle = new _Tag.Tag(sparkTag);

      // `<div class = "envelope-sparks">`
      const envelopeTag = document.createElement('div');
      envelopeTag.classList.add('envelope-sparks');
      const sparkEnvelope = new _Tag.Tag(envelopeTag);
      sparkEnvelope.appendChild(sparkParticle.node);
      const sparkPoint = this.rotatePoint(10 * 1.75 * this.args.direction, 8);
      const flip = Math.sign(this.args.gSpeed);
      sparkEnvelope.style({
        '--x': sparkPoint[0] + this.args.x,
        '--y': sparkPoint[1] + this.args.y + Math.random() * -3,
        'z-index': 0,
        'animation-delay': -Math.random() * 0.25 + 's',
        '--xMomentum': Math.max(Math.abs(this.args.gSpeed), 4) * flip,
        '--flip': flip,
        '--angle': this.realAngle,
        opacity: Math.random() * 2
      });
      sparkEnvelope.particle = sparkParticle;
      this.viewport.particles.add(sparkEnvelope);
      this.sparks.add(sparkEnvelope);
      const viewport = this.viewport;
      this.viewport.onFrameOut(30, () => {
        viewport.particles.remove(sparkEnvelope);
        this.sparks.delete(sparkEnvelope);
      });
    }
  }
  command_1() {
    if (this.args.grinding) {
      return;
    }
    if (this.trickTimer > 10) {
      return;
    }
    this.args.trick = 'insult';
    this.trickTimer = 30;
  }
  hold_1() {
    if (this.trickTimer > 10 || this.args.trick !== 'insult') {
      return;
    }
    this.trickTimer = Math.max(15, this.trickTimer);
    this.idleTime = 10;
  }
  release_1() {
    if (this.args.trick !== 'insult') {
      return;
    }
    this.args.trick = 'insult';
    this.trickTimer = 10;
  }
  command_2() {
    if (this.trickTimer > 10) {
      return;
    }
    this.args.trick = 'handstand';
    this.trickTimer = 30;
  }
  hold_2() {
    if (this.trickTimer > 10 || this.args.trick !== 'handstand') {
      return;
    }
    this.args.trick = 'handstand';
    this.trickTimer = Math.max(15, this.trickTimer);
    this.idleTime = 10;
  }
  release_2() {
    if (this.args.trick !== 'handstand') {
      return;
    }
    this.trickTimer = 10;
  }
  command_3() {
    if (this.args.grinding) {
      return;
    }
    if (this.args.trick && this.args.falling && this.args.trick !== 'manual') {
      return;
    }
    if (this.trickTimer > 10) {
      return;
    }
    this.args.trick = 'manual';
    this.trickTimer = 30;
  }
  hold_3() {
    if (this.args.falling && this.args.trick === 'manual') {
      this.trickTimer = Math.max(15, this.trickTimer);
      return;
    }
    if (this.args.falling || this.args.trick !== 'manual') {
      return;
    }
    if (this.trickTimer > 10 && this.args.trick !== 'manual') {
      return;
    }
    this.args.trick = 'manual';
    this.trickTimer = Math.max(15, this.trickTimer);
    this.idleTime = 10;
  }
  release_3() {
    if (this.args.trick !== 'manual') {
      return;
    }
    this.args.trick = 'manual';
    this.trickTimer = 10;
  }
}
exports.SkateBoard = SkateBoard;
});

;require.register("actor/Skorp.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Skorp = void 0;
var _Tag = require("curvature/base/Tag");
var _Flickie = require("./Flickie");
var _Mixin = require("curvature/base/Mixin");
var _PointActor = require("./PointActor");
var _Patrol = require("../behavior/Patrol");
var _CanPop = require("../mixin/CanPop");
var _Projectile = require("../actor/Projectile");
var _Sfx = require("../audio/Sfx");
class Skorp extends _Mixin.Mixin.from(_PointActor.PointActor, _CanPop.CanPop) {
  constructor() {
    var _this$args$color, _this$args$patrolPaus, _this$args$patrolBeat, _this$args$patrolSpee;
    super(...arguments);
    this.behaviors.add(new _Patrol.Patrol());
    this.args.type = 'actor-item actor-skorp';
    this.args.animation = 'standing';
    this.args.accel = 0.1;
    this.args.decel = 0.5;
    this.args.gSpeedMax = 5;
    this.args.jumpForce = 5;
    this.args.gravity = 0.5;
    this.args.width = 24;
    this.args.height = 32;
    this.args.color = (_this$args$color = this.args.color) !== null && _this$args$color !== void 0 ? _this$args$color : 'green';
    this.willStick = false;
    this.stayStuck = false;
    this.args.patrolPause = (_this$args$patrolPaus = this.args.patrolPause) !== null && _this$args$patrolPaus !== void 0 ? _this$args$patrolPaus : 20;
    this.args.patrolBeat = (_this$args$patrolBeat = this.args.patrolBeat) !== null && _this$args$patrolBeat !== void 0 ? _this$args$patrolBeat : 120;
    this.args.patrolSpeed = (_this$args$patrolSpee = this.args.patrolSpeed) !== null && _this$args$patrolSpee !== void 0 ? _this$args$patrolSpee : 1;
    this.args.segmentCount = 5;
    this.args.segmentAngle = Math.PI / 2;
    this.aggroCount = 0;
    this.coolDown = 0;
    this.args.shooting = 0;
  }
  onRendered() {
    super.onRendered();
    this.autoAttr.get(this.box)['data-color'] = 'color';
    this.autoAttr.get(this.box)['data-shooting'] = 'shooting';
    this.autoAttr.get(this.box)['data-aiming'] = 'aimDirection';
    this.autoStyle.get(this.box)['--segments'] = 'segmentCount';
    this.autoStyle.get(this.box)['--segmentAngle'] = 'segmentAngle';
    this.autoStyle.get(this.box)['--aim-direction'] = 'aimDirection';
    this.autoStyle.get(this.box)['--tail-angle'] = 'tailAngle';
    if (!this.tail) {
      this.tail = new _Tag.Tag(`<div class = "tail">`);
      const segments = [new _Tag.Tag(`<div   class = "segment" style = "--index:0">`), new _Tag.Tag(`<div class = "segment" style = "--index:1">`), new _Tag.Tag(`<div class = "segment" style = "--index:2">`), new _Tag.Tag(`<div class = "segment" style = "--index:3">`), new _Tag.Tag(`<div class = "segment" style = "--index:4">`), new _Tag.Tag(`<div class = "end gun" style = "--index:5">`)];
      let lastSegment;
      for (const segment of segments) {
        if (!lastSegment) {
          this.tail.append(segment.node);
        } else {
          lastSegment.append(segment.node);
        }
        lastSegment = segment;
      }
      this.box.appendChild(this.tail.node);
    }
  }
  update() {
    const direction = this.args.direction;
    const telegraph = this.args.shotTelegraph;
    const beat = this.args.patrolBeat;
    if (this.box) {
      if (this.args.moving && this.args.gSpeed) {
        this.box.setAttribute('data-animation', 'walking');
      } else {
        this.box.setAttribute('data-animation', 'standing');
      }
    }
    const maxDist = 256;
    const leftDist = this.castRayQuick(maxDist, Math.PI, [0, -16], false) || maxDist;
    const rightDist = this.castRayQuick(maxDist, 0, [0, -16], false) || maxDist;
    const leftActors = this.viewport.actorsAtLine(this.x, this.y - 16, this.x - leftDist, this.y + -16);
    const rightActors = this.viewport.actorsAtLine(this.x, this.y - 16, this.x + rightDist, this.y + -16);
    const leftFiltered = [...leftActors.keys()].filter(a => a.controllable);
    const rightFiltered = [...rightActors.keys()].filter(a => a.controllable);
    if (leftFiltered.length) {
      this.args.aimDirection = -1;
    } else if (rightFiltered.length) {
      this.args.aimDirection = 1;
    } else {
      this.args.aimDirection = 0;
    }
    if (this.args.aimDirection) {
      if (this.args.aimDirection !== this.args.direction) {
        this.args.tailAngle = -19 * this.args.aimDirection;
      } else {
        this.args.tailAngle = -21 * this.args.aimDirection;
      }
      this.coolDown = 30;
      this.aggroCount++;
    } else {
      if (this.coolDown <= 0) {
        this.args.tailAngle = -8 * this.args.direction;
        if (!this.args.gSpeed) {
          this.args.tailAngle = 0;
        }
      } else {
        this.coolDown--;
      }
      this.aggroCount = 0;
    }
    if (this.aggroCount > 20) {
      if (this.args.aimDirection !== this.args.direction) {
        const ball = new _Projectile.Projectile({
          x: this.args.x + 60 * this.args.aimDirection,
          y: this.args.y - 28,
          xSpeed: 4 * this.args.aimDirection,
          ySpeed: 0.55,
          float: -1,
          owner: this
        });
        this.viewport.spawn.add({
          object: ball
        });
        this.aggroCount = 10;
        this.args.shooting = 6;
        _Sfx.Sfx.play('SHOT_FIRED');
      } else {
        const ball = new _Projectile.Projectile({
          x: this.args.x + 54 * this.args.aimDirection,
          y: this.args.y - 42,
          xSpeed: 4 * this.args.aimDirection,
          ySpeed: 0.55,
          float: -1,
          owner: this
        });
        this.viewport.spawn.add({
          object: ball
        });
        this.aggroCount = 10;
        this.args.shooting = 6;
        _Sfx.Sfx.play('SHOT_FIRED');
      }
    } else if (this.args.shooting > 0) {
      this.args.shooting--;
    }
    super.update();
    this.args.direction = Math.sign(this.args.gSpeed) || this.args.direction;
  }
  effect(other) {
    super.effect(other);

    // this.viewport.spawn.add({object:new Flickie({
    // 	x: this.args.x,
    // 	y: this.args.y,
    // })});
  }

  get solid() {
    return false;
  }
  get isEffect() {
    return false;
  }
  // get controllable() { return true; }
}
exports.Skorp = Skorp;
});

;require.register("actor/Skull.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Skull = void 0;
var _PointActor = require("./PointActor");
class Skull extends _PointActor.PointActor {
  constructor() {
    super(...arguments);
    this.args.width = 17;
    this.args.height = 15;
    this.args.type = 'actor-item actor-skull';
    this.bindTo('carriedBy', carrier => {
      if (this.cX) {
        this.cX();
        this.cX = null;
      }
      if (this.cY) {
        this.cY();
        this.cY = null;
      }
      if (carrier) {
        this.cX = carrier.args.bindTo('x', v => this.args.x = v + carrier.args.direction * 8);
        this.cY = carrier.args.bindTo('y', v => this.args.y = v + -16);
        carrier.carrying.add(this);
        this.args.float = -1;
      } else if (this.carriedBy) {
        const carrier = this.carriedBy;
        this.carriedBy = null;
        this.args.xSpeed = carrier.args.xSpeed;
        this.args.ySpeed = carrier.args.ySpeed;
        this.args.xSpeed += Math.sign(carrier.args.gSpeed || carrier.args.xSpeed) * 4;
        this.args.ySpeed -= 4;
        carrier.carrying.delete(this);
        this.args.falling = true;
        this.args.float = 0;
      }
    });
  }
  lift(actor) {
    if (this.carriedBy === actor) {
      this.carriedBy = null;
      return;
    }
    this.carriedBy = actor;
  }
  get solid() {
    return false;
  }
}
exports.Skull = Skull;
});

;require.register("actor/SlotMachine.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SlotMachine = void 0;
var _Tag = require("curvature/base/Tag");
var _Sfx = require("../audio/Sfx");
var _PointActor = require("./PointActor");
var _Ring = require("./Ring");
var _AntiRing = require("./AntiRing");
class SlotMachine extends _PointActor.PointActor {
  constructor() {
    super(...arguments);
    this.args.width = 96;
    this.args.height = 32;
    this.args.type = 'actor-item actor-slot-machine';
    this.args.float = -1;
  }
  onRendered(event) {
    super.onRendered(event);
    if (!this.boxes) {
      this.boxes = [new _Tag.Tag(`<div class = "slot-panel slot-panel-a">`), new _Tag.Tag(`<div class = "slot-panel slot-panel-b">`), new _Tag.Tag(`<div class = "slot-panel slot-panel-c">`)];
      this.boxes.forEach(box => this.box.appendChild(box.node));
    }
  }
  dropDelay(other) {
    if (!other.controllable) {
      return;
    }
    this.args.type = 'actor-item actor-slot-machine actor-slot-machine-rolling';
    const pos = Symbol;
    const hand = Array(8).fill(0);
    const result = this.boxes.map(box => {
      box[pos] = box[pos] || 0;
      const scrollTo = 32 + box[pos] + Math.floor(Math.random() * 8);
      box.style({
        '--scrollTo': scrollTo * 32 + 'px'
      });
      box[pos] = scrollTo;
      return box[pos] % 8;
    });
    result.forEach(v => hand[v]++);
    return new Promise(accept => {
      this.viewport.onFrameOut(85, () => {
        this.args.type = 'actor-item actor-slot-machine';
        if (hand[0] === 1) {
          this.onTimeout(30, () => _Sfx.Sfx.play('FAIL'));
          if (other.args.rings > 50) {
            return this.punish(other, 10).then(accept);
          }
          return accept();
        } else if (hand[0] === 2) {
          return this.punish(other, 50).then(accept);
          return accept();
        } else if (hand[0] === 3) {
          if (other.args.rings > 0) {
            other.args.rings = 0;
          } else {
            return this.punish(other, 100).then(accept);
          }
          return accept();
        } else if (hand[5] === 2) {
          return this.reward(other, 25).then(accept);
        } else if (hand[5] === 3) {
          return this.reward(other, 100).then(accept);
        } else if (hand[6] === 2) {
          return this.reward(other, 50).then(accept);
        } else if (hand[6] === 3) {
          return this.reward(other, 75).then(accept);
        } else if (hand[7] === 2) {
          return this.reward(other, 15).then(accept);
        } else if (hand[7] === 3) {
          return this.reward(other, 20).then(accept);
        } else if (hand[2] === 3 || hand[3] === 3 || hand[4] === 3) {
          return this.reward(other, 50).then(accept);
        } else if (hand[1] === 1) {
          return this.reward(other, 2).then(accept);
        } else if (hand[1] === 2) {
          return this.reward(other, 30).then(accept);
        } else if (hand[1] === 3) {
          return this.reward(other, 60).then(accept);
        }
        accept();
      });
    });
  }
  reward(other) {
    let amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;
    const viewport = this.viewport;
    let angle = -1.57;
    for (let i = 0; i < amount; i++) {
      const cos = Math.cos(angle);
      const sin = Math.sin(angle);
      const ring = new _Ring.Ring({
        x: other.x + cos * 288,
        y: other.y + sin * 288,
        xSpeed: -cos * 7,
        ySpeed: -sin * 7,
        static: false,
        reward: true,
        noClip: true,
        float: -1
      });
      ring.noClip = true;
      viewport.spawn.add({
        object: ring,
        frame: i * 3 + viewport.args.frameId
      });
      angle += Math.PI + (i % 2 ? 0.3 : 0);
    }
    return new Promise(accept => viewport.onFrameOut((16 + amount) * 3, () => accept()));
  }
  punish(other, amount) {
    _Sfx.Sfx.play('FAIL');
    const viewport = this.viewport;
    let angle = -1.57;
    for (let i = 0; i < amount; i++) {
      const cos = Math.cos(angle);
      const sin = Math.sin(angle);
      const ring = new _AntiRing.AntiRing({
        x: other.x + cos * 288,
        y: other.y + sin * 288,
        xSpeed: -cos * 7,
        ySpeed: -sin * 7,
        static: false,
        reward: true,
        noClip: true,
        float: -1
      });
      viewport.spawn.add({
        object: ring,
        frame: i * 3 + viewport.args.frameId
      });
      angle -= Math.PI + (i % 2 ? 0.3 : 0);
    }
    return new Promise(accept => viewport.onFrameOut((16 + amount) * 3, () => accept()));
  }
  get solid() {
    return false;
  }
}

/*
0 - robotnik
1 - ring
2 - tails
3 - knuckles
4 - sonic
5 - jackpot
6 - emerald
7 - bar
*/
exports.SlotMachine = SlotMachine;
});

;require.register("actor/SnailBot.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SnailBot = void 0;
var _Mixin = require("curvature/base/Mixin");
var _PointActor = require("./PointActor");
var _Patrol = require("../behavior/Patrol");
var _CanPop = require("../mixin/CanPop");
class SnailBot extends _Mixin.Mixin.from(_PointActor.PointActor, _CanPop.CanPop) {
  constructor() {
    var _this$args$patrolPaus, _this$args$patrolBeat, _this$args$patrolSpee;
    super(...arguments);
    this.behaviors.add(new _Patrol.Patrol());
    this.args.type = 'actor-item actor-snailbot';
    this.args.animation = 'standing';
    this.args.accel = 0.1;
    this.args.decel = 0.5;
    this.args.gSpeedMax = 5;
    this.args.gravity = 0.5;
    this.args.width = 24;
    this.args.height = 32;
    this.willStick = false;
    this.stayStuck = false;
    this.args.patrolPause = (_this$args$patrolPaus = this.args.patrolPause) !== null && _this$args$patrolPaus !== void 0 ? _this$args$patrolPaus : 20;
    this.args.patrolBeat = (_this$args$patrolBeat = this.args.patrolBeat) !== null && _this$args$patrolBeat !== void 0 ? _this$args$patrolBeat : 100;
    this.args.patrolSpeed = (_this$args$patrolSpee = this.args.patrolSpeed) !== null && _this$args$patrolSpee !== void 0 ? _this$args$patrolSpee : 1;
  }
  update() {
    super.update();
    if (this.args.moving && this.args.gSpeed) {
      this.args.animation = 'walking';
    } else {
      this.args.animation = 'standing';
    }
    this.args.direction = Math.sign(this.args.gSpeed);
  }
  get solid() {
    return false;
  }
  get isEffect() {
    return false;
  }
}
exports.SnailBot = SnailBot;
});

;require.register("actor/SnowBoard.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SnowBoard = void 0;
var _Vehicle = require("./Vehicle");
var _Tag = require("curvature/base/Tag");
var _SkidDust = require("../behavior/SkidDust");
class SnowBoard extends _Vehicle.Vehicle {
  constructor() {
    super(...arguments);
    this.behaviors.add(new _SkidDust.SkidDust('particle-dust'));
    this.args.type = 'actor-item actor-snow-board';
    this.args.width = 24;
    this.args.height = 32;
    this.removeTimer = null;
    this.args.gSpeedMax = 15;
    this.args.decel = 0.25;
    this.args.accel = 0.75;
    this.args.gravity = 0.75;
    // this.args.ignore    = -1;

    this.args.seatHeight = 1;
    this.args.skidTraction = 0.5;
    this.args.jumpForce = 9.5;
    this.dustCount = 0;
    this.args.particleScale = 2;
    this.args.started = false;
    this.ridingAnimation = 'grinding';
    // this.alwaysSkidding  = true;
    this.dustDist = -16;
    this.dustFreq = 1;
    this.broad = true;
    this.slowSpin = true;
    this.addEventListener('jump', event => {
      this.args.groundAngle += Math.PI * 0.125 * Math.sign(this.args.gSpeed || this.args.direction);
    });
  }
  update() {
    this.originalSpeed = this.args.gSpeed || this.args.xSpeed;
    super.update();
    if (this.occupant) {
      this.args.z = this.occupant.args.z - 1;
    }
    if (this.args.gSpeed !== 0 || this.args.xSpeed !== 0) {
      this.sprite.classList.add('moving');
      this.args.started = true;
    }
  }
  get solid() {
    return !this.occupant;
  }
}
exports.SnowBoard = SnowBoard;
});

;require.register("actor/Sonic.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Sonic = void 0;
var _PointActor = require("./PointActor");
var _Platformer = require("../behavior/Platformer");
var _Sfx = require("../audio/Sfx");
var _Tag = require("curvature/base/Tag");
var _View = require("curvature/base/View");
var _Twist = require("../effects/Twist");
var _Pinch = require("../effects/Pinch");
var _Png = require("../sprite/Png");
var _Ring = require("./Ring");
var _Spring = require("./Spring");
var _FireSheild = require("../powerups/FireSheild");
var _BubbleSheild = require("../powerups/BubbleSheild");
var _ElectricSheild = require("../powerups/ElectricSheild");
var _GrindingRegion = require("../region/GrindingRegion");
var _Marker = require("./Marker");
var _SkidDust = require("../behavior/SkidDust");
var _SuperForm = require("../behavior/SuperForm");
var _EmeraldHalo = require("../behavior/EmeraldHalo");
var _Color = require("../lib/Color");
var _Router = require("curvature/base/Router");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
const MODE_FLOOR = 0;
const MODE_LEFT = 1;
const MODE_CEILING = 2;
const MODE_RIGHT = 3;
class Sonic extends _PointActor.PointActor {
  constructor() {
    super(...arguments);
    _defineProperty(this, "png", new _Png.Png('/Sonic/sonic.png'));
    window.sonic = this;
    this.behaviors.add(new _SkidDust.SkidDust());
    this.behaviors.add(new _SuperForm.SuperForm());
    this.behaviors.add(new _EmeraldHalo.EmeraldHalo());
    this.args.canonical = 'Sonic';
    this.args.type = 'actor-sonic actor-item';
    this.accelNormal = 0.12;
    this.accelSuper = 0.24;
    this.markers = new Set();
    this.springing = false;
    this.args.boltCount = 0;
    this.args.accel = this.accelNormal;
    this.args.decel = 0.40;
    this.gSpeedMaxNormal = 18;
    this.gSpeedMaxSuper = 20;
    this.gSpeedMaxHyper = 23;
    this.jumpForceNormal = 11;
    this.jumpForceSuper = 13;
    this.jumpForceHyper = 15;
    this.args.gSpeedMax = this.gSpeedMaxNormal;
    this.args.jumpForce = this.jumpForceNormal;
    this.args.gravity = 0.5;
    this.args.width = 16;
    this.args.height = 40;
    this.args.normalHeight = 40;
    this.args.rollingHeight = 28;
    this.sparks = new Set();
    this.spindashCharge = 0;
    this.dropDashCharge = 0;
    this.willStick = false;
    this.stayStuck = false;
    this.lightDashed = true;
    this.dashed = false;
    this.airControlCard = _View.View.from(require('../cards/sonic-air-controls.html'));
    this.controlCard = _View.View.from(require('../cards/sonic-controls.html'));
    this.moveCard = _View.View.from(require('../cards/basic-moves.html'));
    this.args.spriteSheet = this.spriteSheet = '/Sonic/sonic.png';
    this.hyperSheet = 0;
    this.costumes = {
      Santiago: {
        h: -30,
        s: 1.5,
        v: 1.25
      },
      Sequel: {
        h: -10,
        s: 1.5,
        v: 1.25
      },
      White: {
        h: 0,
        s: 0,
        v: 1.25
      },
      RedHot: {
        h: 115,
        s: 1.75,
        v: 1.00
      },
      Brown: {
        h: 125,
        s: 1.15,
        v: 0.50
      }
    };
    this.args.bindTo('falling', v => {
      if (v) {
        return;
      }
      if (this.willStick && (this.args.mode === 1 || this.args.mode === 3)) {
        this.args.wallSticking = true;
        this.onNextFrame(() => {
          this.dashed = false;
        });
      } else {
        this.onNextFrame(() => {
          this.args.wallSticking = false;
        });
      }
    });
    this.transformTime = 0;
    this.args.minRingsSuper = 50;
    this.args.minRingsHyper = 75;
  }
  shiftColor(color, h, s, v) {
    const c = new _Color.Color(color);
    return c.rotate(h, s, v);
  }
  onRendered(event) {
    super.onRendered(event);
    const superColors = {
      '8080e0': 'e0e080',
      '6060c0': 'e0e000',
      '4040a0': 'e0e001',
      '202080': 'a0a000'
    };
    const hyperColorsRed = {
      '8080e0': 'fcfcfc',
      '6060c0': 'fcfcfc',
      '4040a0': 'fcd8d8',
      '202080': 'fcb4b4'
    };
    const hyperColorsPurple = {
      '8080e0': 'fcfcfc',
      '6060c0': 'fcfcfc',
      '4040a0': 'fcd8fc',
      '202080': 'd8b4d8'
    };
    const hyperColorsCyan = {
      '8080e0': 'd8fcfc',
      '6060c0': 'fcfcfc',
      '4040a0': 'b4d8fc',
      '202080': '90b4fc'
    };
    const hyperColorsBlue = {
      '8080e0': 'd8d8ff',
      '6060c0': 'b4b4d8',
      '4040a0': 'a4a4d8',
      '202080': '6c6cb4'
    };
    const hyperColorsGreen = {
      '8080e0': 'd8fcfc',
      '6060c0': 'd8fcd8',
      '4040a0': 'b4fcb4',
      '202080': '00fc24'
    };
    const hyperColorsYellow = {
      '8080e0': 'd8fcfc',
      '6060c0': 'd8fcb4',
      '4040a0': 'd8fc48',
      '202080': 'd8d800'
    };
    const hyperColorsWhite = {
      '8080e0': 'ffffff',
      '6060c0': 'fcfcfc',
      '4040a0': 'd8d8d8',
      '202080': 'b4b4b4'
    };

    // const rH = 180;
    // const rS = 1;
    // const rV = 1;

    // const rH2 = 0;
    // const rS2 = 1;
    // const rV2 = 1;

    this.rotatedSpriteSheet = this.spriteSheet;
    const updateSprite = () => {
      var _this$viewport$custom, _this$viewport$custom2, _this$viewport$custom3;
      let h = Number((_this$viewport$custom = this.viewport.customColor.h) !== null && _this$viewport$custom !== void 0 ? _this$viewport$custom : 0);
      let s = Number((_this$viewport$custom2 = this.viewport.customColor.s) !== null && _this$viewport$custom2 !== void 0 ? _this$viewport$custom2 : 1);
      let v = Number((_this$viewport$custom3 = this.viewport.customColor.v) !== null && _this$viewport$custom3 !== void 0 ? _this$viewport$custom3 : 1);
      this.rotateMainColor(h, s, v);

      // this.args.spriteSheet = this.args.rotatedSpriteSheet;

      this.box.node.style.setProperty('--sprite-sheet', `url(${this.args.rotatedSpriteSheet})`);
    };
    const debindH = this.viewport.customColor.bindTo('h', updateSprite, {
      wait: 0
    });
    const debindS = this.viewport.customColor.bindTo('s', updateSprite, {
      wait: 0
    });
    const debindV = this.viewport.customColor.bindTo('v', updateSprite, {
      wait: 0
    });
    this.onRemove(debindH);
    this.onRemove(debindS);
    this.onRemove(debindV);
    if (this.viewport.args.networked) {
      if (this.args.netplayer) {
        const costume = 'Santiago';
        Object.assign(this.viewport.customColor, this.costumes[costume]);
      } else {
        const costume = 'Sequel';
        Object.assign(this.viewport.customColor, this.costumes[costume]);
      }
    } else if (this.viewport.args.mainPallet && this.costumes[this.viewport.args.mainPallet]) {
      Object.assign(this.viewport.customColor, this.costumes[this.viewport.args.mainPallet]);
    }
    if (!this.superSpriteSheetLoader) {
      this.superSpriteSheetLoader = this.png.ready.then(() => {
        const newPng = this.png.recolor(superColors);
        this.superSpriteSheet = newPng.toUrl();
      });
    }
    if (!this.hyperSpriteSheetLoader) {
      this.hyperSpriteSheetLoader = this.png.ready.then(() => this.hyperSpriteSheets = [this.png.recolor(hyperColorsRed).toUrl(), this.png.recolor(hyperColorsCyan).toUrl(), this.png.recolor(hyperColorsPurple).toUrl(), this.png.recolor(hyperColorsWhite).toUrl(), this.png.recolor(hyperColorsGreen).toUrl(), this.png.recolor(hyperColorsBlue).toUrl(), this.png.recolor(hyperColorsYellow).toUrl()]);
    }
    if (!this.arm) {
      this.arm = new _Tag.Tag(`<div class = "rear-arm">`);
      this.box.appendChild(this.arm.node);
    }
    if (!this.swoosh) {
      this.swoosh = new _Tag.Tag(`<div class = "double-spin">`);
      this.box.appendChild(this.swoosh.node);
    }
    this.autoAttr.get(this.box)['data-doublespin'] = 'doubleSpin';
  }
  updateStart() {
    if (this.args.grinding && this.args.falling && this.args.ySpeed > 0) {
      this.args.animation = 'airdash';
      this.args.grinding = false;
    }
    super.updateStart();
    if (this.args.dead) {
      this.args.animation = 'dead';
      return;
    }
  }
  updateEnd() {
    // if(this.args.animation === 'transform')
    // {
    // 	this.transformTime++;
    // }
    // else if(this.transformTime > 0)
    // {
    // 	this.transformTime = 0;
    // }

    if (!this.args.falling && this.pinchFilterBg) {
      this.pinch(0, 0);
    }
    super.updateEnd();
  }
  update() {
    if (this.args.falling && this.isHyper && this.dashed && this.yAxis < -0.5) {
      this.args.ySpeed -= 0.6;
    }
    if (!this.args.falling && this.groundTime > 3 || this.args.falling && this.fallTime > 90) {
      this.args.trickRamp = false;
      this.args.twistRamp = false;
    }
    if (this.args.dead) {
      this.args.animation = 'dead';
      super.update();
      return;
    }
    if (this.isSuper) {
      const tick = this.isHyper ? 30 : 60;
      if (this.viewport.args.frameId % tick === 0) {
        if (this.args.rings < 2) {
          this.isHyper = false;
          this.setProfile();
        }
        if (this.args.rings > 0) {
          this.args.rings--;
        } else {
          this.isSuper = false;
          this.isHyper = false;
          this.setProfile();
        }
      }
    }
    this.args.isSuper = this.isSuper;
    this.args.isHyper = this.isHyper;
    if (this.isHyper) {
      if (this.viewport.args.frameId % 45 === 0) {
        this.args.spriteSheet = this.hyperSpriteSheets[this.hyperSheet++];
        if (this.hyperSheet >= this.hyperSpriteSheets.length) {
          this.hyperSheet = 0;
        }
      }
    }
    if (this.args.falling) {
      if (this.args.wallSticking && !this.dashed) {
        if (this.args.mode === 1) {
          this.args.direction = -1;
          this.args.facing = 'left';
        } else if (this.args.mode === 3) {
          this.args.direction = 1;
          this.args.facing = 'right';
        }
        this.args.animation = 'wall-dropping-start';
        this.onTimeout(150, () => {
          if (this.args.falling && this.args.wallDropping) {
            this.args.animation = 'wall-dropping';
          }
        });
        this.args.wallDropping = true;
        this.args.groundAngle = 0;
        this.args.ignore = 30;
      }
      if (this.args.wallDropping) {
        this.args.groundAngle = 0;
      }
      if (this.args.animation === 'hanging' && this.args.ySpeed > -3) {
        this.args.animation = 'wall-dropping';
      }
      this.args.wallSticking = false;
    } else {
      this.args.wallDropping = false;
      this.swing = false;
      if (this.springing) {
        this.args.groundAngle = 0;
      }
      this.springing = false;
      this.args.doubleSpin = this.dashed = false;
      if (this.args.mode % 2 === 0) {
        this.args.wallSticking = false;
      }
      if (!this.args.wallSticking) {
        this.willStick = false;
      }

      // this.pincherBg.args.scale = 0;
    }

    if (this.lightDashingCoolDown > 0) {
      this.lightDashingCoolDown--;
    }
    if (this.dashTimer > 0) {
      this.dashTimer--;
    }
    const falling = this.args.falling;
    if (falling) {
      this.args.cameraBias = 0;
    }
    if (this.args.wallSticking) {
      this.args.animation = 'wall-stick';
      let slip = 3;
      if (this.yAxis < 0) {
        this.args.animation = 'wall-stick-brake';
        this.stayStuck = true;
        slip = 0;
      } else if (this.yAxis > 0) {
        slip = 6;
      }
      if (this.args.modeTime < 15) {
        slip = 0;
      }
      if (this.args.mode === 1) {
        this.args.facing = 'left';
        this.args.direction = 1;
        if (Math.abs(this.args.gSpeed) < slip) {
          this.args.gSpeed += 1;
        } else {
          this.args.gSpeed = slip;
        }
      } else if (this.args.mode === 3) {
        this.args.facing = 'right';
        this.args.direction = -1;
        if (Math.abs(this.args.gSpeed) < slip) {
          this.args.gSpeed -= 1;
        } else {
          this.args.gSpeed = -slip;
        }
      }
      const radius = Math.ceil(this.args.width / 2);
      const direction = Math.sign(this.args.gSpeed);
      const headPoint = this.rotatePoint(radius * -direction, this.args.height);
      if (this.getMapSolidAt(this.x + headPoint[0], this.y + headPoint[1])) {
        this.bMap('doJump', 0);
      }
    } else if (this.lightDashing) {
      const direction = Math.sign(this.args.xSpeed) || Math.sign(this.args.gSpeed);
      if (direction < 0) {
        this.args.animation = 'lightdash-back';
      } else if (direction > 0) {
        this.args.animation = 'lightdash';
      }
      if (falling) {
        this.args.direction = Math.sign(this.args.xSpeed) || this.args.direction;
        this.args.mode = MODE_FLOOR;
      }
    } else if (!falling) {
      const maxSpeedNormal = this.gSpeedMaxNormal / (this.isSuper ? 2 : 1);
      const friction = this.getLocalFriction();
      const direction = this.args.direction;
      const gSpeed = this.args.gSpeed;
      const speed = Math.abs(gSpeed) / friction ** 2;
      const maxSpeed = this.args.gSpeedMax;
      this.dashed = false;
      this.lightDashed = false;
      this.lightDashReward = null;
      this.args.height = this.args.normalHeight;
      if (this.spindashCharge) {
        if (this.spindashCharge < 1) {
          this.spindashCharge = 0;
        } else {
          this.args.animation = 'spindash';
          this.spindashCharge -= 0.2;
          if (this.dashDust) {
            this.dashDust.style({
              '--dashCharge': this.spindashCharge
            });
          }
          let dashCharge = this.spindashCharge / 20;
          if (dashCharge > 1) {
            dashCharge = 1;
          }
          this.twist(120 * dashCharge * this.args.direction);
        }
      } else if (!this.args.rolling) {
        this.args.crouching = false;
        if (friction > 0.5 && Math.sign(direction) && Math.sign(gSpeed) && Math.sign(gSpeed) !== Math.sign(direction) && !this.args.antiSkid) {
          this.args.animation = 'skidding';
        } else if (this.args.moving && speed > maxSpeedNormal * 0.75) {
          if (this.xAxis || friction >= 0.5) {
            if (this.isSuper && this.args.moving && speed > maxSpeedNormal * 1.85) {
              this.args.animation = 'super-run';
            } else if (this.args.moving && speed > maxSpeedNormal * 2.25) {
              this.args.animation = 'running-4';
            } else if (this.args.moving && speed > maxSpeedNormal * 1.75) {
              this.args.animation = 'running-3';
            } else if (this.args.moving && speed > maxSpeedNormal * 1.25) {
              this.args.animation = 'running-2';
            } else {
              this.args.animation = 'running';
            }
          } else if (Math.abs(this.args.gSpeed) > 3.5) {
            this.args.animation = 'sliding';
          } else {
            this.args.animation = 'standing';
          }
        } else if (this.args.moving && this.args.gSpeed) {
          if (this.xAxis || friction > 0.5) {
            this.args.animation = 'walking';
          } else if (Math.abs(this.args.gSpeed) > 3.5) {
            this.args.animation = 'sliding';
          } else {
            this.args.animation = 'standing';
          }
        } else if (this.xAxis && friction === 0) {
          this.args.animation = 'running';
          this.args.facing = this.xAxis === -1 ? 'left' : 'right';
        } else if (this.args.moving && this.args.gSpeed) {
          this.args.pushing = Math.sign(this.args.gSpeed);
        } else {
          if (this.yAxis > 0.5 && !this.args.ignore && !this.carrying.size && !this.spindashCharge) {
            this.args.animation = 'crouching';
            this.args.crouching = true;
            this.args.lookTime--;
            if (this.args.lookTime < -45) {
              this.args.cameraBias = -0.5;
            }
          } else if (this.yAxis && this.yAxis < -0.5 && !this.args.ignore) {
            this.args.animation = 'looking-up';
            this.args.lookTime++;
            if (this.args.lookTime > 45) {
              this.args.cameraBias = 0.25;
            }
          } else {
            const fieldType = this.viewport.meta['fieldType'];
            if (this.args.teeter) {
              this.args.animation = 'teeter';
              if (this.args.teeter === -1) {
                this.args.animation = 'teeter--1';
              }
              if (this.args.teeter === 2) {
                this.args.animation = 'teeter-2';
              }
            } else if (fieldType === 'garden' || fieldType === 'adventure') {
              this.args.animation = 'standing';
            } else if (this.idleTime > 60 * 300) {
              this.args.animation = 'idle-3';
            } else if (this.idleTime > 250) {
              this.args.animation = 'idle-2';
            } else if (this.idleTime > 200) {
              this.args.animation = 'idle';
            } else {
              this.args.animation = 'standing';
            }
            this.args.cameraBias = 0;
            this.args.lookTime = 0;
          }
        }
      }
      if (!this.spindashCharge && this.dashDust) {
        this.dashDust.remove();
        this.dashDust = null;
      }
      if (this.dropDashCharge) {
        this.args.animation = 'spindash';
        this.args.rolling = true;
      }
    } else if (!this.dashed) {
      this.args.height = this.args.rollingHeight;
      if (this.args.jumping) {
        this.args.animation = 'jumping';
      } else if (!this.args.xSpeed && !this.args.ySpeed) {
        // this.box.setAttribute('data-animation', 'airdash');
      }
    } else if (falling && !this.args.jumping && this.isSuper && this.args.ySpeed > 0) {
      this.args.animation = 'dropping';
      this.onTimeout(150, () => {
        if (this.args.falling) {
          this.args.animation = 'dropping';
        }
      });
    }
    if (falling && this.args.animation === 'standing') {
      this.args.animation = 'walking';
    }
    if (this.args.animation === 'skidding' && this.fallTime > 16) {
      if (Math.abs(this.args.groundAngle) > Math.PI / 2) {
        this.args.animation = 'walking';
      } else {
        this.args.animation = 'skidding-falling';
      }
    }
    if (this.args.hangingFrom) {
      this.args.animation = 'hanging';
    } else if (this.swing) {
      this.args.animation = 'jumping';
    }
    if (this.args.rolling) {
      if (this.args.animation !== 'spindash') {
        this.args.animation = 'rolling';
      } else {
        this.viewport.onFrameOut(14, () => this.args.animation = 'rolling');
        this.args.animation = 'spindash';
      }
    }
    if (this.skidding && !this.args.rolling && !this.args.falling && !this.spindashCharge) {
      this.args.xOff = 8 * -this.args.direction;
      this.args.yOff = 32;
      let warp = -this.args.gSpeed * 22;
      if (Math.abs(warp) > 256) {
        warp = 256 * Math.sign(warp);
      }
      this.twist(warp);
    } else if (!this.spindashCharge) {
      this.twister && (this.twister.args.scale = 0);
    }
    if (this.args.standingOn && this.args.standingOn.isVehicle) {
      this.args.animation = this.args.standingOn.ridingAnimation || 'standing';
    }
    if (this.viewport.args.frameId % 2 === 0) if (this.viewport.args.frameId % this.viewport.settings.frameSkip === 0) {
      if (this.args.grinding && !this.args.falling) {
        // `<div class = "particle-sparks">`

        const sparkTag = document.createElement('div');
        sparkTag.classList.add('particle-sparks');
        const sparkParticle = new _Tag.Tag(sparkTag);

        // `<div class = "envelope-sparks">`
        const envelopeTag = document.createElement('div');
        envelopeTag.classList.add('envelope-sparks');
        const sparkEnvelope = new _Tag.Tag(envelopeTag);
        sparkEnvelope.appendChild(sparkParticle.node);
        const sparkPoint = this.rotatePoint(-this.args.gSpeed * 1.75 * this.args.direction, 8);
        const flip = Math.sign(this.args.gSpeed);
        sparkEnvelope.style({
          '--x': sparkPoint[0] + this.args.x,
          '--y': sparkPoint[1] + this.args.y + Math.random() * -3,
          'z-index': 0,
          'animation-delay': -Math.random() * 0.25 + 's',
          '--xMomentum': Math.max(Math.abs(this.args.gSpeed), 4) * flip,
          '--flip': flip,
          '--angle': this.realAngle,
          opacity: Math.random() * 2
        });
        sparkEnvelope.particle = sparkParticle;
        this.viewport.particles.add(sparkEnvelope);
        this.sparks.add(sparkEnvelope);
        const viewport = this.viewport;
        this.viewport.onFrameOut(30, () => {
          viewport.particles.remove(sparkEnvelope);
          this.sparks.delete(sparkEnvelope);
        });
      }
    }
    if (this.pincherBg) {
      this.pincherBg.args.scale *= 0.85;
      // this.pincherFg.args.scale *= 0.875;

      if (Math.abs(this.pincherBg.args.scale) < 0.1) {
        // this.pincherBg.args.scale = 0;
        // this.pincherFg.args.scale = 0;
      }
    } else {
      // this.pinch(0, 0);
    }
    if (!this.twister) {
      this.twist(0);
    }
    if (this.args.grinding) {
      this.args.rolling = false;
      if (this.yAxis > 0.5) {
        this.args.animation = 'grinding-crouching';
      } else {
        this.args.animation = 'grinding';
      }
    }
    super.update();
    if (!this.yAxis && this.spindashCharge) {
      this.spindash();
    }
    if (this.args.falling && this.springing && this.args.ySpeed >= 0) {
      this.args.groundAngle = 0;
      this.args.animation = 'dropping-start';
      this.springing = false;
      this.onTimeout(150, () => {
        if (!this.args.falling || this.args.animation !== 'dropping-start') {
          return;
        }
        this.args.animation = 'dropping';
      });
    }
    if (this.args.boltDash) {
      // this.dimmer = this.dimmer || new Tag('<div class = "particle particle-dimmer">');

      const boltParticle = new _Tag.Tag('<div class = "particle particle-bolt">');
      const speed = this.args.falling ? this.args.airSpeed : this.args.gSpeed;
      const boltPoint = this.rotatePoint(speed < 0 ? 8 : -8, this.args.falling ? this.dashed ? speed < 0 ? 28 : 32 : 14 : 28);

      // this.dimmer.style({
      // 	'--x': this.args.x + boltPoint[0]
      // 	, '--y': this.args.y + boltPoint[1]
      // });

      this.args.boltCount++;
      const direction = Math.sign(this.args.gSpeed || this.args.xSpeed);
      boltParticle.attr({
        'data-direction': direction
      });
      boltParticle.style({
        '--x': this.args.x + boltPoint[0],
        '--y': this.args.y + boltPoint[1],
        '--index': this.args.boltCount,
        '--direction': direction,
        '--mod': this.viewport.args.frameId % 4,
        '--wipe': Math.abs(speed),
        '--angle': this.args.falling ? this.args.airAngle : this.realAngle,
        '--dashCharge': 0
      });
      this.viewport.particles.add(boltParticle);
      if (Math.abs(speed) < 20 && this.args.falling) {
        this.args.boltDash = false;
      }

      // this.viewport.particles.add(this.dimmer);

      this.viewport.onFrameOut(30, () => {
        this.viewport.particles.remove(boltParticle);
      });
    }
    if ([...this.regions].filter(r => r.isWater).length && !this.bMap('checkBelow', this.args.x, this.args.y + 16).get(_Platformer.Platformer) && this.args.falling && this.dashed) {
      if (this.yAxis < 0) {
        this.args.xSpeed = this.args.xSpeed * 0.95;
        this.args.ySpeed -= Math.abs(this.args.xSpeed) * 0.05;
      }
      if (this.yAxis > 0) {
        this.args.xSpeed += Math.abs(this.args.ySpeed) * 0.05 * Math.sign(this.args.xSpeed);
        this.args.ySpeed = this.args.ySpeed * 0.95;
      }
    }
    if (this.viewport.args.frameId % this.viewport.settings.frameSkip === 0) {
      if (this.args.grinding && !this.args.falling && this.args.gSpeed) {
        for (const spark of this.sparks) {
          const sparkPoint = this.rotatePoint(1.75 * this.args.direction, 8);
          spark.style({
            opacity: Math.random() * 2,
            '--x': sparkPoint[0] + this.x,
            '--y': sparkPoint[1] + this.y
          });
        }
      }
    }
    if (Math.abs(this.ySpeedLast) > 16) {
      const landingFrames = Math.min(8, this.ySpeedLast / 3) * (this.args.rolling ? 0.5 : 1);
      if (this.groundTime && this.groundTime > 2 && this.groundTime < landingFrames && this.ySpeedLast) {
        this.args.animation = 'landing';
      }
    }
    if (this.args.sliding) {
      this.args.animation = 'sliding';
    }
    if (this.args.trickRamp) {
      this.args.animation = 'adventure-pose';
    }
    if (this.args.twistRamp) {
      this.args.animation = 'side-flip';
    }
  }
  readInput() {
    if (!this.lightDashing) {
      super.readInput();
    }
  }
  airDash(direction) {
    if (this.args.stuck || this.carrying.size) {
      return;
    }
    if (this.dashed || this.args.ignore && this.args.ignore !== -2) {
      return;
    }
    let dashSpeed = direction * (this.isSuper || this.isHyper ? 13 : 8);
    if (this.args.wallSticking) {
      this.args.x += dashSpeed;
      dashSpeed = direction * (this.isSuper || this.isHyper ? 18 : 9);
    }
    this.args.mode = 0;
    this.args.float = 2;
    this.args.rolling = false;
    this.args.height = this.args.normalHeight;
    if (this.args.xSpeed && Math.sign(this.args.xSpeed) !== Math.sign(direction)) {
      dashSpeed = direction * Math.abs(dashSpeed);
      this.args.float = 4;
      this.args.xSpeed = 0;
    }
    this.args.falling = true;
    if (this.args.mercy) {
      dashSpeed *= 0.75;
    }
    const finalSpeed = this.args.xSpeed + dashSpeed;

    // if(Math.abs(finalSpeed) > Math.abs(space))
    // {
    // 	dashSpeed = space * Math.sign(finalSpeed);
    // }

    this.args.animation = 'rolling';
    this.viewport.onFrameOut(3, () => this.args.animation = 'airdash');
    this.args.xSpeed = finalSpeed;
    this.args.ySpeed = 0;
    this.args.gSpeed = 0;
    this.dashTimer = 0;
    this.dashed = true;
    this.args.mode = 0;
    this.args.groundAngle = 0;
  }
  command_0() {
    if (!this.args.falling && this.args.crouching && !this.args.rolling && this.yAxis) {
      this.spindashCharge += 10;
      let dashCharge = this.spindashCharge / 20;
      if (dashCharge > 1) {
        dashCharge = 1;
      }
      this.args.xOff = 5 * -this.args.direction;
      this.args.yOff = 32;
      this.twist(120 * dashCharge * this.args.direction);
      if (!this.dashDust) {
        this.showDashDust();
      } else if (this.dashDust) {
        this.dashDust.style({
          '--dashCharge': this.spindashCharge
        });
      }
      this.willJump = false;
      return;
    }
    this.dropDashCharge = 0;
    if (this.args.jumping && !this.args.wasHanging && !this.dashed && (!this.args.doubleSpin || this.args.doubleSpin === 2) && (!this.args.currentSheild || this.args.currentSheild.type === 'normal' || this.args.currentSheild.type === 'super')) {
      if (this.args.mercy < 120) {
        this.args.mercy = 0;
      }
      this.args.doubleSpin = true;
      this.args.xOff = 0;
      this.args.yOff = 32;

      // this.viewport.onFrameOut(15, () => this.args.doubleSpin = false);

      this.viewport.onFrameOut(5, () => this.pinch(-600, 50));
      const marker = new _Marker.Marker({
        x: this.args.x,
        y: this.args.y
      });
      marker.owner = this;
      this.markers.add(marker);
      this.viewport.spawn.add({
        object: marker
      });
      const debindX = this.args.bindTo('x', (v, k) => marker.args[k] = v);
      const debindY = this.args.bindTo('y', (v, k) => marker.args[k] = v + 18);
      this.viewport.onFrameOut(25, () => {
        this.viewport.actors.remove(marker);
        debindX();
        debindY();
      });
    }
    super.command_0();
  }
  command_4() {
    if (this.args.ignore) {
      return;
    }
    if (this.args.falling) {
      this.airDash(-1);
      this.willStick = 2;
      this.stayStuck = true;
    }
  }
  hold_4(button) {
    if (this.args.ignore) {
      return;
    }
    if (this.args.jumping || this.dashed) {
      this.dropDashCharge = 0;
      this.willStick = 2;
      this.stayStuck = true;
    }
  }
  release_4() {
    this.onNextFrame(() => {
      this.willStick = false;
      this.stayStuck = false;
    });
    if (this.args.wallSticking && !this.dashed) {
      this.args.falling = true;
      if (this.args.ySpeed > 128) {
        // this.args.ySpeed = this.args.ySpeed / 4;
      } else {
        this.args.ySpeed = 0;
      }
      const mode = this.args.mode;
      this.airDash(mode === 1 ? 1 : -1);
      this.args.facing = mode === 1 ? 'left' : 'right';
      this.args.mode = 0;
      this.dashed = true;
    }
  }
  command_5() {
    if (this.args.ignore) {
      return;
    }
    if (this.args.falling) {
      this.airDash(1);
      this.willStick = 2;
      this.stayStuck = true;
    }
  }
  hold_5(button) {
    if (this.args.ignore) {
      return;
    }
    if (this.args.jumping || this.dashed && this.args.mode !== 2) {
      this.dropDashCharge = 0;
      this.willStick = 2;
      this.stayStuck = true;
    }
  }
  release_5() {
    this.onNextFrame(() => {
      this.willStick = false;
      this.stayStuck = false;
    });
    if (this.args.wallSticking && !this.dashed) {
      this.args.falling = true;
      this.args.ySpeed = 0;
      const mode = this.args.mode;
      this.airDash(mode === 1 ? 1 : -1);
      this.args.facing = mode === 1 ? 'left' : 'right';
      this.args.mode = 0;
      this.dashed = true;
    }
  }
  command_1() {
    if (this.args.ignore) {
      return;
    }
    if (this.args.wallSticking) {
      this.args.x += this.args.width / 2 * (this.args.mode === 1 ? 1 : -1);
      this.bMap('doJump', 0);
    }
    if (this.args.gSpeed && !this.args.falling && !this.args.rolling && Math.sign(this.args.gSpeed) === this.args.direction) {
      this.args.rolling = true;
      const standOrRecheck = () => {
        const backOfHead = [this.args.width / 2, this.args.height + 4];

        // const actualBackOfHead = this.rotatePoint(...backOfHead);

        const solid = this.getMapSolidAt(this.x - backOfHead[0], this.y - backOfHead[1]);
        if (solid) {
          this.viewport.onFrameOut(10, standOrRecheck);
          this.args.gSpeed = this.args.gSpeed || this.args.direction * 4 || 4;
          this.args.rolling = true;
          return;
        }
        this.args.rolling = false;
      };
      this.viewport.onFrameOut(20, standOrRecheck);
    }
  }
  release_1()
  // spindash
  {
    this.dropDashCharge = 0;
    if (!this.spindashCharge) {
      return;
    }
    if (!this.yAxis) {
      this.args.crouching = false;
    }
  }
  spindash() {
    if (this.spindashCharge < 5 && (this.args.modeTime < 45 || this.args.skidding)) {
      this.spindashCharge = 15;
    }
    const direction = this.args.facing === 'left' ? -1 : 1;
    let dashPower = this.spindashCharge / 40;
    if (dashPower > 1) {
      dashPower = 1;
    }
    this.args.rolling = true;
    const dashBoost = dashPower * 32;
    this.castRayQuick(dashBoost * Math.sign(direction), [Math.PI, 0, 0][1 + Math.sign(direction)], [0, this.args.height / 2]);
    if (Math.sign(direction) !== Math.sign(this.args.gSpeed)) {
      this.args.gSpeed = dashBoost * Math.sign(direction);
    } else {
      this.args.gSpeed += dashBoost * Math.sign(direction);
    }
    this.args.ignore = 1;
    this.args.rolling = true;
    this.spindashCharge = 0;
    if (this.dashDust) {
      this.dashDust.remove();
    }
  }
  hold_1(button)
  // spindash
  {
    if (this.args.mercy) {
      return;
    }
    if (this.carrying.size) {
      return;
    }

    // if(this.skidding)
    // {
    // 	return;
    // }

    this.yAxis = this.yAxis || 1;
    if (this.args.ignore || this.args.rolling) {
      return;
    }
    if (this.args.jumping) {
      if (this.dropDashCharge < 15) {
        this.dropDashCharge++;
        return;
      }
    }
    if (this.args.modeTime === 0) {
      return;
    }
    if (this.dropDashCharge) {
      return;
    }
    if (this.args.falling || this.willJump || this.args.gSpeed && !this.skidding) {
      if (!this.skidding) {
        this.spindashCharge = 0;
      }
      return;
    }
    if (!this.spindashCharge && button.time > 6) {
      return;
    }
    this.args.ignore = 1;
    let dashCharge = this.spindashCharge / 20;
    if (dashCharge > 1) {
      dashCharge = 1;
    }
    this.spindashCharge = this.spindashCharge || 1;
    if (this.yAxis > 0.5) {
      this.spindashCharge = this.spindashCharge || 10;
    }
    this.args.crouching = true;
    if (!this.dashDust) {
      this.showDashDust();
    } else if (this.dashDust) {
      this.dashDust.style({
        '--dashCharge': this.spindashCharge
      });
    }
    this.spindashCharge++;
    this.args.xOff = 5 * -this.args.direction;
    this.args.yOff = 32;
    this.twist(120 * dashCharge * this.args.direction);
    this.args.animation = 'spindash';
    if (this.args.direction < 0) {
      this.args.facing = 'left';
    } else if (this.args.direction > 0) {
      this.args.facing = 'right';
    }
  }
  showDashDust() {
    const viewport = this.viewport;
    const dustParticle = new _Tag.Tag('<div class = "particle-spindash-dust">');
    const dustPoint = this.rotatePoint(0, 0);
    dustParticle.style({
      '--x': dustPoint[0] + this.args.x,
      '--y': dustPoint[1] + this.args.y,
      '--direction': this.args.direction,
      '--dashCharge': this.spindashCharge
    });
    dustParticle.setAttribute('data-facing', this.args.facing);
    viewport.particles.add(dustParticle);
    this.dashDust = dustParticle;
  }
  hold_2() {
    if (this.args.stuck || !this.args.falling) {
      return;
    }
    if (this.lightDashing) {
      return;
    }
    if (this.lightDashingCoolDown > 0) {
      return;
    }
    const ring = this.findDashableRing(48);
    if (ring) {
      this.lightDash(ring);
      this.lightDashingCoolDown = 9;
      return;
    }
  }
  command_2() {
    if (this.viewport.collisions.has(this)) {
      const objects = this.viewport.collisions.get(this);
      for (const object of objects.keys()) {
        if (this.carrying.size && !this.carrying.has(object)) {
          continue;
        }
        if (typeof object.lift === 'function') {
          object.lift(this);
        }
      }
    }
    this.onNextFrame(() => {
      const speed = this.args.falling ? this.args.airSpeed : this.args.gSpeed;
      if (this.isSuper && !this.lightDashing && !this.args.boltDash && Math.abs(speed) > 6) {
        const xSpeed = this.args.xSpeed;
        const ySpeed = this.args.ySpeed;
        const gSpeed = this.args.gSpeed;
        if (!this.args.falling) {
          this.args.gSpeed *= 3;
          this.args.gSpeed = Math.max(-128, Math.min(this.args.gSpeed, 128));
        } else {
          this.args.xSpeed = Math.max(-64, Math.min(this.args.xSpeed, 64));
          this.args.ySpeed = Math.max(-64, Math.min(this.args.ySpeed, 64));
          this.args.float = 5;
          this.args.xSpeed *= 5;
          this.args.ySpeed *= 5;
        }
        this.args.boltCount = 0;
        this.args.boltDash = true;
        _Sfx.Sfx.play('LIGTNING_STRIKE');
        this.args.opacity = 0;
        this.viewport.onFrameOut(35, () => {
          this.args.opacity = 1;
          this.args.boltDash = false;
          this.args.xSpeed = this.args.xSpeed ? xSpeed : 0;
          this.args.ySpeed = this.args.ySpeed ? ySpeed : 0;
          this.args.gSpeed = this.args.gSpeed ? gSpeed : 0;

          // this.dimmer && this.viewport.particles.remove(this.dimmer);

          // this.dimmer = false;
        });
      }
    });
  }

  release_2() {
    if (!this.args.boltDash) {
      return;
    }
    this.args.opacity = 1;
    this.args.boltDash = false;
    this.args.xSpeed /= 2;
    this.args.ySpeed /= 2;
    this.args.gSpeed /= 3;

    // this.dimmer && this.viewport.particles.remove(this.dimmer);

    // this.dimmer = false;
  }

  command_3() {}
  setProfile() {
    if (this.isHyper) {
      this.args.spriteSheet = this.superSpriteSheet;
      this.args.gSpeedMax = this.gSpeedMaxHyper;
      this.args.jumpForce = this.jumpForceHyper;
      this.args.accel = this.accelSuper;
    } else if (this.isSuper) {
      this.args.spriteSheet = this.superSpriteSheet;
      this.args.gSpeedMax = this.gSpeedMaxSuper;
      this.args.jumpForce = this.jumpForceSuper;
      this.args.accel = this.accelSuper;
    } else {
      this.args.spriteSheet = this.rotatedSpriteSheet;
      this.args.gSpeedMax = this.gSpeedMaxNormal;
      this.args.jumpForce = this.jumpForceNormal;
      this.args.accel = this.accelNormal;
    }
  }
  findNearestRing() {
    return this.findDashableRing(64);
  }
  findDashableRing() {
    let maxDist = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 128;
    const findRing = actor => {
      if (!(actor instanceof _Ring.Ring)) {
        return false;
      }
      const direction = Math.sign(this.args.xSpeed);
      if (direction > 0 && actor.x < this.x) {
        return false;
      }
      if (direction < 0 && actor.x > this.x) {
        return false;
      }
      return true;
    };
    const ring = this.findNearestActor(findRing, maxDist);
    if (!ring) {
      return;
    }
    const nextRing = ring.findNearestActor(findRing, maxDist);
    if (!nextRing) {
      return;
    }
    const firstAngle = Math.atan2(this.y - ring.y, this.x - ring.x);
    const secondAngle = Math.atan2(ring.y - nextRing.y, ring.x - nextRing.x);
    if (Math.abs(firstAngle - secondAngle) > Math.PI / 2) {
      return;
    }
    return ring;
  }
  lightDash(ring) {
    if (!this.args.falling) {
      this.lightDashing = false;
      return false;
    }
    if (this.args.popChain.length) {
      if (!this.lightDashReward) {
        this.lightDashReward = {
          label: 'lightdash',
          points: 10,
          multiplier: 1
        };
        this.args.popChain.push(this.lightDashReward);
      } else {
        this.lightDashReward.points += 10;
      }
    }
    this.lightDashed = true;
    let currentAngle;
    this.spindashCharge = 0;
    let angle = Math.atan2(ring.y - this.y + 8, ring.x - this.x);
    currentAngle = this.args.groundAngle;
    const angleDiff = Math.abs(currentAngle - angle);
    let dashSpeed = this.distanceFrom(ring) * 4 * (Math.PI / 2 / angleDiff);
    const maxDash = 55;
    if (dashSpeed > maxDash) {
      dashSpeed = maxDash;
    }

    // const space = this.bMap('scanForward', dashSpeed, 0.5).get(Platformer);

    // if(space && dashSpeed > space)
    // {
    // 	dashSpeed = space;
    // }

    const direction = Math.sign(this.args.xSpeed) || Math.sign(this.args.gSpeed);
    if (this.args.direction < 0) {
      this.args.animation = 'lightdash-back';
    } else if (this.args.direction > 0) {
      this.args.animation = 'lightdash';
    }
    const breakGroundAngle = Math.PI / 4;

    // this.args.airAngle  = angle;

    this.lightDashing = true;
    this.args.xSpeed = dashSpeed * Math.cos(angle) * 0.5;
    this.args.ySpeed = dashSpeed * Math.sin(angle) * 0.5;
    this.lightDashTimeout();
  }
  collect(pickup) {
    super.collect(pickup);
    if (pickup instanceof _Ring.Ring) {
      if (this.lightDashing) {
        const ring = this.findNearestActor(actor => actor instanceof _Ring.Ring, 128);
        if (ring) {
          // this.args.x = pickup.args.x;
          // this.args.y = pickup.args.y;

          this.lightDash(ring);
        } else {
          this.lightDashing = false;
          this.args.float = 0;
        }
      }
    }
  }
  lightDashTimeout() {
    if (this.clearLightDash) {
      this.clearLightDash();
      this.clearLightDash = false;
    }
    this.clearLightDash = this.viewport.onFrameOut(9, () => {
      this.lightDashing = false;
      this.args.float = 0;
    });
  }
  setCameraMode() {
    if (!this.args.falling && this.regions) {
      for (const region of this.regions) {
        if (region.args.perspective) {
          this.args.cameraMode = 'perspective';
          return;
        }
      }
    }
    if (this.args.boltDash) {
      this.args.cameraMode = 'draggable';
    } else if (this.args.wallSticking) {
      if (this.args.cameraMode !== 'panning' && (this.args.cameraMode !== 'popping' || Math.abs(this.args.ySpeed) < Math.abs(this.args.xSpeed))) {
        this.args.cameraMode = 'aerial';
      }
    } else {
      super.setCameraMode();
    }
  }
  startle(other) {
    super.startle(other);
    this.onNextFrame(() => this.args.animation = 'startle');
  }
  die() {
    super.die();
    this.onNextFrame(() => this.args.animation = 'dead');
    this.pinch(0, 0);
    this.twist(0);
    _Sfx.Sfx.play('PLAYER_DAMAGED');
  }
  loseRings(count, age) {
    super.loseRings(count, age);
    _Sfx.Sfx.play('RINGS_SCATTERED');
  }
  collideA(other) {
    if (other instanceof _Spring.Spring) {
      this.onNextFrame(() => {
        if (!this.args.falling) {
          return;
        }
        this.springing = true;
        this.args.animation = 'springdash';
      });
    }
    if (other.pop && this.isHyper) {
      other.pop(this);
    }
  }
  get solid() {
    return false;
  }
  get canRoll() {
    return !this.args.wallSticking;
  }
  get isEffect() {
    return false;
  }
  get controllable() {
    return !this.args.npc;
  }
  get facePoint() {
    if (this.args.wallSticking) {
      return this.rotatePoint(0, -5);
    }
    return super.facePoint;
  }
  crossRegionBoundary(region, entered) {
    if (region instanceof _GrindingRegion.GrindingRegion) {
      if (!entered) {
        for (const r of this.regions) {
          if (r !== region && r instanceof _GrindingRegion.GrindingRegion) {
            return;
          }
        }
        if (this.args.wasGrinding && this.args.falling) {
          this.args.animation = 'springdash';
        } else {
          this.args.grinding = false;
        }
      }
    }
    super.crossRegionBoundary(region, entered);
  }
  rotateMainColor() {
    let rH = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    let rS = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    let rV = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    const rotatedColors = {
      '8080e0': new _Color.Color('8080e0').rotate(rH, rS, rV).toString(),
      '6060c0': new _Color.Color('6060c0').rotate(rH, rS, rV).toString(),
      '4040a0': new _Color.Color('4040a0').rotate(rH, rS, rV).toString(),
      '202080': new _Color.Color('202080').rotate(rH, rS, rV).toString()
    };
    this.png.ready.then(() => {
      const newPng = this.png.recolor(rotatedColors);
      this.args.rotatedSpriteSheet = this.rotatedSpriteSheet = this.args.spriteSheet = this.spriteSheet = newPng.toUrl();
    });
  }
}
exports.Sonic = Sonic;
});

;require.register("actor/Sparkle.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Sparkle = void 0;
var _Mixin = require("curvature/base/Mixin");
var _Tag = require("curvature/base/Tag");
var _Flickie = require("./Flickie");
var _PointActor = require("./PointActor");
var _SkidDust = require("../behavior/SkidDust");
var _CanPop = require("../mixin/CanPop");
var _Explosion = require("../actor/Explosion");
var _Projectile = require("../actor/Projectile");
class Sparkle extends _Mixin.Mixin.from(_PointActor.PointActor, _CanPop.CanPop) {
  constructor() {
    var _this$args$offset;
    super(...arguments);
    this.args.type = 'actor-item actor-sparkle';
    this.args.animation = 'standing';
    this.args.width = 24;
    this.args.height = 24;
    this.willStick = true;
    this.stayStuck = true;
    this.args.float = -1;
    this.args.static = true;
    this.args.invincible = true;
    this.args.offset = (_this$args$offset = this.args.offset) !== null && _this$args$offset !== void 0 ? _this$args$offset : 0;
  }
  collideA(other, type) {
    if (other instanceof _Projectile.Projectile) return false;
    super.collideA(other, type);
  }
  update() {
    if (!this.viewport) {
      return;
    }
    const viewport = this.viewport;
    if (!this.lightning) {
      this.lightning = new _Tag.Tag(`<div class = "particle-sparkle-lightning">`);
      viewport.particles.add(this.lightning);
      this.lightning.style({
        '--x': this.args.x,
        '--y': this.args.y + -64
      });
    }
    const frameId = viewport.args.frameId + -this.args.offset;
    if (frameId % 180 > 150) {
      this.args.animation = 'flicker-fast';
    } else if (frameId % 180 > 120) {
      this.args.animation = 'flicker';
    } else {
      this.args.animation = 'standing';
    }
    const direction = this.args.mode === 0 ? 1 : -1;
    const angle = -Math.PI / 2 * direction;
    if (frameId % 180 > 168) {
      const length = this.castRayQuick(2048, angle);
      this.args.invincible = true;
      this.lightning.style({
        height: `${length - this.args.height}px`
      });
      const toX = this.args.x + Math.round(Math.cos(angle) * (length + -1));
      const toY = this.args.y + Math.round(Math.sin(angle) * (length + -1));
      const blocking = viewport.actorsAtLine(this.args.x, this.args.y, toX, toY);
      blocking.delete(this);
      for (const [b, p] of blocking) {
        if (!b.controllable) {
          continue;
        }
        b.damage(this, 'electric');
        b.pop && b.pop(this);
      }
    } else {
      this.lightning.style({
        height: '0px'
      });
      this.args.invincible = false;
    }
    if (frameId % 180 === 0) {
      const length = this.castRayQuick(2048, angle);
      this.lightning.style({
        '--x': this.args.x,
        '--y': this.args.y + -length * 0.5 + (this.args.mode === 2 ? length : 0) + direction * this.args.height * 0.5
      });
      const toX = this.args.x + Math.round(Math.cos(angle) * (length + -1));
      const toY = this.args.y + Math.round(Math.sin(angle) * (length + -1));
      this.args.x = toX;
      this.args.y = toY;
      this.args.facing = direction > 0 ? 'right' : 'left';
      this.args.mode = this.args.mode === 0 ? 2 : 0;
      if (this.vizi) {
        const speed = 0.25;
        const sparkL = new _Projectile.Projectile({
          owner: this,
          subType: 'spark',
          damageType: 'electric',
          gravity: 0,
          ySpeed: speed * direction,
          xSpeed: -speed,
          x: this.args.x,
          y: this.args.y
        });
        const sparkR = new _Projectile.Projectile({
          owner: this,
          subType: 'spark',
          damageType: 'electric',
          gravity: 0,
          ySpeed: speed * direction,
          xSpeed: speed,
          x: this.args.x,
          y: this.args.y
        });
        viewport.spawn.add({
          object: sparkL
        });
        viewport.spawn.add({
          object: sparkR
        });
      }
    }
    super.update();
  }
  effect(other) {
    super.effect(other);
  }
  pop(other) {
    const viewport = this.viewport;
    super.pop(other);
    if (this.args.gone) {
      viewport.particles.remove(this.lightning);
    }
  }
  get solid() {
    return false;
  }
  get isEffect() {
    return false;
  }
  // get controllable() { return true; }
}
exports.Sparkle = Sparkle;
});

;require.register("actor/Spawner.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Spawner = void 0;
var _PointActor = require("./PointActor");
var _ObjectPalette = require("../ObjectPalette");
class Spawner extends _PointActor.PointActor {
  constructor() {
    super(...arguments);
    this.args.width = 16;
    this.args.height = 32;
    this.args.type = 'actor-item actor-spawner';
  }
  activate() {
    if (!this.args.spawn || !this.args.point) {
      return;
    }
    const point = this.viewport.objDefs.get(this.args.point);
    const type = _ObjectPalette.ObjectPalette[this.args.spawn];
    if (!point || !type) {
      return;
    }
    const spawned = new type({
      x: point.x,
      y: point.y
    });
    for (const [property, value] of this.def) {
      if (property === 'point' || property === 'type') {
        continue;
      }
      spawned.args[property] = value;
    }
    spawned.args[name] = this.args.spawn;
    this.viewport.spawn.add({
      object: spawned
    });
    this.viewport.setColCell(spawned);
  }
  get solid() {
    return false;
  }
}
exports.Spawner = Spawner;
});

;require.register("actor/SpikeBomb.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SpikeBomb = void 0;
var _PointActor = require("./PointActor");
var _Sfx = require("../audio/Sfx");
var _Tag = require("curvature/base/Tag");
var _RedBomb = require("./RedBomb");
class SpikeBomb extends _PointActor.PointActor {
  constructor() {
    super(...arguments);
    this.args.width = 24;
    this.args.height = 24;
    this.args.type = 'actor-item actor-spike-bomb';
    this.args.decel = 0;
    this.explosions = new Set();
  }
  update() {
    if (!this.args.falling && this.groundTime > 1) {
      this.explode();
    }
    super.update();
    for (const explosion of this.explosions) {
      explosion.style({
        '--x': this.args.x,
        '--y': this.args.y + -16
      });
    }
  }
  collideA(other) {
    if (!other.controllable) {
      return;
    }
    other.damage(this);
    this.explode();
    this.args.float = -1;
    // this.args.xSpeed = 0;
    // this.args.ySpeed = 0;
  }

  explode() {
    if (this.exploded) {
      return;
    }
    this.exploded = true;
    this.args.type = 'actor-item actor-air-bomb hide';
    const redA = new _RedBomb.RedBomb({
      x: this.args.x,
      y: this.args.y + -1,
      owner: this
    });
    const redB = new _RedBomb.RedBomb({
      x: this.args.x,
      y: this.args.y + -1,
      owner: this
    });
    redA.args.ySpeed = -this.ySpeedLast * 0.5;
    redB.args.ySpeed = -this.ySpeedLast * 0.5;
    redA.args.xSpeed = -this.ySpeedLast * 0.35;
    redB.args.xSpeed = +this.ySpeedLast * 0.35;
    this.viewport.spawn.add({
      object: redA
    });
    this.viewport.spawn.add({
      object: redB
    });
    this.viewport.actors.remove(this);
    _Sfx.Sfx.play('OBJECT_DESTROYED');
  }
}
exports.SpikeBomb = SpikeBomb;
});

;require.register("actor/SpikeRing.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SpikeRing = void 0;
var _PointActor = require("./PointActor");
class SpikeRing extends _PointActor.PointActor {
  constructor() {
    super(...arguments);
    this.args.width = 64;
    this.args.height = 32;
    this.args.type = 'actor-item actor-spike-ring';
    this.args.float = -1;
    this.oscMode = 0;
  }
  collideA(other) {
    if (other.controllable) {
      other.damage(this);
    }
  }
  update() {
    const speed = 1.75;
    if (this.oscMode) {
      this.args.y -= speed * Math.sign(this.args.y - this.objDef.y);
      if (Math.abs(this.args.y - this.objDef.y) < speed) {
        this.args.y = this.objDef.y;
        this.oscMode = 0;
      }
    } else {
      this.args.y -= speed * Math.sign(this.args.y - this.args.riseTo);
      if (Math.abs(this.args.y - this.args.riseTo) < speed) {
        this.args.y = this.args.riseTo;
        this.oscMode = 1;
      }
    }
  }
}
exports.SpikeRing = SpikeRing;
});

;require.register("actor/Spikes.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Spikes = void 0;
var _PointActor = require("./PointActor");
var _Sfx = require("../audio/Sfx");
var _Block = require("./Block");
class Spikes extends _PointActor.PointActor {
  static fromDef(objDef) {
    const obj = super.fromDef(objDef);
    obj.args.width = objDef.width;
    obj.args.height = objDef.height;
    obj.args.x = obj.originalX = objDef.x + Math.floor(objDef.width / 2);
    return obj;
  }
  constructor() {
    var _this$args$retractibl;
    let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let parent = arguments.length > 1 ? arguments[1] : undefined;
    super(args, parent);
    this.args.type = 'actor-item actor-spikes';
    this.args.width = args.width || 32;
    this.args.height = args.height || 32;
    this.args.pointing = this.args.pointing || 0;
    this.args.retractible = (_this$args$retractibl = this.args.retractible) !== null && _this$args$retractibl !== void 0 ? _this$args$retractibl : false;
    this.args.retracted = false;
    this.args.offset = this.args.offset || 0;
    this.args.beat = this.args.beat || 90;
    this.hazard = true;
  }
  updateStart() {
    if (this.args.retractible) {
      this.args.wasRetracted = this.args.retracted;
      const frameId = this.viewport.args.frameId + -this.viewport.args.startFrameId + -this.args.offset;
      this.args.retracted = !!(Math.floor(frameId / this.args.beat) % 2);
      if (!this.args.retracted && this.args.wasRetracted) {
        this.vizi && _Sfx.Sfx.play('SPIKES_OUT');
        const actors = this.viewport.actorsAtPoint(this.args.x, this.args.y, this.args.width, this.args.height);
        for (const actor of actors) {
          if (actor === this || actor.isRegion || actor.args.static) {
            continue;
          }
          switch (this.args.pointing) {
            case 0:
              actor.args.y = this.args.y + -this.args.height + -1;
              break;
            case 1:
              actor.args.x = this.args.x + -(this.args.width / 2) + -(actor.args.width / 2) + -1;
              actor.damage(this);
              break;
            case 2:
              actor.args.y = this.args.y + other.args.height;
              break;
            case 3:
              actor.args.x = this.args.y + this.args.width / 2 + actor.args.width / 2 + 1;
              actor.damage(this);
              break;
          }
        }
      }
      if (this.args.retracted && !this.args.wasRetracted) {
        this.vizi && _Sfx.Sfx.play('SPIKES_IN');
      }
    }
    super.updateStart();
  }
  onRendered(event) {
    super.onRendered(event);
    this.autoAttr.get(this.box)['data-pointing'] = 'pointing';
    this.autoAttr.get(this.box)['data-retracted'] = 'retracted';
  }
  startle() {}
  damage() {}
  collideA(other, type) {
    if (this.args.retracted) {
      return false;
    }
    if (other.isRegion) {
      return;
    }

    // if(!other.controllable)
    // {
    // 	return true;
    // }

    if (!this.args.static && this.args.falling && !this.args.float) {
      other.damage(false);
      return true;
    }
    if (!(other instanceof _Block.Block) && type === this.args.pointing) {
      if (this.args.pointing === 3) {
        const speed = other.args.xSpeed || other.args.gSpeed * (other.args.mode === 2 ? -1 : 1);
        if (speed <= 0) {
          if (!other.noClip && !this.args.retracted && this.args.wasRetracted) {
            other.args.x = this.args.x + this.args.width / 2 + other.args.width / 2 + 4;
          }
          other.damage(this);
        }
      } else if (this.args.pointing === 1) {
        const speed = other.args.xSpeed || other.args.gSpeed * (other.args.mode === 2 ? -1 : 1);
        if (speed >= 0) {
          if (!other.noClip && !this.args.retracted && this.args.wasRetracted) {
            other.args.x = this.args.x + -(this.args.width / 2) + -(other.args.width / 2) + -4;
          }
          other.damage(this);
        }
      } else if (this.args.pointing === 2) {
        const speed = other.args.ySpeed || other.args.gSpeed * (other.args.mode === 1 ? -1 : 1);
        if (speed <= 0) {
          if (!other.noClip && !this.args.retracted && this.args.wasRetracted) {
            other.args.y = this.args.y + other.args.height;
          }
          other.damage(this);
        }
      } else if (this.args.pointing === 0) {
        const speed = other.args.ySpeed || other.args.gSpeed * (other.args.mode === 3 ? -1 : 1);
        if (speed >= 0) {
          if (!other.noClip && !this.args.retracted && this.args.wasRetracted) {
            other.args.y = this.args.y + -this.args.height + 0;
          }
          other.damage(this);
        }
      }
    }
    return true;
  }
  get solid() {
    return !this.args.retracted && !this.args.wasRetracted;
  }
}
exports.Spikes = Spikes;
});

;require.register("actor/SpikesSmall.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SpikesSmall = void 0;
var _Tag = require("curvature/base/Tag");
var _Sfx = require("../audio/Sfx");
var _PointActor = require("./PointActor");
var _Spikes = require("./Spikes");
class SpikesSmall extends _Spikes.Spikes {
  static fromDef(objDef) {
    const obj = super.fromDef(objDef);
    obj.args.width = objDef.width;
    obj.args.height = 10;
    obj.args.x = obj.originalX = objDef.x + Math.floor(objDef.width / 2);
    return obj;
  }
  constructor() {
    let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let parent = arguments.length > 1 ? arguments[1] : undefined;
    super(args, parent);
    this.args.type = 'actor-item actor-spikes actor-spikes-small';
    this.args.width = args.width || 32;
    this.args.height = 10;
    this.args.pointing = this.args.pointing || 0;
    this.hazard = true;
    if (this.args.width < 16) {
      this.args.narrow = true;
    }
  }
  update() {
    super.update();
    const breakSplit = 4;
    if (this.sprite && !this.graphic) {
      this.graphic = new _Tag.Tag(`<svg style  = "--breakSplit: ${breakSplit};" data-narrow = "${this.args.narrow}">
				<defs>
					<pattern
						id     = "spikes-${this._id}"
						width  = "${16 / this.args.width}"
						height = "1"
						x      = "0"
						y      = "0"
					>
						<image href = "/Sonic/spikes-small-single.png">
					</pattern>
				</defs>
				<rect fill = "url(#spikes-${this._id})"></rect>
				<rect fill = "url(#spikes-${this._id})"></rect>
			</svg>`);
      this.sprite.appendChild(this.graphic.node);
    }
  }
  collideA(other, type) {
    if (this.args.broken || other instanceof _Spikes.Spikes || other.args.static) {
      return false;
    }
    if (other.isVehicle) {
      this.args.broken = true;
      this.args.gravity = 0.40;
      other.halt(10);
      const minSpace = 8 + (other.args.width + this.args.width) / 2;
      other.args.x = this.x + -minSpace * Math.sign(this.x - other.x);
      this.args.type = 'actor-item actor-spikes actor-spikes-small actor-spikes-breaking';
      this.viewport.onFrameOut(7, () => {
        this.args.falling = true;
        this.args.xSpeed = other.args.hSpeed * 0.25 + 1 * Math.random() ** 2;
        this.args.ySpeed = -5 + -5 * Math.random() ** 2;
        this.args.type = 'actor-item actor-spikes actor-spikes-small actor-spikes-broken';
        _Sfx.Sfx.play('BLOCK_DESTROYED');
      });
      this.args.float = 8;
      this.noClip = true;
      return false;
    }
    return super.collideA(other, type);
  }
  activate() {
    this.args.float = 0;
    this.noClip = true;
  }
  get solid() {
    return !this.args.broken && !this.noClip;
  }
}
exports.SpikesSmall = SpikesSmall;
});

;require.register("actor/SpinBridge.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SpinBridge = void 0;
var _Block = require("./Block");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class SpinBridge extends _Block.Block {
  constructor() {
    let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let parent = arguments.length > 1 ? arguments[1] : undefined;
    super(args, parent);
    _defineProperty(this, "segments", new Set());
    this.args.offset = this.args.offset || 0;
    this.args.speed = this.args.speed || 1;
  }
  initialize() {
    super.initialize();
    if (!this.getMapSolidAt(this.args.x + this.args.width, this.args.y)) {
      const firstSegment = this.args.prevSegment ? this.args.prevSegment.args.firstSegment : this;
      if (!this.args.segmentIndex) {
        this.args.segmentIndex = 0;
        this.args.firstSegment = this;
        this.segments.add(firstSegment);
      }
      if (this.args.segmentIndex >= 7) {
        return;
      }
      const next = new this.constructor({
        platform: this.args.platform,
        segmentIndex: this.args.segmentIndex + 1,
        prevSegment: this,
        firstSegment,
        float: -1,
        width: this.args.width,
        height: this.args.height,
        tileId: this.args.tileId,
        speed: this.args.speed,
        offset: this.args.offset,
        x: this.args.x + this.args.width,
        y: this.args.y + 4
      });
      firstSegment.segments.add(next);
      this.args.nextSegment = next;
      this.viewport.spawn.add({
        object: next
      });
      firstSegment.args.platform = true;
    }
  }
  updateEnd() {
    const age = this.viewport.args.frameId * this.args.speed + this.args.offset;
    const originX = this.args.firstSegment.args.x;
    const originY = this.args.firstSegment.args.y;
    const dist = this.args.segmentIndex * 16;
    this.args.x = originX + Math.cos(age / 120 * Math.PI) * dist;
    this.args.y = originY + Math.sin(age / 120 * Math.PI) * dist;
    super.updateEnd();
  }
  collideA(other, type) {
    if (other instanceof SpinBridge) {
      return false;
    }
    return super.collideA(other, type);
  }
}
exports.SpinBridge = SpinBridge;
});

;require.register("actor/Sping.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Sping = void 0;
var _Flickie = require("./Flickie");
var _Mixin = require("curvature/base/Mixin");
var _Tag = require("curvature/base/Tag");
var _PointActor = require("./PointActor");
var _SkidDust = require("../behavior/SkidDust");
var _CanPop = require("../mixin/CanPop");
var _Explosion = require("../actor/Explosion");
var _Projectile = require("../actor/Projectile");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class Sping extends _Mixin.Mixin.from(_PointActor.PointActor, _CanPop.CanPop) {
  constructor() {
    super(...arguments);
    _defineProperty(this, "name", 'Spiny');
    this.behaviors.add(new _SkidDust.SkidDust());
    this.args.type = 'actor-item actor-sping';
    this.args.animation = 'standing';
    this.args.accel = 0.1;
    this.args.decel = 0.5;
    this.args.gSpeedMax = 5;
    this.args.jumpForce = 5;
    this.args.gravity = 0.5;
    this.args.width = 48;
    this.args.height = 22;
    this.willStick = false;
    this.stayStuck = false;
  }
  update() {
    const direction = this.args.direction;
    const speed = 0.125;
    const beat = 90;
    if (this.age % beat < beat - 25) {
      if (Math.floor(this.age / beat) % 2) {
        this.args.gSpeed = -speed;
      } else {
        this.args.gSpeed = speed;
      }
    }
    if (this.box) {
      this.box.setAttribute('data-animation', 'walking');
      if (this.age % beat < 15 || this.age % beat > beat - 5) {
        this.box.setAttribute('data-animation', 'shooting');
      }
    }
    super.update();
    if (this.age % beat === beat - 3) {
      const x = this.x - 2;
      const y = this.y - 12;
      const z = -1;
      const xSpeed = -1.5 * Math.sign(this.gSpeedLast);
      const ySpeed = -3;
      const owner = this;
      const ball = new _Projectile.Projectile({
        x,
        y,
        z,
        owner
      });
      if (!this.viewport) {
        return;
      }
      this.viewport.onFrameOut(2, () => {
        Object.assign(ball.args, {
          xSpeed,
          ySpeed
        });
      });
      this.viewport.spawn.add({
        object: ball
      });
    }
  }
  effect(other) {
    super.effect(other);

    // this.viewport.spawn.add({object:new Flickie({
    // 	x: this.args.x,
    // 	y: this.args.y,
    // })});
  }

  get solid() {
    return false;
  }
  get isEffect() {
    return false;
  }
  // get controllable() { return true; }
}
exports.Sping = Sping;
});

;require.register("actor/Spinner.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Spinner = void 0;
var _PointActor = require("./PointActor");
var _Block = require("./Block");
var _Sfx = require("../audio/Sfx");
const Boosted = Symbol('Boosted');
class Spinner extends _PointActor.PointActor {
  constructor() {
    super(...arguments);
    this.args.type = 'actor-item actor-spinner';
    this.args.width = 64;
    this.args.height = 24;
    this.args.direction = this.args.direction || 1;
    this.args.static = true;
  }
  update() {
    super.update();
  }
  collideA(other) {
    if (other.isRegion || other.args.static || other instanceof _Block.Block) {
      return;
    }
    if (other instanceof Spinner) {
      return;
    }
    if (other.args.gSpeed === 0) {
      // return;
    }
    if (other.args.falling || Math.sign(other.args.gSpeed) === Math.sign(this.args.direction) && Math.abs(other.args.gSpeed) > this.args.toSpeed) {
      return;
    }
    this.ignores.set(other, 30);

    // this.viewport.onFrameOut(10, () => delete other[Boosted]);

    // other[Boosted] = this;

    const toSpeed = this.args.toSpeed || 40;
    other.args.ignore = 2;
    other.args.direction = this.args.direction;
    other.args.facing = this.args.direction > 0 ? 'right' : 'left';
    other.args.gSpeed = Math.max(Math.abs(other.args.gSpeed), toSpeed) * Math.sign(this.args.direction || 1);
    other.xAxis = 0;
    _Sfx.Sfx.play('SPEEDPAD_HIT');
  }
}
exports.Spinner = Spinner;
});

;require.register("actor/SpinningFloat.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SpinningFloat = void 0;
var _Block = require("./Block");
var _Sfx = require("../audio/Sfx");
var _Region = require("../region/Region");
class SpinningFloat extends _Block.Block {
  constructor() {
    super(...arguments);
    this.hitBlocks = true;
    this.invertsBias = true;
    this.args.width = 64;
    this.args.height = 64;
    this.args.platform = 1;
    // this.args.float    = -1;
    this.args.type = 'actor-item actor-spinning-float';
    this.args.static = 0;
    this.args.gravity = 0.40;
    this.args.spinning = 0;
    this.args.bouncing = 0;
    this.args.treadmill = true;
    this.args.trackX = true;
    this.args.particleScale = 1.25;
    this.lastConvey = 0;
  }
  collideA(other, type) {
    if (other.args.platform) {
      return false;
    }
    return super.collideA(other, type);
  }
  update() {
    super.update();
    this.args.moving = this.args.falling || this.args.gSpeed;
    let inWater = false,
      topWater = false;
    const topRegions = this.viewport.regionsAtPoint(this.args.x, this.args.y - 36);
    for (const region of this.regions) {
      if (region.isWater) {
        inWater = true;
      }
    }
    for (const region of topRegions) {
      if (region.isWater) {
        topWater = true;
      }
    }
    if (topWater) {
      this.args.ySpeed -= this.args.gravity;
      this.args.falling = true;
      if (this.args.ySpeed > 0) {
        this.args.ySpeed *= 0.95;
      }
    }
    const bob = 0.25 + 3.5 * Math.abs(this.args.convey / 20);
    if (inWater && this.args.falling && Math.abs(this.args.ySpeed) < bob && (this.args.ySpeed > 0 || this.args.convey)) {
      if (!topWater && this.args.ySpeed > 0 || topWater && this.args.ySpeed < 0) {
        this.args.ySpeed = Math.sign(this.args.ySpeed) * bob;
      }
    }
    this.standingUnder.forEach(a => {
      a.args.xSpeed = this.args.xSpeed || this.args.gSpeed;
      if (a.xAxis && Math.abs(a.args.gSpeed) > 1) {
        if (!this.args.falling) {
          a.args.gSpeed *= 0.90;
        } else if (!inWater) {
          a.args.gSpeed *= 0.99;
        }
      }
      if (Math.abs(a.args.gSpeed) > 14) {
        a.args.gSpeed = 14 * Math.sign(a.args.gSpeed);
      }
      if (Math.abs(this.args.convey) > 8) {
        a.args.x = this.args.x;
      } else {
        if (a.groundTime < 2) {
          a.args.gSpeed = 0;
          a.args.xSpeed = 0;
          this.args.convey = 0;
        }
        if (Math.abs(this.args.x - a.args.x) < 1) {
          a.args.x = this.args.x;
        }
        a.args.x += 0.2 * (this.args.x - a.args.x);
      }
    });
    if (!this.args.falling && Math.abs(this.args.gSpeed) < Math.abs(this.args.convey)) {
      this.args.gSpeed = this.args.convey;
      this.args.xSpeed = this.args.gSpeed;
    } else if (inWater) {
      if (!this.args.xSpeed && this.gSpeedLast) {
        this.args.xSpeed = this.gSpeedLast;
        this.gSpeedLast = 0;
      }
      if (topWater && this.getMapSolidAt(this.x, this.y + 1)) {
        this.args.y--;
      }
      if (Math.abs(this.args.xSpeed) < 8) {
        this.args.xSpeed += 0.005 * this.args.convey;
      }
      if (this.args.falling) {
        this.args.xSpeed *= 0.99;
      } else {
        this.args.gSpeed = this.args.xSpeed;
      }
    }
  }
  sleep() {
    this.args.y = this.originalY;
  }

  // get solid() { return true; }
}
exports.SpinningFloat = SpinningFloat;
});

;require.register("actor/SpitFire.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SpitFire = void 0;
var _PointActor = require("./PointActor");
class SpitFire extends _PointActor.PointActor {
  constructor() {
    super(...arguments);
    this.args.type = 'actor-item actor-spitfire';
    this.args.width = 99;
    this.args.height = 32;
    this.args.float = -1;
    this.noClip = true;
  }
  update() {
    if (this.age > 45) {
      this.args.gone = true;
      this.viewport.actors.remove(this);
      this.remove();
      return;
    }
    super.update();
  }
  collideA(other) {
    if (this.age < 10) {
      return;
    }
    if (other.immune(this, 'fire')) {
      return;
    }
    if (this.args.owner && !this.args.owner.args.gone) {
      other.controllable && other.damage(this, 'fire');
    }
  }
}
exports.SpitFire = SpitFire;
});

;require.register("actor/SpitSteam.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SpitSteam = void 0;
var _PointActor = require("./PointActor");
class SpitSteam extends _PointActor.PointActor {
  constructor() {
    super(...arguments);
    this.args.type = 'actor-item actor-spitsteam';
    this.args.width = 79;
    this.args.height = 16;
    this.args.float = -1;
    this.noClip = true;
  }
  update() {
    if (this.age > 30) {
      this.args.gone = true;
      this.viewport.actors.remove(this);
      this.remove();
      return;
    }
    super.update();
  }
  collideA(other) {
    if (this.age < 8) {
      return;
    }
    if (!other.controllable) {
      return;
    }
    if (this.args.owner && !this.args.owner.args.gone) {
      other.args.ignore = 3;
      other.args.antiSkid = 8;
      other.args.x += this.args.direction;
      other.args.xSpeed = this.args.direction * 12;
      other.args.falling = true;
      // other.controllable && other.damage(this, 'fire');
    }
  }
}
exports.SpitSteam = SpitSteam;
});

;require.register("actor/Splats.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Splats = void 0;
var _Flickie = require("./Flickie");
var _Mixin = require("curvature/base/Mixin");
var _PointActor = require("./PointActor");
var _Patrol = require("../behavior/Patrol");
var _CanPop = require("../mixin/CanPop");
class Splats extends _Mixin.Mixin.from(_PointActor.PointActor, _CanPop.CanPop) {
  constructor() {
    var _this$args$patrolPaus, _this$args$patrolBeat, _this$args$patrolSpee;
    super(...arguments);
    this.behaviors.add(new _Patrol.Patrol());
    this.args.type = 'actor-item actor-splats';
    this.args.animation = 'standing';
    this.args.accel = 0.1;
    this.args.decel = 0.5;
    this.args.gSpeedMax = 5;
    this.args.jumpForce = 5;
    this.args.gravity = 0.5;
    this.args.width = 24;
    this.args.height = 48;
    this.willStick = false;
    this.stayStuck = false;
    this.args.patrolPause = (_this$args$patrolPaus = this.args.patrolPause) !== null && _this$args$patrolPaus !== void 0 ? _this$args$patrolPaus : 40;
    this.args.patrolBeat = (_this$args$patrolBeat = this.args.patrolBeat) !== null && _this$args$patrolBeat !== void 0 ? _this$args$patrolBeat : 140;
    this.args.patrolSpeed = (_this$args$patrolSpee = this.args.patrolSpeed) !== null && _this$args$patrolSpee !== void 0 ? _this$args$patrolSpee : 1;
  }
  update() {
    const direction = this.args.direction;
    const telegraph = this.args.shotTelegraph;
    const beat = this.args.patrolBeat;
    if (this.box) {
      if (this.args.moving && this.args.gSpeed) {
        this.box.setAttribute('data-animation', 'walking');
      } else {
        this.box.setAttribute('data-animation', 'standing');
      }
    }
    super.update();
    this.args.direction = Math.sign(this.args.xSpeed || this.args.gSpeed);
    if (!this.args.falling && !this.jumpTimer) {
      this.jumpTimer = this.onNextFrame(() => {
        this.args.ySpeed = Math.max(-this.ySpeedLast, -12) || -6;
        this.args.xSpeed = this.args.gSpeed;
        this.args.falling = true;
        this.jumpTimer = false;
        this.args.y -= 32;
      });
    }
  }
  effect(other) {
    super.effect(other);

    // this.viewport.spawn.add({object:new Flickie({
    // 	x: this.args.x,
    // 	y: this.args.y,
    // })});
  }

  get solid() {
    return false;
  }
  get isEffect() {
    return false;
  }
  // get controllable() { return true; }
}
exports.Splats = Splats;
});

;require.register("actor/Spring.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Spring = void 0;
var _LayerSwitch = require("./LayerSwitch");
var _PointActor = require("./PointActor");
var _BreakableBlock = require("./BreakableBlock");
var _Region = require("../region/Region");
var _Sfx = require("../audio/Sfx");
var _Projectile = require("./Projectile");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
const WillSpring = Symbol('WillSpring');
const WontSpring = Symbol('WontSpring');
class Spring extends _PointActor.PointActor {
  static fromDef(objDef) {
    const obj = super.fromDef(objDef);
    obj.args.angle = Number(obj.args.angle);
    obj.args.width = objDef.width || 32;
    obj.args.height = objDef.height || 32;
    return obj;
  }
  constructor() {
    var _this$args$static;
    super(...arguments);
    _defineProperty(this, "float", -1);
    _defineProperty(this, "keepAngle", true);
    _defineProperty(this, "template", `<div
		class = "point-actor actor-item [[type]] [[collType]] [[active]]"
		style = "
			display:[[display]];
			--angle:[[angle]];
			--airAngle:[[airAngle]];
			--ground-angle:[[groundAngle]];
			--height:[[height]];
			--width:[[width]];
			--x:[[x]];
			--y:[[y]];
		"
		data-colliding = "[[colliding]]"
		data-diagonal  = "[[diagonal]]"
		data-falling   = "[[falling]]"
		data-facing    = "[[facing]]"
		data-angle     = "[[angle|rad2deg]]"
		data-mode      = "[[mode]]"
	>
		<div
			data-color = "[[color]]"
			data-type  = "[[base]]"
			class      = "spring-pad"
			style = "--color:[[color]]deg"
		></div>
		<div class = "sprite"></div>
	</div>`);
    this.args.type = 'actor-item actor-spring';
    this.args.width = this.args.width || 32;
    this.args.height = this.args.height || 32;
    this.args.color = this.args.color || 0;
    this.args.static = (_this$args$static = this.args.static) !== null && _this$args$static !== void 0 ? _this$args$static : true;
    if (this.args.standingOn) {
      this.args.static = false;
      this.args.float = 0;
    }
    this.args.actingOn = new Set();
    this.args.blocked = false;
    this.holding = new Set();
  }
  updateEnd() {
    super.updateEnd();
    this.args.blocked = false;
    if (this.viewport.collisions.has(this)) {
      for (const [third, thirdType] of this.viewport.collisions.get(this)) {
        if (thirdType === -1 && !third.broken && third instanceof _BreakableBlock.BreakableBlock) {
          this.args.blocked = true;
        }
      }
    }
    if (this.args.blocked) {
      return false;
    }
    for (const other of this.holding) {
      this.springActor(other);
      this.viewport.onFrameOut(5, () => {
        this.holding.delete(other);
      });
    }
  }
  collideA(other, type) {
    if (other instanceof _Projectile.Projectile) {
      return false;
    }
    if (this.args.blocked) {
      return false;
    }
    if (other.carriedBy) {
      return false;
    }
    if (other.args.hangingFrom) {
      other.args.hangingFrom.unhook(other);
    }
    if (other[WillSpring] || other[WontSpring]) {
      return false;
    }
    if (other.args.static) {
      return false;
    }
    if (other instanceof this.constructor) {
      return false;
    }
    if (other instanceof _LayerSwitch.LayerSwitch) {
      return false;
    }
    super.collideA(other, type);
    if (this.args.actingOn.has(other)) {
      return false;
    }
    if (other.args.platform) {
      return false;
    }
    if (other instanceof _Region.Region) {
      return false;
    }
    other.args.falling = true;
    this.holding.add(other);
    if (other.controllable) {
      this.args.gSpeed = 0;
    }
    return false;
  }
  springActor(other) {
    if (other[WillSpring]) {
      return false;
    }
    _Sfx.Sfx.play('SPRING_HIT');
    const rounded = this.roundAngle(this.args.angle, 8, true);
    other.args.x = this.args.x + Math.cos(rounded) * 4;
    other.args.y = this.args.y + Math.sin(rounded) * 4;
    this.args.actingOn.add(other);
    this.viewport.onFrameOut(1, () => {
      this.args.active = true;
    });
    this.viewport.onFrameOut(5, () => {
      delete other[WillSpring];
      this.args.active = false;
      this.args.actingOn.delete(other);
    });
    if (other.noClip) {
      return false;
    }
    other.args.gSpeed = 0;
    other.args.xSpeed = 0;
    other.args.ySpeed = 0;

    // other.args.direction = Math.sign(this.args.gSpeed);

    other[WillSpring] = true;
    other.args.mercy = 0;

    // const rounded = this.roundAngle(this.args.angle, 8, true);

    if (this.viewport.settings.rumble && other.controller && other.controller.rumble) {
      other.controller.rumble({
        duration: 120,
        strongMagnitude: 1.0,
        weakMagnitude: 1.0
      });
      this.onTimeout(100, () => {
        other.controller.rumble({
          duration: 500,
          strongMagnitude: 0.0,
          weakMagnitude: 0.25
        });
      });
    }
    other.locked = 2;
    other.args.jumping = false;
    other.args.ignore = other.args.ignore || (other.args.falling ? 12 : 2);
    other.args.float = Math.max(2, other.args.float);
    this.viewport.onFrameOut(1, () => {
      other.args.float = Math.max(2, other.args.float);
      other.args.mode = 0;
      other.args.direction = Math.sign(xImpulse) || other.args.direction;
      other.args.flying = false;
      other.impulse(this.args.power, rounded, ![0, Math.PI].includes(this.args.angle) && Math.abs(Math.PI - this.args.angle) > 0.01);
    });
    const xImpulse = Number(Number(Math.cos(rounded) * 1).toFixed(3));
    const yImpulse = Number(Number(Math.sin(rounded) * 1).toFixed(3));
    const isRolling = other.args.rolling;
    if (![0, Math.PI].includes(this.args.angle) && Math.abs(Math.PI - this.args.angle) > 0.01 || other.args.falling || other.args.mode !== 0) {
      other.args.falling = true;
      other.args.mode = 0;
    } else {
      // this.viewport.onFrameOut(4, () => other.args.rolling = isRolling);
      // this.viewport.onFrameOut(3, () => other.args.rolling = isRolling);
      // this.viewport.onFrameOut(2, () => other.args.rolling = isRolling);
      this.viewport.onFrameOut(1, () => other.args.rolling = isRolling);
    }
    if (Math.abs(other.args.xSpeed) < 3 || Math.sign(other.args.xSpeed) !== Math.sign(xImpulse)) {
      other.args.xSpeed = xImpulse;
    } else {
      other.args.xSpeed += xImpulse;
    }
    if (Math.abs(other.args.ySpeed) < 3 || Math.sign(other.args.ySpeed) !== Math.sign(yImpulse)) {
      other.args.ySpeed = yImpulse;
    } else {
      other.args.ySpeed += yImpulse;
    }
    other.args.airAngle = this.args.angle;
    other.args.displayAngle = 0;
    other.args.groundAngle = 0;
    other.args.airAngle = -Math.PI / 2;
    other.args.mode = 0;
  }
  sleep() {
    this.args.actingOn.clear();
    this.args.active = false;
  }
  get canStick() {
    return false;
  }
  get solid() {
    return false;
  }
}
exports.Spring = Spring;
_defineProperty(Spring, "WontSpring", WontSpring);
});

;require.register("actor/SpringTurtle.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SpringTurtle = void 0;
var _Mixin = require("curvature/base/Mixin");
var _PointActor = require("./PointActor");
var _Patrol = require("../behavior/Patrol");
var _CanPop = require("../mixin/CanPop");
var _Ring = require("./Ring");
class SpringTurtle extends _Mixin.Mixin.from(_PointActor.PointActor, _CanPop.CanPop) {
  constructor() {
    var _this$args$patrolPaus, _this$args$patrolBeat, _this$args$patrolSpee;
    super(...arguments);
    this.behaviors.add(new _Patrol.Patrol());
    this.args.type = 'actor-item actor-spring-turtle';
    this.args.animation = 'standing';
    this.args.accel = 0.1;
    this.args.decel = 0.5;
    this.args.gSpeedMax = 3;
    this.args.gravity = 0.5;
    this.args.width = 24;
    this.args.height = 32;
    this.willStick = false;
    this.stayStuck = false;
    this.args.patrolPause = (_this$args$patrolPaus = this.args.patrolPause) !== null && _this$args$patrolPaus !== void 0 ? _this$args$patrolPaus : 10;
    this.args.patrolBeat = (_this$args$patrolBeat = this.args.patrolBeat) !== null && _this$args$patrolBeat !== void 0 ? _this$args$patrolBeat : 120;
    this.args.patrolSpeed = (_this$args$patrolSpee = this.args.patrolSpeed) !== null && _this$args$patrolSpee !== void 0 ? _this$args$patrolSpee : 1;
    this.args.lastSpring = 0;
  }
  onRendered(event) {
    super.onRendered(event);
    this.autoAttr.get(this.box)['data-spring'] = 'springing';
  }
  collideA(other, type) {
    if (other.args.static) {
      return;
    }
    if (type === 0 || other.args.falling) {
      this.ignores.set(other, 15);
      other.args.ySpeed = -20;
      other.args.xSpeed = 0;
      this.args.lastSpring = 10;
      return;
    }
    return super.collideA(other, type);
  }
  update() {
    super.update();
    if (this.args.lastSpring > 0) {
      this.args.lastSpring--;
    }
    this.args.springing = !!this.args.lastSpring;
    if (this.args.moving && this.args.gSpeed) {
      this.args.animation = 'walking';
    } else {
      this.args.animation = 'standing';
    }
    this.args.direction = Math.sign(this.args.gSpeed);
  }
  get solid() {
    return false;
  }
  get isEffect() {
    return false;
  }
}
exports.SpringTurtle = SpringTurtle;
});

;require.register("actor/Springboard.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Springboard = void 0;
var _PointActor = require("./PointActor");
var _Sfx = require("../audio/Sfx");
class Springboard extends _PointActor.PointActor {
  constructor() {
    super(...arguments);
    this.args.type = 'actor-item actor-springboard';
    this.args.width = 56;
    this.args.height = 16;
    this.args.animation = 'idle';
  }
  collideA(other, type) {
    if (this.args.ignore) {
      return;
    }
    let power = Math.min(1, Math.max(0, 1 + (-this.x + -26 + other.x) / 56));
    if (power < 0.5) {
      power *= 0.5;
    }
    this.args.animation = 'depressed';
    if (other.args.jumping && this.args.animation !== 'idle' && other.args.ySpeed < 0) {
      this.args.ignore = 6;
      this.args.animation = 'idle';
      const xSpeed = Math.max(other.args.gSpeed / 2, other.args.xSpeed);
      this.onNextFrame(() => {
        other.args.xSpeed = xSpeed;
        other.args.ySpeed += -12 * power;
      });
      _Sfx.Sfx.play('SPRING_HIT');
    }
    if (-this.x + other.x <= -26) {
      this.args.animation = 'idle';
    }
    if ((-this.x + other.x >= 26 || Math.abs(other.args.gSpeed) > 13) && other.args.mode === 0) {
      this.args.ignore = 6;
      const xSpeed = Math.max(other.args.gSpeed / 2, other.args.xSpeed);
      this.onNextFrame(() => {
        other.args.falling = true;
        other.args.xSpeed = xSpeed;
        other.args.ySpeed = -8;
      });
      this.viewport.onFrameOut(5, () => this.args.animation = 'idle');
      _Sfx.Sfx.play('SPRING_HIT');
    }
    if (other.args.ySpeed < 0) {
      this.args.animation = 'idle';
    }
  }
}
exports.Springboard = Springboard;
});

;require.register("actor/StarBalloon.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.StarBalloon = void 0;
var _Balloon = require("./Balloon");
var _GrapplePoint = require("./GrapplePoint");
var _Spring = require("./Spring");
class StarBalloon extends _Balloon.Balloon {
  constructor() {
    super(...arguments);
    this.args.type = 'actor-item actor-balloon actor-star-balloon';
    this.args.target = this.args.target || 0;
    this.args.gravity = 0.475;
    this[_Spring.Spring.WontSpring] = true;
  }
  update() {
    super.update();
    let weighted = false;
    if (this.hanging.has(_GrapplePoint.GrapplePoint)) for (const hooks of this.hanging.get(_GrapplePoint.GrapplePoint)) {
      if (hooks.hooked.size) {
        weighted = true;
      }
    }
    if (!this.popped) {
      const originY = this.def.get('y');
      if (!weighted) {
        if (Math.abs(this.args.y - originY) < 10) {
          this.args.ySpeed = Math.sin(this.viewport.args.frameId / 10) / 5;
          this.noClip = false;
        } else {
          this.noClip = true;
          if (!this.args.ySpeed) {
            this.args.ySpeed = 1;
          }
          if (this.args.ySpeed < 8) {
            this.args.ySpeed += 0.08;
          }
          if (this.args.y > originY) {
            this.args.y = originY;
            this.args.ySpeed = 0;
          }
        }
      } else {
        this.noClip = false;
        if (!this.args.ySpeed) {
          this.args.ySpeed = -1;
        }
        if (this.args.ySpeed > -8) {
          this.args.ySpeed -= 0.08;
        }
        if (this.args.y < this.args.target) {
          this.args.y = this.args.target;
          this.args.ySpeed = 0;
        }
      }
    }
    this.args.groundAngle = 0;
  }
  activate() {
    this.args.ySpeed = 2;
    this.viewport.onFrameOut(20, () => this.launched = true);
  }
  collideA(other) {
    if (!other.controllable || other.args.hangingFrom) {
      return false;
    }
    if (this.popped) {
      return false;
    }
    if (other.args.ySpeed >= 0 || other.args.spinning) {
      other.args.ySpeed = -14;
      this.pop();
    }
  }
  sleep() {
    if (!this.viewport) {
      return;
    }
    this.tags.sprite && this.tags.sprite.classList.remove('popped');
    this.args.x = this.def.get('x');
    this.args.y = this.def.get('y');
    this.args.xSpeed = 0;
    this.args.ySpeed = 0;
    this.args.float = -1;
    this.popped = this.launched = false;
    this.args.falling = true;
    this.viewport.setColCell(this);
    this.noClip = false;
  }
  damage() {
    this.pop();
  }
  pop() {
    const exploded = new CustomEvent('exploded', {
      detail: {
        actor: this
      }
    });
    this.dispatchEvent(exploded);
    this.tags.sprite.classList.add('popped');
    this.popped = true;
    this.args.ySpeed = -4;
    this.args.float = 0;
    this.noClip = true;
  }
}
exports.StarBalloon = StarBalloon;
});

;require.register("actor/StarPost.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.StarPost = void 0;
var _CharacterString = require("../ui/CharacterString");
var _PointActor = require("./PointActor");
var _Tag = require("curvature/base/Tag");
var _Sfx = require("../audio/Sfx");
var _Monitor = require("./Monitor");
var _RingMonitor = require("./monitor/RingMonitor");
var _SheildElectricMonitor = require("./monitor/SheildElectricMonitor");
var _SheildWaterMonitor = require("./monitor/SheildWaterMonitor");
var _SheildFireMonitor = require("./monitor/SheildFireMonitor");
var _Analytic = require("../lib/Analytic");
// import { Projectile } from '../actor/Projectile';

class StarPost extends _PointActor.PointActor {
  constructor() {
    var _this$args$active;
    super(...arguments);
    this.args.type = 'actor-item actor-star-post';
    this.args.width = 16;
    this.args.height = 48;
    this.args.active = (_this$args$active = this.args.active) !== null && _this$args$active !== void 0 ? _this$args$active : false;
    this.args.static = true;
    this.spinning = false;
  }
  update() {
    super.update();
    if (this.args.wasActive) {
      const monitor = new _RingMonitor.RingMonitor({
        direction: 0,
        ySpeed: -4,
        x: this.x - 10,
        y: this.y - 48
      });
      this.viewport.onFrameOut(12, () => {
        this.viewport.spawn.add({
          object: monitor
        });
      });
      this.args.wasActive = false;
    }
  }
  onRendered() {
    super.onRendered();
    this.headBox = new _Tag.Tag('<div class = "star-post-head-box">');
    this.head = new _Tag.Tag('<div class = "star-post-head">');
    this.headBox.appendChild(this.head.node);
    this.box.appendChild(this.headBox.node);
  }
  collideA(other) {
    super.collideA(other);
    if (other.args.owner) {
      other = other.args.owner;
    }
    if (!other.controllable && !other.occupant) {
      return;
    }
    if (!this.box) {
      return;
    }
    if (!this.args.active) {
      this.args.active = true;
      this.box.setAttribute('data-direction', other.args.direction);
      this.box.setAttribute('data-active', 'true');
      this.box.setAttribute('data-spin', 'true');
      _Sfx.Sfx.play('STARPOST_HIT');
      let throwSpeed = other.args.gSpeed || other.args.xSpeed;
      if (Math.abs(throwSpeed) > 20) {
        throwSpeed += 3;
      }
      const frameId = this.viewport.args.frameId + -this.viewport.args.startFrameId;
      const monitorClasses = other.args.rings > 50 ? [_RingMonitor.RingMonitor, _SheildFireMonitor.SheildFireMonitor, _SheildWaterMonitor.SheildWaterMonitor, _SheildElectricMonitor.SheildElectricMonitor] : [_RingMonitor.RingMonitor];

      // const monitorClass = monitorClasses[Math.floor( Math.random() * monitorClasses.length )];
      const monitorClass = monitorClasses[frameId % monitorClasses.length];
      const monitor = new monitorClass({
        direction: other.args.direction,
        decel: this.args.montiorDecel,
        xSpeed: throwSpeed,
        ySpeed: -6,
        x: this.x - 10,
        y: this.y - 48
      });
      this.viewport.storeCheckpoint(other.args.canonical, this.oid || this.args.id);
      this.viewport.spawn.add({
        object: monitor
      });

      // this.viewport.onFrameOut(360, () => {
      // 	this.box.setAttribute('data-active', 'false');
      // 	this.box.setAttribute('data-spin', 'false');
      // 	this.args.active = false;
      // });

      this.spinning = true;
      this.viewport.onFrameOut(36, () => {
        this.spinning = false;
      });
      if (typeof ga === 'function') {
        _Analytic.Analytic.report({
          eventCategory: 'starpost',
          eventAction: 'activated',
          eventLabel: `${this.viewport.args.actName}::${this.args.id}`
        });
      }

      // const time  = (this.viewport.args.frameId - this.viewport.args.startFrameId) / 60;
      // let minutes = String(Math.floor(Math.abs(time) / 60)).padStart(2,'0')
      // let seconds = String((Math.abs(time) % 60).toFixed(0)).padStart(2,'0');

      // const neg = time < 0 ? '-' : '';

      // if(neg)
      // {
      // 	minutes = Number(minutes);
      // }

      // const yardsPerFrame = other.args.gSpeed / 32;
      // const feetPerSecond = yardsPerFrame * 60 * 3;

      // this.args.charStrings = [
      // 	new CharacterString({value: `Speed: ${feetPerSecond.toFixed(3)} ft/s`})
      // 	, new CharacterString({value: `Time: ${neg}${minutes}:${seconds}`})
      // 	, new CharacterString({value: `Score: ${other.args.score}`})
      // 	, new CharacterString({value: `Rings: ${other.args.rings}`})
      // ];
    }
    // else if(other instanceof Projectile && !this.spinning)
    // {
    // 	this.box.setAttribute('data-direction', other.args.direction);
    // 	this.box.setAttribute('data-spin', 'false');

    // 	if(this.viewport.args.audio && this.sample)
    // 	{
    // 		this.sample.currentTime = 0;
    // 		this.sample.play();
    // 	}

    // 	this.onTimeout(0, () => this.box.setAttribute('data-spin', 'true'));

    // 	this.spinning = true;

    // 	this.onTimeout(600, () => this.spinning = false);
    // }
  }

  get solid() {
    return false;
  }
}
exports.StarPost = StarPost;
});

;require.register("actor/SteelCrate.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SteelCrate = void 0;
var _Block = require("./Block");
var _BreakableBlock = require("./BreakableBlock");
var _Projectile = require("./Projectile");
class SteelCrate extends _BreakableBlock.BreakableBlock {
  constructor() {
    var _this$args$static;
    super(...arguments);
    this.args.type = 'actor-item actor-breakable-block actor-steel-crate';
    this.args.width = 64;
    this.args.height = 64;
    this.args.static = (_this$args$static = this.args.static) !== null && _this$args$static !== void 0 ? _this$args$static : false;
  }
  collideA(other, type) {
    if (other instanceof _Block.Block) {
      return true;
    }
    if (other instanceof _Projectile.Projectile && !this.broken) {
      this.break();
      return true;
    }
    if (other.args.bouncing && !this.broken) {
      this.break();
      return true;
    }
    if (other.punching && !this.broken) {
      this.break();
      return false;
    }
    if (other.args.rolling && !this.broken) {
      return true;
    }
    if (type === 0 && other.controllable) {
      return true;
    }
    if (type !== 1 && type !== 3 || other.y <= this.y - this.args.height) {
      return true;
    }
    if (!this.viewport) {
      return false;
    }
    if (type === -1 || other.args.rolling) {
      return super.collideA(other, type);
    }
    return true;
  }
  setTile() {
    this.args.spriteSheet = '/custom/steel-crate.png';
  }
}
exports.SteelCrate = SteelCrate;
});

;require.register("actor/StoneAltar.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.StoneAltar = void 0;
var _Block = require("./Block");
var _WindStone = require("./WindStone");
class StoneAltar extends _Block.Block {
  constructor() {
    let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let parent = arguments.length > 1 ? arguments[1] : undefined;
    super(args, parent);
    this.args.float = -1;
    this.args.static = true;
    this.args.hidden = true;
    this.args.platform = true;
    this.args.activated = false;
  }
  update() {
    super.update();
    this.args.active = false;
    for (const actor of this.standingUnder) {
      if (!(actor instanceof _WindStone.WindStone)) {
        continue;
      }
      actor.args.inPlace = true;
      this.args.active = true;
    }
  }
}
exports.StoneAltar = StoneAltar;
});

;require.register("actor/Stopper.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Stopper = void 0;
var _BreakableBlock = require("./BreakableBlock");
class Stopper extends _BreakableBlock.BreakableBlock {
  constructor() {
    let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let parent = arguments.length > 1 ? arguments[1] : undefined;
    super(args, parent);
    this.args.type = 'actor-item actor-breakable-block actor-stopper';
    this.args.height = 16;
    this.args.float = -1;
  }
  collideA(other, type) {
    if (other.isVehicle) {
      return true;
    }
    if (this.broken) {
      return false;
    }
    if (!this.broken && type === 2 || Math.abs(other.args.ySpeed) > 20 && type === 0) {
      if (other.args.ySpeed > 0 || other.ySpeedLast > 0) {
        other.args.groundAngle = 0;
        other.args.x = this.args.x;
        other.args.xSpeed = 0;
        other.args.ySpeed = Math.abs(other.args.gSpeed);
        other.args.falling = true;
        other.args.bouncing = false;
        other.args.jumping = false;
        other.args.mode = 0;
        this.break();
        return false;
      }
      return true;
    } else if (other.args.jumping && other.args.ySpeed > 0 || other.args.rolling) {
      other.args.x = this.args.x;
      other.args.y = this.args.y;
      this.viewport.onFrameOut(1, () => {
        other.args.groundAngle = 0;
        other.args.falling = true;
        other.args.animation = 'rolling';
        other.args.x = this.args.x;
        other.args.gSpeed = 0;
        other.args.xSpeed = 0;
        other.args.ySpeed = Math.abs(other.args.gSpeed);
      });
      if (other.args.jumping) {
        other.args.gSpeed = 0;
        other.args.xSpeed = 0;
        other.args.ySpeed = 0;
        other.args.ignore = 30;
        other.args.float = 30;
        this.viewport.onFrameOut(30, () => {
          other.args.xSpeed = 0;
          other.args.ySpeed = 10;
        });
      }
      return super.collideA(other, type);
    }
    return true;
  }
}
exports.Stopper = Stopper;
});

;require.register("actor/SuperRing.js", function(exports, require, module) {
// import { PointActor } from './PointActor';

// const THREE         = require('three')
// const ColladaLoader = require('three-collada-loader');

// export class SuperRing extends PointActor
// {
// 	constructor(...args)
// 	{
// 		super(...args);

// 		this.args.type = 'actor-super-ring actor-item';

// 		this.args.width  = 64;
// 		this.args.height = 64;
// 		this.args.float  = -1;
// 		this.args.gone   = false;

// 		this.args.xRot = 0;
// 		this.args.yRot = 0;
// 		this.args.zRot = 0;

// 		this.args.speed = 4;

// 		this.leaving = new WeakSet;

// 		this.args.xOff = 0;
// 		this.args.yOff = 0;
// 	}

// 	onAttached()
// 	{
// 		this.initRenderer();

// 		this.pinch(0);
// 	}

// 	initRenderer()
// 	{
// 		this.cameraRear = new THREE.PerspectiveCamera(12.5, undefined, 10, 100);
// 		this.cameraFore = new THREE.PerspectiveCamera(12.5, undefined, 1, 10.1);

// 		const modelUrl   = '/models/ring.dae';

// 		const specular   = 0xBBBBBB;
// 		const color      = 0xBBBB00;
// 		const outline    = 0x000000;

// 		// const finalX     = qTurn / 8 * 7;

// 		const emissive   = 0x999900;
// 		const lineColor  = 0x0000AA;

// 		const colladaLoader = new ColladaLoader;

// 		colladaLoader.load(modelUrl, response => {
// 			const geometry = response.dae.geometries['root-mesh'].mesh.geometry3js;

// 			this.cameraRear.position.z = 10;
// 			this.cameraRear.position.x = 0;
// 			this.cameraRear.position.y = 0;

// 			this.cameraFore.position.z = 10;
// 			this.cameraFore.position.x = 0;
// 			this.cameraFore.position.y = 0;

// 			this.scene = new THREE.Scene();

// 			const edgeGeometry = new THREE.EdgesGeometry(geometry);

// 			const goldMaterial = new THREE.MeshPhongMaterial({
// 				side:          THREE.FrontSide
// 				, transparent: true
// 				, skinning:    true
// 				, emissive
// 				, specular
// 				, color
// 			});

// 			const blackMaterial = new THREE.MeshBasicMaterial({
// 				color: outline
// 				, side: THREE.BackSide
// 			});

// 			this.mainMesh = new THREE.Mesh(geometry, goldMaterial);
// 			this.outlineMesh = new THREE.Mesh(geometry, blackMaterial);
// 			this.inlineMesh = new THREE.Mesh(geometry, blackMaterial);

// 			this.outlineMesh.scale.multiplyScalar(1.075);
// 			this.inlineMesh.scale.multiplyScalar(0.925);

// 			this.wireMaterial = new THREE.LineBasicMaterial({
// 				depthTest:   true
// 				, linewidth:   1.25
// 				, color:       lineColor
// 				, transparent: true
// 				, opacity:     0.125
// 			} );

// 			this.wireframe = new THREE.LineSegments(edgeGeometry, this.wireMaterial);

// 			const light = new THREE.DirectionalLight(0xFFFFFF, 0.333);
// 			light.position.set(1, 1.75, 0).normalize();

// 			light.target = this.wireframe;

// 			const light2 = new THREE.DirectionalLight(0xFFFFFF);
// 			light2.position.set(0.75, -1, 0).normalize();

// 			light.target = this.wireframe;

// 			this.scene.add(this.mainMesh);
// 			this.scene.add(this.outlineMesh);
// 			this.scene.add(this.inlineMesh);
// 		 	this.scene.add(this.wireframe);

// 			this.scene.add(light);

// 			this.rendererRear = new THREE.WebGLRenderer({
// 				antialias: true
// 				, alpha:   true
// 			});

// 			this.rendererFore = new THREE.WebGLRenderer({
// 				antialias: true
// 				, alpha:   true
// 			});

// 			this.resizeRenderer();

// 			const parent = this.tags.sprite.node.parentNode;

// 			parent.appendChild(this.rendererRear.domElement);
// 			parent.appendChild(this.rendererFore.domElement);

// 			this.rendererRear.render(this.scene, this.cameraRear);
// 			this.rendererFore.render(this.scene, this.cameraFore);
// 		});

// 	}

// 	resizeRenderer()
// 	{
// 		const parent    = this.tags.sprite.node;

// 		const width     = this.args.width;  //parent.clientWidth  || parent.offsetWidth || width || 0;
// 		const height    = this.args.height; //parent.clientHeight || parent.offsetHeight || height || 0;
// 		const longAxis  = width > height ? width : height;
// 		const shortAxis = width < height ? width : height;

// 		this.cameraRear.aspect = 1;
// 		this.cameraFore.aspect = 1;

// 		this.rendererRear.setSize(shortAxis,  shortAxis);
// 		this.rendererFore.setSize(shortAxis,  shortAxis);

// 		// parent.style.setProperty('--long-axis', longAxis + 'px');
// 		// parent.style.setProperty('--short-axis', shortAxis + 'px');

// 		this.wireMaterial.linewidth = shortAxis / 750;
// 	}

// 	update()
// 	{
// 		super.update();

// 		if(!this.wireframe)
// 		{
// 			return;
// 		}

// 		if(this.caught)
// 		{
// 			this.wireframe.material.opacity = 0.125;

// 			const caught = this.caught;

// 			caught.args.xSpeed = 0;
// 			caught.args.ySpeed = 0;

// 			if(this.caught.yAxis > 0)
// 			{
// 				this.drop();
// 			}
// 			else if(this.caught.yAxis < 0)
// 			{
// 				this.wireframe.material.opacity = 0.25;

// 				this.args.speed++;

// 				caught.args.x = this.args.x;
// 				caught.args.y = this.args.y - 16;
// 			}
// 			else
// 			{
// 				const toX = this.args.x;
// 				const toY = this.args.y - 16;

// 				const speed = 12;

// 				if(caught.args.x !== toX)
// 				{
// 					caught.args.x += Math.sign(toX - caught.args.x) * this.args.speed;
// 				}

// 				if(caught.args.y !== toY)
// 				{
// 					caught.args.y += Math.sign(toY - caught.args.y) * this.args.speed;
// 				}

// 				if(Math.abs(caught.args.x - toX) < speed)
// 				{
// 					caught.args.x = toX;
// 				}

// 				if(Math.abs(caught.args.y - toY) < speed)
// 				{
// 					caught.args.y = toY;
// 				}
// 			}

// 			if(this.args.speed < 5)
// 			{
// 				this.args.speed += 0.25;
// 			}

// 			if(this.args.speed > 5)
// 			{
// 				this.args.speed -= 0.5;
// 			}
// 		}
// 		else
// 		{
// 			this.wireframe.material.opacity = 0.1;

// 			if(this.args.speed > 4)
// 			{
// 				this.args.speed -= 0.125;
// 			}
// 		}

// 		const yRot = (this.args.yRot / 60) % (Math.PI * 2);

// 		if(yRot > (Math.PI / 2 - 0.125) && yRot < (Math.PI / 2 + 0.125))
// 		{
// 			if(this.args.speed > 20)
// 			{
// 				this.onTimeout(500, ()=>this.drop());
// 			}
// 		}

// 		// this.wireframe.rotation.x
// 		//	= this.mainMesh.rotation.x
// 		//	= this.outlineMesh.rotation.x
// 		//	= this.inlineMesh.rotation.x
// 		//	= this.args.xRot / 200;

// 		this.wireframe.rotation.y
// 			= this.mainMesh.rotation.y
// 			= this.outlineMesh.rotation.y
// 			= this.inlineMesh.rotation.y
// 			= yRot;

// 		this.wireframe.rotation.z
// 			= this.mainMesh.rotation.z
// 			= this.outlineMesh.rotation.z
// 			= this.inlineMesh.rotation.z
// 			= this.args.zRot / 60;

// 		this.args.yRot += this.args.speed;
// 		// this.args.xRot++;
// 		this.args.zRot++;

// 		this.onTimeout(0, () => {
// 			this.rendererRear.render(this.scene, this.cameraRear);
// 			this.rendererFore.render(this.scene, this.cameraFore);
// 		});
// 	}

// 	collideA(other)
// 	{
// 		super.collideA(other);

// 		if(!other.controllable || other.args.flying)
// 		{
// 			if(this.leaving.delete(other))
// 			{
// 				return;
// 			}
// 			return;
// 		}

// 		if(this.leaving.has(other))
// 		{
// 			return;
// 		}

// 		if(this.caught)
// 		{
// 			this.caught.args.xSpeed = (Math.sign(other.args.xSpeed) * 3) || 3;

// 			this.leaving.add(this.caught);
// 		}

// 		if(this.caught !== other)
// 		{
// 			this.drop();

// 			if(this.leaving.has(other))
// 			{
// 				return;
// 			}

// 			this.onTimeout(500, () => {

// 				if(this.leaving.has(other))
// 				{
// 					return;
// 				}

// 				this.caught = other

// 			});

// 			this.grab();
// 		}

// 		other.args.xSpeed = 0;
// 		other.args.ySpeed = 0;
// 		other.args.float  = -1;
// 	}

// 	drop()
// 	{
// 		if(this.caught)
// 		{
// 			const caught = this.caught;

// 			this.pinchFilterBg.classList.add('grabbing-start');
// 			this.pinch(-50, 15);

// 			this.leaving.add(caught);

// 			if(this.startGrab)
// 			{
// 				clearTimeout(this.startDrop);
// 				this.startDrop = false;
// 			}

// 			this.startDrop = this.onTimeout(150, () => {
// 				this.pinchFilterBg.classList.add('grabbing');

// 				caught.args.float = 0;
// 				caught.args.ySpeed = 10;

// 				if(this.dropDone)
// 				{
// 					clearTimeout(this.dropDone);
// 					this.dropDone = false;
// 				}

// 				this.dropDone = this.onTimeout(650, () => {
// 					this.pinchFilterBg.classList.remove('grabbing-start');
// 					this.pinchFilterBg.classList.remove('grabbing');
// 					this.pinch(0, 0);
// 				});

// 				this.caught = null;
// 			});

// 			this.onTimeout(1500, () => {
// 				this.leaving.delete(caught);
// 			});
// 		}
// 	}

// 	grab()
// 	{
// 		if(this.pinchFilterFg)
// 		{
// 			this.pinchFilterFg.classList.add('grabbing-start');
// 			this.onTimeout(150, () => {
// 				this.pinchFilterFg.classList.add('grabbing');

// 				this.pinch(0, 100);

// 				this.onTimeout(650, () => {
// 					this.pinch(0, 0);

// 					this.pinchFilterFg.classList.remove('grabbing-start');
// 					this.pinchFilterFg.classList.remove('grabbing');
// 				});
// 			});
// 		}
// 	}
// }
"use strict";
});

;require.register("actor/Switch.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Switch = void 0;
var _PointActor = require("./PointActor");
var _Sfx = require("../audio/Sfx");
var _CharacterString = require("../ui/CharacterString");
class Switch extends _PointActor.PointActor {
  constructor() {
    var _this$args$threshold;
    super(...arguments);
    this.args.type = 'actor-item actor-switch';
    this.args.width = 32;
    this.args.height = 10;
    this.args.label = '';
    this.args.bindTo('label', v => {
      if (!v) {
        this.args.charStrings = [];
      } else {
        this.label = this.label || new _CharacterString.CharacterString({
          value: ''
        });
        this.label.args.value = v;
        this.args.charStrings = [this.label];
      }
    });
    this.removeTimer = null;
    this.args.active = false;
    this.args.latch = this.args.latch || false;
    this.activator = null;
    this.args.bindTo('active', v => {
      this.box && this.box.setAttribute('data-active', v ? 'true' : 'false');
    });
    this.args.threshold = (_this$args$threshold = this.args.threshold) !== null && _this$args$threshold !== void 0 ? _this$args$threshold : 100;
    this.ignore = 0;
    this.args.activeTime = 0;
  }
  update() {
    super.update();
    if (this.ignore > 0) {
      this.ignore--;
      return;
    }
    if (this.args.latch) {
      return;
    }
    if (this.args.active) {
      this.args.activeTime++;
    } else {
      this.args.activeTime = 0;
    }
    if (this.args.activeTime > 2 && (!this.activator || this.activator.args.standingOn !== this || this.activator.y === this.args.y)) {
      this.args.active = false;
      this.activator = null;
    }
  }
  updateEnd() {
    super.updateEnd();
    if (this.args.active) {
      // this.args.height = this.height + -6;
    } else {
      // this.args.height = this.height;
    }
  }
  onRendered(event) {
    super.onRendered(event);
    this.box = this.findTag('div');
  }
  collideA(other, type) {
    // if(!other.args.falling || other.args.y >= this.args.y)
    if (other.args.y >= this.args.y) {
      return false;
    }
    if (this.activator === other && other.y > this.args.y) {
      this.ignore = 8;
      return true;
    }
    if (other.args.ySpeed < 0) {
      // if(other.args.ySpeed === 0 && other.y > this.y)
      // {
      // 	return true;
      // }

      return false;
    }
    if (this.args.active && other.y < this.y) {
      return true;
    }
    if (other.isEffect || other.isRegion) {
      return;
    }
    if (other.y > this.y - this.args.height + 0) {
      return false;
    }
    if (this.args.threshold && other.args.weight < this.args.threshold) {
      return true;
    }
    other.onRemove(() => this.activator = null);
    if (other.y <= this.y - this.args.height) {
      if (!this.args.active) {
        this.activate(other);
      }
      this.ignore = 8;
      this.args.active = true;
      this.activator = other;
      if (other.args.falling && other.args.ySpeed > 1) {
        other.args.ySpeed = 1;
      }
      if (this.activator && Math.abs(this.activator.args.x - this.args.x) > 4 && this.args.activeTime < 1) {
        const originalXSpeed = this.activator.args.xSpeed;

        // this.activator.args.x -= (this.activator.args.x - this.args.x);
        // this.activator.args.xSpeed = 0;
        // this.activator.args.groundAngle = 0;

        this.viewport.onFrameOut(1, () => {
          this.activator.args.gSpeed = originalXSpeed;
          this.activator.args.groundAngle = 0;
        });
      }

      // if(type === 1 || type === 3)
      // {
      // 	return false;
      // }

      return true;
    }
    return false;
  }
  activate(other) {
    this.beep();
    if (this.args.target && this.viewport.actorsById[this.args.target]) {
      const target = this.viewport.actorsById[this.args.target];
      target.activate(other, this);
    }
    if (this.args.destroyLayer) {
      const layerId = this.args.destroyLayer;
      const layer = this.viewport.args.layers[layerId];
      if (layer) {
        layer.args.destroyed = true;
      }
    }
    if (this.args.water) {
      var _this$args$fillSpeed, _this$args$drainSpeed;
      const water = this.viewport.actorsById[this.args.water];
      const level = this.viewport.objDefs.get(this.args.setPoint);
      water.target = Number(water.y || 0) - Number(level.y || 0);
      water.args.fillSpeed = (_this$args$fillSpeed = this.args.fillSpeed) !== null && _this$args$fillSpeed !== void 0 ? _this$args$fillSpeed : water.args.fillSpeed;
      water.args.drainSpeed = (_this$args$drainSpeed = this.args.drainSpeed) !== null && _this$args$drainSpeed !== void 0 ? _this$args$drainSpeed : water.args.drainSpeed;
    }
    const spawnPoint = this.viewport.objDefs.get(this.args.point);
    const spawnType = this.viewport.objectPalette[this.args.spawn];
    if (spawnType && spawnPoint) {
      this.viewport.spawn.add({
        object: new spawnType({
          x: spawnPoint.x,
          y: spawnPoint.y
        })
      });
    }
    this.args.active = true;
  }
  beep() {
    if (!this.viewport) {
      return;
    }
    if (this.args.silent) {
      return;
    }
    _Sfx.Sfx.play('SWITCH_HIT');
  }
  sleep() {
    if (!this.viewport || !this.def) {
      return;
    }
    this.args.x = this.def.get('x');
    this.args.y = this.def.get('y');
    this.onNextFrame(() => {
      this.args.x = this.def.get('x');
      this.args.y = this.def.get('y');
      this.viewport.setColCell(this);
      this.args.xSpeed = 0;
      this.args.ySpeed = 0;
      this.args.pushed = 0;
      this.args.float = 0;
    });
  }
  get solid() {
    return this.args.active;
  }
}
exports.Switch = Switch;
});

;require.register("actor/Tails.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Tails = void 0;
var _PointActor = require("./PointActor");
var _Tag = require("curvature/base/Tag");
var _Spring = require("./Spring");
var _SkidDust = require("../behavior/SkidDust");
var _Spindash = require("../behavior/Spindash");
var _Crouch = require("../behavior/Crouch");
var _LookUp = require("../behavior/LookUp");
var _EmeraldHalo = require("../behavior/EmeraldHalo");
var _SuperForm = require("../behavior/SuperForm");
var _Color = require("../lib/Color");
var _Png = require("../sprite/Png");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class Tails extends _PointActor.PointActor {
  constructor() {
    super(...arguments);
    _defineProperty(this, "png", new _Png.Png('/Sonic/tails.png'));
    _defineProperty(this, "pngTails", new _Png.Png('/Sonic/tails-tails.png'));
    this.args.canonical = 'Tails';
    this.behaviors.add(new _SkidDust.SkidDust());
    this.behaviors.add(new _Spindash.Spindash());
    this.behaviors.add(new _Crouch.Crouch());
    this.behaviors.add(new _LookUp.LookUp());
    this.behaviors.add(new _SuperForm.SuperForm());
    this.behaviors.add(new _EmeraldHalo.EmeraldHalo());
    this.args.type = 'actor-item actor-tails';
    this.accelNormal = 0.12;
    this.accelSuper = 0.24;
    this.args.accel = this.accelNormal;
    this.args.decel = 0.4;
    this.args.flySpeedMax = 25;
    this.gSpeedMaxNormal = 18;
    this.gSpeedMaxSuper = 20;
    this.gSpeedMaxHyper = 23;
    this.jumpForceNormal = 11;
    this.jumpForceSuper = 13;
    this.jumpForceHyper = 15;
    this.args.maxFlyTimeNormal = 350;
    this.args.maxFlyTimeSuper = 600;
    this.args.maxFlyTimeHyper = Infinity;
    this.args.flyBoostNormal = -1.5;
    this.args.flyBoostSuper = -1.75;
    this.args.flyBoostHyper = -2.0;
    this.args.flyBoost = this.args.flyBoostNormal;
    this.args.maxFlyTime = this.args.maxFlyTimeNormal;
    this.args.gSpeedMax = this.gSpeedMaxNormal;
    this.args.jumpForce = this.jumpForceNormal;
    this.args.gravity = 0.5;
    this.args.normalGravity = this.args.gravity;
    this.args.slowGravity = this.args.gravity * 0.125;
    this.args.width = 16;
    this.args.height = 34;
    this.args.weight = 80;
    this.args.normalHeight = 32;
    this.args.rollingHeight = 28;
    ;
    this.willStick = false;
    this.stayStuck = false;
    this.flyTime = 0;
    this.sparks = new Set();
    this.spriteSheet = '/Sonic/tails.png';
    this.args.spriteSheet = `url('${this.args.spriteSheet}')`;
    this.spriteSheetTails = '/Sonic/tails-tails.png';
    this.args.spriteSheetTails = `url('${this.spriteSheetTails}')`;
    this.costumes = {
      SkyCamo: {
        h: 120,
        s: 0.8,
        v: 1.00
      },
      Copper: {
        h: -45,
        s: 1.0,
        v: 1.00
      },
      Patina: {
        h: 90,
        s: 0.8,
        v: 0.85
      },
      Arctic: {
        h: 0,
        s: 0.0,
        v: 0.85
      }
    };
    this.args.minRingsSuper = 40;
    this.args.minRingsHyper = 60;
    this.transformTime = 0;
  }
  onRendered(event) {
    super.onRendered(event);
    if (this.tails) {
      return;
    }
    this.tails = new _Tag.Tag('<div class = "tails-tails">');
    this.sprite.appendChild(this.tails.node);
    this.flyingSound = new Audio('/Sonic/tails-flying.wav');
    this.flyingSound.volume = 0.35 + Math.random() * -0.3;
    this.flyingSound.loop = true;
    this.rotatedSpriteSheet = this.spriteSheet;
    this.rotatedSpriteSheetTails = this.spriteSheetTails;
    this.autoStyle.get(this.box)['--sprite-sheet'] = 'spriteSheet';
    this.autoStyle.get(this.box)['--sprite-sheet-tails'] = 'spriteSheetTails';
    const updateSprite = () => {
      var _this$viewport$custom, _this$viewport$custom2, _this$viewport$custom3;
      let h = Number((_this$viewport$custom = this.viewport.customColor.h) !== null && _this$viewport$custom !== void 0 ? _this$viewport$custom : 0);
      let s = Number((_this$viewport$custom2 = this.viewport.customColor.s) !== null && _this$viewport$custom2 !== void 0 ? _this$viewport$custom2 : 1);
      let v = Number((_this$viewport$custom3 = this.viewport.customColor.v) !== null && _this$viewport$custom3 !== void 0 ? _this$viewport$custom3 : 1);
      this.rotateMainColor(h, s, v).then(() => {
        this.box.node.style.setProperty('--sprite-sheet', `url(${this.args.rotatedSpriteSheet})`);
        this.box.node.style.setProperty('--sprite-sheet-tails', `url(${this.args.rotatedSpriteSheetTails})`);
      });
    };
    const debindH = this.viewport.customColor.bindTo('h', updateSprite, {
      wait: 0
    });
    const debindS = this.viewport.customColor.bindTo('s', updateSprite, {
      wait: 0
    });
    const debindV = this.viewport.customColor.bindTo('v', updateSprite, {
      wait: 0
    });
    this.onRemove(debindH);
    this.onRemove(debindS);
    this.onRemove(debindV);
    if (this.viewport.args.mainPallet && this.costumes[this.viewport.args.mainPallet]) {
      Object.assign(this.viewport.customColor, this.costumes[this.viewport.args.mainPallet]);
    }
    this.superSheet = 0;
    const superColorsA = {
      'ffb691': 'efefef',
      'fcb400': 'ebebeb',
      'fc9000': 'd4d4d4',
      'b46c48': 'b8b8b8'
    };
    const superColorsB = {
      'ffb691': 'fff79e',
      'fcb400': 'fefb00',
      'fc9000': 'fef500',
      'b46c48': 'ceae30'
    };
    if (!this.superSpriteSheetLoaders) {
      this.superSpriteSheetLoaders = this.png.ready.then(() => this.superSpriteSheets = [this.png.recolor(superColorsA).toUrl(), this.png.recolor(superColorsB).toUrl()]);
      this.superSpriteSheetTailsLoaders = this.pngTails.ready.then(() => this.superSpriteSheetsTails = [this.pngTails.recolor(superColorsA).toUrl(), this.pngTails.recolor(superColorsB).toUrl()]);
    }
    this.hyperSheet = 0;
    const hyperColorsRed = {
      'ffb691': 'fcfcfc',
      'fcb400': 'fcfcfc',
      'fc9000': 'fcd8d8',
      'b46c48': 'fcb4b4'
    };
    const hyperColorsPurple = {
      'ffb691': 'fcfcfc',
      'fcb400': 'fcfcfc',
      'fc9000': 'fcd8fc',
      'b46c48': 'd8b4d8'
    };
    const hyperColorsCyan = {
      'ffb691': 'd8fcfc',
      'fcb400': 'fcfcfc',
      'fc9000': 'b4d8fc',
      'b46c48': '90b4fc'
    };
    const hyperColorsBlue = {
      'ffb691': 'd8d8ff',
      'fcb400': 'b4b4d8',
      'fc9000': 'a4a4d8',
      'b46c48': '6c6cb4'
    };
    const hyperColorsGreen = {
      'ffb691': 'd8fcfc',
      'fcb400': 'd8fcd8',
      'fc9000': 'b4fcb4',
      'b46c48': '00fc24'
    };
    const hyperColorsYellow = {
      'ffb691': 'd8fcfc',
      'fcb400': 'd8fcb4',
      'fc9000': 'd8fc48',
      'b46c48': 'd8d800'
    };
    const hyperColorsWhite = {
      'ffb691': 'ffffff',
      'fcb400': 'fcfcfc',
      'fc9000': 'd8d8d8',
      'b46c48': 'b4b4b4'
    };
    if (!this.hyperSpriteSheetLoader) {
      this.hyperSpriteSheetLoader = this.png.ready.then(() => this.hyperSpriteSheets = [this.png.recolor(hyperColorsRed).toUrl(), this.png.recolor(hyperColorsCyan).toUrl(), this.png.recolor(hyperColorsPurple).toUrl(), this.png.recolor(hyperColorsWhite).toUrl(), this.png.recolor(hyperColorsGreen).toUrl(), this.png.recolor(hyperColorsBlue).toUrl(), this.png.recolor(hyperColorsYellow).toUrl()]);
      this.hyperSpriteSheetLoaderTails = this.pngTails.ready.then(() => this.hyperSpriteSheetsTails = [this.pngTails.recolor(hyperColorsRed).toUrl(), this.pngTails.recolor(hyperColorsCyan).toUrl(), this.pngTails.recolor(hyperColorsPurple).toUrl(), this.pngTails.recolor(hyperColorsWhite).toUrl(), this.pngTails.recolor(hyperColorsGreen).toUrl(), this.pngTails.recolor(hyperColorsBlue).toUrl(), this.pngTails.recolor(hyperColorsYellow).toUrl()]);
    }
  }
  startle() {
    super.startle();
    this.args.animation = 'startle';
    this.onNextFrame(() => this.args.animation = 'startle');
  }
  updateStart() {
    if (this.args.grinding && this.args.falling && this.args.ySpeed > 0) {
      this.args.animation = 'springdash';
      this.args.grinding = false;
    }
    super.updateStart();
    if (this.args.dead) {
      this.args.animation = 'dead';
      return;
    }
  }
  update() {
    if (this.isSuper) {
      if (this.isHyper) {
        if (this.viewport.args.frameId % 15 === 0) {
          this.hyperSheet++;
          if (this.hyperSheet >= this.hyperSpriteSheets.length) {
            this.hyperSheet = 0;
          }
        }
        this.hyperSpriteSheet = this.hyperSpriteSheets[this.hyperSheet];
        this.hyperSpriteSheetTails = this.hyperSpriteSheetsTails[this.hyperSheet];
        this.args.spriteSheet = `url(${this.hyperSpriteSheet})`;
        this.args.spriteSheetTails = `url(${this.hyperSpriteSheetTails})`;
      } else {
        if (this.viewport.args.frameId % 15 === 0) {
          this.superSheet++;
          if (this.superSheet >= this.superSpriteSheets.length) {
            this.superSheet = 0;
          }
        }
        this.superSpriteSheet = this.superSpriteSheets[this.superSheet];
        this.superSpriteSheetTails = this.superSpriteSheetsTails[this.superSheet];
        this.args.spriteSheet = `url(${this.superSpriteSheet})`;
        this.args.spriteSheetTails = `url(${this.superSpriteSheetTails})`;
      }
      const tick = this.isHyper ? 30 : 60;
      if (this.viewport.args.frameId % tick === 0) {
        if (this.args.rings < 2) {
          this.isHyper = false;
          this.setProfile();
        }
        if (this.args.rings > 0) {
          this.args.rings--;
        } else {
          this.isSuper = false;
          this.isHyper = false;
          this.setProfile();
        }
      }
    }
    this.args.isSuper = this.isSuper;
    this.args.isHyper = this.isHyper;
    if (!this.args.falling && this.groundTime > 3 || this.args.falling && this.fallTime > 90) {
      this.args.twistRamp = false;
    }
    if (this.yAxis === 0) {
      this.args.lookTime = 0;
      this.args.cameraBias = 0;
    }
    const falling = this.args.falling;
    if (!this.viewport) {
      return;
    }
    if (this.args.bouncing || this.args.wasHanging) {
      this.args.flying = false;
      if (this.flyingSound) {
        this.flyingSound.pause();
      }
    }
    if (this.args.flying) {
      this.args.gravity = this.args.slowGravity;
      this.args.ySpeed = Math.min(3, this.args.ySpeed);
    } else {
      this.args.gravity = this.args.normalGravity;
    }
    if (this.viewport.args.audio && this.flyingSound) {
      if (!this.flyingSound.paused) {
        this.flyingSound.volume = 0.35 + Math.random() * -0.3;
      }
      if (this.flyingSound.currentTime > 0.2) {
        this.flyingSound.currentTime = 0.0;
      }
    }
    if (!this.box) {
      super.update();
      return;
    }
    if (this.args.tailFlyCoolDown > 0) {
      this.args.tailFlyCoolDown--;
    }
    if (this.args.tailFlyCoolDown < 0) {
      this.args.tailFlyCoolDown++;
    }
    if (this.args.tailFlyCoolDown === 0) {
      // this.flyingSound.pause();
      // this.args.flying = false;
    }
    if (!falling) {
      this.args.tailFlyCoolDown = 0;
      this.flyingSound.pause();
      const direction = this.args.direction;
      const gSpeed = this.args.gSpeed;
      const speed = Math.abs(gSpeed);
      const maxSpeed = this.args.gSpeedMax;
      if (this.args.grinding) {
        this.args.animation = 'grinding';
        this.args.rolling = false;
      } else if (this.args.rolling) {
        this.args.animation = 'rolling';
      } else {
        if (Math.sign(this.args.gSpeed) !== direction && Math.abs(this.args.gSpeed - direction) > 5) {
          this.args.animation = 'skidding';
        } else if (speed > maxSpeed) {
          this.args.animation = 'running-2';
        } else if (speed > maxSpeed / 2) {
          this.args.animation = 'running';
        } else if (this.args.moving && this.args.gSpeed) {
          this.args.animation = 'walking';
        } else if (this.args.teeter) {
          this.args.animation = 'teeter';
        } else if (this.idleTime > 60) {
          this.args.animation = 'idle';
        } else {
          this.args.animation = 'standing';
        }
      }
    } else if (this.args.flying && !this.args.startled) {
      if (this.yAxis > 0 && this.args.flying) {
        this.flyingSound.pause();
        this.args.animation = 'jumping';
        this.args.float = 0;
        this.args.flying = false;
        this.args.ySpeed = this.args.ySpeed > this.args.jumpForce ? this.args.ySpeed : this.args.jumpForce;
      } else {
        if (this.viewport.args.audio) {
          this.flyingSound.play();
        }
        this.args.animation = 'flying';
        if (this.flyTime > this.args.maxFlyTime) {
          this.args.animation = 'flying-tired';
        }
      }
    } else if (this.args.jumping) {
      this.flyingSound.pause();
      this.args.animation = 'jumping';
    }
    if (!this.args.startled) {} else {
      this.flyingSound.pause();
      this.args.flying = false;
    }
    super.update();
    if (this.args.hangingFrom) {
      this.args.flying = false;
      this.flyTime = 0;
      this.args.animation = 'hanging';
    }
    if (this.args.grinding && !this.args.falling && this.args.gSpeed) {
      const sparkParticle = new _Tag.Tag(`<div class = "particle-sparks">`);
      const sparkEnvelope = new _Tag.Tag(`<div class = "envelope-sparks">`);
      sparkEnvelope.appendChild(sparkParticle.node);
      const sparkPoint = this.rotatePoint(-this.args.gSpeed * 1.75 * this.args.direction, 8);
      const flip = Math.sign(this.args.gSpeed);
      sparkEnvelope.style({
        '--x': sparkPoint[0] + this.x,
        '--y': sparkPoint[1] + this.y + Math.random * -3,
        'z-index': 0,
        'animation-delay': -Math.random() * 0.25 + 's',
        '--xMomentum': Math.max(Math.abs(this.args.gSpeed), 4) * flip,
        '--flip': flip,
        '--angle': this.realAngle,
        opacity: Math.random() * 2
      });
      sparkEnvelope.particle = sparkParticle;
      this.viewport.particles.add(sparkEnvelope);
      this.sparks.add(sparkEnvelope);
      this.viewport.onFrameOut(30, () => {
        this.viewport.particles.remove(sparkEnvelope);
        this.sparks.delete(sparkEnvelope);
      });
    }
    if (this.sparks.size) {
      for (const spark of this.sparks) {
        const sparkPoint = this.rotatePoint(1.75 * this.args.direction, 8);
        spark.style({
          opacity: Math.random() * 2,
          '--x': sparkPoint[0] + this.x,
          '--y': sparkPoint[1] + this.y
        });
      }
    }
    if (this.args.flying) {
      this.flyTime++;
    }
    if (!this.args.falling) {
      this.flyTime = 0;
      this.args.flying = false;
    } else {
      if (this.args.animation === 'springdash' && this.args.ySpeed >= 0) {
        this.args.animation = 'dropping';
      }
    }
    if (this.args.twistRamp) {
      this.args.animation = 'side-flip';
    }
    if (!this.args.falling) {
      this.dashed = false;
    }
  }
  updateEnd() {
    super.updateEnd();
  }
  command_0(button) {
    if (this.args.hangingFrom) {
      super.command_0();
      return;
    }
    super.command_0(button);
    if (!this.args.jumping) {
      return;
    }
    if (this.args.wasHanging) {
      return;
    }
    if (!this.args.falling) {
      this.args.tailFlyCoolDown = -80;
      return;
    }
    if (this.args.flying && this.args.tailFlyCoolDown === 0) {
      this.args.tailFlyCoolDown = 80;
      return;
    }
    if (this.args.flying && (this.flyTime > this.args.maxFlyTime || this.args.float)) {
      return;
    }
    if (this.args.flying && !this.args.float) {
      this.args.ySpeed = this.args.flyBoost;
      this.args.float = 8;
    }
    this.args.tailFlyCoolDown = 80;
    this.args.flying = true;
    this.flyingSound.volume = 0.35 + Math.random() * -0.3;
    if (this.viewport.args.audio && this.flyingSound.paused) {
      this.flyingSound.play();
    }
  }
  hold_0(button) {
    if (this.args.flying && button.time > 10 && button.time < 30 && this.flyTime < 400) {
      this.args.ySpeed *= 0.99;
      this.args.float = 16;
    }
  }
  sleep() {
    this.flyingSound && this.flyingSound.pause();
  }
  collideA(other) {
    if (other instanceof _Spring.Spring) {
      this.onNextFrame(() => {
        if (!this.args.falling) {
          return;
        }
        this.springing = true;
        this.args.animation = 'springdash';
      });
    }
    if (other.pop && this.isHyper) {
      other.pop(this);
    }
  }
  damage() {
    this.args.flying = false;
    this.flyingSound && this.flyingSound.pause();
    super.damage();
  }
  rotateMainColor() {
    let rH = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    let rS = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    let rV = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    const rotatedColors = {
      'ffb691': new _Color.Color('ffb691').rotate(rH, rS, rV).toString(),
      'fcb400': new _Color.Color('fcb400').rotate(rH, rS, rV).toString(),
      'fc9000': new _Color.Color('fc9000').rotate(rH, rS, rV).toString(),
      'b46c48': new _Color.Color('b46c48').rotate(rH, rS, rV).toString()
    };
    this.png.ready.then(() => {
      const newPng = this.png.recolor(rotatedColors);
      this.args.rotatedSpriteSheet = this.rotatedSpriteSheet = this.spriteSheet = newPng.toUrl();
      this.args.spriteSheet = `url(${this.spriteSheet})`;
    });
    this.pngTails.ready.then(() => {
      const newPng = this.pngTails.recolor(rotatedColors);
      this.args.rotatedSpriteSheetTails = this.rotatedSpriteSheetTails = this.spriteSheetTails = newPng.toUrl();
      this.args.spriteSheetTails = `url(${this.spriteSheetTails})`;
    });
    return Promise.all([this.png.ready, this.pngTails.ready]);
  }
  setProfile() {
    if (this.isHyper) {
      this.args.spriteSheet = `url('${this.hyperSpriteSheet}')`;
      this.args.spriteSheetTails = `url('${this.hyperSpriteSheetTails}')`;
      this.args.maxFlyTime = this.args.maxFlyTimeHyper;
      this.args.flyBoost = this.args.flyBoostHyper;
      this.args.gSpeedMax = this.gSpeedMaxHyper;
      this.args.jumpForce = this.jumpForceHyper;
      this.args.accel = this.accelSuper;
    } else if (this.isSuper) {
      this.args.spriteSheet = `url('${this.superSpriteSheet}')`;
      this.args.spriteSheetTails = `url('${this.superSpriteSheetTails}')`;
      this.args.maxFlyTime = this.args.maxFlyTimeSuper;
      this.args.flyBoost = this.args.flyBoostSuper;
      this.args.gSpeedMax = this.gSpeedMaxSuper;
      this.args.jumpForce = this.jumpForceSuper;
      this.args.accel = this.accelSuper;
    } else {
      this.args.spriteSheet = `url('${this.rotatedSpriteSheet}')`;
      this.args.spriteSheetTails = `url('${this.rotatedSpriteSheetTails}')`;
      this.args.maxFlyTime = this.args.maxFlyTimeNormal;
      this.args.flyBoost = this.args.flyBoostNormal;
      this.args.gSpeedMax = this.gSpeedMaxNormal;
      this.args.jumpForce = this.jumpForceNormal;
      this.args.accel = this.accelNormal;
    }
  }
  command_2() {
    if (this.viewport.collisions.has(this)) {
      const objects = this.viewport.collisions.get(this);
      for (const object of objects.keys()) {
        if (this.carrying.size && !this.carrying.has(object)) {
          continue;
        }
        if (typeof object.lift === 'function') {
          object.lift(this);
        }
      }
    }
  }
  command_3() {}
  get solid() {
    return false;
  }
  get canRoll() {
    return true;
  }
  get canFly() {
    return true;
  }
  get isEffect() {
    return false;
  }
  get controllable() {
    return !this.args.npc;
  }
}
exports.Tails = Tails;
});

;require.register("actor/TechnoSqueak.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TechnoSqueak = void 0;
var _Flickie = require("./Flickie");
var _Mixin = require("curvature/base/Mixin");
var _PointActor = require("./PointActor");
var _Patrol = require("../behavior/Patrol");
var _CanPop = require("../mixin/CanPop");
class TechnoSqueak extends _Mixin.Mixin.from(_PointActor.PointActor, _CanPop.CanPop) {
  constructor() {
    var _this$args$patrolPaus, _this$args$patrolBeat, _this$args$patrolSpee;
    super(...arguments);
    this.behaviors.add(new _Patrol.Patrol());
    this.args.type = 'actor-item actor-techno-squeak';
    this.args.animation = 'standing';
    this.args.accel = 0.75;
    this.args.decel = 0.5;
    this.args.gSpeedMax = 15;
    this.args.jumpForce = 5;
    this.args.gravity = 0.5;
    this.args.width = 24;
    this.args.height = 14;
    this.willStick = true;
    this.stayStuck = true;
    this.args.patrolPause = (_this$args$patrolPaus = this.args.patrolPause) !== null && _this$args$patrolPaus !== void 0 ? _this$args$patrolPaus : 20;
    this.args.patrolBeat = (_this$args$patrolBeat = this.args.patrolBeat) !== null && _this$args$patrolBeat !== void 0 ? _this$args$patrolBeat : 120;
    this.args.patrolSpeed = (_this$args$patrolSpee = this.args.patrolSpeed) !== null && _this$args$patrolSpee !== void 0 ? _this$args$patrolSpee : 4;
    this.args.tailOffset = 0;
    this.stayStuck = true;
  }
  onRendered(event) {
    super.onRendered(event);
    this.autoStyle.get(this.box)['--tailOffset'] = 'tailOffset';
    this.autoAttr.get(this.box)['data-color'] = 'color';
  }
  update() {
    // const direction = this.args.direction;
    const telegraph = this.args.shotTelegraph;
    const beat = this.args.patrolBeat;
    const moved = this.args.x - this.xLast;
    this.args.tailOffset += isNaN(moved) ? 0 : moved;
    if (this.box) {
      if (this.args.moving && this.args.gSpeed) {
        this.box.setAttribute('data-animation', 'walking');
      } else {
        this.box.setAttribute('data-animation', 'standing');
      }
    }
    super.update();
    this.args.direction = Math.sign(this.args.gSpeed);
  }
  effect(other) {
    super.effect(other);

    // this.viewport.spawn.add({object:new Flickie({
    // 	x: this.args.x,
    // 	y: this.args.y,
    // })});
  }

  get solid() {
    return false;
  }
  get isEffect() {
    return false;
  }
  // get controllable() { return true; }
}
exports.TechnoSqueak = TechnoSqueak;
});

;require.register("actor/Tester.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Tester = void 0;
var _PointActor = require("./PointActor");
var _Cursor = require("./Cursor");
var _ObjectPalette = require("../ObjectPalette");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
window.testRuns = [];
class Tester extends _PointActor.PointActor {
  constructor() {
    super(...arguments);
    _defineProperty(this, "count", 0);
    _defineProperty(this, "char", null);
  }
  update() {
    if (!this.char) {
      const charType = _ObjectPalette.ObjectPalette['sonic'];
      const count = this.count;
      this.char = new charType({
        name: `Test #${count}`,
        x: this.x + -(count % 160) + +80,
        y: this.y
      });

      // this.char.cursor = new Cursor;

      const debind = this.char.args.bindTo('falling', () => {
        const landed = this.char.x;
        this.viewport.onFrameOut(5, () => {
          console.log({
            count,
            landed,
            groundAngle: this.char.args.groundAngle,
            gSpeed: this.char.args.gSpeed
          });
        });
        debind();
      }, {
        now: false,
        frame: 1
      });
      window.testRuns[count] = this.char;
      this.count++;
      this.viewport.spawn.add({
        object: this.char
      });
      // this.viewport.spawn.add({object: this.char.cursor});
    } else {
      const controller = this.char.controller;
      const press = 4;
      if (this.char.age === 5) {
        controller.press(press, 1);
      }
      if (this.char.age === 6) {
        controller.press(press, 0);
      }
      this.char.readInput();
    }
    if (this.char.args.dead) {
      const dead = this.char;
      this.char = null;

      // this.viewport.actors.remove(dead.cursor)

      // dead.cursor.remove();

      this.viewport.onFrameOut(100, () => this.viewport.actors.remove(dead));
    } else if (this.char.age > 30) {
      this.char.xAxis = +1;
    }
  }
  updateEnd() {
    if (this.char) {
      // this.char.cursor.args.x        = this.char.x;
      // this.char.cursor.args.y        = this.char.y;

      // this.char.cursor.args.angle    = this.char.angle;
      // this.char.cursor.args.airAngle = this.char.airAngle;

      // this.char.cursor.args.groundAngle = this.char.groundAngle;
    }
  }
}
exports.Tester = Tester;
});

;require.register("actor/TextActor.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TextActor = void 0;
var _PointActor = require("./PointActor");
var _CharacterString = require("../ui/CharacterString");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class TextActor extends _PointActor.PointActor {
  constructor() {
    let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let parent = arguments.length > 1 ? arguments[1] : undefined;
    super(args, parent);
    _defineProperty(this, "float", -1);
    this.args.type = 'actor-item actor-text-actor';
    this.args.float = -1;
    this.args.static = true;
    this.text = new _CharacterString.CharacterString({
      value: ''
    });

    // this.args.x = args.x - 48;

    this.args.bindTo('content', v => {
      this.text.args.value = v;
      this.text.args.color = args.color;
      this.args.width = v ? v.length * 18 : 0;
      this.args.height = 18;
    });
  }
  onRendered(event) {
    super.onRendered(event);
    this.sprite = this.findTag('div.sprite');
    this.text.render(this.sprite);
  }
  get solid() {
    return false;
  }
  get isEffect() {
    return true;
  }
}
exports.TextActor = TextActor;
});

;require.register("actor/TilesetSwapper.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TilesetSwapper = void 0;
var _PointActor = require("./PointActor");
var _ScreenFire = require("../effects/ScreenFire");
var _BackdropPalette = require("../BackdropPalette");
class TilesetSwapper extends _PointActor.PointActor {
  constructor(args, parent) {
    super(args, parent);
    this.args.hidden = true;
    const img = new Image('../Sonic/tiles/azure-lake/azure-lake-burnt.png');
    if (_BackdropPalette.BackdropPalette[this.args.backdrop]) {
      const backdropClass = _BackdropPalette.BackdropPalette[this.args.backdrop];
      this.args.backdrop = new backdropClass();
    }
  }
  activate(other, button) {
    // this.viewport.tilemap.replacements.set(
    // 	this.args.original//'../Sonic/tiles/azure-lake/azure-lake.png'
    // 	, this.args.replacement//'../Sonic/tiles/azure-lake/azure-lake-burnt.png'
    // );

    if (this.activated) {
      return;
    }
    this.activated = true;
    this.viewport.onFrameOut(15, () => {
      const fire = new _ScreenFire.ScreenFire();
      this.viewport.args.screenEffects.add(fire);
      this.viewport.onFrameOut(60 * 5, () => {
        this.viewport.args.screenEffects.remove(fire);
        fire.remove();
      });
      this.viewport.onFrameOut(60 * 1.5, () => {
        this.viewport.tileMap.replacements.set('/map/../Sonic/tiles/azure-lake/azure-lake.png', '/map/../Sonic/tiles/azure-lake/azure-lake-burnt.png');
        this.viewport.args.backdrop = this.args.backdrop;
        this.viewport.tileMap.replacements.set('/map/../Sonic/tiles/azure-lake/azure-lake-shapes.png', '/map/../Sonic/tiles/azure-lake/azure-lake-burnt-shapes.png');
        this.viewport.tileMap.replacements.set('/map/../Sonic/tiles/azure-lake/rolling.png', '/map/../Sonic/tiles/azure-lake/rolling-burnt.png');
        this.viewport.tileMap.replacements.set('/map/../Sonic/tiles/azure-lake/giant-loop.png', '/map/../Sonic/tiles/azure-lake/giant-loop-burnt.png');
        this.viewport.tileMap.replacements.set('/map/../Sonic/azure-lake-platform.png', '/map/../Sonic/azure-lake-platform-burnt.png');
      });
    });
  }
}
exports.TilesetSwapper = TilesetSwapper;
});

;require.register("actor/Torch.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Torch = void 0;
var _PointActor = require("./PointActor");
class Torch extends _PointActor.PointActor {
  constructor() {
    super(...arguments);
    this.args.width = 16;
    this.args.height = 32;
    this.args.type = 'actor-item actor-torch';
    this.args.float = -1;
  }
  get solid() {
    return false;
  }
}
exports.Torch = Torch;
});

;require.register("actor/Tornado.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Tornado = void 0;
var _Vehicle = require("./Vehicle");
var _Tag = require("curvature/base/Tag");
class Tornado extends _Vehicle.Vehicle {
  constructor() {
    super(...arguments);
    this.args.type = 'actor-item actor-tornado';
    this.args.width = 96;
    this.args.height = 48;
    this.removeTimer = null;
    this.args.xSpeedMaxThrusting = 10;
    this.args.xSpeedMaxOriginal = 8;
    this.args.xSpeedMax = this.args.xSpeedMaxOriginal;
    this.args.gSpeedMax = 5;
    this.args.decel = 0.15;
    this.args.accel = 0.5;
    this.args.seatHeight = 14;
    this.args.seatForward = -32;
    this.args.skidTraction = 0.95;
    this.dustCount = 0;
    this.args.flyAngle = -0.25;
    this.args.particleScale = 2;
    this.args.float = -1;
    this.args.thrusting = false;
    this.args.landingGear = true;
    this.args.jumpForce = 8;
    this.args.fuelLevel = 100;
    this.args.thrusterFill = 0;
    this.args.noThrust = 0;
    this.plane = new _Tag.Tag('<div class = "plane">');
    this.fuselage = new _Tag.Tag('<div class = "fuselage">');
    this.propeller = new _Tag.Tag('<div class = "propeller">');
    this.thruster = new _Tag.Tag('<div class = "thruster">');
    this.fuelMeter = new _Tag.Tag('<div class = "fuel-meter">');
    this.frontGear = new _Tag.Tag('<div class = "front-landing-gear">');
    this.rearGear = new _Tag.Tag('<div class = "rear-landing-gear">');
  }
  onRendered(event) {
    super.onRendered(event);
    this.box = this.findTag('div');
    this.sprite = this.findTag('div.sprite');
    this.sprite.appendChild(this.plane.node);
    this.thruster.appendChild(this.fuelMeter.node);
    this.plane.appendChild(this.thruster.node);
    this.plane.appendChild(this.propeller.node);
    this.plane.appendChild(this.frontGear.node);
    this.plane.appendChild(this.rearGear.node);
    this.plane.appendChild(this.fuselage.node);
    this.args.bindTo('landingGear', v => {
      if (this.plane) {
        this.plane.setAttribute('data-landing-gear', v);
      }
    });
    this.args.bindTo('thrusting', v => {
      if (this.plane) {
        this.plane.setAttribute('data-thrusting', v);
      }
    });
  }
  update() {
    if (!this.occupant || !this.args.falling) {
      this.args.flyAngle = this.args.falling ? 0.26 : -0.26;
      this.args.flying = false;
      this.args.float = 0;
    }
    if (!this.args.thrusting && Math.abs(this.args.xSpeed) < 3) {
      this.args.float = 0;
      this.args.flying = false;
    } else if (this.args.falling || this.args.gSpeed > 5) {
      if (!this.args.falling) {
        this.args.falling = true;
        this.args.ySpeed = -2;
      }
      this.args.float = -1;
      this.args.flying = true;
    }
    if (!this.args.jumping && this.args.xSpeed === 0 && this.args.falling) {
      this.args.flying = false;
      this.args.float = 0;
      if (this.args.thrusting) {
        this.args.crashed = true;
        this.args.thrusting = false;
        this.args.noThrust = Date.now() + 500;
      }
      super.update();
      return;
    }
    const downPoint = this.castRayQuick(128, Math.PI / 2, [0, 0], false) || 128;
    const maxAirSpeed = this.args.xSpeedMaxThrusting;
    if (this.args.thrusting && this.args.fuelLevel <= 0) {
      this.args.thrusting = false;
      this.args.noThrust = Date.now() + 500;
      this.args.thrusterFill = Date.now() + 500;
    }
    if (this.args.thrusting) {
      this.args.xSpeedMax = this.args.xSpeedMaxThrusting;
      if (this.args.fuelLevel > 0) {
        this.args.fuelLevel -= 0.1;
      }
    } else {
      this.args.xSpeedMax = this.args.xSpeedMaxOriginal;
      if (this.args.thrusterFill < Date.now() && this.args.fuelLevel < 100) {
        this.args.fuelLevel += 0.25;
      }
    }
    this.fuelMeter.style({
      '--fuelLevel': this.args.fuelLevel / 100
    });
    if (!this.args.thrusting && Math.abs(this.args.xSpeed) > maxAirSpeed) {
      this.args.xSpeed -= Math.sign(this.args.xSpeed) * 0.2;
    }
    if (this.args.thrusting && (Math.sign(this.args.xSpeed) !== this.args.direction || Math.abs(this.args.xSpeed) < maxAirSpeed)) {
      if (!this.args.falling && this.args.xSpeed === 0) {
        this.args.flyAngle = -0.26;
        this.args.falling = true;
        this.args.flying = true;
        this.args.ySpeed = -5;
      }
      this.args.xSpeed += Math.sign(this.args.direction) * 4;
    }
    if (Math.abs(this.args.xSpeed) > this.args.xSpeedMax / 2 && !this.args.thrusting && !this.xAxis) {
      this.args.xSpeed *= 0.95;
    }
    if (Math.abs(this.args.xSpeed) > maxAirSpeed) {
      this.args.xSpeed = maxAirSpeed * Math.sign(this.args.direction);
    }
    if (this.args.flying) {
      if (this.args.ySpeed === 0) {
        this.args.flyAngle = 0;
      }
      if (downPoint > 128) {
        if (this.args.flyAngle > 0) {
          this.args.flyAngle *= 0.80;
        }
      } else {
        this.args.flyAngle *= 0.8;
      }
      if (this.args.landingGear) {
        this.args.flyAngle += 0.005;
      }
      if (!this.args.xSpeed) {
        this.args.flying = false;
        return;
      }

      // const newAngle = downPoint < 128
      // 	?
      // 	: ;

      let newAngle = this.args.flyAngle;
      if (downPoint < 128) {
        newAngle = this.args.flyAngle + Math.sign(this.yAxis) * 0.035;
      } else if (downPoint > 128 && downPoint < 132) {
        newAngle = this.args.flyAngle + Math.max(0, this.yAxis) * 0.035;
      } else {
        newAngle = this.args.flyAngle + 0.01;
      }
      if (this.args.flyAngle > 0) {
        this.args.xSpeed *= 1.025;
      } else if (this.args.flyAngle > 0) {
        this.args.xSpeed /= 1.025;
      }
      if (this.yAxis && Math.abs(newAngle) < Math.PI / 2) {
        this.args.flyAngle = newAngle;
      }
      if (Math.sign(this.args.xSpeed) === this.args.direction) {
        const speed = this.args.xSpeed || this.args.gSpeed;
        this.args.ySpeed = Math.sin(this.args.flyAngle) * speed * (this.args.direction || Math.sign(speed)) * 2;
      }
      if (this.args.thrusting && downPoint < 128) {
        this.args.flyAngle -= 0.025;
      }
    } else {
      if (!this.args.thrusting && this.args.flyAngle < Math.PI / 2 && this.args.ySpeed > 0) {
        this.args.flyAngle += 0.025;
      }
    }
    if (this.args.flying) {
      this.args.airAngle = this.args.flyAngle;
      this.args.jumping = false;
    }
    if (!this.args.falling) {
      this.args.landingGear = true;
      this.args.flyAngle = -0.26;
    }
    super.update();
    if (this.args.flying) {
      this.args.cameraMode = 'airplane';
    }
  }
  command_1() {
    if (this.args.falling) {
      this.args.landingGear = !this.args.landingGear;
    }
  }
  hold_2() {
    this.args.landingGear = false;
    if (!this.args.thrusting && this.args.fuelLevel <= 1) {
      return;
    }
    if (this.args.fuelLevel <= 0) {
      return;
    }
    if (this.args.crashed || this.args.noThrust > Date.now()) {
      this.args.false = true;
      return;
    }
    this.args.thrusting = true;
  }
  release_2() {
    this.args.thrusting = false;
    this.args.crashed = false;
  }
  get solid() {
    return !this.occupant;
  }
}
exports.Tornado = Tornado;
});

;require.register("actor/ToxicBarrel.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ToxicBarrel = void 0;
var _MarbleBlock = require("./MarbleBlock");
var _BarnacleTrap = require("./BarnacleTrap");
var _Sfx = require("../audio/Sfx");
class ToxicBarrel extends _MarbleBlock.MarbleBlock {
  constructor() {
    let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    super(args);
    this.args.type = 'actor-item actor-toxic-barrel';
    this.args.density = this.args.density || 9.5;
    this.played = false;
    this.args.width = 23;
    this.args.height = 32;
    this.args.weight = 0;
  }
  collideA(other, type) {
    if (other instanceof _BarnacleTrap.BarnacleTrap) {
      return false;
    }
    if (this.args.falling && other.pop) {
      this.pop();
    }
    if (this.args.animation === 'exploding') {
      other.damage && other.damage(this, 'explosion');
      other.pop && other.pop(this);
      return false;
    }
    if (this.args.falling && other.args.modeTime < 3) {
      other.args.gSpeed = 0;
    }
    if (this.args.falling) {
      return false;
    }
    return super.collideA(other, type);
  }
  update() {
    if (this.args.animation === 'exploding') {
      this.args.float = -1;
      this.args.xSpeed = 0;
      this.args.ySpeed = 0;
      this.castRayQuick(32, 0, [0, -16]);
      this.castRayQuick(32, Math.PI, [0, -16]);
      this.castRayQuick(32, Math.PI / 2, [0, -16]);
      this.castRayQuick(32, Math.PI / -2, [0, -16]);
    }
    super.update();
    if (!this.args.falling && this.ySpeedLast > 3) {
      this.pop();
    }
  }
  pop() {
    this.args.animation = 'exploding';
    const viewport = this.viewport;
    viewport.onFrameOut(20, () => viewport.actors.remove(this));
    if (!this.played) {
      _Sfx.Sfx.play('BARREL_EXPLODE');
      this.played = true;
    }
  }
  sleep() {
    this.args.x = this.def.get('x');
    this.args.y = this.def.get('y');
    this.ySpeedLast = 0;
    this.onNextFrame(() => {
      this.args.x = this.def.get('x');
      this.args.y = this.def.get('y');
      this.viewport.setColCell(this);
      this.args.xSpeed = 0;
      this.args.ySpeed = 0;
      this.args.pushed = 0;
      this.args.float = 0;
    });
  }
  get solid() {
    return !this.args.falling && !this.args.hangingFrom;
  }
}
exports.ToxicBarrel = ToxicBarrel;
});

;require.register("actor/Tree.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Tree = void 0;
var _PointActor = require("./PointActor");
var _Coconut = require("./Coconut");
var _Tag = require("curvature/base/Tag");
class Tree extends _PointActor.PointActor {
  static fromDef(objDef) {
    const obj = super.fromDef(objDef);
    obj.args.height = objDef.height;
    return obj;
  }
  constructor() {
    super(...arguments);
    this.args.type = 'actor-item actor-tree';
    this.args.z = -1;
    this.args.width = 80;
    this.args.lean = 0;
    this.args.coconutCount = 4;
    this.args.shakeTime = 0;
  }
  updateEnd() {
    super.updateEnd();
    const objects = this.viewport.collisions.get(this);
    let shaking = false;
    if (objects) for (const object of objects.keys()) {
      if (object.args.currentState === 'shakingTree') {
        shaking = Math.sign(this.args.x - object.args.x);
      }
    }
    this.args.shaking = shaking;
  }
  update() {
    const frame = this.viewport.args.frameId;
    if (this.args.shaking) {
      this.args.lean = 2 * (Math.trunc(this.args.shakeTime / 10) % 2) + -1 * this.args.shaking;
      this.args.shakeTime++;
    } else {
      if (this.viewport.args.frameId - this.args.lastChange > 1200 && this.args.coconutCount < 4) {
        this.args.coconutCount++;
        this.args.lastChange = this.viewport.args.frameId;
      }
      this.args.shakeTime = 0;
      this.args.lean = 0;
    }
    if (this.args.shakeTime > 120) {
      this.args.shakeTime = -60;
      this.dropFruit();
    }
    super.update();
  }
  onRendered(event) {
    super.onRendered(event);
    if (this.box && !this.top) {
      this.top = new _Tag.Tag(`<div class = "tree-top">`);
      this.box.appendChild(this.top.node);
    }
    this.autoStyle.get(this.box)['--count'] = 'coconutCount';
    this.autoStyle.get(this.box)['--lean'] = 'lean';
  }
  collideA(other, type) {
    if (!other.controllable) {
      return;
    }
    // else
    // {
    // 	this.args.shaking = true;
    // }

    if (Math.abs(other.args.x - this.args.x) > 20) {
      return;
    }
    if (other.args.y > this.args.y + -this.args.height + 64) {
      return;
    }
    this.ignores.set(other, 45);
    this.dropFruit(other);
  }
  dropFruit(other) {
    if (this.args.coconutCount) {
      this.args.coconutCount--;
      this.args.lastChange = this.viewport.args.frameId;
      const coconut = new _Coconut.Coconut();

      // coconut.args.ySpeed = -2;
      coconut.args.x = this.args.x;
      coconut.args.y = this.args.y + -this.args.height + 48;
      this.viewport.spawn.add({
        object: coconut
      });
      if (other) {
        this.viewport.onFrameOut(1, () => coconut.args.xSpeed = other.args.xSpeed || other.args.direction * Math.random() * 2);
        this.args.lean = 5 * Math.sign(other.args.xSpeed);
      } else {
        this.viewport.onFrameOut(1, () => coconut.args.xSpeed = this.args.lean * 0.5 + this.args.lean * 2.5 * Math.random());
      }
      this.viewport.onFrameOut(10, () => this.args.lean = 0);
    }
  }
  sleep() {
    this.args.coconutCount = 4;
  }
  get solid() {
    return false;
  }
}
exports.Tree = Tree;
});

;require.register("actor/TrickRamp.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TrickRamp = void 0;
var _PointActor = require("./PointActor");
class TrickRamp extends _PointActor.PointActor {
  static fromDef(objDef) {
    const obj = super.fromDef(objDef);
    obj.args.width = objDef.width;
    obj.args.height = objDef.height;
    return obj;
  }
  constructor() {
    super(...arguments);
    this.args.type = 'actor-item actor-trick-ramp';
    this.args.width = this.args.width || 64;
    this.args.height = this.args.height || 64;
    this.args.float = -1;
    this.args.static = 1;
    this.args.power = this.args.power || 24;
    // this.args.hidden  = true;
  }

  collideA(other) {
    if (other.args.x < this.args.x) {
      return;
    }
    if (Math.abs(other.args.gSpeed) < 8 && other.willJump) {
      return;
    }
    if (Math.abs(other.args.gSpeed) < 14 && other.args.rolling && !other.willJump) {
      return;
    }
    if (other.willJump || other.args.rolling) {
      if (!other.args.falling) {
        const reward = {
          label: 'OFF THE RAMP',
          points: 100,
          multiplier: 1,
          color: 'orange',
          special: true
        };
        other.args.popChain.push(reward);
        other.args.popCombo += 1;
      }
      const dir = Math.sign(other.args.gSpeed || other.gSpeedLast);
      ;
      other.args.trickRamp = true;
      other.args.ignore = 5;
      other.args.xSpeed = this.args.power * dir;
      other.args.ySpeed = -this.args.power * 0.65;
      other.args.float = 18;
      other.args.y -= 5;
      other.args.rolling = true;
      other.args.falling = true;
      other.willJump = false;
      other.dashed = true;
    }
  }
}
exports.TrickRamp = TrickRamp;
});

;require.register("actor/TruckBody.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TruckBody = void 0;
var _PointActor = require("./PointActor");
var _Mixin = require("curvature/base/Mixin");
class TruckBody extends _Mixin.Mixin.from(_PointActor.PointActor) {
  constructor() {
    super(...arguments);
    this.args.type = 'actor-item actor-truck-body';
    this.args.width = 145;
    this.args.height = 48;
    this.args.gravity = 0.4;
    this.args.float = -1;
    this.noClip = 1;
    this.args.driver = this.args.driver || null;
    this.args.ramming = true;
  }

  // collideA(other,type)
  // {
  // 	if(!other.controllable)
  // 	{
  // 		return;
  // 	}

  // 	other.damage(this);
  // }

  collideA(other, type) {
    if (this.args.destroyed) {
      return;
    }
    if (other.break) {
      other.break(this);
      return;
    }
    if (other.pop) {
      other.pop(this);
      return;
    }
    if (!other.controllable) {
      return;
    }
    other.damage(this);
  }
}
exports.TruckBody = TruckBody;
});

;require.register("actor/TruckCab.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TruckCab = void 0;
var _PointActor = require("./PointActor");
var _Mixin = require("curvature/base/Mixin");
// import { Sfx } from '../audio/Sfx';

class TruckCab extends _Mixin.Mixin.from(_PointActor.PointActor) {
  constructor() {
    super(...arguments);
    this.args.type = 'actor-item actor-truck-cab';
    this.args.width = 49;
    this.args.height = 51;
    this.args.gravity = 0.4;
    this.args.float = -1;
    this.noClip = 1;
    this.args.driver = this.args.driver || null;
    this.args.ramming = true;
  }
  collideA(other, type) {
    if (this.args.destroyed) {
      return;
    }
    if (other.break) {
      other.break(this);
      return;
    }
    if (other.pop) {
      other.pop(this);
      return;
    }
    if (!other.controllable) {
      return;
    }
    other.damage(this);
  }
}
exports.TruckCab = TruckCab;
});

;require.register("actor/Tumbler.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Tumbler = void 0;
var _PointActor = require("./PointActor");
class Tumbler extends _PointActor.PointActor {
  constructor() {
    super(...arguments);
    this.args.decel = 0.1;
    this.args.width = 96;
    this.args.height = 35;
    this.args.type = 'actor-item actor-tumbler';
    this.args.color = this.args.color || ['red', 'green', 'blue'][Math.trunc(3 * Math.random())];
    this.tumbling = false;
    this.bounced = 0;
  }
  onRendered(event) {
    super.onRendered(event);
    this.autoAttr.get(this.box)['data-color'] = 'color';
    this.autoAttr.get(this.box)['data-model'] = 'model';
  }
  update() {
    if (this.tumbling && !this.args.falling) {
      this.args.xSpeed = this.xSpeedLast;
      this.args.ySpeed = Math.max(-10, -this.ySpeedLast);
      this.args.y--;
      this.args.falling = true;
      this.bounced++;
    }
    if (this.tumbling) {
      // this.args.xSpeed = (this.args.xSpeed || this.xSpeedLast) * 0.7;
    }
    this.noClip = !!this.bounced;
    if (this.noClip) {
      this.args.xSpeed = this.args.gSpeed = 0;
    }
    super.update();
  }
  collideA(other, type) {
    if (!other.controllable && !other.isVehicle || this.args.falling) {
      return;
    }
    const speed = other.args.gSpeed || other.args.xSpeed;
    if (Math.abs(speed) > 8) {
      this.args.animation = 'tumbling';
      this.args.xSpeed = speed + 5 * Math.random();
      this.args.ySpeed = Math.max(-10, -Math.abs(speed * 0.25) + -2 * Math.random());
      this.args.falling = true;
      this.tumbling = true;
      this.isGhost = true;
    }
    super.collideA(other, type);
  }
}
exports.Tumbler = Tumbler;
});

;require.register("actor/Turtloid.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Turtloid = void 0;
var _Block = require("./Block");
var _Sfx = require("../audio/Sfx");
class Turtloid extends _Block.Block {
  constructor() {
    super(...arguments);
    this.args.width = 56;
    this.args.height = 24;
    this.args.platform = 1;
    this.args.float = -1;
    this.args.type = 'actor-item actor-turtloid';
    this.args.static = 0;
    this.args.pathSpeed = 4;
  }
  updateStart() {
    const standingUnder = [...this.standingUnder].filter(a => a.controllable);
    if (standingUnder.length && (!this.others.guard || this.others.guard.removed)) {
      this.otherDefs.path = this.otherDefs.ridePath;
    } else {
      this.otherDefs.path = null;
    }
    super.updateStart();
    if (this.xLast) {
      this.args.direction = Math.sign(this.args.x - this.xLast) || this.args.direction;
    }
    const xSpeed = this.xLast - this.args.x;
    const ySpeed = this.yLast - this.args.y;
    if (xSpeed) {
      this.args.animation = 'swimming';
    } else if (ySpeed) {
      this.args.animation = 'sinking';
    } else {
      this.args.animation = 'idle';
    }
  }

  // sleep()
  // {
  // 	this.args.y = this.originalY;
  // }
}
exports.Turtloid = Turtloid;
});

;require.register("actor/TwistRamp.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TwistRamp = void 0;
var _PointActor = require("./PointActor");
class TwistRamp extends _PointActor.PointActor {
  static fromDef(objDef) {
    const obj = super.fromDef(objDef);
    obj.args.width = objDef.width;
    obj.args.height = objDef.height;
    return obj;
  }
  constructor() {
    super(...arguments);
    this.args.type = 'actor-item actor-twist-ramp';
    this.args.width = this.args.width || 64;
    this.args.height = this.args.height || 64;
    this.args.float = -1;
    this.args.static = 1;
    this.args.power = this.args.power || 24;
    // this.args.hidden  = true;
  }

  collideA(other) {
    if (other.args.x < this.args.x) {
      return;
    }
    if (Math.abs(other.args.gSpeed) < 8 && other.willJump) {
      return;
    }
    if (Math.abs(other.args.gSpeed) < 14 && other.args.rolling && !other.willJump) {
      return;
    }
    if (Math.abs(other.args.gSpeed) > 8) {
      // if(!other.args.falling)
      // {
      // 	const reward = {label:'OFF THE RAMP', points:100, multiplier: 1, color: 'orange', special: true};
      // 	other.args.popChain.push(reward);
      // 	other.args.popCombo += 1;
      // }

      const dir = Math.sign(other.args.gSpeed || other.gSpeedLast);
      other.args.twistRamp = true;
      other.args.ignore = 5;
      if (other.args.mode === 0) {
        other.args.xSpeed = this.args.power * dir;
        other.args.ySpeed = -this.args.power * 0.65;
        other.args.y -= 5;
      } else if (other.args.mode === 2) {
        other.args.xSpeed = -this.args.power * dir;
        other.args.ySpeed = this.args.power * 0.65;
        other.args.y += 5;
      } else if (other.args.mode === 3) {
        other.args.xSpeed = -this.args.power * 0.65;
        other.args.ySpeed = -this.args.power * dir;
        other.args.x -= 5;
      } else if (other.args.mode === 1) {
        other.args.xSpeed = this.args.power * 0.65;
        other.args.ySpeed = this.args.power * dir;
        other.args.x += 5;
      }
      other.args.float = 18;
      other.args.rolling = true;
      other.args.falling = true;
      other.willJump = false;
      other.dashed = true;
    }
  }
}
exports.TwistRamp = TwistRamp;
});

;require.register("actor/Umbrella.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Umbrella = void 0;
var _PointActor = require("./PointActor");
class Umbrella extends _PointActor.PointActor {
  static fromDef(objDef) {
    const obj = super.fromDef(objDef);
    obj.args.width = objDef.width;
    obj.args.height = objDef.height;
    return obj;
  }
  constructor() {
    var _this$args$height;
    super(...arguments);
    this.args.width = 20;
    this.args.height = (_this$args$height = this.args.height) !== null && _this$args$height !== void 0 ? _this$args$height : 80;
    this.args.type = 'actor-item actor-umbrella';
  }
  get solid() {
    return false;
  }
}
exports.Umbrella = Umbrella;
});

;require.register("actor/UnbreakableCrate.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.UnbreakableCrate = void 0;
var _PointActor = require("./PointActor");
var _Block = require("./Block");
class UnbreakableCrate extends _Block.Block {
  constructor(args, parent) {
    super(args, parent);
    this.args.type = 'actor-item actor-unbreakable-crate';
    this.args.width = 64;
    this.args.height = 64;
    this.args.static = false;
  }
  update() {
    if (this.viewport && this.args.gate) {
      const gatekeeper = this.viewport.actorsById[this.args.gate];
      if (!gatekeeper.args.hitPoints) {
        this.viewport.actors.remove(this);
      }
    }
    super.update();
  }
  collideA(other, type) {
    return true;
  }
  damage(other, type) {
    return true;
  }
}
exports.UnbreakableCrate = UnbreakableCrate;
});

;require.register("actor/Vehicle.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Vehicle = void 0;
var _PointActor = require("./PointActor");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class Vehicle extends _PointActor.PointActor {
  constructor() {
    super(...arguments);
    _defineProperty(this, "dead", false);
  }
  update() {
    if (this.occupant) {
      this.running = this.occupant.running;
      this.crawling = this.occupant.crawling;
    }
    super.update();
  }
  collideA(other, type) {
    if (other.noClip) {
      return false;
    }
    if (other.controllable) {
      if (other.args.falling && this.y + -other.y + 24 <= this.args.seatHeight) {
        return false;
      } else if (other.args.ySpeed > 0 && !this.occupant) {
        const seatHeight = this.args.seatHeight || 0;
        other.args.ySpeed = 0;
        other.args.y = this.y + -seatHeight + 1;
        other.args.x = this.x;
        other.args.standingOn = this;
        return true;
      } else {
        return false;
      }
    }
    if (other.y >= this.y) {
      return false;
    }
    if (!other.args.float) {
      other.args.ySpeed = -other.args.ySpeed;
      other.args.xSpeed = other.args.xSpeed || other.args.direction * 5;
      if (other.args.ySpeed > -5) {
        other.args.ySpeed = -5;
      }
    }
    return false;
  }
  standBelow(other) {
    if (!other.controllable) {
      other.args.ySpeed = -other.args.ySpeed;
      other.args.xSpeed = other.args.xSpeed || other.args.direction * 5;
      if (other.args.ySpeed > -5) {
        other.args.ySpeed = -5;
      }
    }
  }
  get isVehicle() {
    return true;
  }
  sleep() {
    super.sleep();
    if (this.dead) {
      this.viewport.actors.remove(this);
      return;
    }
  }
}
exports.Vehicle = Vehicle;
});

;require.register("actor/Voltorb.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Voltorb = void 0;
var _GohlaBall = require("../actor/GohlaBall");
class Voltorb extends _GohlaBall.GohlaBall {
  constructor() {
    super(...arguments);
    this.args.type = 'actor-item actor-gohla-ball actor-voltorb';
  }
  update() {
    super.update();
    if (!this.viewport) {
      return;
    }
    if (!this.viewport.controlActor) {
      return;
    }
    const player = this.viewport.controlActor;
    this.direction = Math.sign(this.x - player.x);
    this.args.facing = this.direction < 0 ? 'left' : 'right';
    if (Math.abs(player.y - this.y) <= 16) {
      if (Math.abs(player.x - this.x) < 34) {
        this.args.animation = 'sparking';
        player.damage(this, 'electric');
      } else if (!player.args.dead && !player.args.mercy) {
        this.args.animation = 'standing';
      }
    } else if (!player.args.dead && !player.args.mercy) {
      this.args.animation = 'standing';
    }
  }
}
exports.Voltorb = Voltorb;
});

;require.register("actor/WallSwitch.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WallSwitch = void 0;
var _Sfx = require("../audio/Sfx");
var _PointActor = require("./PointActor");
class WallSwitch extends _PointActor.PointActor {
  constructor() {
    super(...arguments);
    this.args.width = this.args.width || 12;
    this.args.height = this.args.height || 20;
    this.args.type = 'actor-item actor-wall-switch';
    this.args.z = 100;
    this.args.float = -1;
  }
  collideA(other) {
    if (!other.controllable || this.args.active) {
      if (this.args.toggle) {
        this.ignores.set(other, 8);
        this.args.active = false;
        _Sfx.Sfx.play('SWITCH_HIT');
      }
      return;
    }
    this.ignores.set(other, 15);
    this.args.active = true;
    _Sfx.Sfx.play('SWITCH_HIT');
  }
  sleep() {
    this.args.active = false;
  }
  get solid() {
    return false;
  }
}
exports.WallSwitch = WallSwitch;
});

;require.register("actor/WaterController.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WaterController = void 0;
var _PointActor = require("./PointActor");
class WaterController extends _PointActor.PointActor {
  constructor(args, parent) {
    super(args, parent);
    this.args.activated = false;
    this.args.levelLimit = this.args.levelLimit || 0;
    this.args.levelSpeed = this.args.levelSpeed || 1;
    this.args.level = this.args.level || 0;
    this.args.static = true;
    this.args.hidden = true;
  }
  updateStart() {
    super.updateStart();
    if (this.args.switch && !this.switch) {
      this.switch = this.viewport.actorsById[this.args.switch];
    }
    if (this.switch) {
      if (this.switch.args.active > 0) {
        this.activate(this.switch.activator, this.switch);
      }
    }
  }
  update() {
    // if(this.args.activated && this.args.levelSpeed < 18)
    // {
    // 	this.args.levelSpeed += 1;
    // }

    if (this.args.level < this.args._levelLimit) {
      this.args.level += this.args.levelSpeed || 0;
    }
    if (this.args.level > this.args._levelLimit) {
      this.args.levelSpeed = 0;
      this.args.level = this.args._levelLimit;
      const viewport = this.viewport;
      viewport.onFrameOut(30, () => {
        viewport.auras.delete(this);
        if (this.args.target !== undefined) {
          const target = viewport.actorsById[this.args.target];
          viewport.auras.delete(target);
        }
      });
    }
  }
  activate(other, button) {
    if (this.args.activated) {
      return;
    }
    this.args._levelLimit = this.args.levelLimit || 4096;
    this.viewport.auras.add(this);
    this.args.activated = true;
    if (this.args.target !== undefined && this.viewport.actorsById[this.args.target]) {
      const target = this.viewport.actorsById[this.args.target];
      this.viewport.auras.add(target);
      target.activate(other, this);
    }
  }
}
exports.WaterController = WaterController;
});

;require.register("actor/WaterFall.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WaterFall = void 0;
var _PointActor = require("./PointActor");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class WaterFall extends _PointActor.PointActor {
  static fromDef(objDef) {
    const obj = super.fromDef(objDef);
    obj.args.width = objDef.width;
    obj.args.height = objDef.height;
    obj.args.toHeight = objDef.toHeight || 0;
    obj.args.x = objDef.x + 32;
    obj.args.yOriginal = objDef.y;
    return obj;
  }
  constructor() {
    var _this$args$upward;
    super(...arguments);
    _defineProperty(this, "float", -1);
    this.args.width = this.args.width || 32;
    this.args.height = this.args.height || 64;
    this.args.upward = (_this$args$upward = this.args.upward) !== null && _this$args$upward !== void 0 ? _this$args$upward : false;
    this.args.type = 'actor-item actor-water-fall';
    this.args.active = false;
    this.args.static = true;
  }
  onRendered() {
    super.onRendered();
    this.autoAttr.get(this.box)['data-upward'] = 'upward';
  }
  wakeUp() {
    this.switch = this.viewport.actorsById[this.args.switch];
  }
  update() {
    super.update();
    if (this.args.toHeight !== this.args.height) {
      const diff = this.args.toHeight - this.args.height;
      const increment = Math.sign(diff) * 32;
      if (diff <= increment) {
        this.args.height = this.args.toHeight;
        this.args.y = this.args.yOriginal + this.args.toHeight;
      } else {
        this.args.height += increment;
        this.args.y += increment;
      }
    }
    if (this.switch && this.switch.args.active > 0 && !this.args.active) {
      this.args.active = true;
      this.args.toHeight = this.args.openHeight;
      this.args.y -= this.args.openOffset;
    }
  }
  get solid() {
    return false;
  }
  get isEffect() {
    return true;
  }
}
exports.WaterFall = WaterFall;
});

;require.register("actor/WaterJet.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WaterJet = void 0;
var _PointActor = require("./PointActor");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class WaterJet extends _PointActor.PointActor {
  static fromDef(objDef) {
    const obj = super.fromDef(objDef);
    obj.args.width = objDef.width;
    obj.args.height = objDef.height;
    obj.args.x = objDef.x + objDef.width / 2;
    return obj;
  }
  constructor() {
    super(...arguments);
    _defineProperty(this, "float", -1);
    this.args.width = this.args.width || 32;
    this.args.height = this.args.height || 64;
    this.args.type = 'actor-item actor-water-jet';
    this.args.active = false;
    this.args.static = true;
  }
  wakeUp() {
    this.switch = this.viewport.actorsById[this.args.switch];
  }
  update() {
    super.update();
    if (!this.viewport || !this.args.switch) {
      return;
    }
    if (!this.switch) {
      return;
    }
    if (this.switch.args.active && !this.args.active) {
      this.args.active = true;
      this.onNextFrame(() => {
        this.args.x += 0.5 * this.args.openWidth + -0.5 * this.args.width;
        this.args.width = this.args.openWidth;
      });
    }
  }
  get solid() {
    return false;
  }
  get isEffect() {
    return true;
  }
}
exports.WaterJet = WaterJet;
});

;require.register("actor/WaterSpout.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WaterSpout = void 0;
var _PointActor = require("./PointActor");
class WaterSpout extends _PointActor.PointActor {
  static fromDef(objDef) {
    const obj = super.fromDef(objDef);
    obj.args.rotation = objDef.rotation;
    obj.args.height = objDef.height;
    return obj;
  }
  constructor() {
    var _this$args$float, _this$args$static;
    let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let parent = arguments.length > 1 ? arguments[1] : undefined;
    super(args, parent);
    this.args.type = 'actor-item actor-water-spout';
    this.args.float = (_this$args$float = this.args.float) !== null && _this$args$float !== void 0 ? _this$args$float : -1;
    this.args.static = (_this$args$static = this.args.static) !== null && _this$args$static !== void 0 ? _this$args$static : true;
    this.args.width = args.width || 32;
    this.args.height = args.height || 64;
  }
  get solid() {
    return false;
  }
}
exports.WaterSpout = WaterSpout;
});

;require.register("actor/WindStone.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WindStone = void 0;
var _CharacterString = require("../ui/CharacterString");
var _PointActor = require("./PointActor");
class WindStone extends _PointActor.PointActor {
  constructor() {
    super(...arguments);
    this.args.width = 8;
    this.args.height = 24;
    this.args.type = 'actor-item actor-wind-stone';
    this.args.inPlace = false;
    this.label = new _CharacterString.CharacterString({
      value: '❷'
    });
    this.args.charStrings = [this.label];
    this.args.bindTo('inPlace', v => {
      if (!v) {
        this.args.charStrings[0] = this.label;
        return;
      }
      this.args.charStrings.splice(0);
    });
    this.bindTo('carriedBy', carrier => {
      if (this.cX) {
        this.cX();
        this.cX = null;
      }
      if (this.cY) {
        this.cY();
        this.cY = null;
      }
      if (carrier) {
        this.cX = carrier.args.bindTo('x', v => this.args.x = v + carrier.args.direction * 8);
        this.cY = carrier.args.bindTo('y', v => this.args.y = v + -16);
        carrier.carrying.add(this);
        this.args.float = -1;
        this.args.charStrings.splice(0);
      } else if (this.carriedBy) {
        const carrier = this.carriedBy;
        this.carriedBy = null;
        this.args.xSpeed = carrier.args.xSpeed;
        this.args.ySpeed = carrier.args.ySpeed;
        this.args.xSpeed += Math.sign(carrier.args.gSpeed || carrier.args.xSpeed) * 4;
        this.args.ySpeed -= 4;
        carrier.carrying.delete(this);
        this.args.falling = true;
        this.args.float = 0;
        if (!this.args.inPlace) {
          this.args.charStrings[0] = this.label;
        }
      }
    });
  }
  lift(actor) {
    if (this.args.inPlace) {
      return;
    }
    if (this.carriedBy === actor) {
      this.carriedBy = null;
      return;
    }
    this.carriedBy = actor;
  }
  update() {
    super.update();
    if (!this.carriedBy && !this.args.standingOn) {
      this.args.inPlace = false;
      this.args.float = 0;
    }
    if (this.args.inPlace) {
      this.args.x += Math.sign(this.args.standingOn.args.x - this.args.x);
      ;
    }
  }
  get solid() {
    return false;
  }
}
exports.WindStone = WindStone;
});

;require.register("actor/Windmill.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Windmill = void 0;
var _Block = require("./Block");
var _PointActor = require("./PointActor");
const spinTime = 25;
class Windmill extends _PointActor.PointActor {
  constructor() {
    super(...arguments);
    this.args.type = 'actor-item actor-windmill';
    this.args.platform = true;
    this.args.width = 128;
    this.args.height = 32;
    this.args.float = -1;
    this.noClip = true;
    this.spinning = false;
    this.spinFrame = 0;
    this.tossing = null;
    this.spinAngle = 0;
    this.spinDist = 0;
    this.spinDirection = 0;
  }
  tossPlayer(other) {
    let vertical = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    if (this.spinning) {
      return;
    }
    const xCenter = this.args.x;
    const yCenter = this.args.y + -16;
    const xOther = xCenter - other.args.x;
    const yOther = yCenter - other.args.y;
    const dist = Math.max(Math.hypot(8, 8), Math.hypot(yOther, xOther));
    const angle = Math.atan2(yOther, xOther);
    if (dist > Math.hypot(16, 64) || Math.abs(yOther) >= 64 || Math.abs(xOther) >= 64) {
      return;
    }
    this.ignores.set(other, spinTime + 15);
    this.args.column.ignores.set(other, spinTime + 15);
    this.spinning = true;
    other.args.falling = true;
    other.args.standingOn = null;
    other.args.float = spinTime;
    other.args.animation = 'rolling';
    this.tossing = other;
    this.spinFrame = spinTime;
    this.spinAngle = angle;
    this.spinDist = dist;
    this.spinVertical = vertical;
    this.spinDirection = xOther < 0 ? -1 : 1;
    if (vertical) {
      this.spinDirection = xOther < 0 ? 1 : -1;
    }
    other.args.xSpeed = 0;
    other.args.ySpeed = 0;
    other.args.gSpeed = 0;
    if (this.spinDirection < 0) {
      this.args.type = 'actor-item actor-windmill actor-windmill-spinning-back';
    } else {
      this.args.type = 'actor-item actor-windmill actor-windmill-spinning';
    }
    this.viewport.onFrameOut(spinTime + 5, () => {
      this.args.type = 'actor-item actor-windmill';
      this.spinning = false;
      this.tossing = null;
    });
  }
  collideA(other, type) {
    if (other.args.y > this.args.y || other.args.ySpeed < 0) {
      return false;
    }
    if (Math.abs(other.args.ySpeed) < Math.abs(other.args.xSpeed | other.args.gSpeed)) {
      return true;
    }
    if (Math.abs(other.args.xSpeed || other.args.gSpeed) > 16) {
      return true;
    }
    if (!other.controllable) {
      return;
    }
    this.tossPlayer(other);
    return true;
  }
  update() {
    if (this.spinFrame > 0) {
      const spinFrame = spinTime - this.spinFrame;
      const other = this.tossing;
      const xCenter = this.args.x;
      const yCenter = this.args.y + -16;
      const spinAngle = this.spinAngle + -(Math.PI / (spinTime * 0.5) * spinFrame * this.spinDirection);
      other.args.x = xCenter + -Math.cos(spinAngle) * this.spinDist;
      other.args.y = yCenter + -Math.sin(spinAngle) * this.spinDist;
      this.spinFrame--;
      if (this.spinFrame === 0) {
        const other = this.tossing;
        const launchSpeed = Math.min(20, Math.max(17, Math.PI / 8 * this.spinDist));
        if (this.spinVertical) {
          other.args.xSpeed = 0;
          other.args.ySpeed = -launchSpeed;
        } else {
          other.args.xSpeed = -launchSpeed * this.spinDirection;
          other.args.ySpeed = 0;
        }
        other.args.x += other.args.xSpeed;
        other.args.y += other.args.ySpeed;
      }
    }
    super.update();
  }
  updateStart() {
    if (!this.args.column) {
      this.args.column = new WindmillColumn({
        windmill: this,
        hidden: true,
        x: this.args.x,
        y: this.args.y + -32,
        width: 32,
        height: 48,
        float: -1
      });
      this.viewport.spawn.add({
        object: this.args.column
      });
    }
  }
  get solid() {
    return !this.spinning;
  }
}
exports.Windmill = Windmill;
class WindmillColumn extends _Block.Block {
  constructor() {
    super(...arguments);
    this.args.type = 'actor-item actor-windmill-column';
  }
  collideA(other, type) {
    if (!other.controllable) {
      return true;
    }
    if (Math.abs(other.args.ySpeed) > Math.abs(other.args.xSpeed)) {
      return true;
    }
    this.args.windmill.tossPlayer(other, true);
    return true;
  }
  get solid() {
    return !this.args.windmill.spinning;
  }
}
});

;require.register("actor/Window.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Window = void 0;
var _PointActor = require("./PointActor");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class Window extends _PointActor.PointActor {
  constructor() {
    super(...arguments);
    _defineProperty(this, "float", -1);
    this.args.type = 'actor-item actor-window';
    this.args.width = 64;
    this.args.height = 160;
  }
  get solid() {
    return false;
  }
  get isEffect() {
    return true;
  }
}
exports.Window = Window;
});

;require.register("actor/WoodenCrate.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WoodenCrate = void 0;
var _BreakableBlock = require("./BreakableBlock");
var _Platformer = require("../behavior/Platformer");
var _Projectile = require("./Projectile");
var _Spring = require("./Spring");
var _Block = require("./Block");
var _Sfx = require("../audio/Sfx");
var _OrbSmall = require("./OrbSmall");
class WoodenCrate extends _BreakableBlock.BreakableBlock {
  constructor() {
    super(...arguments);
    this.args.type = 'actor-item actor-breakable-block actor-wooden-crate';
    this.args.width = 64;
    this.args.height = 64;
    this.args.static = false;
    this[_Spring.Spring.WontSpring] = true;
  }
  updateStart() {
    if (this.args.static) {
      this.args.static = !!this.bMap('checkBelow', this.x, this.y + 1).get(_Platformer.Platformer);
    } else {
      this.args.static = !this.args.falling;
    }
    if (this.args.gSpeed || this.args.xSpeed) {
      this.args.static = false;
    }
    super.updateStart();
  }
  update() {
    const wasFalling = this.args.falling;
    super.update();
    if (wasFalling && !this.args.falling && this.ySpeedLast > 9) {
      _Sfx.Sfx.play('WOOD_THUD');
    }
  }
  collideA(other, type) {
    if (other.args.ramming) {
      return false;
    }
    if (other instanceof _Block.Block) {
      return true;
    }
    if (type === 0 && other.controllable) {
      return true;
      // return super.collideA(other, type);
    }

    if (other instanceof _OrbSmall.OrbSmall && !this.broken) {
      this.break(other);
      return false;
    }
    if (other instanceof _Projectile.Projectile && !this.broken) {
      this.break(other);
      return true;
    }

    // if(other.spindashCharge)
    // {
    // 	this.break(other);
    // 	return true;
    // }

    // if(type === -1 && !other.args.gSpeed && !other.args.falling && other.controllable)
    // {
    // 	this.break(other);
    // 	return false;
    // }

    if (type !== 1 && type !== 3 || other.y <= this.y - this.args.height) {
      return true;
    }
    if (other.args.rolling || type === 2) {
      this.args.gSpeed = 0;
      this.args.xSpeed = 0;
      this.break(other);
      return false;
    }
    if (other.punching && !this.broken) {
      this.args.gSpeed = 0;
      this.args.xSpeed = 0;
      this.break(other);
      return false;
    }
    if (!this.viewport) {
      return false;
    }
    if (type === -1 || other.args.rolling) {
      return super.collideA(other, type);
    }
    return true;
  }
  setTile() {
    this.args.spriteSheet = '/Sonic/wooden-crate.png';
  }
}
exports.WoodenCrate = WoodenCrate;
});

;require.register("actor/Zipline.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Zipline = void 0;
var _PointActor = require("./PointActor");
class Zipline extends _PointActor.PointActor {
  constructor() {
    super(...arguments);
    this.args.width = 1;
    this.args.height = 1;
    this.args.type = 'actor-item actor-zipline';
    this.args.z = 128;
    this.args.static = false;
    this.breakable = false;
    this.args.decel = 0;
    this.args.accel = 0;
  }
  activate() {
    this.viewport.auras.add(this);
    this.args.launched = true;
  }
  update() {
    if (this.args.launched) {
      if (this.args.gSpeed < 1) {
        this.args.gSpeed = 1;
      }
      this.args.gSpeed += 0.1;
      const maxSpeed = Infinity;
      // const maxSpeed = 25;

      if (this.args.gSpeed > maxSpeed) {
        this.args.gSpeed = maxSpeed;
      }
    }
    super.update();
  }
  collideA(other, type) {
    if (!this.breakable) {
      return true;
    }
    return super.collideA(other, type);
  }
}
exports.Zipline = Zipline;
});

;require.register("actor/monitor/InfoMonitor.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.InfoMonitor = void 0;
var _Monitor = require("../Monitor");
var _Sfx = require("../../audio/Sfx");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class InfoMonitor extends _Monitor.Monitor {
  constructor() {
    super(...arguments);
    _defineProperty(this, "name", 'Info Monitor');
  }
  onRendered(event) {
    super.onRendered(event);
    this.box.attr({
      'data-monitor': 'info'
    });
  }
  effect(other) {
    if (this.args.target && this.viewport.actorsById[this.args.target]) {
      const target = this.viewport.actorsById[this.args.target];
      target.activate(other, this, true);
      other.args.xSpeed *= 0.25;
      other.dropDashCharge = 0;
    }
  }
}
exports.InfoMonitor = InfoMonitor;
});

;require.register("actor/monitor/RingMonitor.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RingMonitor = void 0;
var _Monitor = require("../Monitor");
var _Sfx = require("../../audio/Sfx");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class RingMonitor extends _Monitor.Monitor {
  constructor() {
    super(...arguments);
    _defineProperty(this, "name", 'Ring Monitor');
  }
  onRendered(event) {
    super.onRendered(event);
    this.box.attr({
      'data-monitor': 'ring'
    });
  }
  effect(other) {
    other.args.rings += 10;
    _Sfx.Sfx.play('RING_COLLECTED');
  }
}
exports.RingMonitor = RingMonitor;
});

;require.register("actor/monitor/SheildElectricMonitor.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SheildElectricMonitor = void 0;
var _Monitor = require("../Monitor");
var _ElectricSheild = require("../../powerups/ElectricSheild");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class SheildElectricMonitor extends _Monitor.Monitor {
  constructor() {
    super(...arguments);
    _defineProperty(this, "name", 'Lightning Monitor');
  }
  onRendered(event) {
    super.onRendered(event);
    this.box && this.box.attr({
      'data-monitor': 'sheild-electric'
    });
  }
  effect(other) {
    if (!other.controllable) {
      return;
    }
    const sheild = new _ElectricSheild.ElectricSheild();
    other.inventory.add(sheild);
  }
}
exports.SheildElectricMonitor = SheildElectricMonitor;
});

;require.register("actor/monitor/SheildFireMonitor.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SheildFireMonitor = void 0;
var _Monitor = require("../Monitor");
var _FireSheild = require("../../powerups/FireSheild");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class SheildFireMonitor extends _Monitor.Monitor {
  constructor() {
    super(...arguments);
    _defineProperty(this, "name", 'Fire Monitor');
  }
  onRendered(event) {
    super.onRendered(event);
    this.box.attr({
      'data-monitor': 'sheild-fire'
    });
  }
  effect(other) {
    if (!other.controllable) {
      return;
    }
    const sheild = new _FireSheild.FireSheild();
    other.inventory.add(sheild);
  }
}
exports.SheildFireMonitor = SheildFireMonitor;
});

;require.register("actor/monitor/SheildNormalMonitor.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SheildNormalMonitor = void 0;
var _Monitor = require("../Monitor");
var _NormalSheild = require("../../powerups/NormalSheild");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class SheildNormalMonitor extends _Monitor.Monitor {
  constructor() {
    super(...arguments);
    _defineProperty(this, "name", 'Shield Monitor');
  }
  onRendered(event) {
    super.onRendered(event);
    this.box && this.box.attr({
      'data-monitor': 'sheild-normal'
    });
  }
  effect(other) {
    if (!other.controllable) {
      return;
    }
    const sheild = new _NormalSheild.NormalSheild();
    other.inventory.add(sheild);
  }
}
exports.SheildNormalMonitor = SheildNormalMonitor;
});

;require.register("actor/monitor/SheildStarMonitor.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SheildStarMonitor = void 0;
var _Monitor = require("../Monitor");
var _StarSheild = require("../../powerups/StarSheild");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class SheildStarMonitor extends _Monitor.Monitor {
  constructor() {
    super(...arguments);
    _defineProperty(this, "name", 'Star Monitor');
  }
  onRendered(event) {
    super.onRendered(event);
    this.box.attr({
      'data-monitor': 'sheild-star'
    });
  }
  effect(other) {
    if (!other.controllable) {
      return;
    }
    const sheild = new _StarSheild.StarSheild();
    other.inventory.add(sheild);
  }
}
exports.SheildStarMonitor = SheildStarMonitor;
});

;require.register("actor/monitor/SheildWaterMonitor.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SheildWaterMonitor = void 0;
var _Monitor = require("../Monitor");
var _BubbleSheild = require("../../powerups/BubbleSheild");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class SheildWaterMonitor extends _Monitor.Monitor {
  constructor() {
    super(...arguments);
    _defineProperty(this, "name", 'Bubble Monitor');
  }
  onRendered(event) {
    super.onRendered(event);
    this.box.attr({
      'data-monitor': 'sheild-water'
    });
  }
  effect(other) {
    if (!other.controllable) {
      return;
    }
    const sheild = new _BubbleSheild.BubbleSheild();
    other.inventory.add(sheild);
  }
}
exports.SheildWaterMonitor = SheildWaterMonitor;
});

;require.register("actor/monitor/TripleRingMonitor.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TripleRingMonitor = void 0;
var _Monitor = require("../Monitor");
var _Sfx = require("../../audio/Sfx");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class TripleRingMonitor extends _Monitor.Monitor {
  constructor() {
    super(...arguments);
    _defineProperty(this, "name", 'Triple Ring Monitor');
  }
  onRendered(event) {
    super.onRendered(event);
    this.box.attr({
      'data-monitor': 'triple-ring'
    });
  }
  effect(other) {
    other.args.rings += 30;
    this.viewport.onFrameOut(6, () => _Sfx.Sfx.play('RING_COLLECTED'));
    this.viewport.onFrameOut(18, () => _Sfx.Sfx.play('RING_COLLECTED'));
    this.viewport.onFrameOut(32, () => _Sfx.Sfx.play('RING_COLLECTED'));
  }
}
exports.TripleRingMonitor = TripleRingMonitor;
});

;require.register("actor/monitor/WebMonitor.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WebMonitor = void 0;
var _HtmlFrame = require("../HtmlFrame");
var _Monitor = require("../Monitor");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class WebMonitor extends _Monitor.Monitor {
  constructor() {
    super(...arguments);
    _defineProperty(this, "name", 'Web Monitor');
  }
  onRendered(event) {
    super.onRendered(event);
    this.box.attr({
      'data-monitor': 'web-monitor'
    });
  }
  effect(other) {
    const frame = new _HtmlFrame.HtmlFrame({
      x: this.x,
      y: this.y,
      width: 240,
      height: 180
    });
    this.viewport.spawn.add({
      object: frame
    });
  }
}
exports.WebMonitor = WebMonitor;
});

;require.register("audio/AudioManager.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AudioManager = void 0;
var _Pool = require("curvature/base/Pool");
var _Elicit = require("curvature/net/Elicit");
var _Mixin = require("curvature/base/Mixin");
var _EventTargetMixin = require("curvature/mixin/EventTargetMixin");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class AudioManager extends _Mixin.Mixin.with(_EventTargetMixin.EventTargetMixin) {
  constructor() {
    super(...arguments);
    _defineProperty(this, "volume", 1.0);
    _defineProperty(this, "theme", '/Sonic/carnival-night-zone-act-2-beta.mp3');
    _defineProperty(this, "overlay", '/audio/leslie-wai/feel-the-sunshine.mp3');
    _defineProperty(this, "tracks", new Map());
    _defineProperty(this, "plays", new Map());
    _defineProperty(this, "tags", new Map());
    _defineProperty(this, "factors", new Map());
    _defineProperty(this, "stack", []);
    _defineProperty(this, "playing", null);
    _defineProperty(this, "id3", new Map());
    _defineProperty(this, "request", []);
    _defineProperty(this, "pool", new _Pool.Pool({
      max: 2,
      init: item => {
        item.open();
        return item;
      }
    }));
    _defineProperty(this, "throttle", new Map());
    _defineProperty(this, "tracksPlaying", new Set());
    _defineProperty(this, "tracksPaused", new Set());
  }
  setVolume() {
    let volume = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    this.volume = Math.max(0, Math.min(volume, 1));
    if (this.playing) {
      this.playing.volume = this.volume;
    }
  }
  register(tag, url) {
    let {
      maxConcurrent = 1,
      volume = 1,
      fudgeFactor = 0,
      startTime = 0,
      throttle = 0
    } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    const getTags = new _Elicit.Elicit(url, {
      defer: true
    });
    getTags.addEventListener('error', event => event.preventDefault());
    this.pool.add(getTags);
    if (url.substr(-3) === 'mp3') {
      this.request.push(getTags.buffer().then(buffer => {
        const list = Array(maxConcurrent).fill().map(x => new Audio(url));
        this.tracks.set(tag, list);
        for (const track of list) {
          this.factors.set(track, {
            volume,
            fudgeFactor,
            startTime
          });
        }
        const bytes = new Uint8Array(buffer);
        const prefix = String.fromCharCode(...bytes.slice(0, 3));
        if (prefix !== 'ID3') {
          return;
        }
        const version = bytes[3];
        const revision = bytes[4];
        const flags = bytes[5];
        const size = bytes[6] << 21 | bytes[7] << 14 | bytes[8] << 7 | bytes[9];
        let i = 10;
        const tags = {};
        while (i < size) {
          const framePrefix = String.fromCharCode(...bytes.slice(i, i + 4));
          const frameSize = 10 + (bytes[i + 4] << 21 | bytes[i + 5] << 14 | bytes[i + 6] << 7 | bytes[i + 7]);
          if (frameSize === 10) {
            break;
          }
          if (i + frameSize > size) {
            break;
          }
          const frameValue = String.fromCharCode(...bytes.slice(i + 11, i + frameSize));
          if (!framePrefix) {
            break;
          }
          i += frameSize;
          if (!framePrefix) {
            break;
          }
          tags[framePrefix] = frameValue;
        }
        for (const track of list) {
          this.id3.set(track, tags);
        }
      }));
    } else {
      getTags.objectUrl().then(objectUrl => {
        const list = Array(maxConcurrent).fill().map(x => new Audio(objectUrl));
        this.tracks.set(tag, list);
        for (const track of list) {
          this.factors.set(track, {
            volume,
            fudgeFactor,
            startTime,
            throttle
          });
        }
      });
    }
  }
  play(tag) {
    let loop = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    let options = {
      loop
    };
    if (typeof loop === 'object') {
      options = loop;
      loop = loop.loop;
    }
    if (!this.playing) {
      this.playing = this.stack[this.stack.length - 1];
    }

    // if(this.playing && this.tags.get(this.playing) === tag)
    // {
    // 	if(this.playing.paused)
    // 	{
    // 		const cancelable = true;
    // 		const detail = this.id3.get(this.playing);

    // 		const play = new CustomEvent('play', {detail, cancelable});

    // 		if(!this.dispatchEvent(play))
    // 		{
    // 			return;
    // 		}

    // 		return this.unpause();
    // 	}
    // }
    // else if(this.playing)
    // {
    // 	this.playing.pause();
    // }

    if (!this.tracks.has(tag)) {
      return;
    }
    const candidates = new Map();
    const tracks = this.tracks.get(tag);
    let selected = null;
    for (const track of tracks) {
      if (!this.plays.has(track)) {
        selected = track;
        break;
      }
      candidates.set(track, this.plays.get(track));
    }
    if (!selected) {
      const sorted = [...candidates].sort((a, b) => Math.sign(a[1] - b[1]));
      selected = sorted[0][0];
    }
    if (selected) {
      let {
        volume,
        fudgeFactor,
        startTime,
        throttle
      } = this.factors.get(selected);
      if (throttle) {
        if (Date.now() - this.throttle.get(tag) < throttle) {
          return;
        }
      }
      if ('volume' in options) {
        volume = options.volume;
      }
      const vol = this.volume * (volume + fudgeFactor * (Math.random() + -0.5));
      selected.playbackRate = 1.0;
      selected.currentTime = startTime;
      selected.volume = Math.max(0, Math.min(1, vol));
      selected.loop = loop;
      this.plays.set(selected, Date.now());
      this.playing = selected;
      this.stack.push(this.playing);
      const onCompleted = event => {
        this.playing = this.stack[this.stack.length - 1];
        this.tracksPlaying.delete(selected);
        this.stack.pop();
        this.play();
      };
      this.tags.set(selected, tag);
      const cancelable = true;
      const play = new CustomEvent('play', {
        cancelable
      });
      if (this.dispatchEvent(play)) {
        try {
          selected.play();
          if (!loop) {
            this.playing.addEventListener('ended', onCompleted, {
              once: true
            });
          }
          this.throttle.set(tag, Date.now());
        } catch (error) {
          console.warn(error);
        }
      }
      Promise.all(this.request).then(() => {
        // const detail = this.id3.get(selected);
      });
      this.tracksPlaying.add(selected);
      return true;
    }
  }
  stop() {
    let tag = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    let requeue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    if (tag === null && this.playing) {
      this.playing.pause();
      this.playing = null;
    }
    for (const t of Object.keys(this.stack)) {
      const track = this.stack[t];
      if (!this.tags.has(track)) {
        delete this.stack.splice(t, 1);
        continue;
      }
      if (tag === null || this.tags.get(track) === tag) {
        const cancelable = true;
        const detail = this.id3.get(this.playing);
        const stop = new CustomEvent('stop', {
          detail,
          cancelable
        });
        if (this.dispatchEvent(stop)) {
          if (!track.paused) {
            track.pause();
          }
          delete this.stack.splice(t, 1);
        }
      }
    }
    if (requeue) {
      this.playing = this.stack[this.stack.length - 1];
      if (this.playing) {
        this.play(this.tags.get(this.playing));
      }
    }
  }
  pause() {
    if (!this.playing || this.playing.paused) {
      return;
    }
    const cancelable = true;
    const detail = this.id3.get(this.playing);
    const pause = new CustomEvent('pause', {
      detail,
      cancelable
    });
    if (!this.dispatchEvent(pause)) {
      return;
    }
    for (const track of this.tracksPlaying) {
      this.tracksPaused.add(track);
      track.pause();
    }

    // this.playing.pause();
  }

  unpause() {
    if (!this.playing || !this.playing.paused) {
      return;
    }
    const cancelable = true;
    const detail = this.id3.get(this.playing);
    const unpause = new CustomEvent('unpause', {
      detail,
      cancelable
    });
    if (!this.dispatchEvent(unpause)) {
      return;
    }
    for (const track of this.tracksPaused) {
      this.tracksPaused.delete(track);
      if (track.played && track.played < 1) {
        track.play();
      } else {
        this.tracksPaused.delete(track);
      }
    }

    // this.playing && this.playing.play();
  }

  fadeOut(time) {
    return new Promise(accept => {
      let track;
      let start;
      let initial;
      let interval;
      const fade = () => {
        track = this.playing;
        if (!track) {
          return;
        }
        if (!start) {
          initial = track.volume;
          start = Date.now();
        }
        const now = Date.now();
        const vol = 1 - Math.min(1, (now - start) / time);
        track.volume = vol * initial;
        if (!vol) {
          this.stop(this.tags.get(track));
          clearInterval(interval);
          accept();
        }
      };
      interval = setInterval(fade, 16);
    });
  }
}
exports.AudioManager = AudioManager;
});

;require.register("audio/Bgm.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BgmHandler = exports.Bgm = void 0;
var _Pool = require("curvature/base/Pool");
var _Elicit = require("curvature/net/Elicit");
var _Mixin = require("curvature/base/Mixin");
var _EventTargetMixin = require("curvature/mixin/EventTargetMixin");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class BgmHandler extends _Mixin.Mixin.with(_EventTargetMixin.EventTargetMixin) {
  constructor() {
    super(...arguments);
    _defineProperty(this, "volume", 1.0);
    _defineProperty(this, "tracks", new Map());
    _defineProperty(this, "plays", new Map());
    _defineProperty(this, "tags", new Map());
    _defineProperty(this, "stack", []);
    _defineProperty(this, "playing", null);
    _defineProperty(this, "id3", new Map());
    _defineProperty(this, "request", []);
    _defineProperty(this, "pool", new _Pool.Pool({
      max: 3,
      init: item => {
        item.open();
        return item;
      }
    }));
    _defineProperty(this, "downloads", new Map());
    _defineProperty(this, "cancels", new Map());
  }
  setVolume() {
    let volume = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    this.volume = Math.max(0, Math.min(volume, 1));
    if (this.playing) {
      this.playing.volume = this.volume;
    }
  }
  register(tag, url) {
    let maxConcurrent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    const getTags = new _Elicit.Elicit(url, {
      defer: true
    });
    getTags.addEventListener('error', event => event.preventDefault());
    const getBlob = getTags.blob();
    this.pool.add(getTags);
    const registerTrack = getBlob.then(blob => Promise.all([blob.arrayBuffer(), URL.createObjectURL(blob)])).then(_ref => {
      let [buffer, objectUrl] = _ref;
      this.downloads.delete(tag);
      const list = Array(maxConcurrent).fill().map(x => new Audio(objectUrl));
      this.tracks.set(tag, list);
      const bytes = new Uint8Array(buffer);
      const prefix = String.fromCharCode(...bytes.slice(0, 3));
      if (prefix !== 'ID3') {
        return;
      }
      const version = bytes[3];
      const revision = bytes[4];
      const flags = bytes[5];
      const size = bytes[6] << 21 | bytes[7] << 14 | bytes[8] << 7 | bytes[9];
      let i = 10;
      const tags = {};
      while (i < size) {
        const framePrefix = String.fromCharCode(...bytes.slice(i, i + 4));
        const frameSize = 10 + (bytes[i + 4] << 21 | bytes[i + 5] << 14 | bytes[i + 6] << 7 | bytes[i + 7]);
        if (frameSize === 10) {
          break;
        }
        if (i + frameSize > size) {
          break;
        }
        const frameValue = String.fromCharCode(...bytes.slice(i + 11, i + frameSize));
        if (!framePrefix) {
          break;
        }
        i += frameSize;
        if (!framePrefix) {
          break;
        }
        tags[framePrefix] = frameValue;
      }
      const commentPrefixU = 'XXXComment\u0000';
      const commentPrefixL = 'xxxComment\u0000';
      if (tags['COMM'] && tags['COMM'].substr(0, commentPrefixU.length) === commentPrefixU) {
        tags['COMM'] = tags['COMM'].slice(commentPrefixU.length);
      } else if (tags['COMM'] && tags['COMM'].substr(0, commentPrefixL.length) === commentPrefixL) {
        tags['COMM'] = tags['COMM'].slice(commentPrefixL.length);
      }
      for (const track of list) {
        this.id3.set(track, tags);
      }
    });
    this.request.push(registerTrack);
    this.downloads.set(tag, registerTrack);
  }
  play(tag) {
    let {
      loop = false,
      interlude = false,
      dontClear = false
    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    if (this.downloads.has(tag)) {
      this.downloads.get(tag).then(() => {
        this.downloads.delete(tag);
        this.play(tag, {
          loop,
          interlude,
          dontClear
        });
      });
      return;
    }
    if (this.tags.get(this.playing) !== tag && !interlude && !dontClear) {
      for (const track of this.stack) {
        track.pause();
      }
      this.stack.length = 0;
      this.playing = false;
    }
    if (!this.playing) {
      this.playing = this.stack[this.stack.length - 1];
    }
    if (this.playing && this.tags.get(this.playing) === tag) {
      if (this.playing.paused) {
        const cancelable = true;
        const detail = this.id3.get(this.playing);
        const play = new CustomEvent('play', {
          detail,
          cancelable
        });
        if (!this.dispatchEvent(play)) {
          return;
        }
        return this.unpause();
      }
    } else if (this.playing) {
      this.playing.pause();
    }
    if (!this.tracks.has(tag)) {
      return;
    }
    const candidates = new Map();
    const tracks = this.tracks.get(tag);
    let selected = null;
    for (const track of tracks) {
      if (!this.plays.has(track)) {
        selected = track;
        break;
      }
      candidates.set(this.plays.get(track), track);
    }
    if (!selected) {
      const sorted = [...candidates].sort((a, b) => Math.sign(a[0] - b[0]));
      selected = sorted[0][1];
    }
    if (selected && selected !== this.playing) {
      selected.playbackRate = 1.0;
      selected.currentTime = 0.0;
      selected.volume = this.volume;
      selected.loop = loop;
      this.plays.set(selected, Date.now());
      this.playing = selected;
      this.stack.push(this.playing);
      const onCompleted = event => {
        this.stack.pop();
        this.playing = this.stack[this.stack.length - 1];
        // this.play();
      };

      if (!loop) {
        this.playing.addEventListener('ended', onCompleted, {
          once: true
        });
      }
      this.tags.set(selected, tag);
      Promise.all(this.request).then(() => {
        const cancelable = true;
        const detail = this.id3.get(selected);
        const play = new CustomEvent('play', {
          detail,
          cancelable
        });
        if (this.dispatchEvent(play)) {
          try {
            selected.play();
          } catch (error) {
            console.warn(error);
          }
        }
      });
    }
  }
  stop() {
    let tag = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    if (tag === null && this.playing) {
      this.playing.pause();
      this.playing = null;
    }
    for (const t of Object.keys(this.stack)) {
      const track = this.stack[t];
      if (!this.tags.has(track)) {
        delete this.stack.splice(t, 1);
        continue;
      }
      if (tag === null || this.tags.get(track) === tag) {
        const cancelable = true;
        const detail = this.id3.get(this.playing);
        const stop = new CustomEvent('stop', {
          detail,
          cancelable
        });
        if (this.dispatchEvent(stop)) {
          if (!track.paused) {
            track.pause();
          }
          delete this.stack.splice(t, 1);
        }
      }
    }
    this.playing = this.stack[this.stack.length - 1];
    if (this.playing) {
      this.play(this.tags.get(this.playing), {
        dontClear: true
      });
    }
  }
  pause() {
    if (!this.playing || this.playing.paused) {
      return;
    }
    const cancelable = true;
    const detail = this.id3.get(this.playing);
    const pause = new CustomEvent('pause', {
      detail,
      cancelable
    });
    if (!this.dispatchEvent(pause)) {
      return;
    }
    this.playing.pause();
  }
  unpause() {
    if (!this.playing || !this.playing.paused) {
      return;
    }
    const cancelable = true;
    const detail = this.id3.get(this.playing);
    const unpause = new CustomEvent('unpause', {
      detail,
      cancelable
    });
    if (!this.dispatchEvent(unpause)) {
      return;
    }
    this.playing && this.playing.play();
  }
  fadeOut(time) {
    return new Promise(accept => {
      let track;
      let start;
      let initial;
      let interval;
      track = this.playing;
      const fade = () => {
        if (!track) {
          clearInterval(interval);
          return;
        }
        if (!start) {
          initial = track.volume;
          start = Date.now();
        }
        const now = Date.now();
        const vol = 1 - Math.min(1, (now - start) / time);
        track.volume = vol * initial;
        if (!vol) {
          this.stop(this.tags.get(track));
          clearInterval(interval);
          accept();
        }
      };
      interval = setInterval(fade, 16);
    });
  }
}
exports.BgmHandler = BgmHandler;
const Bgm = new BgmHandler();
exports.Bgm = Bgm;
});

require.register("audio/Sfx.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Sfx = void 0;
var _AudioManager = require("./AudioManager");
const Sfx = new _AudioManager.AudioManager();
exports.Sfx = Sfx;
});

require.register("backdrop/AngelIsland.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AngelIsland = void 0;
var _Backdrop = require("./Backdrop");
const recolor = [{
  '990099': 'fcfcfc',
  '770077': '0048fc',
  '550055': '90fcfc'
}, {
  '990099': '90fcfc',
  '770077': 'fcfcfc',
  '550055': '90fcfc'
}, {
  '990099': '6c90fc',
  '770077': '90fcfc',
  '550055': '90fcfc'
}, {
  '990099': '0048fc',
  '770077': '6c90fc',
  '550055': '90fcfc'
}, {
  '990099': 'fcfcfc',
  '770077': '0048fc',
  '550055': '6c90fc'
}, {
  '990099': '90fcfc',
  '770077': 'fcfcfc',
  '550055': '0048fc'
}, {
  '990099': '6c90fc',
  '770077': '90fcfc',
  '550055': 'fcfcfc'
}, {
  '990099': '0048fc',
  '770077': '6c90fc',
  '550055': '90fcfc'
}];
class AngelIsland extends _Backdrop.Backdrop {
  constructor(args, parent) {
    super(args, parent);
    this.args.name = 'angel-island';
    this.args.strips = [{
      autoscroll: -0.230,
      parallax: 0.005,
      url: '/Sonic/backdrop/angel-island/sky-0.png',
      height: 196
    }, {
      autoscroll: -0.230,
      parallax: 0.005,
      url: '/Sonic/backdrop/angel-island/reflection.png',
      height: 33
    }, {
      autoscroll: 0.000,
      parallax: 0.009,
      url: '/Sonic/backdrop/angel-island/water-1.png',
      interval: 12,
      timeout: 100,
      frame: 0,
      recolor,
      height: -16
    }, {
      autoscroll: 0.000,
      parallax: 0.011,
      url: '/Sonic/backdrop/angel-island/water-2.png',
      height: 8,
      interval: 14,
      timeout: 100,
      frame: 0,
      recolor
    }, {
      autoscroll: 0.000,
      parallax: 0.013,
      url: '/Sonic/backdrop/angel-island/water-3.png',
      height: 8,
      interval: 16,
      timeout: 100,
      frame: 0,
      recolor
    }, {
      autoscroll: 0.000,
      parallax: 0.015,
      url: '/Sonic/backdrop/angel-island/water-4.png',
      height: 16,
      interval: 16,
      timeout: 100,
      frame: 0,
      recolor
    }, {
      autoscroll: 0.000,
      parallax: 0.017,
      url: '/Sonic/backdrop/angel-island/water-5.png',
      height: 8,
      interval: 16,
      timeout: 100,
      frame: 4,
      recolor
    }, {
      autoscroll: 0.000,
      parallax: 0.019,
      url: '/Sonic/backdrop/angel-island/water-6.png',
      height: 8,
      interval: 13,
      timeout: 100,
      frame: 0,
      recolor
    }, {
      autoscroll: 0.000,
      parallax: 0.021,
      url: '/Sonic/backdrop/angel-island/water-7.png',
      height: 16,
      interval: 11,
      timeout: 100,
      frame: 1,
      recolor
    }, {
      autoscroll: 0.000,
      parallax: 0.023,
      url: '/Sonic/backdrop/angel-island/water-8.png',
      height: 8,
      interval: 12,
      timeout: 100,
      frame: 2,
      recolor
    }, {
      autoscroll: 0.000,
      parallax: 0.025,
      url: '/Sonic/backdrop/angel-island/water-9.png',
      height: 8,
      interval: 11,
      timeout: 100,
      frame: 0,
      recolor
    }, {
      autoscroll: 0.000,
      parallax: 0.028,
      url: '/Sonic/backdrop/angel-island/water-10.png',
      height: 8,
      interval: 13,
      timeout: 100,
      frame: 3,
      recolor
    }, {
      autoscroll: 0.000,
      parallax: 0.030,
      url: '/Sonic/backdrop/angel-island/water-11.png',
      height: 16,
      interval: 13,
      timeout: 100,
      frame: 4,
      recolor
    }, {
      autoscroll: 0.000,
      parallax: 0.033,
      url: '/Sonic/backdrop/angel-island/water-12.png',
      height: 8,
      interval: 11,
      timeout: 100,
      frame: 5,
      recolor
    }, {
      autoscroll: 0.000,
      parallax: 0.035,
      url: '/Sonic/backdrop/angel-island/water-13.png',
      height: 7,
      interval: 15,
      timeout: 100,
      frame: 0,
      recolor
    }, {
      autoscroll: 0.000,
      parallax: 0.037,
      url: '/Sonic/backdrop/angel-island/water-14.png',
      height: 8,
      interval: 17,
      timeout: 100,
      frame: 1,
      recolor
    }, {
      autoscroll: 0.000,
      parallax: 0.039,
      url: '/Sonic/backdrop/angel-island/water-15.png',
      height: 8,
      interval: 19,
      timeout: 100,
      frame: 2,
      recolor
    }, {
      autoscroll: 0.000,
      parallax: 0.041,
      url: '/Sonic/backdrop/angel-island/water-16.png',
      height: 6,
      interval: 11,
      timeout: 100,
      frame: 3,
      recolor
    }, {
      autoscroll: 0.000,
      parallax: 0.044,
      url: '/Sonic/backdrop/angel-island/water-17.png',
      height: 10,
      interval: 13,
      timeout: 100,
      frame: 4,
      recolor
    }, {
      autoscroll: 0.000,
      parallax: 0.000,
      url: '/Sonic/backdrop/angel-island/water-18.png',
      height: 32
    }];
  }
}
exports.AngelIsland = AngelIsland;
});

;require.register("backdrop/Backdrop.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Backdrop = void 0;
var _View = require("curvature/base/View");
var _Png = require("../sprite/Png");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
const layers = [];
class Backdrop extends _View.View {
  constructor() {
    super(...arguments);
    _defineProperty(this, "template", `<div class = "backdrop [[name]]">
		<div cv-ref = "backdrop" class = "parallax"></div>
	</div>`);
    _defineProperty(this, "layers", []);
    _defineProperty(this, "urls", []);
    _defineProperty(this, "stacked", 0);
  }
  onAttached(event) {
    if (this.alreadyAttached) {
      return;
    }
    this.alreadyAttached = true;
    const backdrop = this.tags.backdrop;
    const strips = this.args.strips.reverse();
    const yPositions = [];
    const xPositions = [];
    const urls = [];
    let stacked = 0;
    const stripRecolors = [];
    for (const i in strips) {
      const recolors = [];
      const strip = strips[i];
      yPositions.push(`calc(100% - calc(1px * ${stacked}))`);
      let xFormula = `calc(var(--xOffset, 0px) * 1px)`;
      if (strip.parallax) {
        xFormula = `calc(${xFormula} + calc(1px * calc(${strip.parallax} * var(--xPan))))`;
      }
      if (strip.autoscroll) {
        xFormula = `calc(${xFormula} + calc(1px * calc(${strip.autoscroll} * var(--frame) )) )`;
      }
      xPositions.push(xFormula);
      urls.push(strips[i].url);
      stacked += strips[i].height - 1;
      if (strip.recolor) {
        const stripPng = new _Png.Png(strip.url);
        for (const pallete of strip.recolor) {
          recolors.push(stripPng.ready.then(() => stripPng.recolor(pallete).toDataUri()));
        }
        const stripRecolor = Promise.all(recolors).then(frames => strip.frames = frames);
        stripRecolors.push(stripRecolor);
      }
    }
    Promise.all(stripRecolors).then(() => {
      this.refreshLayers();
    });
    this.urls = urls;
    this.stacked = stacked;
    const xPos = xPositions.join(', ');
    const yPos = yPositions.join(', ');
    const url = this.urls.map(u => `url(${u})`).join(', ');
    this.args.xOffset = 0;
    backdrop.style({
      'background-position-y': yPos,
      'background-position-x': xPos,
      'background-repeat': 'repeat-x',
      'background-image': url,
      '--stackHeight': stacked
    });
    this.args.bindTo(['x', 'y', 'xPan', 'yPan', 'bX', 'bY', 'width', 'height', 'right', 'xMax', 'yMax', 'frame', 'stacked', 'top', 'bottom', 'xOffset'], (v, k) => backdrop.style({
      [`--${k}`]: v
    }));
    this.args.bindTo('frame', (v, k) => {
      for (const i in this.args.strips) {
        const strip = this.args.strips[i];
        if (strip.frames) {
          if (strip.timeout-- === 0) {
            strip.timeout = strip.interval;
            strip.frame++;
            if (strip.frame >= strip.frames.length) {
              strip.frame = 0;
            }
            this.urls[i] = strip.frames[strip.frame];
            this.refreshLayers();
          }
        }
      }
    });
  }
  refreshLayers() {
    this.tags.backdrop.style({
      'background-image': this.urls.map(u => `url(${u})`).join(', ')
    });
  }
}
exports.Backdrop = Backdrop;
});

;require.register("backdrop/City.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.City = void 0;
var _Backdrop = require("./Backdrop");
class City extends _Backdrop.Backdrop {
  constructor(args, parent) {
    super(args, parent);
    this.args.name = 'city';
    this.args.strips = [{
      autoscroll: 0.0,
      parallax: 0.128,
      url: '/bttf2/city/sky.png',
      height: 85
    }, {
      autoscroll: 0.0,
      parallax: 0.096,
      url: '/bttf2/city/sky.png',
      height: 85
    }, {
      autoscroll: 0.0,
      parallax: 0.064,
      url: '/bttf2/city/sky.png',
      height: 85
    }, {
      autoscroll: 0.0,
      parallax: 0.048,
      url: '/bttf2/city/sky.png',
      height: 85
    }, {
      autoscroll: 0.0,
      parallax: 0.032,
      url: '/bttf2/city/sky.png',
      height: 85
    }, {
      autoscroll: 0.0,
      parallax: 0.05,
      url: '/bttf2/city/buildings-bg.png',
      height: 76
    }, {
      autoscroll: 0.0,
      parallax: 0.1,
      url: '/bttf2/city/bushes.png',
      height: 144
    }, {
      autoscroll: 0.0,
      parallax: 0.2,
      url: '/bttf2/city/buildings-fg-recolor.png',
      height: 64
    }];
  }
}
exports.City = City;
});

;require.register("backdrop/DarkClouds.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DarkClouds = void 0;
var _Backdrop = require("./Backdrop");
class DarkClouds extends _Backdrop.Backdrop {
  constructor(args, parent) {
    super(args, parent);
    this.args.name = 'dark-clouds';
    this.args.strips = [{
      autoscroll: 0.14,
      parallax: 0.02,
      url: '/Sonic/backdrop/west-side/clouds--1.png',
      height: 64
    }, {
      autoscroll: 0.14,
      parallax: 0.02,
      url: '/Sonic/backdrop/west-side/clouds-0.png',
      height: 33
    }, {
      autoscroll: 0.13,
      parallax: 0.014,
      url: '/Sonic/backdrop/west-side/clouds-1.png',
      height: 32
    }, {
      autoscroll: 0.12,
      parallax: 0.013,
      url: '/Sonic/backdrop/west-side/clouds-2.png',
      height: 24
    }, {
      autoscroll: 0.11,
      parallax: 0.012,
      url: '/Sonic/backdrop/west-side/clouds-3.png',
      height: 16
    }, {
      autoscroll: 0.10,
      parallax: 0.011,
      url: '/Sonic/backdrop/west-side/clouds-4.png',
      height: 5
    }, {
      autoscroll: 0.09,
      parallax: 0.010,
      url: '/Sonic/backdrop/west-side/clouds-5.png',
      height: 3
    }, {
      autoscroll: 0.08,
      parallax: 0.009,
      url: '/Sonic/backdrop/west-side/clouds-6.png',
      height: 8
    }, {
      autoscroll: 0.07,
      parallax: 0.008,
      url: '/Sonic/backdrop/west-side/clouds-7.png',
      height: 5
    }, {
      autoscroll: 0.06,
      parallax: 0.007,
      url: '/Sonic/backdrop/west-side/clouds-8.png',
      height: 3
    }, {
      autoscroll: 0.05,
      parallax: 0.006,
      url: '/Sonic/backdrop/west-side/clouds-9.png',
      height: 8
    }, {
      autoscroll: 0.04,
      parallax: 0.005,
      url: '/Sonic/backdrop/west-side/clouds-10.png',
      height: 8
    }, {
      autoscroll: 0.03,
      parallax: 0.004,
      url: '/Sonic/backdrop/west-side/clouds-11.png',
      height: 32
    }, {
      autoscroll: 0.02,
      parallax: 0.003,
      url: '/Sonic/backdrop/west-side/clouds-12.png',
      height: 8
    }, {
      autoscroll: 0.015,
      parallax: 0.002,
      url: '/Sonic/backdrop/west-side/clouds-13.png',
      height: 32
    }, {
      autoscroll: 0.015,
      parallax: 0.002,
      url: '/Sonic/backdrop/west-side/empty.png',
      height: 120
    }];
    this.args.bindTo('frame', v => {
      if (this.args.ligtening) {
        return;
      }
      if (Math.random() > 0.995) {
        this.args.name = 'dark-clouds lightning';
        this.args.lightning = true;
        this.onTimeout(1000, () => {
          this.args.name = 'dark-clouds';
          this.args.lightning = false;
        });
      }
    });
  }
}
exports.DarkClouds = DarkClouds;
});

;require.register("backdrop/Desert.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Desert = void 0;
var _Backdrop = require("./Backdrop");
class Desert extends _Backdrop.Backdrop {
  constructor(args, parent) {
    super(args, parent);
    this.args.name = 'desert';
    this.args.strips = [{
      autoscroll: 0.0,
      parallax: 0.0,
      url: '/Sonic/backdrop/desert-palace/sky.png',
      height: 32
    }, {
      autoscroll: 0.0,
      parallax: 0.0,
      url: '/Sonic/backdrop/desert-palace/sky.png',
      height: 32
    }, {
      autoscroll: 0.0,
      parallax: 0.0,
      url: '/Sonic/backdrop/desert-palace/sky.png',
      height: 32
    }, {
      autoscroll: 0.0,
      parallax: 0.0,
      url: '/Sonic/backdrop/desert-palace/sky.png',
      height: 32
    }, {
      autoscroll: 0.0,
      parallax: 0.3,
      url: '/Sonic/backdrop/desert-palace/dunes.png',
      height: 28
    }, {
      autoscroll: 0.0,
      parallax: 0.4,
      url: '/Sonic/backdrop/desert-palace/dunes-fg.png',
      height: 12
    }, {
      autoscroll: 0.0,
      parallax: 0.0,
      url: '/Sonic/backdrop/desert-palace/sand-color.png',
      height: 8
    }, {
      autoscroll: 0.0,
      parallax: 0.5,
      url: '/Sonic/backdrop/desert-palace/dunes-fg.png',
      height: 12
    }, {
      autoscroll: 0.0,
      parallax: 0.0,
      url: '/Sonic/backdrop/desert-palace/sand-color.png',
      height: 8
    }, {
      autoscroll: 0.0,
      parallax: 0.0,
      url: '/Sonic/backdrop/desert-palace/sand-color.png',
      height: 8
    }, {
      autoscroll: 0.0,
      parallax: 0.0,
      url: '/Sonic/backdrop/desert-palace/sand-color.png',
      height: 8
    }, {
      autoscroll: 0.0,
      parallax: 0.0,
      url: '/Sonic/backdrop/desert-palace/sand-color.png',
      height: 8
    }, {
      autoscroll: 0.0,
      parallax: 0.6,
      url: '/Sonic/backdrop/desert-palace/dunes-fg.png',
      height: 12
    }, {
      autoscroll: 0.0,
      parallax: 0.0,
      url: '/Sonic/backdrop/desert-palace/sand-color.png',
      height: 8
    }, {
      autoscroll: 0.0,
      parallax: 0.0,
      url: '/Sonic/backdrop/desert-palace/sand-color.png',
      height: 8
    }, {
      autoscroll: 0.0,
      parallax: 0.0,
      url: '/Sonic/backdrop/desert-palace/sand-color.png',
      height: 8
    }, {
      autoscroll: 0.0,
      parallax: 0.0,
      url: '/Sonic/backdrop/desert-palace/sand-color.png',
      height: 8
    }, {
      autoscroll: 0.0,
      parallax: 0.0,
      url: '/Sonic/backdrop/desert-palace/sand-color.png',
      height: 8
    }, {
      autoscroll: 0.0,
      parallax: 0.0,
      url: '/Sonic/backdrop/desert-palace/sand-color.png',
      height: 8
    }, {
      autoscroll: 0.0,
      parallax: 0.0,
      url: '/Sonic/backdrop/desert-palace/sand-color.png',
      height: 8
    }, {
      autoscroll: 0.0,
      parallax: 0.0,
      url: '/Sonic/backdrop/desert-palace/sand-color.png',
      height: 8
    }, {
      autoscroll: 0.0,
      parallax: 0.0,
      url: '/Sonic/backdrop/desert-palace/sand-color.png',
      height: 8
    }, {
      autoscroll: 0.0,
      parallax: 0.0,
      url: '/Sonic/backdrop/desert-palace/sand-color.png',
      height: 8
    }, {
      autoscroll: 0.0,
      parallax: 0.0,
      url: '/Sonic/backdrop/desert-palace/sand-color.png',
      height: 8
    }, {
      autoscroll: 0.0,
      parallax: 0.0,
      url: '/Sonic/backdrop/desert-palace/sand-color.png',
      height: 8
    }, {
      autoscroll: 0.0,
      parallax: 0.0,
      url: '/Sonic/backdrop/desert-palace/sand-color.png',
      height: 8
    }, {
      autoscroll: 0.0,
      parallax: 0.0,
      url: '/Sonic/backdrop/desert-palace/sand-color.png',
      height: 8
    }, {
      autoscroll: 0.0,
      parallax: 0.0,
      url: '/Sonic/backdrop/desert-palace/sand-color.png',
      height: 8
    }];
  }
}
exports.Desert = Desert;
});

;require.register("backdrop/IceCap.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.IceCap = void 0;
var _Backdrop = require("./Backdrop");
class IceCap extends _Backdrop.Backdrop {
  constructor(args, parent) {
    super(args, parent);
    this.args.name = 'ice-cap';
    this.args.strips = [{
      autoscroll: 0,
      parallax: 0,
      url: '/Sonic/backdrop/ice-cap/mountains-13.png',
      height: 64
    }, {
      autoscroll: 0,
      parallax: 0.01,
      url: '/Sonic/backdrop/ice-cap/mountains-12.png',
      height: 4
    }, {
      autoscroll: 0,
      parallax: 0.02,
      url: '/Sonic/backdrop/ice-cap/mountains-11.png',
      height: 12
    }, {
      autoscroll: 0,
      parallax: 0.025,
      url: '/Sonic/backdrop/ice-cap/mountains-10.png',
      height: 11
    }, {
      autoscroll: 0,
      parallax: 0.03,
      url: '/Sonic/backdrop/ice-cap/mountains-9.png',
      height: 13
    }, {
      autoscroll: 0,
      parallax: 0.03,
      url: '/Sonic/backdrop/ice-cap/mountains-8.png',
      height: 24
    }, {
      autoscroll: 0,
      parallax: 0.045,
      url: '/Sonic/backdrop/ice-cap/mountains-7.png',
      height: 80
    }, {
      autoscroll: 0,
      parallax: 0.05,
      url: '/Sonic/backdrop/ice-cap/mountains-6.png',
      height: 3
    }, {
      autoscroll: 0,
      parallax: 0.06,
      url: '/Sonic/backdrop/ice-cap/mountains-5.png',
      height: 7
    }, {
      autoscroll: 0,
      parallax: 0.07,
      url: '/Sonic/backdrop/ice-cap/mountains-4.png',
      height: 14
    }, {
      autoscroll: 0,
      parallax: 0.08,
      url: '/Sonic/backdrop/ice-cap/mountains-3.png',
      height: 24
    }, {
      autoscroll: 0,
      parallax: 0.09,
      url: '/Sonic/backdrop/ice-cap/mountains-2.png',
      height: 32
    }, {
      autoscroll: 0,
      parallax: 0.1,
      url: '/Sonic/backdrop/ice-cap/mountains-1.png',
      height: 32
    }, {
      autoscroll: 0,
      parallax: 0.11,
      url: '/Sonic/backdrop/ice-cap/mountains-4.png',
      height: 14
    }, {
      autoscroll: 0,
      parallax: 0.12,
      url: '/Sonic/backdrop/ice-cap/mountains-3.png',
      height: 24
    }, {
      autoscroll: 0,
      parallax: 0.13,
      url: '/Sonic/backdrop/ice-cap/mountains-2.png',
      height: 32
    }, {
      autoscroll: 0,
      parallax: 0.14,
      url: '/Sonic/backdrop/ice-cap/mountains-1.png',
      height: 32
    }];
  }
}
exports.IceCap = IceCap;
});

;require.register("backdrop/Industrial.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Industrial = void 0;
var _Backdrop = require("./Backdrop");
var _Tag = require("curvature/base/Tag");
class Industrial extends _Backdrop.Backdrop {
  constructor(args, parent) {
    super(args, parent);
    this.args.name = 'industrial';
    this.args.sunrise = 0;
    this.args.bindTo('sunrise', v => {
      this.nodes[1] && this.nodes[1].style.setProperty('--sunrise', v);
    });
    this.args.strips = [{
      autoscroll: 0.7,
      parallax: 0.055,
      url: '/Sonic/backdrop/labrynth-industrial/0.png',
      height: 24
    }, {
      autoscroll: 0.65,
      parallax: 0.050,
      url: '/Sonic/backdrop/labrynth-industrial/1.png',
      height: 24
    }, {
      autoscroll: 0.60,
      parallax: 0.045,
      url: '/Sonic/backdrop/labrynth-industrial/0.png',
      height: 24
    }, {
      autoscroll: 0.55,
      parallax: 0.040,
      url: '/Sonic/backdrop/labrynth-industrial/1.png',
      height: 24
    }, {
      autoscroll: 0.50,
      parallax: 0.035,
      url: '/Sonic/backdrop/labrynth-industrial/0.png',
      height: 24
    }, {
      autoscroll: 0.40,
      parallax: 0.030,
      url: '/Sonic/backdrop/labrynth-industrial/1.png',
      height: 24
    }, {
      autoscroll: 0.35,
      parallax: 0.025,
      url: '/Sonic/backdrop/labrynth-industrial/0.png',
      height: 24
    }, {
      autoscroll: 0.30,
      parallax: 0.020,
      url: '/Sonic/backdrop/labrynth-industrial/1.png',
      height: 24
    }, {
      autoscroll: 0.25,
      parallax: 0.015,
      url: '/Sonic/backdrop/labrynth-industrial/2.png',
      height: 24
    }, {
      autoscroll: 0.20,
      parallax: 0.010,
      url: '/Sonic/backdrop/labrynth-industrial/3.png',
      height: 24
    }, {
      autoscroll: 0,
      parallax: 0.02,
      url: '/Sonic/backdrop/labrynth-industrial/4-dist.png',
      height: 70
    }, {
      autoscroll: 0,
      parallax: 0.05,
      url: '/Sonic/backdrop/labrynth-industrial/4.png',
      height: 0
    }, {
      autoscroll: 0,
      parallax: 0.05,
      url: '/Sonic/backdrop/labrynth-industrial/flame-0.png',
      height: 1,
      interval: 1,
      timeout: 0,
      frame: 0,
      frames: ['/Sonic/backdrop/labrynth-industrial/flame-0a.png', '/Sonic/backdrop/labrynth-industrial/flame-1.png', '/Sonic/backdrop/labrynth-industrial/flame-1.png', '/Sonic/backdrop/labrynth-industrial/flame-2.png', '/Sonic/backdrop/labrynth-industrial/flame-0.png', '/Sonic/backdrop/labrynth-industrial/flame-2.png', '/Sonic/backdrop/labrynth-industrial/flame-2.png', '/Sonic/backdrop/labrynth-industrial/flame-2.png', '/Sonic/backdrop/labrynth-industrial/flame-3.png', '/Sonic/backdrop/labrynth-industrial/flame-0.png', '/Sonic/backdrop/labrynth-industrial/flame-3.png', '/Sonic/backdrop/labrynth-industrial/flame-3.png', '/Sonic/backdrop/labrynth-industrial/flame-4.png', '/Sonic/backdrop/labrynth-industrial/flame-0.png', '/Sonic/backdrop/labrynth-industrial/flame-4.png', '/Sonic/backdrop/labrynth-industrial/flame-5.png', '/Sonic/backdrop/labrynth-industrial/flame-6.png', '/Sonic/backdrop/labrynth-industrial/flame-0.png', '/Sonic/backdrop/labrynth-industrial/flame-6.png', '/Sonic/backdrop/labrynth-industrial/flame-6.png', '/Sonic/backdrop/labrynth-industrial/flame-0.png', '/Sonic/backdrop/labrynth-industrial/flame-0.png', '/Sonic/backdrop/labrynth-industrial/flame-0.png', '/Sonic/backdrop/labrynth-industrial/flame-0.png', '/Sonic/backdrop/labrynth-industrial/flame-0.png', '/Sonic/backdrop/labrynth-industrial/flame-0.png', '/Sonic/backdrop/labrynth-industrial/flame-0.png', '/Sonic/backdrop/labrynth-industrial/flame-0.png', '/Sonic/backdrop/labrynth-industrial/flame-0.png', '/Sonic/backdrop/labrynth-industrial/flame-0.png', '/Sonic/backdrop/labrynth-industrial/flame-0.png', '/Sonic/backdrop/labrynth-industrial/flame-0.png', '/Sonic/backdrop/labrynth-industrial/flame-0.png', '/Sonic/backdrop/labrynth-industrial/flame-0.png', '/Sonic/backdrop/labrynth-industrial/flame-0.png', '/Sonic/backdrop/labrynth-industrial/flame-0.png', '/Sonic/backdrop/labrynth-industrial/flame-0.png', '/Sonic/backdrop/labrynth-industrial/flame-0.png']
    }, {
      autoscroll: 0,
      parallax: 0.05,
      url: '/Sonic/backdrop/labrynth-industrial/flame-0.png',
      height: 1,
      interval: 1,
      timeout: 0,
      frame: 0,
      frames: ['/Sonic/backdrop/labrynth-industrial/flame-b-0a.png', '/Sonic/backdrop/labrynth-industrial/flame-b-1.png', '/Sonic/backdrop/labrynth-industrial/flame-b-1.png', '/Sonic/backdrop/labrynth-industrial/flame-b-2.png', '/Sonic/backdrop/labrynth-industrial/flame-b-0.png', '/Sonic/backdrop/labrynth-industrial/flame-b-2.png', '/Sonic/backdrop/labrynth-industrial/flame-b-2.png', '/Sonic/backdrop/labrynth-industrial/flame-b-2.png', '/Sonic/backdrop/labrynth-industrial/flame-b-3.png', '/Sonic/backdrop/labrynth-industrial/flame-b-0.png', '/Sonic/backdrop/labrynth-industrial/flame-b-3.png', '/Sonic/backdrop/labrynth-industrial/flame-b-3.png', '/Sonic/backdrop/labrynth-industrial/flame-b-4.png', '/Sonic/backdrop/labrynth-industrial/flame-b-0.png', '/Sonic/backdrop/labrynth-industrial/flame-b-4.png', '/Sonic/backdrop/labrynth-industrial/flame-b-5.png', '/Sonic/backdrop/labrynth-industrial/flame-b-6.png', '/Sonic/backdrop/labrynth-industrial/flame-b-0.png', '/Sonic/backdrop/labrynth-industrial/flame-b-6.png', '/Sonic/backdrop/labrynth-industrial/flame-b-6.png', '/Sonic/backdrop/labrynth-industrial/flame-b-0.png', '/Sonic/backdrop/labrynth-industrial/flame-b-0.png', '/Sonic/backdrop/labrynth-industrial/flame-b-0.png', '/Sonic/backdrop/labrynth-industrial/flame-b-0.png', '/Sonic/backdrop/labrynth-industrial/flame-b-0.png', '/Sonic/backdrop/labrynth-industrial/flame-b-0.png', '/Sonic/backdrop/labrynth-industrial/flame-b-0.png', '/Sonic/backdrop/labrynth-industrial/flame-b-0.png', '/Sonic/backdrop/labrynth-industrial/flame-b-0.png', '/Sonic/backdrop/labrynth-industrial/flame-b-0.png', '/Sonic/backdrop/labrynth-industrial/flame-b-0.png', '/Sonic/backdrop/labrynth-industrial/flame-b-0.png', '/Sonic/backdrop/labrynth-industrial/flame-b-0.png', '/Sonic/backdrop/labrynth-industrial/flame-b-0.png', '/Sonic/backdrop/labrynth-industrial/flame-b-0.png', '/Sonic/backdrop/labrynth-industrial/flame-b-0.png', '/Sonic/backdrop/labrynth-industrial/flame-b-0.png', '/Sonic/backdrop/labrynth-industrial/flame-b-0.png']
    }, {
      autoscroll: 0,
      parallax: 0.05,
      url: '/Sonic/backdrop/labrynth-industrial/flame-0.png',
      height: 1,
      interval: 1,
      timeout: 0,
      frame: 0,
      frames: ['/Sonic/backdrop/labrynth-industrial/flame-c-0a.png', '/Sonic/backdrop/labrynth-industrial/flame-c-1.png', '/Sonic/backdrop/labrynth-industrial/flame-c-1.png', '/Sonic/backdrop/labrynth-industrial/flame-c-2.png', '/Sonic/backdrop/labrynth-industrial/flame-c-0.png', '/Sonic/backdrop/labrynth-industrial/flame-c-2.png', '/Sonic/backdrop/labrynth-industrial/flame-c-2.png', '/Sonic/backdrop/labrynth-industrial/flame-c-2.png', '/Sonic/backdrop/labrynth-industrial/flame-c-3.png', '/Sonic/backdrop/labrynth-industrial/flame-c-0.png', '/Sonic/backdrop/labrynth-industrial/flame-c-3.png', '/Sonic/backdrop/labrynth-industrial/flame-c-3.png', '/Sonic/backdrop/labrynth-industrial/flame-c-4.png', '/Sonic/backdrop/labrynth-industrial/flame-c-0.png', '/Sonic/backdrop/labrynth-industrial/flame-c-4.png', '/Sonic/backdrop/labrynth-industrial/flame-c-5.png', '/Sonic/backdrop/labrynth-industrial/flame-c-6.png', '/Sonic/backdrop/labrynth-industrial/flame-c-0.png', '/Sonic/backdrop/labrynth-industrial/flame-c-6.png', '/Sonic/backdrop/labrynth-industrial/flame-c-6.png', '/Sonic/backdrop/labrynth-industrial/flame-c-0.png']
    }, {
      autoscroll: 0,
      parallax: 0.125,
      url: '/Sonic/backdrop/labrynth-industrial/5-bw-small.png',
      height: 10
    }, {
      autoscroll: 0,
      parallax: 0.15,
      url: '/Sonic/backdrop/labrynth-industrial/5-bw-small.png',
      height: 10
    }, {
      autoscroll: 0,
      parallax: 0.275,
      url: '/Sonic/backdrop/labrynth-industrial/5-dim.png',
      height: 50
    }, {
      autoscroll: 0,
      parallax: 0.275,
      url: '/Sonic/backdrop/labrynth-industrial/5-pink-lights.png',
      height: 1,
      interval: 20,
      timeout: 0,
      frame: 0,
      frames: ['/Sonic/backdrop/labrynth-industrial/5-lights-0.png', '/Sonic/backdrop/labrynth-industrial/5-lights-0.png', '/Sonic/backdrop/labrynth-industrial/5-lights-1.png', '/Sonic/backdrop/labrynth-industrial/5-lights-1.png', '/Sonic/backdrop/labrynth-industrial/5-lights-2.png', '/Sonic/backdrop/labrynth-industrial/5-lights-2.png']
    }, {
      autoscroll: 0,
      parallax: 0.275,
      url: '/Sonic/backdrop/labrynth-industrial/5-signals-0.png',
      height: 1,
      interval: 10,
      timeout: 0,
      frame: 0,
      frames: ['/Sonic/backdrop/labrynth-industrial/5-signals-0.png', '/Sonic/backdrop/labrynth-industrial/5-signals-1.png', '/Sonic/backdrop/labrynth-industrial/5-signals-1.png', '/Sonic/backdrop/labrynth-industrial/5-signals-1.png', '/Sonic/backdrop/labrynth-industrial/5-signals-1.png', '/Sonic/backdrop/labrynth-industrial/5-signals-0.png', '/Sonic/backdrop/labrynth-industrial/5-signals-2.png', '/Sonic/backdrop/labrynth-industrial/5-signals-2.png', '/Sonic/backdrop/labrynth-industrial/5-signals-2.png', '/Sonic/backdrop/labrynth-industrial/5-signals-2.png']
    }, {
      autoscroll: 0,
      parallax: 0.35,
      url: '/Sonic/backdrop/labrynth-industrial/5.png',
      height: 40
    }, {
      autoscroll: 0,
      parallax: 0.35,
      url: '/Sonic/backdrop/labrynth-industrial/5-pink-lights.png',
      height: 1
      // , interval: 100
      // , timeout:  0
      // , frame:    0
      // , frames:   [
      // 	'/Sonic/backdrop/labrynth-industrial/5-lights-0.png',
      // 	'/Sonic/backdrop/labrynth-industrial/5-lights-1.png'
      // ]
    }, {
      autoscroll: 0,
      parallax: 0.35,
      url: '/Sonic/backdrop/labrynth-industrial/5-signals-0.png',
      height: 1,
      interval: 20,
      timeout: 0,
      frame: 0,
      frames: ['/Sonic/backdrop/labrynth-industrial/5-signals-0.png', '/Sonic/backdrop/labrynth-industrial/5-signals-2.png', '/Sonic/backdrop/labrynth-industrial/5-signals-2.png', '/Sonic/backdrop/labrynth-industrial/5-signals-2.png', '/Sonic/backdrop/labrynth-industrial/5-signals-2.png', '/Sonic/backdrop/labrynth-industrial/5-signals-0.png', '/Sonic/backdrop/labrynth-industrial/5-signals-1.png', '/Sonic/backdrop/labrynth-industrial/5-signals-1.png', '/Sonic/backdrop/labrynth-industrial/5-signals-1.png', '/Sonic/backdrop/labrynth-industrial/5-signals-1.png']
    }, {
      autoscroll: 0,
      parallax: 0.4,
      url: '/Sonic/backdrop/labrynth-industrial/6-half.png',
      height: 88
    }];
  }
}
exports.Industrial = Industrial;
});

;require.register("backdrop/MarbleGarden.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MarbleGarden = void 0;
var _Backdrop = require("./Backdrop");
class MarbleGarden extends _Backdrop.Backdrop {
  constructor(args, parent) {
    super(args, parent);
    this.args.name = 'marble-garden';
    this.args.strips = [{
      autoscroll: -1.25,
      parallax: 0.015,
      url: '/Sonic/backdrop/marble-garden/0.png',
      height: 32
    }, {
      autoscroll: -1,
      parallax: 0.015,
      url: '/Sonic/backdrop/marble-garden/1.png',
      height: 24
    }, {
      autoscroll: -0.9,
      parallax: 0.015,
      url: '/Sonic/backdrop/marble-garden/2.png',
      height: 8
    }, {
      autoscroll: -0.8,
      parallax: 0.015,
      url: '/Sonic/backdrop/marble-garden/3.png',
      height: 24
    }, {
      autoscroll: -0.7,
      parallax: 0.015,
      url: '/Sonic/backdrop/marble-garden/4.png',
      height: 8
    }, {
      autoscroll: -0.6,
      parallax: 0.0125,
      url: '/Sonic/backdrop/marble-garden/5.png',
      height: 24
    }, {
      autoscroll: -0.5,
      parallax: 0.0125,
      url: '/Sonic/backdrop/marble-garden/6.png',
      height: 16
    }, {
      autoscroll: -0.45,
      parallax: 0.0125,
      url: '/Sonic/backdrop/marble-garden/7.png',
      height: 8
    }, {
      autoscroll: -0.45,
      parallax: 0.0125,
      url: '/Sonic/backdrop/marble-garden/8.png',
      height: 16
    }, {
      autoscroll: -0.4,
      parallax: 0.0125,
      url: '/Sonic/backdrop/marble-garden/9.png',
      height: 8
    }, {
      autoscroll: -0.35,
      parallax: 0.0125,
      url: '/Sonic/backdrop/marble-garden/10.png',
      height: 16
    }, {
      autoscroll: -0.3,
      parallax: 0.01,
      url: '/Sonic/backdrop/marble-garden/11.png',
      height: 8
    }, {
      autoscroll: -0.25,
      parallax: 0.0075,
      url: '/Sonic/backdrop/marble-garden/12.png',
      height: 8
    }, {
      autoscroll: -0.2,
      parallax: 0.0075,
      url: '/Sonic/backdrop/marble-garden/13.png',
      height: 8
    }, {
      autoscroll: -0.15,
      parallax: 0.01,
      url: '/Sonic/backdrop/marble-garden/14.png',
      height: 8
    }, {
      autoscroll: -0.1,
      parallax: 0.01,
      url: '/Sonic/backdrop/marble-garden/15.png',
      height: 5
    }, {
      autoscroll: 0,
      parallax: 0.1,
      url: '/Sonic/backdrop/marble-garden/16.png',
      height: 30
    }, {
      autoscroll: 0,
      parallax: 0.125,
      url: '/Sonic/backdrop/marble-garden/17.png',
      height: 12
    }, {
      autoscroll: 0,
      parallax: 0.125,
      url: '/Sonic/backdrop/marble-garden/18.png',
      height: 6
    }, {
      autoscroll: 0,
      parallax: 0.15,
      url: '/Sonic/backdrop/marble-garden/19.png',
      height: 6
    }, {
      autoscroll: 0,
      parallax: 0.175,
      url: '/Sonic/backdrop/marble-garden/20.png',
      height: 8
    }, {
      autoscroll: 0,
      parallax: 0.2,
      url: '/Sonic/backdrop/marble-garden/21.png',
      height: 8
    }, {
      autoscroll: 0,
      parallax: 0.225,
      url: '/Sonic/backdrop/marble-garden/22.png',
      height: 24
    }, {
      autoscroll: 0,
      parallax: 0.25,
      url: '/Sonic/backdrop/marble-garden/23.png',
      height: 344
    }];
  }
}
exports.MarbleGarden = MarbleGarden;
});

;require.register("backdrop/Moon.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Moon = void 0;
var _Backdrop = require("./Backdrop");
class Moon extends _Backdrop.Backdrop {
  constructor(args, parent) {
    super(args, parent);
    this.args.name = 'moon';
    this.args.strips = [{
      autoscroll: 0.035,
      parallax: 0.0019,
      url: '/Sonic/backdrop/doomsday/backdrop-inverted-0-0a.png',
      height: 13
    }, {
      autoscroll: 0.03,
      parallax: 0.0016,
      url: '/Sonic/backdrop/doomsday/backdrop-inverted-0-0b.png',
      height: 13
    }, {
      autoscroll: 0.025,
      parallax: 0.0015,
      url: '/Sonic/backdrop/doomsday/backdrop-inverted-0-1.png',
      height: 12
    }, {
      autoscroll: 0.02,
      parallax: 0.0013,
      url: '/Sonic/backdrop/doomsday/backdrop-inverted-0-2.png',
      height: 12
    }, {
      autoscroll: 0.015,
      parallax: 0.0010,
      url: '/Sonic/backdrop/doomsday/backdrop-inverted-0-3.png',
      height: 8
    }, {
      autoscroll: 0.01,
      parallax: 0.0009,
      url: '/Sonic/backdrop/doomsday/backdrop-inverted-0-4.png',
      height: 5
    }, {
      autoscroll: 0.005,
      parallax: 0.0007,
      url: '/Sonic/backdrop/doomsday/backdrop-inverted-0-5.png',
      height: 14
    }, {
      autoscroll: 0.0025,
      parallax: 0.0005,
      url: '/Sonic/backdrop/doomsday/backdrop-inverted-0-6.png',
      height: 140
    }, {
      autoscroll: 0,
      parallax: 0.030,
      url: '/mmpr/moon/terrain-00-00.png',
      height: 0
    }, {
      autoscroll: 0,
      parallax: 0.035,
      url: '/mmpr/moon/terrain-00-01.png',
      height: 2
    }, {
      autoscroll: 0,
      parallax: 0.045,
      url: '/mmpr/moon/terrain-00-02.png',
      height: 3
    }, {
      autoscroll: 0,
      parallax: 0.055,
      url: '/mmpr/moon/terrain-00-03.png',
      height: 4
    }, {
      autoscroll: 0,
      parallax: 0.065,
      url: '/mmpr/moon/terrain-00-04.png',
      height: 4
    }, {
      autoscroll: 0,
      parallax: 0.075,
      url: '/mmpr/moon/terrain-00-05.png',
      height: 10
    }, {
      autoscroll: 0,
      parallax: 0.085,
      url: '/mmpr/moon/terrain-00-06.png',
      height: 5
    }, {
      autoscroll: 0,
      parallax: 0.095,
      url: '/mmpr/moon/terrain-00-07-b.png',
      height: 10
    }, {
      autoscroll: 0,
      parallax: 0.1,
      url: '/mmpr/moon/terrain-00-08.png',
      height: 10
    }, {
      autoscroll: 0,
      parallax: 0.105,
      url: '/mmpr/moon/terrain-00-09.png',
      height: 12
    }, {
      autoscroll: 0,
      parallax: 0.115,
      url: '/mmpr/moon/terrain-00-10-b.png',
      height: 12
    }, {
      autoscroll: 0,
      parallax: 0.125,
      url: '/mmpr/moon/terrain-00-11.png',
      height: 5
    }, {
      autoscroll: 0,
      parallax: 0.1325,
      url: '/mmpr/moon/terrain-00-09-b.png',
      height: 12
    }
    // , {
    // 	autoscroll:  0
    // 	, parallax:  0.145
    // 	, url:       '/mmpr/moon/terrain-00-10.png'
    // 	, height:    12
    // }
    , {
      autoscroll: 0,
      parallax: 0.1435,
      url: '/mmpr/moon/terrain-00-12.png',
      height: 22
    }];
  }
}
exports.Moon = Moon;
});

;require.register("backdrop/MushroomHill.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MushroomHill = void 0;
var _Backdrop = require("./Backdrop");
class MushroomHill extends _Backdrop.Backdrop {
  constructor(args, parent) {
    super(args, parent);
    this.args.name = 'mushroom-hill-summer';
    this.args.strips = [{
      autoscroll: 0,
      parallax: 0,
      url: '/Sonic/backdrop/mushroom-hill/blank.png',
      height: 320 + 12
    }, {
      autoscroll: 0,
      parallax: 0.05,
      url: '/Sonic/backdrop/marble-garden-1/hills-recolored_1.png',
      height: 8
    }, {
      autoscroll: 0,
      parallax: 0.06,
      url: '/Sonic/backdrop/marble-garden-1/hills-recolored_2.png',
      height: 8
    }, {
      autoscroll: 0,
      parallax: 0.07,
      url: '/Sonic/backdrop/marble-garden-1/hills-recolored_3.png',
      height: 8
    }, {
      autoscroll: 0,
      parallax: 0.08,
      url: '/Sonic/backdrop/marble-garden-1/hills-recolored_4.png',
      height: 24
    }, {
      autoscroll: 0,
      parallax: 0.09,
      url: '/Sonic/backdrop/marble-garden-1/hills-recolored_5.png',
      height: 120
    }
    // , {
    // 	autoscroll: 0
    // 	, parallax: 0.10
    // 	, url:      '/Sonic/backdrop/mushroom-hill/background-hills-summer.png'
    // 	, height:   10 + -32
    // }
    , {
      autoscroll: 0,
      parallax: 0.11,
      url: '/Sonic/backdrop/mushroom-hill/background-trees-summer-edit.png',
      height: 0
    }, {
      autoscroll: 0,
      parallax: 0.165,
      url: '/Sonic/backdrop/mushroom-hill/foreground-summer.png',
      height: 224
    }];
  }
}
exports.MushroomHill = MushroomHill;
});

;require.register("backdrop/MysticCave.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MysticCave = void 0;
var _Backdrop = require("./Backdrop");
class MysticCave extends _Backdrop.Backdrop {
  constructor(args, parent) {
    super(args, parent);
    this.args.name = 'mystic-cave';
    this.args.strips = [{
      autoscroll: 0,
      parallax: 0.27,
      url: '/Sonic/backdrop/mystic-cave/1.png',
      height: 37
    }, {
      autoscroll: 0,
      parallax: 0.23,
      url: '/Sonic/backdrop/mystic-cave/2.png',
      height: 23
    }, {
      autoscroll: 0,
      parallax: 0.21,
      url: '/Sonic/backdrop/mystic-cave/3.png',
      height: 18
    }, {
      autoscroll: 0,
      parallax: 0.20,
      url: '/Sonic/backdrop/mystic-cave/4.png',
      height: 7
    }, {
      autoscroll: 0,
      parallax: 0.19,
      url: '/Sonic/backdrop/mystic-cave/5.png',
      height: 6
    }, {
      autoscroll: 0,
      parallax: 0.18,
      url: '/Sonic/backdrop/mystic-cave/6.png',
      height: 1
    }, {
      autoscroll: 0,
      parallax: 0.17,
      url: '/Sonic/backdrop/mystic-cave/7.png',
      height: 1
    }, {
      autoscroll: 0,
      parallax: 0.16,
      url: '/Sonic/backdrop/mystic-cave/8.png',
      height: 1
    }, {
      autoscroll: 0,
      parallax: 0.15,
      url: '/Sonic/backdrop/mystic-cave/9.png',
      height: 1
    }, {
      autoscroll: 0,
      parallax: 0.14,
      url: '/Sonic/backdrop/mystic-cave/10.png',
      height: 1
    }, {
      autoscroll: 0,
      parallax: 0.13,
      url: '/Sonic/backdrop/mystic-cave/11.png',
      height: 48
    }, {
      autoscroll: 0,
      parallax: 0.14,
      url: '/Sonic/backdrop/mystic-cave/12.png',
      height: 13
    }, {
      autoscroll: 0,
      parallax: 0.15,
      url: '/Sonic/backdrop/mystic-cave/13.png',
      height: 19
    }, {
      autoscroll: 0,
      parallax: 0.17,
      url: '/Sonic/backdrop/mystic-cave/14.png',
      height: 34
    }, {
      autoscroll: 0,
      parallax: 0.20,
      url: '/Sonic/backdrop/mystic-cave/15.png',
      height: 62
    }, {
      autoscroll: 0,
      parallax: 0.17,
      url: '/Sonic/backdrop/mystic-cave/16.png',
      height: 32
    }, {
      autoscroll: 0,
      parallax: 0.14,
      url: '/Sonic/backdrop/mystic-cave/16.5.png',
      height: 19
    }, {
      autoscroll: 0,
      parallax: 0.13,
      url: '/Sonic/backdrop/mystic-cave/17.png',
      height: 13
    }, {
      autoscroll: 0,
      parallax: 0.12,
      url: '/Sonic/backdrop/mystic-cave/18.png',
      height: 48
    }, {
      autoscroll: 0,
      parallax: 0.13,
      url: '/Sonic/backdrop/mystic-cave/19.png',
      height: 1
    }, {
      autoscroll: 0,
      parallax: 0.14,
      url: '/Sonic/backdrop/mystic-cave/20.png',
      height: 1
    }, {
      autoscroll: 0,
      parallax: 0.16,
      url: '/Sonic/backdrop/mystic-cave/21.png',
      height: 1
    }, {
      autoscroll: 0,
      parallax: 0.18,
      url: '/Sonic/backdrop/mystic-cave/22.png',
      height: 1
    }, {
      autoscroll: 0,
      parallax: 0.20,
      url: '/Sonic/backdrop/mystic-cave/23.png',
      height: 1
    }, {
      autoscroll: 0,
      parallax: 0.22,
      url: '/Sonic/backdrop/mystic-cave/24.png',
      height: 6
    }, {
      autoscroll: 0,
      parallax: 0.24,
      url: '/Sonic/backdrop/mystic-cave/25.png',
      height: 7
    }, {
      autoscroll: 0,
      parallax: 0.28,
      url: '/Sonic/backdrop/mystic-cave/26.png',
      height: 32
    }, {
      autoscroll: 0,
      parallax: 0.33,
      url: '/Sonic/backdrop/mystic-cave/27.png',
      height: 18
    }, {
      autoscroll: 0,
      parallax: 0.35,
      url: '/Sonic/backdrop/mystic-cave/28.png',
      height: 23
    }, {
      autoscroll: 0,
      parallax: 0.37,
      url: '/Sonic/backdrop/mystic-cave/29.png',
      height: 37
    }];
  }
}
exports.MysticCave = MysticCave;
});

;require.register("backdrop/Overcast.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Overcast = void 0;
var _Backdrop = require("./Backdrop");
class Overcast extends _Backdrop.Backdrop {
  constructor(args, parent) {
    super(args, parent);
    this.args.name = 'overcast';
    this.args.strips = [{
      autoscroll: 0.14,
      parallax: 0.16,
      url: '/Sonic/backdrop/stardust-speedway/sky-0.png',
      height: 32
    }, {
      autoscroll: 0.13,
      parallax: 0.15,
      url: '/Sonic/backdrop/stardust-speedway/sky-1.png',
      height: 32
    }, {
      autoscroll: 0.12,
      parallax: 0.14,
      url: '/Sonic/backdrop/stardust-speedway/sky-2.png',
      height: 16
    }, {
      autoscroll: 0.11,
      parallax: 0.13,
      url: '/Sonic/backdrop/stardust-speedway/sky-3.png',
      height: 16
    }, {
      autoscroll: 0.10,
      parallax: 0.12,
      url: '/Sonic/backdrop/stardust-speedway/sky-4.png',
      height: 16
    }, {
      autoscroll: 0.09,
      parallax: 0.11,
      url: '/Sonic/backdrop/stardust-speedway/sky-5.png',
      height: 32
    }, {
      autoscroll: 0.08,
      parallax: 0.10,
      url: '/Sonic/backdrop/stardust-speedway/sky-6.png',
      height: 32
    }, {
      autoscroll: 0.07,
      parallax: 0.09,
      url: '/Sonic/backdrop/stardust-speedway/sky-7.png',
      height: 16
    }, {
      autoscroll: 0.06,
      parallax: 0.08,
      url: '/Sonic/backdrop/stardust-speedway/sky-8.png',
      height: 32
    }, {
      autoscroll: 0.05,
      parallax: 0.07,
      url: '/Sonic/backdrop/stardust-speedway/sky-9.png',
      height: 16
    }, {
      autoscroll: 0.04,
      parallax: 0.06,
      url: '/Sonic/backdrop/stardust-speedway/sky-10.png',
      height: 16
    }, {
      autoscroll: 0.03,
      parallax: 0.05,
      url: '/Sonic/backdrop/stardust-speedway/sky-11.png',
      height: 16
    }, {
      autoscroll: 0.02,
      parallax: 0.04,
      url: '/Sonic/backdrop/stardust-speedway/sky-12.png',
      height: 16
    }, {
      autoscroll: 0.01,
      parallax: 0.03,
      url: '/Sonic/backdrop/stardust-speedway/sky-13.png',
      height: 8
    }, {
      autoscroll: 0.005,
      parallax: 0.02,
      url: '/Sonic/backdrop/stardust-speedway/sky-14.png',
      height: 51
    }, {
      autoscroll: 0.005,
      parallax: 0.01,
      url: '/Sonic/backdrop/west-side/empty.png',
      height: 51
    }];

    // this.args.bindTo('frame', v => {

    // 	if(this.args.ligtening)
    // 	{
    // 		return;
    // 	}

    // 	if(Math.random() > 0.995)
    // 	{
    // 		this.args.name = 'dark-clouds lightning';
    // 		this.args.lightning = true;

    // 		this.onTimeout(1000, () => {
    // 			this.args.name = 'dark-clouds';
    // 			this.args.lightning = false;
    // 		});
    // 	}

    // });
  }
}
exports.Overcast = Overcast;
});

;require.register("backdrop/PhazonMines.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PhazonMines = void 0;
var _Backdrop = require("./Backdrop");
class PhazonMines extends _Backdrop.Backdrop {
  constructor(args, parent) {
    super(args, parent);
    this.args.name = 'scrap-brain';
    this.args.strips = [{
      autoscroll: 0.0,
      parallax: 0.1,
      url: '/Sonic/backdrop/tidal-tempest/phazon-mines.png',
      height: 512
    }];
  }
}
exports.PhazonMines = PhazonMines;
});

;require.register("backdrop/ProtoLabrynth.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ProtoLabrynth = void 0;
var _Backdrop = require("./Backdrop");
class ProtoLabrynth extends _Backdrop.Backdrop {
  constructor(args, parent) {
    super(args, parent);
    this.args.name = 'proto-labrynth';
    this.args.strips = [{
      autoscroll: 0,
      parallax: 0.15,
      url: '/Sonic/backdrop/protolabrynth/0.png',
      height: 48
    }, {
      autoscroll: 0,
      parallax: 0.125,
      url: '/Sonic/backdrop/protolabrynth/1.png',
      height: 24
    }, {
      autoscroll: 0,
      parallax: 0.1,
      url: '/Sonic/backdrop/protolabrynth/2.png',
      height: 8
    }, {
      autoscroll: 0,
      parallax: 0.075,
      url: '/Sonic/backdrop/protolabrynth/3.png',
      height: 68
    }, {
      autoscroll: 0,
      parallax: 0.1,
      url: '/Sonic/backdrop/protolabrynth/4.png',
      height: 18
    }, {
      autoscroll: 0,
      parallax: 0.125,
      url: '/Sonic/backdrop/protolabrynth/5.png',
      height: 27
    }, {
      autoscroll: 0,
      parallax: 0.15,
      url: '/Sonic/backdrop/protolabrynth/5.png',
      height: 27
    }, {
      autoscroll: 0,
      parallax: 0.175,
      url: '/Sonic/backdrop/protolabrynth/6.png',
      height: 76
    }];
  }
}
exports.ProtoLabrynth = ProtoLabrynth;
});

;require.register("backdrop/ScrapBrainDark.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ScrapBrainDark = void 0;
var _Backdrop = require("./Backdrop");
class ScrapBrainDark extends _Backdrop.Backdrop {
  constructor(args, parent) {
    super(args, parent);
    this.args.name = 'scrap-brain';
    this.args.strips = [{
      autoscroll: 0.0,
      parallax: 0.1,
      url: '/Sonic/backdrop/scrap-brain/indoors-dark.png',
      height: 1024
    }];
  }
}
exports.ScrapBrainDark = ScrapBrainDark;
});

;require.register("backdrop/SouthRidge.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SouthRidge = void 0;
var _Backdrop = require("./Backdrop");
class SouthRidge extends _Backdrop.Backdrop {
  constructor(args, parent) {
    super(args, parent);
    this.args.name = 'south-ridge';
    this.args.strips = [{
      autoscroll: 0,
      parallax: 0,
      url: '/Sonic/backdrop/south-ridge/sky-0.png',
      height: 192
    }, {
      autoscroll: -0.05,
      parallax: 0.11,
      url: '/Sonic/backdrop/south-ridge/clouds-10.png',
      height: 0
    }, {
      autoscroll: 0,
      parallax: 0.115,
      url: '/Sonic/backdrop/south-ridge/ridge.png',
      height: 0
    }, {
      autoscroll: -0.06,
      parallax: 0.12,
      url: '/Sonic/backdrop/south-ridge/clouds-9.png',
      height: 8
    }, {
      autoscroll: -0.07,
      parallax: 0.125,
      url: '/Sonic/backdrop/south-ridge/clouds-9b.png',
      height: 8
    }, {
      autoscroll: -0.08,
      parallax: 0.13,
      url: '/Sonic/backdrop/south-ridge/clouds-9.png',
      height: 8
    }, {
      autoscroll: -0.09,
      parallax: 0.135,
      url: '/Sonic/backdrop/south-ridge/clouds-9b.png',
      height: 8
    }, {
      autoscroll: -0.10,
      parallax: 0.13,
      url: '/Sonic/backdrop/south-ridge/clouds-8.png',
      height: 11
    }, {
      autoscroll: 0,
      parallax: 0.12,
      url: '/Sonic/backdrop/south-ridge/ridge-b.png',
      height: 10
    }, {
      autoscroll: -0.14,
      parallax: 0.14,
      url: '/Sonic/backdrop/south-ridge/clouds-7.png',
      height: -1
    }, {
      autoscroll: -0.075,
      parallax: 0.15,
      url: '/Sonic/backdrop/south-ridge/clouds-6.png',
      height: 9
    }, {
      autoscroll: -0.08,
      parallax: 0.16,
      url: '/Sonic/backdrop/south-ridge/clouds-5.png',
      height: 8
    }, {
      autoscroll: -0.09,
      parallax: 0.18,
      url: '/Sonic/backdrop/south-ridge/clouds-4.png',
      height: 16
    }, {
      autoscroll: -0.1,
      parallax: 0.20,
      url: '/Sonic/backdrop/south-ridge/clouds-3.png',
      height: 13
    }, {
      autoscroll: -0.1125,
      parallax: 0.22,
      url: '/Sonic/backdrop/south-ridge/clouds-2.png',
      height: 17
    }, {
      autoscroll: -0.15,
      parallax: 0.21,
      url: '/Sonic/backdrop/south-ridge/clouds-1.png',
      height: 15
    }, {
      autoscroll: -0.175,
      parallax: 0.21,
      url: '/Sonic/backdrop/south-ridge/clouds-0.png',
      height: 16
    }, {
      autoscroll: -0.15,
      parallax: 0.22,
      url: '/Sonic/backdrop/south-ridge/clouds-1.png',
      height: 15
    }, {
      autoscroll: -0.175,
      parallax: 0.23,
      url: '/Sonic/backdrop/south-ridge/clouds-0.png',
      height: 16
    }, {
      autoscroll: -0.2,
      parallax: 0.24,
      url: '/Sonic/backdrop/south-ridge/clouds-1.png',
      height: 15
    }, {
      autoscroll: -0.225,
      parallax: 0.25,
      url: '/Sonic/backdrop/south-ridge/clouds-0.png',
      height: 16
    }, {
      autoscroll: -0.25,
      parallax: 0.26,
      url: '/Sonic/backdrop/south-ridge/clouds-1.png',
      height: 15
    }, {
      autoscroll: -0.23,
      parallax: 0.27,
      url: '/Sonic/backdrop/south-ridge/clouds-0.png',
      height: 16
    }, {
      autoscroll: -0.26,
      parallax: 0.28,
      url: '/Sonic/backdrop/south-ridge/clouds-1.png',
      height: 15
    }, {
      autoscroll: -0.24,
      parallax: 0.29,
      url: '/Sonic/backdrop/south-ridge/clouds-0.png',
      height: 16
    }, {
      autoscroll: -0.27,
      parallax: 0.29,
      url: '/Sonic/backdrop/south-ridge/clouds-1.png',
      height: 15
    }, {
      autoscroll: -0.25,
      parallax: 0.31,
      url: '/Sonic/backdrop/south-ridge/clouds-0.png',
      height: 16
    }, {
      autoscroll: -0.28,
      parallax: 0.30,
      url: '/Sonic/backdrop/south-ridge/clouds-1.png',
      height: 15
    }, {
      autoscroll: -0.26,
      parallax: 0.32,
      url: '/Sonic/backdrop/south-ridge/clouds-0.png',
      height: 16
    }];
  }
}
exports.SouthRidge = SouthRidge;
});

;require.register("backdrop/Underground.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Underground = void 0;
var _Backdrop = require("./Backdrop");
class Underground extends _Backdrop.Backdrop {
  constructor(args, parent) {
    super(args, parent);
    this.args.name = 'underground';
    this.args.strips = [{
      autoscroll: 0.045,
      parallax: 0.075,
      url: '/Sonic/backdrop/wing-fortress/sky-1b-recolor.png',
      height: 32
    }, {
      autoscroll: 0.043,
      parallax: 0.070,
      url: '/Sonic/backdrop/wing-fortress/sky-0-recolor.png',
      height: 48
    }, {
      autoscroll: 0.041,
      parallax: 0.065,
      url: '/Sonic/backdrop/wing-fortress/sky-1-recolor.png',
      height: 32
    }, {
      autoscroll: 0.039,
      parallax: 0.060,
      url: '/Sonic/backdrop/wing-fortress/sky-2-recolor.png',
      height: 48
    }, {
      autoscroll: 0,
      parallax: 0.075,
      url: '/Sonic/backdrop/aquatic-ruin/mountains-0-recolor.png',
      height: 0
    }, {
      autoscroll: 0,
      parallax: 0,
      url: '/Sonic/backdrop/aquatic-ruin/mountains-1-recolor.png',
      height: 48
    }, {
      autoscroll: 0,
      parallax: 0,
      url: '/Sonic/backdrop/aquatic-ruin/mountains-1-recolor.png',
      height: 48
    }, {
      autoscroll: 0,
      parallax: 0,
      url: '/Sonic/backdrop/aquatic-ruin/mountains-1-recolor.png',
      height: 24
    }];
  }
}
exports.Underground = Underground;
});

;require.register("backdrop/WestSide.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WestSide = void 0;
var _Backdrop = require("./Backdrop");
class WestSide extends _Backdrop.Backdrop {
  constructor(args, parent) {
    super(args, parent);
    this.args.name = 'west-side';
    this.args.strips = [{
      autoscroll: 0.001,
      parallax: 0.001,
      url: '/Sonic/backdrop/west-side/stars-before.png',
      height: 64
    }, {
      autoscroll: 0.001,
      parallax: 0.001,
      url: '/Sonic/backdrop/west-side/stars.png',
      height: 205
    }, {
      autoscroll: 0,
      parallax: 0.0005,
      url: '/Sonic/backdrop/west-side/island-dark.png',
      height: 0
    }, {
      autoscroll: 0,
      parallax: 0.0005,
      url: '/Sonic/backdrop/west-side/water-shine-0.png',
      height: 3
    }, {
      autoscroll: 0,
      parallax: 0.0005,
      url: '/Sonic/backdrop/west-side/water-shine-1.png',
      height: 3
    }
    // , {
    // 	autoscroll: 0
    // 	, parallax: 0.0004
    // 	, url:      '/Sonic/backdrop/west-side/water-shine-2.png'
    // 	, height:   3
    // }
    , {
      autoscroll: 0,
      parallax: 0.004,
      url: '/Sonic/backdrop/west-side/water-night.png',
      height: 144
    }, {
      autoscroll: 0.001,
      parallax: 0.001,
      url: '/Sonic/backdrop/west-side/stars-reflected.png',
      height: 0
    }, {
      autoscroll: 0,
      parallax: 0.0005,
      url: '/Sonic/backdrop/west-side/island-dark-reflected.png',
      height: 0
    }, {
      autoscroll: 0,
      parallax: 0.03,
      url: '/Sonic/backdrop/launch-base/bushes-0-night.png',
      height: 0
    }, {
      autoscroll: 0,
      parallax: 0.05,
      url: '/Sonic/backdrop/launch-base/bushes-1-night.png',
      height: 0
    }, {
      autoscroll: 0,
      parallax: 0.05,
      url: '/Sonic/backdrop/launch-base/bushes-2-night.png',
      height: 48
    }, {
      autoscroll: 0,
      parallax: 0.05,
      url: '/Sonic/backdrop/launch-base/bushes-3-night.png',
      height: 128
    }];
  }
}
exports.WestSide = WestSide;
});

;require.register("backdrop/WestSideCloudy.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WestSideCloudy = void 0;
var _Backdrop = require("./Backdrop");
class WestSideCloudy extends _Backdrop.Backdrop {
  constructor(args, parent) {
    super(args, parent);
    this.args.name = 'west-side-cloudy';
    const cloudSpeed = 8;
    this.args.strips = [{
      autoscroll: 0.14 * cloudSpeed,
      parallax: 0.02,
      url: '/Sonic/backdrop/west-side/clouds--1.png',
      height: 64
    }, {
      autoscroll: 0.14 * cloudSpeed,
      parallax: 0.02,
      url: '/Sonic/backdrop/west-side/clouds-0.png',
      height: 33
    }, {
      autoscroll: 0.13 * cloudSpeed,
      parallax: 0.014,
      url: '/Sonic/backdrop/west-side/clouds-1.png',
      height: 32
    }, {
      autoscroll: 0.12 * cloudSpeed,
      parallax: 0.013,
      url: '/Sonic/backdrop/west-side/clouds-2.png',
      height: 24
    }, {
      autoscroll: 0.11 * cloudSpeed,
      parallax: 0.012,
      url: '/Sonic/backdrop/west-side/clouds-3.png',
      height: 16
    }, {
      autoscroll: 0.10 * cloudSpeed,
      parallax: 0.011,
      url: '/Sonic/backdrop/west-side/clouds-4.png',
      height: 5
    }, {
      autoscroll: 0.09 * cloudSpeed,
      parallax: 0.010,
      url: '/Sonic/backdrop/west-side/clouds-5.png',
      height: 3
    }, {
      autoscroll: 0.08 * cloudSpeed,
      parallax: 0.009,
      url: '/Sonic/backdrop/west-side/clouds-6.png',
      height: 8
    }, {
      autoscroll: 0.07 * cloudSpeed,
      parallax: 0.008,
      url: '/Sonic/backdrop/west-side/clouds-7.png',
      height: 5
    }, {
      autoscroll: 0.06 * cloudSpeed,
      parallax: 0.007,
      url: '/Sonic/backdrop/west-side/clouds-8.png',
      height: 3
    }, {
      autoscroll: 0.05 * cloudSpeed,
      parallax: 0.006,
      url: '/Sonic/backdrop/west-side/clouds-9.png',
      height: 8
    }, {
      autoscroll: 0.04 * cloudSpeed,
      parallax: 0.005,
      url: '/Sonic/backdrop/west-side/clouds-10.png',
      height: 8
    }, {
      autoscroll: 0.03 * cloudSpeed,
      parallax: 0.004,
      url: '/Sonic/backdrop/west-side/clouds-11.png',
      height: 32
    }, {
      autoscroll: 0.02 * cloudSpeed,
      parallax: 0.003,
      url: '/Sonic/backdrop/west-side/clouds-12.png',
      height: 8
    }, {
      autoscroll: 0.015 * cloudSpeed,
      parallax: 0.002,
      url: '/Sonic/backdrop/west-side/clouds-13.png',
      height: 32
    }, {
      autoscroll: 0,
      parallax: 0.0005,
      url: '/Sonic/backdrop/west-side/water-shine-cloudy.png',
      height: 2
    }, {
      autoscroll: 0,
      parallax: 0.0005,
      url: '/Sonic/backdrop/west-side/island-dark-cloudy.png',
      height: 0
    }, {
      autoscroll: 0.015 * cloudSpeed,
      parallax: 0.002,
      url: '/Sonic/backdrop/west-side/reflected-clouds-0.png',
      height: 32
    }, {
      autoscroll: 0.02 * cloudSpeed,
      parallax: 0.003,
      url: '/Sonic/backdrop/west-side/reflected-clouds-1.png',
      height: 8
    }, {
      autoscroll: 0.03 * cloudSpeed,
      parallax: 0.004,
      url: '/Sonic/backdrop/west-side/reflected-clouds-2.png',
      height: 32
    }, {
      autoscroll: 0.04 * cloudSpeed,
      parallax: 0.005,
      url: '/Sonic/backdrop/west-side/reflected-clouds-3.png',
      height: 8
    }, {
      autoscroll: 0.05 * cloudSpeed,
      parallax: 0.006,
      url: '/Sonic/backdrop/west-side/reflected-clouds-4.png',
      height: 8
    }, {
      autoscroll: 0.06 * cloudSpeed,
      parallax: 0.007,
      url: '/Sonic/backdrop/west-side/reflected-clouds-5.png',
      height: 3
    }, {
      autoscroll: 0.07 * cloudSpeed,
      parallax: 0.008,
      url: '/Sonic/backdrop/west-side/reflected-clouds-6.png',
      height: 5
    }, {
      autoscroll: 0.08 * cloudSpeed,
      parallax: 0.009,
      url: '/Sonic/backdrop/west-side/reflected-clouds-7.png',
      height: 16
    }, {
      autoscroll: 0.09 * cloudSpeed,
      parallax: 0.010,
      url: '/Sonic/backdrop/west-side/reflected-clouds-8.png',
      height: 24
    }, {
      autoscroll: 0.1 * cloudSpeed,
      parallax: 0.011,
      url: '/Sonic/backdrop/west-side/reflected-clouds-9.png',
      height: 20
    }, {
      autoscroll: 0,
      parallax: 0.0005,
      url: '/Sonic/backdrop/west-side/island-dark-cloudy-reflected.png',
      height: 0
    }, {
      autoscroll: 0,
      parallax: 0.004,
      url: '/Sonic/backdrop/west-side/water-cloudy.png',
      height: 46
    }, {
      autoscroll: 0,
      parallax: 0.000,
      url: '/Sonic/backdrop/west-side/water-cloudy-after.png',
      height: 128
    }];
    this.args.bindTo('frame', v => {
      if (this.args.ligtening) {
        return;
      }
      if (Math.random() > 0.995) {
        this.args.name = 'west-side-cloudy lightning';
        this.args.lightning = true;
        this.onTimeout(1000, () => {
          this.args.name = 'west-side-cloudy';
          this.args.lightning = false;
        });
      }
    });
  }
}
exports.WestSideCloudy = WestSideCloudy;
});

;require.register("backdrop/WestSideDay.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WestSideDay = void 0;
var _Backdrop = require("./Backdrop");
// d6ffe0
// fffee0

const recolor = [, {
  'e0e0e5': 'afafc1'
}, {
  'e0e0e5': 'afafc1'
}, {
  'e0e0e5': 'afafc1'
}, {
  'e0e0e5': 'afafc1'
}, {
  'e0e0e5': 'afafc1'
}, {
  'e0e0e5': 'e0e0e5'
}, {
  'e0e0e5': 'afafc1'
}, {
  'e0e0e5': 'e0e0e5'
}, {
  'e0e0e5': 'e0e0e5'
}];
class WestSideDay extends _Backdrop.Backdrop {
  constructor(args, parent) {
    super(args, parent);
    this.args.name = 'west-side-day';
    this.args.strips = [{
      autoscroll: 0.001,
      parallax: 0.001,
      url: '/Sonic/backdrop/west-side/empty.png',
      height: 64
    }, {
      autoscroll: 0.001,
      parallax: 0.001,
      url: '/Sonic/backdrop/west-side/empty.png',
      height: 205
    }, {
      autoscroll: 0,
      parallax: 0.0005,
      url: '/Sonic/backdrop/west-side/island-day.png',
      height: 0
    }, {
      autoscroll: 0,
      parallax: 0.0005,
      url: '/Sonic/backdrop/west-side/water-shine-0.png',
      height: 3
    }, {
      autoscroll: 0,
      parallax: 0.0005,
      url: '/Sonic/backdrop/west-side/water-shine-1.png',
      height: 3
    }
    // , {
    // 	autoscroll: 0
    // 	, parallax: 0.0004
    // 	, url:      '/Sonic/backdrop/west-side/water-shine-2.png'
    // 	, height:   3
    // }
    , {
      autoscroll: 0,
      parallax: 0.004,
      url: '/Sonic/backdrop/west-side/water.png',
      height: 144
    }, {
      autoscroll: 0,
      parallax: 0,
      url: '/Sonic/backdrop/west-side/empty.png',
      height: 0
    }, {
      autoscroll: 0,
      parallax: 0.0005,
      url: '/Sonic/backdrop/west-side/island-day-reflected.png',
      height: 0
    }, {
      autoscroll: 0,
      parallax: 0.0005,
      url: '/Sonic/backdrop/west-side/island-shine.png',
      height: 1,
      interval: 26,
      timeout: 100,
      frame: 0,
      recolor
    }, {
      autoscroll: 0,
      parallax: 0.03,
      url: '/Sonic/backdrop/launch-base/bushes-0.png',
      height: 0
    }, {
      autoscroll: 0,
      parallax: 0.05,
      url: '/Sonic/backdrop/launch-base/bushes-1.png',
      height: 0
    }, {
      autoscroll: 0,
      parallax: 0.05,
      url: '/Sonic/backdrop/launch-base/bushes-2.png',
      height: 48
    }, {
      autoscroll: 0,
      parallax: 0.05,
      url: '/Sonic/backdrop/launch-base/bushes-3.png',
      height: 128
    }];
  }
}
exports.WestSideDay = WestSideDay;
});

;require.register("backdrop/WestSideNight.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WestSideNight = void 0;
var _Backdrop = require("./Backdrop");
class WestSideNight extends _Backdrop.Backdrop {
  constructor(args, parent) {
    super(args, parent);
    this.args.name = 'west-side';
    this.args.strips = [{
      autoscroll: 0,
      parallax: 0.001,
      url: '/Sonic/backdrop/west-side/stars.png',
      height: 0
    }, {
      autoscroll: 0,
      parallax: 0.0005,
      url: '/Sonic/backdrop/west-side/island-dark.png',
      height: 0
    }, {
      autoscroll: 0,
      parallax: 0.0005,
      url: '/Sonic/backdrop/west-side/water-shine-0.png',
      height: 3
    }, {
      autoscroll: 0,
      parallax: 0.0005,
      url: '/Sonic/backdrop/west-side/water-shine-1.png',
      height: 3
    }, {
      autoscroll: 0,
      parallax: 0.0004,
      url: '/Sonic/backdrop/west-side/water-shine-2.png',
      height: 3
    }, {
      autoscroll: 0,
      parallax: 0.004,
      url: '/Sonic/backdrop/west-side/water.png',
      height: 142
    }, {
      autoscroll: 0,
      parallax: 0.001,
      url: '/Sonic/backdrop/west-side/stars-reflected.png',
      height: 0
    }, {
      autoscroll: 0,
      parallax: 0.0005,
      url: '/Sonic/backdrop/west-side/island-dark-reflected.png',
      height: 0
    }];
  }
}
exports.WestSideNight = WestSideNight;
});

;require.register("backdrop/Wood.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Wood = void 0;
var _Backdrop = require("./Backdrop");
class Wood extends _Backdrop.Backdrop {
  constructor(args, parent) {
    super(args, parent);
    this.args.name = 'wood';
    this.args.strips = [{
      autoscroll: 0.0,
      parallax: 0.1,
      url: '/Sonic/backdrop/wood/forest.png',
      height: 1600
    }];
  }
}
exports.Wood = Wood;
});

;require.register("behavior/Behavior.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Behavior = void 0;
class Behavior {
  update(host) {}
}
exports.Behavior = Behavior;
});

;require.register("behavior/Crouch.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Crouch = void 0;
var _Tag = require("curvature/base/Tag");
var _Behavior = require("./Behavior");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class Crouch extends _Behavior.Behavior {
  constructor() {
    super(...arguments);
    _defineProperty(this, "spindashCharge", 0);
  }
  command_0(host, button) {
    if (host.yAxis > 0.55 && !host.args.falling && !host.args.gSpeed) {
      // return false;
    }
  }
  update(host) {
    if (host.args.grinding) {
      if (host.yAxis > 0.55) {
        host.args.animation = 'grinding-crouching';
        host.args.crouching = true;
      } else {
        host.args.crouching = false;
      }
      return;
    }
    if (host.yAxis > 0.55 && !host.args.gSpeed && !host.args.falling && !host.spindashCharge) {
      host.args.lookTime--;
      if (host.args.lookTime < -45) {
        host.args.cameraBias = -0.5;
      }
      host.args.animation = 'crouching';
      host.args.crouching = true;
    } else {
      host.args.crouching = false;
    }
  }
}
exports.Crouch = Crouch;
});

;require.register("behavior/EmeraldHalo.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EmeraldHalo = void 0;
var _Tag = require("curvature/base/Tag");
var _Behavior = require("./Behavior");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class EmeraldHalo extends _Behavior.Behavior {
  constructor() {
    super(...arguments);
    _defineProperty(this, "emeraldColors", ['red-alt', 'yellow', 'green', 'cyan', 'white', 'purple', 'pink']);
    _defineProperty(this, "emeraldParticles", new Set());
  }
  command_3(host, button) {
    if (!host.isSuper && host.args.rings < host.args.minRingsSuper) {
      return;
    }
    if (host.isSuper && !host.isHyper && host.args.rings < host.args.minRingsHyper) {
      return;
    }
    if (host.isHyper || !host.args.falling || !host.args.jumping) {
      return;
    }
    while (this.emeraldParticles.size < 7) {
      const color = this.emeraldColors[this.emeraldParticles.size];
      const emerald = host.isSuper ? new _Tag.Tag(`<img src = "/Sonic/emerald-super-${color}-mini.png">`) : new _Tag.Tag(`<img src = "/Sonic/emerald-${color}-mini.png">`);
      emerald.index = this.emeraldParticles.size;
      emerald.style({
        '--x': host.args.x,
        '--y': host.args.y,
        '--z': host.args.z + 1,
        width: host.isSuper ? '14px' : '8px',
        height: host.isSuper ? '10px' : '8px'
      });
      host.viewport.particles.add(emerald);
      this.emeraldParticles.add(emerald);
      host.viewport.onFrameOut(60, () => {
        host.viewport.particles.remove(emerald);
        this.emeraldParticles.delete(emerald);
      });
    }
  }
  updateEnd(host) {
    for (const emerald of this.emeraldParticles) {
      const t = host.transformTime;
      const offset = 2 * Math.PI * emerald.index / this.emeraldParticles.size;
      const radius = t < 30 ? Math.min(t * 2, 32) || 3 : 45 + -t + 15;
      const x = Math.cos(offset + t * 0.15) * radius;
      const w = -Math.sin(offset + t * 0.15) * radius;
      const y = Math.cos(t * 0.075) * w;
      emerald.style({
        '--x': host.args.x + 0 + x,
        '--y': host.args.y + -(host.args.height * 0.65) + y,
        'z-index': host.args.z + -Math.sign(w)
      });
    }
  }
}
exports.EmeraldHalo = EmeraldHalo;
});

;require.register("behavior/Liftable.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Liftable = void 0;
var _Behavior = require("./Behavior");
const rendered = Symbol('rendered');
class Liftable extends _Behavior.Behavior {
  rendered(host) {
    if (host[rendered]) {
      return;
    }
    host[rendered] = true;
    host.bindTo('carriedBy', carrier => {
      if (host.cX) {
        host.cX();
        host.cX = null;
      }
      if (host.cY) {
        host.cY();
        host.cY = null;
      }
      if (host.carriedBy) {
        const carrier = host.carriedBy;
        host.carriedBy = null;
        host.args.xSpeed = carrier.args.xSpeed;
        host.args.ySpeed = carrier.args.falling ? carrier.args.ySpeed : 0;
        host.args.xSpeed += Math.sign(carrier.args.gSpeed || carrier.args.xSpeed) * 4;
        host.args.ySpeed -= 4;
        carrier.carrying.delete(host);
        host.args.falling = true;
        host.args.float = 0;
      }
      if (carrier) {
        host.cX = carrier.args.bindTo('x', v => host.args.x = v + carrier.args.direction * carrier.xHold);
        host.cY = carrier.args.bindTo('y', v => host.args.y = v + -carrier.yHold);
        host.args.xSpeed = 0;
        host.args.ySpeed = 0;
        carrier.carrying.add(host);
        host.args.standingOn = null;
        host.args.float = -1;
      }
    });
  }
  update(host) {
    if (host.carriedBy) {
      host.args.float = -1;
    }
  }
}
exports.Liftable = Liftable;
});

;require.register("behavior/LookUp.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LookUp = void 0;
var _Tag = require("curvature/base/Tag");
var _Behavior = require("./Behavior");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class LookUp extends _Behavior.Behavior {
  constructor() {
    super(...arguments);
    _defineProperty(this, "lookTime", 0);
  }
  update(host) {
    if (host.args.mode !== 0) {
      return;
    }
    if (host.yAxis < -0.55 && !host.args.gSpeed && !host.args.falling && !host.spindashCharge) {
      host.args.animation = 'looking-up';
      host.args.lookTime++;
      if (host.args.lookTime > 45) {
        host.args.cameraBias = +0.25;
      }
    } else {
      this.lookTime = 0;
    }
  }
}
exports.LookUp = LookUp;
});

;require.register("behavior/Patrol.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Patrol = void 0;
var _Behavior = require("./Behavior");
class Patrol extends _Behavior.Behavior {
  update(host) {
    var _host$args$direction, _host$args$patrolSpee, _host$args$patrolOffs, _host$args$patrolBeat, _host$args$patrolPaus;
    const direction = (_host$args$direction = host.args.direction) !== null && _host$args$direction !== void 0 ? _host$args$direction : 1;
    const speed = (_host$args$patrolSpee = host.args.patrolSpeed) !== null && _host$args$patrolSpee !== void 0 ? _host$args$patrolSpee : 1;
    const offset = (_host$args$patrolOffs = host.args.patrolOffset) !== null && _host$args$patrolOffs !== void 0 ? _host$args$patrolOffs : 0;
    const beat = (_host$args$patrolBeat = host.args.patrolBeat) !== null && _host$args$patrolBeat !== void 0 ? _host$args$patrolBeat : 90;
    const pause = (_host$args$patrolPaus = host.args.patrolPause) !== null && _host$args$patrolPaus !== void 0 ? _host$args$patrolPaus : 25;
    host.age = host.age || 0;
    const age = host.age + offset;
    if (age % beat < beat - pause) {
      if (Math.floor(age / beat) % 2) {
        host.args.gSpeed = -speed;
      } else {
        host.args.gSpeed = speed;
      }
      host.args.direction = -Math.sign(host.args.gSpeed) || host.args.direction;
    } else {
      host.args.direction = -Math.sign(host.gSpeedLast) || host.args.direction;
    }
  }
}
exports.Patrol = Patrol;
});

;require.register("behavior/Platformer.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Platformer = void 0;
var _Tag = require("curvature/base/Tag");
var _Bindable = require("curvature/base/Bindable");
var _PointActor = require("../actor/PointActor");
var _Layer = require("../viewport/Layer");
var _CharacterString = require("../ui/CharacterString");
var _StarSheild = require("../powerups/StarSheild");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
const MODE_FLOOR = 0;
const MODE_LEFT = 1;
const MODE_CEILING = 2;
const MODE_RIGHT = 3;
class Platformer {
  constructor() {
    _defineProperty(this, "collisionMap", null);
  }
  updateStart(host) {
    host.args.wasHanging = host.args.falling && host.args.hangingFrom;
    this.stepsTaken = 0;
    if (host.knocked) {
      host.args.knocked = Math.sign(host.args.xSpeed || host.args.gSpeed);
    }
    if (!host.args.falling && host.knocked) {
      if (host.args.ySpeedLast < 3 && host.pop) {
        host.pop(host.knocked);
      }
      host.args.ySpeed = -host.ySpeedLast * 0.7;
      host.args.falling = true;
      host.args.y--;
    }
    if (!host.args.falling) {
      host.modeLast = host.args.mode;
      if (host.args.grinding) {
        host.args.wasGrinding = true;
      } else {
        host.args.wasGrinding = false;
      }
    }
    host.args.sliding = false;
    host.lastLayer = null;
    host.args.localCameraMode = null;
    if (host.args.dead) {
      return;
    }
    if (host.args.standingLayer && !host.args.static) {
      const layer = host.args.standingLayer.layer;
      let grindRegion = false;
      for (const region of host.regions) {
        if (region.grind) {
          grindRegion = true;
        }
      }
      if (!host.controllable && !host.canGrind) {
        host.args.grinding = false;
      } else if (layer && layer.meta.grinding) {
        host.args.grinding = true;
        host.args.direction = Math.sign(host.args.xSpeed || host.args.gSpeed);
      } else if (!grindRegion) {
        host.args.grinding = false;
      }
      if (host.args.grinding && host.args.falling) {
        host.args.grinding = false;
      }
    }
    if (!host.args.falling) {
      host.fallTime = 0;
    }
  }
  updateEnd(host) {
    if (!host.args.falling) {
      host.args.jumpArced = false;
    } else if (host.args.jumping && (host.args.ySpeed > -3 || host.args.ySpeed >= 0 && host.ySpeedLast < 0)) {
      host.args.jumpArced = true;
    }
    if (!host.args.static && host.args.falling) {
      if (host.args.standingLayer && host.fallTime === 0) {
        host.args.xSpeed += host.args.standingLayer.offsetXChanged || 0;
        host.args.ySpeed += host.args.standingLayer.offsetYChanged || 0;
      }
      host.args.standingLayer = null;
    }
    if (!host.controllable) {
      return;
    }
    if (host.args.popChain.length && host.args.grinding) {
      if (!host.grindReward) {
        host.grindReward = {
          label: 'Rail Grind',
          points: 100,
          multiplier: 1,
          direction: Math.sign(host.args.gSpeed)
        };
        host.args.popChain.push(host.grindReward);
      }
      host.grindReward.points += Math.round(host.args.gSpeed / 10) * host.grindReward.direction || 1;
    }
    if (host.airReward && host.args.falling) {
      // host.grindReward.points += (Math.round(host.args.gSpeed / 10) * host.grindReward.direction) || 1;
      host.airReward.points += Math.ceil(Math.abs(host.args.ySpeed) + Math.abs(host.args.xSpeed));
    }
    if (!host.args.popChain) {
      host.grindReward = null;
      host.airReward = null;
    }
    if (!host.args.falling && !host.args.grinding && host.groundTime > 2) {
      host.grindReward = null;
      host.airReward = null;
    }
    if (host.follower) {
      const frame = host.viewport.serializePlayer();
      const follower = host.follower;
      host.viewport.onFrameOut(5, () => {
        if (frame.input) {
          follower.controller && follower.controller.replay(frame.input);
          follower.readInput();
        }
        if (frame.args) {
          Object.assign(follower.args, frame.args);
          follower.viewport && follower.viewport.setColCell(host);
        }
      });
      if (host.follower.args.dead) {
        host.follower.args.dead = false;
        host.follower.args.x = host.x;
        host.follower.args.y = host.y;
      }
    }
    if (!host.args.falling && !host.args.rolling && !host.args.hangingFrom && !host.args.grinding && host.groundTime > 1 && !host.args.bouncing && !host.punched && !host.readyTime && host.args.popChain.length) {
      host.totalCombo();
    }
  }
  update(host) {
    if (host.args.mercy) {
      host.args.spindashCharge = 0;
      host.args.dropDashCharge = 0;
    }
    if (typeof host.args.standingOn === 'number') {
      const standId = host.args.standingOn;
      const standOn = host.viewport.actorsById[standId];
      if (standOn) {
        host.args.standingOn = standOn;
        host.args.falling = false;
        host.args.x = standOn.args.x;
        host.args.y = -1 + standOn.args.y - standOn.args.height;
      }
    }
    host.args.jumpBlocked = false;
    if (!host.xAxis || Math.sign(host.args.gSpeed) !== host.args.pushing || Math.sign(host.xAxis) !== host.args.pushing) {
      host.args.pushing = false;
    }
    const startX = host.args.x;
    const startY = host.args.y;
    if (host.noClip && !host.controllable) {
      if (host.args.xSpeed) {
        host.args.x += host.args.xSpeed;
      }
      if (host.args.ySpeed) {
        host.args.y += host.args.ySpeed;
      }
      if (!host.args.float && host.args.falling) {
        host.args.ySpeed += host.args.gravity;
      }
      if (host.impulseMag !== null) {
        this.applyImpulse(host);
      }
      if (host.args.float > 0) {
        host.args.float--;
      }
      let collisions;
      switch (host.args.mode) {
        case MODE_CEILING:
          collisions = viewport.actorsAtPoint(host.args.x, host.args.y + host.args.height, host.args.width, host.args.height);
          break;
        case MODE_LEFT:
          collisions = viewport.actorsAtPoint(host.args.x - host.args.height / 2, host.args.y + host.args.width / 2, host.args.height, host.args.width);
          break;
        case MODE_RIGHT:
          collisions = viewport.actorsAtPoint(host.args.x + host.args.height / 2, host.args.y + host.args.width / 2, host.args.height, host.args.width);
          break;
        default:
        case MODE_FLOOR:
          collisions = viewport.actorsAtPoint(host.args.x, host.args.y, host.args.width, host.args.height);
          break;
      }
      if (collisions) {
        for (const actor of collisions) {
          if (actor.args === host.args) {
            continue;
          }
          actor.callCollideHandler(host);
        }
      }
      return;
    }
    if (!host.args.falling && !host.args.rolling && host.args.modeTime >= 1) {
      host.args.spinning = false;
    }
    if (host.args.rolling || host.args.jumping || host.spindashCharge) {
      host.args.spinning = true;
    }
    if (host.viewport && host.args.respawning && !host.args.npc && !host.viewport.args.isRecording && !host.viewport.args.isReplaying) {
      const stored = host.viewport.getCheckpoint(host.args.canonical);
      let toX, toY;
      if (stored && stored.checkpointId) {
        const viewport = host.viewport;
        const checkpoint = viewport.defsByMap.get(viewport.currentMap)[stored.checkpointId];
        toX = checkpoint.x;
        toY = checkpoint.y;
      } else if (host.def) {
        toX = host.def.get('x');
        toY = host.def.get('y');
      } else if (!host.canRoll && host.viewport.defsByName.get('wide-player-start')) {
        const startDef = host.viewport.defsByName.get('wide-player-start');
        toX = startDef.x;
        toY = startDef.y;
      } else if (host.viewport.defsByName.has('player-start')) {
        const startDef = host.viewport.defsByName.get('player-start');
        toX = startDef.x;
        toY = startDef.y;
      }
      host.args.animation = 'dropping';
      host.args.standingLayer = null;
      host.args.standingOn = null;
      host.lastLayer = null;
      const xDiff = host.args.x - toX;
      const yDiff = host.args.y - toY;
      const xPanSpeed = Math.max(Math.abs(xDiff / 8), 16);
      const yPanSpeed = Math.max(Math.abs(yDiff / 8), 16);
      host.args.x -= Math.sign(xDiff) * xPanSpeed;
      host.args.y -= Math.sign(yDiff) * yPanSpeed;
      const viewport = host.viewport;
      if (Math.abs(xDiff) <= xPanSpeed) {
        host.args.x = toX;
      }
      if (Math.abs(yDiff) <= yPanSpeed) {
        host.args.y = toY;
      }
      if (Math.abs(xDiff) <= xPanSpeed && Math.abs(yDiff) <= yPanSpeed) {
        host.viewport.onFrameOut(60, () => {
          if (host.viewport.args.networked) {
            host.args.dead = false;
            host.noClip = false;
            host.args.respawning = false;
            host.args.display = 'initial';
            host.args.ignore = 4;
            host.args.xSpeed = 0;
            host.args.ySpeed = -3;
          } else {
            viewport.reset();
            viewport.startLevel(false);
          }
          viewport.args.paused = false;
        });
      }
      host.viewport && host.viewport.setColCell(host);
      return;
    }
    if (host.viewport && host.viewport.meta.deathLine && !host.args.dead && host.controllable && host.y > host.viewport.meta.deathLine) {
      host.die();
      return;
    }
    if (host.controllable && !host.args.dead) {
      const radius = 0.5 * host.args.width;
      const direction = Math.sign(host.args.xSpeed);
      const height = Math.max(host.args.height, 0);
      const headPoint = host.rotatePoint(0, height * 0.75);
      // const headPoint = host.rotatePoint(radius * -direction, host.args.height * 0.75);

      let jumpBlock = host.getMapSolidAt(host.args.x + headPoint[0], host.args.y + headPoint[1]);
      if (Array.isArray(jumpBlock)) {
        jumpBlock = !!jumpBlock.filter(a => !a.args.platform && !a.isVehicle).length;
      }
      if (host.args.rolling) {
        const rollTopPoint = host.rotatePoint(0, height);
        // const headPoint = host.rotatePoint(radius * -direction, host.args.height * 0.75);

        let rollJumpBlock = host.getMapSolidAt(host.args.x + rollTopPoint[0], host.args.y + rollTopPoint[1]);
        if (Array.isArray(rollJumpBlock)) {
          rollJumpBlock = !!rollJumpBlock.filter(a => !a.args.platform && !a.isVehicle).length;
          host.args.jumpBlocked = !!rollJumpBlock;
        }
        host.args.jumpBlocked = !!rollJumpBlock;
      }
      if (!host.args.hangingFrom && !host.noClip && !host.args.falling && this.checkBelow(host, host.args.x, host.args.y) && jumpBlock) {
        host.die();
        return;
      }
      if (!host.args.falling && host.args.mode === 0) {
        const upFirstSpace = host.castRay(host.maxStep, host.upAngle, this.findUpSpace);
        if (upFirstSpace) {
          host.args.y -= upFirstSpace;
        }
      }
    }
    host.args.skimming = false;
    if (host.args.falling) {
      host.args.airAngle = host.airAngle;
      if (host.args.displayAngle !== host.args.groundAngle) {
        const angleDiff = host.args.groundAngle + -host.args.displayAngle;
        host.args.displayAngle += Math.sign(angleDiff) * (Math.abs(angleDiff) > 1 ? 1 : Math.abs(angleDiff)) * 0.5;
      }
    } else {
      host.args.airAngle = 0;
      host.args.displayAngle = host.args.groundAngle;
    }
    if (host.args.halted < 1 && host.args.halted > 0) {
      host.args.halted = 0;
    }
    if (host.args.halted > 0) {
      host.args.halted--;
      return;
    }
    if (host.args.currentSheild && 'update' in host.args.currentSheild) {
      host.args.currentSheild.update(host);
    }
    if (host.args.rolling) {
      host.args.height = host.args.rollingHeight || host.args.height;
    } else if (host.args.jumping) {
      host.args.height = host.args.rollingHeight || host.args.height;
    } else if (host.canRoll) {
      host.args.height = host.args.normalHeight || host.args.height;
    }
    if (host.args.dontJump > 0) {
      host.args.dontJump--;
    }
    if (host.args.dontJump < 0) {
      host.args.dontJump = 0;
    }
    if (!host.viewport || host.removed) {
      return;
    }
    host.args.modeTime++;
    if (!host.args.falling) {
      if (Math.abs(host.args.gSpeed) < 1 && !host.impulseMag && host.args.modeTime > 3) {
        host.args.rolling = false;
      }
      if (Math.abs(host.args.gSpeed) < 0.01) {
        host.args.gSpeed = 0;
      } else if (host.canRoll && host.yAxis > 0.55 && !host.args.ignore && !host.carrying.size) {
        host.args.rolling = true;
      }
      if (host.controllable && !host.args.gSpeed && host.args.mode === 0 && !host.args.groundAngle) {
        const dSolid = host.getMapSolidAt(host.args.x + 0 * host.args.direction, host.args.y + 4);
        const dSolidF = host.getMapSolidAt(host.args.x + 4 * host.args.direction, host.args.y + 4);
        const uSolidF = host.getMapSolidAt(host.args.x + 4 * host.args.direction, host.args.y - 4);
        const dSolidF2 = host.getMapSolidAt(host.args.x + 2 * host.args.direction, host.args.y + 4);
        const dSolidB = host.getMapSolidAt(host.args.x - 4 * host.args.direction, host.args.y + 4);
        const uSolidB = host.getMapSolidAt(host.args.x - 4 * host.args.direction, host.args.y - 4);
        if (dSolid && !dSolidF && !uSolidF) {
          host.args.teeter = 1;
          if (!dSolidF2) {
            host.args.teeter = 2;
          }
        } else if (dSolid && !dSolidB && !uSolidB) {
          host.args.teeter = -1;
        } else {
          host.args.teeter = 0;
        }
      } else {
        host.args.teeter = 0;
      }
    }
    host.args.driving = false;
    if (host.args.standingOn && host.args.standingOn.isVehicle && !host.isVehicle) {
      const vehicle = host.args.standingOn;
      host.args.groundTimeTotal++;
      host.args.falling = true;
      host.args.flying = false;
      host.args.jumping = false;
      host.args.driving = true;
      host.processInput();
      host.args.cameraMode = vehicle.args.cameraMode;
      if (!host.args.standingOn.args.lockedIn && host.willJump && (host.yAxis < 0 || host.args.standingOn && host.args.standingOn.quickDrop)) {
        const leaving = host.args.standingOn;
        host.args.standingLayer = false;
        host.args.standingOn = false;
        host.willJump = false;
        leaving.occupant = null;
        host.args.falling = true;
        host.args.jumping = true;

        // host.args.y -= vehicle.args.seatHeight || vehicle.args.height;
        host.args.y -= 16;
        if (!(leaving && leaving.quickDrop)) {
          host.args.xSpeed = vehicle.args.direction * 2 * -Math.sign(vehicle.args.seatAngle || -1);
          host.args.ySpeed = -host.args.jumpForce;
        } else {
          host.args.ySpeed = -host.args.jumpForce + Math.max(leaving.args.ySpeed, 0);
        }
        vehicle.args.ySpeed = 0;
      }
      host.args.groundAngle = (vehicle.args.groundAngle || 0) + (vehicle.args.seatAngle || 0);
      if (host.willJump && host.yAxis >= 0) {
        host.args.standingOn.falling = false;
        host.willJump = false;
        host.args.standingOn.command_0();
      }
      return;
    }
    if (host.impulseMag !== null) {
      this.applyImpulse(host);
    }
    if (host.args.ignore === -2 && (host.args.falling === false || host.args.ySpeed > 0)) {
      host.args.ignore = 0;
    }
    if (host.args.ignore === -3 && (!host.args.falling || host.args.ySpeed >= -10)) {
      host.viewport.onFrameOut(1, () => host.args.ignore = 0);
    }
    if (host.args.ignore === -4 && !host.args.falling) {
      host.args.ignore = 30;
    }
    if (host.args.ignore < 1 && host.args.ignore > 0) {
      host.args.ignore = 0;
    }
    if (host.args.ignore > 0) {
      host.args.ignore--;
    }
    if (host.args.cameraIgnore > 0) {
      host.args.cameraIgnore--;
    }
    if (host.args.mercy > 0) {
      host.args.mercy--;
    }
    if (host.args.startled > 0) {
      host.args.startled--;
    }
    if (host.args.antiSkid > 0) {
      host.args.antiSkid--;
    }
    if (host.args.float > 0) {
      host.args.float--;
    }
    if (host.args.standingOn instanceof _PointActor.PointActor) {
      host.args.standingOn.callCollideHandler(host);
    }
    if (!host.args.float && host.args.falling) {
      if (!host.args.standingOn || !host.args.standingOn.isVehicle) {
        host.args.standingOn = null;
        host.args.landed = false;
        host.lastAngles.splice(0, host.lastAngles.length, ...Array(host.angleAvg).fill(0));
        if (host.args.jumping && host.args.jumpedAt < host.args.y) {
          host.args.deepJump = true;
        } else if (host.args.jumping && host.args.jumpedAt > host.args.y + 160) {
          host.args.highJump = true;
        } else if (host.args.jumping) {
          host.args.deepJump = false;
          host.args.highJump = false;
        }
      }
    } else if (host.args.jumping && !host.args.falling) {
      host.args.jumping = false;
      host.args.deepJump = false;
      host.args.highJump = false;
      host.args.jumpedAt = null;
    }
    if (!host.args.falling && host.args.standingOn && host.args.rolling && host.args.modeTime < 3 && !host.args.dropDashCharge && host.args.standingOn.args.convey) {
      host.args.gSpeed = -host.args.standingOn.args.convey * 0.8;
    }
    const drag = host.getLocalDrag();
    let gSpeedMax = host.args.gSpeedMax;
    let regions = new Set();
    if (!host.isRegion) {
      if (!host.noClip) {
        regions = host.viewport.regionsAtPoint(host.args.x, host.args.y);
        for (const region of host.regions) {
          region.updateActor(host);
        }
      }
      for (const region of regions) {
        if (host.args.density) {
          if (region.args.density && host.args.density < region.args.density) {
            const densityRatio = region.args.density / host.args.density;
            let blocked = false;
            let blockers = host.getMapSolidAt(host.x, host.y - host.args.height);
            if (Array.isArray(blockers)) {
              blockers.filter(x => ![...regions].includes(x));
              if (blockers.length) {
                blocked = true;
              }
            }
            if (!blocked) {
              const myTop = host.y - host.args.height;
              const regionTop = region.y - region.args.height;
              const depth = Math.min((myTop + -regionTop + 4) / host.args.height, 1);
              host.args.float = 1;
              const force = depth * drag;
              host.args.falling = true;
              if (depth > -1) {
                host.args.ySpeed -= force;
                host.args.ySpeed *= drag;
              } else if (depth < -1 && host.args.ySpeed < 0) {
                if (Math.abs(depth) < 0.25 && Math.abs(host.args.ySpeed) < 1) {
                  host.args.ySpeed = 0;
                  host.args.y = -1 + regionTop + host.args.height;
                }
              }
            }
          }
        }
        if (!host.regions.has(region)) {
          host.regions.add(region);
          host.crossRegionBoundary(region, true);
          region.enter(host);
        }
      }
      for (const region of host.regions) {
        if (!regions.has(region)) {
          host.regions.delete(region);
          host.crossRegionBoundary(region, false);
          region.leave(host);
        }
      }
    }
    if (host.willJump && !host.args.dontJump && (!host.args.falling || host.falltime < 2)) {
      host.willJump = false;
      const tileMap = host.viewport.tileMap;
      const height = Math.max(host.args.height, 32);
      const headPoint = host.rotatePoint(0, height + 1);
      let jumpBlock = host.getMapSolidAt(host.args.x + headPoint[0], host.args.y + headPoint[1]);
      if (Array.isArray(jumpBlock)) {
        jumpBlock = !!jumpBlock.filter(a => !a.args.platform && !a.isVehicle).length;
      }
      if (!jumpBlock) {
        let force = host.args.jumpForce * drag;
        if (host.running) {
          force = force * 1.5;
        } else if (host.crawling) {
          force = force * 0.5;
        }
        this.doJump(host, force);
      }
      return;
    }
    host.willJump = false;
    if (!host.viewport) {
      return;
    }
    if (host.noClip) {
      host.args.falling = true;
    }
    if (!host.args.static) {
      const groundPoint = host.groundPoint;
      const regionsBelow = host.controllable || host.args.pushed || host.isVehicle ? host.viewport.regionsAtPoint(groundPoint[0], groundPoint[1] + 1) : [];
      const standingOn = host.getMapSolidAt(...groundPoint) || (host.controllable && host.args.groundAngle ? host.getMapSolidAt(groundPoint[0], groundPoint[1] + 1) : false);
      if (!host.args.dead && !host.isRegion && host.args.mode === MODE_FLOOR && regionsBelow.size) {
        let falling = !standingOn;
        if (!host.args.falling || host.broad) for (const region of regionsBelow) {
          if (host.broad || !Math.round(host.args.ySpeed) && (Math.round(host.args.y) === region.args.y - region.args.height || Math.round(host.args.y + 1) === region.args.y - region.args.height || Math.round(host.args.y + 2) === region.args.y - region.args.height)) {
            if (region.skimSpeed < Infinity && (host.broad || Math.max(Math.abs(host.args.gSpeed), Math.abs(host.args.xSpeed)) >= region.skimSpeed)) {
              const speed = host.args.falling ? Math.abs(host.args.xSpeed) : Math.abs(host.args.gSpeed);
              host.args.gSpeed = speed * Math.sign(host.args.gSpeed || host.args.xSpeed);
              if (host.args.y - 32 < region.args.y - region.args.height) {
                if (host.broad) {
                  host.args.falling = false;
                }
                host.args.skimming = true;
                host.args.y = region.y - region.args.height + -1;
                falling = false;
                region.skim(host);
              } else if (host.broad) {
                host.args.ySpeed--;
              }
              break;
            } else {
              host.args.xSpeed = host.args.gSpeed || host.args.xSpeed;
            }
          }
        }
        if (standingOn instanceof _Layer.Layer) {
          host.args.standingOn = standingOn;
        } else {
          host.args.falling = host.args.falling || falling;
        }

        // host.args.falling = falling || host.args.falling;
        // host.args.falling = host.args.ySpeed <= 0 ? falling : host.args.falling;

        if (host.args.falling) {
          // host.args.xSpeed = host.args.xSpeed || host.args.gSpeed;
          host.args.standingLayer = null;
        } else {
          host.args.gSpeed = host.args.gSpeed || host.args.xSpeed;
        }
      } else if (!host.noClip && !host.args.climbing && !host.args.xSpeed && !host.args.ySpeed && !host.args.float) {
        host.args.falling = !host.args.float && !this.checkBelow(host) || host.args.falling;
      }
      if (!host.args.static && !host.noClip && host.args.falling) {
        host.args.mode = MODE_FLOOR;
        host.args.gSpeed = 0;
      }
      if (!host.willStick && (host.args.falling && host.args.ySpeed >= 0 || host.args.standingOn) && !host.args.static && !host.noClip) {
        let popOut = 64;
        const radius = host.args.width * 0.5;
        while (host.getMapSolidAt(host.args.x + -radius, host.args.y - host.args.height * 0.5) && !host.getMapSolidAt(host.args.x + radius + 1, host.args.y - host.args.height * 0.5) && popOut > 0) {
          host.args.x += 1;
          popOut--;
        }
        while (host.getMapSolidAt(host.args.x + radius, host.args.y - host.args.height * 0.5) && !host.getMapSolidAt(host.args.x + -radius + -1, host.args.y - host.args.height * 0.5) && popOut > 0) {
          host.args.x -= 1;
          popOut--;
        }
      }
      if (!host.viewport) {
        return;
      }
      if (host.noClip || !host.isRegion && !host.isEffect && host.args.falling && host.viewport) {
        if (host.args.grinding) {
          host.args.grinding = false;
        }

        // host.args.mode    = MODE_FLOOR;
        // host.args.gSpeed  = 0;
        host.args.pushing = false;
        if (host.args.xSpeed || host.args.ySpeed) {
          if (!host.args.hangingFrom) {
            this.updateAirPosition(host);
            host.swing = false;
            host.args.airTimeTotal++;
          } else {
            host.args.groundTimeTotal++;
            host.args.flying = false;
          }
        }
        host.args.animationBias = Math.abs(host.args.airSpeed / host.args.flySpeedMax);
        if (host.args.animationBias > 1) {
          host.args.animationBias = 1;
        }
        if (!host.args.canHide && !host.noClip) {
          let popOut = 32;
          let stuckInside;
          while (!host.args.static && host.args.mode === 0 && !host.getMapSolidAt(host.args.x, host.args.y - host.args.height, host.args.layer, 0) && (stuckInside = host.getMapSolidAt(host.args.x, host.args.y - 1, host.args.layer, 0))) {
            if (stuckInside.find && !stuckInside.find(other => {
              const collisions = host.viewport.collisions.get(host);
              return collisions && collisions.has(other);
            })) {
              break;
            }
            if (--popOut <= 0) {
              return;
            }
            host.args.y--;
          }
        }
      } else if (!host.args.static && (!host.noClip || host.args.standingLayer || !host.isRegion && !host.isEffect && !host.args.falling)) {
        if (Math.abs(host.args.xSpeed) > Math.abs(host.args.gSpeed)) {
          if (host.args.mode === 0) {
            host.args.gSpeed = host.args.xSpeed;
          } else if (host.args.mode === 2) {
            host.args.gSpeed = -host.args.xSpeed;
          }
          if (host.args.standingLayer) {
            host.args.gSpeed -= host.args.standingLayer.layer.offsetXChanged;
          }
        }
        host.args.xSpeed = 0;
        host.args.ySpeed = 0;
        host.xLast = host.args.x;
        host.yLast = host.args.y;
        if (host.args.grinding && !host.args.gSpeed && host.args.modeTime > 4) {
          host.args.gSpeed = Math.sign(host.args.direction || host.axis || host.xSpeedLast || host.gSpeedLast || 0);
        }
        if (!host.args.canHide && !host.noClip) {
          let popOut = 32;
          let stuckInside;
          while (!host.args.static && host.args.mode === 0 && (stuckInside = host.getMapSolidAt(host.args.x, host.args.y - 1))) {
            if (stuckInside.find && !stuckInside.find(other => {
              const collisions = host.viewport.collisions.get(host);
              return collisions && collisions.has(other);
            })) {
              break;
            }
            if (--popOut <= 0) {
              return;
            }
            host.args.y--;
          }
        }
        this.updateGroundPosition(host);
        host.args.groundTimeTotal++;
        host.args.animationBias = Math.abs((host.args.hSpeed * 0.75 || host.args.gSpeed) / host.args.gSpeedMax);
        if (host.args.animationBias > 1) {
          host.args.animationBias = 1;
        }
      }
      if (host.args.rolling && host.args.pushing) {
        host.args.gSpeed = 0;
      }
      if (!host.viewport) {
        return;
      }
    }
    const halfWidth = Math.ceil(host.args.width / 2);
    const halfHeight = Math.floor(host.args.height / 2);

    // if(!host.isRegion && (host.args.pushed || ( !host.willStick && host.controllable )))
    if (!host.noClip && !host.isRegion && host.args.pushed) {
      let block;
      const testWallPoint = direction => {
        switch (host.args.mode) {
          case MODE_FLOOR:
            block = host.getMapSolidAt(host.x + halfWidth * direction + (direction === -1 ? 0 : -1), host.y - halfHeight);
            break;
          case MODE_CEILING:
            block = host.getMapSolidAt(host.x + halfWidth * direction + (direction === -1 ? 0 : -1), host.y + halfHeight);
            break;
          case MODE_LEFT:
            block = host.getMapSolidAt(host.x + halfHeight * (direction === -1 ? 0 : 2), host.y);
            break;
          case MODE_RIGHT:
            block = host.getMapSolidAt(host.x - halfHeight * (direction === -1 ? 0 : 2), host.y);
            break;
        }
        if (block && Array.isArray(block)) {
          return block.filter(a => !a.args.platform && !a.isVehicle);
        }
        return block;
      };
      const leftWall = testWallPoint(-1);
      const rightWall = testWallPoint(1);
      if (rightWall && !leftWall) {
        if (host.args.xSpeed > 0) {
          host.args.xSpeed = 0;
        }
        host.args.x--;
      }
      if (leftWall && !rightWall) {
        if (host.args.xSpeed > 0) {
          host.args.xSpeed = 0;
        }
        host.args.x++;
      }
    }
    if (!host.viewport || host.removed) {
      return;
    }
    const layerSwitch = host.viewport.objectPalette['layer-switch'];
    const regionClass = host.viewport.objectPalette['base-region'];
    const skipChecking = [regionClass];
    if (!host.noClip && !host.isGhost && !host.isStatic && !host.isRegion && !skipChecking.some(x => host instanceof x)) {
      let collisions;
      switch (host.args.mode) {
        case MODE_CEILING:
          collisions = viewport.actorsAtPoint(host.args.x, host.args.y + host.args.height, host.args.width, host.args.height);
          break;
        case MODE_LEFT:
          collisions = viewport.actorsAtPoint(host.args.x + host.args.height / 2, host.args.y + host.args.width / 2, host.args.height, host.args.width);
          break;
        case MODE_RIGHT:
          collisions = viewport.actorsAtPoint(host.args.x - host.args.height / 2, host.args.y + host.args.width / 2, host.args.height, host.args.width);
          break;
        default:
        case MODE_FLOOR:
          collisions = viewport.actorsAtPoint(host.args.x, host.args.y, host.args.width, host.args.height);
          break;
      }
      collisions.forEach(x => x.args !== host.args && !(host.args.static && x.args.static) && !x.isPushable && x.callCollideHandler(host));
    }
    if (!host.viewport) {
      return;
    }
    const tileMap = host.viewport.tileMap;
    if ((host.args.pushing || Math.abs(host.args.gSpeed) < 2) && !host.args.falling) {
      let stayStuck = host.stayStuck;
      host.regions.forEach(region => {
        stayStuck = stayStuck || region.args.sticky;
      });
      if (!stayStuck && !host.args.climbing) {
        const half = Math.floor(host.args.width / 2) || 0;

        // if(!tileMap.getSolid(host.x, host.y+1, host.args.layer))
        const mode = host.args.mode;
        if (host.args.mode === MODE_FLOOR && host.args.groundAngle <= -(Math.PI / 4)) {
          host.args.gSpeed = 1;
        } else if (host.args.mode === MODE_FLOOR && host.args.groundAngle >= Math.PI / 4 && host.args.groundAngle < Math.PI) {
          host.args.gSpeed = -1;
        } else if (mode === MODE_LEFT && host.args.groundAngle < Math.PI * 0.05) {
          host.lastAngles.splice(0, host.lastAngles.length, ...Array(host.angleAvg).fill(0));

          // host.args.xSpeed = 2;

          host.args.mode = MODE_FLOOR;
          host.args.falling = true;
          if (host.args.rolling) {
            host.args.x += host.args.width;
            host.args.y += host.args.height;
            host.args.ySpeed = host.args.gSpeed;
            host.args.float = 1;
          } else {
            host.args.groundAngle = -Math.PI / 2;
            host.args.x++;
          }
          host.args.cameraIgnore = 30;
          host.args.ignore = -4;
        } else if (mode === MODE_RIGHT && host.args.groundAngle > -Math.PI * 0.05) {
          host.lastAngles.splice(0, host.lastAngles.length, ...Array(host.angleAvg).fill(0));

          // host.args.xSpeed = -2;

          host.args.mode = MODE_FLOOR;
          host.args.falling = true;
          if (host.args.rolling) {
            host.args.x -= host.args.width;
            host.args.y += host.args.height;
            host.args.ySpeed = -host.args.gSpeed;
            host.args.float = 1;
          } else {
            host.args.groundAngle = Math.PI / 2;
            host.args.x--;
          }
          host.args.cameraIgnore = 30;
          host.args.ignore = -4;
        } else if (mode === MODE_CEILING) {
          host.lastAngles.splice(0, host.lastAngles.length, ...Array(host.angleAvg).fill(0));
          host.args.xSpeed = 0;
          host.args.y++;
          host.args.falling = true;
          host.willJump = false;
          const gSpeed = host.args.gSpeed;
          host.args.groundAngle = Math.PI;
          host.args.mode = MODE_FLOOR;
          host.viewport.onFrameOut(1, () => {
            host.args.mode = MODE_FLOOR;
            host.willJump = false;
            host.args.xSpeed = -gSpeed;
          });
          if (!host.args.rolling) {
            if (Math.sign(host.xSpeedLast) === -1) {
              host.args.direction = -1;
              host.args.facing = 'left';
              // host.args.x++;
            } else if (Math.sign(host.xSpeedLast) === 1) {
              host.args.direction = 1;
              host.args.facing = 'right';
              // host.args.x--;
            }
          }

          host.args.cameraIgnore = 30;
          host.args.ignore = -2;
        }
      }
    }
    host.args.landed = true;
    if (host.controllable) {
      host.args.x = host.args.x;
      host.args.y = host.args.y;
    }
    host.controllable && host.processInput();
    if (host.args.falling || host.args.gSpeed) {
      host.args.stopped = 0;
    } else {
      host.args.stopped++;
    }
    if (host.args.falling) {
      host.lastAngles.splice(0, host.lastAngles.length, ...Array(host.angleAvg).fill(0));
    } else if (host.lastAngles.length > 0) {
      host.args.groundAngle = host.lastAngles.map(a => Number(a)).reduce((a, b) => a + b) / host.lastAngles.length;
    }
    if (isNaN(host.args.groundAngle)) {
      console.log(host.lastAngles, host.lastAngles.length);
    }
    if (!host.args.float && !host.args.static && !host.noClip) {
      const standingOn = host.getMapSolidAt(...host.groundPoint);
      if (Array.isArray(standingOn) && standingOn.length && !host.args.float) {
        host.args.standingLayer = false;
        const groundActors = standingOn.filter(a => a.args !== host.args && a.solid && a.callCollideHandler(host));
        if (groundActors.length) {
          for (const groundActor of groundActors) {
            if (!groundActor.isVehicle && host.args.y > 1 + groundActor.args.y + -groundActor.args.height) {
              continue;
            }
            host.args.groundAngle = groundActor.groundAngle || 0;
            host.args.standingOn = groundActor;

            // if(groundActor.args.standingLayer)
            // {
            // 	host.args.standingLayer = groundActor.args.standingLayer;
            // }
          }
        }
      } else if (standingOn) {
        host.args.standingOn = null;
        if (typeof standingOn === 'object') {
          if (!Array.isArray(standingOn)) {
            host.args.standingLayer = standingOn;
          }
          if (host.args.modeTime < 1 && standingOn.xLayerSpeed) {
            // host.args.gSpeed = 0;
          }
        } else {
          host.args.standingLayer = null;
        }
      } else if (host.args.standingOn && !host.args.standingOn.isVehicle) {
        host.args.standingOn = null;
      }
    }
    if (!host.args.static && !host.isRegion && !host.noClip && !host.args.xSpeed && !host.args.ySpeed && this.checkBelow(host, host.args.x, host.args.y)) {
      host.args.falling = false;
    }
    if (host.args.falling && host.args.ySpeed < host.args.ySpeedMax) {
      if (!host.args.float) {
        let gravity = 1;
        for (const region of host.regions) {
          if (!region.args.gravity && region.args.gravity !== 1) {
            continue;
          }
          gravity *= region.args.gravity;
        }
        host.args.ySpeed += host.args.gravity * gravity;
      }
      host.args.landed = false;
    }
    if (!host.args.falling) {
      this.checkDropDash(host);
      host.args.jumping = false;
    }

    // for(const behavior of host.behaviors)
    // {
    // 	behavior.update(host);
    // }

    if (host.twister) {
      if (host.viewport && host.viewport.args.frameId % host.viewport.settings.frameSkip === 0) {
        host.twister.args.x = host.args.x;
        host.twister.args.y = host.args.y;
      }
      if (host.args.mode) {
        host.twister.args.xOff = host.args.xOff;
      } else {
        host.twister.args.xOff = host.args.xOff + -8 * host.args.direction;
      }
      host.twister.args.yOff = host.args.yOff + 16;
      host.twister.args.width = host.args.width;
      host.twister.args.height = host.args.height;
    }
    if (host.pincherBg) {
      if (host.viewport && host.viewport.args.frameId % host.viewport.settings.frameSkip === 0) {
        host.pincherBg.args.x = host.args.x;
        host.pincherBg.args.y = host.args.y;
      }
      host.pincherBg.args.xOff = host.args.xOff;
      host.pincherBg.args.yOff = host.args.yOff;
      host.pincherBg.args.width = host.args.width;
      host.pincherBg.args.height = host.args.height;
    }
    if (host.pincherFg) {
      if (host.viewport && host.viewport.args.frameId % host.viewport.settings.frameSkip === 0) {
        host.pincherFg.args.x = host.args.x;
        host.pincherFg.args.y = host.args.y;
      }
      host.pincherFg.args.xOff = host.args.xOff;
      host.pincherFg.args.yOff = host.args.yOff;
      host.pincherFg.args.width = host.args.width;
      host.pincherFg.args.height = host.args.height;
    }
    if (host.args.falling) {
      host.groundTime = 0;
      host.idleTime = 0;
      host.args.rolling = false;
      host.fallTime++;
    } else {
      host.groundTime++;
      host.idleTime++;
      if (host.yAxis || host.xAxis) {
        host.idleTime = 0;
      }
    }
    host.args.carrying = !!host.carrying.size;
    if (host.args.carrying) {
      if (Math.abs(host.args.gSpeed) > 8) {
        host.args.gSpeed = 8 * Math.sign(host.args.gSpeed);
      }
      host.idleTime = 0;
      host.args.rolling = false;
    }
  }
  applyImpulse(host) {
    if (host.args.dead) {
      return;
    }
    host.args.xSpeed += Number(Number(Math.cos(host.impulseDir) * host.impulseMag).toFixed(3));
    host.args.ySpeed += Number(Number(Math.sin(host.impulseDir) * host.impulseMag).toFixed(3));
    if (!host.impulseFal) {
      switch (host.args.mode) {
        case MODE_FLOOR:
          host.args.gSpeed = Math.cos(host.impulseDir) * host.impulseMag;
          break;
        case MODE_CEILING:
          host.args.gSpeed = -Math.cos(host.impulseDir) * host.impulseMag;
          break;
        case MODE_LEFT:
          host.args.gSpeed = -Math.sin(host.impulseDir) * host.impulseMag;
          break;
        case MODE_RIGHT:
          host.args.gSpeed = Math.sin(host.impulseDir) * host.impulseMag;
          break;
      }
    } else {
      host.args.falling = host.impulseFal || host.args.falling;
    }
    host.impulseMag = null;
    host.impulseDir = null;
    host.impulseFal = null;
  }
  updateGroundPosition(host) {
    if (host.args.mercy) {
      if (Math.abs(host.args.gSpeed) > 10) {
        host.args.gSpeed = 10 * Math.sign(host.args.gSpeed);
      }
    }
    const drag = host.getLocalDrag();
    let gSpeedMax = host.args.gSpeedMax;
    if (host.running) {
      gSpeedMax = RUNNING_SPEED;
    } else if (host.crawling) {
      gSpeedMax = CRAWLING_SPEED;
    }
    let nextPosition = [0, 0];
    const radius = Math.ceil(host.args.width / 2);
    const wasPaused = host.paused;
    if (host.args.gSpeed || host.args.rolling || host.canRoll && host.args.crouching) {
      // const scanDist  = radius + Math.abs(host.args.gSpeed);
      const direction = Math.sign(host.args.gSpeed || host.args.direction);
      const max = Math.abs(host.args.gSpeed) + host.args.gForce;
      const step = 1;
      host.pause(true);
      const dirs = [0, 0, Math.PI];
      const filterBlockers = x => x.args !== host.args && x.callCollideHandler(host) && x.solid;
      for (let s = 0; s < max; s += step) {
        if (host.args.height > 8 && host.args.modeTime > 1) {
          if (!host.args.gSpeed) {
            host.args.pushing = false;
          }
          const headPoint = host.rotatePoint(radius * -direction, host.args.height);
          let headBlock = host.getMapSolidAt(host.args.x + headPoint[0], host.args.y + headPoint[1]);
          if (Array.isArray(headBlock)) {
            headBlock = headBlock.filter(filterBlockers).length;
          }
          if (headBlock) {
            if (host.args.mode === MODE_CEILING) {
              host.args.x += radius * Math.sign(host.args.gSpeed);
              host.args.y += host.args.height;
              host.args.mode = MODE_FLOOR;
            }
            host.args.pushing = Math.sign(host.args.gSpeed);
            break;
          } else {
            host.args.pushing = false;
          }
          let waistBlock = false;
          if (!host.noClip && host.controllable && host.args.groundAngle === 0) {
            const waistPoint = host.rotatePoint(-radius * Math.sign(host.args.gSpeed), host.args.height * 0.5);
            waistBlock = host.getMapSolidAt(host.args.x + waistPoint[0], host.args.y + waistPoint[1]);
            if (Array.isArray(waistBlock)) {
              waistBlock = waistBlock.filter(filterBlockers).length || false;
            }
            if (waistBlock !== false && waistBlock <= radius) {
              if (host.args.mode === MODE_CEILING) {
                host.args.x += radius * Math.sign(host.args.gSpeed);
                host.args.y += host.args.rollingeight || host.args.height;
                host.args.mode = MODE_FLOOR;
                host.args.gSpeed = 0;
              } else if (host.args.mode === MODE_FLOOR) {
                host.args.gSpeed = Math.min(1, waistBlock) * Math.sign(host.args.gSpeed);
              }
              host.args.gSpeed && (host.args.pushing = Math.sign(host.args.gSpeed));
              break;
            }
          }

          // if(!headBlock && !waistBlock)
          // {
          // 	host.args.pushing = 0;
          // }
        }

        for (const behavior of host.behaviors) {
          behavior.movedGround && behavior.movedGround(host);
        }
        if (host.args.falling || host.locked) {
          return;
        }
        nextPosition = this.findNextStep(host, step * direction);
        if (!nextPosition) {
          break;
        }
        if (nextPosition[3]) {
          host.args.moving = false;
          host.args.gSpeed = 0.15 * Math.sign(host.args.gSpeed);

          // if(host.args.mode === MODE_LEFT || host.args.mode === MODE_RIGHT)
          // {
          // 	host.args.mode = MODE_FLOOR;
          // 	host.lastAngles.splice(0, host.lastAngles.length, ...Array(host.angleAvg).fill(0));
          // }

          break;
        } else if (nextPosition[2] === true) {
          const gSpeed = host.args.gSpeed || 0;
          const gAngle = host.args.groundAngle || 0;
          host.args.standingLayer = null;
          let radius;
          let hRadius;
          switch (host.args.mode) {
            case MODE_FLOOR:
              radius = host.args.width / 2;

              // if(headBlock)
              // {
              // 	host.args.x += (headBlock - host.args.width) * Math.sign(gSpeed);
              // }
              // else

              const stepsLeft = Math.max(1, Math.abs(gSpeed) - Math.abs(this.stepsTaken)) || 1;
              const impulseLeft = stepsLeft * Math.sign(gSpeed || 0);
              host.args.x += impulseLeft * Math.cos(gAngle);
              host.args.y += -impulseLeft * Math.sin(gAngle);
              host.args.xSpeed = gSpeed * Math.cos(gAngle);
              host.args.ySpeed = -gSpeed * Math.sin(gAngle);
              host.args.float = host.args.float < 0 ? host.args.float : 1;
              let falling = !!host.args.gSpeed;
              if (this.checkBelow(host, host.args.x, host.args.y)) {
                host.args.gSpeed = gSpeed;
                host.args.xSpeed = 0;
                host.args.ySpeed = 0;
                falling = false;
                if (host.canRoll && host.yAxis > 0.55) {
                  host.args.rolling = true;
                }
              }
              host.args.falling = falling;
              host.args.ignore = 2;
              break;
            case MODE_CEILING:
              host.args.y += host.args.height;
              host.args.y++;
              host.args.float = host.args.float < 0 ? host.args.float : 1;
              host.args.falling = true;

              // host.args.groundAngle  = Math.PI;
              // host.args.displayAngle = Math.PI;

              host.args.mode = MODE_FLOOR;
              host.args.xSpeed = -gSpeed * Math.cos(gAngle);
              host.args.ySpeed = gSpeed * Math.sin(gAngle);
              host.args.x += -gSpeed * Math.cos(gAngle);
              host.args.y += gSpeed * Math.sin(gAngle);
              host.lastAngles.splice(0, host.lastAngles.length, ...Array(host.angleAvg).fill(0));
              host.args.direction *= -1;
              if (!host.args.rolling && !host.args.grinding) {
                host.args.facing = host.args.facing === 'left' ? 'right' : 'left';
              }
              host.args.ignore = 3;
              break;
            case MODE_LEFT:
              radius = host.args.width / 2;
              hRadius = host.args.height / 2;
              if (!host.args.climbing) {
                if (Math.abs(host.args.gSpeed) < 2 && !host.args.rolling) {
                  if (host.args.gSpeed < 0) {
                    // host.args.x -= host.args.direction;
                    // host.args.y -= hRadius * Math.sign(host.args.gSpeed);
                    // host.args.y -= host.args.gSpeed + -2;
                    // host.args.groundAngle = 0;
                  } else {
                    host.args.x += radius;
                  }
                } else {
                  host.args.ignore = -3;
                  host.args.x += 1;
                  // host.args.y += hRadius;
                }

                host.args.xSpeed = gSpeed * Math.sin(gAngle);
                host.args.ySpeed = gSpeed * Math.cos(gAngle);
                host.args.x += gSpeed * Math.sin(gAngle);
                host.args.y += gSpeed * Math.cos(gAngle);
                if (host.isVehicle || !host.args.rolling && !host.args.grinding) {
                  host.args.groundAngle = -Math.PI * 0.5;
                } else {
                  host.args.x += radius;
                }
                host.args.mode = MODE_FLOOR;
                host.args.cameraIgnore = 30;

                // host.onNextFrame(() => {
                // });
              }

              // host.args.mode = MODE_FLOOR;
              host.args.falling = true;
              break;
            case MODE_RIGHT:
              radius = host.args.width / 2;
              hRadius = host.args.height / 2;
              if (!host.args.climbing) {
                if (Math.abs(host.args.gSpeed) < 3 && !host.args.rolling) {
                  if (host.args.gSpeed > 0) {
                    // host.args.x -= host.args.direction;
                    // host.args.y -= hRadius * Math.sign(host.args.gSpeed);
                    // host.args.y -= host.args.gSpeed + 2;
                    // host.args.groundAngle = 0;
                  } else {
                    host.args.x -= 1;
                  }
                } else {
                  host.args.ignore = -3;
                  host.args.x -= 1;
                  // host.args.y += hRadius;
                }

                host.args.xSpeed = -gSpeed * Math.sin(gAngle);
                host.args.ySpeed = -gSpeed * Math.cos(gAngle);
                host.args.x += -gSpeed * Math.sin(gAngle);
                host.args.y += -gSpeed * Math.cos(gAngle);
                if (host.isVehicle || !host.args.rolling && !host.args.grinding) {
                  host.args.groundAngle = Math.PI * 0.5;
                } else {
                  host.args.x -= radius;
                }
                host.args.mode = MODE_FLOOR;
                host.args.cameraIgnore = 30;

                // host.onNextFrame(() => {
                // });
              }

              // host.args.mode = MODE_FLOOR;
              host.args.falling = true;
              break;
          }

          // host.args.gSpeed = 0;

          break;
        } else if (!nextPosition[0] && !nextPosition[1]) {
          host.args.moving = false;
          switch (host.args.mode) {
            case MODE_FLOOR:
            case MODE_CEILING:
              host.args.gSpeed = 0;
              break;
            case MODE_LEFT:
            case MODE_RIGHT:
              break;
          }
        } else if ((nextPosition[0] || nextPosition[1]) && !host.rotateLock) {
          host.args.moving = true;
          if (!host.keepAngle) {
            let newAngle = nextPosition[0] ? Math.atan(nextPosition[1] / nextPosition[0]) : Math.sign(nextPosition[1]) * Math.PI / 2;
            if (Math.abs(host.args.angle - newAngle) >= Math.PI * 0.38) {
              const sensorSpread = 6;
              const backPositionWide = this.findNextStep(host, -sensorSpread);
              const forePositionWide = this.findNextStep(host, sensorSpread);
              // console.log({mode: host.args.mode, nextPosition, forePositionWide, backPositionWide});
              if (backPositionWide[1] === nextPosition[1] || forePositionWide[1] === nextPosition[1]) {
                newAngle = 0;
              }
            }
            host.args.angle = newAngle;
            host.lastAngles.unshift(host.args.angle);
            host.lastAngles.splice(host.angleAvg);

            // console.log(newAngle, host.args.angle / Math.PI, host.groundTime);
          }
        }

        if (!host.rotateLock) {
          switch (host.args.mode) {
            case MODE_FLOOR:
              host.args.x += nextPosition[0];
              host.args.y -= nextPosition[1];
              break;
            case MODE_CEILING:
              host.args.x -= nextPosition[0];
              host.args.y += nextPosition[1];
              break;
            case MODE_LEFT:
              host.args.x += nextPosition[1];
              host.args.y += nextPosition[0];
              break;
            case MODE_RIGHT:
              host.args.x -= nextPosition[1];
              host.args.y -= nextPosition[0];
              break;
          }
          if (host.args.angle > Math.PI / 4 && host.args.angle < Math.PI / 2) {
            const lastAngles = host.lastAngles.map(n => Number(n) - Math.PI / 2);
            Object.defineProperty(lastAngles, _Bindable.Bindable.NoGetters, {
              value: true
            });
            host.lastAngles = lastAngles;
            switch (host.args.mode) {
              case MODE_FLOOR:
                host.args.mode = MODE_RIGHT;
                break;
              case MODE_RIGHT:
                host.args.mode = MODE_CEILING;
                break;
              case MODE_CEILING:
                host.args.mode = MODE_LEFT;
                break;
              case MODE_LEFT:
                host.args.mode = MODE_FLOOR;
                break;
            }
            host.args.groundAngle -= Math.PI / 2;
          } else if (host.args.angle < -Math.PI / 4 && host.args.angle > -Math.PI / 2) {
            const orig = host.args.mode;
            const lastAngles = host.lastAngles.map(n => Number(n) + Math.PI / 2);
            Object.defineProperty(lastAngles, _Bindable.Bindable.NoGetters, {
              value: true
            });
            host.lastAngles = lastAngles;
            switch (host.args.mode) {
              case MODE_FLOOR:
                host.args.mode = MODE_LEFT;
                break;
              case MODE_RIGHT:
                host.args.mode = MODE_FLOOR;
                break;
              case MODE_CEILING:
                host.args.mode = MODE_RIGHT;
                break;
              case MODE_LEFT:
                host.args.mode = MODE_CEILING;
                break;
            }
            host.args.groundAngle = Number(host.args.groundAngle) + Math.PI / 2;
          }
        } else {
          host.args.x += nextPosition[0];
          host.args.y -= nextPosition[1];
        }
      }
      if (host.args.pushing && !host.args.careening) {
        host.args.gSpeed = Math.sign(host.args.gSpeed);
      }
      const hRadius = Math.round(host.args.height / 2);
      let popOut = 16;
      if (!host.args.static && host.args.mode === MODE_FLOOR) {
        while ((host.args.gSpeed <= 0 || host.args.modeTime < 3) && host.getMapSolidAt(host.args.x - radius, host.args.y - hRadius, false) && popOut > 0) {
          // host.args.direction = 0;
          // host.args.gSpeed = 0;
          host.args.x++;
          popOut--;
        }
        while ((host.args.gSpeed >= 0 || host.args.modeTime < 3) && host.getMapSolidAt(host.args.x + radius, host.args.y - hRadius, false) && popOut > 0) {
          // host.args.direction = 0;
          // host.args.gSpeed = 0;
          host.args.x--;
          popOut--;
        }
      }
      wasPaused || host.pause(false);
      const pushFoward = host.xAxis && Math.sign(host.xAxis) === Math.sign(host.args.gSpeed);
      const friction = host.getLocalFriction();
      if (host.args.mode === MODE_FLOOR || host.args.mode === MODE_CEILING || host.args.gSpeed < 0 && host.args.mode === MODE_LEFT || host.args.gSpeed > 0 && host.args.mode === MODE_RIGHT) {
        const pushBack = host.xAxis && Math.sign(host.xAxis) !== Math.sign(host.args.gSpeed);
        const decel = friction * host.args.decel * (host.args.rolling && pushBack ? 3 : 0.75);
        if (!host.args.climbing && host.args.gSpeed && (!pushFoward || host.args.rolling)) {
          if (host.args.sliding) {} else if (host.args.grinding) {
            if (Math.abs(host.yAxis) > 0.5) {
              // host.args.gSpeed -= decel * 1/drag * 0.06125 * Math.sign(host.args.gSpeed);
            } else {
              host.args.gSpeed -= decel * 1 / drag * 0.125 * Math.sign(host.args.gSpeed);
            }
            if (Math.abs(host.args.gSpeed) > 40) {
              host.args.gSpeed = 40 * direction;
            }
          } else if (host.args.rolling) {
            host.args.gSpeed -= decel * 1 / drag * 0.06125 * Math.sign(host.args.gSpeed);
          } else if (!host.args.grinding && !host.args.rolling && (!host.xAxis || pushBack && Math.abs(host.args.gSpeed) > 6)) {
            const step = decel * 1 / drag * Math.sign(host.args.gSpeed);
            if (Math.abs(host.args.gSpeed) > Math.abs(step)) {
              host.args.gSpeed -= step;
            } else {
              host.args.gSpeed = 0;
            }
          }
          if (Math.abs(host.args.gSpeed) < 0.1 || pushBack && Math.abs(host.args.gSpeed) < 1) {
            host.args.gSpeed = 0;
          }
        }
      }

      // if(!pushFoward && Math.abs(host.args.gSpeed) < 1)
      // {
      // 	if(!host.args.climbing && !host.args.wallSticking)
      // 	{
      // 		// host.args.gSpeed = 0;
      // 	}
      // }

      let slopeFactor = 0;
      if (!host.args.climbing) {
        switch (host.args.mode) {
          case MODE_FLOOR:
            slopeFactor = host.args.groundAngle / (Math.PI / 2);
            if (direction > 0) {
              slopeFactor *= -1;
            }
            break;
          case MODE_CEILING:
            slopeFactor = -host.args.groundAngle / (Math.PI / 2);
            if (direction > 0) {
              slopeFactor *= -1;
            }
            break;
            break;
          case MODE_RIGHT:
            if (direction > 0) {
              slopeFactor = -1;
              slopeFactor -= host.args.groundAngle / (Math.PI / 2);
            } else {
              slopeFactor = 1;
              slopeFactor += host.args.groundAngle / (Math.PI / 2);
            }
            break;
          case MODE_LEFT:
            if (direction > 0) {
              slopeFactor = 1;
              slopeFactor -= host.args.groundAngle / (Math.PI / 2);
            } else {
              slopeFactor = -1;
              slopeFactor += host.args.groundAngle / (Math.PI / 2);
            }
            break;
        }
        if (host.args.grinding) {
          const speed = Math.abs(host.args.gSpeed);

          // const direction = Math.sign(host.args.gSpeed || host.xSpeedLast || 1);
          const direction = Math.sign(host.args.gSpeed);
          host.args.direction = direction;

          // if(Math.sign(host.args.gSpeed) !== Math.sign(host.args.direction))
          // {
          // 	host.args.gSpeed = 0;
          // }

          if (speed < 6) {
            host.args.gSpeed = 6 * direction;
          } else if (speed > 40) {
            host.args.gSpeed = 40 * direction;
          } else if (slopeFactor < 0) {
            host.args.gSpeed *= 1.0000 - (0 - slopeFactor / 2 * 0.015);
          } else if (slopeFactor > 0) {
            host.args.gSpeed *= 1.0015 * (1 + slopeFactor / 2 * 0.045);
          } else {
            host.args.gSpeed += 0.1 * direction;
          }
        } else if (host.args.rolling || host.canRoll && host.args.crouching) {
          if (slopeFactor > 0 && host.args.modeTime > 3) {
            if ((host.args.gSpeed || Math.abs(slopeFactor) > 0.05) && Math.abs(host.args.gSpeed) < host.args.gSpeedMax * 3) {
              host.args.gSpeed += 0.60 * slopeFactor * direction;
            }
            if (Math.abs(host.args.gSpeed) < 1) {
              host.args.gSpeed = (1 + slopeFactor ** 2) * Math.sign(host.args.gSpeed);
            }
            const regions = host.controllable || host.args.pushed || host.isVehicle ? host.regions : [];
            for (const region of regions) {
              if (!region.args.maxSpeed || region.args.maxSpeed < 0) {
                continue;
              }
              if (region.args.maxSpeed < Math.abs(host.args.gSpeed)) {
                host.args.gSpeed = region.args.maxSpeed * Math.sign(host.args.gSpeed);
              }
            }
            if (Math.abs(slopeFactor) > 0.25 && Math.abs(host.args.gSpeed) < 2 && Math.abs(Math.sign(host.args.gSpeed) - Math.sign(direction)) < 2) {
              host.args.gSpeed = 2 * direction;
            }
          } else if (slopeFactor < -0.20 || slopeFactor < 0 && host.args.gSpeed) {
            host.args.gSpeed += -0.078125 * direction;
            // if(Math.abs(host.args.gSpeed) < 10)
            // {
            // 	const slopeVector = slopeFactor * direction;

            // 	if(host.args.gSpeed || slopeFactor < -0.075)
            // 	{
            // 		if(Math.sign(slopeVector) === Math.sign(host.args.gSpeed))
            // 		{
            // 			host.args.gSpeed += 1.65 * slopeFactor * direction;
            // 		}
            // 		else
            // 		{
            // 			host.args.gSpeed += 0.25 * slopeFactor * direction;
            // 		}
            // 	}
            // }
            // else
            // {
            // 	host.args.gSpeed += 0.65 * slopeFactor * direction;
            // }
          }
        } else if (!host.stayStuck) {
          if (slopeFactor > 0.125) {
            if (Math.abs(host.args.gSpeed) < host.args.gSpeedMax * 2) {
              host.args.gSpeed += 0.25 * slopeFactor * direction;
              if (Math.abs(host.args.gSpeed) < 2 && Math.abs(Math.sign(host.args.gSpeed) - Math.sign(direction)) < 2) {
                host.args.gSpeed = 2 * direction;
              }
            }
          } else if (slopeFactor < -0.075) {
            const originalSign = Math.sign(host.args.gSpeed);
            if (Math.abs(host.args.gSpeed) < 10) {
              host.args.gSpeed += 0.30 * slopeFactor * direction;
            } else {
              // host.args.gSpeed += 0.15 * slopeFactor * direction;
            }
            if (Math.sign(host.args.gSpeed) !== originalSign) {
              host.args.ignore = host.args.ignore || 5;
              host.args.antiSkid = 10;
              host.args.gSpeed += Math.sign(host.args.gSpeed) * 0.5;
            }
          } else if (slopeFactor > 0 && friction < 0.75) {
            if (Math.abs(host.args.gSpeed) < 1) {
              host.args.gSpeed = direction;
            }
            host.args.gSpeed += direction * slopeFactor;
          }

          // let speedFactor = 1;

          // if(slopeFactor < 0 && Math.abs(host.args.gSpeed) < 2)
          // {
          // 	speedFactor = 0.99990 * (1 - (slopeFactor**2/4) / 2);
          // }
          // else if(slopeFactor > 1 && Math.abs(host.args.gSpeed) < host.args.gSpeedMax / 2)
          // {
          // 	speedFactor = 1.05000 * (1 + (slopeFactor**2/4) / 2);
          // }

          // if(host.args.mode === MODE_FLOOR && slopeFactor > 0.25)
          // {
          // 	if(Math.abs(host.args.gSpeed) < 1)
          // 	{
          // 		host.args.gSpeed = Math.sign(slopeFactor) * 4 * Math.sign(host.args.gSpeed);
          // 	}

          // 	host.args.gSpeed += slopeFactor * 1 * Math.sign(host.args.gSpeed);
          // }
          // else if(host.args.mode === MODE_FLOOR && slopeFactor < -0.25)
          // {
          // 	if(Math.abs(host.args.gSpeed) < 1)
          // 	{
          // 		host.args.gSpeed = Math.sign(-slopeFactor) * 4 * Math.sign(-host.args.gSpeed);
          // 	}

          // 	host.args.gSpeed += -slopeFactor * 1 * Math.sign(-host.args.gSpeed);
          // }

          // if(host.args.mode === MODE_LEFT && slopeFactor < 0.5)
          // {
          // 	if(Math.abs(host.args.gSpeed) < 1)
          // 	{
          // 		host.args.gSpeed = Math.sign(slopeFactor) * 4;
          // 	}

          // 	host.args.gSpeed += -slopeFactor * 1;
          // }

          // if(host.args.mode === MODE_RIGHT && slopeFactor < -0.5)
          // {
          // 	if(Math.abs(host.args.gSpeed) < 1)
          // 	{
          // 		host.args.gSpeed = Math.sign(slopeFactor) * 4;
          // 	}

          // 	host.args.gSpeed += slopeFactor * 1;
          // }

          if (Math.abs(host.args.gSpeed) < 1) {
            // if(slopeFactor <= -1)
            // {
            // 	host.args.gSpeed *= -0.5;
            // 	host.args.ignore = host.args.ignore || 8;
            // }
          }
        }
      }
    }
    if (nextPosition && (nextPosition[0] !== false || nextPosition[1] !== false)) {} else {
      host.args.ignore = host.args.ignore || 1;
      if (host.args.falling) {
        // host.args.gSpeed = 0;
      }
    }
    host.args.heading = Math.sign(host.args.gSpeed);

    // if(host.controllable)
    // {
    // 	const radius = 0.5 * host.args.width;
    // 	const direction = Math.sign(host.args.xSpeed);
    // 	const height = Math.max(host.args.height, 0);

    // 	const headPoint = host.rotatePoint(0, height * 0.75);
    // 	// const headPoint = host.rotatePoint(radius * -direction, host.args.height * 0.75);

    // 	let jumpBlock = host.getMapSolidAt(host.x + headPoint[0], host.y + headPoint[1]);

    // 	if(Array.isArray(jumpBlock))
    // 	{
    // 		jumpBlock = !!jumpBlock.filter(a => !a.args.platform && !a.isVehicle).length;
    // 	}

    // 	if(!host.args.falling && this.checkBelow(host, host.x, host.y) && jumpBlock)
    // 	{
    // 		console.log(host.realAngle, host.args.groundAngle, host.args.mode);
    // 		console.log([host.x + headPoint[0], host.y + headPoint[1]]);
    // 		console.log(headPoint);

    // 		host.die();

    // 		return;
    // 	}
    // }
  }

  updateAirPosition(host) {
    const xSpeedOriginal = host.args.xSpeed;
    const ySpeedOriginal = host.args.ySpeed;
    const originalAngle = host.airAngle;
    host.args.standingLayer = null;
    const viewport = host.viewport;
    const radius = Math.ceil(host.args.width / 2);
    const direction = Math.sign(host.args.xSpeed);
    const tileMap = host.viewport.tileMap;
    const airSpeed = Math.hypot(host.args.xSpeed, host.args.ySpeed);
    host.args.airSpeed = airSpeed;
    if (!airSpeed) {
      return;
    }
    if (host.fallTime > 8 && (host.controllable || host.isVehicle)) {
      let spinBack = 20;
      if (host.springing) {
        spinBack = 125;
      }
      host.args.groundAngle += -Math.sign(host.args.groundAngle) * 0.001 * spinBack;
    }
    if (Math.abs(host.args.groundAngle) < 0.08) {
      host.args.groundAngle = 0;
    }
    if (host.noClip) {
      if (host.args.falling) {
        host.xLast = host.args.x;
        host.yLast = host.args.y;
        host.args.x += host.args.xSpeed;
        host.args.y += host.args.ySpeed;
      }
      return;
    }
    if (host.args.jumping && host.args.ySpeed < 0 && host.args.ySpeed > -4) {
      // host.args.xSpeed -= ((host.args.xSpeed / 0.125) / 256);
      host.args.xSpeed -= host.args.xSpeed * (host.args.decel * 0.078125);
    }
    const upMargin = (host.args.flying ? host.args.height + host.args.yMargin : host.args.height) || 1;
    host.upScan = true;
    const upScanDist = host.args.ySpeed < 0 ? -host.args.ySpeed + upMargin : 0;

    // window.logPoints = upScanDist && true;

    // if(host.viewport && host.viewport.args.debugEnabled)
    // {
    // 	window.logPoints = (x,y,label) => host.viewport.args.plot.addPoint(x,y,'up-l-scan '+label);
    // }

    const upDistanceL = host.castRayQuick(upScanDist, -Math.PI / 2, [host.args.width * -0.5 + 1, 0]);

    // if(host.viewport && host.viewport.args.debugEnabled)
    // {
    // 	window.logPoints = (x,y,label) => host.viewport.args.plot.addPoint(x,y,'up-r-scan '+label);
    // }

    const upDistanceR = host.castRayQuick(upScanDist, -Math.PI / 2, [host.args.width * 0.5 + -1, 0]);
    let upCollisionAngle = false;
    if (![upDistanceL, upDistanceR].some(x => x === false)) {
      upCollisionAngle = Math.atan2(upDistanceL - upDistanceR, host.args.width);
    }

    // if(host.viewport && host.viewport.args.debugEnabled)
    // {
    // 	window.logPoints = false;
    // }

    // if(upDistanceL !== upDistanceLQ || upDistanceR !== upDistanceRQ)
    // {
    // 	console.log(upDistanceL - upDistanceLQ, upDistanceR - upDistanceRQ);
    // 	console.log(321);
    // }

    const upDistance = upDistanceL || upDistanceR ? Math.min(...[upDistanceL, upDistanceR].filter(x => x !== false)) : false;
    host.upScan = false;
    let hits = [],
      distances = [];
    if (!host.args.hLock && !host.noClip) {
      const hScanDist = host.args.xSpeed;
      const rotScale = Math.abs(host.args.groundAngle) > Math.PI * 0.5 ? Math.cos(host.args.groundAngle) : 1;
      const foreDistanceHead = hScanDist ? this.scanForward(host, hScanDist, 0.9 * rotScale) : false;
      const foreDistanceWaist = hScanDist ? this.scanForward(host, hScanDist, 0.5 * rotScale) : false;
      const foreDistanceFoot = hScanDist ? this.scanForward(host, hScanDist, 0.1 * rotScale) : false;
      distances = [foreDistanceHead, foreDistanceWaist, foreDistanceFoot];

      // if(host.controllable && !host.args.falling && !host.args.rolling)
      // {
      // 	distances.push(foreDistanceFoot);
      // }

      hits = distances.filter(x => x !== false);
    }
    if (host.args.ySpeed && upDistance && host.lastLayer && host.lastLayer.offsetYChanged) {
      host.args.y += host.lastLayer.offsetYChanged + 1;
      host.args.ySpeed = host.lastLayer.offsetYChanged + 1;
      host.lastLayer = null;
      return;
    }
    const willStick = host.willStick || host.args.deepJump;
    // const xMove = host.xLast - host.args.x;

    if (upDistanceL && upDistanceR && upDistance <= upScanDist && (!host.args.flying || host.canStick)
    // && !host.args.flying
    && Math.abs(upCollisionAngle) < Math.PI / 4 && host.args.ySpeed <= 0) {
      host.args.y -= upDistance - host.args.height;
      if (host.args.ySpeed) {
        host.args.falling = true;
      }
      host.args.ySpeed = Math.max(0, host.args.ySpeed);
      return;
    }
    if (host.args.ySpeed >= 0 && distances[2] && distances[2] <= host.args.width * 0.5 && distances[1] === false && distances[0] === false) {
      const dir = Math.sign(xSpeedOriginal);
      if (!host.getMapSolidAt(host.args.x + host.args.width * 0.5 * dir, host.args.y + 4)) {
        host.args.x += dir * Math.abs(distances[2]);
        while (host.getMapSolidAt(host.args.x + host.args.width * 0.5 * dir, host.args.y)) {
          host.args.y--;
        }

        // host.args.falling = false;
        // host.args.gSpeed = host.args.xSpeed;
        return;
      }
    } else if (!host.willStick && (hits.length > 1 || distances[2])
    // && (upDistance === false || upDistance < (host.args.height + -host.args.ySpeed))
    ) {
      const xDirection = Math.sign(xSpeedOriginal);
      const minHit = -1 + Math.min(...hits);
      const width = host.args.width;
      const radius = 0.5 * width;
      // const shiftBy = width + -minHit;
      const shiftBy = radius + -minHit;
      const shift = shiftBy * -xDirection;

      // if(!isNaN(shift) && (!shift || Math.abs(shiftBy) < width || Math.sign(shift) !== Math.sign(host.args.xSpeed)))
      if (!isNaN(shift) && (!shift || Math.abs(shiftBy) < radius || Math.sign(shift) !== Math.sign(host.args.xSpeed))) {
        host.args.x += shift;
        host.args.flySpeed = 0;
        host.args.xSpeed = 0;
        host.args.gSpeed = 0;
        host.args.mode = MODE_FLOOR;
      }
      host.viewport && host.viewport.actorsAtPoint(host.x + (0 + radius) * xDirection, host.y, host.args.width, host.args.height).forEach(actor => {
        if (actor === host) {
          return;
        }
        actor.callCollideHandler(host, xDirection < 0 ? 1 : 3);
      });
    }

    // Object.assign(host.lastPointA, [host.args.x, host.args.y].map(Math.trunc));
    // Object.assign(host.lastPointB, [host.args.x, host.args.y].map(Math.trunc));

    const scanDist = airSpeed;
    const tiny = 1;
    let airMag = host.castRayQuick(scanDist, originalAngle);

    // if(host.viewport && host.viewport.args.debugEnabled)
    // {
    // 	window.logPoints = (x,y,label) => host.viewport.args.plot.addPoint(x,y,'main-scan '+label);
    // }

    if (Math.abs(host.args.xSpeed) <= Math.abs(host.args.ySpeed)) {
      airMag = airMag !== false ? airMag : host.castRayQuick(scanDist, originalAngle, [-tiny, 0]);
      airMag = airMag !== false ? airMag : host.castRayQuick(scanDist, originalAngle, [+tiny, 0]);
    }

    // if(airMag && Math.abs(host.args.xSpeed) < Math.abs(host.args.ySpeed))
    // {
    // 	airMag -= Math.abs(Math.sin(originalAngle));
    // }
    // else if(airMag && Math.abs(host.args.xSpeed) > Math.abs(host.args.ySpeed))
    // {
    // 	airMag -= Math.abs(Math.cos(originalAngle));
    // }

    const airPointQ = airMag !== false && [Math.cos(originalAngle) * airMag + host.args.x, Math.sin(originalAngle) * airMag + host.args.y];
    let airPointBQ = airPointQ;
    if (!host.rotateLock) {
      // if(host.viewport && host.viewport.args.debugEnabled)
      // {
      // 	window.logPoints = (x,y,label) => host.viewport.args.plot.addPoint(x,y,'alt-scan '+label);;
      // }

      const bOffset = -3 * Math.sign(host.args.ySpeed || 1);
      const airMag = host.castRayQuick(scanDist, originalAngle, [0, bOffset]);
      airPointBQ = airMag !== false ? [Math.cos(originalAngle) * airMag + host.args.x, Math.sin(originalAngle) * airMag + host.args.y + bOffset] : airPointBQ;
    }

    // if(host.viewport && host.viewport.args.debugEnabled)
    // {
    // 	window.logPoints = false;
    // }

    const airPoint = airPointQ;
    const airPointB = airPointBQ;
    host.willJump = false;
    let blockers = false;
    let collisionAngle = false;
    if (![airPoint, airPointB].some(x => x === false)) {
      collisionAngle = Math.atan2(airPoint[1] - airPointB[1], airPoint[0] - airPointB[0]);
    }
    if (host.xLast !== host.args.x) {
      host.xLast = host.args.x;
    }
    if (host.yLast !== host.args.y) {
      host.yLast = host.args.y;
    }
    if (airPoint !== false) {
      let angleIsWall = false;
      if (xSpeedOriginal < 0) {
        const angle = Math.abs(collisionAngle - Math.PI / 2) % Math.PI;
        angleIsWall = Math.abs(airPoint[1] - airPointB[1]) > 1 && airPoint[0] >= -1 + airPointB[0] && angle < Math.PI / 4;
      }
      if (xSpeedOriginal > 0) {
        const angle = Math.abs(collisionAngle - Math.PI / 2) % Math.PI;
        angleIsWall = Math.abs(airPoint[1] - airPointB[1]) > 1 && airPoint[0] <= +1 + airPointB[0] && angle < Math.PI / 4;
      }
      const isLeft = angleIsWall && xSpeedOriginal < 0;
      const isRight = angleIsWall && xSpeedOriginal > 0;
      const solid = this.checkBelow(host, airPoint[0], airPoint[1] + 1);
      if (!host.willStick && host.args.mode === 0 && !angleIsWall) {
        // host.args.gSpeed = xSpeedOriginal || host.args.gSpeed;
        host.args.gSpeed = host.args.xSpeed;
        if (solid && typeof solid === 'object') {
          if (solid.args && solid.args.treadmill) {
            host.args.gSpeed = 0;
          } else if (solid.offsetXChanged) {
            host.args.gSpeed -= solid.offsetXChanged;
          }
        }
      } else {
        airPoint[0] = Math.round(airPoint[0]);
        airPoint[1] = Math.round(airPoint[1]);
      }
      if (host.willStick) {
        airPoint[0] = Math.round(airPoint[0]);
        airPoint[1] = Math.round(airPoint[1]);
      }
      const stickX = airPoint[0];
      const stickY = airPoint[1];

      // let away = false;

      // if(!host.args.ySpeed || Math.sign(stickY - host.args.y) === Math.sign(host.args.ySpeed))
      // {
      // 	// host.args.xSpeed = 0;
      // 	// host.args.ySpeed = 0;

      // 	// if(host.args.flying && !angleIsWall && collisionAngle)
      // 	// {
      // 	// 	host.args.mode = MODE_CEILING;
      // 	// 	host.args.xSpeed *= -1;
      // 	// }
      // }
      // else
      // {
      // 	// host.args.y++;
      // 	away = true;
      // }

      // if(!host.viewport.tileMap.getSolid(stickX, stickY))
      // {
      // }

      if (host.removed) {
        return;
      }
      host.args.x = Math.round(stickX);
      host.args.y = Math.round(stickY);
      if (angleIsWall && !host.willStick) {
        host.args.x -= host.args.width * 0.5 * Math.sign(xSpeedOriginal);
        host.args.falling = true;
        if (hits.length > 2) {
          host.args.xSpeed = 0;
        }
      }
      blockers = host.getMapSolidAt(host.args.x + direction, host.args.y);
      if (Array.isArray(blockers)) {
        blockers = blockers.filter(a => a.callCollideHandler(host) !== false);
        if (!blockers.length) {
          blockers = false;
        }
      }
      if (!host.rotateLock) {
        if (upCollisionAngle !== false && upCollisionAngle < 0) {
          host.args.gSpeed = 0;
          host.args.mode = MODE_LEFT;
          host.args.groundAngle = 0;
          host.args.direction = 1;
          host.args.facing = 'right';
        } else if (upCollisionAngle !== false && upCollisionAngle > 0) {
          host.args.gSpeed = 0;
          host.args.mode = MODE_RIGHT;
          host.args.groundAngle = 0;
          host.args.direction = -1;
          host.args.facing = 'left';
        } else if ((host.willStick || !isLeft && !isRight) && !host.getMapSolidAt(host.args.x - direction, host.args.y) && !host.getMapSolidAt(host.args.x - direction, host.args.y + 1)) {
          if (isLeft) {
            host.args.gSpeed = 0;
            host.args.mode = MODE_LEFT;
            host.args.direction = 1;
            host.args.facing = 'right';
          } else if (isRight) {
            host.args.gSpeed = 0;
            host.args.mode = MODE_RIGHT;
            host.args.direction = -1;
            host.args.facing = 'left';
          } else if (upCollisionAngle !== false) {
            host.args.mode = MODE_CEILING;
          }
        }
      }

      // if(host.args.ySpeed < 0 && Math.abs(upCollisionAngle - Math.PI/2) < Math.PI/8)
      // {
      // 	return;
      // }

      const halfWidth = Math.floor(host.args.width / 2);
      const sensorSpread = 6;
      const backPosition = this.findNextStep(host, -sensorSpread * 0.5);
      const forePosition = this.findNextStep(host, sensorSpread * 0.5);
      const xSpeed = Math.trunc(host.args.xSpeed);
      if (xSpeed > 0 && forePosition && forePosition[3]) {
        if (!host.willStick) {
          host.args.x -= host.args.width;
        }
      } else if (xSpeed < 0 && backPosition && backPosition[3]) {
        if (!host.willStick) {
          host.args.x += host.args.width;
        }
      } else if (!forePosition || forePosition[0] !== false && forePosition[1] !== false || !backPosition || backPosition[0] !== false && backPosition[1] !== false) {
        let newAngle = 0;
        if (forePosition && backPosition) {
          var _forePosition$, _backPosition$, _forePosition$2, _backPosition$2;
          // newAngle = (ySpeedOriginal < 0 ? -1 : 1) * Number(Math.atan2(
          // 	(forePosition[1]??0) - (backPosition[1]??0)
          // 	, (forePosition[0]??0) - (backPosition[0]??0)
          // ));

          newAngle = ySpeedOriginal < 0 && upCollisionAngle ? -upCollisionAngle : Math.atan2(((_forePosition$ = forePosition[1]) !== null && _forePosition$ !== void 0 ? _forePosition$ : 0) - ((_backPosition$ = backPosition[1]) !== null && _backPosition$ !== void 0 ? _backPosition$ : 0), ((_forePosition$2 = forePosition[0]) !== null && _forePosition$2 !== void 0 ? _forePosition$2 : 0) - ((_backPosition$2 = backPosition[0]) !== null && _backPosition$2 !== void 0 ? _backPosition$2 : 0));
          if (Math.abs(newAngle) >= Math.PI * 0.25) {
            const backPositionWide = this.findNextStep(host, -sensorSpread);
            const forePositionWide = this.findNextStep(host, sensorSpread);
            if ((backPositionWide[1] === backPosition[1] || forePositionWide[1] === forePosition[1]) && !(forePosition[3] && forePositionWide[3] && backPosition[3] && backPositionWide[3])) {
              // console.log({forePosition, backPosition, forePositionWide, backPositionWide});
              newAngle = 0;
            } else {
              // console.log({forePosition, backPosition, forePositionWide, backPositionWide});
            }
          }
          if (host.ySpeedLast < 0) {
            newAngle *= -1;
          }
        }
        if (isNaN(newAngle)) {
          console.log(newAngle);
          throw new Error('angle is NAN!');
        }

        // const shallowLedgePoint = host.findNextStep(backPosition[1] < forePosition[1] ? 3 : -3);

        // let shallowLedge = false;

        // if(shallowLedgePoint[1] === Math.max(backPosition[1], forePosition[1]))
        // {
        // 	shallowLedge = true;
        // }

        // if(shallowLedge && Math.abs(forePosition[1] - backPosition[1]) > 2 * host.maxStep)
        // {
        // 	host.args.x += backPosition[1] < forePosition[1] ? -1 : 1;

        // 	host.args.ySpeed = ySpeedOriginal;

        // 	host.args.groundAngle = 0;
        // }
        // else
        if (angleIsWall && !host.willStick) {} else if (Math.abs(newAngle) < Math.PI / 2 + -Math.PI / 16 && forePosition && backPosition && forePosition[0] !== false && backPosition[0] !== false && forePosition[1] !== false && backPosition[1] !== false && !forePosition[2] && !backPosition[2] && !(forePosition[3] && backPosition[3])) {
          if (host.canRoll && (host.yAxis > 0.55 || host.args.dropDashCharge) && !host.carrying.size) {
            host.args.rolling = true;
          }
          if (host.args.startled < 175) {
            host.args.falling = false;
            if (host.viewport.settings.rumble && !host.controller.willRumble) {
              host.controller.rumble && host.controller.rumble({
                duration: 80,
                strongMagnitude: 0,
                weakMagnitude: Math.min(40, Math.max(Math.abs(host.args.ySpeed * 10), 10)) / 40
              });
            }
          }
          const qPi = Math.PI * 0.25;
          const landAngle = newAngle;
          if (newAngle < -qPi) {
            host.args.mode = MODE_LEFT;
            newAngle += qPi;
          } else if (newAngle > qPi) {
            host.args.mode = MODE_RIGHT;
            newAngle -= qPi;
          }
          host.args.groundAngle = newAngle;
          host.lastAngles.splice(0, host.lastAngles.length, ...Array(host.angleAvg).fill(newAngle));
          // host.args.ignore = host.args.ignore || 5;

          const slopeDir = -landAngle / (Math.PI * 0.4);
          let gSpeed = 0;
          gSpeed += xSpeedOriginal;
          gSpeed += ySpeedOriginal * slopeDir;
          if (blockers && blockers.length) {
            gSpeed = 0;
          }
          if (host.args.mode % 2 == 1) {
            // gSpeed *=-1;
          }

          // if(ySpeedOriginal)
          // {
          // 	gSpeed *= 0.75;
          // }

          if (typeof solid === 'object') {
            if (!Array.isArray(solid)) {
              host.args.standingLayer = solid;
            }
            if (solid.offsetXChanged) {
              gSpeed -= solid.offsetXChanged;
              host.args.x += solid.offsetXChanged;
            }
          }
          if (gSpeed && !host.args.climbing && (!host.args.standingOn || !host.args.standingOn.args.treadmill)) {
            host.args.gSpeed = gSpeed;
            if (host.args.mode === 2) {
              host.args.gSpeed *= -1;
            }
          }

          // host.args.x += gSpeed < 0 ? backPosition[0] : forePosition[0];
          // host.args.y += gSpeed < 0 ? backPosition[1] : forePosition[1];

          // host.args.xSpeed = 0;
          // host.args.ySpeed = 0;
        } else if (!host.args.dead && host.args.startled < 175 && host.args.ySpeed > 0 && (forePosition && forePosition[2] && (!backPosition || !backPosition[3]) || forePosition && !forePosition[3] && backPosition && backPosition[2])) {
          // const speed = xSpeedOriginal || host.xSpeedLast;
          const speed = xSpeedOriginal;
          host.args.falling = false;
          host.args.gSpeed = speed;

          // host.args.xSpeed = 0;
          // host.args.ySpeed = 0;

          host.args.float = host.args.float || 1;
          host.args.x += forePosition[0];
          host.args.y -= forePosition[1];
          if (host.viewport.settings.rumble && !host.controller.willRumble) {
            host.controller.rumble && host.controller.rumble({
              duration: 80,
              strongMagnitude: 0,
              weakMagnitude: Math.min(40, Math.max(Math.abs(host.args.ySpeed * 10), 10)) / 40
            });
          }
          return;
        }
        if (Math.abs(host.args.gSpeed) < 1) {
          // host.args.gSpeed = 0; //Math.sign(host.args.gSpeed);
        }
      }
    } else if (host.args.ySpeed > 0) {
      if (host.args.mode === MODE_LEFT || host.args.mode === MODE_RIGHT) {
        const direction = host.args.mode === MODE_LEFT ? -1 : 1;
        host.args.direction = direction;
        host.args.groundAngle = Math.PI / 2 * direction;
      }

      // host.args.mode = MODE_FLOOR;

      if (!host.args.falling && !host.args.gSpeed) {
        // host.args.gSpeed = Math.floor(xSpeedOriginal || host.xSpeedLast);
        host.args.gSpeed = Math.floor(xSpeedOriginal);
      }
      if (airPoint && (yPointDir === ySpeedDir || !yPointDir && ySpeedDir === 1)) {
        host.args.x = Number(airPoint[0]);
        host.args.y = Number(airPoint[1]);
        host.args.falling = false;
        if (host.viewport.settings.rumble) {
          host.controller.rumble && host.controller.rumble({
            duration: 80,
            strongMagnitude: 0,
            weakMagnitude: Math.min(40, Math.max(Math.abs(host.args.ySpeed * 10), 10)) / 40
          });
        }
      }
    }
    if (!tileMap.getSolid(host.args.x + host.args.width / 2 * Math.sign(host.args.xSpeed), host.args.y, host.getCollisionMap())) {
      if (Math.abs(host.args.xSpeed) > host.args.xSpeedMax) {
        host.args.xSpeed = host.args.xSpeedMax * Math.sign(host.args.xSpeed);
      }
      if (Math.abs(host.args.ySpeed) > host.args.ySpeedMax) {
        host.args.ySpeed = host.args.ySpeedMax * Math.sign(host.args.ySpeed);
      }
    }
    if (airPoint === false) {
      if (host.args.xSpeed) {
        const edgeTest = host.willStick ? false : host.getMapSolidAt(host.args.x + (1 + radius) * Math.sign(host.args.xSpeed), host.args.y - host.args.height / 2);
        const topTest = host.getMapSolidAt(host.args.x, host.args.y - host.args.height);
        if (!edgeTest) {
          host.args.x = Number(host.args.x) + Number(host.args.xSpeed);
        }
        if (topTest) {
          // host.args.ySpeed += topTest.yOffsetChanged;
          host.args.y += 1;
        }
      }
      if (host.args.ySpeed) {
        if (0) {
          host.args.y = Math.round(Number(host.args.y) + Number(host.args.ySpeed));
        } else {
          host.args.y = Number(host.args.y) + Number(host.args.ySpeed);
        }
        if (host.args.flying && host.args.ySpeed < 0 && upDistance > 0) {
          host.args.y += upMargin - upDistance + 4;
          host.args.ySpeed = 0;
        }
      }
    } else if (host.viewport && host.ySpeedLast > 0) {
      const collMap = host.getCollisionMap();
      if (host.viewport.tileMap.getSolid(host.args.x, host.args.y, collMap) && !host.viewport.tileMap.getSolid(host.args.x, host.args.y - 1, collMap)) {
        host.args.y--;
      }
    }
    if (host.args.standingOn instanceof _PointActor.PointActor) {
      const groundTop = host.args.standingOn.args.y + -host.args.standingOn.args.height + -1;
      if (host.args.y < groundTop || host.args.ySpeed < 0) {
        host.args.standingOn = null;
      }
    }
  }
  checkDropDash(host) {
    if (host.dropDashCharge && host.args.mode === MODE_FLOOR) {
      const dropBoost = host.dropDashCharge * Math.sign(host.args.direction);
      host.dropDashCharge = 0;
      host.viewport.onFrameOut(1, () => {
        host.args.gSpeed += dropBoost;
        host.args.rolling = true;
      });
      const viewport = host.viewport;
      const dustParticle = new _Tag.Tag('<div class = "particle-dust">');
      const dustPoint = host.rotatePoint(host.args.gSpeed, 0);
      dustParticle.style({
        '--x': dustPoint[0] + host.args.x,
        '--y': dustPoint[1] + host.args.y,
        'z-index': 0,
        opacity: Math.random() * 2
      });
      viewport.particles.add(dustParticle);
      setTimeout(() => {
        viewport.particles.remove(dustParticle);
      }, 350);
    }
  }
  findDownSolid(i, point, nearbyActors, actor) {
    if (!actor.viewport) {
      return;
    }
    const viewport = actor.viewport;
    const tileMap = viewport.tileMap;
    if (actor.args.mode === MODE_FLOOR && actor.args.groundAngle === 0 && (actor.controllable || actor.args.pushed || actor.isVehicle)) {
      const regions = actor.viewport.regionsAtPoint(point[0], point[1], nearbyActors);
      for (const region of regions) {
        if (-1 + point[1] === region.args.y + -region.args.height && Math.abs(actor.args.gSpeed) >= region.skimSpeed) {
          return -1 + i;
        }
      }
    }
    if (tileMap.getSolid(point[0], point[1], actor.getCollisionMap())) {
      return i;
    }
    const actors = viewport.actorsAtPoint(point[0], point[1], 0, 0, {
      nearbyActors
    }).filter(x => x.args !== actor.args && x.callCollideHandler(actor) && x.solid);
    if (actors.length > 0) {
      return i;
    }
  }
  findUpSpace(i, point, nearbyActors, actor) {
    if (!actor.viewport) {
      return;
    }
    const viewport = actor.viewport;
    const tileMap = viewport.tileMap;
    const pointSolid = tileMap.getSolid(point[0], point[1], actor.getCollisionMap());
    if (pointSolid) {
      return;
    }
    const actors = viewport.actorsAtPoint(point[0], point[1], 0, 0, {
      nearbyActors
    }).filter(x => x.args !== actor.args && x.callCollideHandler(actor) && x.solid);
    if (actor.args.groundAngle <= 0) {
      const regions = actor.controllable || actor.args.pushed || actor.isVehicle ? actor.viewport.regionsAtPoint(point[0], point[1], nearbyActors) : [];
      for (const region of regions) {
        if (actors.length === 0 && !pointSolid) {
          if (actor.args.mode !== MODE_FLOOR || point[1] !== 1 + region.args.y + -region.args.height || Math.abs(actor.args.gSpeed) <= region.skimSpeed) {
            return i;
          }
        }
      }
    }
    if (actors.length === 0) {
      if (!pointSolid) {
        return i;
      }
    }
  }
  findNextStep(host, offset) {
    if (!host.viewport) {
      return;
    }

    // if(host.stepCache[offset] !== undefined)
    // {
    // 	return host.stepCache[offset];
    // }

    const viewport = host.viewport;
    const tileMap = viewport.tileMap;
    const maxStep = host.maxStep * (host.args.falling ? 2 : 1);
    const radius = Math.max(host.args.width / 2, 1);
    const sign = Math.sign(offset);
    let downFirstSolid = false;
    let upFirstSpace = false;
    let prevUp = 0,
      prevDown = 0;
    let col = 0;
    for (; col < Math.abs(offset); col += 1) {
      downFirstSolid = false;
      upFirstSpace = false;
      let offsetPoint;
      const columnNumber = (1 + col) * sign;
      switch (host.args.mode) {
        case MODE_FLOOR:
          offsetPoint = [columnNumber, 1];
          break;
        case MODE_RIGHT:
          offsetPoint = [1, -columnNumber];
          break;
        case MODE_CEILING:
          offsetPoint = [-columnNumber, -1];
          break;
        case MODE_LEFT:
          offsetPoint = [-1, columnNumber];
          break;
      }
      downFirstSolid = host.castRay(maxStep // * (1+col)
      , host.downAngle, offsetPoint, this.findDownSolid);
      if (downFirstSolid === false) {
        return [false, false, true];
      }
      const downDiff = prevDown - downFirstSolid;
      if (Math.abs(downDiff) >= maxStep) {
        return [false, false, downDiff < 0, downDiff > 0];
      }
      if (downFirstSolid === 0) {
        let offsetPoint;
        switch (host.args.mode) {
          case MODE_FLOOR:
            offsetPoint = [columnNumber, 0];
            break;
          case MODE_RIGHT:
            offsetPoint = [0, -columnNumber];
            break;
          case MODE_CEILING:
            offsetPoint = [-columnNumber, 0];
            break;
          case MODE_LEFT:
            offsetPoint = [0, columnNumber];
            break;
        }
        const upLength = +1 + maxStep;

        // window.logPoints = (x,y,label) => host.viewport.args.plot.addPoint(x,y,'up-walk-space ' + label);

        upFirstSpace = host.castRay(upLength, host.upAngle, offsetPoint, this.findUpSpace);

        // window.logPoints = null;

        const upDiff = Math.abs(prevUp - upFirstSpace);
        if (upFirstSpace === false) {
          return [false, false, false, true];
        }
        if (upDiff >= maxStep) {
          return [false, false, false, true];
        }
        prevUp = upFirstSpace;
      } else {
        prevDown = downFirstSolid;
      }
      this.stepsTaken++;

      // if(upFirstSpace !== false)
      // {
      // 	host.stepCache[col * sign] = [col * sign, upFirstSpace, false];
      // }
      // else
      // {
      // 	host.stepCache[col * sign] = [col * sign, -downFirstSolid, false];
      // }
    }

    if (upFirstSpace !== false) {
      return [col * sign, upFirstSpace, false];
    }
    return [col * sign, -downFirstSolid, false];
  }

  // castRay(...args)
  // {
  // 	let length   = 1;
  // 	let callback = () => {};
  // 	let angle    = Math.PI / 2;
  // 	let offset   = [0,0];

  // 	switch(args.length)
  // 	{
  // 		case 2:
  // 			[length, callback] = args;
  // 			break;
  // 		case 3:
  // 			[length, angle, callback] = args;
  // 			break;
  // 		case 4:
  // 			[length, angle, offset, callback] = args;
  // 			break;
  // 	}

  // 	let hit = false;

  // 	for(let i = 0; i < Math.floor(length); i++)
  // 	{
  // 		const bottom  = [
  // 			host.args.x + offset[0] + (i * Math.cos(angle))
  // 			, host.args.y + offset[1] + (i * Math.sin(angle))
  // 		];

  // 		const retVal = callback(i, bottom, host);

  // 		if(retVal !== undefined)
  // 		{
  // 			return retVal;
  // 		}
  // 	}

  // 	return false;
  // }

  doJump(host, force) {
    var _host$args$gSpeed;
    if (host.args.climbing && host.getMapSolidAt(host.args.x, host.args.y - host.args.height)) {
      host.args.y += host.args.height;
    }
    if (host.args.ignore || host.args.falling || !host.args.landed || host.args.float) {
      return;
    }
    const jumpEvent = new CustomEvent('jump', {
      cancelable: true,
      detail: {
        host,
        force
      }
    });
    if (!host.dispatchEvent(jumpEvent)) {
      return;
    }
    if (host.args.standingOn && host.args.standingOn.args.yForce) {
      force += Math.max(0, host.args.standingOn.args.yForce * 0.25);
    } else if (host.args.standingOn && host.args.standingOn.yLast && host.args.standingOn.args.falling) {
      force += Math.max(0, host.args.standingOn.yLast - host.args.standingOn.args.y);
    }
    const radius = host.args.width / 2;
    const scanRadius = Math.min(radius, 4);
    const backPosition = this.findNextStep(host, -scanRadius);
    const forePosition = this.findNextStep(host, +scanRadius);
    const sensorSpread = scanRadius * 2;
    let groundAngle = Math.atan2(backPosition[1] - forePosition[1], Math.ceil(sensorSpread));

    // let groundAngle = host.args.angle;

    host.args.pushing = false;
    host.args.landed = false;
    host.args.falling = true;

    // host.args.ignore  = 6;

    const originalMode = host.args.mode;
    switch (host.args.mode) {
      case MODE_FLOOR:
        host.args.y -= 16;
        break;
      case MODE_RIGHT:
        groundAngle += -Math.PI / 2;
        host.args.x += -host.args.width / 2;
        break;
      case MODE_CEILING:
        groundAngle += Math.PI;
        host.args.y += host.args.normalHeight || host.args.height;
        break;
      case MODE_LEFT:
        groundAngle += Math.PI / 2;
        host.args.x += host.args.width / 2;
        break;
    }
    let floorX = 0;
    let gSpeedReal = (_host$args$gSpeed = host.args.gSpeed) !== null && _host$args$gSpeed !== void 0 ? _host$args$gSpeed : 0;
    if (host.args.standingOn && host.args.standingOn.args.convey) {
      gSpeedReal += host.args.standingOn.args.convey;
    }
    if (host.args.standingOn && host.args.standingOn.args.trackX) {
      floorX = host.args.standingOn.args.xSpeed || host.args.standingOn.args.gSpeed;
    }
    host.args.standingOn = null;
    host.args.xSpeed = gSpeedReal * Math.cos(groundAngle);
    host.args.ySpeed = gSpeedReal * Math.sin(groundAngle);
    const jumpAngle = groundAngle - Math.PI / 2;
    let xJump = force * Math.cos(jumpAngle);
    let yJump = force * Math.sin(jumpAngle);
    if (Math.abs(xJump) < 0.01) {
      xJump = 0;
    }
    if (Math.abs(yJump) < 0.01) {
      yJump = 0;
    }
    host.args.airAngle = jumpAngle;
    host.args.xSpeed += xJump;
    host.args.ySpeed += yJump;
    host.args.jumpedAt = host.args.y;
    host.args.jumping = true;
    const tileMap = host.viewport.tileMap;
    if (tileMap.getSolid(host.args.x + host.args.width / 2 * Math.sign(host.args.xSpeed), host.args.y, host.getCollisionMap())) {
      // if(tileMap.getSolid(host.x + (1 + host.args.width / 2) * Math.sign(host.args.xSpeed), host.y, host.args.layer))
      // {
      // 	host.args.x -= 2 * Math.sign(host.args.xSpeed);
      // }

      host.args.xSpeed = 0;
    }
    host.args.rolling = false;
    host.args.mode = MODE_FLOOR;
    host.args.groundAngle = 0;
    host.args.gSpeed = 0;
    host.args.xSpeed += floorX;
  }
  impulse(host, magnitude, direction) {
    let willFall = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    if (host.args.dead) {
      return;
    }
    host.impulseMag = magnitude;
    host.impulseDir = direction;
    host.impulseFal = willFall;
  }
  scanForward(host, speed) {
    let height = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.5;
    let scanActors = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
    const dir = Math.sign(speed);
    const radius = host.args.width / 2;
    const scanDist = Math.abs(speed);
    const startPoint = host.args.falling ? [0, -host.args.height * height] : host.rotatePoint(0, host.args.height * height);
    // ? [radius * -dir, -host.args.height * height]
    // : host.rotatePoint(radius * -dir, host.args.height * height);

    const angle = host.args.falling ? [Math.PI, 0, 0][dir + 1] : host.realAngle + [0, 0, Math.PI][dir + 1];
    return host.castRayQuick(host.args.falling
    // ? scanDist + host.args.width + 1
    ? scanDist + radius + 1 : scanDist + 1, angle, startPoint);
  }
  scanBottomEdge() {
    let direction = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    const tileMap = host.viewport.tileMap;
    const radius = host.args.width / 2;
    const collMap = host.getCollisionMap();
    const leftCorner = tileMap.getSolid(host.x - radius, host.y - 1, collMap);
    const rightCorner = tileMap.getSolid(host.x + radius, host.y - 1, collMap);
    if (leftCorner && rightCorner) {
      return;
    }
    return host.castRay(host.args.width, direction < 0 ? Math.PI : 0, [-direction * radius, 0], (i, point) => {
      const actors = host.viewport.actorsAtPoint(point[0], point[1]).filter(a => a.args !== host.args);
      if (!actors.length && !tileMap.getSolid(point[0], point[1] + 1, collMap)) {
        return i;
      }
    });
  }
  checkBelow(host) {
    var _testX, _testY;
    let testX = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    let testY = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    testX = (_testX = testX) !== null && _testX !== void 0 ? _testX : host.args.x;
    testY = (_testY = testY) !== null && _testY !== void 0 ? _testY : host.args.y;
    const lPoint = [];
    const rPoint = [];
    const spread = 0;
    switch (host.args.mode) {
      case MODE_FLOOR:
        lPoint[0] = testX + spread;
        lPoint[1] = testY + 1;
        rPoint[0] = testX - spread;
        rPoint[1] = testY + 1;
        break;
      case MODE_LEFT:
        lPoint[0] = testX - 1;
        lPoint[1] = testY + spread;
        rPoint[0] = testX - 1;
        rPoint[1] = testY - spread;
        break;
      case MODE_CEILING:
        lPoint[0] = testX - spread;
        lPoint[1] = testY - 1;
        rPoint[0] = testX + spread;
        rPoint[1] = testY - 1;
        break;
      case MODE_RIGHT:
        lPoint[0] = testX + 1;
        lPoint[1] = testY + spread;
        rPoint[0] = testX + 1;
        rPoint[1] = testY - spread;
        break;
    }
    let below = host.getMapSolidAt(...lPoint);

    // if(!below)
    // {
    // 	below = this.getMapSolidAt(...rPoint);
    // }

    if (Array.isArray(below)) {
      below = below.filter(x => x.callCollideHandler(host) !== false);
    }
    return below;
  }
  onSpawned(host, viewport) {
    if (!host.args.onLayer) {
      return;
    }
    const layerName = host.args.onLayer;
    const layers = viewport.tileMap.tileLayers;
    for (const layer of layers) {
      if (layer.name !== layerName) {
        continue;
      }
      host.args.standingLayer = layer;
      break;
    }
  }
  command_0(host, button)
  // jump
  {
    if (host.args.hangingFrom && host.args.hangingFrom.unhook) {
      const drag = host.getLocalDrag();
      host.args.ySpeed = -host.args.jumpForce * drag * 0.75;
      host.args.hangingFrom.unhook(host);
      host.swing = false;
      return;
    }
    if (host.args.falling || host.willJump || host.args.dontJump) {
      if (host.args.standingOn && !host.args.standingOn.isVehicle) {
        if (host.args.ignore && host.args.ignore !== -4) {
          return;
        }
        host.viewport.auras.delete(host.args.standingOn);
        host.willJump = true;
        return;
      }
    }
    if (!host.willJump) {
      if (host.args.standingOn && host.args.standingOn.quickDrop) {
        host.ignores.set(host.args.standingOn, 15);
        host.args.ignore = 0;
      }
      host.willJump = true;
    }
  }
  release_0(host, button) {
    if (host.args.float || host.args.ignore) {
      return;
    }
    if (host.args.jumping && !host.lightDashed && !host.dashed) {
      if (host.args.ySpeed < 0) {
        host.args.ySpeed *= 0.5;
      }
      return;
    }
    if (host.args.jumping && !host.lightDashed && !host.dashed && host.args.ySpeed < -4) {
      host.args.ySpeed = -4;
      // host.args.ySpeed *= 0.5;
    }
  }

  command_1(host, button) {
    if (host.canRoll && host.args.gSpeed) {
      host.args.rolling = true;
    }
  }
  command_11(host, button) {
    if (host.args.currentSheild && !(host.args.currentSheild instanceof _StarSheild.StarSheild)) {
      const item = host.args.currentSheild;
      item.unequip && item.unequip(host);
      host.args.currentSheild = null;
    }
  }
}
exports.Platformer = Platformer;
});

;require.register("behavior/SkidDust.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SkidDust = void 0;
var _Tag = require("curvature/base/Tag");
var _Behavior = require("./Behavior");
class SkidDust extends _Behavior.Behavior {
  constructor(dustType) {
    super();
    this.dustType = dustType || 'particle-dust';
  }
  update(host) {
    if (host.args.falling || host.args.rolling || host.args.sliding || host.spindashCharge) {
      return;
    }
    if (host.args.wallSticking || host.args.climbing) {
      return;
    }
    const direction = host.args.direction;
    if (!Math.sign(host.args.gSpeed) || !Math.sign(direction)) {
      return;
    }
    if (Math.abs(host.args.gSpeed - direction) < 5) {
      return;
    }
    if (!host.alwaysSkidding) {
      if (Math.sign(host.args.gSpeed) === Math.sign(direction)) {
        return;
      }
      if (!host.skidding) {
        return;
      }
    }
    if (host.silentSkid) {
      return;
    }
    const viewport = host.viewport;
    const dustFreq = host.dustFreq || 3;
    if (viewport.args.frameId % dustFreq !== 0) {
      return;
    }
    const dustParticle = new _Tag.Tag(document.createElement('div'));
    dustParticle.classList.add(this.dustType);
    const dustDist = Math.sign(host.args.gSpeed) * host.dustDist || 0;

    // const dustPoint = host.rotatePoint(host.args.gSpeed, 0);
    const dustPoint = host.groundPoint;
    dustParticle.style({
      '--x': dustPoint[0] + dustDist,
      '--y': dustPoint[1],
      'z-index': 0,
      opacity: Math.random() * 0.25 + 0.5
    });
    viewport.particles.add(dustParticle);
    viewport.onFrameOut(20, () => {
      viewport.particles.remove(dustParticle);
    });
  }
}
exports.SkidDust = SkidDust;
});

;require.register("behavior/Spindash.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Spindash = void 0;
var _Tag = require("curvature/base/Tag");
var _Behavior = require("./Behavior");
class Spindash extends _Behavior.Behavior {
  command_0(host, button) {
    if (host.args.falling || host.args.gSpeed) {
      return;
    }
    if (host.yAxis < 0.55 && !host.args.gSpeed || host.groundTime < 5) {
      return;
    }
    host.spindashCharge += 10;
    this.showDashDust(host);
    return false;
  }
  update(host) {
    host.spindashCharge = host.spindashCharge || 0;
    if (host.spindashCharge) {
      if (host.spindashCharge < 1) {
        host.spindashCharge = 0;
      } else {
        host.args.animation = 'spindash';
        // host.args.animation = 'rolling';

        host.spindashCharge -= 0.2;
        if (this.dashDust) {
          this.dashDust.style({
            '--dashCharge': host.spindashCharge
          });
        }
        let dashCharge = host.spindashCharge / 20;
        if (dashCharge > 1) {
          dashCharge = 1;
        }

        // this.twist(120 * dashCharge * this.args.direction);
      }
    }

    if (!host.yAxis && host.spindashCharge) {
      if (host.spindashCharge < 5 && (host.args.modeTime < 45 || host.args.skidding)) {
        host.spindashCharge = 15;
      }
      const direction = host.args.facing === 'left' ? -1 : 1;
      let dashPower = host.spindashCharge / 40;
      if (dashPower > 1) {
        dashPower = 1;
      }
      host.args.rolling = true;
      const dashBoost = dashPower * 32;
      host.castRayQuick(dashBoost * Math.sign(direction), [Math.PI, 0, 0][1 + Math.sign(direction)], [0, host.args.height / 2]);
      if (Math.sign(direction) !== Math.sign(host.args.gSpeed)) {
        host.args.gSpeed = dashBoost * Math.sign(direction);
      } else {
        host.args.gSpeed += dashBoost * Math.sign(direction);
      }
      host.args.ignore = 1;
      host.args.rolling = true;
      host.spindashCharge = 0;
      if (this.dashDust) {
        this.dashDust.remove();
        this.dashDust = false;
      }
    }
  }
  showDashDust(host) {
    const dustPoint = host.rotatePoint(0, 0);
    if (this.dashDust) {
      this.dashDust.style({
        '--x': dustPoint[0] + host.args.x,
        '--y': dustPoint[1] + host.args.y,
        '--direction': host.args.direction,
        '--dashCharge': host.spindashCharge
      });
      return;
    }
    const viewport = host.viewport;
    const dustParticle = new _Tag.Tag('<div class = "particle-spindash-dust">');
    dustParticle.style({
      '--x': dustPoint[0] + host.args.x,
      '--y': dustPoint[1] + host.args.y,
      '--direction': host.args.direction,
      '--dashCharge': host.spindashCharge
    });
    dustParticle.setAttribute('data-facing', host.args.facing);
    viewport.particles.add(dustParticle);
    this.dashDust = dustParticle;
  }
}
exports.Spindash = Spindash;
});

;require.register("behavior/SuperForm.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SuperForm = void 0;
var _Tag = require("curvature/base/Tag");
var _Behavior = require("./Behavior");
class SuperForm extends _Behavior.Behavior {
  command_3(host, button) {
    var _host$args$minRingsSu, _host$args$minRingsHy;
    if (host.args.halted) {
      return;
    }
    const minRingsSuper = (_host$args$minRingsSu = host.args.minRingsSuper) !== null && _host$args$minRingsSu !== void 0 ? _host$args$minRingsSu : 50;
    const minRingsHyper = (_host$args$minRingsHy = host.args.minRingsHyper) !== null && _host$args$minRingsHy !== void 0 ? _host$args$minRingsHy : 75;
    if (host.isSuper && !host.isHyper && host.args.rings < minRingsHyper || !host.args.falling || !host.args.jumping || host.args.rings < minRingsSuper || host.args.ignore || host.isHyper) {
      host.isSuper = false;
      host.isHyper = false;
      host.setProfile();
      return;
    }
    if (!host.isHyper) {
      host.args.halted = 45;
      host.args.animation = 'transform';
      host.args.jumping = false;
      host.args.ySpeed = Math.min(host.args.ySpeed, 0);
      host.args.flying = false;
      host.args.dashed = false;
    }
    if (host.isSuper) {
      host.isHyper = !host.isHyper;
    } else {
      host.isSuper = !host.isSuper;
    }
    host.transformTime = 0;
    host.setProfile();
  }
  updateEnd(host) {
    if (host.args.animation === 'transform') {
      host.transformTime++;
    } else if (host.transformTime > 0) {
      host.transformTime = 0;
    }
  }
}
exports.SuperForm = SuperForm;
});

;require.register("cards/basic-controls.html", function(exports, require, module) {
module.exports = "<div class = \"control-card\">\n\t<span class = \"button-index\">\n\t\t<span class = \"arrow button arrow-west\"></span>\n\t\t/ <span class = \"arrow button arrow-east\"></span>\n\t\t/ <b>wasd</b>\n\t</span>\n\n\t<span class = \"button-index\">\n\t\t<span class = \"button ps ps-x\"></span>\n\t\t<span class = \"button xb xb-a\"></span>\n\t\t<b>space</b>\n\t</span>\n\n\t<span class = \"button-index\">\n\t\t<span class = \"button ps ps-o\"></span>\n\t\t<span class = \"button xb xb-b\"></span>\n\t\t<b>ctrl</b>\n\t</span>\n\n\t<span class = \"button-index\">\n\t\t<span class = \"button ps ps-s\"></span>\n\t\t<span class = \"button xb xb-x\"></span>\n\t\t<b>shift</b>\n\t</span>\n\n\t<span class = \"button-index\">\n\t\t<span class = \"button ps ps-t\"></span>\n\t\t<span class = \"button xb xb-y\"></span>\n\t\t<b>z</b>\n\t</span>\n\n\t<span class = \"button-index\">\n\t\t<span class = \"button ps ps-l1\"></span>\n\t\t<span class = \"button xb xb-lb\"></span>\n\t\t<b>q</b>\n\t</span>\n\n\t<span class = \"button-index\">\n\t\t<span class = \"button ps ps-r1\"></span>\n\t\t<span class = \"button xb xb-rb\"></span>\n\t\t<b>e</b>\n\t</span>\n</div>\n"
});

;require.register("cards/basic-moves.html", function(exports, require, module) {
module.exports = "<p><b>jump</b> + <b>jump</b> - fly / double jump action</p>\n\n<p><span class = \"arrow-button arrow-north\"></span> + <b>jump</b> - disengage vehicle</p>\n\n<!-- <p><span class = \"arrow-button arrow-south\"></span> + <b>jump</b> - spindash</p> -->\n"
});

;require.register("cards/plane-air-controls.html", function(exports, require, module) {
module.exports = "<div class = \"control-card\">\n\t<span class = \"button-index\">\n\t\t<span class = \"arrow button arrow-west\"></span>\n\t\t/ <span class = \"arrow button arrow-east\"></span>\n\t\t/ <b>wasd</b>\n\t\t- move\n\t</span>\n\n\t<span class = \"button-index\">\n\t\t<span class = \"button ps ps-x\"></span>\n\t\t<span class = \"button xb xb-a\"></span>\n\t\t<b>space</b>\n\t\t- double barrier\n\t</span>\n\n\t<span class = \"button-index\">\n\t\t<span class = \"button ps ps-o\"></span>\n\t\t<span class = \"button xb xb-b\"></span>\n\t\t<b>ctrl</b>\n\t\t- <span>no action</span>\n\t</span>\n\n\t<span class = \"button-index\">\n\t\t<span class = \"button ps ps-s\"></span>\n\t\t<span class = \"button xb xb-x\"></span>\n\t\t<b>shift</b>\n\t\t- <span>light dash</span>\n\t</span>\n\n\t<span class = \"button-index\">\n\t\t<span class = \"button ps ps-t\"></span>\n\t\t<span class = \"button xb xb-y\"></span>\n\t\t<b>z</b>\n\t\t- <span>no action</span>\n\t</span>\n\n\t<span class = \"button-index\">\n\t\t<span class = \"button ps ps-l1\"></span>\n\t\t<span class = \"button xb xb-lb\"></span>\n\t\t<b>q</b>\n\t\t- <span>air dash left</span>\n\t</span>\n\n\t<span class = \"button-index\">\n\t\t<span class = \"button ps ps-r1\"></span>\n\t\t<span class = \"button xb xb-rb\"></span>\n\t\t<b>e</b>\n\t\t- <span>air dash right</span>\n\t</span>\n\n</div>\n"
});

;require.register("cards/sonic-air-controls.html", function(exports, require, module) {
module.exports = "<div class = \"control-card\">\n\t<span class = \"button-index\">\n\t\t<span class = \"arrow button arrow-west\"></span>\n\t\t/ <span class = \"arrow button arrow-east\"></span>\n\t\t/ <b>wasd</b>\n\t\t- move\n\t</span>\n\n\t<span class = \"button-index\">\n\t\t<span class = \"button ps ps-x\"></span>\n\t\t<span class = \"button xb xb-a\"></span>\n\t\t<b>space</b>\n\t\t- double barrier\n\t</span>\n\n\t<span class = \"button-index\">\n\t\t<span class = \"button ps ps-o\"></span>\n\t\t<span class = \"button xb xb-b\"></span>\n\t\t<b>ctrl</b>\n\t\t- <span>no action</span>\n\t</span>\n\n\t<span class = \"button-index\">\n\t\t<span class = \"button ps ps-s\"></span>\n\t\t<span class = \"button xb xb-x\"></span>\n\t\t<b>shift</b>\n\t\t- <span>light dash</span>\n\t</span>\n\n\t<span class = \"button-index\">\n\t\t<span class = \"button ps ps-t\"></span>\n\t\t<span class = \"button xb xb-y\"></span>\n\t\t<b>z</b>\n\t\t- <span>no action</span>\n\t</span>\n\n\t<span class = \"button-index\">\n\t\t<span class = \"button ps ps-l1\"></span>\n\t\t<span class = \"button xb xb-lb\"></span>\n\t\t<b>q</b>\n\t\t- <span>air dash left</span>\n\t</span>\n\n\t<span class = \"button-index\">\n\t\t<span class = \"button ps ps-r1\"></span>\n\t\t<span class = \"button xb xb-rb\"></span>\n\t\t<b>e</b>\n\t\t- <span>air dash right</span>\n\t</span>\n\n</div>\n"
});

;require.register("cards/sonic-controls.html", function(exports, require, module) {
module.exports = "<div class = \"control-card\">\n\n\t<span class = \"button-index\">\n\t\t<span class = \"arrow button arrow-west\"></span>\n\t\t/ <span class = \"arrow button arrow-east\"></span>\n\t\t/ <b>wasd</b>\n\t\t- move\n\t</span>\n\n\t<span class = \"button-index\">\n\t\t<span class = \"button ps ps-x\"></span>\n\t\t<span class = \"button xb xb-a\"></span>\n\t\t<b>space</b>\n\t\t- jump\n\t</span>\n\n\t<span class = \"button-index\">\n\t\t<span class = \"button ps ps-o\"></span>\n\t\t<span class = \"button xb xb-b\"></span>\n\t\t<b>ctrl</b>\n\t\t- <span>spindash</span>\n\t</span>\n\n\t<span class = \"button-index\">\n\t\t<span class = \"button ps ps-s\"></span>\n\t\t<span class = \"button xb xb-x\"></span>\n\t\t<b>z</b>\n\t\t- <span>no action</span>\n\t</span>\n\n\t<span class = \"button-index\">\n\t\t<span class = \"button ps ps-t\"></span>\n\t\t<span class = \"button xb xb-y\"></span>\n\t\t<b>x</b>\n\t\t- <span>super</span>\n\t</span>\n\n\t<span class = \"button-index\">\n\t\t<span class = \"button ps ps-l1\"></span>\n\t\t<span class = \"button xb xb-lb\"></span>\n\t\t<b>q</b>\n\t\t- <span>no action</span>\n\t</span>\n\n\t<span class = \"button-index\">\n\t\t<span class = \"button ps ps-r1\"></span>\n\t\t<span class = \"button xb xb-rb\"></span>\n\t\t<b>e</b>\n\t\t- <span>no action</span>\n\t</span>\n\n</div>\n"
});

;require.register("console/task/Chao.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Chao = void 0;
var _Router = require("curvature/base/Router");
var _Task = require("subspace-console/Task");
var _Chao = require("../../actor/Chao");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class Chao extends _Task.Task {
  init() {
    let command = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'list';
    if (typeof this['command_' + command] === 'function') {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      this['command_' + command](...args);
    }
  }
  command_list() {
    if (!Chao.viewport) {
      return;
    }
    const actors = Chao.viewport.actors;
    for (const actor of actors.items()) {
      if (!(actor instanceof _Chao.Chao)) {
        continue;
      }
      this.print(`${Number(actor.args.id)}) Chao "${actor.args.name}" is at ${actor.x}, ${actor.y}.`);
    }
  }
  command_name(id, name) {
    if (!Chao.viewport) {
      return;
    }
    const chao = Chao.viewport.actorsById[id];
    if (!(chao instanceof _Chao.Chao)) {
      return;
    }
    chao.args.name = name;
  }
  command_color(id) {
    if (!Chao.viewport) {
      return;
    }
    const chao = Chao.viewport.actorsById[id];
    if (!(chao instanceof _Chao.Chao)) {
      return;
    }
    for (var _len2 = arguments.length, pairs = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      pairs[_key2 - 1] = arguments[_key2];
    }
    this.recolor(chao, ...pairs);
  }
  recolor(chao) {
    for (var _len3 = arguments.length, pairs = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
      pairs[_key3 - 1] = arguments[_key3];
    }
    while (pairs.length) {
      const colorId = pairs.shift();
      const color = pairs.shift();
      chao.customColors[colorId] = color;
    }
  }
  command_store(id) {
    if (!Chao.viewport) {
      return;
    }
    const chao = Chao.viewport.actorsById[id];
    if (!(chao instanceof _Chao.Chao)) {
      return;
    }
    this.print(JSON.stringify(chao.store()));
  }
}
exports.Chao = Chao;
_defineProperty(Chao, "viewport", null);
_defineProperty(Chao, "helpText", 'List the chao in the current map.');
});

;require.register("console/task/Impulse.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Impulse = void 0;
var _Task = require("subspace-console/Task");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class Impulse extends _Task.Task {
  constructor() {
    super(...arguments);
    _defineProperty(this, "title", 'Impulse task');
    _defineProperty(this, "prompt", '..');
  }
  init(magnitude, angle) {
    if (!Impulse.viewport.controlActor) {
      return;
    }

    // this.print(`Pressing button ${buttonId} for ${ms} milliseconds...`);
    let actor = Impulse.viewport.controlActor;
    if (actor.standingOn && actor.standingOn.isVehicle) {
      actor = actor.standingOn;
    }
    actor.impulse(magnitude, angle, true);
  }
  write(line) {
    this.print(line);
  }
}
exports.Impulse = Impulse;
_defineProperty(Impulse, "viewport", null);
_defineProperty(Impulse, "helpText", 'Apply an impulse to the player object.');
_defineProperty(Impulse, "useText", 'input magnitude angle');
});

;require.register("console/task/Input.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Input = void 0;
var _Task = require("subspace-console/Task");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class Input extends _Task.Task {
  constructor() {
    super(...arguments);
    _defineProperty(this, "title", 'Input task');
    _defineProperty(this, "prompt", '..');
  }
  init(inputId) {
    let ms = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 500;
    let magnitude = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    let frame,
      intervalId,
      onDone = () => {};
    if (!Input.viewport.controlActor) {
      return;
    }
    const actor = Input.viewport.controlActor;
    const controller = actor.controller;
    if (inputId[0] === 'a') {
      const axisId = inputId.substring(1);
      this.print(`Setting axis ${axisId} to ${magnitude} for ${ms} milliseconds...`);
      frame = {
        axes: {
          [axisId]: magnitude
        }
      };
      intervalId = setInterval(() => {
        controller.replay(frame);
        actor.readInput();
      }, 16);
      onDone = () => {
        frame.axes[axisId] = 0;
        controller.replay(frame);
        actor.readInput();
        clearInterval(intervalId);
      };
    }
    if (inputId[0] === 'b') {
      const buttonId = inputId.substring(1);
      this.print(`Pressing button ${buttonId} for ${ms} milliseconds...`);
      frame = {
        buttons: {
          [buttonId]: 1
        }
      };
      intervalId = setInterval(() => {
        frame.buttons[buttonId] = 1;
        controller.replay(frame);
        actor.readInput();
      }, 16);
      onDone = () => {
        frame.buttons[buttonId] = 0;
        controller.replay(frame);
        actor.readInput();
        clearInterval(intervalId);
      };
    }
    if (!frame) {
      return;
    }
    controller.replay(frame);
    actor.readInput();
    return new Promise(accept => {
      setTimeout(() => {
        onDone();
        accept();
      }, ms);
    });
  }
  write(line) {
    this.print(line);
  }
}
exports.Input = Input;
_defineProperty(Input, "viewport", null);
_defineProperty(Input, "helpText", 'Press a button x for y milliseconds.');
_defineProperty(Input, "useText", 'input x y');
});

;require.register("console/task/Mark.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Mark = void 0;
var _Router = require("curvature/base/Router");
var _Task = require("subspace-console/Task");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class Mark extends _Task.Task {
  init(x, y) {
    if (!Mark.viewport.controlActor) {
      return;
    }
    const actor = Mark.viewport.controlActor;
    this.print(`Character is at ${actor.x}, ${actor.y}.`);
    _Router.Router.setQuery('map', Mark.viewport.baseMap.replace(/^\/map\//, ''));
    _Router.Router.setQuery('start', `${Math.round(actor.x)},${Math.round(actor.y)}`);
  }
}
exports.Mark = Mark;
_defineProperty(Mark, "viewport", null);
_defineProperty(Mark, "helpText", 'Mark the current actor\'s position in space as a start position.');
});

;require.register("console/task/Move.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Move = void 0;
var _Task = require("subspace-console/Task");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class Move extends _Task.Task {
  constructor() {
    super(...arguments);
    _defineProperty(this, "prompt", '..');
  }
  init(x, y) {
    if (!Move.viewport.controlActor) {
      return;
    }
    this.print(`Moving character to x, y...`);
    const actor = Move.viewport.controlActor;
    actor.args.x = parseFloat(x);
    actor.args.y = parseFloat(y);
    if (actor.viewport) {
      actor.viewport.setColCell(actor);
    }
  }
}
exports.Move = Move;
_defineProperty(Move, "viewport", null);
_defineProperty(Move, "helpText", 'Move the current actor to a position in space.');
_defineProperty(Move, "useText", 'move x y');
});

;require.register("console/task/Pos.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Pos = void 0;
var _Task = require("subspace-console/Task");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class Pos extends _Task.Task {
  init(x, y) {
    if (!Pos.viewport.controlActor) {
      return;
    }
    const actor = Pos.viewport.controlActor;
    this.print(`Character is at ${actor.x}, ${actor.y}.`);
  }
}
exports.Pos = Pos;
_defineProperty(Pos, "viewport", null);
_defineProperty(Pos, "helpText", 'Check the current actor\'s position in space.');
});

;require.register("console/task/Settings.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Settings = void 0;
var _Task = require("subspace-console/Task");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class Settings extends _Task.Task {
  constructor() {
    super(...arguments);
    _defineProperty(this, "prompt", '..');
  }
  init(key, val) {
    const viewport = Settings.viewport;
    if (val !== undefined) {
      viewport.settings[key] = JSON.parse(val);
    }
    this.print(JSON.stringify(viewport.settings[key]));
  }
}
exports.Settings = Settings;
_defineProperty(Settings, "viewport", null);
_defineProperty(Settings, "helpText", 'Get/set the values of settings variables.');
_defineProperty(Settings, "useText", 'set key val');
});

;require.register("console/task/Spawn.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Spawn = void 0;
var _Task = require("subspace-console/Task");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class Spawn extends _Task.Task {
  init(typeName) {
    if (!Spawn.viewport || !Spawn.viewport.controlActor) {
      return;
    }
    const palette = Spawn.viewport.objectPalette;
    const actor = Spawn.viewport.controlActor;
    if (!typeName) {
      this.print(Object.keys(palette).join(', '));
      return;
    }
    if (!(typeName in palette)) {
      this.print(`Type not found: "${typeName}".`);
      return;
    }
    const type = palette[typeName];
    const mouse = Spawn.viewport.mouse.position;
    Spawn.viewport.spawn.add({
      object: new type({
        x: mouse[0],
        y: mouse[1]
      })
    });
  }
}
exports.Spawn = Spawn;
_defineProperty(Spawn, "viewport", null);
_defineProperty(Spawn, "helpText", 'Spawn an object.');
});

;require.register("controller/Axis.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Axis = void 0;
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class Axis {
  constructor(_ref) {
    let {
      deadZone = 0,
      proportional = true
    } = _ref;
    _defineProperty(this, "magnitude", 0);
    _defineProperty(this, "delta", 0);
    if (deadZone) {
      this.proportional = proportional;
      this.deadZone = deadZone;
    }
  }
  tilt(magnitude) {
    if (this.deadZone && Math.abs(magnitude) >= this.deadZone) {
      magnitude = (Math.abs(magnitude) - this.deadZone) / (1 - this.deadZone) * Math.sign(magnitude);
    } else {
      magnitude = 0;
    }
    this.delta = Number(magnitude - this.magnitude).toFixed(3) - 0;
    this.magnitude = Number(magnitude).toFixed(3) - 0;
  }
  zero() {
    this.magnitude = this.delta = 0;
  }
}
exports.Axis = Axis;
});

;require.register("controller/Button.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Button = void 0;
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class Button {
  constructor() {
    _defineProperty(this, "active", false);
    _defineProperty(this, "pressure", 0);
    _defineProperty(this, "delta", 0);
    _defineProperty(this, "time", 0);
  }
  update() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    if (this.pressure) {
      this.time++;
    } else if (!this.pressure && this.time > 0) {
      this.time = -1;
    } else if (!this.pressure && this.time < 0) {
      this.time--;
    }
    if (this.time < -1 && this.delta === -1) {
      this.delta = 0;
    }
  }
  press(pressure) {
    this.delta = Number(pressure - this.pressure).toFixed(3) - 0;
    this.pressure = Number(pressure).toFixed(3) - 0;
    this.active = true;
    this.time = this.time > 0 ? this.time : 0;
  }
  release() {
    // if(!this.active)
    // {
    // 	return;
    // }

    this.delta = Number(-this.pressure).toFixed(3) - 0;
    this.pressure = 0;
    this.active = false;
  }
  zero() {
    this.pressure = this.delta = 0;
    this.active = false;
  }
}
exports.Button = Button;
});

;require.register("controller/Controller.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Controller = void 0;
var _Axis = require("./Axis");
var _Button = require("./Button");
const keys = {
  'Space': 0,
  'Enter': 0,
  'NumpadEnter': 0,
  'ControlLeft': 1,
  'ControlRight': 1,
  'ShiftLeft': 2,
  'ShiftRight': 2,
  'KeyZ': 3,
  'KeyQ': 4,
  'KeyE': 5,
  'Digit1': 6,
  'Digit3': 7,
  'KeyBackspace': 8,
  'KeyW': 12,
  'KeyA': 14,
  'KeyS': 13,
  'KeyD': 15,
  'KeyH': 112,
  'KeyJ': 113,
  'KeyK': 114,
  'KeyL': 115,
  'KeyP': 1020,
  'KeyO': 1209,
  'Pause': 1020,
  'Tab': 11,
  'ArrowUp': 12,
  'ArrowDown': 13,
  'ArrowLeft': 14,
  'ArrowRight': 15,
  'KeyMeta': 16,
  'Numpad4': 112,
  'Numpad2': 113,
  'Numpad8': 114,
  'Numpad6': 115,
  'Backquote': 1010,
  'NumpadAdd': 1011,
  'NumpadSubtract': 1012,
  'NumpadMultiply': 1013,
  'NumpadDivide': 1014,
  'PageUp': 1022,
  'PageDown': 1023,
  'Home': 1024,
  'End': 1025,
  'Escape': [1020, 1050],
  'KeyB': 1201
};
[...Array(12)].map((x, fn) => keys[`F${fn}`] = 2000 + fn);
const axisMap = {
  12: -1,
  13: +1,
  14: -0,
  15: +0,
  112: -2,
  113: +3,
  114: -3,
  115: +2
};
const buttonMap = {
  '-6': 14,
  '+6': 15,
  '-7': 12,
  '+7': 13
};
const buttonRemap = {
  0: 1200,
  1: 1201,
  9: 1209,
  4: 1022,
  5: 1023
};
class Controller {
  constructor(_ref) {
    let {
      keys = {},
      deadZone = 0,
      gamepad = null,
      keyboard = null
    } = _ref;
    this.deadZone = deadZone;
    Object.defineProperties(this, {
      buttons: {
        value: {}
      },
      pressure: {
        value: {}
      },
      axes: {
        value: {}
      },
      keys: {
        value: {}
      }
    });
  }
  update() {
    let {
      gamepad
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    for (const i in this.buttons) {
      const button = this.buttons[i];
      button.update();
    }
    if (gamepad && this.willRumble) {
      // let vibeFactor = 1;

      if (typeof this.willRumble !== 'object') {
        this.willRumble = {
          duration: 1000,
          strongMagnitude: 1.0,
          weakMagnitude: 1.0
        };
      }
      if (gamepad.id && String(gamepad.id).match(/playstation.{0,5}3/i)) {
        if (this.willRumble.duration < 100 && this.willRumble.strongMagnitude < 0.75) {
          this.willRumble.duration = 0;
          this.willRumble.weakMagnitude = 0;
          this.willRumble.strongMagnitude = 0;
        }
        const stopVibing = () => {
          if (this.willRumble) {
            return;
          }
          gamepad.vibrationActuator.playEffect("dual-rumble", {
            duration: 0,
            weakMagnitude: 0,
            strongMagnitude: 0
          });
        };
        setTimeout(stopVibing, this.willRumble.duration + -1);
      }

      // console.log({...this.willRumble, id: gamepad.id});

      if (gamepad.vibrationActuator && gamepad.vibrationActuator.playEffect) {
        gamepad.vibrationActuator.playEffect("dual-rumble", this.willRumble);
      }
      this.willRumble = false;
    }
  }
  rumble() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
    this.willRumble = options;
  }
  readInput(_ref2) {
    let {
      keyboard,
      gamepads = []
    } = _ref2;
    const tilted = {};
    const pressed = {};
    const released = {};
    const tookInput = new Set();
    for (let i = 0; i < gamepads.length; i++) {
      const gamepad = gamepads[i];
      if (!gamepad) {
        continue;
      }
      for (const i in gamepad.buttons) {
        const button = gamepad.buttons[i];
        if (button.pressed) {
          this.press(i, button.value);
          pressed[i] = true;
          tookInput.add(gamepad);
        }
      }
    }
    if (keyboard) {
      for (const i in [...Array(10)]) {
        if (pressed[i]) {
          continue;
        }
        if (keyboard.getKeyCode(i) > 0) {
          this.press(i, 1);
          pressed[i] = true;
          tookInput.add(keyboard);
        }
      }
      for (let keycode in keys) {
        if (pressed[keycode]) {
          continue;
        }
        let buttonIds = keys[keycode];
        if (!Array.isArray(buttonIds)) {
          buttonIds = keys[keycode] = [buttonIds];
        }
        for (const buttonId of buttonIds) {
          if (keyboard.getKeyCode(keycode) > 0) {
            this.press(buttonId, 1);
            pressed[buttonId] = true;
          }
        }
      }
    }
    for (const gamepad of gamepads) {
      if (!gamepad) {
        continue;
      }
      for (const i in gamepad.buttons) {
        if (released[i]) {
          continue;
        }
        if (pressed[i]) {
          continue;
        }
        const button = gamepad.buttons[i];
        if (this.buttons[i] && !button.pressed && this.buttons[i].active) {
          this.release(i);
          released[i] = true;
        }
      }
    }
    if (keyboard) {
      for (const i in [...Array(10)]) {
        if (released[i]) {
          continue;
        }
        if (pressed[i]) {
          continue;
        }
        if (keyboard.getKeyCode(i) < 0) {
          this.release(i);
          released[i] = true;
        }
      }
      for (let keycode in keys) {
        let buttonIds = keys[keycode];
        if (!Array.isArray(buttonIds)) {
          buttonIds = keys[keycode] = [buttonIds];
        }
        for (const buttonId of buttonIds) {
          if (released[buttonId]) {
            continue;
          }
          if (pressed[buttonId]) {
            continue;
          }
          if (keyboard.getKeyCode(keycode) < 0) {
            this.release(buttonId);
            released[keycode] = true;
          }
        }
      }
    }
    for (let i = 0; i < gamepads.length; i++) {
      const gamepad = gamepads[i];
      if (!gamepad) {
        continue;
      }
      for (const i in gamepad.axes) {
        const axis = gamepad.axes[i];
        if (Math.abs(axis) < this.deadZone) {
          if (!tilted[i]) {
            this.tilt(i, 0);
          }
          continue;
        }
        tilted[i] = true;
        this.tilt(i, axis);
      }
    }
    for (let inputId in axisMap) {
      if (!this.buttons[inputId]) {
        this.buttons[inputId] = new _Button.Button();
      }
      const axis = axisMap[inputId];
      const value = Math.sign(1 / axis);
      const axisId = Math.abs(axis);
      if (tilted[axisId]) {
        continue;
      }
      if (this.buttons[inputId].active) {
        tilted[axisId] = true;
        this.tilt(axisId, value);
      } else if (!tilted[axisId]) {
        this.tilt(axisId, 0);
      }
    }
    for (let axisMove in buttonMap) {
      const buttonId = buttonMap[axisMove];
      if (released[buttonId]) {
        continue;
      }
      if (pressed[buttonId]) {
        continue;
      }
      const [move, axisId] = [axisMove.slice(0, 1), axisMove.slice(1)];
      if (!this.axes[axisId]) {
        this.axes[axisId] = new _Axis.Axis({
          deadZone: this.deadZone
        });
      }
      const axis = this.axes[axisId];
      if (axis.magnitude && Math.sign(axisMove) !== Math.sign(axis.magnitude)) {
        continue;
      }
      const pressure = Math.abs(axis.magnitude);
      if (pressure) {
        this.press(buttonId, pressure);
        pressed[buttonId] = true;
      } else {
        this.release(buttonId, pressure);
        released[buttonId] = true;
      }
    }
    for (const concreteId in buttonRemap) {
      const abstractId = buttonRemap[concreteId];
      if (released[abstractId]) {
        continue;
      }
      if (pressed[abstractId]) {
        continue;
      }
      if (!this.buttons[abstractId]) {
        this.buttons[abstractId] = new _Button.Button();
      }
      if (!this.buttons[concreteId]) {
        this.buttons[concreteId] = new _Button.Button();
      }
      if (this.buttons[concreteId].active) {
        this.press(abstractId, this.buttons[concreteId].pressure);
        pressed[abstractId] = true;
      } else if (!pressed[abstractId]) {
        this.release(abstractId, this.buttons[concreteId].pressure);
        released[abstractId] = true;
      }
    }
    return tookInput;
  }
  tilt(axisId, magnitude) {
    if (!this.axes[axisId]) {
      this.axes[axisId] = new _Axis.Axis({
        deadZone: this.deadZone
      });
    }
    this.axes[axisId].tilt(magnitude);
  }
  press(buttonId) {
    let pressure = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    if (!this.buttons[buttonId]) {
      this.buttons[buttonId] = new _Button.Button();
    }
    this.buttons[buttonId].press(pressure);
  }
  release(buttonId) {
    if (!this.buttons[buttonId]) {
      this.buttons[buttonId] = new _Button.Button();
    }
    this.buttons[buttonId].release();
  }
  serialize() {
    const buttons = {};
    for (const i in this.buttons) {
      buttons[i] = this.buttons[i].pressure;
    }
    const axes = {};
    for (const i in this.axes) {
      axes[i] = this.axes[i].magnitude;
    }
    return {
      axes,
      buttons
    };
  }
  replay(input) {
    if (input.buttons) {
      for (const i in input.buttons) {
        if (input.buttons[i] > 0) {
          this.press(i, input.buttons[i]);
        } else {
          this.release(i);
        }
      }
    }
    if (input.axes) {
      for (const i in input.axes) {
        if (input.axes[i].magnitude !== input.axes[i]) {
          this.tilt(i, input.axes[i]);
        }
      }
    }
  }
  zero() {
    for (const i in this.axes) {
      this.axes[i].zero();
    }
    for (const i in this.buttons) {
      this.buttons[i].zero();
    }
  }
  buttonIsMapped(buttonId) {
    return buttonId in buttonRemap;
  }
  keyIsMapped(keyCode) {
    return keyCode in keys;
  }
}
exports.Controller = Controller;
});

;require.register("controller/GamepadConfig.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GamepadConfig = void 0;
var _View = require("curvature/base/View");
var _SkippableCard = require("../intro/SkippableCard");
var _KbInput = require("./KbInput");
class GamepadConfig extends _SkippableCard.SkippableCard {
  constructor(args, parent) {
    super(args, parent);
    this.template = require('./gamepad-config.html');
    this.args.cardName = 'gamepad-config-card';
    this.args.moves = {};
    this.args.char = this.args.char || 'Sonic';
    switch (args.char) {
      case 'Sonic':
        this.args.moves = {
          start: 'Pause',
          dpad: 'Move',
          a: 'Jump',
          b: 'Spindash / Roll / Dropdash',
          x: 'Light Dash / Interact',
          y: 'Super Transform',
          l1: 'Air Dash',
          r1: 'Air Dash',
          la: 'Move',
          ra: 'Switch Sheilds'
        };
        break;
      case 'Tails':
        this.args.moves = {
          start: 'Pause',
          dpad: 'Move',
          a: 'Jump',
          aa: 'Fly',
          ad: 'Use Shield / Spindash',
          d: 'Dive',
          x: 'Interact',
          y: 'Super Transform'
          // , l1:   'Air Dash'
          // , r1:   'Air Dash'
          ,
          la: 'Move',
          ra: 'Switch Sheilds'
        };
        break;
      case 'Knuckles':
        this.args.moves = {
          start: 'Pause',
          dpad: 'Move',
          a: 'Jump',
          aa: 'Fly',
          b: 'Punch / Drop off wall',
          ad: 'Use Shield / Spindash',
          d: 'Dive'
          // , x:    'Interact'
          ,
          y: 'Super Transform'
          // , l1:   'Air Dash'
          // , r1:   'Air Dash'
          ,
          la: 'Move',
          ra: 'Switch Sheilds'
        };
        break;
    }

    // this.gamepads = {
    // 	xb: View.from(require('./xbox360-input.svg'), this.args.moves)
    // 	, dc: View.from(require('./dc-input.svg'), this.args.moves)
    // 	, gc: View.from(require('./gc-input.svg'), this.args.moves)
    // 	, ps: View.from(require('./ps3-input.svg'), this.args.moves)
    // };

    // this.gamepads = {kb: new KbInput(this.args.moves) }

    if (this.args.inputType === 'input-xbox') {
      this.gamepads = {
        xb: _View.View.from(require('./xbox360-input.svg'), this.args.moves)
      };
      this.args.type = 'xb';
    } else if (this.args.inputType === 'input-playstation') {
      this.gamepads = {
        ps: _View.View.from(require('./ps3-input.svg'), this.args.moves)
      };
      this.args.type = 'ps';
    } else if (this.args.inputType === 'input-dreamcast') {
      this.gamepads = {
        ps: _View.View.from(require('./dc-input.svg'), this.args.moves)
      };
      this.args.type = 'dc';
    } else if (this.args.inputType === 'input-gamecube') {
      this.gamepads = {
        ps: _View.View.from(require('./gc-input.svg'), this.args.moves)
      };
      this.args.type = 'gc';
    } else {
      this.gamepads = {
        kb: new _KbInput.KbInput({
          char: this.args.char,
          moves: this.args.moves
        })
      };
    }
    this.current = 0;
    this.buttons = [];
    this.sticks = {};
  }
  onAttached() {
    this.span = this.findTag('div');
    this.args.text = Object.values(this.gamepads)[this.current];
    this.args.type = this.args.type || Object.keys(this.gamepads)[this.current];
  }
  swap() {
    this.current++;
    const list = Object.values(this.gamepads);
    const type = Object.keys(this.gamepads);
    if (this.current >= list.length) {
      this.current = 0;
    }
    this.args.text = list[this.current];
    this.args.type = type[this.current];
  }
  exit() {
    this.remove();
  }
  input(controller) {
    super.input(controller);
    if (!this.span) {
      return;
    }
    let x = 0,
      y = 0,
      a = 0,
      b = 0;
    if (controller.axes[0]) {
      x = controller.axes[0].magnitude;
    }
    if (controller.axes[1]) {
      y = controller.axes[1].magnitude;
    }
    if (controller.axes[2]) {
      a = controller.axes[2].magnitude;
    }
    if (controller.axes[3]) {
      b = controller.axes[3].magnitude;
    }
    this.span.style({
      '--x': x,
      '--y': y,
      '--a': a,
      '--b': b
    });
    for (const b in controller.buttons) {
      if (controller.buttons[b]) {
        this.span.style({
          [`--pressed-${b}`]: controller.buttons[b].pressure
        });
      } else {
        this.span.style({
          [`--pressed-${b}`]: 0
        });
      }
    }
  }
  play(event) {
    // this.onTimeout(50, () => this.args.animation = 'opened');

    // const waitFor = this.args.waitFor || Promise.resolve();

    // return new Promise(accept => {
    // 	waitFor.then(() => {
    // 		const timeAcc = this.args.timeout;

    // 		if(timeAcc > 0)
    // 		{
    // 			this.onTimeout(timeAcc-500, () => this.args.animation = 'closing');
    // 			this.onTimeout(timeAcc, () => {
    // 				this.args.animation = 'closed';
    // 				const done = new Promise(acceptDone => this.onTimeout(timeAcc, acceptDone));
    // 				accept(this.accept([done]));
    // 			});
    // 		}
    // 	});
    // });
  }
}
exports.GamepadConfig = GamepadConfig;
});

;require.register("controller/KbInput.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KbInput = void 0;
var _View = require("curvature/base/View");
var _CharacterString = require("../ui/CharacterString");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class KbInput extends _View.View {
  constructor(args, parent) {
    super(args, parent);
    _defineProperty(this, "template", require('./kb-input.html'));
    switch (this.args.char) {
      case 'Sonic':
        this.args.lines = [new _CharacterString.CharacterString({
          font: this.font,
          value: `⬲ ✚ ${this.args.moves.dpad}`
        }), new _CharacterString.CharacterString({
          font: this.font,
          value: `⬚ ⓿ ${this.args.moves.a}`
        }), new _CharacterString.CharacterString({
          font: this.font,
          value: `⬚ ❶ ${this.args.moves.b}`
        }), new _CharacterString.CharacterString({
          font: this.font,
          value: `⬚ ❷ ${this.args.moves.x}`
        }), new _CharacterString.CharacterString({
          font: this.font,
          value: `⬚ ❸ ${this.args.moves.y}`
        }), new _CharacterString.CharacterString({
          font: this.font,
          value: `❹ ❺ ${this.args.moves.r1}`
        }), new _CharacterString.CharacterString({
          font: this.font,
          value: `⬚ ▦ ${this.args.moves.ra}`
        }), new _CharacterString.CharacterString({
          font: this.font,
          value: `⬚ ❾ ${this.args.moves.start}`
        })];
        break;
      case 'Tails':
        this.args.lines = [new _CharacterString.CharacterString({
          font: this.font,
          value: `⬲ ✚ ${this.args.moves.dpad}`
        }), new _CharacterString.CharacterString({
          font: this.font,
          value: `⬚ ⓿ ${this.args.moves.a}`
        }), new _CharacterString.CharacterString({
          font: this.font,
          value: `⓿ ⓿ ${this.args.moves.aa}`
        }), new _CharacterString.CharacterString({
          font: this.font,
          value: `↓ ⓿ ${this.args.moves.ad}`
        }), new _CharacterString.CharacterString({
          font: this.font,
          value: `↓ ⬚ ${this.args.moves.d}`
        })
        // , new CharacterString({font: this.font, value: `⬚ ❶ ${this.args.moves.b}`})
        , new _CharacterString.CharacterString({
          font: this.font,
          value: `⬚ ❷ ${this.args.moves.x}`
        }), new _CharacterString.CharacterString({
          font: this.font,
          value: `⬚ ❸ ${this.args.moves.y}`
        })
        // , new CharacterString({font: this.font, value: `❹ ❺ ${this.args.moves.r1}`})
        // , new CharacterString({font: this.font, value: `⬚ ▦ ${this.args.moves.ra}`})
        , new _CharacterString.CharacterString({
          font: this.font,
          value: `⬚ ❾ ${this.args.moves.start}`
        })];
        break;
      case 'Knuckles':
        this.args.lines = [new _CharacterString.CharacterString({
          font: this.font,
          value: `⬲ ✚ ${this.args.moves.dpad}`
        }), new _CharacterString.CharacterString({
          font: this.font,
          value: `⬚ ⓿ ${this.args.moves.a}`
        }), new _CharacterString.CharacterString({
          font: this.font,
          value: `⬚ ❶ ${this.args.moves.b}`
        }), new _CharacterString.CharacterString({
          font: this.font,
          value: `⓿ ⓿ ${this.args.moves.aa}`
        }), new _CharacterString.CharacterString({
          font: this.font,
          value: `↓ ⓿ ${this.args.moves.ad}`
        }), new _CharacterString.CharacterString({
          font: this.font,
          value: `↓ ⬚ ${this.args.moves.d}`
        })
        // , new CharacterString({font: this.font, value: `⬚ ❷ ${this.args.moves.x}`})
        , new _CharacterString.CharacterString({
          font: this.font,
          value: `⬚ ❸ ${this.args.moves.y}`
        })
        // , new CharacterString({font: this.font, value: `❹ ❺ ${this.args.moves.r1}`})
        // , new CharacterString({font: this.font, value: `⬚ ▦ ${this.args.moves.ra}`})
        , new _CharacterString.CharacterString({
          font: this.font,
          value: `⬚ ❾ ${this.args.moves.start}`
        })];
        break;
    }
  }
}
exports.KbInput = KbInput;
});

;require.register("controller/dc-input.svg", function(exports, require, module) {
module.exports = "<svg version=\"1.0\" viewBox=\"0 0 512 288\" xmlns=\"http://www.w3.org/2000/svg\">\n <defs>\n  <clipPath id=\"a\">\n   <ellipse cx=\"296.69\" cy=\"214.12\" rx=\"206.77\" ry=\"205.42\" display=\"none\" fill=\"#4d4d4d\"/>\n   <path class=\"powerclip\" d=\"m8.0946 3.7805h575.41v590.04h-575.41zm495.36 210.34a206.77 205.42 0 0 0-206.77-205.42 206.77 205.42 0 0 0-206.77 205.42 206.77 205.42 0 0 0 206.77 205.42 206.77 205.42 0 0 0 206.77-205.42z\" display=\"block\" fill=\"#4d4d4d\"/>\n  </clipPath>\n </defs>\n <g transform=\"translate(-260.34 -473.69)\">\n  <path d=\"m437.18 546.97c0.0704-0.35215 1.3382-5.8456 1.479-6.7612 0.14086-0.91559 0.35215-1.4086 1.479-2.1833 10.576-7.2713 5.4994-7.4732 17.763-5.4952 2.1833 0.35214 5.0005 5.8456 5.0005 5.8456z\" fill=\"#d8d8d8\" fill-rule=\"evenodd\" stroke=\"#000\" stroke-width=\".96695\" data-button=\"button-6\"/>\n  <path d=\"m595.5 546.97c-0.0704-0.35215-1.3382-5.8456-1.479-6.7612-0.14086-0.91559-0.35215-1.4086-1.479-2.1833-10.576-7.2713-5.4994-7.4732-17.763-5.4952-2.1833 0.35214-5.0005 5.8456-5.0005 5.8456z\" fill=\"#d8d8d8\" fill-rule=\"evenodd\" stroke=\"#000\" stroke-width=\".96695\" data-button=\"button-7\"/>\n  <path d=\"m604.24 553.13c-0.0704-0.35215-1.3382-5.8456-1.479-6.7612-0.14086-0.91559-0.35215-1.4086-1.479-2.1833-10.576-7.2713-22.951-10.782-35.215-8.8037-2.1833 0.35214-5.0005 5.8456-5.0005 5.8456z\" fill=\"#d8d8d8\" fill-rule=\"evenodd\" stroke=\"#000\" stroke-width=\".96695\" data-button=\"button-5\"/>\n  <path d=\"m428.44 553.13c0.0704-0.35215 1.3382-5.8456 1.479-6.7612 0.14086-0.91559 0.35215-1.4086 1.479-2.1833 10.576-7.2713 22.951-10.782 35.215-8.8037 2.1833 0.35214 5.0005 5.8456 5.0005 5.8456z\" fill=\"#d8d8d8\" fill-rule=\"evenodd\" stroke=\"#000\" stroke-width=\".96695\" data-button=\"button-4\"/>\n  <g transform=\"matrix(.34401 0 0 .34401 414.97 503.95)\">\n   <ellipse cx=\"294.98\" cy=\"208.06\" rx=\"205.59\" ry=\"199.11\" fill=\"none\" stroke=\"#000\" stroke-width=\"7.4\"/>\n   <ellipse cx=\"295.57\" cy=\"214.12\" rx=\"206.77\" ry=\"205.42\" display=\"block\" fill=\"#e6e6e6\"/>\n   <rect x=\"255.55\" y=\"18.994\" width=\"93.05\" height=\"71.373\" fill=\"#d35f5f\" stroke-width=\".67124\"/>\n   <rect x=\"234.74\" y=\"140.67\" width=\"129.82\" height=\"113.54\" fill=\"#666\"/>\n   <g transform=\"translate(-1.12)\" fill=\"#1a1a1a\">\n    <g>\n     <path d=\"m243.78 111.34c0.838 0 1.818-0.043 2.687-0.135s1.481-0.397 2.167-0.636 1.377-0.643 2.02-1.261c0.637-0.618 1.157-1.316 1.548-2.099 0.392-0.784 0.673-1.659 0.845-2.632 0.171-0.967 0.239-1.952 0.196-2.95-0.042-1.12-0.343-1.953-0.648-2.907-0.306-0.955-0.881-2.154-1.671-2.803-0.869-0.716-1.493-1.224-2.387-1.481-0.894-0.251-2.154-0.637-3.599-0.637-0.881 0-2.05 0.062-2.62 0.128-0.593 0.074-1.138 0.147-1.885 0.159l0.196 17.228c1.162 0.038 2.154 0.026 3.151 0.026z\" fill=\"#1a1a1a\"/>\n     <path d=\"m278.33 102.96c-0.031-0.624 0-0.416-0.073-0.765-0.074-0.343-0.166-0.618-0.349-0.991-0.184-0.367-0.502-0.624-0.795-0.894-0.294-0.27-0.643-0.478-1.053-0.618-0.404-0.147-1.01-0.22-1.475-0.22-0.501 0-0.948 0.153-1.395 0.312s-0.838 0.374-1.175 0.649c-0.336 0.275-0.618 0.6-0.844 0.967-0.227 0.367-0.392 0.729-0.496 1.071-0.042 0.135-0.049 0.147-0.042 0.153 6e-3 6e-3 0.03-0.012-0.025 0.336z\" fill=\"#1a1a1a\"/>\n     <path d=\"m291.54 104.42c-0.3 0.27-0.441 0.343-0.587 0.453-0.147 0.11-0.361 0.171-0.551 0.269-0.19 0.092-0.447 0.116-0.68 0.202-0.226 0.085-1.022 0.11-1.346 0.153-0.691 0.086-1.15 0.159-1.426 0.27-0.6 0.214-0.955 0.275-1.298 0.496-0.342 0.22-0.612 0.551-0.838 0.808-0.227 0.257-0.312 0.49-0.404 0.747-0.104 0.318-0.092 0.655-0.073 0.998 0.018 0.538 0.434 1.132 0.734 1.523 0.293 0.398 0.3 0.257 0.679 0.526 0.379 0.263 0.918 0.404 1.518 0.404 0.374 0 0.759-0.031 1.157-0.092 0.306-0.043 0.637-0.239 1.096-0.392 0.146-0.049 0.489-0.361 0.655-0.422 0 0 0.422-0.342 0.844-1.077 0.422-0.734 0.508-1.952 0.508-1.952z\" fill=\"#1a1a1a\"/>\n     <path d=\"m341.81 104.23c-0.294 0.27-0.44 0.349-0.588 0.459-0.146 0.11-0.379 0.153-0.569 0.251-0.189 0.092-0.428 0.135-0.66 0.22-0.227 0.086-1.022 0.11-1.347 0.153-0.691 0.085-1.15 0.159-1.426 0.269-0.6 0.22-0.961 0.282-1.304 0.496-0.343 0.221-0.618 0.551-0.845 0.808s-0.318 0.489-0.404 0.747c-0.104 0.318-0.085 0.655-0.073 1.003 0.019 0.533 0.435 1.132 0.734 1.524 0.3 0.398 0.3 0.257 0.686 0.526 0.38 0.263 0.918 0.404 1.524 0.404 0.373 0 0.759-0.03 1.162-0.092 0.307-0.042 0.643-0.245 1.096-0.392 0.146-0.049 0.489-0.361 0.655-0.422 0 0 0.422-0.343 0.844-1.077 0.423-0.729 0.509-1.953 0.509-1.953z\" fill=\"#1a1a1a\"/>\n     <path d=\"m79.619 239.47c24.811 0 44.995-20.073 44.995-44.748s-20.184-44.748-44.995-44.748-44.997 20.073-44.997 44.748 20.192 44.748 44.997 44.748z\" fill=\"#ececec\"/>\n     <polygon transform=\"matrix(1.6291,0,0,1.6291,-178.01,-257.79)\" points=\"318.12 444.41 293.78 403.06 269.44 444.41\" fill=\"#fff\" stroke-width=\".61384\"/>\n     <path d=\"m119.14 577.38c12.815-43.023 10.985-43.023 17.393-58.582 6.408-15.562 19.223-16.475 35.698-20.135 15.404-3.42 80.508-11.378 123.02-12.431 6e-3 0.117 0 0 0 0l11.652-0.15207-0.013-0.092s75.652 4.8914 112.49 12.675c16.476 3.66 29.291 4.578 35.698 20.135 6.407 15.564 4.578 15.564 17.394 58.582 12.814 43.018 69.554-66.818 95.184-228.83 25.631-162.01-11.848-224.91-22.222-230.4-10.373-5.49-79.382-20.404-79.382-20.404-18.269-23.911-37.871-41.377-57.039-54.199v181.14c0 53.85-43.807 97.657-97.656 97.657h-21.524c-53.85 0-97.657-43.808-97.657-97.657v-187.17c-22.156 13.194-45.296 32.319-66.624 60.232 0 0-69.009 14.908-79.382 20.404-10.374 5.49-47.853 68.385-22.222 230.4 25.624 162.01 82.375 271.85 95.19 228.83zm373.77-258.73c-13.801 0-25.031-11.223-25.031-25.024s11.23-25.031 25.031-25.031c13.8 0 25.024 11.224 25.024 25.031 1e-3 13.802-11.224 25.024-25.024 25.024zm48.207-96.432c13.801 0 25.03 11.224 25.03 25.031 0 13.801-11.229 25.025-25.03 25.025s-25.031-11.224-25.031-25.025 11.23-25.031 25.031-25.031zm-47.601-46.989c13.801 0 25.031 11.224 25.031 25.031 0 13.8-11.23 25.024-25.031 25.024s-25.03-11.224-25.03-25.024c5e-3 -13.801 11.229-25.031 25.03-25.031zm-48.207 46.383c13.801 0 25.024 11.224 25.024 25.031 0 13.801-11.224 25.025-25.024 25.025s-25.031-11.224-25.031-25.025c6e-3 -13.807 11.236-25.031 25.031-25.031zm-176.43 232.05 28.458-48.342c1.408-2.418 5.056-2.441 6.5-6e-3l28.451 48.342c0.729 1.242 0.759 2.662 0.099 3.818-0.655 1.15-1.91 1.842-3.33 1.842h-56.928c-1.426 0-2.674-0.691-3.335-1.842-0.668-1.156-0.631-2.582 0.085-3.812zm-136.01-171.33c2.699 0 4.896 2.191 4.896 4.89v26.23h26.23c2.693 0 4.89 2.191 4.89 4.891v23.801c0 2.697-2.191 4.889-4.89 4.889h-26.23v26.23c0 2.693-2.191 4.891-4.896 4.891h-23.801c-2.692 0-4.89-2.191-4.89-4.891v-26.23h-26.23c-2.693 0-4.89-2.191-4.89-4.889v-23.801c0-2.693 2.191-4.891 4.89-4.891h26.23v-26.23c0-2.699 2.191-4.89 4.89-4.89zm-54.009-133.64c24.902 0 45.166 20.263 45.166 45.166s-20.263 45.166-45.166 45.166-45.166-20.263-45.166-45.166 20.264-45.166 45.166-45.166z\" clip-path=\"url(#b)\" fill=\"#e6e6e6\"/>\n     <path d=\"m371.79 133.6h-142.4v126.1h142.4zm-8.256 117.31c0 0.985-0.796 1.781-1.781 1.781h-122.33c-0.979 0-1.781-0.796-1.781-1.781v-108.51c0-0.985 0.795-1.781 1.781-1.781h122.33c0.985 0 1.781 0.795 1.781 1.781z\" fill=\"#1a1a1a\"/>\n     <path d=\"m289.82 316.22h21.523c50.558 0 91.537-40.985 91.537-91.536v-6.089l0.0627-180.67c-46.252-27.867-85.605-28.475-100.38-29.284-3.6348-0.19916-6.7928-0.03767-6.7928-0.03767s-2.9265-0.19568-6.6277-0.015294c-13.717 0.66851-50.54 2.3407-91.789 25.089l0.93221 184.88v6.12c0 50.552 40.986 91.537 91.537 91.537zm66.506-218.18 1.806-0.061c0.018-0.379-0.031-1.567-0.031-2.497 0-0.453-0.227-0.869-0.41-1.096 0.82-0.184 2.069-0.563 2.638-0.728-6e-3 1.469 0.099 3.556 0.117 4.321l3.684 0.055c-0.019 0.63 0.049 0.851 0.062 1.419l-1.016-0.122h-2.705l-0.05 8.103-0.024 0.679c0.024 0.723 0.123 1.641 0.282 2.001 0.159 0.361 0.385 0.496 0.679 0.655 0.3 0.159 0.637 0.196 0.949 0.196 0.22 0 0.551-6e-3 0.808-6e-3s0.435-0.019 1.071-0.202c-0.08 0.478-0.209 0.741-0.294 1.536-0.588 0.166-0.857 0.208-1.206 0.245-0.349 0.043-0.679-0.067-0.997-0.067-0.777 0-1.414-0.11-1.903-0.337-0.49-0.22-0.869-0.575-1.139-1.071-0.275-0.49-0.465-1.708-0.496-2.552-6e-3 -0.11-6e-3 -0.3-0.012-0.575 0-0.275-0.019-0.551 0-2.197l-0.056-6.402h-1.774c0.023-0.397 0.023-0.519 0.017-1.297zm-2.932 9.309c-0.135-0.184-0.643-0.618-0.899-0.838-0.257-0.227-0.937-0.557-1.824-0.924-0.899-0.379-2.044-0.74-2.46-1.089-0.416-0.355-1.175-0.759-1.475-1.132s-0.526-0.74-0.68-1.12c-0.153-0.374-0.043-0.943-0.055-1.328-0.024-0.618 0.36-1.254 0.728-1.836 0.361-0.575 0.992-0.9 1.714-1.188 0.723-0.281 1.579-0.428 2.564-0.428 1.102 0 2.166 0.214 3.501 0.471 0.073 0.753-0.099 1.273-7e-3 1.897-0.961-0.636-2.025-0.955-3.072-0.955-0.568 0-1.145 0.086-1.621 0.233-0.478 0.146-1.01 0.624-1.218 0.918-0.215 0.3-0.331 0.581-0.318 0.936 6e-3 0.233 0.079 0.618 0.165 0.833 0.086 0.214 0.648 0.808 0.942 0.937 0.404 0.177 0.245 0.153 0.612 0.232 0.416 0.092 1.444 0.618 2.423 1.083 1.017 0.483 1.946 1.089 2.265 1.408 0.324 0.318 0.637 0.759 0.931 1.438 0.165 0.38 0.257 0.826 0.257 1.145 0 0.551-0.146 0.625-0.129 0.967 0.031 0.673-0.141 0.924-0.514 1.5s-1.071 1.126-1.849 1.444c-0.777 0.318-1.604 0.582-2.576 0.582-0.416 0-1.377 0.049-1.934-6e-3 -0.558-0.049-1.035-0.239-1.427-0.312s-0.643-0.092-1.224-0.232l-0.202-0.985c-6e-3 -0.116-0.263-0.771-0.373-1.396 1.646 0.906 3.385 1.542 4.633 1.542 0.654 0 1.304-0.19 1.75-0.361 0.447-0.171 0.882-0.489 1.096-0.826 0.208-0.336 0.44-0.661 0.521-1.016 0.049-0.196 0.11-0.459 0.061-0.637-0.067-0.211-0.171-0.774-0.306-0.957zm-86.138-55.282c0.324-2.111 0.955-4.223 1.364-5.673 0.973-3.47 3.581-8.672 4.841-10.429s1.762-2.295 3.592-4.339 0.783-0.637 4.174-3.421c3.384-2.785 7.938-4.78 9.933-5.587 1.995-0.814 5.037-2.301 10.521-2.668s8.794 0.312 11.854 0.667c3.586 0.417 10.435 2.754 10.435 2.754s3.996 1.805 7.093 3.837c1.671 1.004 3.158 2.987 4.676 4.927 2.087 2.668 4.131 6.028 4.425 6.505 0.508 0.814 2.778 4.908 3.256 6.426s1.542 7.117 1.628 7.729 0.937 4.051-2.001 4.253c-3.22 0.22-3.55-3.066-3.758-4.002-0.214-0.942-2.387-8.158-3.14-9.517s-5.264-7.962-7.265-10.135-5.894-4.951-10.141-6.255c-4.063-1.254-10.961-2.479-15.6-2.276-4.076 0.177-5.416 0.459-7.191 1.022-3.629 1.157-6.812 2.993-9.015 4.382-2.203 1.383-5.899 4.357-7.515 6.383-1.916 2.405-5.166 8.354-5.888 11.64-1.334 6.114-0.502 12.014-0.502 12.014s1.506 11.579 9.015 17.521c2.938 2.332 5.336 3.562 12.02 5.379 0.937 0.257 3.978 0.471 7.778 0.496 3.801 0.019 4.957-0.11 7.124-0.869 2.16-0.759 2.852-0.894 4.504-1.75 1.659-0.857 4.505-1.799 7.559-4.811 1.707-1.689 3.837-5.006 4.719-8.329 0.514-1.946 0.189-2.552 0.122-5.104-0.019-0.783-0.092-1.493-0.153-2.167-0.146-1.524-0.397-2.938-0.93-5.178-0.771-3.231-0.539-2.387-1.292-4.449-0.52-1.42-1.107-2.577-1.523-3.25s-0.814-1.12-1.273-1.818c-3.17-4.841-9.431-8.011-15.232-8.201-1.934-0.067-4.314 0.135-6.714 0.894-1.628 0.514-3.268 1.346-4.786 2.271-0.63 0.379-1.23 0.673-1.812 1.132-0.587 0.471-0.942 0.606-1.462 1.157-0.471 0.501-1.114 1.628-1.5 2.136-4.725 6.065-3.629 11.689-3.629 11.689s-0.44 13.207 13.52 14.646c3.525 0.171 9.89-2.087 12.301-4.67 1.481-1.591 1.585-4.437 1.536-6.964-0.036-2.001-1.016-5.551-2.552-6.922-3.342-2.98-6.12-3.072-7.576-3.158-1.94-0.123-4.7 0.477-5.79 4.725-0.38 1.475 0.777 4.547 2.962 4.982 1.879 0.379 3.88 0 4.762 0.128 0.783 0.11 1.971-0.153 1.971 2.313-0.221 4.321-9.633 1.903-9.737 1.812-0.722-0.624-4.969-3.042-5.134-7.631-0.178-4.847 2.099-8.507 6.236-10.576 1.041-0.52 2.956-0.783 4.254-0.838 3.524 0.171 6.021 0.63 8.604 2.02 0.483 0.263 0.979 0.477 1.512 0.838 0.165 0.11 0.802 0.557 0.899 0.618 3.023 2.601 4.284 6.035 4.884 9.499 0.238 1.377 0.232 2.662 0.275 3.678 0.08 1.738-0.122 3.843-1.01 5.82-0.942 2.112-2.638 4.082-5 5.318-2.295 1.2-5.643 3.103-10.264 3.672-2.784 0.342-6.021 0.287-9.773-0.924-10.643-3.439-11.646-15.514-11.646-15.514s-2.173-8.898 3.69-16.916c0.618-0.844 1.322-1.928 2.129-2.735 2.644-2.644 5.012-4.015 7.185-5.166 3.99-2.111 6.916-2.595 7.779-2.595 0.618 0 2.093-0.085 3.824 0.043 1.983 0.141 4.309 0.526 6.065 0.955 1.928 0.471 3.537 0.851 4.792 1.383 1.188 0.508 2.038 1.175 2.968 1.744 1.922 1.169 4.982 3.488 6.017 5.055 1.07 1.628 2.589 3.715 3.77 7.387 0.691 2.154 1.273 5.232 1.983 8.703 1.064 5.196 0.679 10.447-0.502 13.764-0.129 0.355-1.451 4.566-5.637 8.513-4.187 3.954-9.455 6.193-11.016 6.817-1.567 0.625-3.795 2.521-12.332 2.381-7.387-0.123-12.987-2.081-14.651-2.754-1.665-0.673-6.059-2.068-10.833-7.319-4.773-5.257-5.814-8.648-6.573-10.949s-2.191-8.195-2.191-8.195 0.171-0.024-0.171-3.066c-0.129-1.359-0.111-3.133 0.159-4.908zm73.825 59.388c-0.465 0.386-0.937 0.673-1.236 0.857-0.637 0.134-1.021 0.281-1.426 0.312-0.404 0.037-0.783 0.049-1.15 0.049-1.212 0-2.1-0.367-2.791-0.686-0.691-0.318-1.261-0.875-1.622-1.523-0.36-0.649-0.44-1.243-0.471-2.008-0.019-0.446 0.11-0.905 0.22-1.279 0.104-0.379 0.251-0.716 0.447-1.022 0.189-0.306 0.33-0.539 0.691-0.851 0.361-0.306 0.575-0.478 0.979-0.673 0.403-0.202 0.777-0.288 1.315-0.483 0.539-0.196 1.524-0.263 2.785-0.441 0.385-0.098 0.71-0.073 0.979-0.177 0.27-0.104 0.509-0.208 0.717-0.306s0.385-0.214 0.538-0.349 0.294-0.3 0.416-0.49c0.129-0.196 0.215-0.141 0.27-0.336 0.055-0.196 0.024-0.294 0.019-0.496-0.019-0.489-0.043-0.765-0.337-1.107s-0.637-0.833-1.102-0.967c-0.459-0.141-1.23-0.361-1.849-0.361-0.575 0-1.046 0.073-1.646 0.178-0.6 0.104-1.114 0.232-1.549 0.373-0.429 0.147-0.918 0.361-1.561 0.649 0.062-0.435 0.013-1.065 0.062-1.922 1.053-0.306 1.609-0.453 2.387-0.563s1.928-0.178 2.674-0.178c0.796 0 1.292 0.171 1.995 0.337 0.698 0.165 1.586 0.777 1.91 1.261 0.336 0.496 0.648 0.856 0.819 1.334 0.172 0.478 0.404 1.42 0.429 1.958 0.024 0.679 0.062 0.239 0.037 1.842-0.024 1.609 0.073 4.547 0.061 5.912-6e-3 0.833 0.099 0.912 0.318 2.038-0.483-0.019-1.102 0.024-1.401 0.024-0.287 0-0.71-0.043-1.236-0.024v-1.53c7e-3 6e-3 -0.226 0.263-0.691 0.648zm-19.155-3.378c0.336 0.838 0.899 1.659 1.683 2.118s1.701 0.906 2.662 0.906c0.931 0 2.889-0.098 5.013-1.224-0.013 0.159-0.098 0.514-0.153 0.942-0.055 0.435-0.178 0.796-0.214 1.212-0.637 0.166-1.31 0.349-1.903 0.41-0.588 0.061-2.197 0.165-2.644 0.165-0.949 0-2.051-0.196-2.864-0.483-0.814-0.288-1.83-0.832-2.448-1.487-0.624-0.655-1.328-1.31-1.646-2.283s-0.545-1.909-0.581-2.993c-0.056-1.457 0.177-1.946 0.587-3.25 0.404-1.31 1.438-2.252 2.394-2.993 0.954-0.741 3.164-1.371 4.859-1.371 1.248 0 2.711 0.208 3.91 0.575 0.086 0.851 0.116 1.31 0.178 1.861-0.845-0.3-1.616-0.649-2.148-0.753s-1.199-0.202-1.652-0.202c-0.771 0-2.411 0.343-3.011 0.655-0.6 0.318-1.102 0.765-1.512 1.353-0.41 0.581-0.734 1.395-0.894 2.197s-0.221 0.869-0.189 1.702c0.04 1.125 0.23 2.104 0.573 2.943zm-6.898-5.263c-0.019-0.575-0.189-1.224-0.306-1.548-0.116-0.324-0.704-0.924-0.949-1.187-0.244-0.263-0.611-0.312-0.961-0.447-0.349-0.135-0.911-0.166-1.353-0.166-0.354 0-0.802 0.062-1.095 0.147-0.275 0.086-0.551 0.147-0.809 0.331-0.281 0.189-0.532 0.3-0.752 0.575-0.221 0.27-0.398 0.575-0.545 0.912-0.153 0.349-0.159 0.869-0.189 1.432-0.037 0.606 0.03 1.383 0.012 2.252-0.024 0.918-0.024 4.56 0 6.065l0.422 1.346c-0.514-0.018-1.272-0.03-1.529-0.03-0.239 0-0.894 6e-3 -1.457 0.03 0.043-1.224 0.19-0.11 0.196-1.407l0.024-5.594c0-1.108-0.013-2.057-0.043-2.833-0.019-0.508-0.079-0.686-0.184-1.041-0.098-0.355-0.275-0.802-0.532-1.096-0.251-0.293-0.808-0.765-1.15-0.918-0.35-0.153-0.839-0.269-1.268-0.269-0.452 0-0.746 0.049-1.138 0.22s-0.734 0.251-1.059 0.594c-0.318 0.336-0.588 0.373-0.796 0.869-0.208 0.489-0.367 0.385-0.459 1.181-0.098 0.795-0.141 3.69-0.135 5.667 6e-3 1.169 0.019 2.228 0.037 3.183 0.012 0.654 0.281 0.887 0.306 1.444-0.569-0.018-1.212-0.03-1.42-0.03-0.232 0-1.01 6e-3 -1.585 0.03l0.318-1.028c0.012-0.453 0.019-1.922 0.024-2.901l-0.147-8.292c-0.018-0.741-0.416-1.628-0.435-2.014 0.41 0.012 1.335-0.135 1.763-0.294 0.343-0.128 0.729-0.128 1.09-0.141l-6e-3 1.928c0.275-0.557 0.776-0.612 1.01-0.942 0.232-0.324 0.471-0.312 0.856-0.587s0.624-0.288 1.139-0.361c0.63-0.092 1.027-0.123 1.572-0.123 0.38 0 0.753 0.049 1.126 0.147 0.374 0.098 0.717 0.239 1.041 0.417 0.318 0.177 0.594 0.379 0.826 0.605 0.232 0.227 0.483 0.349 0.691 0.741 0.073 0.128 0.637-0.624 1.426-1.083 0.79-0.453 1.72-0.802 2.711-0.802 0.637 0 2.057 0.085 2.662 0.312 0.606 0.227 1.463 0.557 1.836 0.979 0.367 0.429 0.478 0.618 0.809 0.967 0.41 0.435 0.538 1.53 0.562 1.995 0.019 0.477 0.067 1.199 0.067 2.16l6e-3 6.818c0 0.655 0.19 0.734 0.312 1.481-0.471-0.019-1.083-0.031-1.353-0.031-0.281 0-0.955 6e-3 -1.506 0.031 0.367-1.169 0.294-0.771 0.325-1.487l0.024-6.181c-2e-3 -0.87-7e-3 -1.384-0.032-2.026zm-24.217 8.831c-0.459 0.386-0.937 0.667-1.23 0.857-0.637 0.135-1.016 0.282-1.42 0.312-0.404 0.031-0.79 0.049-1.151 0.049-1.206 0-2.093-0.367-2.784-0.686-0.692-0.318-1.255-0.875-1.616-1.524-0.361-0.648-0.441-1.242-0.471-2.007-0.019-0.447 0.116-0.906 0.22-1.279 0.104-0.374 0.251-0.716 0.44-1.022 0.19-0.306 0.331-0.539 0.692-0.844 0.361-0.306 0.575-0.478 0.979-0.673s0.771-0.288 1.31-0.483c0.539-0.19 1.524-0.263 2.778-0.441 0.38-0.098 0.71-0.073 0.979-0.177s0.508-0.208 0.716-0.306 0.386-0.214 0.539-0.349 0.294-0.3 0.417-0.49c0.128-0.196 0.214-0.263 0.269-0.459s0.024-0.294 0.019-0.496c-0.019-0.49-0.043-0.637-0.337-0.985-0.293-0.349-0.636-0.833-1.095-0.967s-1.224-0.361-1.842-0.361c-0.575 0-1.046 0.074-1.646 0.177-0.6 0.104-1.114 0.233-1.548 0.374-0.429 0.147-0.918 0.361-1.561 0.649 0.062-0.441 0.012-1.065 0.062-1.928 1.046-0.3 1.604-0.453 2.38-0.563 0.777-0.11 1.928-0.177 2.668-0.177 0.795 0 1.292 0.171 1.989 0.336 0.704 0.166 1.579 0.777 1.904 1.261 0.336 0.496 0.648 0.851 0.82 1.328 0.165 0.478 0.404 1.42 0.428 1.958 0.025 0.686 0.062 0.239 0.037 1.842-0.025 1.609 0.073 4.547 0.061 5.912-6e-3 0.826 0.098 0.912 0.318 2.038-0.478-0.019-1.096 0.024-1.402 0.024-0.281 0-0.709-0.043-1.236-0.024v-1.53c6e-3 0.011-0.227 0.268-0.686 0.654zm-19.975-3.109c0.422 0.875 0.991 1.438 1.769 1.891 0.777 0.447 1.805 0.839 2.791 0.839 1.139 0 3.213-0.478 4.915-1.328-0.085 0.539-0.263 1.242-0.336 2.075-0.838 0.238-2.222 0.771-2.84 0.856-0.618 0.086-1.23 0.104-1.848 0.104-1.102 0-2.197-0.275-3.084-0.569-0.888-0.3-1.775-0.912-2.424-1.652-0.655-0.735-1.297-1.536-1.603-2.491-0.312-0.948-0.386-1.909-0.429-2.968-0.055-1.475 0.184-2.025 0.637-3.286s1.401-2.179 2.387-2.901c0.979-0.722 2.246-1.083 3.794-1.083 0.802 0 1.713 0.062 2.454 0.325 0.74 0.263 1.365 0.539 1.867 1.071 0.508 0.539 0.93 1.071 1.224 1.86 0.294 0.79 0.361 0.802 0.526 1.72 0.074 0.429 0.129 1.102 0.092 1.438l-10.49 0.061c-0.012 0.545-0.049 0.814-0.037 1.096 0.029 1.045 0.212 2.067 0.635 2.942zm-11.12-10.288c0.318-0.067 1.102-0.177 1.518-0.189l6e-3 2.644c0.3-0.612 0.318-0.575 0.563-0.881 0.239-0.312 0.624-0.667 0.93-0.869 0.312-0.202 0.649-0.49 1.046-0.606 0.392-0.117 0.753-0.282 1.188-0.3 0.343-0.012 0.667-0.061 1.548 0.031 0.887 0.092 1.353 0.294 1.548 0.349 0.019 0.355-0.649 1.989-0.649 1.989s-0.636-0.055-1.211-0.293c-0.551-0.166-0.924-0.166-1.359-0.166-0.514 0-1.12 0.116-1.524 0.312-0.404 0.19-0.79 0.422-1.102 0.814s-0.52 0.796-0.71 1.34c-0.159 0.441-0.104 0.073-0.165 0.765-0.067 0.691-6e-3 7.326 0.049 8.819l0.263 0.857c-0.483-0.019-1.169 0-1.462 0-0.27 0-0.924 0.012-1.469 0.03 0-0.281 0.282-0.673 0.288-0.942 0.067-4.633-0.03-8.213-0.141-11.206l-0.049-1.261-0.44-1.071c0.446-0.05 1.052-0.111 1.334-0.166zm-18.654-6.224c0.533 0 1.322 0.086 2.436 0.062 1.114-0.025 2.105 0 2.546 0.042 1.585 0.147 1.989 0.233 3.078 0.502 0.826 0.196 2.393 1.034 3.091 1.53 0.704 0.496 1.401 1.064 1.97 1.866 0.563 0.802 0.845 1.059 1.224 1.989 0.508 1.261 0.802 2.625 0.851 3.892 0.067 1.732-0.116 3.06-0.618 4.651-0.496 1.591-1.603 2.772-2.668 3.837s-2.234 1.708-3.593 2.044c-1.365 0.336-2.901 0.667-4.596 0.667l-3.991-0.03-3.8-0.092 0.539-1.42-0.043-17.528c-0.012-0.508-0.251-1.034-0.501-1.922 1.198 0.027 3.224-0.09 4.075-0.09zm-17.797 168.64v-128.02c0-2.846 2.313-5.159 5.159-5.159h144.32c2.846 0 5.159 2.313 5.159 5.159v128.02c0 2.846-2.313 5.159-5.159 5.159h-144.32c-2.846 1e-3 -5.159-2.312-5.159-5.158z\" fill=\"#1a1a1a\"/>\n     <ellipse cx=\"493.55\" cy=\"200.22\" rx=\"25.204\" ry=\"25.115\" fill=\"#fff\"/>\n     <circle cx=\"493.51\" cy=\"200.26\" r=\"18.911\" fill=\"#1a1a1a\"/>\n     <ellipse cx=\"444.94\" cy=\"246.54\" rx=\"25.204\" ry=\"25.115\" fill=\"#fff\"/>\n     <path d=\"m445.3 265.55c10.422 0 18.904-8.482 18.904-18.905s-8.482-18.911-18.904-18.911c-10.429 0-18.911 8.482-18.911 18.911s8.482 18.905 18.911 18.905z\" fill=\"#1a1a1a\"/>\n     <ellipse cx=\"492.88\" cy=\"293.45\" rx=\"25.204\" ry=\"25.115\" fill=\"#fff\"/>\n     <path d=\"m492.9 274.71c-10.429 0-18.911 8.482-18.911 18.911 0 10.428 8.482 18.905 18.911 18.905 10.422 0 18.904-8.482 18.904-18.905s-8.482-18.911-18.904-18.911z\" fill=\"#1a1a1a\"/>\n     <ellipse cx=\"541.23\" cy=\"247.25\" rx=\"25.204\" ry=\"25.115\" fill=\"#fff\"/>\n     <circle cx=\"541.11\" cy=\"247.25\" r=\"18.911\" fill=\"#1a1a1a\"/>\n     <path d=\"m78.855 232.89c21.53 0 39.045-17.515 39.045-39.045s-17.515-39.045-39.045-39.045-39.046 17.515-39.046 39.045 17.522 39.045 39.046 39.045z\" fill=\"#1a1a1a\"/>\n     <polygon transform=\"translate(6.8088,8.7805)\" points=\"124.82 332.13 155.94 332.13 155.94 310.78 124.82 310.78 124.82 279.67 103.48 279.67 103.48 310.78 72.364 310.78 72.364 332.13 103.48 332.13 103.48 363.25 124.82 363.25\" fill=\"#1a1a1a\"/>\n     <polygon transform=\"translate(6.8088,8.7805)\" points=\"269.44 444.41 318.12 444.41 293.78 403.06\" fill=\"#1a1a1a\"/>\n    </g>\n   </g>\n   <g transform=\"translate(-1.12)\" clip-path=\"url(#a)\" fill=\"#1a1a1a\">\n    <g clip-path=\"none\">\n     <path d=\"m243.78 111.34c0.838 0 1.818-0.043 2.687-0.135s1.481-0.397 2.167-0.636 1.377-0.643 2.02-1.261c0.637-0.618 1.157-1.316 1.548-2.099 0.392-0.784 0.673-1.659 0.845-2.632 0.171-0.967 0.239-1.952 0.196-2.95-0.042-1.12-0.343-1.953-0.648-2.907-0.306-0.955-0.881-2.154-1.671-2.803-0.869-0.716-1.493-1.224-2.387-1.481-0.894-0.251-2.154-0.637-3.599-0.637-0.881 0-2.05 0.062-2.62 0.128-0.593 0.074-1.138 0.147-1.885 0.159l0.196 17.228c1.162 0.038 2.154 0.026 3.151 0.026z\" fill=\"#1a1a1a\"/>\n     <path d=\"m278.33 102.96c-0.031-0.624 0-0.416-0.073-0.765-0.074-0.343-0.166-0.618-0.349-0.991-0.184-0.367-0.502-0.624-0.795-0.894-0.294-0.27-0.643-0.478-1.053-0.618-0.404-0.147-1.01-0.22-1.475-0.22-0.501 0-0.948 0.153-1.395 0.312s-0.838 0.374-1.175 0.649c-0.336 0.275-0.618 0.6-0.844 0.967-0.227 0.367-0.392 0.729-0.496 1.071-0.042 0.135-0.049 0.147-0.042 0.153 6e-3 6e-3 0.03-0.012-0.025 0.336z\" fill=\"#1a1a1a\"/>\n     <path d=\"m291.54 104.42c-0.3 0.27-0.441 0.343-0.587 0.453-0.147 0.11-0.361 0.171-0.551 0.269-0.19 0.092-0.447 0.116-0.68 0.202-0.226 0.085-1.022 0.11-1.346 0.153-0.691 0.086-1.15 0.159-1.426 0.27-0.6 0.214-0.955 0.275-1.298 0.496-0.342 0.22-0.612 0.551-0.838 0.808-0.227 0.257-0.312 0.49-0.404 0.747-0.104 0.318-0.092 0.655-0.073 0.998 0.018 0.538 0.434 1.132 0.734 1.523 0.293 0.398 0.3 0.257 0.679 0.526 0.379 0.263 0.918 0.404 1.518 0.404 0.374 0 0.759-0.031 1.157-0.092 0.306-0.043 0.637-0.239 1.096-0.392 0.146-0.049 0.489-0.361 0.655-0.422 0 0 0.422-0.342 0.844-1.077 0.422-0.734 0.508-1.952 0.508-1.952z\" fill=\"#1a1a1a\"/>\n     <path d=\"m341.81 104.23c-0.294 0.27-0.44 0.349-0.588 0.459-0.146 0.11-0.379 0.153-0.569 0.251-0.189 0.092-0.428 0.135-0.66 0.22-0.227 0.086-1.022 0.11-1.347 0.153-0.691 0.085-1.15 0.159-1.426 0.269-0.6 0.22-0.961 0.282-1.304 0.496-0.343 0.221-0.618 0.551-0.845 0.808s-0.318 0.489-0.404 0.747c-0.104 0.318-0.085 0.655-0.073 1.003 0.019 0.533 0.435 1.132 0.734 1.524 0.3 0.398 0.3 0.257 0.686 0.526 0.38 0.263 0.918 0.404 1.524 0.404 0.373 0 0.759-0.03 1.162-0.092 0.307-0.042 0.643-0.245 1.096-0.392 0.146-0.049 0.489-0.361 0.655-0.422 0 0 0.422-0.343 0.844-1.077 0.423-0.729 0.509-1.953 0.509-1.953z\" fill=\"#1a1a1a\"/>\n     <path d=\"m119.14 577.38c12.815-43.023 10.985-43.023 17.393-58.582 6.408-15.562 19.223-16.475 35.698-20.135 82.805-10.454 167.09-15.742 247.15-7e-5 16.476 3.66 29.291 4.578 35.698 20.135 6.407 15.564 4.578 15.564 17.394 58.582 12.814 43.018 69.554-66.818 95.184-228.83 25.631-162.01-11.848-224.91-22.222-230.4-10.373-5.49-79.382-20.404-79.382-20.404-18.269-23.911-37.871-41.377-57.039-54.199v181.14c0 53.85-43.807 97.657-97.656 97.657h-21.524c-53.85 0-97.657-43.808-97.657-97.657v-187.17c-22.156 13.194-45.296 32.319-66.624 60.232 0 0-69.009 14.908-79.382 20.404-10.374 5.49-47.853 68.385-22.222 230.4 25.624 162.01 82.375 271.85 95.19 228.83zm373.77-258.73c-13.801 0-25.031-11.223-25.031-25.024s11.23-25.031 25.031-25.031c13.8 0 25.024 11.224 25.024 25.031 1e-3 13.802-11.224 25.024-25.024 25.024zm48.207-96.432c13.801 0 25.03 11.224 25.03 25.031 0 13.801-11.229 25.025-25.03 25.025s-25.031-11.224-25.031-25.025 11.23-25.031 25.031-25.031zm-47.601-46.989c13.801 0 25.031 11.224 25.031 25.031 0 13.8-11.23 25.024-25.031 25.024s-25.03-11.224-25.03-25.024c5e-3 -13.801 11.229-25.031 25.03-25.031zm-48.207 46.383c13.801 0 25.024 11.224 25.024 25.031 0 13.801-11.224 25.025-25.024 25.025s-25.031-11.224-25.031-25.025c6e-3 -13.807 11.236-25.031 25.031-25.031zm-176.43 232.05 28.458-48.342c1.408-2.418 5.056-2.441 6.5-6e-3l28.451 48.342c0.729 1.242 0.759 2.662 0.099 3.818-0.655 1.15-1.91 1.842-3.33 1.842h-56.928c-1.426 0-2.674-0.691-3.335-1.842-0.668-1.156-0.631-2.582 0.085-3.812zm-136.01-171.33c0.12593-2.6961 5.1037 2.1992 4.895 4.8902v26.23l26.231-1.6e-4c2.693-2e-5 4.89 2.191 4.89 4.891v23.801c0 2.697-2.191 4.889-4.89 4.889l-26.231 1.6e-4v26.23c0 2.693-2.19 4.8908-4.895 4.8908h-23.801c-2.692 0-4.89-2.191-4.89-4.891v-26.23h-26.23c-2.693 0-4.89-2.191-4.89-4.889v-23.801c0-2.693 2.191-4.891 4.89-4.891h26.23v-26.23c0-2.699 2.191-4.89 4.89-4.89 7.9337 0 15.867 169.86 23.801 0zm-54.009-133.64c24.902 0 45.166 20.263 45.166 45.166s-20.263 45.166-45.166 45.166-45.166-20.263-45.166-45.166 20.264-45.166 45.166-45.166z\" fill=\"#f2f2f2\" stroke=\"#000\" stroke-width=\"3.2267\"/>\n     <path d=\"m371.79 133.6h-142.4v126.1h142.4zm-8.256 117.31c0 0.985-0.796 1.781-1.781 1.781h-122.33c-0.979 0-1.781-0.796-1.781-1.781v-108.51c0-0.985 0.795-1.781 1.781-1.781h122.33c0.985 0 1.781 0.795 1.781 1.781z\" fill=\"#1a1a1a\"/>\n     <path d=\"m126.54 95.719a205.64 206.43 0 0 0-36.058 116.76 205.64 206.43 0 0 0 205.64 206.43 205.64 206.43 0 0 0 205.64-206.43 205.64 206.43 0 0 0-36.06-116.76z\" clip-path=\"none\" fill=\"none\" stroke=\"#000\" stroke-width=\"7.4\"/>\n     <path d=\"m289.82 316.22h21.523c50.558 0 91.537-40.985 91.537-91.536v-185.14c-45.018-27.974-86.578-30.765-101.38-30.765-3.69 0-5.71 0.171-5.71 0.171s-2.026-0.171-5.71-0.171c-13.733 0-50.551 2.405-91.8 25.153v190.75c0 50.552 40.986 91.537 91.537 91.537zm66.506-218.18 1.806-0.061c0.018-0.379-0.031-1.567-0.031-2.497 0-0.453-0.227-0.869-0.41-1.096 0.82-0.184 2.069-0.563 2.638-0.728-6e-3 1.469 0.099 3.556 0.117 4.321l3.684 0.055c-0.019 0.63 0.049 0.851 0.062 1.419l-1.016-0.122h-2.705l-0.05 8.103-0.024 0.679c0.024 0.723 0.123 1.641 0.282 2.001 0.159 0.361 0.385 0.496 0.679 0.655 0.3 0.159 0.637 0.196 0.949 0.196 0.22 0 0.551-6e-3 0.808-6e-3s0.435-0.019 1.071-0.202c-0.08 0.478-0.209 0.741-0.294 1.536-0.588 0.166-0.857 0.208-1.206 0.245-0.349 0.043-0.679-0.067-0.997-0.067-0.777 0-1.414-0.11-1.903-0.337-0.49-0.22-0.869-0.575-1.139-1.071-0.275-0.49-0.465-1.708-0.496-2.552-6e-3 -0.11-6e-3 -0.3-0.012-0.575 0-0.275-0.019-0.551 0-2.197l-0.056-6.402h-1.774c0.023-0.397 0.023-0.519 0.017-1.297zm-2.932 9.309c-0.135-0.184-0.643-0.618-0.899-0.838-0.257-0.227-0.937-0.557-1.824-0.924-0.899-0.379-2.044-0.74-2.46-1.089-0.416-0.355-1.175-0.759-1.475-1.132s-0.526-0.74-0.68-1.12c-0.153-0.374-0.043-0.943-0.055-1.328-0.024-0.618 0.36-1.254 0.728-1.836 0.361-0.575 0.992-0.9 1.714-1.188 0.723-0.281 1.579-0.428 2.564-0.428 1.102 0 2.166 0.214 3.501 0.471 0.073 0.753-0.099 1.273-7e-3 1.897-0.961-0.636-2.025-0.955-3.072-0.955-0.568 0-1.145 0.086-1.621 0.233-0.478 0.146-1.01 0.624-1.218 0.918-0.215 0.3-0.331 0.581-0.318 0.936 6e-3 0.233 0.079 0.618 0.165 0.833 0.086 0.214 0.648 0.808 0.942 0.937 0.404 0.177 0.245 0.153 0.612 0.232 0.416 0.092 1.444 0.618 2.423 1.083 1.017 0.483 1.946 1.089 2.265 1.408 0.324 0.318 0.637 0.759 0.931 1.438 0.165 0.38 0.257 0.826 0.257 1.145 0 0.551-0.146 0.625-0.129 0.967 0.031 0.673-0.141 0.924-0.514 1.5s-1.071 1.126-1.849 1.444c-0.777 0.318-1.604 0.582-2.576 0.582-0.416 0-1.377 0.049-1.934-6e-3 -0.558-0.049-1.035-0.239-1.427-0.312s-0.643-0.092-1.224-0.232l-0.202-0.985c-6e-3 -0.116-0.263-0.771-0.373-1.396 1.646 0.906 3.385 1.542 4.633 1.542 0.654 0 1.304-0.19 1.75-0.361 0.447-0.171 0.882-0.489 1.096-0.826 0.208-0.336 0.44-0.661 0.521-1.016 0.049-0.196 0.11-0.459 0.061-0.637-0.067-0.211-0.171-0.774-0.306-0.957zm-86.138-55.282c0.324-2.111 0.955-4.223 1.364-5.673 0.973-3.47 3.581-8.672 4.841-10.429s1.762-2.295 3.592-4.339 0.783-0.637 4.174-3.421c3.384-2.785 7.938-4.78 9.933-5.587 1.995-0.814 5.037-2.301 10.521-2.668s8.794 0.312 11.854 0.667c3.586 0.417 10.435 2.754 10.435 2.754s3.996 1.805 7.093 3.837c1.671 1.004 3.158 2.987 4.676 4.927 2.087 2.668 4.131 6.028 4.425 6.505 0.508 0.814 2.778 4.908 3.256 6.426s1.542 7.117 1.628 7.729 0.937 4.051-2.001 4.253c-3.22 0.22-3.55-3.066-3.758-4.002-0.214-0.942-2.387-8.158-3.14-9.517s-5.264-7.962-7.265-10.135-5.894-4.951-10.141-6.255c-4.063-1.254-10.961-2.479-15.6-2.276-4.076 0.177-5.416 0.459-7.191 1.022-3.629 1.157-6.812 2.993-9.015 4.382-2.203 1.383-5.899 4.357-7.515 6.383-1.916 2.405-5.166 8.354-5.888 11.64-1.334 6.114-0.502 12.014-0.502 12.014s1.506 11.579 9.015 17.521c2.938 2.332 5.336 3.562 12.02 5.379 0.937 0.257 3.978 0.471 7.778 0.496 3.801 0.019 4.957-0.11 7.124-0.869 2.16-0.759 2.852-0.894 4.504-1.75 1.659-0.857 4.505-1.799 7.559-4.811 1.707-1.689 3.837-5.006 4.719-8.329 0.514-1.946 0.189-2.552 0.122-5.104-0.019-0.783-0.092-1.493-0.153-2.167-0.146-1.524-0.397-2.938-0.93-5.178-0.771-3.231-0.539-2.387-1.292-4.449-0.52-1.42-1.107-2.577-1.523-3.25s-0.814-1.12-1.273-1.818c-3.17-4.841-9.431-8.011-15.232-8.201-1.934-0.067-4.314 0.135-6.714 0.894-1.628 0.514-3.268 1.346-4.786 2.271-0.63 0.379-1.23 0.673-1.812 1.132-0.587 0.471-0.942 0.606-1.462 1.157-0.471 0.501-1.114 1.628-1.5 2.136-4.725 6.065-3.629 11.689-3.629 11.689s-0.44 13.207 13.52 14.646c3.525 0.171 9.89-2.087 12.301-4.67 1.481-1.591 1.585-4.437 1.536-6.964-0.036-2.001-1.016-5.551-2.552-6.922-3.342-2.98-6.12-3.072-7.576-3.158-1.94-0.123-4.7 0.477-5.79 4.725-0.38 1.475 0.777 4.547 2.962 4.982 1.879 0.379 3.88 0 4.762 0.128 0.783 0.11 1.971-0.153 1.971 2.313-0.221 4.321-9.633 1.903-9.737 1.812-0.722-0.624-4.969-3.042-5.134-7.631-0.178-4.847 2.099-8.507 6.236-10.576 1.041-0.52 2.956-0.783 4.254-0.838 3.524 0.171 6.021 0.63 8.604 2.02 0.483 0.263 0.979 0.477 1.512 0.838 0.165 0.11 0.802 0.557 0.899 0.618 3.023 2.601 4.284 6.035 4.884 9.499 0.238 1.377 0.232 2.662 0.275 3.678 0.08 1.738-0.122 3.843-1.01 5.82-0.942 2.112-2.638 4.082-5 5.318-2.295 1.2-5.643 3.103-10.264 3.672-2.784 0.342-6.021 0.287-9.773-0.924-10.643-3.439-11.646-15.514-11.646-15.514s-2.173-8.898 3.69-16.916c0.618-0.844 1.322-1.928 2.129-2.735 2.644-2.644 5.012-4.015 7.185-5.166 3.99-2.111 6.916-2.595 7.779-2.595 0.618 0 2.093-0.085 3.824 0.043 1.983 0.141 4.309 0.526 6.065 0.955 1.928 0.471 3.537 0.851 4.792 1.383 1.188 0.508 2.038 1.175 2.968 1.744 1.922 1.169 4.982 3.488 6.017 5.055 1.07 1.628 2.589 3.715 3.77 7.387 0.691 2.154 1.273 5.232 1.983 8.703 1.064 5.196 0.679 10.447-0.502 13.764-0.129 0.355-1.451 4.566-5.637 8.513-4.187 3.954-9.455 6.193-11.016 6.817-1.567 0.625-3.795 2.521-12.332 2.381-7.387-0.123-12.987-2.081-14.651-2.754-1.665-0.673-6.059-2.068-10.833-7.319-4.773-5.257-5.814-8.648-6.573-10.949s-2.191-8.195-2.191-8.195 0.171-0.024-0.171-3.066c-0.129-1.359-0.111-3.133 0.159-4.908zm73.825 59.388c-0.465 0.386-0.937 0.673-1.236 0.857-0.637 0.134-1.021 0.281-1.426 0.312-0.404 0.037-0.783 0.049-1.15 0.049-1.212 0-2.1-0.367-2.791-0.686-0.691-0.318-1.261-0.875-1.622-1.523-0.36-0.649-0.44-1.243-0.471-2.008-0.019-0.446 0.11-0.905 0.22-1.279 0.104-0.379 0.251-0.716 0.447-1.022 0.189-0.306 0.33-0.539 0.691-0.851 0.361-0.306 0.575-0.478 0.979-0.673 0.403-0.202 0.777-0.288 1.315-0.483 0.539-0.196 1.524-0.263 2.785-0.441 0.385-0.098 0.71-0.073 0.979-0.177 0.27-0.104 0.509-0.208 0.717-0.306s0.385-0.214 0.538-0.349 0.294-0.3 0.416-0.49c0.129-0.196 0.215-0.141 0.27-0.336 0.055-0.196 0.024-0.294 0.019-0.496-0.019-0.489-0.043-0.765-0.337-1.107s-0.637-0.833-1.102-0.967c-0.459-0.141-1.23-0.361-1.849-0.361-0.575 0-1.046 0.073-1.646 0.178-0.6 0.104-1.114 0.232-1.549 0.373-0.429 0.147-0.918 0.361-1.561 0.649 0.062-0.435 0.013-1.065 0.062-1.922 1.053-0.306 1.609-0.453 2.387-0.563s1.928-0.178 2.674-0.178c0.796 0 1.292 0.171 1.995 0.337 0.698 0.165 1.586 0.777 1.91 1.261 0.336 0.496 0.648 0.856 0.819 1.334 0.172 0.478 0.404 1.42 0.429 1.958 0.024 0.679 0.062 0.239 0.037 1.842-0.024 1.609 0.073 4.547 0.061 5.912-6e-3 0.833 0.099 0.912 0.318 2.038-0.483-0.019-1.102 0.024-1.401 0.024-0.287 0-0.71-0.043-1.236-0.024v-1.53c7e-3 6e-3 -0.226 0.263-0.691 0.648zm-19.155-3.378c0.336 0.838 0.899 1.659 1.683 2.118s1.701 0.906 2.662 0.906c0.931 0 2.889-0.098 5.013-1.224-0.013 0.159-0.098 0.514-0.153 0.942-0.055 0.435-0.178 0.796-0.214 1.212-0.637 0.166-1.31 0.349-1.903 0.41-0.588 0.061-2.197 0.165-2.644 0.165-0.949 0-2.051-0.196-2.864-0.483-0.814-0.288-1.83-0.832-2.448-1.487-0.624-0.655-1.328-1.31-1.646-2.283s-0.545-1.909-0.581-2.993c-0.056-1.457 0.177-1.946 0.587-3.25 0.404-1.31 1.438-2.252 2.394-2.993 0.954-0.741 3.164-1.371 4.859-1.371 1.248 0 2.711 0.208 3.91 0.575 0.086 0.851 0.116 1.31 0.178 1.861-0.845-0.3-1.616-0.649-2.148-0.753s-1.199-0.202-1.652-0.202c-0.771 0-2.411 0.343-3.011 0.655-0.6 0.318-1.102 0.765-1.512 1.353-0.41 0.581-0.734 1.395-0.894 2.197s-0.221 0.869-0.189 1.702c0.04 1.125 0.23 2.104 0.573 2.943zm-6.898-5.263c-0.019-0.575-0.189-1.224-0.306-1.548-0.116-0.324-0.704-0.924-0.949-1.187-0.244-0.263-0.611-0.312-0.961-0.447-0.349-0.135-0.911-0.166-1.353-0.166-0.354 0-0.802 0.062-1.095 0.147-0.275 0.086-0.551 0.147-0.809 0.331-0.281 0.189-0.532 0.3-0.752 0.575-0.221 0.27-0.398 0.575-0.545 0.912-0.153 0.349-0.159 0.869-0.189 1.432-0.037 0.606 0.03 1.383 0.012 2.252-0.024 0.918-0.024 4.56 0 6.065l0.422 1.346c-0.514-0.018-1.272-0.03-1.529-0.03-0.239 0-0.894 6e-3 -1.457 0.03 0.043-1.224 0.19-0.11 0.196-1.407l0.024-5.594c0-1.108-0.013-2.057-0.043-2.833-0.019-0.508-0.079-0.686-0.184-1.041-0.098-0.355-0.275-0.802-0.532-1.096-0.251-0.293-0.808-0.765-1.15-0.918-0.35-0.153-0.839-0.269-1.268-0.269-0.452 0-0.746 0.049-1.138 0.22s-0.734 0.251-1.059 0.594c-0.318 0.336-0.588 0.373-0.796 0.869-0.208 0.489-0.367 0.385-0.459 1.181-0.098 0.795-0.141 3.69-0.135 5.667 6e-3 1.169 0.019 2.228 0.037 3.183 0.012 0.654 0.281 0.887 0.306 1.444-0.569-0.018-1.212-0.03-1.42-0.03-0.232 0-1.01 6e-3 -1.585 0.03l0.318-1.028c0.012-0.453 0.019-1.922 0.024-2.901l-0.147-8.292c-0.018-0.741-0.416-1.628-0.435-2.014 0.41 0.012 1.335-0.135 1.763-0.294 0.343-0.128 0.729-0.128 1.09-0.141l-6e-3 1.928c0.275-0.557 0.776-0.612 1.01-0.942 0.232-0.324 0.471-0.312 0.856-0.587s0.624-0.288 1.139-0.361c0.63-0.092 1.027-0.123 1.572-0.123 0.38 0 0.753 0.049 1.126 0.147 0.374 0.098 0.717 0.239 1.041 0.417 0.318 0.177 0.594 0.379 0.826 0.605 0.232 0.227 0.483 0.349 0.691 0.741 0.073 0.128 0.637-0.624 1.426-1.083 0.79-0.453 1.72-0.802 2.711-0.802 0.637 0 2.057 0.085 2.662 0.312 0.606 0.227 1.463 0.557 1.836 0.979 0.367 0.429 0.478 0.618 0.809 0.967 0.41 0.435 0.538 1.53 0.562 1.995 0.019 0.477 0.067 1.199 0.067 2.16l6e-3 6.818c0 0.655 0.19 0.734 0.312 1.481-0.471-0.019-1.083-0.031-1.353-0.031-0.281 0-0.955 6e-3 -1.506 0.031 0.367-1.169 0.294-0.771 0.325-1.487l0.024-6.181c-2e-3 -0.87-7e-3 -1.384-0.032-2.026zm-24.217 8.831c-0.459 0.386-0.937 0.667-1.23 0.857-0.637 0.135-1.016 0.282-1.42 0.312-0.404 0.031-0.79 0.049-1.151 0.049-1.206 0-2.093-0.367-2.784-0.686-0.692-0.318-1.255-0.875-1.616-1.524-0.361-0.648-0.441-1.242-0.471-2.007-0.019-0.447 0.116-0.906 0.22-1.279 0.104-0.374 0.251-0.716 0.44-1.022 0.19-0.306 0.331-0.539 0.692-0.844 0.361-0.306 0.575-0.478 0.979-0.673s0.771-0.288 1.31-0.483c0.539-0.19 1.524-0.263 2.778-0.441 0.38-0.098 0.71-0.073 0.979-0.177s0.508-0.208 0.716-0.306 0.386-0.214 0.539-0.349 0.294-0.3 0.417-0.49c0.128-0.196 0.214-0.263 0.269-0.459s0.024-0.294 0.019-0.496c-0.019-0.49-0.043-0.637-0.337-0.985-0.293-0.349-0.636-0.833-1.095-0.967s-1.224-0.361-1.842-0.361c-0.575 0-1.046 0.074-1.646 0.177-0.6 0.104-1.114 0.233-1.548 0.374-0.429 0.147-0.918 0.361-1.561 0.649 0.062-0.441 0.012-1.065 0.062-1.928 1.046-0.3 1.604-0.453 2.38-0.563 0.777-0.11 1.928-0.177 2.668-0.177 0.795 0 1.292 0.171 1.989 0.336 0.704 0.166 1.579 0.777 1.904 1.261 0.336 0.496 0.648 0.851 0.82 1.328 0.165 0.478 0.404 1.42 0.428 1.958 0.025 0.686 0.062 0.239 0.037 1.842-0.025 1.609 0.073 4.547 0.061 5.912-6e-3 0.826 0.098 0.912 0.318 2.038-0.478-0.019-1.096 0.024-1.402 0.024-0.281 0-0.709-0.043-1.236-0.024v-1.53c6e-3 0.011-0.227 0.268-0.686 0.654zm-19.975-3.109c0.422 0.875 0.991 1.438 1.769 1.891 0.777 0.447 1.805 0.839 2.791 0.839 1.139 0 3.213-0.478 4.915-1.328-0.085 0.539-0.263 1.242-0.336 2.075-0.838 0.238-2.222 0.771-2.84 0.856-0.618 0.086-1.23 0.104-1.848 0.104-1.102 0-2.197-0.275-3.084-0.569-0.888-0.3-1.775-0.912-2.424-1.652-0.655-0.735-1.297-1.536-1.603-2.491-0.312-0.948-0.386-1.909-0.429-2.968-0.055-1.475 0.184-2.025 0.637-3.286s1.401-2.179 2.387-2.901c0.979-0.722 2.246-1.083 3.794-1.083 0.802 0 1.713 0.062 2.454 0.325 0.74 0.263 1.365 0.539 1.867 1.071 0.508 0.539 0.93 1.071 1.224 1.86 0.294 0.79 0.361 0.802 0.526 1.72 0.074 0.429 0.129 1.102 0.092 1.438l-10.49 0.061c-0.012 0.545-0.049 0.814-0.037 1.096 0.029 1.045 0.212 2.067 0.635 2.942zm-11.12-10.288c0.318-0.067 1.102-0.177 1.518-0.189l6e-3 2.644c0.3-0.612 0.318-0.575 0.563-0.881 0.239-0.312 0.624-0.667 0.93-0.869 0.312-0.202 0.649-0.49 1.046-0.606 0.392-0.117 0.753-0.282 1.188-0.3 0.343-0.012 0.667-0.061 1.548 0.031 0.887 0.092 1.353 0.294 1.548 0.349 0.019 0.355-0.649 1.989-0.649 1.989s-0.636-0.055-1.211-0.293c-0.551-0.166-0.924-0.166-1.359-0.166-0.514 0-1.12 0.116-1.524 0.312-0.404 0.19-0.79 0.422-1.102 0.814s-0.52 0.796-0.71 1.34c-0.159 0.441-0.104 0.073-0.165 0.765-0.067 0.691-6e-3 7.326 0.049 8.819l0.263 0.857c-0.483-0.019-1.169 0-1.462 0-0.27 0-0.924 0.012-1.469 0.03 0-0.281 0.282-0.673 0.288-0.942 0.067-4.633-0.03-8.213-0.141-11.206l-0.049-1.261-0.44-1.071c0.446-0.05 1.052-0.111 1.334-0.166zm-18.654-6.224c0.533 0 1.322 0.086 2.436 0.062 1.114-0.025 2.105 0 2.546 0.042 1.585 0.147 1.989 0.233 3.078 0.502 0.826 0.196 2.393 1.034 3.091 1.53 0.704 0.496 1.401 1.064 1.97 1.866 0.563 0.802 0.845 1.059 1.224 1.989 0.508 1.261 0.802 2.625 0.851 3.892 0.067 1.732-0.116 3.06-0.618 4.651-0.496 1.591-1.603 2.772-2.668 3.837s-2.234 1.708-3.593 2.044c-1.365 0.336-2.901 0.667-4.596 0.667l-3.991-0.03-3.8-0.092 0.539-1.42-0.043-17.528c-0.012-0.508-0.251-1.034-0.501-1.922 1.198 0.027 3.224-0.09 4.075-0.09zm-17.797 168.64v-128.02c0-2.846 2.313-5.159 5.159-5.159h144.32c2.846 0 5.159 2.313 5.159 5.159v128.02c0 2.846-2.313 5.159-5.159 5.159h-144.32c-2.846 1e-3 -5.159-2.312-5.159-5.158z\" fill=\"#1a1a1a\"/>\n     <ellipse cx=\"444.94\" cy=\"246.54\" rx=\"25.204\" ry=\"25.115\" fill=\"#fff\"/>\n     <path d=\"m445.3 265.55c10.422 0 18.904-8.482 18.904-18.905s-8.482-18.911-18.904-18.911c-10.429 0-18.911 8.482-18.911 18.911s8.482 18.905 18.911 18.905z\" fill=\"#1a1a1a\"/>\n     <ellipse cx=\"492.88\" cy=\"293.45\" rx=\"25.204\" ry=\"25.115\" fill=\"#fff\"/>\n     <path d=\"m492.9 274.71c-10.429 0-18.911 8.482-18.911 18.911 0 10.428 8.482 18.905 18.911 18.905 10.422 0 18.904-8.482 18.904-18.905s-8.482-18.911-18.904-18.911z\" fill=\"#1a1a1a\"/>\n     <ellipse cx=\"541.23\" cy=\"247.25\" rx=\"25.204\" ry=\"25.115\" fill=\"#fff\"/>\n     <circle cx=\"541.11\" cy=\"247.25\" r=\"18.911\" fill=\"#1a1a1a\"/>\n     <path d=\"m78.855 232.89c21.53 0 39.045-17.515 39.045-39.045s-17.515-39.045-39.045-39.045-39.046 17.515-39.046 39.045 17.522 39.045 39.046 39.045z\" fill=\"#1a1a1a\"/>\n     <polygon transform=\"translate(6.8088,8.7805)\" points=\"124.82 279.67 103.48 279.67 103.48 310.78 72.364 310.78 72.364 332.13 103.48 332.13 103.48 363.25 124.82 363.25 124.82 332.13 155.94 332.13 155.94 310.78 124.82 310.78\" fill=\"#1a1a1a\"/>\n     <polygon transform=\"translate(6.8088,8.7805)\" points=\"318.12 444.41 293.78 403.06 269.44 444.41\" fill=\"#1a1a1a\"/>\n     <polygon transform=\"translate(6.8088,8.7805)\" points=\"124.82 332.13 155.94 332.13 155.94 310.78 124.82 310.78 124.82 279.67 103.48 279.67 103.48 310.78 72.364 310.78 72.364 332.13 103.48 332.13 103.48 363.25 124.82 363.25\" fill=\"#1a1a1a\"/>\n     <ellipse cx=\"409.18\" cy=\"244.08\" rx=\"25.204\" ry=\"25.115\" fill=\"#fff\"/>\n    </g>\n   </g>\n   <path d=\"m444.19 415.9c23.103 0 41.897-18.795 41.897-41.897s-18.794-41.897-41.897-41.897c-23.103 0-41.898 18.795-41.898 41.897s18.802 41.897 41.898 41.897z\" stroke-width=\".86172\"/>\n   <path d=\"m444.19 412.57c21.38 0 38.773-17.297 38.773-38.56 0-21.263-17.393-38.56-38.773-38.56-21.38 0-38.775 17.297-38.775 38.56 0 21.263 17.4 38.56 38.775 38.56z\" fill=\"#ececec\" stroke-width=\".86172\"/>\n   <path d=\"m444.19 407.65c18.553 0 33.646-15.093 33.646-33.646 0-18.553-15.093-33.646-33.646-33.646-18.553 0-33.647 15.093-33.647 33.646 0 18.553 15.099 33.646 33.647 33.646z\" fill=\"#333\" stroke=\"#000\" stroke-width=\"2.9069\" data-button=\"button-11\"/>\n   <path d=\"m78.499 243.34c26.81 0 48.62-21.811 48.62-48.621s-21.81-48.621-48.62-48.621-48.622 21.811-48.622 48.621 21.819 48.621 48.622 48.621z\"/>\n   <path d=\"m78.499 239.47c24.811 0 44.995-20.073 44.995-44.748s-20.184-44.748-44.995-44.748-44.997 20.073-44.997 44.748 20.192 44.748 44.997 44.748z\" fill=\"#ececec\"/>\n   <path d=\"m78.499 233.76c21.53 0 39.045-17.515 39.045-39.045s-17.515-39.045-39.045-39.045-39.046 17.515-39.046 39.045 17.522 39.045 39.046 39.045z\" fill=\"#333\" stroke=\"#000\" stroke-width=\"2.9069\" data-button=\"button-10\"/>\n   <path d=\"m491.78 320.33c14.996 0 27.196-12.2 27.196-27.196s-12.199-27.196-27.196-27.196c-14.996 0-27.197 12.2-27.197 27.196s12.204 27.196 27.197 27.196z\"/>\n   <path d=\"m491.78 317.32c13.408 0 24.317-10.848 24.317-24.183s-10.908-24.183-24.317-24.183c-13.409 0-24.317 10.848-24.317 24.183s10.912 24.183 24.317 24.183z\" fill=\"#ececec\"/>\n   <path d=\"m491.78 314.23c11.635 0 21.101-9.4653 21.101-21.101 0-11.635-9.4653-21.101-21.101-21.101-11.635 0-21.101 9.4653-21.101 21.101 0 11.635 9.4692 21.101 21.101 21.101z\" fill=\"#a02c2c\" data-button=\"button-0\"/>\n   <path d=\"m539.97 273.92c14.738 0 26.727-11.99 26.727-26.728s-11.989-26.728-26.727-26.728c-14.738 0-26.728 11.99-26.728 26.728s11.994 26.728 26.728 26.728z\"/>\n   <path d=\"m539.97 270.95c13.177 0 23.898-10.661 23.898-23.767 0-13.105-10.72-23.767-23.898-23.767s-23.899 10.661-23.899 23.767c0 13.105 10.724 23.767 23.899 23.767z\" fill=\"#ececec\"/>\n   <path d=\"m539.97 267.92c11.435 0 20.738-9.3024 20.738-20.738 0-11.435-9.3024-20.738-20.738-20.738-11.435 0-20.738 9.3024-20.738 20.738 0 11.435 9.3062 20.738 20.738 20.738z\" fill=\"#06f\" data-button=\"button-1\"/>\n   <path d=\"m493.22 227.32c14.738 0 26.727-11.99 26.727-26.728s-11.989-26.728-26.727-26.728c-14.738 0-26.728 11.99-26.728 26.728s11.994 26.728 26.728 26.728z\"/>\n   <path d=\"m493.22 224.36c13.177 0 23.898-10.661 23.898-23.767 0-13.105-10.72-23.767-23.898-23.767s-23.899 10.661-23.899 23.767c0 13.105 10.724 23.767 23.899 23.767z\" fill=\"#ececec\"/>\n   <path d=\"m493.22 221.33c11.435 0 20.738-9.3024 20.738-20.738 0-11.435-9.3024-20.738-20.738-20.738-11.435 0-20.738 9.3024-20.738 20.738 0 11.435 9.3062 20.738 20.738 20.738z\" fill=\"#1ccb1c\" data-button=\"button-3\"/>\n   <path d=\"m444.79 268.33c14.738 0 26.727-11.99 26.727-26.728s-11.989-26.728-26.727-26.728c-14.738 0-26.728 11.99-26.728 26.728s11.994 26.728 26.728 26.728z\"/>\n   <path d=\"m444.79 265.37c13.177 0 23.898-10.661 23.898-23.767 0-13.105-10.72-23.767-23.898-23.767s-23.899 10.661-23.899 23.767c0 13.105 10.724 23.767 23.899 23.767z\" fill=\"#fff\"/>\n   <path d=\"m444.79 262.34c11.435 0 20.738-9.3024 20.738-20.738 0-11.435-9.3024-20.738-20.738-20.738-11.435 0-20.738 9.3024-20.738 20.738 0 11.435 9.3062 20.738 20.738 20.738z\" fill=\"#fa9900\" data-button=\"button-2\"/>\n   <polygon transform=\"matrix(1.7101,0,0,1.7148,-202.93,-294.51)\" points=\"269.44 444.41 318.12 444.41 293.78 403.06\" fill=\"#fff\" stroke=\"#000\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2.0439\"/>\n   <g transform=\"matrix(1.2116 0 0 1.2405 -56.477 -89.866)\" fill=\"#333\" stroke=\"#000\" stroke-width=\"2.3711\">\n    <polygon points=\"269.44 444.41 318.12 444.41 293.78 403.06\" fill=\"#333\" stroke=\"#000\" stroke-width=\"2.3711\" data-button=\"button-9\"/>\n   </g>\n   <text x=\"484.67032\" y=\"210.79993\" fill=\"#000000\" fill-opacity=\".75\" font-family=\"sans-serif\" font-size=\"40px\" letter-spacing=\"0px\" stroke-width=\"1.8197\" word-spacing=\"0px\" style=\"line-height:1.25\" xml:space=\"preserve\"><tspan x=\"484.67032\" y=\"210.79993\" fill=\"#000000\" fill-opacity=\".75\" font-family=\"sans-serif\" font-size=\"28px\" stroke-width=\"1.8197\" style=\"font-variant-caps:normal;font-variant-east-asian:normal;font-variant-ligatures:normal;font-variant-numeric:normal\">Y</tspan></text>\n   <text x=\"435.22971\" y=\"251.80605\" fill=\"#000000\" fill-opacity=\".75\" font-family=\"sans-serif\" font-size=\"40px\" letter-spacing=\"0px\" stroke-width=\"1.8197\" word-spacing=\"0px\" style=\"line-height:1.25\" xml:space=\"preserve\"><tspan x=\"435.22971\" y=\"251.80605\" fill=\"#000000\" fill-opacity=\".75\" font-family=\"sans-serif\" font-size=\"28px\" stroke-width=\"1.8197\" style=\"font-variant-caps:normal;font-variant-east-asian:normal;font-variant-ligatures:normal;font-variant-numeric:normal\">X</tspan></text>\n   <text x=\"531.4353\" y=\"257.39502\" fill=\"#000000\" fill-opacity=\".75\" font-family=\"sans-serif\" font-size=\"40px\" letter-spacing=\"0px\" stroke-width=\"1.8197\" word-spacing=\"0px\" style=\"line-height:1.25\" xml:space=\"preserve\"><tspan x=\"531.4353\" y=\"257.39502\" fill=\"#000000\" fill-opacity=\".75\" font-family=\"sans-serif\" font-size=\"28px\" stroke-width=\"1.8197\" style=\"font-variant-caps:normal;font-variant-east-asian:normal;font-variant-ligatures:normal;font-variant-numeric:normal\">B</tspan></text>\n   <text x=\"482.2132\" y=\"303.34509\" fill=\"#000000\" fill-opacity=\".75\" font-family=\"sans-serif\" font-size=\"40px\" letter-spacing=\"0px\" stroke-width=\"1.8197\" word-spacing=\"0px\" style=\"line-height:1.25\" xml:space=\"preserve\"><tspan x=\"482.2132\" y=\"303.34509\" fill=\"#000000\" fill-opacity=\".75\" font-family=\"sans-serif\" font-size=\"28px\" stroke-width=\"1.8197\" style=\"font-variant-caps:normal;font-variant-east-asian:normal;font-variant-ligatures:normal;font-variant-numeric:normal\">A</tspan></text>\n   <path d=\"m173.25 347.86v-35.975h-35.335v-35.719h-36.421v35.719h-35.602v35.975h35.602v35.944h36.421v-35.944z\" fill=\"#fff\" stroke=\"#000\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-miterlimit=\"6.6\" stroke-width=\"3.1826\"/>\n   <g fill=\"#333\" stroke=\"#000\" stroke-width=\"2.0348\" data-button=\"dpad-0\">\n    <polygon transform=\"matrix(1.1296 0 0 1.1296 -9.6574 -33.438)\" points=\"103.48 363.25 124.82 363.25 124.82 332.13 155.94 332.13 155.94 310.78 124.82 310.78 124.82 279.67 103.48 279.67 103.48 310.78 72.364 310.78 72.364 332.13 103.48 332.13\" fill=\"#333\" stroke=\"#000\" stroke-width=\"1.8014\"/>\n   </g>\n   <path d=\"m246.43 423.18c9.522 0 17.268-7.7465 17.268-17.268 0-9.522-7.7461-17.268-17.268-17.268-9.522 0-17.269 7.7465-17.269 17.268 0 9.522 7.7493 17.268 17.269 17.268z\" stroke-width=\".63497\"/>\n   <path d=\"m246.43 420.5c8.0934 0 14.678-6.5481 14.678-14.597 0-8.0492-6.5842-14.597-14.678-14.597-8.0937 0-14.678 6.5481-14.678 14.597 0 8.0492 6.5869 14.597 14.678 14.597z\" fill=\"#ececec\" stroke-width=\".60362\"/>\n   <path d=\"m246.43 418.33c6.8504 0 12.424-5.5729 12.424-12.424 0-6.8504-5.5729-12.424-12.424-12.424-6.8504 0-12.424 5.5729-12.424 12.424 0 6.8504 5.5752 12.424 12.424 12.424z\" fill=\"#333\" stroke=\"#000\" stroke-width=\"1.4535\" data-button=\"button-8\"/>\n   <path d=\"m352.5 423.18c9.522 0 17.268-7.7465 17.268-17.268 0-9.522-7.7461-17.268-17.268-17.268-9.522 0-17.269 7.7465-17.269 17.268 0 9.522 7.7493 17.268 17.269 17.268z\" stroke-width=\".63497\"/>\n   <path d=\"m352.5 420.5c8.0934 0 14.678-6.5481 14.678-14.597 0-8.0492-6.5842-14.597-14.678-14.597-8.0937 0-14.678 6.5481-14.678 14.597 0 8.0492 6.5869 14.597 14.678 14.597z\" fill=\"#ececec\" stroke-width=\".60362\"/>\n   <path d=\"m352.5 418.33c6.8504 0 12.424-5.5729 12.424-12.424 0-6.8504-5.5729-12.424-12.424-12.424-6.8504 0-12.424 5.5729-12.424 12.424 0 6.8504 5.5752 12.424 12.424 12.424z\" fill=\"#333\" stroke=\"#000\" stroke-width=\"1.4535\" data-button=\"button-16\"/>\n   <text x=\"281.13306\" y=\"481.78577\" fill=\"#000000\" font-family=\"sans-serif\" font-size=\"40px\" letter-spacing=\"0px\" stroke-width=\"1.8191\" word-spacing=\"0px\" style=\"line-height:1.25\" xml:space=\"preserve\"><tspan x=\"281.13306\" y=\"481.78577\" fill=\"#000000\" font-family=\"sans-serif\" font-size=\"11.628px\" stroke-width=\"1.8191\" style=\"font-variant-caps:normal;font-variant-east-asian:normal;font-variant-ligatures:normal;font-variant-numeric:normal\">START</tspan></text>\n   <text x=\"224.14134\" y=\"384.38974\" fill=\"#000000\" font-family=\"sans-serif\" font-size=\"40px\" letter-spacing=\"0px\" stroke-width=\"1.8191\" word-spacing=\"0px\" style=\"line-height:1.25\" xml:space=\"preserve\"><tspan x=\"224.14134\" y=\"384.38974\" fill=\"#000000\" font-family=\"sans-serif\" font-size=\"11.628px\" stroke-width=\"1.8191\" style=\"font-variant-caps:normal;font-variant-east-asian:normal;font-variant-ligatures:normal;font-variant-numeric:normal\">SELECT</tspan></text>\n   <text x=\"334.6618\" y=\"384.38974\" fill=\"#000000\" font-family=\"sans-serif\" font-size=\"40px\" letter-spacing=\"0px\" stroke-width=\"1.8191\" word-spacing=\"0px\" style=\"line-height:1.25\" xml:space=\"preserve\"><tspan x=\"334.6618\" y=\"384.38974\" fill=\"#000000\" font-family=\"sans-serif\" font-size=\"11.628px\" stroke-width=\"1.8191\" style=\"font-variant-caps:normal;font-variant-east-asian:normal;font-variant-ligatures:normal;font-variant-numeric:normal\">HOME</tspan></text>\n  </g>\n </g>\n <g transform=\"translate(-260.34 -473.69)\">\n  <g cv-if = \"a\">\n  \t<path d=\"m591.98 611.79 68.946 20.079\" fill=\"none\" stroke=\"#000\" stroke-width=\".5\"/>\n  </g>\n  <g cv-if = \"x\">\n  \t<path d=\"m576.4 592.1 84.526 24.701\" fill=\"none\" stroke=\"#000\" stroke-width=\".5\"/>\n  </g>\n  <g cv-if = \"y\">\n  \t<path d=\"m595.33 575.12 65.6 18.183\" fill=\"none\" stroke=\"#000\" stroke-width=\".5\"/>\n  </g>\n  <g cv-if = \"b\">\n  \t<path d=\"m609.93 591.65 50.998 15.219\" fill=\"none\" stroke=\"#000\" stroke-width=\".5\"/>\n  </g>\n  <text x=\"662.21619\" y=\"608.90283\" fill=\"#000000\" font-family=\"sans-serif\" font-size=\"40px\" letter-spacing=\"0px\" word-spacing=\"0px\" style=\"line-height:1.25\" xml:space=\"preserve\"><tspan x=\"662.21619\" y=\"608.90283\" font-family=\"sans-serif\" font-size=\"6px\" style=\"font-variant-caps:normal;font-variant-east-asian:normal;font-variant-ligatures:normal;font-variant-numeric:normal\">[[b]]</tspan></text>\n  <text x=\"662.5141\" y=\"634.3454\" fill=\"#000000\" font-family=\"sans-serif\" font-size=\"40px\" letter-spacing=\"0px\" word-spacing=\"0px\" style=\"line-height:1.25\" xml:space=\"preserve\"><tspan x=\"662.5141\" y=\"634.3454\" font-family=\"sans-serif\" font-size=\"6px\" style=\"font-variant-caps:normal;font-variant-east-asian:normal;font-variant-ligatures:normal;font-variant-numeric:normal\">[[a]]</tspan></text>\n  <text x=\"662.27887\" y=\"619.60553\" fill=\"#000000\" font-family=\"sans-serif\" font-size=\"40px\" letter-spacing=\"0px\" word-spacing=\"0px\" style=\"line-height:1.25\" xml:space=\"preserve\"><tspan x=\"662.27887\" y=\"619.60553\" font-family=\"sans-serif\" font-size=\"6px\" style=\"font-variant-caps:normal;font-variant-east-asian:normal;font-variant-ligatures:normal;font-variant-numeric:normal\">[[x]]</tspan></text>\n  <text x=\"661.63348\" y=\"595.76831\" fill=\"#000000\" font-family=\"sans-serif\" font-size=\"40px\" letter-spacing=\"0px\" word-spacing=\"0px\" style=\"line-height:1.25\" xml:space=\"preserve\"><tspan x=\"661.63348\" y=\"595.76831\" font-family=\"sans-serif\" font-size=\"6px\" style=\"font-variant-caps:normal;font-variant-east-asian:normal;font-variant-ligatures:normal;font-variant-numeric:normal\">[[y]]</tspan></text>\n  <g cv-if = \"r1\">\n  \t<path d=\"m605.15 544.5 53.163 13.403\" fill=\"none\" stroke=\"#000\" stroke-width=\".5\"/>\n  </g>\n  <text x=\"659.01825\" y=\"560.35986\" fill=\"#000000\" font-family=\"sans-serif\" font-size=\"40px\" letter-spacing=\"0px\" word-spacing=\"0px\" style=\"line-height:1.25\" xml:space=\"preserve\"><tspan x=\"659.01825\" y=\"560.35986\" font-family=\"sans-serif\" font-size=\"6px\" style=\"font-variant-caps:normal;font-variant-east-asian:normal;font-variant-ligatures:normal;font-variant-numeric:normal\">[[r1]]</tspan></text>\n  <g cv-if = \"ra\">\n  <path d=\"m582.92 636.21 78.008 22.519\" fill=\"none\" stroke=\"#000\" stroke-width=\".5\"/>\n  </g>\n  <text x=\"664.28082\" y=\"661.3197\" fill=\"#000000\" font-family=\"sans-serif\" font-size=\"40px\" letter-spacing=\"0px\" word-spacing=\"0px\" style=\"line-height:1.25\" xml:space=\"preserve\"><tspan x=\"664.28082\" y=\"661.3197\" font-family=\"sans-serif\" font-size=\"6px\" style=\"font-variant-caps:normal;font-variant-east-asian:normal;font-variant-ligatures:normal;font-variant-numeric:normal\">[[ra]]</tspan></text>\n  <g cv-if = \"l1\">\n  \t<path d=\"m426.92 544.08-53.163 13.403\" fill=\"none\" stroke=\"#000\" stroke-width=\".5\"/>\n  </g>\n  <text x=\"347.5455\" y=\"559.51819\" fill=\"#000000\" font-family=\"sans-serif\" font-size=\"40px\" letter-spacing=\"0px\" word-spacing=\"0px\" style=\"line-height:1.25\" xml:space=\"preserve\"><tspan x=\"347.5455\" y=\"559.51819\" font-family=\"sans-serif\" font-size=\"6px\" style=\"font-variant-caps:normal;font-variant-east-asian:normal;font-variant-ligatures:normal;font-variant-numeric:normal\">[[l1]]</tspan></text>\n  <g cv-if = \"dpad\">\n\t<path d=\"m438.09 626.74-67.043 18.472\" fill=\"none\" stroke=\"#000\" stroke-width=\".5\"/>\n  </g>\n  <text x=\"352.86777\" y=\"647.30273\" fill=\"#000000\" font-family=\"sans-serif\" font-size=\"40px\" letter-spacing=\"0px\" word-spacing=\"0px\" style=\"line-height:1.25\" xml:space=\"preserve\"><tspan x=\"352.86777\" y=\"647.30273\" font-family=\"sans-serif\" font-size=\"6px\" style=\"font-variant-caps:normal;font-variant-east-asian:normal;font-variant-ligatures:normal;font-variant-numeric:normal\">[[dpad]]</tspan></text>\n  <g cv-if = \"start\">\n  \t<path d=\"m507.06 652.49-115.69 44.146\" fill=\"none\" stroke=\"#000\" stroke-width=\".5\"/>\n  </g>\n  <text x=\"371.43689\" y=\"698.36121\" fill=\"#000000\" font-family=\"sans-serif\" font-size=\"40px\" letter-spacing=\"0px\" word-spacing=\"0px\" style=\"line-height:1.25\" xml:space=\"preserve\"><tspan x=\"371.43689\" y=\"698.36121\" font-family=\"sans-serif\" font-size=\"6px\" style=\"font-variant-caps:normal;font-variant-east-asian:normal;font-variant-ligatures:normal;font-variant-numeric:normal\">[[start]]</tspan></text>\n </g>\n</svg>\n"
});

;require.register("controller/gamepad-config.html", function(exports, require, module) {
module.exports = "<div class = \"gamepad-config [[animation]] input-[[type]]\">\n\t<span>[[text]]</span>\n\t<div>[[caption]]</div>\n\t<!-- <div class = \"buttons\">\n\t\t<button cv-on = \"click:swap\">next</button>\n\t\t<button cv-on = \"click:exit\">exit</button>\n\t</div> -->\n</div>\n"
});

;require.register("controller/gc-input.svg", function(exports, require, module) {
module.exports = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<svg width=\"512\" height=\"288\" version=\"1.0\" xmlns=\"http://www.w3.org/2000/svg\"><g transform=\"translate(-260.34 -473.69)\"><g transform=\"translate(134.82 68.294)\"><g transform=\"matrix(.06485 0 0 .06485 172.41 452.75)\" stroke-width=\"15.42\"><g stroke-width=\"15.42\" data-button=\"button-6\"><g id=\"Shape_13_copy_1_\" enable-background=\"new    \" fill=\"#2d1650\"><g id=\"Shape_13_copy\" fill=\"#2d1650\" stroke-width=\"15.42\"><g fill=\"#2d1650\" stroke-width=\"15.42\"><ellipse cx=\"2016\" cy=\"596\" rx=\"394.32\" ry=\"416.56\" fill=\"#2d1650\" stroke-width=\"15.42\"/></g></g></g><g id=\"Shape_13_1_\" enable-background=\"new    \"><g stroke-width=\"15.42\"><g stroke-width=\"15.42\"><ellipse cx=\"2016\" cy=\"600\" rx=\"381.55\" ry=\"410.27\" fill=\"#eee\" stroke-width=\"207.68\"/></g></g></g></g><g stroke-width=\"15.42\" data-button=\"button-7\"><g id=\"Shape_13_copy_2_1_\" enable-background=\"new    \" fill=\"#2d1650\"><g fill=\"#2d1650\" stroke-width=\"15.42\"><g fill=\"#2d1650\" stroke-width=\"15.42\"><ellipse cx=\"4444\" cy=\"597\" rx=\"394.32\" ry=\"416.56\" fill=\"#2d1650\" stroke-width=\"15.42\"/></g></g></g><g id=\"Shape_13_copy_3_1_\" enable-background=\"new    \"><g stroke-width=\"15.42\"><g stroke-width=\"15.42\"><ellipse cx=\"4444\" cy=\"601\" rx=\"381.55\" ry=\"410.27\" fill=\"#eee\" stroke-width=\"207.68\"/></g></g></g></g><text transform=\"matrix(.68482 0 0 .68587 845.52 -545.07)\" fill=\"#000000\" fill-opacity=\".75\" font-family=\"sans-serif\" font-size=\"144px\" letter-spacing=\"0px\" stroke-width=\"22.5\" word-spacing=\"0px\" style=\"line-height:1.25;shape-inside:url(#rect1879-3-6-5-2);white-space:pre\" xml:space=\"preserve\"><tspan x=\"5247.6191\" y=\"1275.3691\"><tspan stroke-width=\"22.5\">R</tspan></tspan></text><g stroke-width=\"15.42\" data-button=\"button-5\"><g id=\"Shape_14_copy_1_\" transform=\"translate(63.785 -10.951)\" enable-background=\"new    \"><g id=\"Shape_14_copy\" stroke-width=\"15.42\"><g stroke-width=\"15.42\"><path d=\"m4875.8 533.15c-9.153-20.295-141.3-109.76-312.96-156.14-171.66-46.381-446.05-75.91-470.47-66.579-24.426 9.331-20.68 96.067-20.68 96.067l755.06 236.36c0 1e-3 58.209-89.412 49.057-109.71z\" fill=\"#490094\" stroke-width=\"207.68\"/></g></g></g><g id=\"Shape_14_1_\" transform=\"translate(63.785 -10.951)\" enable-background=\"new    \"><g stroke-width=\"15.42\"><g stroke-width=\"15.42\"><path d=\"m4862.8 543.29c-8.855-19.636-136.71-106.2-302.8-151.08s-431.57-73.446-455.2-64.418-20.008 92.95-20.008 92.95l730.55 228.69s56.319-86.51 47.464-106.15z\" fill=\"#5600ae\" stroke-width=\"207.68\"/></g></g></g></g><g stroke-width=\"15.42\" data-button=\"button-4\"><g transform=\"matrix(-1 0 0 1 6378.1 -10.674)\" enable-background=\"new    \"><g stroke-width=\"15.42\"><g stroke-width=\"15.42\"><path d=\"m4875.8 533.15c-9.153-20.295-141.3-109.76-312.96-156.14-171.66-46.381-446.05-75.91-470.47-66.579-24.426 9.331-20.68 96.067-20.68 96.067l755.06 236.36c0 1e-3 58.209-89.412 49.057-109.71z\" fill=\"#490094\" stroke-width=\"207.68\"/></g></g></g><g transform=\"matrix(-1 0 0 1 6378.1 -10.674)\" enable-background=\"new    \"><g stroke-width=\"15.42\"><g stroke-width=\"15.42\"><path d=\"m4862.8 543.29c-8.855-19.636-136.71-106.2-302.8-151.08s-431.57-73.446-455.2-64.418-20.008 92.95-20.008 92.95l730.55 228.69s56.319-86.51 47.464-106.15z\" fill=\"#5600ae\" stroke-width=\"207.68\"/></g></g></g></g><g id=\"Shape_15_copy_2_1_\" enable-background=\"new    \" stroke-width=\"15.42\"><g fill=\"#2d1650\" stroke-width=\"15.42\"><g fill=\"#2d1650\" stroke-width=\"15.42\"><path d=\"m3227.9 120.17c-783.43 0-1504.4 382.76-1504.4 382.76l447.27 1463.6s200.02-494.06 1045-494.06c807.36 0 1061.2 473.81 1061.2 473.81l423.57-1451.3s-688.92-374.76-1472.6-374.76z\" fill=\"#2d1650\" stroke-width=\"15.42\"/></g></g></g><g id=\"Shape_15_copy_3_1_\" enable-background=\"new    \" fill=\"#442178\" stroke-width=\"15.42\"><g fill=\"#442178\" stroke-width=\"15.42\"><g fill=\"#442178\" stroke-width=\"15.42\"><path d=\"m3228 136c-767.99 0-1504 388-1504 388l460 1390s194.99-457.37 1044-457.37c779.87 0 1036 437.37 1036 437.37l436-1378s-719.98-380-1472-380z\" fill=\"#442178\" stroke-width=\"15.42\"/></g></g></g><text transform=\"matrix(.49661 0 0 .49737 -1067.6 -73.788)\" fill=\"#000000\" fill-opacity=\".75\" font-family=\"sans-serif\" font-size=\"144px\" letter-spacing=\"0px\" stroke-width=\"31.027\" word-spacing=\"0px\" style=\"line-height:1.25;shape-inside:url(#rect1879-3-6-5-2-3-7);white-space:pre\" xml:space=\"preserve\"><tspan x=\"5247.6191\" y=\"1275.3691\"><tspan stroke-width=\"31.027\">ZL</tspan></tspan></text><g id=\"Shape_12_1_\" enable-background=\"new    \" fill=\"#2d1650\" stroke-width=\"15.42\"><g fill=\"#2d1650\" stroke-width=\"15.42\"><g fill=\"#2d1650\" stroke-width=\"15.42\"><path d=\"m1376.2 941.81c-30.5 123.8-80.063 786.99-61.001 1136.3 19.063 349.28 53.376 702.99 282.13 725.09s244-265.28 270.69-371.39c26.688-106.11 163.94-711.83 163.94-711.83s-625.25-901.94-655.75-778.15z\" fill=\"#2d1650\" stroke-width=\"15.42\"/></g></g></g><g id=\"Shape_12_copy_5_1_\" enable-background=\"new    \" fill=\"#442178\" stroke-width=\"15.42\"><g fill=\"#442178\" stroke-width=\"15.42\"><g fill=\"#442178\" stroke-width=\"15.42\"><path d=\"m1387.9 966.73c-28.94 121.04-75.969 769.48-57.881 1111s50.646 687.34 267.7 708.96c217.06 21.614 231.52-259.38 256.85-363.12 25.322-103.75 155.56-695.99 155.56-695.99s-593.28-881.87-622.22-760.83z\" fill=\"#442178\" stroke-width=\"15.42\"/></g></g></g><g id=\"Shape_12_copy_6_1_\" enable-background=\"new    \" fill=\"#2d1650\" stroke-width=\"15.42\"><g fill=\"#2d1650\" stroke-width=\"15.42\"><g fill=\"#2d1650\" stroke-width=\"15.42\"><path d=\"m5071.2 945.81c-31.246-123.8-671.8 778.15-671.8 778.15s140.61 605.72 167.95 711.83c27.34 106.11 42.963 393.5 277.31 371.39s269.5-375.81 289.03-725.09-31.246-1012.5-62.493-1136.3z\" fill=\"#2d1650\" stroke-width=\"15.42\"/></g></g></g><g id=\"Shape_12_copy_7_1_\" enable-background=\"new    \" fill=\"#442178\" stroke-width=\"15.42\"><g fill=\"#442178\" stroke-width=\"15.42\"><g fill=\"#442178\" stroke-width=\"15.42\"><path d=\"m5059.2 970.73c-29.648-121.04-637.45 760.83-637.45 760.83s133.42 592.24 159.36 695.99c25.942 103.75 40.768 384.74 263.13 363.12 222.36-21.615 255.72-367.45 274.25-708.96 18.531-341.51-29.649-989.94-59.297-1111z\" fill=\"#442178\" stroke-width=\"15.42\"/></g></g></g><g id=\"Shape_12_copy_3_1_\" enable-background=\"new    \" fill=\"#2d1650\" stroke-width=\"15.42\"><g fill=\"#2d1650\" stroke-width=\"15.42\"><g fill=\"#2d1650\" stroke-width=\"15.42\"><path d=\"m3049.2 1753.4c-122.76-188.31-176.88-182.53-252.72-305.76-97.796-158.92 14.472-476-199.59-766.22-174.59-236.7-591.61-384.65-941.21-138.62-373.08 262.56-355.83 699.77-175.22 973.89 189.64 287.82 445.08 264.06 582.85 407.41 85.999 89.487 101.86 265.09 203.89 370.36 143.79 148.36 380.24 225.33 639.15 61.496 215.72-136.5 255.61-429.57 142.84-602.55z\" fill=\"#2d1650\" stroke-width=\"15.42\"/></g></g></g><g id=\"Shape_12_copy_1_\" enable-background=\"new    \" fill=\"#442178\" stroke-width=\"15.42\"><g id=\"Shape_12_copy\" fill=\"#442178\" stroke-width=\"15.42\"><g fill=\"#442178\" stroke-width=\"15.42\"><path d=\"m3044 1772c-111.08-187.17-185.56-195.03-260-316-96-156-1.5-502.6-192-760-171.76-232.08-571.05-373.11-920-140-362.3 242.03-364 668-172 956 188.32 282.48 434.64 257.5 568 400 108.42 115.84 111.85 264.14 196 356 154.8 168.97 400.25 242.11 644 68 224-160 208.51-441.82 136-564z\" fill=\"#442178\" stroke-width=\"15.42\"/></g></g></g><g id=\"Shape_12_copy_4_1_\" enable-background=\"new    \" fill=\"#2d1650\" stroke-width=\"15.42\"><g fill=\"#2d1650\" stroke-width=\"15.42\"><g fill=\"#2d1650\" stroke-width=\"15.42\"><path d=\"m4789.3 542.8c-349.6-246.03-766.62-98.079-941.21 138.62-214.06 290.21-101.8 607.3-199.59 766.22-75.836 123.24-129.96 117.45-252.72 305.76-112.77 172.98-72.872 466.05 142.84 602.55 258.9 163.84 495.36 86.859 639.15-61.496 102.03-105.28 117.89-280.87 203.89-370.36 137.77-143.35 393.21-119.59 582.85-407.41 180.61-274.12 197.86-711.33-175.22-973.89z\" fill=\"#2d1650\" stroke-width=\"15.42\"/></g></g></g><g id=\"Shape_12_copy_2_1_\" enable-background=\"new    \" fill=\"#442178\" stroke-width=\"15.42\"><g fill=\"#442178\" stroke-width=\"15.42\"><g fill=\"#442178\" stroke-width=\"15.42\"><path d=\"m4773 556c-348.95-233.11-748.24-92.075-920 140-190.5 257.4-96 604-192 760-74.444 120.97-148.92 128.83-260 316-72.508 122.18-88 404 136 564 243.75 174.11 489.2 100.97 644-68 84.154-91.858 87.58-240.16 196-356 133.36-142.5 379.68-117.52 568-400 192-288 190.3-713.97-172-956z\" fill=\"#442178\" stroke-width=\"15.42\"/></g></g></g><g fill=\"#2d1650\" stroke-width=\"15.42\"><g fill=\"#2d1650\" stroke-width=\"15.42\"><ellipse cx=\"2064\" cy=\"1112\" rx=\"475.27\" ry=\"470.42\" fill=\"#2d1650\" stroke-width=\"15.42\"/></g></g><g id=\"Shape_2_copy\" fill=\"#442178\" stroke-width=\"15.42\"><g fill=\"#442178\" stroke-width=\"15.42\"><ellipse cx=\"2064\" cy=\"1112\" rx=\"463.16\" ry=\"458.44\" fill=\"#442178\" stroke-width=\"15.42\"/></g></g><g stroke-width=\"15.42\"><g stroke-width=\"15.42\"><path d=\"m2277.5 911.54c-16.518-16.517-171.99-88.264-210.78-88.264-38.798 0-189.87 67.706-210.24 88.074-21.36 21.361-87.389 180.22-88.395 211.24-0.982 30.301 63.237 186.73 87.045 210.53 26.177 26.177 171.71 85.496 210.51 86.467 38.797 0.97 184.9-64.136 209.77-86.1 25.23-22.284 89.316-181.15 89.316-211.28-1e-3 -30.067-68.831-192.28-87.223-210.68z\" stroke-width=\"15.42\"/></g></g><g stroke-width=\"15.42\"><g stroke-width=\"15.42\"><path d=\"m2271 917.95c-16.014-16.014-166.74-85.57-204.35-85.57s-184.07 65.64-203.82 85.386c-20.709 20.709-84.722 174.72-85.696 204.8-0.952 29.376 61.307 181.03 84.389 204.11 25.377 25.377 166.47 82.886 204.08 83.827 37.613 0.939 179.26-62.179 203.36-83.472 24.46-21.604 86.591-175.62 86.591-204.83 0-29.15-66.729-186.42-84.561-204.25z\" fill=\"#d1d1d1\" stroke-width=\"207.68\"/></g></g><g stroke-width=\"15.42\" data-button=\"button-10\"><g><g stroke-width=\"15.42\"><ellipse cx=\"2065.6\" cy=\"1124.9\" rx=\"248.44\" ry=\"238.77\" stroke-width=\"15.42\"/></g></g><g id=\"Shape_1_copy\"><g stroke-width=\"15.42\"><ellipse cx=\"2065.6\" cy=\"1124.9\" rx=\"234.29\" ry=\"225.17\" fill=\"#eee\" stroke-width=\"207.68\"/></g></g><g><g stroke-width=\"15.42\"><ellipse cx=\"2064.1\" cy=\"1125.8\" rx=\"211.47\" ry=\"199.69\" fill=\"#acacac\" stroke-width=\"207.68\"/></g></g><g><g stroke-width=\"15.42\"><ellipse cx=\"2064.1\" cy=\"1125.8\" rx=\"199.43\" ry=\"188.32\" fill=\"#eee\" stroke-width=\"207.68\"/></g></g><g><g stroke-width=\"15.42\"><ellipse cx=\"2063.9\" cy=\"1131.1\" rx=\"135.66\" ry=\"128.1\" fill=\"#acacac\" stroke-width=\"207.68\"/></g></g><g><g stroke-width=\"15.42\"><ellipse cx=\"2063.9\" cy=\"1131.1\" rx=\"123.95\" ry=\"117.04\" fill=\"#eee\" stroke-width=\"207.68\"/></g></g><g><g stroke-width=\"15.42\"><ellipse cx=\"2066\" cy=\"1131\" rx=\"53.975\" ry=\"50.966\" fill=\"#acacac\" stroke-width=\"207.68\"/></g></g><g><g stroke-width=\"15.42\"><ellipse cx=\"2066\" cy=\"1131\" rx=\"42.118\" ry=\"39.771\" fill=\"#eee\" stroke-width=\"207.68\"/></g></g></g><g stroke-width=\"15.42\"><g stroke-width=\"15.42\"><path d=\"m4035.5 1760.5c-16.518-16.517-171.99-88.264-210.78-88.264-38.798 0-189.87 67.706-210.24 88.074-21.361 21.361-87.389 180.22-88.395 211.24-0.982 30.301 63.237 186.73 87.045 210.53 26.177 26.177 171.71 85.496 210.51 86.466 38.798 0.971 184.9-64.135 209.77-86.099 25.229-22.284 89.316-181.15 89.316-211.28 0-30.067-68.831-192.28-87.223-210.68z\" stroke-width=\"15.42\"/></g></g><g stroke-width=\"15.42\"><g stroke-width=\"15.42\"><path d=\"m4029 1767c-16.014-16.014-166.74-85.57-204.35-85.57s-184.07 65.64-203.82 85.386c-20.709 20.709-84.722 174.72-85.696 204.8-0.952 29.376 61.307 181.03 84.389 204.11 25.377 25.377 166.47 82.886 204.08 83.827 37.613 0.939 179.26-62.179 203.36-83.472 24.46-21.604 86.591-175.62 86.591-204.83 0-29.15-66.729-186.42-84.561-204.25z\" fill=\"#ffe400\" stroke-width=\"207.68\"/></g></g><g data-button=\"button-11\"><g stroke-width=\"15.42\"><g stroke-width=\"15.42\"><circle cx=\"3824\" cy=\"1976\" r=\"144\" fill=\"#5f5500\" stroke-width=\"207.68\"/></g></g><g id=\"Shape_9_copy\" stroke-width=\"15.42\"><g stroke-width=\"15.42\"><circle cx=\"3824\" cy=\"1976\" r=\"128\" fill=\"#ffe400\" stroke-width=\"207.68\"/></g></g><text transform=\"matrix(.68482 0 0 .68587 195.81 1137.2)\" fill=\"#000000\" fill-opacity=\".75\" font-family=\"sans-serif\" font-size=\"144px\" letter-spacing=\"0px\" stroke-width=\"22.5\" word-spacing=\"0px\" style=\"line-height:1.25;shape-inside:url(#rect1879-3-6-5-2-7);white-space:pre\" xml:space=\"preserve\"><tspan x=\"5247.6191\" y=\"1275.3691\"><tspan stroke-width=\"22.5\">C</tspan></tspan></text></g><text x=\"3826.5161\" y=\"1970.2391\" fill=\"#000000\" font-family=\"sans-serif\" font-size=\"40px\" letter-spacing=\"0px\" stroke-width=\"15.42\" word-spacing=\"0px\" style=\"line-height:1.25\" xml:space=\"preserve\"><tspan x=\"3826.5161\" y=\"1970.2391\" stroke-width=\"15.42\"/></text><g fill=\"#2d1650\" stroke-width=\"15.42\"><g fill=\"#2d1650\" stroke-width=\"15.42\"><ellipse cx=\"2626.5\" cy=\"1976.9\" rx=\"320.41\" ry=\"317.14\" fill=\"#2d1650\" stroke-width=\"15.42\"/></g></g><g fill=\"#442178\" stroke-width=\"15.42\"><g fill=\"#442178\" stroke-width=\"15.42\"><ellipse cx=\"2626.5\" cy=\"1976.9\" rx=\"312.25\" ry=\"309.06\" fill=\"#442178\" stroke-width=\"15.42\"/></g></g><g stroke-width=\"15.42\"><g stroke-width=\"15.42\"><polygon points=\"2870.6 1901.9 2709.5 1901.9 2709.5 1737.1 2545.8 1737.1 2545.9 1899.5 2387.3 1899.5 2387.3 2055.9 2544.8 2057.1 2544.8 2221.9 2707.3 2221.9 2708.5 2054.7 2870.6 2053.5\" stroke-width=\"15.42\"/></g></g><g stroke-width=\"15.42\" data-button=\"dpad-0\"><g id=\"Shape_4_copy\"><g stroke-width=\"15.42\"><polygon points=\"2860.2 1911 2700.8 1911 2700.8 1747.6 2554.2 1747.6 2554.4 1908.7 2396.1 1908.7 2396.1 2047.5 2554.1 2048.7 2554.3 2211.4 2698.2 2211.4 2699.6 2046.4 2860.2 2045.3\" fill=\"#eaeaea\" stroke-width=\"207.68\"/></g></g><g><g stroke-width=\"15.42\"><polygon points=\"2674.2 1862 2627.3 1780.1 2578.7 1862\" fill=\"#c7c7c7\" stroke-width=\"207.68\"/></g></g><g id=\"Shape_5_copy\"><g stroke-width=\"15.42\"><polygon points=\"2674.2 2103 2578.7 2103 2627.3 2184.9\" fill=\"#c7c7c7\" stroke-width=\"207.68\"/></g></g><g><g stroke-width=\"15.42\"><polygon points=\"2506 1934.7 2424 1981.7 2506 2030.3\" fill=\"#c7c7c7\" stroke-width=\"207.68\"/></g></g><g><g stroke-width=\"15.42\"><polygon points=\"2828.9 1981.7 2747 1934.7 2747 2030.3\" fill=\"#c7c7c7\" stroke-width=\"207.68\"/></g></g><g><g stroke-width=\"15.42\"><circle cx=\"2626.9\" cy=\"1979.4\" r=\"48.647\" fill=\"#c7c7c7\" stroke-width=\"207.68\"/></g></g></g><g id=\"Shape_6_copy_1_\" enable-background=\"new    \" stroke-width=\"15.42\"><g id=\"Shape_6_copy\" stroke-width=\"15.42\"></g></g><g id=\"START_x2F_PAUSE\" transform=\"matrix(1.4379 0 0 1.1683 -1075.9 -163.29)\" enable-background=\"new    \" stroke-width=\"11.898\"><text transform=\"matrix(.7382 0 0 1 3021.6 1148)\" font-family=\"KhmerUI-Bold\" font-size=\"86.409px\" stroke-width=\"160.24\">START</text></g><g fill=\"#2d1650\" stroke-width=\"15.42\"><g fill=\"#2d1650\" stroke-width=\"15.42\"><ellipse cx=\"4403.4\" cy=\"1112\" rx=\"475.27\" ry=\"470.42\" fill=\"#2d1650\" stroke-width=\"15.42\"/></g></g><g fill=\"#442178\" stroke-width=\"15.42\"><g fill=\"#442178\" stroke-width=\"15.42\"><ellipse cx=\"4403.4\" cy=\"1112\" rx=\"463.16\" ry=\"458.44\" fill=\"#442178\" stroke-width=\"15.42\"/></g></g><g stroke-width=\"15.42\" data-button=\"button-0\"><g id=\"Shape_7_copy\"><g stroke-width=\"15.42\"><circle cx=\"4408\" cy=\"1104\" r=\"240\" stroke-width=\"15.42\"/></g></g><g><g stroke-width=\"15.42\"><circle cx=\"4408\" cy=\"1104\" r=\"224\" fill=\"#00bc8e\" stroke-width=\"207.68\"/></g></g></g><g stroke-width=\"15.42\" data-button=\"button-2\"><g><g stroke-width=\"15.42\"><circle cx=\"3968\" cy=\"1336\" r=\"148\" stroke-width=\"15.42\"/></g></g><g id=\"Shape_8_copy\"><g stroke-width=\"15.42\"><circle cx=\"3968\" cy=\"1336\" r=\"130\" fill=\"#f00\" stroke-width=\"207.68\"/></g></g></g><g stroke-width=\"15.42\" data-button=\"button-3\"><g><g stroke-width=\"15.42\"><path d=\"m4206 614c-40 18-216 108-140 216 94 100 146-2 226-40 104-40 210 18 210-118-8-128-256-76-296-58z\" stroke-width=\"15.42\"/></g></g><g id=\"Shape_10_copy\"><g stroke-width=\"15.42\"><path d=\"m4487.3 672.68c-8.889-112.4-236.65-62.308-273.91-45.485s-207.07 96.898-134.67 194.16c83.202 86.025 136.64-11.178 211.14-46.641 96.962-37.559 200.88 15.784 197.44-102.04z\" fill=\"#eaeaea\" stroke-width=\"207.68\"/></g></g></g><g stroke-width=\"15.42\" data-button=\"button-1\"><g><g stroke-width=\"15.42\"><path d=\"m4910.5 905.72c-18-40-108-216-216-140-100 94 2 146 40 226 40 104-18 210 118 210 128-8 76-256 58-296z\" stroke-width=\"15.42\"/></g></g><g><g stroke-width=\"15.42\"><path d=\"m4897.3 913.11c-16.822-37.264-96.897-207.07-194.16-134.67-86.025 83.202 11.178 136.64 46.641 211.14 37.56 96.962-15.783 200.88 102.04 197.44 112.4-8.888 62.308-236.64 45.485-273.91z\" fill=\"#eaeaea\" stroke-width=\"207.68\"/></g></g></g><text transform=\"translate(-888.84 -118.88)\" fill=\"#000000\" fill-opacity=\".75\" font-family=\"sans-serif\" font-size=\"144px\" letter-spacing=\"0px\" stroke-width=\"15.42\" word-spacing=\"0px\" style=\"line-height:1.25;shape-inside:url(#rect1879-3);white-space:pre\" xml:space=\"preserve\"><tspan x=\"5247.6191\" y=\"1275.3691\"><tspan fill=\"#000000\" fill-opacity=\".75\" stroke-width=\"15.42\" style=\"shape-inside:url(#rect1879-3)\">A</tspan></tspan></text><text transform=\"translate(-1331 113.12)\" fill=\"#000000\" fill-opacity=\".75\" font-family=\"sans-serif\" font-size=\"144px\" letter-spacing=\"0px\" stroke-width=\"15.42\" word-spacing=\"0px\" style=\"line-height:1.25;shape-inside:url(#rect1879-3-6);white-space:pre\" xml:space=\"preserve\"><tspan x=\"5247.6191\" y=\"1275.3691\"><tspan stroke-width=\"15.42\">B</tspan></tspan></text><text transform=\"matrix(.88915 0 0 .88915 -425.56 -389.36)\" fill=\"#000000\" fill-opacity=\".75\" font-family=\"sans-serif\" font-size=\"144px\" letter-spacing=\"0px\" stroke-width=\"17.343\" word-spacing=\"0px\" style=\"line-height:1.25;shape-inside:url(#rect1879-3-6-5);white-space:pre\" xml:space=\"preserve\"><tspan x=\"5247.6191\" y=\"1275.3691\"><tspan stroke-width=\"17.343\">Y</tspan></tspan></text><text transform=\"translate(-479.38 -261.09)\" fill=\"#000000\" fill-opacity=\".75\" font-family=\"sans-serif\" font-size=\"144px\" letter-spacing=\"0px\" stroke-width=\"15.42\" word-spacing=\"0px\" style=\"line-height:1.25;shape-inside:url(#rect1879-3-6-5-5);white-space:pre\" xml:space=\"preserve\"><tspan x=\"5247.6191\" y=\"1275.3691\"><tspan stroke-width=\"15.42\">X</tspan></tspan></text><text transform=\"matrix(.68482 0 0 .68587 -1678.4 -545.07)\" fill=\"#000000\" fill-opacity=\".75\" font-family=\"sans-serif\" font-size=\"144px\" letter-spacing=\"0px\" stroke-width=\"22.5\" word-spacing=\"0px\" style=\"line-height:1.25;shape-inside:url(#rect1879-3-6-5-2-1);white-space:pre\" xml:space=\"preserve\"><tspan x=\"5247.6191\" y=\"1275.3691\"><tspan stroke-width=\"22.5\">L</tspan></tspan></text><text transform=\"matrix(.49661 0 0 .49737 2207.6 -73.254)\" fill=\"#000000\" fill-opacity=\".75\" font-family=\"sans-serif\" font-size=\"144px\" letter-spacing=\"0px\" stroke-width=\"31.027\" word-spacing=\"0px\" style=\"line-height:1.25;shape-inside:url(#rect1879-3-6-5-2-3);white-space:pre\" xml:space=\"preserve\"><tspan x=\"5247.6191\" y=\"1275.3691\"><tspan stroke-width=\"31.027\">ZR</tspan></tspan></text><g stroke-width=\"15.42\" data-button=\"button-16\"><g transform=\"translate(-1196 -395.27)\"><g stroke-width=\"15.42\"><circle cx=\"4408\" cy=\"1104\" r=\"240\" stroke-width=\"15.42\"/></g></g><g><g transform=\"translate(-1196 -395.27)\" stroke-width=\"15.42\"><circle cx=\"4408\" cy=\"1104\" r=\"224\" fill=\"#ebebeb\" stroke-width=\"207.68\"/></g></g></g><path d=\"m3170.6 561.51c-21.814 12.496-54.583 31.25-72.82 41.674l-33.157 18.954-0.026 170.4 72.068 42.783c39.638 23.53 73.022 43.032 74.185 43.336 1.3821 0.36118 17.016-8.291 45.019-24.916 23.596-14.009 56.552-33.525 73.235-43.371l30.335-17.901v-85.002c0-79.864-0.1179-84.957-1.9466-84.255-1.0711 0.41057-18.804 11.009-39.407 23.553-20.603 12.543-37.97 22.797-38.594 22.787-0.6235-0.0103-16.148-9.5256-34.499-21.145l-33.366-21.125-5.2696 3.0995c-2.8975 1.7042-17.847 10.754-33.219 20.109l-27.95 17.01 0.016 41.958 0.017 41.959 32.606 18.428c17.933 10.135 33.345 18.407 34.249 18.382 0.9044-0.025 16.698-8.3971 35.096-18.605l33.454-18.56 0.317-14.198 0.3162-14.199 14.426-8.7472c7.9335-4.8111 14.808-8.961 15.276-9.2219 0.4673-0.26094 0.8397 13.971 0.827 31.628l-0.023 32.102-50.01 29.247-50.01 29.246-26.228-15.523c-14.425-8.5379-37.327-22.118-50.893-30.176l-24.665-14.654v-116.2l50.068-28.856c27.537-15.871 50.482-29.02 50.988-29.22 0.5064-0.19976 15.973 8.6028 34.372 19.562 18.398 10.959 33.999 19.925 34.668 19.925 1.8597 0 46.5-27.347 46.5-28.486 0-0.54913-0.5337-0.99804-1.186-0.99804s-26.117-14.289-56.588-31.752c-30.471-17.464-56.103-31.752-56.96-31.752-0.8573 0-19.406 10.224-41.22 22.721\" fill-opacity=\".75\" fill-rule=\"evenodd\" stroke-width=\"237.78\"/><g transform=\"translate(9.424)\" data-button=\"button-8\"><g transform=\"matrix(.58703 0 0 .58703 695.18 537.14)\" stroke-width=\"26.268\"><g stroke-width=\"26.268\"><circle cx=\"3968\" cy=\"1336\" r=\"148\" stroke-width=\"26.268\"/></g></g><g transform=\"translate(-943.5 -14.586)\" stroke-width=\"15.42\"><g stroke-width=\"15.42\"><circle cx=\"3968\" cy=\"1336\" r=\"76.314\" fill=\"#ebebeb\" stroke-width=\"207.68\"/></g></g></g><g transform=\"matrix(1.4379 0 0 1.1683 -1486.6 -163.29)\" enable-background=\"new    \" stroke-width=\"11.898\"><text transform=\"matrix(.7382 0 0 1 3021.6 1148)\" font-family=\"KhmerUI-Bold\" font-size=\"86.409px\" stroke-width=\"160.24\">SELECT</text></g><g data-button=\"button-9\"><g transform=\"matrix(.58703 0 0 .58703 1084.2 537.14)\" stroke-width=\"26.268\"><g stroke-width=\"26.268\"><circle cx=\"3968\" cy=\"1336\" r=\"148\" stroke-width=\"26.268\"/></g></g><g transform=\"translate(-554.5 -14.586)\" stroke-width=\"15.42\"><g stroke-width=\"15.42\"><circle cx=\"3968\" cy=\"1336\" r=\"76.314\" fill=\"#ebebeb\" stroke-width=\"207.68\"/></g></g></g></g></g></g><g transform=\"translate(-260.34 -473.69)\"><g cv-if = \"ra\"><path d=\"m567.54 648.99h103.15\" fill=\"none\" stroke=\"#000\" stroke-width=\".5\"/></g><g cv-if = \"dpad\"><path d=\"m374.56 649.32h103.15\" fill=\"none\" stroke=\"#000\" stroke-width=\".5\"/></g><g cv-if = \"a\"><path d=\"m596.71 592.91h91.882\" fill=\"none\" stroke=\"#000\" stroke-width=\".5\"/></g><g cv-if = \"b\"><path d=\"m568.05 607.66h103.15\" fill=\"none\" stroke=\"#000\" stroke-width=\".5\"/></g><g><g cv-if = \"y\"><path d=\"m589.13 565.7h99.459\" fill=\"none\" stroke=\"#000\" stroke-width=\".5\"/></g><g cv-if = \"x\"><path d=\"m622.99 583.02h65.606\" fill=\"none\" stroke=\"#000\" stroke-width=\".5\"/></g><g cv-if = \"r1\"><path d=\"m628.97 554.91h59.627\" fill=\"none\" stroke=\"#000\" stroke-width=\".5\"/></g><g cv-if = \"start\"><path d=\"m528.6 591.28v-82.736\" fill=\"none\" stroke=\"#000\" stroke-width=\".5\"/></g><text x=\"519.64154\" y=\"506.8317\" fill=\"#000000\" font-family=\"sans-serif\" font-size=\"40px\" letter-spacing=\"0px\" word-spacing=\"0px\" style=\"line-height:1.25\" xml:space=\"preserve\"><tspan x=\"519.64154\" y=\"506.8317\" font-family=\"sans-serif\" font-size=\"6px\" style=\"font-variant-caps:normal;font-variant-east-asian:normal;font-variant-ligatures:normal;font-variant-numeric:normal\">[[start]]</tspan></text><text x=\"674.04346\" y=\"651.5755\" fill=\"#000000\" font-family=\"sans-serif\" font-size=\"40px\" letter-spacing=\"0px\" word-spacing=\"0px\" style=\"line-height:1.25\" xml:space=\"preserve\"><tspan x=\"674.04346\" y=\"651.5755\" font-family=\"sans-serif\" font-size=\"6px\" style=\"font-variant-caps:normal;font-variant-east-asian:normal;font-variant-ligatures:normal;font-variant-numeric:normal\">[[ra]]</tspan></text><text x=\"673.08386\" y=\"609.31451\" fill=\"#000000\" font-family=\"sans-serif\" font-size=\"40px\" letter-spacing=\"0px\" word-spacing=\"0px\" style=\"line-height:1.25\" xml:space=\"preserve\"><tspan x=\"673.08386\" y=\"609.31451\" font-family=\"sans-serif\" font-size=\"6px\" style=\"font-variant-caps:normal;font-variant-east-asian:normal;font-variant-ligatures:normal;font-variant-numeric:normal\">[[b]]</tspan></text><text x=\"691.40167\" y=\"594.74054\" fill=\"#000000\" font-family=\"sans-serif\" font-size=\"40px\" letter-spacing=\"0px\" word-spacing=\"0px\" style=\"line-height:1.25\" xml:space=\"preserve\"><tspan x=\"691.40167\" y=\"594.74054\" font-family=\"sans-serif\" font-size=\"6px\" style=\"font-variant-caps:normal;font-variant-east-asian:normal;font-variant-ligatures:normal;font-variant-numeric:normal\">[[a]]</tspan></text><text x=\"690.66138\" y=\"584.66785\" fill=\"#000000\" font-family=\"sans-serif\" font-size=\"40px\" letter-spacing=\"0px\" word-spacing=\"0px\" style=\"line-height:1.25\" xml:space=\"preserve\"><tspan x=\"690.66138\" y=\"584.66785\" font-family=\"sans-serif\" font-size=\"6px\" style=\"font-variant-caps:normal;font-variant-east-asian:normal;font-variant-ligatures:normal;font-variant-numeric:normal\">[[x]]</tspan></text><text x=\"691.40601\" y=\"567.63531\" fill=\"#000000\" font-family=\"sans-serif\" font-size=\"40px\" letter-spacing=\"0px\" word-spacing=\"0px\" style=\"line-height:1.25\" xml:space=\"preserve\"><tspan x=\"691.40601\" y=\"567.63531\" font-family=\"sans-serif\" font-size=\"6px\" style=\"font-variant-caps:normal;font-variant-east-asian:normal;font-variant-ligatures:normal;font-variant-numeric:normal\">[[y]]</tspan></text><text x=\"690.68622\" y=\"557.03937\" fill=\"#000000\" font-family=\"sans-serif\" font-size=\"40px\" letter-spacing=\"0px\" word-spacing=\"0px\" style=\"line-height:1.25\" xml:space=\"preserve\"><tspan x=\"690.68622\" y=\"557.03937\" font-family=\"sans-serif\" font-size=\"6px\" style=\"font-variant-caps:normal;font-variant-east-asian:normal;font-variant-ligatures:normal;font-variant-numeric:normal\">[[r1]]</tspan></text><g cv-if = \"l1\"><path d=\"m342.83 555.19h59.627\" fill=\"none\" stroke=\"#000\" stroke-width=\".5\"/></g><text x=\"315.89267\" y=\"557.19037\" fill=\"#000000\" font-family=\"sans-serif\" font-size=\"40px\" letter-spacing=\"0px\" word-spacing=\"0px\" style=\"line-height:1.25\" xml:space=\"preserve\"><tspan x=\"315.89267\" y=\"557.19037\" font-family=\"sans-serif\" font-size=\"6px\" style=\"font-variant-caps:normal;font-variant-east-asian:normal;font-variant-ligatures:normal;font-variant-numeric:normal\">[[l1]]</tspan></text><text x=\"354.72061\" y=\"651.14825\" fill=\"#000000\" font-family=\"sans-serif\" font-size=\"40px\" letter-spacing=\"0px\" word-spacing=\"0px\" style=\"line-height:1.25\" xml:space=\"preserve\"><tspan x=\"354.72061\" y=\"651.14825\" font-family=\"sans-serif\" font-size=\"6px\" style=\"font-variant-caps:normal;font-variant-east-asian:normal;font-variant-ligatures:normal;font-variant-numeric:normal\">[[dpad]]</tspan></text></g></svg>\n"
});

;require.register("controller/kb-input.html", function(exports, require, module) {
module.exports = "<section cv-each = \"lines:line\">[[line]]</section>\n"
});

;require.register("controller/ps3-input.svg", function(exports, require, module) {
module.exports = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<svg width=\"512\" height=\"288\" version=\"1.0\"\n\txmlns=\"http://www.w3.org/2000/svg\">\n\t<g transform=\"translate(-260.34 -473.69)\">\n\t\t<g transform=\"translate(134.82 68.294)\">\n\t\t\t<path d=\"m435.57 481.84h33.046l-2.5898-4.9919c-1.698-3.2729-6.1119-5.7018-13.933-5.7018-7.8212 0-12.235 2.4289-13.933 5.7018z\" fill=\"#7a7a7a\" fill-rule=\"evenodd\" stroke=\"#000\" stroke-width=\"1.0793\" data-button=\"button-7\"/>\n\t\t\t<path d=\"m293.22 481.84h33.046l-2.5898-4.9919c-1.698-3.2729-6.1119-5.7018-13.933-5.7018-7.8212 0-12.235 2.4289-13.933 5.7018z\" fill=\"#7a7a7a\" fill-rule=\"evenodd\" stroke=\"#000\" stroke-width=\"1.0793\" data-button=\"button-6\"/>\n\t\t\t<path d=\"m320.62 497.85c-1.5358 0-2.75 1.2454-2.75 2.7812v73.156c0 1.5358 1.2142 2.75 2.75 2.75h121.78c1.5358 0 2.7812-1.2142 2.7812-2.75v-73.156c0-1.5358-1.2454-2.7812-2.7812-2.7812h-52.808c-0.2723 0.44907-0.77809 0.75-1.3438 0.75h-14.312c-0.56415 0-1.0398-0.30294-1.3125-0.75z\" fill=\"#3f3f3f\" fill-rule=\"evenodd\" stroke=\"#000\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/>\n\t\t\t<rect x=\"324.17\" y=\"504.14\" width=\"114.69\" height=\"68.484\" rx=\"2.7723\" ry=\"2.6797\" fill=\"#262626\" fill-rule=\"evenodd\"/>\n\t\t\t<path d=\"m272.94 520.34c-5.4902 30.065-9.0709 62.226-11.765 76.34-4.2253 22.138 32.77 40.747 46.797 15.163 10.649-19.422 22.745-44.183 22.745-44.183z\" fill=\"#262626\" fill-rule=\"evenodd\" stroke=\"#000\"/>\n\t\t\t<path d=\"m435.52 483.74h33.15l-2.598-4.2714c-1.7033-2.8005-6.1312-4.8789-13.977-4.8789-7.8459 0-12.274 2.0784-13.977 4.8789z\" fill=\"#7a7a7a\" fill-rule=\"evenodd\" stroke=\"#000\" data-button=\"button-5\"/>\n\t\t\t<path d=\"m293.16 483.74h33.15l-2.598-4.2714c-1.7033-2.8005-6.1312-4.8789-13.977-4.8789-7.8459 0-12.274 2.0784-13.977 4.8789z\" fill=\"#7a7a7a\" fill-rule=\"evenodd\" stroke=\"#000\" data-button=\"button-4\"/>\n\t\t\t<path d=\"m330.59 504.54c-1.6994-10.98-2.4837-16.471-3.268-20.523-0.78432-4.0523-7.7124-6.1438-17.582-6.1438s-16.797 2.0915-17.582 6.1438c-0.78431 4.0523-1.5686 9.5425-3.268 20.523\" fill=\"#262626\" fill-rule=\"evenodd\" stroke=\"#000\"/>\n\t\t\t<circle cx=\"309.8\" cy=\"529.75\" r=\"37.909\" fill=\"#333\" fill-rule=\"evenodd\" stroke=\"#000\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/>\n\t\t\t<path d=\"m472.94 504.54c-1.6994-10.98-2.4837-16.471-3.268-20.523-0.78432-4.0523-7.7124-6.1438-17.582-6.1438s-16.797 2.0915-17.582 6.1438c-0.78431 4.0523-1.5686 9.5425-3.268 20.523\" fill=\"#262626\" fill-rule=\"evenodd\" stroke=\"#000\"/>\n\t\t\t<circle cx=\"346.14\" cy=\"566.61\" r=\"24.052\" fill=\"#333\" fill-rule=\"evenodd\" stroke=\"#000\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/>\n\t\t\t<circle cx=\"346.14\" cy=\"566.61\" r=\"18.562\" fill-opacity=\".51852\" fill-rule=\"evenodd\" stroke=\"#000\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/>\n\t\t\t<circle cx=\"346.14\" cy=\"566.61\" r=\"16.209\" fill=\"#3b3b3b\" fill-rule=\"evenodd\" stroke=\"#000\" stroke-linecap=\"round\" stroke-linejoin=\"round\" data-button=\"left-stick button-10\"/>\n\t\t\t<path d=\"m490.08 520.34c5.4902 30.065 9.0709 62.749 11.765 76.34 4.3818 22.107-32.77 40.747-46.797 15.163-10.649-19.422-22.745-44.183-22.745-44.183z\" fill=\"#262626\" fill-rule=\"evenodd\" stroke=\"#000\"/>\n\t\t\t<circle transform=\"scale(-1,1)\" cx=\"-453.21\" cy=\"529.75\" r=\"37.909\" fill=\"#333\" fill-rule=\"evenodd\" stroke=\"#000\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/>\n\t\t\t<path d=\"m445.43 501.73c-1.5358 0-2.7812 1.2454-2.7812 2.7812v14.656h-14.688c-1.5358 0-2.75 1.2454-2.75 2.7812v15.594c0 1.5358 1.2142 2.7812 2.75 2.7812h14.688v14.656c0 1.5358 1.2454 2.7812 2.7812 2.7812h15.594c1.5358 0 2.75-1.2454 2.75-2.7812v-14.656h14.688c1.5358 0 2.75-1.2454 2.75-2.7812v-15.594c0-1.5358-1.2142-2.7812-2.75-2.7812h-14.688v-14.656c0-1.5358-1.2142-2.7812-2.75-2.7812z\" fill=\"#262626\" fill-rule=\"evenodd\"/>\n\t\t\t<rect x=\"353.46\" y=\"530.28\" width=\"11.634\" height=\"6.6667\" rx=\"1.5686\" ry=\"1.5686\" fill=\"#595959\" fill-rule=\"evenodd\" stroke=\"#000\" stroke-linecap=\"round\" stroke-linejoin=\"round\" data-button=\"button-8\"/>\n\t\t\t<path d=\"m407.19 533.61-8.4967 3.3333c-0.80899 0.31737-1.5686-0.69961-1.5686-1.5686v-3.5294c0-0.86902 0.75963-1.886 1.5686-1.5686z\" fill=\"#595959\" fill-rule=\"evenodd\" stroke=\"#000\" stroke-linecap=\"round\" stroke-linejoin=\"round\" data-button=\"button-9\"/>\n\t\t\t<circle cx=\"382.48\" cy=\"551.32\" r=\"7.9347\" fill=\"#595959\" fill-rule=\"evenodd\" stroke=\"#000\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"1.3796\" data-button=\"button-16\"/>\n\t\t\t<circle cx=\"453.21\" cy=\"512.1\" r=\"8.2353\" fill=\"#5a5a5a\" fill-rule=\"evenodd\" stroke=\"#454545\" stroke-linecap=\"round\" stroke-linejoin=\"round\" data-button=\"button-3\"/>\n\t\t\t<circle cx=\"453.21\" cy=\"547.53\" r=\"8.2353\" fill=\"#5a5a5a\" fill-rule=\"evenodd\" stroke=\"#454545\" stroke-linecap=\"round\" stroke-linejoin=\"round\" data-button=\"button-0\"/>\n\t\t\t<circle cx=\"470.93\" cy=\"529.81\" r=\"8.2353\" fill=\"#5a5a5a\" fill-rule=\"evenodd\" stroke=\"#454545\" stroke-linecap=\"round\" stroke-linejoin=\"round\" data-button=\"button-1\"/>\n\t\t\t<circle cx=\"435.5\" cy=\"529.81\" r=\"8.2353\" fill=\"#5a5a5a\" fill-rule=\"evenodd\" stroke=\"#454545\" stroke-linecap=\"round\" stroke-linejoin=\"round\" data-button=\"button-2\"/>\n\t\t\t<path d=\"m301.84 501.25c-1.5358 0-2.7812 1.2454-2.7812 2.7812v14.656h-14.688c-1.5358 0-2.75 1.2454-2.75 2.7812v15.594c0 1.5358 1.2142 2.7812 2.75 2.7812h14.688v14.656c0 1.5358 1.2454 2.7812 2.7812 2.7812h15.594c1.5358 0 2.75-1.2454 2.75-2.7812v-14.656h14.688c1.5358 0 2.75-1.2454 2.75-2.7812v-15.594c0-1.5358-1.2142-2.7812-2.75-2.7812h-14.688v-14.656c0-1.5358-1.2142-2.7812-2.75-2.7812z\" fill=\"#262626\" fill-rule=\"evenodd\"/>\n\t\t\t<circle cx=\"416.21\" cy=\"566.61\" r=\"24.052\" fill=\"#333\" fill-rule=\"evenodd\" stroke=\"#000\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/>\n\t\t\t<circle cx=\"416.21\" cy=\"566.61\" r=\"18.562\" fill-opacity=\".51852\" fill-rule=\"evenodd\" stroke=\"#000\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/>\n\t\t\t<circle cx=\"416.21\" cy=\"566.61\" r=\"16.209\" fill=\"#3b3b3b\" fill-rule=\"evenodd\" stroke=\"#000\" stroke-linecap=\"round\" stroke-linejoin=\"round\" data-button=\"right-stick button-11\"/>\n\t\t\t<g fill=\"#3f3f3f\" fill-rule=\"evenodd\">\n\t\t\t\t<path transform=\"matrix(0 -.28374 -.51741 0 575.79 583.64)\" d=\"m279.97 514.41-12.665 7.3123v-14.625z\"/>\n\t\t\t\t<path transform=\"matrix(0 .28374 -.51741 0 575.79 474.89)\" d=\"m279.97 514.41-12.665 7.3123v-14.625z\"/>\n\t\t\t\t<path transform=\"matrix(.28374 0 0 -.51741 255.25 795.43)\" d=\"m279.97 514.41-12.665 7.3123v-14.625z\"/>\n\t\t\t\t<path transform=\"matrix(-.28374 0 0 -.51741 364 795.43)\" d=\"m279.97 514.41-12.665 7.3123v-14.625z\"/>\n\t\t\t</g>\n\t\t\t<rect x=\"430.79\" y=\"525.1\" width=\"9.4281\" height=\"9.4281\" rx=\"0\" ry=\"0\" fill=\"none\" stroke=\"#ff01db\"/>\n\t\t\t<path transform=\"matrix(.87668 0 0 .87521 59.31 61.955)\" d=\"m455.3 518.14h-11.974l5.9871-10.37z\" fill=\"none\" stroke=\"#00ff83\" stroke-width=\"1.1416\"/>\n\t\t\t<circle transform=\"scale(-1)\" cx=\"-470.93\" cy=\"-529.81\" r=\"5.6472\" fill=\"none\" stroke=\"#f00\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/>\n\t\t\t<path d=\"m449.04 543.43 8.5038 8.5038m0-8.5038-8.5038 8.5038\" fill=\"none\" stroke=\"#8243fb\"/>\n\t\t\t<g fill=\"#5a5a5a\" stroke=\"#454545\">\n\t\t\t\t<path transform=\"translate(.35102 .37335)\" d=\"m318.62 523.29a1.1789 1.1789 0 0 0-0.85742 0.44726l-3.5 4.4375a1.1789 1.1789 0 0 0-2e-3 1.457l3.5 4.4688a1.1789 1.1789 0 0 0 0.92382 0.45313l8.125 0.0312a1.1789 1.1789 0 0 0 1.1836-1.1797v-8.7812a1.1789 1.1789 0 0 0-1.1562-1.1777l-8.125-0.15625a1.1789 1.1789 0 0 0-0.0918 0z\" fill=\"#5a5a5a\" fill-rule=\"evenodd\" stroke=\"#454545\" stroke-linecap=\"round\" stroke-linejoin=\"round\" data-button=\"button-15\"/>\n\t\t\t\t<g data-button=\"button-14\">\n\t\t\t\t\t<path transform=\"matrix(-1 0 0 1 618.9 .2845)\" d=\"m318.62 523.29a1.1789 1.1789 0 0 0-0.85742 0.44726l-3.5 4.4375a1.1789 1.1789 0 0 0-2e-3 1.457l3.5 4.4688a1.1789 1.1789 0 0 0 0.92382 0.45313l8.125 0.0312a1.1789 1.1789 0 0 0 1.1836-1.1797v-8.7812a1.1789 1.1789 0 0 0-1.1562-1.1777l-8.125-0.15625a1.1789 1.1789 0 0 0-0.0918 0z\" fill=\"#5a5a5a\" fill-rule=\"evenodd\" stroke=\"#454545\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/>\n\t\t\t\t</g>\n\t\t\t\t<g data-button=\"button-13\">\n\t\t\t\t\t<path transform=\"rotate(90 309.26 529.25)\" d=\"m318.62 523.29a1.1789 1.1789 0 0 0-0.85742 0.44726l-3.5 4.4375a1.1789 1.1789 0 0 0-2e-3 1.457l3.5 4.4688a1.1789 1.1789 0 0 0 0.92382 0.45313l8.125 0.0312a1.1789 1.1789 0 0 0 1.1836-1.1797v-8.7812a1.1789 1.1789 0 0 0-1.1562-1.1777l-8.125-0.15625a1.1789 1.1789 0 0 0-0.0918 0z\" fill=\"#5a5a5a\" fill-rule=\"evenodd\" stroke=\"#454545\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/>\n\t\t\t\t</g>\n\t\t\t\t<g data-button=\"button-12\">\n\t\t\t\t\t<path transform=\"matrix(0 -1 -1 0 838.61 838.54)\" d=\"m318.62 523.29a1.1789 1.1789 0 0 0-0.85742 0.44726l-3.5 4.4375a1.1789 1.1789 0 0 0-2e-3 1.457l3.5 4.4688a1.1789 1.1789 0 0 0 0.92382 0.45313l8.125 0.0312a1.1789 1.1789 0 0 0 1.1836-1.1797v-8.7812a1.1789 1.1789 0 0 0-1.1562-1.1777l-8.125-0.15625a1.1789 1.1789 0 0 0-0.0918 0z\" fill=\"#5a5a5a\" fill-rule=\"evenodd\" stroke=\"#454545\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/>\n\t\t\t\t</g>\n\t\t\t</g>\n\t\t\t<path d=\"m307.47 481.42h1.038v6.7985h3.7358v0.87358h-4.7738v-7.6721\"/>\n\t\t\t<path d=\"m454.02 485.5c0.22267 0.0754 0.43849 0.23638 0.64747 0.48303 0.2124 0.24666 0.4248 0.58582 0.6372 1.0175l1.0534 2.0966h-1.1151l-0.98149-1.9681c-0.25352-0.51387-0.50017-0.85473-0.73998-1.0226-0.23638-0.16786-0.56012-0.25179-0.97121-0.25179h-1.1305v3.2425h-1.038v-7.6721h2.3432c0.877 1e-5 1.5313 0.18329 1.963 0.54984 0.43164 0.36657 0.64747 0.91983 0.64747 1.6598 0 0.48304-0.11305 0.88386-0.33915 1.2024-0.22268 0.31861-0.54813 0.53957-0.97635 0.6629m-2.6002-3.222v2.7235h1.3052c0.50016 1e-5 0.877-0.11476 1.1305-0.34429 0.25693-0.23295 0.3854-0.57382 0.3854-1.0226 0-0.44877-0.12847-0.78622-0.3854-1.0123-0.25351-0.22953-0.63035-0.34429-1.1305-0.3443h-1.3052\"/>\n\t\t\t<path d=\"m353.63 524.56v0.43917c-0.17091-0.0817-0.33216-0.14267-0.48375-0.1828-0.15159-0.0401-0.29798-0.0602-0.43917-0.0602-0.24522 0-0.43471 0.0476-0.56846 0.14267-0.13227 0.0951-0.19841 0.23036-0.19841 0.40573 0 0.14713 0.0438 0.2586 0.13153 0.33439 0.0892 0.0743 0.25711 0.1345 0.50382 0.18057l0.27197 0.0557c0.33587 0.0639 0.58332 0.17686 0.74234 0.33885 0.16051 0.16051 0.24076 0.37601 0.24077 0.64649-1e-5 0.3225-0.1085 0.56698-0.32548 0.73343-0.2155 0.16646-0.53205 0.24968-0.94967 0.24968-0.15753 0-0.32547-0.0178-0.50381-0.0535-0.17686-0.0357-0.3604-0.0884-0.55063-0.15828v-0.46369c0.1828 0.10255 0.36188 0.17983 0.53725 0.23185 0.17537 0.052 0.34777 0.078 0.51719 0.078 0.25711 0 0.45551-0.0505 0.59522-0.15159 0.1397-0.10106 0.20955-0.24522 0.20955-0.43248 0-0.16348-0.0505-0.29129-0.15159-0.38343-0.0996-0.0921-0.2638-0.16125-0.49267-0.20733l-0.2742-0.0535c-0.33588-0.0669-0.57887-0.17165-0.72897-0.31433-0.15011-0.14267-0.22516-0.34107-0.22516-0.59521 0-0.29426 0.10329-0.52611 0.30987-0.69553 0.20806-0.16943 0.49415-0.25414 0.85827-0.25414 0.15605 0 0.31507 0.0141 0.47706 0.0423 0.162 0.0283 0.3277 0.0706 0.49713 0.12707m0.90286-0.10923h2.1044v0.37898h-1.6541v0.98533h1.585v0.37898h-1.585v1.206h1.6942v0.37897h-2.1446v-3.3283m2.8891 0h0.45032v2.9493h1.6207v0.37897h-2.071v-3.3283m2.5414 0h2.1044v0.37898h-1.6541v0.98533h1.585v0.37898h-1.585v1.206h1.6942v0.37897h-2.1446v-3.3283m5.3815 0.25637v0.47483c-0.15159-0.14118-0.31359-0.2467-0.48598-0.31656-0.17092-0.0698-0.35297-0.10477-0.54617-0.10477-0.38047 0-0.67176 0.11667-0.87388 0.34999-0.20212 0.23185-0.30318 0.56773-0.30318 1.0076 0 0.43843 0.10106 0.77431 0.30318 1.0076 0.20212 0.23184 0.49341 0.34776 0.87388 0.34776 0.1932 0 0.37525-0.0349 0.54617-0.10477 0.17239-0.0698 0.33439-0.17537 0.48598-0.31656v0.47038c-0.15754 0.107-0.32473 0.18726-0.50159 0.24076-0.17537 0.0535-0.36114 0.0802-0.55732 0.0802-0.50381 0-0.90062-0.15382-1.1904-0.46146-0.2898-0.30912-0.43471-0.73045-0.43471-1.264 0-0.53502 0.14491-0.95635 0.43471-1.264 0.28981-0.30913 0.68662-0.46369 1.1904-0.46369 0.19915 0 0.38641 0.0267 0.56178 0.0802 0.17685 0.052 0.34256 0.13079 0.49713 0.23631m0.23853-0.25637h2.8156v0.37898h-1.1815v2.9493h-0.45254v-2.9493h-1.1815v-0.37898\" fill=\"#e6e6e6\"/>\n\t\t\t<path d=\"m396.51 524.56v0.43917c-0.17092-0.0817-0.33217-0.14267-0.48376-0.1828-0.15159-0.0401-0.29798-0.0602-0.43916-0.0602-0.24522 0-0.43471 0.0476-0.56847 0.14267-0.13227 0.0951-0.1984 0.23036-0.1984 0.40573 0 0.14713 0.0438 0.2586 0.13152 0.33439 0.0892 0.0743 0.25711 0.1345 0.50382 0.18057l0.27197 0.0557c0.33588 0.0639 0.58333 0.17686 0.74235 0.33885 0.1605 0.16051 0.24076 0.37601 0.24076 0.64649 0 0.3225-0.10849 0.56698-0.32547 0.73343-0.2155 0.16646-0.53206 0.24968-0.94967 0.24968-0.15754 0-0.32548-0.0178-0.50382-0.0535-0.17686-0.0357-0.3604-0.0884-0.55063-0.15828v-0.46369c0.1828 0.10255 0.36189 0.17983 0.53726 0.23185 0.17536 0.052 0.34776 0.078 0.51719 0.078 0.2571 0 0.45551-0.0505 0.59521-0.15159 0.1397-0.10106 0.20955-0.24522 0.20955-0.43248 0-0.16348-0.0505-0.29129-0.15159-0.38343-0.0996-0.0921-0.2638-0.16125-0.49267-0.20733l-0.2742-0.0535c-0.33587-0.0669-0.57886-0.17165-0.72897-0.31433-0.1501-0.14267-0.22516-0.34107-0.22515-0.59521-1e-5 -0.29426 0.10328-0.52611 0.30986-0.69553 0.20807-0.16943 0.49416-0.25414 0.85827-0.25414 0.15605 0 0.31507 0.0141 0.47707 0.0423 0.16199 0.0283 0.3277 0.0706 0.49713 0.12707m0.44139-0.10923h2.8156v0.37898h-1.1815v2.9493h-0.45254v-2.9493h-1.1815v-0.37898m4.0082 0.44362-0.61082 1.6564h1.2239l-0.61305-1.6564m-0.25413-0.44362h0.5105l1.2685 3.3283h-0.46815l-0.30318-0.85381h-1.5003l-0.30318 0.85381h-0.47484l1.2707-3.3283m3.841 1.7678c0.0966 0.0327 0.19023 0.10255 0.28089 0.20955 0.0921 0.10701 0.18429 0.25414 0.27643 0.4414l0.457 0.90954h-0.48375l-0.42579-0.85381c-0.10998-0.22292-0.21698-0.3708-0.32102-0.44362-0.10254-0.0728-0.24299-0.10924-0.42133-0.10924h-0.49044v1.4067h-0.45031v-3.3283h1.0166c0.38046 0 0.66432 0.0795 0.85158 0.23853s0.28088 0.39904 0.28089 0.72006c-1e-5 0.20955-0.0491 0.38343-0.14713 0.52165-0.0966 0.13821-0.2378 0.23407-0.42357 0.28757m-1.128-1.3978v1.1815h0.56624c0.21698 0 0.38046-0.0498 0.49044-0.14936 0.11146-0.10106 0.16719-0.24893 0.16719-0.44362s-0.0557-0.34108-0.16719-0.43917c-0.10998-0.0996-0.27346-0.14936-0.49044-0.14936h-0.56624m1.9328-0.37006h2.8156v0.37898h-1.1815v2.9493h-0.45254v-2.9493h-1.1815v-0.37898\" fill=\"#e6e6e6\"/>\n\t\t\t<text transform=\"scale(-1.6252 -.6153)\" x=\"-223.68372\" y=\"-815.48474\" fill=\"#b3b3b3\" font-family=\"Arial\" stroke-width=\"1px\" style=\"line-height:0%\" xml:space=\"preserve\">\n\t\t\t\t<tspan x=\"-223.68372\" y=\"-815.48474\" font-size=\"3.0753px\" style=\"line-height:1.25\">1</tspan>\n\t\t\t</text>\n\t\t\t<text transform=\"scale(-1.6252 -.6153)\" x=\"-220.45108\" y=\"-815.48474\" fill=\"#b3b3b3\" font-family=\"Arial\" stroke-width=\"1px\" style=\"line-height:0%\" xml:space=\"preserve\">\n\t\t\t\t<tspan x=\"-220.45108\" y=\"-815.48474\" font-size=\"3.0753px\" style=\"line-height:1.25\">2</tspan>\n\t\t\t</text>\n\t\t\t<text transform=\"scale(-1.6252 -.6153)\" x=\"-216.92226\" y=\"-815.5238\" fill=\"#b3b3b3\" font-family=\"Arial\" stroke-width=\"1px\" style=\"line-height:0%\" xml:space=\"preserve\">\n\t\t\t\t<tspan x=\"-216.92226\" y=\"-815.5238\" font-size=\"3.0753px\" style=\"line-height:1.25\">3</tspan>\n\t\t\t</text>\n\t\t\t<text transform=\"scale(-1.6252 -.6153)\" x=\"-212.86066\" y=\"-815.49377\" fill=\"#b3b3b3\" font-family=\"Arial\" stroke-width=\"1px\" style=\"line-height:0%\" xml:space=\"preserve\">\n\t\t\t\t<tspan x=\"-212.86066\" y=\"-815.49377\" font-size=\"3.0753px\" style=\"line-height:1.25\">4</tspan>\n\t\t\t</text>\n\t\t\t<rect x=\"343.44\" y=\"498.32\" width=\"2.0832\" height=\"2.7005\" rx=\"0\" ry=\"1.5686\" fill=\"#1a1a1a\"/>\n\t\t\t<rect x=\"350\" y=\"498.32\" width=\"2.0832\" height=\"2.7005\" rx=\"0\" ry=\"1.5686\" fill=\"#1a1a1a\"/>\n\t\t\t<rect x=\"355.86\" y=\"498.32\" width=\"2.0832\" height=\"2.7005\" rx=\"0\" ry=\"1.5686\" fill=\"#1a1a1a\"/>\n\t\t\t<rect x=\"360.96\" y=\"498.32\" width=\"2.0832\" height=\"2.7005\" rx=\"0\" ry=\"1.5686\" fill=\"#f00\"/>\n\t\t\t<g transform=\"matrix(.080659 0 0 .080659 351.05 512.47)\" clip-rule=\"evenodd\" fill-rule=\"evenodd\" stroke-width=\"2.256\">\n\t\t\t\t<path d=\"m394.88 444.14-0.0851 78.095-20.924-6.8051v-91.793l26.708 7.0613c17.096 4.5948 27.559 13.526 27.388 29.18-0.17 18.206-8.5908 25.521-25.007 20.757v-35.901c0-4.3389-8.0805-4.593-8.0805-0.59435z\" fill=\"#de0029\"/>\n\t\t\t\t<path d=\"m364.26 500.28-9.867 3.3186c-6.3802 2.2124-11.823-2.9768-5.9543-5.1048l4.763-1.7003-17.947-5.701c-5.5292 1.8724-10.718 5.8707-10.377 11.486 0.34027 5.6992 13.354 7.061 23.392 8.6775 9.3559 1.5306 17.862 0.68001 25.603-2.0424v-5.8705zm30.706 21.95 18.288-6.381-18.458-5.8692v11.824z\" fill=\"#f3c202\"/>\n\t\t\t\t<path d=\"m443.62 505.13 0.34-0.0857c7.9956-2.8065 11.398-6.7213 10.548-10.378-1.3611-6.1248-11.143-9.4434-26.199-10.55-10.802-0.76514-21.434 1.6162-31.811 5.1889l-1.7013 0.5962 18.628 5.7848 10.887-3.6586c11.398-2.1262 15.992 1.6165 5.0189 5.1048l-5.444 1.8705zm-69.748-27.052-8.2516 2.8065 8.2516 2.5524z\" fill=\"#326db3\"/>\n\t\t\t\t<path d=\"m413.25 515.85 30.366-10.718-19.734-6.1267-29.09 9.9534v1.0221zm-39.382-18.801-9.6118 3.2327 9.6118 3.0627zm20.924 5.0207v-12.166l18.628 5.7848zm-41.594-5.2748 20.67-7.4013v-5.9551l-8.2513-2.5524-29.941 10.124c-0.0851 0-0.25513 0.0841-0.42513 0.0841z\" fill=\"#00aa9e\"/>\n\t\t\t</g>\n\t\t</g>\n\t</g>\n\t<g transform=\"translate(-260.34 -473.69)\">\n\t\t<g class = \"a\" class = \"a\" cv-if = \"a\">\n\t\t\t<path transform=\"translate(134.82 68.294)\" d=\"m456.39 552.34 69.71 17.901\" fill=\"none\" stroke=\"#000\" stroke-width=\".5\"/>\n\t\t</g>\n\t\t<g class = \"x\" class = \"x\" cv-if = \"x\">\n\t\t\t<path transform=\"translate(134.82 68.294)\" d=\"m439.07 532.57 87.033 22.593\" fill=\"none\" stroke=\"#000\" stroke-width=\".5\"/>\n\t\t</g>\n\t\t<g class = \"y\" class = \"y\" cv-if = \"y\">\n\t\t\t<path transform=\"translate(134.82 68.294)\" d=\"m457.95 515.41 68.155 16.266\" fill=\"none\" stroke=\"#000\" stroke-width=\".5\"/>\n\t\t</g>\n\t\t<g class = \"b\" class = \"b\" cv-if = \"b\">\n\t\t\t<path transform=\"translate(134.82 68.294)\" d=\"m474.2 532.63 51.904 12.605\" fill=\"none\" stroke=\"#000\" stroke-width=\".5\"/>\n\t\t</g>\n\t\t<text transform=\"translate(134.82 68.294)\" x=\"527.39423\" y=\"547.27045\" fill=\"#000000\" font-family=\"sans-serif\" font-size=\"40px\" letter-spacing=\"0px\" word-spacing=\"0px\" style=\"line-height:1.25\" xml:space=\"preserve\">\n\t\t\t<tspan class = \"b\" x=\"527.39423\" y=\"547.27045\" font-family=\"sans-serif\" font-size=\"6px\" style=\"font-variant-caps:normal;font-variant-east-asian:normal;font-variant-ligatures:normal;font-variant-numeric:normal\">[[b]]</tspan>\n\t\t</text>\n\t\t<text transform=\"translate(134.82 68.294)\" x=\"527.69214\" y=\"572.71301\" fill=\"#000000\" font-family=\"sans-serif\" font-size=\"40px\" letter-spacing=\"0px\" word-spacing=\"0px\" style=\"line-height:1.25\" xml:space=\"preserve\">\n\t\t\t<tspan class = \"a\" x=\"527.69214\" y=\"572.71301\" font-family=\"sans-serif\" font-size=\"6px\" style=\"font-variant-caps:normal;font-variant-east-asian:normal;font-variant-ligatures:normal;font-variant-numeric:normal\">[[a]]</tspan>\n\t\t</text>\n\t\t<text transform=\"translate(134.82 68.294)\" x=\"527.45691\" y=\"557.97314\" fill=\"#000000\" font-family=\"sans-serif\" font-size=\"40px\" letter-spacing=\"0px\" word-spacing=\"0px\" style=\"line-height:1.25\" xml:space=\"preserve\">\n\t\t\t<tspan class = \"x\" x=\"527.45691\" y=\"557.97314\" font-family=\"sans-serif\" font-size=\"6px\" style=\"font-variant-caps:normal;font-variant-east-asian:normal;font-variant-ligatures:normal;font-variant-numeric:normal\">[[x]]</tspan>\n\t\t</text>\n\t\t<text transform=\"translate(134.82 68.294)\" x=\"526.81152\" y=\"534.13593\" fill=\"#000000\" font-family=\"sans-serif\" font-size=\"40px\" letter-spacing=\"0px\" word-spacing=\"0px\" style=\"line-height:1.25\" xml:space=\"preserve\">\n\t\t\t<tspan class = \"y\" x=\"526.81152\" y=\"534.13593\" font-family=\"sans-serif\" font-size=\"6px\" style=\"font-variant-caps:normal;font-variant-east-asian:normal;font-variant-ligatures:normal;font-variant-numeric:normal\">[[y]]</tspan>\n\t\t</text>\n\t\t<g cv-if =\"r1\" class = \"r1\">\n\t\t\t<path transform=\"translate(134.82 68.294)\" d=\"m470.33 481.76 53.163 13.403\" fill=\"none\" stroke=\"#000\" stroke-width=\".5\"/>\n\t\t\t<text transform=\"translate(134.82 68.294)\" x=\"524.19629\" y=\"497.62772\" fill=\"#000000\" font-family=\"sans-serif\" font-size=\"40px\" letter-spacing=\"0px\" word-spacing=\"0px\" style=\"line-height:1.25\" xml:space=\"preserve\">\n\t\t\t\t<tspan class = \"r1\" x=\"524.19629\" y=\"497.62772\" font-family=\"sans-serif\" font-size=\"6px\" style=\"font-variant-caps:normal;font-variant-east-asian:normal;font-variant-ligatures:normal;font-variant-numeric:normal\">[[r1]]</tspan>\n\t\t\t</text>\n\t\t</g>\n\t\t<g cv-if =\"ra\" class = \"ra\">\n\t\t\t<path transform=\"translate(134.82 68.294)\" d=\"m435.96 571.55 90.146 25.55\" fill=\"none\" stroke=\"#000\" stroke-width=\".5\"/>\n\t\t\t<text transform=\"translate(134.82 68.294)\" x=\"529.45886\" y=\"599.68732\" fill=\"#000000\" font-family=\"sans-serif\" font-size=\"40px\" letter-spacing=\"0px\" word-spacing=\"0px\" style=\"line-height:1.25\" xml:space=\"preserve\">\n\t\t\t\t<tspan x=\"529.45886\" y=\"599.68732\" font-family=\"sans-serif\" font-size=\"6px\" style=\"font-variant-caps:normal;font-variant-east-asian:normal;font-variant-ligatures:normal;font-variant-numeric:normal\">[[ra]]</tspan>\n\t\t\t</text>\n\t\t</g>\n\t\t<g cv-if = \"l1\" class = \"l1\">\n\t\t\t<path transform=\"translate(134.82 68.294)\" d=\"m292.1 481.01-53.163 13.403\" fill=\"none\" stroke=\"#000\" stroke-width=\".5\"/>\n\t\t\t<text transform=\"translate(134.82 68.294)\" x=\"212.72356\" y=\"496.87265\" fill=\"#000000\" font-family=\"sans-serif\" font-size=\"40px\" letter-spacing=\"0px\" word-spacing=\"0px\" style=\"line-height:1.25\" xml:space=\"preserve\">\n\t\t\t\t<tspan class = \"l1\" x=\"212.72356\" y=\"496.87265\" font-family=\"sans-serif\" font-size=\"6px\" style=\"font-variant-caps:normal;font-variant-east-asian:normal;font-variant-ligatures:normal;font-variant-numeric:normal\">[[l1]]</tspan>\n\t\t\t</text>\n\t\t</g>\n\t\t<g cv-if = \"dpad\" class = \"dpad\">\n\t\t\t<path transform=\"translate(134.82 68.294)\" d=\"m294.23 543.48-55.024 27.964\" fill=\"none\" stroke=\"#000\" stroke-width=\".5\"/>\n\t\t\t<text transform=\"translate(134.82 68.294)\" x=\"220.96754\" y=\"573.75909\" fill=\"#000000\" font-family=\"sans-serif\" font-size=\"40px\" letter-spacing=\"0px\" word-spacing=\"0px\" style=\"line-height:1.25\" xml:space=\"preserve\">\n\t\t\t\t<tspan x=\"220.96754\" y=\"573.75909\" font-family=\"sans-serif\" font-size=\"6px\" style=\"font-variant-caps:normal;font-variant-east-asian:normal;font-variant-ligatures:normal;font-variant-numeric:normal\">[[dpad]]</tspan>\n\t\t\t</text>\n\t\t</g>\n\t\t<g cv-if = \"start\" class = \"start\">\n\t\t\t<path transform=\"translate(134.82 68.294)\" d=\"m401.03 523.14v-50.774\" fill=\"none\" stroke=\"#000\" stroke-width=\".5\"/>\n\t\t\t<text transform=\"translate(134.82 68.294)\" x=\"392.06915\" y=\"470.65366\" fill=\"#000000\" font-family=\"sans-serif\" font-size=\"40px\" letter-spacing=\"0px\" word-spacing=\"0px\" style=\"line-height:1.25\" xml:space=\"preserve\">\n\t\t\t\t<tspan class = \"start\" x=\"392.06915\" y=\"470.65366\" font-family=\"sans-serif\" font-size=\"6px\" style=\"font-variant-caps:normal;font-variant-east-asian:normal;font-variant-ligatures:normal;font-variant-numeric:normal\">[[start]]</tspan>\n\t\t\t</text>\n\t\t</g>\n\t</g>\n</svg>\n"
});

;require.register("controller/xbox360-input.svg", function(exports, require, module) {
module.exports = "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n<svg\n   xmlns:dc=\"http://purl.org/dc/elements/1.1/\"\n   xmlns:cc=\"http://creativecommons.org/ns#\"\n   xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\"\n   xmlns:svg=\"http://www.w3.org/2000/svg\"\n   xmlns=\"http://www.w3.org/2000/svg\"\n   xmlns:sodipodi=\"http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd\"\n   xmlns:inkscape=\"http://www.inkscape.org/namespaces/inkscape\"\n   width=\"512\"\n   height=\"288\"\n   id=\"svg2\"\n   sodipodi:version=\"0.32\"\n   inkscape:version=\"1.0.2 (e86c870879, 2021-01-15)\"\n   sodipodi:docname=\"xbox360-input.svg\"\n   inkscape:output_extension=\"org.inkscape.output.svg.inkscape\"\n   version=\"1.0\">\n  <defs\n     id=\"defs4\">\n    <inkscape:perspective\n       sodipodi:type=\"inkscape:persp3d\"\n       inkscape:vp_x=\"0 : 663.1653 : 1\"\n       inkscape:vp_y=\"0 : 1000 : 0\"\n       inkscape:vp_z=\"744.09448 : 663.1653 : 1\"\n       inkscape:persp3d-origin=\"372.04724 : 487.7716 : 1\"\n       id=\"perspective10\" />\n    <inkscape:perspective\n       id=\"perspective2390\"\n       inkscape:persp3d-origin=\"372.04724 : 487.7716 : 1\"\n       inkscape:vp_z=\"744.09448 : 663.1653 : 1\"\n       inkscape:vp_y=\"0 : 1000 : 0\"\n       inkscape:vp_x=\"0 : 663.1653 : 1\"\n       sodipodi:type=\"inkscape:persp3d\" />\n    <inkscape:perspective\n       id=\"perspective12\"\n       inkscape:persp3d-origin=\"886.50018 : 236.98421 : 1\"\n       inkscape:vp_z=\"1773.0004 : 286.98421 : 1\"\n       inkscape:vp_y=\"0 : 1000 : 0\"\n       inkscape:vp_x=\"0 : 286.98421 : 1\"\n       sodipodi:type=\"inkscape:persp3d\" />\n    <inkscape:perspective\n       id=\"perspective3355\"\n       inkscape:persp3d-origin=\"67.123741 : 170.98342 : 1\"\n       inkscape:vp_z=\"134.24748 : 187.98302 : 1\"\n       inkscape:vp_y=\"0 : 1000 : 0\"\n       inkscape:vp_x=\"0 : 187.98302 : 1\"\n       sodipodi:type=\"inkscape:persp3d\" />\n    <inkscape:perspective\n       id=\"perspective3443\"\n       inkscape:persp3d-origin=\"177.16534 : 255.09444 : 1\"\n       inkscape:vp_z=\"354.33069 : 314.14955 : 1\"\n       inkscape:vp_y=\"0 : 1000 : 0\"\n       inkscape:vp_x=\"0 : 314.14955 : 1\"\n       sodipodi:type=\"inkscape:persp3d\" />\n  </defs>\n  <sodipodi:namedview\n     id=\"base\"\n     pagecolor=\"#ffffff\"\n     bordercolor=\"#666666\"\n     borderopacity=\"1.0\"\n     gridtolerance=\"10000\"\n     guidetolerance=\"10\"\n     objecttolerance=\"10\"\n     inkscape:pageopacity=\"0.0\"\n     inkscape:pageshadow=\"2\"\n     inkscape:zoom=\"1.7956884\"\n     inkscape:cx=\"145.53463\"\n     inkscape:cy=\"120.12192\"\n     inkscape:document-units=\"px\"\n     inkscape:current-layer=\"layer4\"\n     showgrid=\"false\"\n     inkscape:window-width=\"1920\"\n     inkscape:window-height=\"1026\"\n     inkscape:window-x=\"1050\"\n     inkscape:window-y=\"31\"\n     showguides=\"true\"\n     inkscape:guide-bbox=\"true\"\n     inkscape:document-rotation=\"0\"\n     inkscape:window-maximized=\"1\">\n    <sodipodi:guide\n       position=\"399.98588,184.41855\"\n       orientation=\"1,0\"\n       id=\"guide4464\" />\n    <sodipodi:guide\n       position=\"113.8839,194.16412\"\n       orientation=\"1,0\"\n       id=\"guide5621\" />\n  </sodipodi:namedview>\n  <metadata\n     id=\"metadata7\">\n    <rdf:RDF>\n      <cc:Work\n         rdf:about=\"\">\n        <dc:format>image/svg+xml</dc:format>\n        <dc:type\n           rdf:resource=\"http://purl.org/dc/dcmitype/StillImage\" />\n        <dc:title></dc:title>\n      </cc:Work>\n    </rdf:RDF>\n  </metadata>\n  <g\n     inkscape:label=\"Layer 1\"\n     inkscape:groupmode=\"layer\"\n     id=\"layer1\"\n     transform=\"translate(-260.34243,-473.69226)\">\n    <g\n       id=\"g237\"\n       transform=\"translate(134.82195,68.29447)\">\n      <g\n         id=\"g817\"\n         transform=\"matrix(0.32231801,0,0,0.32231801,260.60086,378.95899)\">\n        <path\n           style=\"fill:#d8d8d8;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:3;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n           d=\"m 628.39816,299.51068 c -0.21851,-1.09254 -4.15168,-18.13627 -4.58869,-20.97689 -0.43702,-2.84062 -1.09255,-4.37019 -4.5887,-6.77379 -32.81359,-22.55933 -17.06203,-23.18579 -55.11042,-17.04898 -6.77379,1.09254 -15.51417,18.13627 -15.51417,18.13627 z\"\n           id=\"path3352-3-3\"\n           sodipodi:nodetypes=\"cssscc\"\n           data-button=\"button-7\" />\n        <path\n           style=\"fill:#d8d8d8;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:3;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n           d=\"m 124.78295,299.51068 c 0.21851,-1.09254 4.15168,-18.13627 4.58869,-20.97689 0.43702,-2.84062 1.09255,-4.37019 4.5887,-6.77379 32.81359,-22.55933 17.06203,-23.18579 55.11042,-17.04898 6.77379,1.09254 15.51417,18.13627 15.51417,18.13627 z\"\n           id=\"path3352-3\"\n           sodipodi:nodetypes=\"cssscc\"\n           data-button=\"button-6\" />\n        <g\n           id=\"g4442\"\n           transform=\"matrix(0.5752286,0,0,0.5752286,161.90411,275.5957)\"\n           style=\"stroke:#000000;stroke-width:2;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\">\n          <rect\n             style=\"fill:#4d4d4d;fill-opacity:1;stroke:#000000;stroke-width:2;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n             id=\"rect4436\"\n             width=\"45.344299\"\n             height=\"27.532085\"\n             x=\"390.84552\"\n             y=\"630.43866\"\n             ry=\"4.973381\"\n             rx=\"4.973381\" />\n          <rect\n             rx=\"4.973381\"\n             ry=\"4.973381\"\n             y=\"630.43866\"\n             x=\"305.26193\"\n             height=\"27.532085\"\n             width=\"45.344299\"\n             id=\"rect4438\"\n             style=\"fill:#4d4d4d;fill-opacity:1;stroke:#000000;stroke-width:2;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\" />\n          <rect\n             style=\"fill:#4d4d4d;fill-opacity:1;stroke:#000000;stroke-width:2;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n             id=\"rect4440\"\n             width=\"32.910625\"\n             height=\"27.325605\"\n             x=\"354.27057\"\n             y=\"630.23145\"\n             ry=\"4.973381\"\n             rx=\"4.973381\" />\n        </g>\n        <path\n           sodipodi:nodetypes=\"cssscc\"\n           id=\"path3365\"\n           d=\"m 655.50745,318.60794 c -0.21851,-1.09254 -4.15168,-18.13627 -4.58869,-20.97689 -0.43702,-2.84062 -1.09255,-4.37019 -4.5887,-6.77379 -32.81359,-22.55933 -71.20626,-33.45047 -109.25465,-27.31366 -6.77379,1.09254 -15.51417,18.13627 -15.51417,18.13627 z\"\n           style=\"fill:#d8d8d8;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:3;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n           data-button=\"button-5\" />\n        <path\n           style=\"fill:#d8d8d8;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:3;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n           d=\"m 97.673659,318.60794 c 0.218509,-1.09254 4.151681,-18.13627 4.588691,-20.97689 0.43702,-2.84062 1.09255,-4.37019 4.5887,-6.77379 32.81359,-22.55933 71.20626,-33.45047 109.25465,-27.31366 6.77379,1.09254 15.51417,18.13627 15.51417,18.13627 z\"\n           id=\"path3352\"\n           sodipodi:nodetypes=\"cssscc\"\n           data-button=\"button-4\" />\n        <path\n           style=\"fill:#cccccc;fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:3;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n           d=\"m 692.40625,795.6875 c 36.84007,1.09337 52.80772,-18.83796 56.40625,-117.4375 3.77124,-103.33202 -63.29854,-299.68945 -82.96875,-349.21875 -19.67025,-49.52929 -118.71329,-75.82532 -163.65625,-47.5 -36.98649,23.31075 -77.50632,26.375 -127.03125,26.375 -49.52492,0 -90.0135,-3.06425 -127,-26.375 -12.6402,-7.9665 -29.58112,-11.63473 -47.8125,-11.65625 C 153.75246,269.82 98.606739,293.43208 84.46875,329.03125 64.798509,378.56054 -2.2712417,574.91797 1.5,678.25 c 3.5785642,98.05266 19.406856,118.31763 55.8125,117.45312 84.47581,-9.05099 93.14578,-56.86454 150.09375,-101.60937 52.79739,-41.48369 89.78117,-45.2585 167.46875,-43.75 77.68757,-1.50848 114.64011,2.26634 167.4375,43.75 56.94798,44.7448 65.61794,92.54276 150.09375,101.59375 z\"\n           id=\"path3354\"\n           sodipodi:nodetypes=\"cssssscsscscsc\" />\n        <path\n           style=\"fill:#808080;fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:3;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n           d=\"m 376.55538,626.9578 c -70.07127,10e-6 -105.56406,1.53631 -141.34375,21.125 -74.56634,40.82366 -89.5368,105.33263 -168.59376,147.59375 77.18929,-11.18226 87.06449,-58.28282 142.1875,-101.59375 52.7974,-41.48366 89.78118,-45.2585 167.46876,-43.75 77.68757,-1.50851 114.64011,2.26634 167.4375,43.75 55.31458,43.46144 65.07175,90.74856 143,101.71875 -79.25058,-42.25894 -94.17658,-106.857 -168.8125,-147.71875 -35.77969,-19.58869 -71.27248,-21.125 -141.34375,-21.125 z\"\n           id=\"path3191\" />\n        <ellipse\n           style=\"opacity:1;fill:#d4d4d4;fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:1.24301;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n           id=\"path3339\"\n           cx=\"485.73596\"\n           cy=\"515.71448\"\n           rx=\"90.509804\"\n           ry=\"93.149673\" />\n        <ellipse\n           style=\"opacity:1;fill:#d4d4d4;fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:1;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n           id=\"path3335\"\n           cx=\"162.54053\"\n           cy=\"382.21249\"\n           rx=\"76.556213\"\n           ry=\"71.276474\" />\n        <ellipse\n           id=\"path3337\"\n           style=\"opacity:1;fill:#d4d4d4;fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:1.24301;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n           cx=\"264.74118\"\n           cy=\"515.71448\"\n           rx=\"90.509804\"\n           ry=\"93.149673\" />\n        <circle\n           style=\"opacity:1;fill:#333333;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:3;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n           id=\"path3249\"\n           cx=\"265.90213\"\n           cy=\"501.4498\"\n           r=\"60.547413\" />\n        <path\n           id=\"path3253\"\n           style=\"fill:#3a3a3a;fill-opacity:1;fill-rule:evenodd;stroke:#515151;stroke-width:3;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-opacity:1\"\n           d=\"m 249.60884,556.05516 c 0,5.37504 32.58658,4.96298 32.58658,0 0,-20.05425 16.27567,-36.33015 36.32964,-36.33015 5.24879,1.15665 7.27598,-35.55207 0,-36.55035 -20.05397,0 -36.32964,-16.2759 -36.32964,-36.33015 0,-5.39506 -32.58658,-5.80591 -32.58658,0 0,20.05425 -16.27567,36.33015 -36.32964,36.33015 -5.88003,-0.22498 -7.05562,36.34403 0,36.55035 20.05397,0 36.32964,16.2759 36.32964,36.33015 z\"\n           sodipodi:nodetypes=\"ccccssccc\"\n           data-button=\"dpad-0\" />\n        <g\n           id=\"g3292\"\n           data-button=\"button-9\">\n          <rect\n             ry=\"16.450199\"\n             rx=\"16.450203\"\n             y=\"372.24924\"\n             x=\"437.39334\"\n             height=\"29.558952\"\n             width=\"37.428303\"\n             id=\"rect3288\"\n             style=\"opacity:1;fill:#d1d1d1;fill-opacity:1;fill-rule:evenodd;stroke:#6d6d6d;stroke-width:1;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\" />\n          <path\n             transform=\"matrix(0,1.1259413,1.1259413,0,20.719223,57.395722)\"\n             inkscape:randomized=\"0\"\n             inkscape:rounded=\"0\"\n             inkscape:flatsided=\"true\"\n             sodipodi:arg2=\"0.52359878\"\n             sodipodi:arg1=\"-0.52359878\"\n             sodipodi:r2=\"4.7132702\"\n             sodipodi:r1=\"9.4265404\"\n             sodipodi:cy=\"386.38617\"\n             sodipodi:cx=\"292.76215\"\n             sodipodi:sides=\"3\"\n             id=\"path3290\"\n             style=\"opacity:1;fill:#717171;fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:3;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n             sodipodi:type=\"star\"\n             d=\"m 300.92577,381.6729 -8.16362,14.13981 -8.16363,-14.13981 z\" />\n        </g>\n        <g\n           id=\"g3296-7\"\n           data-button=\"button-8\">\n          <rect\n             style=\"opacity:1;fill:#d1d1d1;fill-opacity:1;fill-rule:evenodd;stroke:#6d6d6d;stroke-width:1;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n             id=\"rect3298-5\"\n             width=\"37.428303\"\n             height=\"29.558952\"\n             x=\"282.40161\"\n             y=\"372.24924\"\n             rx=\"16.450203\"\n             ry=\"16.450199\" />\n          <path\n             sodipodi:type=\"star\"\n             style=\"opacity:1;fill:#717171;fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:3;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n             id=\"path3300-6\"\n             sodipodi:sides=\"3\"\n             sodipodi:cx=\"292.76215\"\n             sodipodi:cy=\"386.38617\"\n             sodipodi:r1=\"9.4265404\"\n             sodipodi:r2=\"4.7132702\"\n             sodipodi:arg1=\"-0.52359878\"\n             sodipodi:arg2=\"0.52359878\"\n             inkscape:flatsided=\"true\"\n             inkscape:rounded=\"0\"\n             inkscape:randomized=\"0\"\n             transform=\"matrix(0,1.1259413,-1.1259413,0,738.02813,57.395722)\"\n             d=\"m 300.92577,381.6729 -8.16362,14.13981 -8.16363,-14.13981 z\" />\n        </g>\n        <circle\n           id=\"path3310\"\n           style=\"opacity:1;fill:#a7a7a7;fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:1.07159;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n           cx=\"379.25415\"\n           cy=\"382.24289\"\n           r=\"27.00733\" />\n        <g\n           id=\"g4372\"\n           data-button=\"button-16\">\n          <circle\n             id=\"path3304\"\n             style=\"opacity:1;fill:#007800;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:1;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n             cx=\"379.25418\"\n             cy=\"387.28577\"\n             r=\"42.671013\" />\n          <circle\n             style=\"opacity:1;fill:#979797;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:1;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n             id=\"path3302\"\n             cx=\"379.25418\"\n             cy=\"387.28577\"\n             r=\"36.252529\" />\n          <path\n             style=\"fill:#007800;fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:0.25pt;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1\"\n             d=\"m 344.94011,404.6356 c 11.61506,-28.78785 27.87652,-46.26619 54.74832,-50.37874 l 3.08442,2.57034 c -21.94963,7.88995 -42.83002,29.43216 -53.72019,53.46315 z\"\n             id=\"path3306\"\n             sodipodi:nodetypes=\"ccccc\" />\n          <path\n             sodipodi:nodetypes=\"ccccc\"\n             id=\"path3308\"\n             d=\"M 412.64636,405.10615 C 401.90402,378.48134 383.44171,358.47214 358.58899,354.6686 l -2.85267,2.37721 c 20.3004,7.29712 43.03458,31.06484 53.1065,53.29021 z\"\n             style=\"fill:#007800;fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:0.25pt;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1\" />\n        </g>\n        <text\n           xml:space=\"preserve\"\n           style=\"font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;line-height:0%;font-family:'DejaVu Sans Mono';-inkscape-font-specification:'DejaVu Sans Mono';text-align:center;writing-mode:lr-tb;text-anchor:middle;fill:#000000;fill-opacity:1;stroke:none;stroke-width:3pt;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1\"\n           x=\"472.78644\"\n           y=\"364.41809\"\n           id=\"text3312\"><tspan\n             sodipodi:role=\"line\"\n             id=\"tspan3314\"\n             x=\"472.78644\"\n             y=\"364.41809\"\n             style=\"font-size:10.9335px;line-height:-2\">START</tspan></text>\n        <path\n           d=\"m 542.19462,503.98223 c 0,31.40573 -25.48873,56.89446 -56.89447,56.89446 -31.40574,0 -56.89447,-25.48873 -56.89447,-56.89446 0,-31.40575 25.48873,-56.89448 56.89447,-56.89448 31.40574,0 56.89447,25.48873 56.89447,56.89448 z m -8.30373,-1e-5 c 0,26.82209 -21.76866,48.59074 -48.59074,48.59074 -26.82209,0 -48.59075,-21.76865 -48.59075,-48.59074 0,-26.82209 21.76866,-48.59074 48.59075,-48.59074 26.82208,0 48.59074,21.76865 48.59074,48.59074 z\"\n           style=\"fill:#dfdfdf;fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:2.06703;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-opacity:1\"\n           id=\"path3348\" />\n        <text\n           xml:space=\"preserve\"\n           style=\"font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;line-height:0%;font-family:'DejaVu Sans Mono';-inkscape-font-specification:'DejaVu Sans Mono';text-align:center;writing-mode:lr-tb;text-anchor:middle;fill:#000000;fill-opacity:1;stroke:none;stroke-width:3pt;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1\"\n           x=\"284.78766\"\n           y=\"362.92157\"\n           id=\"text3316\"><tspan\n             sodipodi:role=\"line\"\n             id=\"tspan3318\"\n             x=\"284.78766\"\n             y=\"362.92157\"\n             style=\"font-size:10.9335px;line-height:1\">BACK</tspan></text>\n        <path\n           id=\"path3350\"\n           style=\"fill:#dfdfdf;fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:2.06703;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-opacity:1\"\n           d=\"m 218.67656,375.05998 c 0,30.22813 -24.533,54.76113 -54.76114,54.76113 -30.22814,0 -54.76114,-24.533 -54.76114,-54.76113 0,-30.22815 24.533,-54.76115 54.76114,-54.76115 30.22814,0 54.76114,24.533 54.76114,54.76115 z m -7.99237,-10e-6 c 0,25.81636 -20.95242,46.76877 -46.76877,46.76877 -25.81636,0 -46.76878,-20.95241 -46.76878,-46.76877 0,-25.81636 20.95242,-46.76877 46.76878,-46.76877 25.81635,0 46.76877,20.95241 46.76877,46.76877 z\" />\n        <path\n           id=\"path3320\"\n           style=\"fill:none;fill-opacity:1;fill-rule:evenodd;stroke:#969696;stroke-width:0.81337;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-opacity:1\"\n           d=\"m 379.23104,433.61031 c 12.61575,0 24.35251,-4.77192 32.3309,-13.285 7.1145,-7.5913 15.68671,-13.9149 22.63475,-13.9149 6.94804,0 -0.53333,0 -0.53333,0 0,0 27.94422,0 27.94422,0 10.45366,0 18.93778,-8.48412 18.93778,-19.03121 0,-10.54708 -8.48412,-19.0312 -18.93778,-19.0312 0,0 -27.94422,0 -27.94422,0 0,0 7.48137,0 0.53333,0 -6.94804,0 -15.52025,-6.3236 -22.63475,-13.9149 -7.97839,-8.51308 -19.73829,-13.285 -32.3309,-13.285 -12.5926,0 -24.3525,4.77192 -32.33089,13.285 -7.1145,7.5913 -15.68671,13.9149 -22.63475,13.9149 -6.94804,0 0.53333,0 0.53333,0 0,0 -27.94422,0 -27.94422,0 -10.45366,0 -18.93778,8.48412 -18.93778,19.0312 0,10.54709 8.48412,19.03121 18.93778,19.03121 0,0 27.94422,0 27.94422,0 0,0 -7.48137,0 -0.53333,0 6.94804,0 15.52025,6.3236 22.63475,13.9149 7.97839,8.51308 19.71515,13.285 32.33089,13.285 z\"\n           sodipodi:nodetypes=\"cssccsccsscssccsccssc\" />\n        <path\n           id=\"path3341\"\n           style=\"fill:#dfdfdf;fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:2.06703;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-opacity:1\"\n           d=\"m 338.14038,501.44979 c 0,39.8755 -32.36275,72.23825 -72.23826,72.23825 -39.87552,0 -72.23826,-32.36275 -72.23826,-72.23825 0,-39.87552 32.36274,-72.23827 72.23826,-72.23827 39.87551,0 72.23826,32.36275 72.23826,72.23827 z m -10.54315,-1e-5 c 0,34.0557 -27.63942,61.69511 -61.69511,61.69511 -34.0557,0 -61.69512,-27.63941 -61.69512,-61.69511 0,-34.0557 27.63942,-61.69511 61.69512,-61.69511 34.05569,0 61.69511,27.63941 61.69511,61.69511 z\" />\n        <g\n           id=\"g3233-5\"\n           data-button=\"button-10\">\n          <circle\n             style=\"opacity:1;fill:#4d4d4d;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:3;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n             id=\"path3235-6\"\n             cx=\"163.84641\"\n             cy=\"375.03775\"\n             r=\"49.266716\" />\n          <circle\n             id=\"path3237-6\"\n             style=\"opacity:1;fill:#333333;fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:3;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n             cx=\"163.84641\"\n             cy=\"375.03778\"\n             r=\"34.993183\" />\n          <g\n             id=\"g3239-4\"\n             transform=\"matrix(1.0746269,0,0,1.0746269,-358.16498,-156.16434)\">\n            <circle\n               transform=\"matrix(0.08411222,0,0,0.08411222,471.14277,452.73529)\"\n               id=\"path3241-0\"\n               style=\"fill:#9b9b9b;fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:26.75;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n               cx=\"491.28583\"\n               cy=\"494.31305\"\n               r=\"49.266716\" />\n            <circle\n               style=\"fill:#9b9b9b;fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:26.75;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n               id=\"path3243-0\"\n               transform=\"matrix(0.08411222,0,0,0.08411222,417.73213,452.73529)\"\n               cx=\"491.28583\"\n               cy=\"494.31305\"\n               r=\"49.266716\" />\n            <circle\n               style=\"fill:#9b9b9b;fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:26.75;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n               id=\"path3245-4\"\n               transform=\"matrix(0,0.08411222,-0.08411222,0,527.33836,479.69524)\"\n               cx=\"491.28583\"\n               cy=\"494.31305\"\n               r=\"49.266716\" />\n            <circle\n               transform=\"matrix(0,0.08411222,-0.08411222,0,527.33836,426.2846)\"\n               id=\"path3247-6\"\n               style=\"fill:#9b9b9b;fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:26.75;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n               cx=\"491.28583\"\n               cy=\"494.31305\"\n               r=\"49.266716\" />\n          </g>\n        </g>\n        <g\n           id=\"g3224\"\n           data-button=\"button-11\">\n          <circle\n             id=\"path3196\"\n             style=\"opacity:1;fill:#4d4d4d;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:3;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n             cx=\"491.28583\"\n             cy=\"494.31305\"\n             r=\"49.266716\"\n             transform=\"translate(-5.525239)\" />\n          <circle\n             style=\"opacity:1;fill:#333333;fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:4.22368;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n             id=\"path3198\"\n             transform=\"matrix(0.7102804,0,0,0.7102804,136.8099,143.21219)\"\n             cx=\"491.28583\"\n             cy=\"494.31305\"\n             r=\"49.266716\" />\n          <g\n             transform=\"matrix(1.0746269,0,0,1.0746269,-36.250788,-36.889032)\"\n             id=\"g3218\">\n            <circle\n               style=\"fill:#9b9b9b;fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:26.75;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n               id=\"path3200\"\n               transform=\"matrix(0.08411222,0,0,0.08411222,471.14277,452.73529)\"\n               cx=\"491.28583\"\n               cy=\"494.31305\"\n               r=\"49.266716\" />\n            <circle\n               transform=\"matrix(0.08411222,0,0,0.08411222,417.73213,452.73529)\"\n               id=\"path3202\"\n               style=\"fill:#9b9b9b;fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:26.75;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n               cx=\"491.28583\"\n               cy=\"494.31305\"\n               r=\"49.266716\" />\n            <circle\n               transform=\"matrix(0,0.08411222,-0.08411222,0,527.33836,479.69524)\"\n               id=\"path3210-6\"\n               style=\"fill:#9b9b9b;fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:26.75;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n               cx=\"491.28583\"\n               cy=\"494.31305\"\n               r=\"49.266716\" />\n            <circle\n               style=\"fill:#9b9b9b;fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:26.75;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n               id=\"path3212-9\"\n               transform=\"matrix(0,0.08411222,-0.08411222,0,527.33836,426.2846)\"\n               cx=\"491.28583\"\n               cy=\"494.31305\"\n               r=\"49.266716\" />\n          </g>\n        </g>\n        <circle\n           id=\"path3405\"\n           style=\"opacity:1;fill:#dadada;fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:1.26316;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n           cx=\"645.6366\"\n           cy=\"385.60663\"\n           r=\"36.203922\" />\n        <path\n           sodipodi:nodetypes=\"cssssscsscscsc\"\n           id=\"path3363\"\n           d=\"m 692.40625,795.6875 c 36.84007,1.09337 52.80772,-18.83796 56.40625,-117.4375 3.77124,-103.33202 -63.29854,-299.68945 -82.96875,-349.21875 -19.67025,-49.52929 -118.71329,-75.82532 -163.65625,-47.5 -36.98649,23.31075 -77.50632,26.375 -127.03125,26.375 -49.52492,0 -90.0135,-3.06425 -127,-26.375 -12.6402,-7.9665 -29.58112,-11.63473 -47.8125,-11.65625 C 153.75246,269.82 98.606739,293.43208 84.46875,329.03125 64.798509,378.56054 -2.2712417,574.91797 1.5,678.25 c 3.5785642,98.05266 19.406856,118.31763 55.8125,117.45312 84.47581,-9.05099 93.14578,-56.86454 150.09375,-101.60937 52.79739,-41.48369 89.78117,-45.2585 167.46875,-43.75 77.68757,-1.50848 114.64011,2.26634 167.4375,43.75 56.94798,44.7448 65.61794,92.54276 150.09375,101.59375 z\"\n           style=\"fill:none;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:3;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\" />\n        <circle\n           style=\"opacity:1;fill:#dadada;fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:1.26316;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n           id=\"path3403\"\n           cx=\"536.64771\"\n           cy=\"385.60663\"\n           r=\"36.203922\" />\n        <circle\n           style=\"opacity:1;fill:#dadada;fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:1.26316;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n           id=\"path3407\"\n           cx=\"590.95355\"\n           cy=\"333.56348\"\n           r=\"36.203922\" />\n        <circle\n           id=\"path3409\"\n           style=\"opacity:1;fill:#dadada;fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:1.26316;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n           cx=\"590.95355\"\n           cy=\"441.04388\"\n           r=\"36.203922\" />\n        <g\n           id=\"g4272\"\n           data-button=\"button-2\">\n          <circle\n             style=\"opacity:1;fill:#004cca;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:1;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n             id=\"path3367\"\n             cx=\"536.64771\"\n             cy=\"382.96677\"\n             r=\"25.267321\" />\n          <path\n             style=\"fill:#ffffff;fill-opacity:0.486772;fill-rule:evenodd;stroke:none;stroke-width:1;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-opacity:1\"\n             d=\"m 553.83094,369.19255 c 0,5.88801 -7.72084,1.63138 -17.23402,1.63138 -9.51318,0 -17.23402,4.25663 -17.23402,-1.63138 0,-5.888 7.72084,-10.66668 17.23402,-10.66668 9.51318,0 17.23402,4.77868 17.23402,10.66668 z\"\n             id=\"path3433\"\n             sodipodi:nodetypes=\"csssc\" />\n          <path\n             sodipodi:nodetypes=\"csssc\"\n             id=\"path3462\"\n             d=\"m 557.61978,396.01861 c 0,-6.53475 -10.46192,4.49228 -21.02005,4.49228 -10.55813,0 -21.02005,-10.71153 -21.02005,-4.17678 0,6.53475 10.46192,11.52283 21.02005,11.52283 10.55813,0 21.02005,-5.30358 21.02005,-11.83833 z\"\n             style=\"fill:#000000;fill-opacity:0.26455;fill-rule:evenodd;stroke:none;stroke-width:1;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-opacity:1\" />\n        </g>\n        <text\n           xml:space=\"preserve\"\n           style=\"font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;line-height:0%;font-family:'DejaVu Sans Mono';-inkscape-font-specification:'DejaVu Sans Mono Bold';text-align:center;writing-mode:lr-tb;text-anchor:middle;fill:#000000;fill-opacity:0.70356804;stroke:none;stroke-width:3pt;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1;\"\n           x=\"491.71802\"\n           y=\"429.30984\"\n           id=\"text3381\"\n           transform=\"scale(1.0913562,0.91629113)\"><tspan\n             sodipodi:role=\"line\"\n             id=\"tspan3383\"\n             x=\"491.71802\"\n             y=\"429.30984\"\n             style=\"font-size:31.1568px;line-height:-2;fill:#000000;fill-opacity:0.70356804;\">X</tspan></text>\n        <g\n           id=\"g4267\"\n           data-button=\"button-3\">\n          <circle\n             id=\"path3371\"\n             style=\"fill:#ffaa00;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:1;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n             transform=\"scale(-1)\"\n             cx=\"-591.33069\"\n             cy=\"-328.28375\"\n             r=\"25.267321\" />\n          <path\n             sodipodi:nodetypes=\"csssc\"\n             id=\"path3436\"\n             d=\"m 609.04671,315.31534 c 0,5.88801 -7.72084,1.63138 -17.23402,1.63138 -9.51318,0 -17.23402,4.25663 -17.23402,-1.63138 0,-5.888 7.72084,-10.66668 17.23402,-10.66668 9.51318,0 17.23402,4.77868 17.23402,10.66668 z\"\n             style=\"fill:#ffffff;fill-opacity:0.486772;fill-rule:evenodd;stroke:none;stroke-width:1;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-opacity:1\" />\n          <path\n             sodipodi:nodetypes=\"csssc\"\n             id=\"path3456\"\n             d=\"m 612.51723,341.12116 c 0,-6.53475 -10.46192,4.49228 -21.02005,4.49228 -10.55813,0 -21.02005,-10.71153 -21.02005,-4.17678 0,6.53475 10.46192,11.52283 21.02005,11.52283 10.55813,0 21.02005,-5.30358 21.02005,-11.83833 z\"\n             style=\"fill:#000000;fill-opacity:0.26455;fill-rule:evenodd;stroke:none;stroke-width:1;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-opacity:1\" />\n        </g>\n        <text\n           xml:space=\"preserve\"\n           style=\"font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;line-height:0%;font-family:'DejaVu Sans Mono';-inkscape-font-specification:'DejaVu Sans Mono Bold';text-align:center;writing-mode:lr-tb;text-anchor:middle;fill:#000000;fill-opacity:0.70356804;stroke:none;stroke-width:3pt;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1;\"\n           x=\"541.82349\"\n           y=\"369.6312\"\n           id=\"text3385\"\n           transform=\"scale(1.0913562,0.91629113)\"><tspan\n             sodipodi:role=\"line\"\n             id=\"tspan3387\"\n             x=\"541.82349\"\n             y=\"369.6312\"\n             style=\"font-size:31.1568px;line-height:-2;fill:#000000;fill-opacity:0.70356804;\">Y</tspan></text>\n        <g\n           id=\"g4257\"\n           data-button=\"button-0\">\n          <circle\n             transform=\"scale(-1)\"\n             style=\"fill:#009a00;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:1;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n             id=\"path3373\"\n             cx=\"-591.33069\"\n             cy=\"-437.64978\"\n             r=\"25.267321\" />\n          <path\n             style=\"fill:#ffffff;fill-opacity:0.486772;fill-rule:evenodd;stroke:none;stroke-width:1;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-opacity:1\"\n             d=\"m 609.04671,423.73903 c 0,5.88801 -7.72084,1.63138 -17.23402,1.63138 -9.51318,0 -17.23402,4.25663 -17.23402,-1.63138 0,-5.888 7.72084,-10.66668 17.23402,-10.66668 9.51318,0 17.23402,4.77868 17.23402,10.66668 z\"\n             id=\"path3438\"\n             sodipodi:nodetypes=\"csssc\" />\n          <path\n             style=\"fill:#000000;fill-opacity:0.26455;fill-rule:evenodd;stroke:none;stroke-width:1;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-opacity:1\"\n             d=\"m 612.51723,450.91606 c 0,-6.53475 -10.46192,4.49228 -21.02005,4.49228 -10.55813,0 -21.02005,-10.71153 -21.02005,-4.17678 0,6.53475 10.46192,11.52283 21.02005,11.52283 10.55813,0 21.02005,-5.30358 21.02005,-11.83833 z\"\n             id=\"path3460\"\n             sodipodi:nodetypes=\"csssc\" />\n        </g>\n        <text\n           xml:space=\"preserve\"\n           style=\"font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;line-height:0%;font-family:'DejaVu Sans Mono';-inkscape-font-specification:'DejaVu Sans Mono Bold';text-align:center;writing-mode:lr-tb;text-anchor:middle;fill:#000000;fill-opacity:0.70356804;stroke:none;stroke-width:3pt;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1;\"\n           x=\"541.82349\"\n           y=\"488.98853\"\n           id=\"text3389\"\n           transform=\"scale(1.0913562,0.91629113)\"><tspan\n             sodipodi:role=\"line\"\n             id=\"tspan3391\"\n             x=\"541.82349\"\n             y=\"488.98853\"\n             style=\"font-size:31.1568px;line-height:-2;fill:#000000;fill-opacity:0.70356804;\">A</tspan></text>\n        <g\n           id=\"g4262\"\n           data-button=\"button-1\">\n          <circle\n             id=\"path3369\"\n             style=\"opacity:1;fill:#740000;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:1;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n             cx=\"646.01373\"\n             cy=\"382.96677\"\n             r=\"25.267321\" />\n          <path\n             sodipodi:nodetypes=\"csssc\"\n             id=\"path3440\"\n             d=\"m 663.92784,369.52718 c 0,5.88801 -7.72084,1.63138 -17.23402,1.63138 -9.51318,0 -17.23402,4.25663 -17.23402,-1.63138 0,-5.888 7.72084,-10.66668 17.23402,-10.66668 9.51318,0 17.23402,4.77868 17.23402,10.66668 z\"\n             style=\"fill:#ffffff;fill-opacity:0.486772;fill-rule:evenodd;stroke:none;stroke-width:1;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-opacity:1\" />\n          <path\n             style=\"fill:#000000;fill-opacity:0.26455;fill-rule:evenodd;stroke:none;stroke-width:1;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-opacity:1\"\n             d=\"m 667.73018,396.01861 c 0,-6.53475 -10.46192,4.49228 -21.02005,4.49228 -10.55813,0 -21.02005,-10.71153 -21.02005,-4.17678 0,6.53475 10.46192,11.52283 21.02005,11.52283 10.55813,0 21.02005,-5.30358 21.02005,-11.83833 z\"\n             id=\"path3464\"\n             sodipodi:nodetypes=\"csssc\" />\n        </g>\n        <text\n           xml:space=\"preserve\"\n           style=\"font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;line-height:0%;font-family:'DejaVu Sans Mono';-inkscape-font-specification:'DejaVu Sans Mono Bold';text-align:center;writing-mode:lr-tb;text-anchor:middle;fill:#000000;fill-opacity:0.70356804;stroke:none;stroke-width:3pt;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1;\"\n           x=\"591.54114\"\n           y=\"429.32504\"\n           id=\"text3393\"\n           transform=\"scale(1.0913562,0.91629113)\"><tspan\n             sodipodi:role=\"line\"\n             id=\"tspan3395\"\n             x=\"591.54114\"\n             y=\"429.32504\"\n             style=\"font-size:31.1568px;line-height:-2;fill:#000000;fill-opacity:0.70356804;\">B</tspan></text>\n        <text\n           xml:space=\"preserve\"\n           style=\"font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;line-height:0%;font-family:Arial;-inkscape-font-specification:Arial;text-align:start;writing-mode:lr-tb;text-anchor:start;fill:#808080;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1\"\n           x=\"334.25269\"\n           y=\"350.16708\"\n           id=\"text4416\"><tspan\n             sodipodi:role=\"line\"\n             id=\"tspan4418\"\n             x=\"334.25269\"\n             y=\"350.16708\"\n             style=\"font-size:19.0724px;line-height:1.25\">1</tspan></text>\n        <text\n           id=\"text4420\"\n           y=\"350.16708\"\n           x=\"412.03046\"\n           style=\"font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;line-height:0%;font-family:Arial;-inkscape-font-specification:Arial;text-align:start;writing-mode:lr-tb;text-anchor:start;fill:#808080;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1\"\n           xml:space=\"preserve\"><tspan\n             y=\"350.16708\"\n             x=\"412.03046\"\n             id=\"tspan4422\"\n             sodipodi:role=\"line\"\n             style=\"font-size:19.0724px;line-height:1.25\">2</tspan></text>\n        <text\n           xml:space=\"preserve\"\n           style=\"font-style:normal;font-weight:normal;line-height:0%;font-family:'Bitstream Vera Sans';fill:#007800;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1;\"\n           x=\"337.12454\"\n           y=\"424.88486\"\n           id=\"text4424\"><tspan\n             sodipodi:role=\"line\"\n             id=\"tspan4426\"\n             x=\"337.12454\"\n             y=\"424.88486\"\n             style=\"font-size:40px;line-height:1.25;fill:#007800;fill-opacity:1;\"> </tspan></text>\n        <text\n           id=\"text4428\"\n           y=\"436.35324\"\n           x=\"334.25269\"\n           style=\"font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;line-height:0%;font-family:Arial;-inkscape-font-specification:Arial;text-align:start;writing-mode:lr-tb;text-anchor:start;fill:#808080;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1\"\n           xml:space=\"preserve\"><tspan\n             y=\"436.35324\"\n             x=\"334.25269\"\n             id=\"tspan4430\"\n             sodipodi:role=\"line\"\n             style=\"font-size:19.0724px;line-height:1.25\">3</tspan></text>\n        <text\n           xml:space=\"preserve\"\n           style=\"font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;line-height:0%;font-family:Arial;-inkscape-font-specification:Arial;text-align:start;writing-mode:lr-tb;text-anchor:start;fill:#808080;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1\"\n           x=\"412.03046\"\n           y=\"436.35324\"\n           id=\"text4432\"><tspan\n             sodipodi:role=\"line\"\n             id=\"tspan4434\"\n             x=\"412.03046\"\n             y=\"436.35324\"\n             style=\"font-size:19.0724px;line-height:1.25\">4</tspan></text>\n      </g>\n    </g>\n  </g>\n  <g\n     inkscape:groupmode=\"layer\"\n     id=\"layer4\"\n     inkscape:label=\"Layer 2\"\n     transform=\"translate(-125.52048,-405.39779)\">\n\t<g cv-if = \"a\" class = \"a\">\n    <path\n       style=\"fill:none;stroke:#000000;stroke-width:0.499999;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n       d=\"m 455.79635,519.99047 69.71001,17.90083\"\n       id=\"path4466-5-6\"\n       sodipodi:nodetypes=\"cc\" /></g>\n\t<g cv-if = \"x\" class = \"x\">\n    <path\n       style=\"fill:none;stroke:#000000;stroke-width:0.499999;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n       d=\"m 438.47373,504.22466 87.03273,22.59255\"\n       id=\"path4466-6\"\n       sodipodi:nodetypes=\"cc\" /></g>\n\t<g cv-if = \"y\" class = \"y\">\n    <path\n       style=\"fill:none;stroke:#000000;stroke-width:0.499999;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n       d=\"m 457.35152,487.45952 68.15505,16.26615\"\n       id=\"path4466-5-6-4\"\n       sodipodi:nodetypes=\"cc\" /></g>\n\t<g cv-if = \"b\" class = \"b\">\n    <path\n       style=\"fill:none;stroke:#000000;stroke-width:0.499999;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n       d=\"m 473.60248,502.87892 51.90361,12.60482\"\n       id=\"path4466-6-0\"\n       sodipodi:nodetypes=\"cc\" /></g>\n    <text\n       xml:space=\"preserve\"\n       style=\"font-style:normal;font-weight:normal;font-size:40px;line-height:1.25;font-family:sans-serif;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;stroke-width:1\"\n       x=\"526.79633\"\n       y=\"517.52081\"\n       id=\"text3125-3-3-9-9\"><tspan\n\t     class = \"b\"\n         sodipodi:role=\"line\"\n         id=\"tspan3123-1-4-1-6\"\n         x=\"526.79633\"\n         y=\"517.52081\"\n         style=\"font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:6.00001px;font-family:sans-serif;-inkscape-font-specification:'sans-serif, Normal';font-variant-ligatures:normal;font-variant-caps:normal;font-variant-numeric:normal;font-variant-east-asian:normal;stroke-width:1\">[[b]]</tspan></text>\n    <text\n       xml:space=\"preserve\"\n       style=\"font-style:normal;font-weight:normal;font-size:40px;line-height:1.25;font-family:sans-serif;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;stroke-width:1\"\n       x=\"527.09454\"\n       y=\"540.36304\"\n       id=\"text3125-3-3-9-9-0\"><tspan\n\t     class = \"a\"\n         sodipodi:role=\"line\"\n         id=\"tspan3123-1-4-1-6-4\"\n         x=\"527.09454\"\n         y=\"540.36304\"\n         style=\"font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:6.00001px;font-family:sans-serif;-inkscape-font-specification:'sans-serif, Normal';font-variant-ligatures:normal;font-variant-caps:normal;font-variant-numeric:normal;font-variant-east-asian:normal;stroke-width:1\">[[a]]</tspan></text>\n    <text\n       xml:space=\"preserve\"\n       style=\"font-style:normal;font-weight:normal;font-size:40px;line-height:1.25;font-family:sans-serif;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;stroke-width:1\"\n       x=\"526.85919\"\n       y=\"529.62354\"\n       id=\"text3125-3-3-9-9-6\"><tspan\n\t     class = \"x\"\n         sodipodi:role=\"line\"\n         id=\"tspan3123-1-4-1-6-2\"\n         x=\"526.85919\"\n         y=\"529.62354\"\n         style=\"font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:6.00001px;font-family:sans-serif;-inkscape-font-specification:'sans-serif, Normal';font-variant-ligatures:normal;font-variant-caps:normal;font-variant-numeric:normal;font-variant-east-asian:normal;stroke-width:1\">[[x]]</tspan></text>\n    <text\n       xml:space=\"preserve\"\n       style=\"font-style:normal;font-weight:normal;font-size:40px;line-height:1.25;font-family:sans-serif;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;stroke-width:1\"\n       x=\"526.21417\"\n       y=\"506.18649\"\n       id=\"text3125-3-3-9-9-67\"><tspan\n\t     class = \"y\"\n         sodipodi:role=\"line\"\n         id=\"tspan3123-1-4-1-6-5\"\n         x=\"526.21417\"\n         y=\"506.18649\"\n         style=\"font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:6.00001px;font-family:sans-serif;-inkscape-font-specification:'sans-serif, Normal';font-variant-ligatures:normal;font-variant-caps:normal;font-variant-numeric:normal;font-variant-east-asian:normal;stroke-width:1\">[[y]]</tspan></text>\n\t<g cv-if = \"r1\" class = \"r1\">\n    <path\n       style=\"fill:none;stroke:#000000;stroke-width:1.55126;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n       d=\"M 656.93727,296.09185 821.8762,337.67559\"\n       id=\"path4466-5-6-4-6\"\n       sodipodi:nodetypes=\"cc\"\n       transform=\"matrix(0.32231801,0,0,0.32231801,260.60086,378.95899)\" />\n\t</g>\n    <text\n       xml:space=\"preserve\"\n       style=\"font-style:normal;font-weight:normal;font-size:124.101px;line-height:1.25;font-family:sans-serif;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;stroke-width:3.10253\"\n       x=\"824.07147\"\n       y=\"345.30997\"\n       id=\"text3125-3-3-9-9-67-9\"\n       transform=\"matrix(0.32231801,0,0,0.32231801,260.60086,378.95899)\"><tspan\n\t     class = \"r1\"\n         sodipodi:role=\"line\"\n         id=\"tspan3123-1-4-1-6-5-8\"\n         x=\"824.07147\"\n         y=\"345.30997\"\n         style=\"font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:18.6152px;font-family:sans-serif;-inkscape-font-specification:'sans-serif, Normal';font-variant-ligatures:normal;font-variant-caps:normal;font-variant-numeric:normal;font-variant-east-asian:normal;stroke-width:3.10253\">[[r1]]</tspan></text>\n\t<g cv-if = \"l1\" class = \"l1\">\n    <path\n       style=\"fill:none;stroke:#000000;stroke-width:1.55126;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n       d=\"M 98.337471,294.83145 -66.601455,336.41519\"\n       id=\"path4466-5-6-4-6-7\"\n       sodipodi:nodetypes=\"cc\"\n       transform=\"matrix(0.32231801,0,0,0.32231801,260.60086,378.95899)\" /></g>\n    <text\n       xml:space=\"preserve\"\n       style=\"font-style:normal;font-weight:normal;font-size:124.101px;line-height:1.25;font-family:sans-serif;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;stroke-width:3.10253\"\n       x=\"-147.9368\"\n       y=\"344.04959\"\n       id=\"text3125-3-3-9-9-67-9-2\"\n       transform=\"matrix(0.32231801,0,0,0.32231801,260.60086,378.95899)\"><tspan\n\t     class = \"l1\"\n         sodipodi:role=\"line\"\n         id=\"tspan3123-1-4-1-6-5-8-8\"\n         x=\"-147.9368\"\n         y=\"344.04959\"\n         style=\"font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:18.6152px;font-family:sans-serif;-inkscape-font-specification:'sans-serif, Normal';font-variant-ligatures:normal;font-variant-caps:normal;font-variant-numeric:normal;font-variant-east-asian:normal;stroke-width:3.10253\">[[l1]]</tspan></text>\n\t<g cv-if = \"dpad\">\n    <path\n       style=\"fill:none;stroke:#000000;stroke-width:1.55126;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n       d=\"M 195.45,507.2765 -65.76263,575.40558\"\n       id=\"path4466-5-6-4-6-7-2\"\n       sodipodi:nodetypes=\"cc\"\n       transform=\"matrix(0.32231801,0,0,0.32231801,260.60086,378.95899)\" />\n    <text\n       xml:space=\"preserve\"\n       style=\"font-style:normal;font-weight:normal;font-size:124.101px;line-height:1.25;font-family:sans-serif;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;stroke-width:3.10253\"\n       x=\"-122.35963\"\n       y=\"582.59192\"\n       id=\"text3125-3-3-9-9-67-9-2-9\"\n       transform=\"matrix(0.32231801,0,0,0.32231801,260.60086,378.95899)\"><tspan\n         sodipodi:role=\"line\"\n         id=\"tspan3123-1-4-1-6-5-8-8-9\"\n         x=\"-122.35963\"\n         y=\"582.59192\"\n         style=\"font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:18.6152px;font-family:sans-serif;-inkscape-font-specification:'sans-serif, Normal';font-variant-ligatures:normal;font-variant-caps:normal;font-variant-numeric:normal;font-variant-east-asian:normal;stroke-width:3.10253\">[[dpad]]</tspan></text></g>\n\t<g cv-if = \"start\">\n    <path\n       style=\"fill:none;stroke:#000000;stroke-width:1.55126;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n       d=\"M 455.73274,349.69679 V 192.16781\"\n       id=\"path3121\"\n       sodipodi:nodetypes=\"cc\"\n       transform=\"matrix(0.32231801,0,0,0.32231801,260.60086,378.95899)\" />\n    <text\n       xml:space=\"preserve\"\n       style=\"font-style:normal;font-weight:normal;font-size:124.101px;line-height:1.25;font-family:sans-serif;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;stroke-width:3.10253\"\n       x=\"427.94226\"\n       y=\"186.86783\"\n       id=\"text3125\"\n       transform=\"matrix(0.32231801,0,0,0.32231801,260.60086,378.95899)\"><tspan\n\t     class = \"start\"\n         sodipodi:role=\"line\"\n         id=\"tspan3123\"\n         x=\"427.94226\"\n         y=\"186.86783\"\n         style=\"font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:18.6152px;font-family:sans-serif;-inkscape-font-specification:'sans-serif, Normal';font-variant-ligatures:normal;font-variant-caps:normal;font-variant-numeric:normal;font-variant-east-asian:normal;stroke-width:3.10253\">[[start]]</tspan></text></g>\n\t<g cv-if = \"ra\" class = \"ra\">\n    <path\n       style=\"fill:none;stroke:#000000;stroke-width:1.55126;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n       d=\"M 542.19462,503.98223 821.8762,583.25165\"\n       id=\"path2959\"\n       sodipodi:nodetypes=\"cc\"\n       transform=\"matrix(0.32231801,0,0,0.32231801,260.60086,378.95899)\" /></g>\n    <text\n       xml:space=\"preserve\"\n       style=\"font-style:normal;font-weight:normal;font-size:124.101px;line-height:1.25;font-family:sans-serif;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;stroke-width:3.10253\"\n       x=\"832.28497\"\n       y=\"591.27563\"\n       id=\"text3125-3\"\n       transform=\"matrix(0.32231801,0,0,0.32231801,260.60086,378.95899)\"><tspan\n         sodipodi:role=\"line\"\n         id=\"tspan3123-1\"\n         x=\"832.28497\"\n         y=\"591.27563\"\n         style=\"font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:18.6152px;font-family:sans-serif;-inkscape-font-specification:'sans-serif, Normal';font-variant-ligatures:normal;font-variant-caps:normal;font-variant-numeric:normal;font-variant-east-asian:normal;stroke-width:3.10253\">[[ra]]</tspan></text>\n  </g>\n</svg>\n"
});

;require.register("debug/LineDump.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LineDump = void 0;
var _View = require("curvature/base/View");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class LineDump extends _View.View {
  constructor() {
    super(...arguments);
    _defineProperty(this, "template", `<div class = "line-dump" style = "--x:[[x]];--y:[[y]];--length:[[len]];--angle:[[angle]]">
		<div class = "line" style = "border-color:[[color]]"></div>
	</div>`);
    this.args.x = this.args.x || 0;
    this.args.y = this.args.y || 0;
  }
}
exports.LineDump = LineDump;
});

;require.register("debug/PointDump.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PointDump = void 0;
var _View = require("curvature/base/View");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class PointDump extends _View.View {
  constructor() {
    super(...arguments);
    _defineProperty(this, "template", `<div class = "point-dump">
		<div class = "point" style = "--color:[[color]]">[[x]], [[y]]</div>
	</div>`);
    this.args.x = this.args.x || 0;
    this.args.y = this.args.y || 0;
  }
}
exports.PointDump = PointDump;
});

;require.register("debug/arrow-east.svg", function(exports, require, module) {
module.exports = "<svg width=\"497.81px\" height=\"497.81px\" enable-background=\"new 0 0 497.812 497.812\" version=\"1.1\" viewBox=\"0 0 497.81 497.81\" xmlns=\"http://www.w3.org/2000/svg\">\n\t<g transform=\"matrix(-1 0 0 1 497.81 0)\">\n\t\t<path d=\"m203.66 312.91 117.03 117.03-67.906 67.875-248.91-248.91 248.91-248.91 67.906 67.875-117.06 117.06 290.28-0.031 0.031 127.97z\"/>\n\t</g>\n</svg>\n"
});

;require.register("effects/Cylinder.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Cylinder = void 0;
var _View = require("curvature/base/View");
var _Tag = require("curvature/base/Tag");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class Cylinder extends _View.View {
  constructor(args, parent) {
    super(args, parent);
    _defineProperty(this, "template", require('./twist.svg'));
    this.args.scale = this.args.scale || 0;
    this.args.id = this.args.id || 'cylinder';
    this.args.width = this.args.width || 64;
    this.args.height = this.args.height || 64;
  }
  onRendered() {
    const displacer = new _Tag.Tag(`<canvas width = "${this.args.width}" height = "${this.args.height}">`);
    const context = displacer.getContext('2d');
    context.imageSmoothingEnabled = false;
    const image = context.getImageData(0, 0, this.args.width, this.args.height);
    const pixels = image.data;
    for (let i = 0; i < pixels.length; i += 4) {
      var _r, _g, _b;
      let r,
        g,
        b,
        a,
        c,
        d = 0;
      const w = i / 4;
      const y = Math.floor(w / this.args.width);
      const x = w % this.args.width;
      const ox = x - this.args.width / 2;
      const oy = y - this.args.height / 2;
      const p = Math.hypot(ox, oy);
      const s = Math.min(this.args.width, this.args.height) / 2;
      c = Math.abs(ox / this.args.width) / 2;
      // d = p / s;

      r = 128 + ox * 4 * c;
      g = 128; // + (oy * 4) * d;
      b = 0;
      pixels[i + 0] = (_r = r) !== null && _r !== void 0 ? _r : 128;
      pixels[i + 1] = (_g = g) !== null && _g !== void 0 ? _g : 128;
      pixels[i + 2] = (_b = b) !== null && _b !== void 0 ? _b : 128;
      pixels[i + 3] = a !== null && a !== void 0 ? a : 255;
    }
    context.putImageData(image, 0, 0);
    displacer.toBlob(png => this.args.blob = URL.createObjectURL(png), 'image/png');
  }
  get name() {
    return `${this.args.id}`;
    // return `filter_${this.args.id}`;
  }
}
exports.Cylinder = Cylinder;
});

;require.register("effects/Droop.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Droop = void 0;
var _View = require("curvature/base/View");
var _Tag = require("curvature/base/Tag");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class Droop extends _View.View {
  constructor(args, parent) {
    super(args, parent);
    _defineProperty(this, "template", require('./droop.svg'));
    this.args.scale = this.args.scale || 0;
    this.args.id = this.args.id || 'droop';
    this.args.width = (args.width || 64) * 2;
    this.args.height = args.height || 64;
    this.args.intensity = 1.0;
    this.args.droopWidth = '102%';
  }
  static generateMap(width, height) {
    const memoKey = `${width}::${height}`;
    const memoMap = this.memoMaps;
    if (memoMap.has(memoKey)) {
      return memoMap.get(memoKey);
    }
    const displacer = new _Tag.Tag(`<canvas width = "${width}" height = "${height}">`);
    const context = displacer.getContext('2d');
    context.imageSmoothingEnabled = false;
    const image = context.getImageData(0, 0, width, height);
    const pixels = image.data;
    for (let i = 0; i < pixels.length; i += 4) {
      var _r, _g, _b, _a;
      let r,
        g,
        b,
        a,
        c,
        d = 0;
      const w = i / 4;
      const y = Math.floor(w / width);
      const x = w % width;
      const ux = x / width;
      const uy = y / height;
      const input = -Math.PI + ux * Math.PI;
      r = 128;
      g = 128 + Math.round(128 * (Math.cos(input) * 0.5 + 0.5));
      b = 0;
      a = 255;
      pixels[i + 0] = (_r = r) !== null && _r !== void 0 ? _r : 128;
      pixels[i + 1] = (_g = g) !== null && _g !== void 0 ? _g : 128;
      pixels[i + 2] = (_b = b) !== null && _b !== void 0 ? _b : 128;
      pixels[i + 3] = (_a = a) !== null && _a !== void 0 ? _a : 255;
    }
    context.putImageData(image, 0, 0);
    const ret = new Promise(accept => displacer.toBlob(png => {
      const blob = URL.createObjectURL(png, 'image/png');
      accept(blob);
    }));
    memoMap.set(memoKey, ret);
    return ret;
  }
  onRendered() {
    this.constructor.generateMap(this.args.width, this.args.height).then(image => {
      this.args.blob = image;
    });
  }
  get name() {
    return `${this.args.id}`;
    // return `filter_${this.args.id}`;
  }
}
exports.Droop = Droop;
_defineProperty(Droop, "memoMaps", new Map());
});

;require.register("effects/Pinch.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Pinch = void 0;
var _View = require("curvature/base/View");
var _Tag = require("curvature/base/Tag");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class Pinch extends _View.View {
  constructor(args, parent) {
    super(args, parent);
    _defineProperty(this, "template", require('./twist.svg'));
    this.args.scale = this.args.scale || 0;
    this.args.id = this.args.id || 'pinch';
    this.args.width = this.args.width || 64;
    this.args.height = this.args.height || 64;
  }
  onRendered() {
    const displacer = new _Tag.Tag(`<canvas width = "${this.args.width}" height = "${this.args.height}">`);
    const context = displacer.getContext('2d');
    context.imageSmoothingEnabled = false;
    const image = context.getImageData(0, 0, this.args.width, this.args.height);
    const pixels = image.data;
    for (let i = 0; i < pixels.length; i += 4) {
      var _r, _g, _b;
      let r,
        g,
        b,
        a,
        c,
        d = 0;
      const w = i / 4;
      const y = Math.floor(w / this.args.width);
      const x = w % this.args.width;
      const ox = x - this.args.width / 2;
      const oy = y - this.args.height / 2;
      const p = Math.hypot(ox, oy);
      const ss = Math.min(this.args.width, this.args.height);
      const s = ss / 2;
      if (p < s) {
        c = (1 - p / s) ** 2;
        d = (1 - p / s) ** 2;
      } else {
        c = 0;
        d = 0;
      }
      r = 128 + ox * 4 * c;
      g = 128 + oy * 4 * d;
      b = 0;
      pixels[i + 0] = (_r = r) !== null && _r !== void 0 ? _r : 128;
      pixels[i + 1] = (_g = g) !== null && _g !== void 0 ? _g : 128;
      pixels[i + 2] = (_b = b) !== null && _b !== void 0 ? _b : 128;
      pixels[i + 3] = a !== null && a !== void 0 ? a : 255;
    }
    context.putImageData(image, 0, 0);
    displacer.toBlob(png => this.args.blob = URL.createObjectURL(png), 'image/png');
  }
  get name() {
    return `${this.args.id}`;
    // return `filter_${this.args.id}`;
  }
}
exports.Pinch = Pinch;
});

;require.register("effects/ScreenFire.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ScreenFire = void 0;
var _View = require("curvature/base/View");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class ScreenFire extends _View.View {
  constructor() {
    super(...arguments);
    _defineProperty(this, "template", require('./screen-fire'));
  }
  onAttach(event) {
    this.args.animation = 'playing';
  }
}
exports.ScreenFire = ScreenFire;
});

;require.register("effects/ScreenWarp.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ScreenWarp = void 0;
var _View = require("curvature/base/View");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class ScreenWarp extends _View.View {
  constructor() {
    super(...arguments);
    _defineProperty(this, "template", require('./screen-fire'));
  }
  onAttach(event) {
    this.args.animation = 'playing';
    this.onTimeout(5000, () => this.remove());
  }
}
exports.ScreenWarp = ScreenWarp;
});

;require.register("effects/Twist.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Twist = void 0;
var _View = require("curvature/base/View");
var _Tag = require("curvature/base/Tag");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class Twist extends _View.View {
  constructor(args, parent) {
    super(args, parent);
    _defineProperty(this, "template", require('./twist.svg'));
    this.args.scale = this.args.scale || 0;
    this.args.id = this.args.id || 'twist';
    this.args.width = this.args.width || 64;
    this.args.height = this.args.height || 64;
    this.args.dx = 0;
    this.args.dy = 0;
  }
  onRendered() {
    const displacer = new _Tag.Tag('<canvas width = "64" height = "64">');
    const context = displacer.getContext('2d');
    context.imageSmoothingEnabled = false;
    const image = context.getImageData(0, 0, 64, 64);
    const pixels = image.data;
    for (let i = 0; i < pixels.length; i += 4) {
      var _r, _g;
      let r,
        g,
        b,
        a,
        c = 1;
      const w = i / 4;
      const y = Math.floor(w / 64);
      const x = w % 64;
      const ox = x - 31.5;
      const oy = y - 31.5;
      const p = Math.hypot(ox, oy);
      if (p > 32) {
        c = 0;
      } else {
        c = (1 - p / 32) ** 3;
      }
      r = 128 + oy * 4 * c;
      g = 128 - ox * 4 * c;
      pixels[i + 0] = (_r = r) !== null && _r !== void 0 ? _r : 0;
      pixels[i + 1] = (_g = g) !== null && _g !== void 0 ? _g : 0;
      pixels[i + 2] = b !== null && b !== void 0 ? b : 0;
      pixels[i + 3] = a !== null && a !== void 0 ? a : 255;
    }
    context.putImageData(image, 0, 0);
    displacer.toBlob(png => this.args.blob = URL.createObjectURL(png), 'image/png');
  }
  get name() {
    return `${this.args.id}`;
    // return `filter_${this.args.id}`;
  }
}
exports.Twist = Twist;
});

;require.register("effects/droop.svg", function(exports, require, module) {
module.exports = "<svg\n\twidth  =\"100%\"\n\theight =\"100%\"\n>\n\t<defs>\n\n\t\t<filter\n\t\t\tcv-ref = \"filter\"\n\t\t\tcolor-interpolation-filters=\"sRGB\"\n\t\t\tid = \"[[id]]\"\n\t\t\twidth  =\"102%\"\n\t\t\theight =\"1204%\"\n\t\t\tx  = \"-1%\"\n\t\t\ty  = \"-2%\"\n\n\t\t>\n\t\t\t<feImage\n\t\t\t\tpreserveAspectRatio = \"none\"\n\t\t\t\tresult  = \"DisplacementSourceLeft\"\n\t\t\t\tcv-attr = \"width:droopWidthLeft,href:blob\"\n\t\t\t/>\n\n\t\t\t<feImage\n\t\t\t\tpreserveAspectRatio = \"none\"\n\t\t\t\tresult  = \"DisplacementSourceRightInvert\"\n\t\t\t\tcv-attr = \"x:droopRightStart,width:droopWidthRight,href:blob\"\n\t\t\t/>\n\n\t\t\t<feColorMatrix\n\t\t\t\tin     = \"DisplacementSourceRightInvert\"\n\t\t\t\tresult = \"DisplacementSourceRight\"\n\t\t\t\ttype   = \"matrix\"\n\t\t\t\tvalues=\"\n\t\t\t\t\t1 0 0 0 0\n\t\t\t\t\t0 -1 0 0 1.5\n\t\t\t\t\t0 0 1 0 0\n\t\t\t\t\t0 0 0 1 0\"\n\t\t\t/>\n\n\t\t\t<feComposite\n\t\t\t\toperator=\"over\"\n\t\t\t\tin     = \"DisplacementSourceLeft\"\n\t\t\t\tin2    = \"DisplacementSourceRight\"\n\t\t\t\tresult = \"DisplacementSource\"\n\t\t\t\twidth  =\"102%\"\n\t\t\t/>\n\n\t\t\t<feFlood flood-color=\"#808000\" result = \"OffsetNeutral\" />\n\n\t\t\t<feComposite\n\t\t\t\toperator=\"over\"\n\t\t\t\tin     = \"DisplacementSource\"\n\t\t\t\tin2    = \"OffsetNeutral\"\n\t\t\t\tresult = \"DisplacementResult\"\n\t\t\t\twidth  =\"102%\"\n\t\t\t/>\n\n\t\t\t<feComposite\n\t\t\t\toperator=\"over\"\n\t\t\t\tin     = \"DisplacementSource\"\n\t\t\t\tin2    = \"OffsetNeutral\"\n\t\t\t\tresult = \"DisplacementResult\"\n\t\t\t\twidth  =\"102%\"\n\t\t\t/>\n\n\t\t\t<feDisplacementMap\n\t\t\t\txChannelSelector = \"R\"\n\t\t\t\tyChannelSelector = \"G\"\n\t\t\t\tin      = \"SourceGraphic\"\n\t\t\t\tin2     = \"DisplacementResult\"\n\t\t\t\tcv-ref  = \"displace\"\n\t\t\t\tcv-attr = \"scale:scale\"\n\t\t\t\twidth  =\"102%\"\n\t\t\t/>\n\n\t\t</filter>\n\n\t</defs>\n</svg>\n"
});

;require.register("effects/screen-fire.html", function(exports, require, module) {
module.exports = "<div class = \"screen-fire [[animation]]\">\n\t<div class = \"fire-strip\" style = \"--index:0\"><div></div></div>\n\t<div class = \"fire-strip\" style = \"--index:1\"><div></div></div>\n\t<div class = \"fire-strip\" style = \"--index:2\"><div></div></div>\n\t<div class = \"fire-strip\" style = \"--index:3\"><div></div></div>\n\t<div class = \"fire-strip\" style = \"--index:4\"><div></div></div>\n\t<div class = \"fire-strip\" style = \"--index:5\"><div></div></div>\n\t<div class = \"fire-strip\" style = \"--index:6\"><div></div></div>\n\t<div class = \"fire-strip\" style = \"--index:7\"><div></div></div>\n\t<div class = \"fire-strip\" style = \"--index:8\"><div></div></div>\n\t<div class = \"fire-strip\" style = \"--index:9\"><div></div></div>\n\t<div class = \"fire-strip\" style = \"--index:10\"><div></div></div>\n\t<div class = \"fire-strip\" style = \"--index:11\"><div></div></div>\n\t<div class = \"fire-strip\" style = \"--index:12\"><div></div></div>\n\t<div class = \"fire-strip\" style = \"--index:13\"><div></div></div>\n\t<div class = \"fire-strip\" style = \"--index:14\"><div></div></div>\n\t<div class = \"fire-strip\" style = \"--index:15\"><div></div></div>\n\t<div class = \"fire-strip\" style = \"--index:16\"><div></div></div>\n</div>\n"
});

;require.register("effects/twist.svg", function(exports, require, module) {
module.exports = "<svg\n\theight =\"100%\"\n\twidth  =\"100%\"\n>\n\t<defs>\n\n\t\t<filter\n\t\t\tcv-ref = \"filter\"\n\t\t\tcolor-interpolation-filters=\"sRGB\"\n\t\t\theight = \"100%\"\n\t\t\twidth  = \"100%\"\n\t\t\tid     = \"[[id]]\"\n\t\t\tx      = \"0%\"\n\t\t\ty      = \"0%\"\n\n\t\t>\n\t\t\t<feFlood\n\t\t\t\tflood-color=\"#808000\"\n\t\t\t\theight = \"100%\"\n\t\t\t\twidth  = \"100%\"\n\t\t\t\tresult = \"OffsetNeutral\"\n\t\t\t\tx=\"0\"\n\t\t\t\ty=\"0\"\n\t\t\t/>\n\n\t\t\t<feImage\n\t\t\t\txlink:href=\"[[blob]]\"\n\t\t\t\tresult = \"DisplacementSource\"\n\t\t\t\theight = \"100%\"\n\t\t\t\twidth  = \"100%\"\n\t\t\t/>\n\n\t\t\t<feOffset\n\t\t\t\tin      = \"DisplacementSource\"\n\t\t\t\tresult  = \"OffsetSource\"\n\t\t\t\tcv-attr =  \"dx:dx,dy:dy\"\n\t\t\t/>\n\n\t\t\t<feComposite\n\t\t\t\toperator=\"over\"\n\t\t\t\tin2    = \"OffsetNeutral\"\n\t\t\t\tin     = \"OffsetSource\"\n\t\t\t\tresult = \"DisplacementResult\"\n\t\t\t/>\n\n\t\t\t<feDisplacementMap\n\t\t\t\txChannelSelector = \"R\"\n\t\t\t\tyChannelSelector = \"G\"\n\t\t\t\tin      = \"SourceGraphic\"\n\t\t\t\tin2     = \"DisplacementResult\"\n\t\t\t\tcv-ref  = \"displace\"\n\t\t\t\tcv-attr = \"scale:scale\"\n\t\t\t/>\n\n\t\t</filter>\n\n\t</defs>\n</svg>\n"
});

;require.register("initialize.js", function(exports, require, module) {
"use strict";

var _Bgm = require("./audio/Bgm");
var _Sfx = require("./audio/Sfx");
var _Viewport = require("./viewport/Viewport");
var _Matrix = require("matrix-api/Matrix");
// import { Tag } from 'curvature/base/Tag';

_Bgm.Bgm.register('MENU_THEME', '/Sonic/s3k-competition.mp3');
if (location.pathname === '/accept-sso') {
  const baseUrl = 'https://matrix.org/_matrix';
  const matrix = new _Matrix.Matrix(baseUrl);

  // Get the loginToken from the query string.
  const query = new URLSearchParams(location.search);
  const token = query.get('loginToken');

  // Complete the SSO and close the window.
  matrix.completeSso(token);
} else {
  const viewportA = new _Viewport.Viewport();
  document.addEventListener('DOMContentLoaded', function () {
    const getFPS = () => new Promise(accept => requestAnimationFrame(t1 => requestAnimationFrame(t2 => accept(1000 / (t2 - t1)))));
    console.log('Starting...');
    if (navigator.serviceWorker) {
      navigator.serviceWorker.register('/worker-cache.js');
    }
    let lastTime = 0;
    const frameTimes = [];
    const update = now => {
      const frameTime = now - lastTime;
      const frameAgeMin = 1000 / (viewportA.args.maxFps || 61);
      if (frameTime < frameAgeMin) {
        requestAnimationFrame(update);
        return;
      }
      viewportA.update();
      viewportA.args.fps = 1000 / frameTime;
      lastTime = now;
      requestAnimationFrame(update);
    };
    viewportA.render(document.body);
    update();
  });

  /*** BGM ***/

  _Bgm.Bgm.register('STAR_SHIELD', '/audio/leslie-wai/feel-the-sunshine.mp3');
  _Bgm.Bgm.register('RADICAL_CITY', '/audio/colbreakz/848482_ColBreakz---My-Universe.mp3');
  _Bgm.Bgm.register('WEST_SIDE', '/audio/akselmcbossmcgee123/1066486_Blammed-By-Pico.mp3');
  _Bgm.Bgm.register('UNDERGROUND_ZONE', '/audio/tee-lopes/under-ground-zone-remix.mp3');
  _Bgm.Bgm.register('MISTY_RUINS', 'audio/neil-voss/extol.mp3');
  _Bgm.Bgm.register('MANIC_HARBOR', '/audio/bobenshibobsled/1024371_Curse-Ska-Version.mp3');
  _Bgm.Bgm.register('STRATORAIL', '/audio/PlasmaGlow/1274013_Nitro-by-Plasma-Glow-Neuro.mp3');
  _Bgm.Bgm.register('TITLE_THEME', '/Sonic/carnival-night-zone-act-2-beta.mp3');
  _Bgm.Bgm.register('TUTORIAL_THEME', '/audio/teravex/1083419_Lowbeat.mp3');
  _Bgm.Bgm.register('CITY_ESCAPE', '/audio/senoue-jun/city-escape.mp3');
  _Bgm.Bgm.register('AGORAPOLIS', '/audio/AetheR/1063556_Forest.mp3');
  _Bgm.Bgm.register('ACT-BOSS', '/audio/F-777/Double-Cross.mp3');
  _Bgm.Bgm.register('ZONE-BOSS', '/audio/dex-arson/rampage.mp3');
  _Bgm.Bgm.register('ACT_CLEAR', '/audio/gta-sa/mission-passed.mp3', {
    volume: 1
  });
  _Bgm.Bgm.register('NO_WAY', '/audio/sonic/no-way.mp3');

  /*** SFX ***/

  _Sfx.Sfx.register('WTF_BOOM', '/audio/meme/wtf-boom.mp3');
  _Sfx.Sfx.register('PLAYER_DAMAGED', '/Sonic/S3K_35.wav');
  _Sfx.Sfx.register('RINGS_SCATTERED', '/Sonic/ring-loss.wav', {
    maxConcurrent: 3,
    volume: 0.75,
    fudgeFactor: 0
  });
  _Sfx.Sfx.register('BUMPER_BOUNCE', '/Sonic/S3K_AA.wav');
  _Sfx.Sfx.register('BOOST_RING', '/Sonic/S3K_CA.wav', {
    maxConcurrent: 1,
    volume: 0.75,
    fudgeFactor: 0.2
  });
  _Sfx.Sfx.register('RING_COLLECTED', '/Sonic/ring-collect.wav', {
    maxConcurrent: 3,
    volume: 0.25,
    fudgeFactor: 0.1
  });
  _Sfx.Sfx.register('SPIKE_DAMAGE', '/Sonic/S2_26.wav', {
    maxConcurrent: 1,
    volume: 0.5,
    fudgeFactor: 0.1
  });
  _Sfx.Sfx.register('EMBLEM_COLLECTED', '/custom/emblem-collect.wav', {
    maxConcurrent: 3,
    volume: 0.25,
    fudgeFactor: 0.1
  });
  _Sfx.Sfx.register('EMERALD_COLLECTED', '/Sonic/S3K_9C.wav');
  _Sfx.Sfx.register('OBJECT_DESTROYED', '/Sonic/object-destroyed.wav', {
    maxConcurrent: 8,
    volume: 0.75,
    fudgeFactor: 0.3
  });
  _Sfx.Sfx.register('BOX_DESTROYED', '/Sonic/S3K_B4.wav', {
    maxConcurrent: 4,
    volume: 1,
    fudgeFactor: 0,
    startTime: 0.0
  });
  _Sfx.Sfx.register('BLOCK_DESTROYED', '/Sonic/0A3H.wav', {
    maxConcurrent: 4,
    volume: 1,
    fudgeFactor: 0,
    startTime: 0.2,
    throttle: 100
  });
  _Sfx.Sfx.register('WORM_BLOCK_DESTROYED', '/Sonic/0A3H.wav', {
    maxConcurrent: 4,
    volume: 0.8,
    fudgeFactor: 0.2,
    startTime: 0.2,
    throttle: 100
  });
  _Sfx.Sfx.register('ROCKS_DESTROYED', '/Sonic/rock-smash.wav');
  _Sfx.Sfx.register('ROCK_BREAK_1', '/Sonic/S1_B9.wav', {
    maxConcurrent: 1,
    volume: 0.75,
    fudgeFactor: 0.3
  });
  _Sfx.Sfx.register('ROCK_BREAK_2', '/Sonic/S1_CB.wav', {
    maxConcurrent: 1,
    volume: 0.50,
    fudgeFactor: 0.1
  });
  _Sfx.Sfx.register('SPEEDPAD_HIT', '/Sonic/S2_2B.wav', {
    maxConcurrent: 3,
    volume: 0.75,
    fudgeFactor: 0.1
  });
  _Sfx.Sfx.register('HALLBOOSTER_HIT', '/Sonic/S3K_74.wav', {
    maxConcurrent: 1,
    volume: 0.75,
    fudgeFactor: 0.1
  });
  _Sfx.Sfx.register('SPRING_HIT', '/Sonic/spring-activated.wav', {
    maxConcurrent: 2,
    volume: 0.5,
    fudgeFactor: 0.1
  });
  _Sfx.Sfx.register('NOTCH_SPRING_HIT', '/Sonic/S3K_7B.wav', {
    maxConcurrent: 1,
    volume: 0.5,
    fudgeFactor: 0.2
  });
  _Sfx.Sfx.register('SWITCH_HIT', '/Sonic/switch-activated.wav', {
    maxConcurrent: 3,
    volume: 0.3,
    fudgeFactor: 0.2
  });
  _Sfx.Sfx.register('ALT_BEEP', '/Sonic/S2_28.wav', {
    maxConcurrent: 8,
    volume: 0.5,
    fudgeFactor: 0.2
  });
  _Sfx.Sfx.register('KNOCK_PLATFORM', '/Sonic/S2_57.wav', {
    maxConcurrent: 3,
    volume: 0.8,
    fudgeFactor: 0.2
  });
  _Sfx.Sfx.register('STAR_TWINKLE', '/Sonic/S2_27.wav', {
    maxConcurrent: 3,
    volume: 0.8,
    fudgeFactor: 0.2
  });
  _Sfx.Sfx.register('PAD_BOUNCE', '/Sonic/S2_58.wav', {
    maxConcurrent: 3,
    volume: 0.8,
    fudgeFactor: 0.2
  });
  _Sfx.Sfx.register('SPRING_SHOT', '/Sonic/S2_62.wav', {
    maxConcurrent: 3,
    volume: 0.8,
    fudgeFactor: 0.2
  });
  _Sfx.Sfx.register('QUICK_SLIDE', '/Sonic/S2_5B.wav', {
    maxConcurrent: 1,
    volume: 0.3,
    fudgeFactor: 0.2
  });
  _Sfx.Sfx.register('SS_BWIP', '/Sonic/S1_A9.wav', {
    maxConcurrent: 1,
    volume: 0.7,
    fudgeFactor: 0.2
  });
  _Sfx.Sfx.register('SS_BWIP_HIGH', '/Sonic/S2_29.wav', {
    maxConcurrent: 8,
    volume: 0.85,
    fudgeFactor: 0.2
  });
  _Sfx.Sfx.register('WAIT_TONE', '/Sonic/S3K_A7.wav', {
    maxConcurrent: 8,
    volume: 0.5,
    fudgeFactor: 0.2
  });
  _Sfx.Sfx.register('READY_TONE', '/Sonic/S3K_AD.wav', {
    maxConcurrent: 8,
    volume: 0.5,
    fudgeFactor: 0.2
  });
  _Sfx.Sfx.register('BALL_SWITCH', '/Sonic/S3K_AD.wav', {
    maxConcurrent: 8,
    volume: 0.5,
    fudgeFactor: 0.2,
    startTime: 0.1
  });
  _Sfx.Sfx.register('STARPOST_HIT', '/Sonic/starpost-active.wav', {
    volume: 0.5
  });
  _Sfx.Sfx.register('SHOT_FIRED', '/Sonic/shot-fired.wav', {
    volume: 0.5
  });
  _Sfx.Sfx.register('THRUSTER_FIRED', '/Sonic/mecha-sonic-thruster.wav');
  _Sfx.Sfx.register('BOSS_DAMAGED', '/Sonic/S3K_6E.wav');
  _Sfx.Sfx.register('BOSS_DUDHIT', '/Sonic/S2_59.wav');
  _Sfx.Sfx.register('FAIL', '/Sonic/S2_6D.wav');
  _Sfx.Sfx.register('HEAVY_THUD', '/Sonic/S3K_96.wav', {
    maxConcurrent: 3,
    volume: 1,
    fudgeFactor: 0.2,
    startTime: 0.00
  });
  _Sfx.Sfx.register('WOOD_THUD', '/Sonic/S3K_5F_smoother.wav', {
    maxConcurrent: 3,
    volume: 1,
    fudgeFactor: 0.2,
    startTime: 0.04
  });
  _Sfx.Sfx.register('WATER_ACQUIRE', '/Sonic/S3K_3F.wav', {
    volume: 0.75,
    fudgeFactor: 0.1
  });
  _Sfx.Sfx.register('WATER_BOUNCE', '/Sonic/S3K_44.wav', {
    volume: 0.5,
    fudgeFactor: 0.1
  });
  _Sfx.Sfx.register('ELECTRIC_ACQUIRE', '/Sonic/S3K_41.wav', {
    volume: 0.75,
    fudgeFactor: 0.1
  });
  _Sfx.Sfx.register('ELECTRIC_JUMP', '/Sonic/S3K_45.wav', {
    maxConcurrent: 3,
    volume: 0.5,
    fudgeFactor: 0.1
  });
  _Sfx.Sfx.register('FIRE_ACQUIRE', '/Sonic/S3K_3E.wav', {
    volume: 0.75,
    fudgeFactor: 0.1
  });
  _Sfx.Sfx.register('FIRE_DASH', '/Sonic/S3K_43.wav', {
    volume: 0.5,
    fudgeFactor: 0.1
  });
  _Sfx.Sfx.register('CHOPPER_DRONE', '/Sonic/drill-car-copter.wav');
  _Sfx.Sfx.register('CHOPPER_GUN', '/Sonic/010.Synth_MLT_se_ac_bf_ricochet.wav', {
    maxConcurrent: 4,
    volume: 0.5,
    fudgeFactor: 0.25
  });
  _Sfx.Sfx.register('MECHASONIC_TAKEOFF', '/Sonic/mecha-sonic-takeoff.wav');
  _Sfx.Sfx.register('MECHASONIC_SCRAPE', '/Sonic/mecha-sonic-scrape.wav');
  _Sfx.Sfx.register('MECHASONIC_SLAP', '/Sonic/mecha-sonic-thruster-close.wav');
  _Sfx.Sfx.register('TAILS_FLY', '/Sonic/tails-flying.wav');
  _Sfx.Sfx.register('DOOT_DOOT', '/audio/meme/doot-doot.mp3');
  _Sfx.Sfx.register('HOOK_GRABBED', '/Sonic/S3K_4A.wav');
  // Sfx.register('ROCKET_THRUST', '/Sonic/S3K_47.wav');

  _Sfx.Sfx.register('LIGTNING_STRIKE', '/Sonic/S3K_4E.wav', {
    maxConcurrent: 1,
    volume: 1,
    fudgeFactor: 0
  });
  _Sfx.Sfx.register('SECRET_FOUND', '/doom/dssecret.wav');
  _Sfx.Sfx.register('SICK_TRICK', '/Sonic/S2_6C.wav', {
    volume: 1,
    fudgeFactor: 0,
    maxConcurrent: 6
  });
  _Sfx.Sfx.register('GRINDING', '/Sonic/S3K_DB_sus.wav');
  _Sfx.Sfx.register('SPIKES_OUT', '/Sonic/S3K_A6.wav');
  _Sfx.Sfx.register('SPIKES_IN', '/Sonic/S3K_52.wav');
  _Sfx.Sfx.register('LID_POP', '/Sonic/S2_54.wav', {
    maxConcurrent: 1,
    volume: 0.5,
    fudgeFactor: 0.25
  });
  _Sfx.Sfx.register('PROP_PLAT', '/Sonic/S3K_PropPlat.wav', {
    maxConcurrent: 1,
    volume: 0.5,
    fudgeFactor: 0.25
  });
  _Sfx.Sfx.register('POGO_BOUNCE', '/Sonic/0A8H.wav', {
    maxConcurrent: 3,
    volume: 0.5,
    fudgeFactor: 0.25
  });
  _Sfx.Sfx.register('COPTER_SPIN', '/Sonic/drill-car-copter.wav', {
    maxConcurrent: 1,
    volume: 0.5,
    fudgeFactor: 0
  });
  _Sfx.Sfx.register('TOTAL_SCORE', '/Sonic/S3K_B0.wav', {
    maxConcurrent: 1,
    volume: 1,
    fudgeFactor: 0
  });
  _Sfx.Sfx.register('TALLY_SCORE', '/Sonic/B00_00_05.WAV', {
    maxConcurrent: 1,
    volume: 0.5,
    fudgeFactor: 0
  });
  _Sfx.Sfx.register('TALLY_SCORE', '/Sonic/027.Synth_MLT_menu_score menu text appear.wav', {
    maxConcurrent: 1,
    volume: 0.5,
    fudgeFactor: 0
  });
  _Sfx.Sfx.register('RADIO_CHATTER_1', '/thps2/CD_00171.wav', {
    maxConcurrent: 1,
    volume: 1,
    fudgeFactor: 0
  });
  _Sfx.Sfx.register('RADIO_CHATTER_2', '/thps2/CD_00181.wav', {
    maxConcurrent: 1,
    volume: 1,
    fudgeFactor: 0
  });
  _Sfx.Sfx.register('BARREL_EXPLODE', '/audio/doom/DSBAREXP.wav', {
    maxConcurrent: 1,
    volume: 1,
    fudgeFactor: 0
  });
  _Sfx.Sfx.register('SAP_HEALTH', '/audio/pokemon/SFX_POISONED.wav', {
    maxConcurrent: 1,
    volume: 0.5,
    fudgeFactor: 0.25,
    startTime: 0.1
  });
  _Sfx.Sfx.register('BREAK_GLASS_1', '/Sonic/SCD_FM_51.wav', {
    maxConcurrent: 1,
    volume: 0.85,
    fudgeFactor: 0.15,
    startTime: 0.1
  });
  _Sfx.Sfx.register('BREAK_GLASS_2', '/Sonic/SCD_FM_52.wav', {
    maxConcurrent: 1,
    volume: 0.50,
    fudgeFactor: 0.25,
    startTime: 0.1
  });
}
});

;require.register("intro/BootCard.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BootCard = void 0;
var _Card = require("./Card");
class BootCard extends _Card.Card {
  constructor(args, parent) {
    super(args, parent);
    this.args.cardName = 'boot-card';
    this.args.text = `PRODUCED BY
SEAN MORRIS UNDER
THE APACHE 2.0 LICENSE`;
  }
}
exports.BootCard = BootCard;
});

;require.register("intro/Card.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Card = void 0;
var _View = require("curvature/base/View");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class Card extends _View.View {
  constructor() {
    let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let parent = arguments.length > 1 ? arguments[1] : undefined;
    super(args, parent);
    _defineProperty(this, "template", require('./card.html'));
    args.text = args.text || 'this is an intro card.';
    this.args.timeout = this.args.timeout || 1000;
    this.args.animation = 'opening';
    this.done = new Promise(accept => this.accept = accept);
  }
  play(event) {
    this.onTimeout(50, () => this.args.animation = 'opened');
    const waitFor = this.args.waitFor || Promise.resolve();
    return new Promise(accept => {
      waitFor.then(() => {
        const timeAcc = this.args.timeout;
        if (timeAcc > 0) {
          this.onTimeout(timeAcc - 500, () => this.args.animation = 'closing');
          this.onTimeout(timeAcc, () => {
            this.args.animation = 'closed';
            const done = new Promise(acceptDone => this.onTimeout(timeAcc, acceptDone));
            accept(this.accept([done]));
          });
        }
      });
    });
  }
}
exports.Card = Card;
});

;require.register("intro/DebianCard.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DebianCard = void 0;
var _SkippableCard = require("./SkippableCard");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class DebianCard extends _SkippableCard.SkippableCard {
  constructor(args, parent) {
    super(args, parent);
    _defineProperty(this, "template", require('./debian-card.html'));
    this.args.cardName = 'debian-card';
    this.args.text = ``;
  }
}
exports.DebianCard = DebianCard;
});

;require.register("intro/GamepadCard.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GamepadCard = void 0;
var _SkippableCard = require("./SkippableCard");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class GamepadCard extends _SkippableCard.SkippableCard {
  constructor(args, parent) {
    super(args, parent);
    _defineProperty(this, "template", require('./gamepad-card.html'));
    this.args.timeout = this.args.timeout || 2500;
    this.args.cardName = 'gamepad-card';
    this.args.text = ``;
  }
}
exports.GamepadCard = GamepadCard;
});

;require.register("intro/LoadingCard.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LoadingCard = void 0;
var _Card = require("./Card");
class LoadingCard extends _Card.Card {
  constructor(args, parent) {
    super(args, parent);
    this.args.cardName = 'loading-card';
  }
}
exports.LoadingCard = LoadingCard;
});

;require.register("intro/LogoSplash.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LogoSplash = void 0;
var _View = require("curvature/base/View");
var _Sfx = require("../audio/Sfx");
class LogoSplash extends _View.View {
  constructor() {
    let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let parent = arguments.length > 1 ? arguments[1] : undefined;
    super(args, parent);
    this.template = `
		<div class = "player-waving"></div>
		<div class = "splash [[animation]]" style = "
			pointer-events: [[pointerEvents]]
		">
			<div class = "center">SEAN<span class = "min">MORRIS</span><div class = "sm">SM</div></div>
			<div class = "center">SEAN<span class = "min">MORRIS</span><div class = "sm">SM</div></div>
			<div class = "center">SEAN<span class = "min">MORRIS</span><div class = "sm">SM</div></div>
		</div>`;
  }
  onAttached() {
    if (this.alreadyAttached) {
      return;
    }
    this.alreadyAttached = true;
    this.args.left = 0;
    this.args.right = 0;
    this.args.fade = 1;
    this.args.frame = 0;
    this.args.fullFade = 1;
    this.args.pointerEvents = 'all';
    this.args.animation = 'hide';
    this.onTimeout(500, () => this.args.animation = 'slide');
    this.onTimeout(1250, () => this.args.animation = 'show');
    this.onTimeout(5000, () => this.args.animation = 'done');
    this.onTimeout(1250, () => _Sfx.Sfx.play('RING_COLLECTED'));
  }
}
exports.LogoSplash = LogoSplash;
});

;require.register("intro/NewgroundsCard.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NewgroundsCard = void 0;
var _SkippableCard = require("./SkippableCard");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class NewgroundsCard extends _SkippableCard.SkippableCard {
  constructor(args, parent) {
    super(args, parent);
    _defineProperty(this, "template", require('./newgrounds-card.html'));
    this.args.timeout = 2500;
    this.args.cardName = 'newgrounds-card';
    this.args.text = ``;
  }
}
exports.NewgroundsCard = NewgroundsCard;
});

;require.register("intro/NoWayCard.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NoWayCard = void 0;
var _Card = require("./Card");
var _Bgm = require("../audio/Bgm");
var _CharacterString = require("../ui/CharacterString");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class NoWayCard extends _Card.Card {
  constructor(args, parent) {
    super(args, parent);
    _defineProperty(this, "template", require('./no-way.html'));
    this.args.cardName = 'no-way-card';
    this.args.text = new _CharacterString.CharacterString({
      value: 'Error: ' + this.args.errorString
    });
    this.args.backdrop = '...';
  }
  onAttached() {
    _Bgm.Bgm.play('NO_WAY', {
      loop: true
    });
  }
}
exports.NoWayCard = NoWayCard;
});

;require.register("intro/SaneCard.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SaneCard = void 0;
var _SkippableCard = require("./SkippableCard");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class SaneCard extends _SkippableCard.SkippableCard {
  constructor(args, parent) {
    super(args, parent);
    _defineProperty(this, "template", require('./sane-card.html'));
    this.args.cardName = 'sane-card';
    this.args.text = ``;
  }
}
exports.SaneCard = SaneCard;
});

;require.register("intro/SeanCard.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SeanCard = void 0;
var _Card = require("./Card");
var _LogoSplash = require("./LogoSplash");
class SeanCard extends _Card.Card {
  constructor(args, parent) {
    super(args, parent);
    this.args.cardName = 'sean-card';
    this.args.text = new _LogoSplash.LogoSplash({}, parent);
  }
}
exports.SeanCard = SeanCard;
});

;require.register("intro/Series.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Series = void 0;
var _View = require("curvature/base/View");
var _Card = require("./Card");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class Series extends _View.View {
  constructor() {
    let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let parent = arguments.length > 1 ? arguments[1] : undefined;
    super(args, parent);
    _defineProperty(this, "template", `<div class = "intro-cards" cv-each = "cards:card:c">[[card]]</div>`);
    this.cards = this.args.cards;
    this.args.cards = [];
    this.args.card = null;
    this.startTime = false;
  }
  play() {
    if (!this.cards.length) {
      return;
    }
    const card = this.cards.shift();
    const early = new Promise(accept => card.onRemove(accept));
    const play = card.play();
    this.args.cards.push(card);
    this.startTime = Date.now();
    const racers = [early, card.done];
    if (play) {
      racers.push(play);
    }
    return Promise.race(racers).then(done => {
      if (done) {
        this.parent.onFrameOut(10, () => card.remove());
      }
      if (this.cards.length) {
        return this.play();
      } else {
        return play;
      }
    });
  }
  input(controller) {
    const card = this.args.cards[this.args.cards.length - 1];
    if (card && card.input) {
      card.input(controller);
    }
  }
}
exports.Series = Series;
});

;require.register("intro/SkippableCard.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SkippableCard = void 0;
var _Card = require("./Card");
class SkippableCard extends _Card.Card {
  // template = require('./debian-card.html');

  constructor(args, parent) {
    super(args, parent);
    this.args.cardName = 'skippable-card';
    this.args.text = ``;
  }
  input(controller) {
    if (!this.started || Date.now() + -this.started < 500) {
      return;
    }
    if (controller.buttons[9] && controller.buttons[9].time === 1 || controller.buttons[0] && controller.buttons[0].time === 1) {
      this.onTimeout(200, () => this.startPressed = true);
      this.args.animation = 'closing';
    }
  }
  play() {
    this.started = Date.now();
    return Promise.race([super.play(), new Promise(accept => this.onFrame(() => {
      if (this.startPressed) {
        accept();
      }
    }))]);
  }
}
exports.SkippableCard = SkippableCard;
});

;require.register("intro/ThankYouCard.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ThankYouCard = void 0;
var _Card = require("./Card");
var _CharacterString = require("../ui/CharacterString");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class ThankYouCard extends _Card.Card {
  constructor(args, parent) {
    super(args, parent);
    _defineProperty(this, "template", require('./thank-you.html'));
    this.args.cardName = 'thank-you-card';
    this.args.text = new _CharacterString.CharacterString({
      value: 'Thank you for playing!'
    });
    this.args.backdrop = '...';
  }
}
exports.ThankYouCard = ThankYouCard;
});

;require.register("intro/TitleScreenCard.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TitleScreenCard = void 0;
var _Card = require("./Card");
var _CharacterString = require("../ui/CharacterString");
var _Bgm = require("../audio/Bgm");
var _MarbleGarden = require("../backdrop/MarbleGarden");
var _Keyboard = require("curvature/input/Keyboard");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class TitleScreenCard extends _Card.Card {
  constructor(args, parent) {
    super(args, parent);
    _defineProperty(this, "template", require('./titlescreen.html'));
    this.args.cardName = 'title-screen-card';
    this.args.text = '';
    this.args.backdrop = '...';
    this.startPressed = false;
    const backdrop = new _MarbleGarden.MarbleGarden();
    backdrop.args.frame = 0;
    backdrop.args.x = 0;
    backdrop.args.y = 140;
    backdrop.args.xMax = 10000;
    backdrop.args.yMax = 800;
    this.started = 0;
    _Keyboard.Keyboard.get().reset();
    const keyBinding = _Keyboard.Keyboard.get().codes.bindTo('Enter', v => {
      if (!this.started || Date.now() - this.started < 2000) {
        return;
      }
      if (v <= 0 || v === undefined) {
        return;
      }
      this.onTimeout(200, () => this.startPressed = true);
      this.args.animation = 'closing';
    });
    this.onRemove(keyBinding);
    backdrop.args.xPan = 0;
    this.start = new Promise(accept => this.onFrame(() => {
      if (!this.started || Date.now() - this.started < 0) {
        return;
      }

      // backdrop.args.x -= 24;
      backdrop.args.xPan -= 24;
      backdrop.args.frame++;
      if (this.startPressed) {
        const done = new Promise(acceptDone => this.onTimeout(200, acceptDone));
        accept([done]);
      }
    }));
    this.args.backdrop = backdrop;
    this.args.pressStart = new _CharacterString.CharacterString({
      value: 'press start/enter'
    });
  }
  input(controller) {
    if (!this.started || Date.now() - this.started < 2000) {
      controller.zero();
      return;
    }
    const startButton = 9;
    if (controller.buttons[startButton] && controller.buttons[startButton].time === 1) {
      this.onTimeout(200, () => this.startPressed = true);
      this.args.animation = 'closing';
    }
  }
  play() {
    this.onTimeout(1000, () => {
      this.onRemove(() => _Bgm.Bgm.stop('TITLE_THEME'));
      _Bgm.Bgm.play('TITLE_THEME');
    });
    this.onTimeout(2000, () => this.args.aurora = 'aurora');
    this.started = Date.now();
    const play = super.play();
    return Promise.race([this.start, play]);
  }
}
exports.TitleScreenCard = TitleScreenCard;
});

;require.register("intro/WarningCard.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WarningCard = void 0;
var _SkippableCard = require("./SkippableCard");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class WarningCard extends _SkippableCard.SkippableCard {
  constructor(args, parent) {
    super(args, parent);
    _defineProperty(this, "template", require('./warning-card.html'));
    this.args.cardName = 'warning-card';
    this.args.text = ``;
  }
}
exports.WarningCard = WarningCard;
});

;require.register("intro/WebkitCard.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WebkitCard = void 0;
var _SkippableCard = require("./SkippableCard");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class WebkitCard extends _SkippableCard.SkippableCard {
  constructor(args, parent) {
    super(args, parent);
    _defineProperty(this, "template", require('./webkit-card.html'));
    this.args.cardName = 'webkit-card';
    this.args.text = ``;
  }
  play(event) {
    this.onTimeout(1500, () => this.args.animation = 'spindash-charge');
    this.onTimeout(3000, () => this.args.animation = 'spindash');
    return super.play(event);
  }
}
exports.WebkitCard = WebkitCard;
});

;require.register("intro/card.html", function(exports, require, module) {
module.exports = "<div class = \"screen-card screen-card-[[cardName]] [[animation]]\">\n\t<span>[[text]]</span>\n</div>\n"
});

;require.register("intro/debian-card.html", function(exports, require, module) {
module.exports = "<div class = \"screen-card screen-card-[[cardName]] [[animation]] [[aurora]]\">\n\t<div class = \"main-elements-container\">\n\t\t<div class = \"debian-logo\"></div>\n\t\t<div class = \"caption\">Built on Debian</div>\n\t</div>\n</div>\n"
});

;require.register("intro/gamepad-card.html", function(exports, require, module) {
module.exports = "<div class = \"screen-card screen-card-[[cardName]] [[animation]] [[aurora]]\">\n\t<div class = \"main-elements-container\">\n\t\t<div class = \"gamepad-svg\"></div>\n\t\t<div class = \"caption\">Supports HTML5 Gamepad API.</div>\n\t\t<div class = \"button-callout\">Toggle audio and fullscreen<div class = \"arrow\"></div></div>\n\t</div>\n</div>\n\n"
});

;require.register("intro/newgrounds-card.html", function(exports, require, module) {
module.exports = "<div class = \"screen-card screen-card-[[cardName]] [[animation]] [[aurora]]\">\n\t<div class = \"main-elements-container\">\n\t\t<div class = \"caption\">Special thanks to the artists on</div>\n\t\t<div class = \"newgrounds-svg\"></div>\n\t</div>\n</div>\n\n"
});

;require.register("intro/no-way.html", function(exports, require, module) {
module.exports = "<div class = \"screen-card screen-card-[[cardName]] [[animation]] [[aurora]]\">\n\t<div class = \"player-waving\"></div>\n\t<div class = \"no-way\"></div>\n\t<div class = \"main-elements-container\">\n\t\t[[text]]\n\t</div>\n</div>\n"
});

;require.register("intro/sane-card.html", function(exports, require, module) {
module.exports = "<div class = \"screen-card screen-card-[[cardName]] [[animation]] [[aurora]]\">\n\t<div class = \"main-elements-container\">\n\t\t<div><img src = \"/icons/chaosean.svg\" /></div>\n\t\t<div><img src = \"/icons/sane-engine.svg\" /></div>\n\t</div>\n</div>\n\n"
});

;require.register("intro/thank-you.html", function(exports, require, module) {
module.exports = "<div class = \"screen-card screen-card-[[cardName]] [[animation]] [[aurora]]\">\n\t<div class = \"player-waving\"></div>\n\t<div class = \"main-elements-container\">\n\t\t<div class = \"title-emblem\"></div>\n\t\t[[text]]\n\t</div>\n</div>\n"
});

;require.register("intro/titlescreen.html", function(exports, require, module) {
module.exports = "<div class = \"screen-card screen-card-[[cardName]] [[animation]] [[aurora]]\">\n\t[[backdrop]]\n\n\t<div class = \"main-elements-container\">\n\n\t\t<div class = \"title-emblem\"></div>\n\t\t<div class = \"press-start\">[[pressStart]]</div>\n\n\t</div>\n\n</div>\n"
});

;require.register("intro/warning-card.html", function(exports, require, module) {
module.exports = "<div class = \"screen-card screen-card-[[cardName]] [[animation]] [[aurora]]\">\n\t<div class = \"main-elements-container\">\n\t\t<div class = \"warning-svg\"></div>\n\t</div>\n</div>\n\n"
});

;require.register("intro/webkit-card.html", function(exports, require, module) {
module.exports = "<div class = \"screen-card screen-card-[[cardName]] [[animation]] [[aurora]]\">\n\t<div class = \"main-elements-container\">\n\t\t<div class = \"chromium-logo\"></div>\n\t\t<div class = \"caption\">WebKit recommended for best experience.</div>\n\t</div>\n</div>\n"
});

;require.register("legacy/Actor.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Actor = void 0;
var _View = require("curvature/base/View");
var _PointDump = require("../debug/PointDump");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class Actor extends _View.View {
  constructor() {
    super(...arguments);
    _defineProperty(this, "speed", 15);
    _defineProperty(this, "template", require('./actor.html'));
    this.world = null;
    this.x = 92;
    this.y = 1024;
    this.width = 64;
    this.height = 64;
    this.boxWidth = 64;
    this.boxHeight = 64;
    this.directions = 16;
    this.state = 'standing';
    this.gSpeed = 0;
    // this.gSpeedMax = 48;
    this.gSpeedMax = 40;
    this.xSpeed = 0;
    this.ySpeed = 0;
    this.angle = 0;
    this.maxGravity = 48;
    this.gravity = 0;
    this.slopeFactor = 0.01;
    this.falling = true;
    this.sensors = {
      top: false,
      bottom: false,
      left: false,
      right: false
    };
    this.mode = this.args.mode = 0;
    this.modes = {
      floor: 0,
      leftWall: 1,
      ceiling: 2,
      rightWall: 3
    };
    this.animationClasses = {};
    this.currentClasses = null;
    this.pdL = new _PointDump.PointDump({
      color: 'red'
    });
    this.pdR = new _PointDump.PointDump({
      color: 'green'
    });
    this.args.debugs = [this.pdL, this.pdR];
  }
  destroy() {}
  update() {
    if (!this.tags.actor) {
      return;
    }
    let g = this.gSpeed;
    this.args.animspeed = Math.floor((this.gSpeedMax - Math.abs(g)) / 12);
    if (this.args.animspeed < 1) {
      this.args.animspeed = 1;
    }
    const angle = Math.round(this.angle * 1000) / 1000;
    if (!this.falling) {
      if (angle > Math.PI / 4 && angle < 2 * Math.PI / 4) {
        if (this.mode === this.modes.floor) {
          this.args.mode = this.mode = this.modes.leftWall;
        } else if (this.mode === this.modes.leftWall) {
          this.args.mode = this.mode = this.modes.ceiling;
        } else if (this.mode === this.modes.ceiling) {
          this.args.mode = this.mode = this.modes.rightWall;
        } else if (this.mode === this.modes.rightWall) {
          this.args.mode = this.mode = this.modes.floor;
        }
      }
      if (angle < -Math.PI / 4 && angle > -2 * Math.PI / 4) {
        if (this.mode === this.modes.floor) {
          this.args.mode = this.mode = this.modes.rightWall;
        } else if (this.mode === this.modes.rightWall) {
          this.args.mode = this.mode = this.modes.ceiling;
        } else if (this.mode === this.modes.ceiling) {
          this.args.mode = this.mode = this.modes.leftWall;
        } else if (this.mode === this.modes.leftWall) {
          this.args.mode = this.mode = this.modes.floor;
        }
      }
      if (Math.abs(g) > this.gSpeedMax / 2) {
        this.args.state = 'running';
      } else if (Math.abs(g) > 0) {
        this.args.state = 'walking';
      } else {
        this.args.state = 'standing';
      }
      if (g > 0) {
        this.args.facing = 'facing-right';
      } else {
        this.args.facing = 'facing-left';
      }
    } else if (this.falling || this.jumped) {
      this.args.state = 'jumping';
    }
    if (this.falling) {
      if (this.mode == this.modes.floor) {
        this.ySpeed++;
      } else if (this.mode == this.modes.ceiling) {
        this.ySpeed--;
      } else if (this.mode == this.modes.leftWall) {
        this.xSpeed--;
      } else if (this.mode == this.modes.rightWall) {
        this.xSpeed++;
      }
    } else if (!this.jumped) {
      this.xSpeed = 0;
      this.ySpeed = 0;
    }
    this.x += this.xSpeed;
    this.ySpeed && (this.y += this.ySpeed > 0 ? 1 : -1);
    if (g) {
      const max = 8;
      const abG = Math.abs(g);
      const div = abG > max ? max : abG;
      for (let i = 0; i < div; i++) {
        this.iteratePosition(Math.floor(g / div));
      }
    } else {
      this.iteratePosition(0);
    }
    if (this.ySpeed > 32) {
      this.ySpeed = 32;
    }
    if (this.ySpeed < -32) {
      this.ySpeed = -32;
    }
    if (this.xSpeed > 32) {
      this.xSpeed = 32;
    }
    if (this.xSpeed < -32) {
      this.xSpeed = -32;
    }
    this.tags.actor.style({
      '--x': Math.floor(this.x),
      '--y': Math.floor(this.y)
    });
    if (this.mode === this.modes.floor) {
      this.tags.actor.style({
        '--angle': this.angle
      });
    } else if (this.mode === this.modes.leftWall) {
      this.tags.actor.style({
        '--angle': this.angle + 1 * (Math.PI / 2)
      });
    } else if (this.mode === this.modes.ceiling) {
      this.tags.actor.style({
        '--angle': this.angle + 2 * (Math.PI / 2)
      });
    } else if (this.mode === this.modes.rightWall) {
      this.tags.actor.style({
        '--angle': this.angle + 3 * (Math.PI / 2)
      });
    }
    if (this.jumped) {
      this.jumped = false;
    }
  }
  iteratePosition(speed) {
    let sin = Math.sin(this.angle);
    let cos = Math.cos(this.angle);
    const center = this.center;
    const top = this.top;
    const bottom = this.bottom;
    const left = this.left;
    const right = this.right;
    let arm, leg, sensorLeft, sensorRight, sensorSpread;
    if (this.mode == this.modes.floor || this.mode == this.modes.ceiling) {
      arm = right - center[0];
      leg = bottom - center[1];
    } else if (this.mode == this.modes.leftWall || this.mode == this.modes.rightWall) {
      arm = right - center[1];
      leg = bottom - center[0];
    }
    sensorLeft = this.left - arm * sin + arm * 0.5;
    sensorRight = this.right - arm * sin - arm * 0.5;
    sensorSpread = Math.abs(sensorRight - sensorLeft);
    const map = this.viewport.tileMap;
    let leftScan = 0;
    let rightScan = 0;
    let scanLX, scanLY, scanRX, scanRY;
    let leftSolid = false,
      rightSolid = false;
    const height = this.falling ? this.height : this.height;
    const scans = [[-height, 0], [-height, height]];
    regress: for (let i in scans) {
      leftScan = scans[i][0];
      while (leftScan < scans[i][1]) {
        if (this.mode == this.modes.floor) {
          scanLX = sensorLeft;
          scanLY = bottom + leftScan;
        } else if (this.mode == this.modes.ceiling) {
          scanLX = sensorLeft;
          scanLY = bottom - leftScan;
        } else if (this.mode == this.modes.leftWall) {
          scanLX = bottom - leftScan;
          scanLY = sensorLeft;
        } else if (this.mode == this.modes.rightWall) {
          scanLX = bottom + leftScan;
          scanLY = sensorLeft;
        }
        leftSolid = map.getSolid(scanLX, scanLY);
        if (leftSolid) {
          if (leftScan !== 0) {
            break regress;
          }
          break;
        }
        leftScan++;
      }
    }
    regress: for (let i in scans) {
      rightScan = scans[i][0];
      while (rightScan < scans[i][1]) {
        if (this.mode == this.modes.floor) {
          scanRX = sensorRight;
          scanRY = bottom + rightScan;
        } else if (this.mode == this.modes.ceiling) {
          scanRX = sensorRight;
          scanRY = bottom - rightScan;
        } else if (this.mode == this.modes.leftWall) {
          scanRX = bottom - rightScan;
          scanRY = sensorRight;
        } else if (this.mode == this.modes.rightWall) {
          scanRX = bottom + rightScan;
          scanRY = sensorRight;
        }
        rightSolid = map.getSolid(scanRX, scanRY);
        if (rightSolid) {
          break;
        }
        rightScan++;
      }
    }
    this.pdL.args.x = scanLX;
    this.pdL.args.y = scanLY;
    this.pdR.args.x = scanRX;
    this.pdR.args.y = scanRY;
    this.angle = Math.atan((rightScan - leftScan) / sensorSpread);
    if (!this.falling) {
      let offset = (leftScan + rightScan) / 2;
      if (this.mode === this.modes.floor) {
        this.x += speed * cos;
        this.y += speed * sin;
      } else if (this.mode === this.modes.rightWall) {
        this.x += speed * sin;
        this.y -= speed * cos;
      } else if (this.mode === this.modes.ceiling) {
        this.x -= speed * cos;
        this.y -= speed * sin;
      } else if (this.mode === this.modes.leftWall) {
        this.x -= speed * sin;
        this.y += speed * cos;
      }
      if (leftSolid && rightSolid && leftScan <= 0 && rightScan <= 0) {
        if (this.mode == this.modes.floor) {
          this.y += Math.ceil(offset);
        } else if (this.mode == this.modes.ceiling) {
          this.y -= Math.ceil(offset);
        } else if (this.mode == this.modes.leftWall) {
          this.x -= offset;
        } else if (this.mode == this.modes.rightWall) {
          this.x += offset;
        }
      }
    }
    if (leftScan > 0 && rightScan > 0) {
      this.falling = true;
    } else {
      this.falling = false;
    }
  }
  isColliding(actor) {}
  animate(aniation) {}
  animate() {
    if (!this.animationClasses[animation]) {
      return;
    }
    if (this.currentClasses == this.animationClasses[animation]) {
      return;
    }
    this.currentClasses.map(function (remClass) {
      this.tags.sprite.removeClass(remClass);
    });
    this.animationClasses[animation].map(function (newClass) {
      this.tags.sprite.addClass(newClass);
    });
    this.currentClasses = this.animationClasses[animation];
  }
  roundAngle(angle, segments) {
    angle = Math.round(angle * (180 / Math.PI));
    var rAngle = `Math.round`(angle / (360 / segments)) * 360 / segments;
    return rAngle * (Math.PI / 180);
  }
  goLeft() {
    if (this.gSpeed > 0) {
      this.gSpeed = 0;
    }
    if (this.gSpeed > -this.gSpeedMax) {
      this.gSpeed--;
    }
  }
  goRight() {
    if (this.gSpeed < 0) {
      this.gSpeed = 0;
    }
    if (this.gSpeed < this.gSpeedMax) {
      this.gSpeed++;
    }
  }
  slowDown() {
    if (Math.abs(this.gSpeed) > 32) {
      this.gSpeed = this.gSpeed * 0.95;
    } else {
      this.gSpeed = this.gSpeed * 0.75;
    }
    if (Math.abs(this.gSpeed) <= 0.1) {
      this.gSpeed = 0;
    }
  }
  jump() {
    if (this.falling) {
      return;
    }
    this.falling = true;
    this.jumped = true;
    this.mode = this.args.mode = this.modes.floor;
    let angle;
    if (this.mode === this.modes.floor) {
      angle = this.angle;
    } else if (this.mode === this.modes.leftWall) {
      angle = this.angle + 1 * (Math.PI / 2);
    } else if (this.mode === this.modes.ceiling) {
      angle = this.angle + 2 * (Math.PI / 2);
    } else if (this.mode === this.modes.rightWall) {
      angle = this.angle + 3 * (Math.PI / 2);
    }
    this.angle = 0;
    this.ySpeed = -Math.cos(angle) * 20;
    this.xSpeed = Math.sin(angle) * 20;
    if (this.mode === this.modes.leftWall || this.mode === this.modes.rightWall) {
      this.gSpeed = 0;
    }
  }
  get center() {
    return [this.x + this.boxWidth / 2, this.y + this.boxHeight / 2];
  }
  get left() {
    if (this.mode == this.modes.floor) {
      return this.center[0] - this.width / 2;
    } else if (this.mode == this.modes.ceiling) {
      return this.center[0] + this.width / 2;
    } else if (this.mode == this.modes.leftWall) {
      return this.center[1] - this.width / 2;
    } else if (this.mode == this.modes.rightWall) {
      return this.center[1] + this.width / 2;
    }
  }
  get right() {
    if (this.mode == this.modes.floor) {
      return this.center[0] + this.width / 2;
    } else if (this.mode == this.modes.ceiling) {
      return this.center[0] - this.width / 2;
    } else if (this.mode == this.modes.leftWall) {
      return this.center[1] + this.width / 2;
    } else if (this.mode == this.modes.rightWall) {
      return this.center[1] - this.width / 2;
    }
  }
  get top() {
    if (this.mode == this.modes.floor) {
      return this.center[1] - Math.floor(this.height / 2);
    } else if (this.mode == this.modes.ceiling) {
      return this.center[1] + Math.floor(this.height / 2);
    } else if (this.mode == this.modes.leftWall) {
      return this.center[0] + Math.floor(this.height / 2);
    } else if (this.mode == this.modes.rightWall) {
      return this.center[0] - Math.floor(this.height / 2);
    }
  }
  get bottom() {
    if (this.mode == this.modes.floor) {
      return this.center[1] + Math.floor(this.height / 2);
    } else if (this.mode == this.modes.ceiling) {
      return this.center[1] - Math.floor(this.height / 2);
    } else if (this.mode == this.modes.leftWall) {
      return this.center[0] - Math.floor(this.height / 2);
    } else if (this.mode == this.modes.rightWall) {
      return this.center[0] + Math.floor(this.height / 2);
    }
  }
}
exports.Actor = Actor;
});

;require.register("legacy/Walker.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Walker = void 0;
var _Actor = require("./Actor");
class Walker extends _Actor.Actor {}
exports.Walker = Walker;
});

;require.register("legacy/actor.html", function(exports, require, module) {
module.exports = "<div class = \"actor knuckles [[state]] [[facing]]\" cv-ref = \"actor\" data-mode = \"[[mode]]\" style = \"--animspeed:[[animspeed]]\">\n\t<div class = \"sprite\" cv-ref = \"sprite\" ></div>\n</div>\n<div cv-each = \"debugs:debug\">[[debug]]</div>\n"
});

;require.register("lib/Analytic.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Analytic = void 0;
class Analytic {
  static report() {
    let event = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    if (!typeof ga === 'function') {
      return;
    }
    requestIdleCallback(() => ga('send', 'event', event));
  }
}
exports.Analytic = Analytic;
});

;require.register("lib/Color.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Color = void 0;
class Color extends Uint8Array {
  get r() {
    return this[0];
  }
  get g() {
    return this[1];
  }
  get b() {
    return this[2];
  }
  get rf() {
    return this[0] / 0xFF;
  }
  get gf() {
    return this[1] / 0xFF;
  }
  get bf() {
    return this[2] / 0xFF;
  }
  constructor(value) {
    super(3);
    if (typeof value === 'string') {
      if (value[0] === '#') {
        value = value.substr(1);
      }
      if (value[0] !== '0' && (value[1] !== 'x' || value[1] !== 'X')) {
        value = '0x' + value;
      }
      value = parseInt(value);
    }
    if (typeof value === 'number') {
      if (value > 0xFFFFFF) {
        value = value % 0xFFFFFF;
      }
      this[0] = value >> 16 & 0xFF;
      this[1] = value >> 8 & 0xFF;
      this[2] = value >> 0 & 0xFF;
    } else if (Array.isArray(value) && value.length <= 3) {
      this[0] = value[0];
      this[1] = value[1];
      this[2] = value[2];
    }
  }
  rotate(h, s, v) {
    const normalized = [this.rf, this.gf, this.bf];
    const cMax = Math.max(...normalized);
    const cMin = Math.min(...normalized);
    const delta = cMax - cMin;
    let hInit = 0;
    if (delta && cMax === this.rf) {
      hInit = 60 * ((normalized[1] - normalized[2]) / delta % 6);
    } else if (delta && cMax === this.gf) {
      hInit = 60 * ((normalized[2] - normalized[0]) / delta + 2);
    } else if (delta && cMax === this.bf) {
      hInit = 60 * ((normalized[0] - normalized[1]) / delta + 4);
    }
    const sInit = delta === 0 ? 0 : delta / cMax;
    const vInit = cMax;
    let hOut = (hInit + h) % 360;
    const sOut = Math.max(0, Math.min(sInit * s, 1));
    const vOut = Math.max(0, Math.min(vInit * v, 1));
    if (hOut < 0) {
      hOut += 360;
    }
    const c = vOut * sOut;
    const x = c * (1 - Math.abs(hOut / 60 % 2 - 1));
    const m = vOut - c;
    let ri, gi, bi;
    if (0 <= hOut && hOut < 60) {
      ri = c + m;
      gi = x + m;
      bi = 0 + m;
    } else if (60 <= hOut && hOut < 120) {
      ri = x + m;
      gi = c + m;
      bi = 0 + m;
    } else if (120 <= hOut && hOut < 180) {
      ri = 0 + m;
      gi = c + m;
      bi = x + m;
    } else if (180 <= hOut && hOut < 240) {
      ri = 0 + m;
      gi = x + m;
      bi = c + m;
    } else if (240 <= hOut && hOut < 300) {
      ri = x + m;
      gi = 0 + m;
      bi = c + m;
    } else if (300 <= hOut && hOut < 360) {
      ri = c + m;
      gi = 0 + m;
      bi = x + m;
    }
    const rotated = new this.constructor([ri * 0xFF, gi * 0xFF, bi * 0xFF].map(Math.round));
    return rotated;
  }
  toString() {
    return String(Math.round(this[0]).toString(16).padStart(2, '0') + Math.round(this[1]).toString(16).padStart(2, '0') + Math.round(this[2]).toString(16).padStart(2, '0'));
  }
  toPrimitive() {
    return (this[0] << 16) + (this[1] << 8);
    +(this[2] << 0);
  }
}
exports.Color = Color;
});

;require.register("mixin/CanPop.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CanPop = void 0;
var _Tag = require("curvature/base/Tag");
var _Explosion = require("../actor/Explosion");
var _Projectile = require("../actor/Projectile");
var _Sfx = require("../audio/Sfx");
var _Analytic = require("../lib/Analytic");
var _Vehicle = require("../actor/Vehicle");
class CanPop {
  collideA(other, type) {
    if (this.knocked && other.pop) {
      this.pop(this.knocked);
    }
    const viewport = this.viewport;
    if (this.args.invincible) {
      other.damage(this);
      return;
    }
    if (other.knocked) {
      other.pop && other.pop(other.knocked);
      this.pop(other.knocked);
      return;
    }
    if (other.punching && !this.knocked) {
      // this.viewport.args.frozen = 1;

      this.args.falling = true;
      if (Math.abs(other.args.gSpeed || other.gSpeedLast) < 5) {
        this.pop(other);
        return;
      }
      if (other.args.falling && other.args.ySpeed < 0) {
        // this.args.xSpeed = other.args.xSpeed + 10 * Math.sign(other.args.xSpeed);
        this.args.ySpeed = -10 + other.args.ySpeed;
        this.args.y -= 18;
      } else {
        this.args.xSpeed = 1.2 * (other.args.gSpeed || other.gSpeedLast);
        this.args.ySpeed = -5;
        this.args.y -= 18;
      }
      this.args.x = other.args.x + 24 * other.args.direction + other.args.gSpeed;

      // this.args.float = 15;
      this.knocked = other;
      // this.noClip = true;
      this.static = false;
      this.viewport.onFrameOut(60, () => this.pop(other));
      return false;
    }
    const shield = this.args.currentSheild;
    const immune = other.immune(this, shield ? shield.type : 'normal');
    if ((!shield || immune) && !this.args.gone && this.viewport && (immune || other.dashed || other.args.jumping || other.args.bellySliding || other.args.spinning || other.args.standinOn && other.args.standinOn instanceof _Vehicle.Vehicle || other instanceof _Projectile.Projectile && other.args.owner && other.args.owner.controllable)) {
      const otherShield = other.args.currentSheild;
      this.damage(other, otherShield ? otherShield.type : other.args.damageType || 'normal');
      return;
    }
    if (!this.knocked && other && other.controllable && !other.punching) {
      if (viewport && typeof ga === 'function') {
        _Analytic.Analytic.report({
          eventCategory: 'badnik',
          eventAction: 'damaged-player',
          eventLabel: `${viewport.args.actName}::${this.args.name}::${this.args.id}::${other.args.id}`
        });
      }
      if (!other.args.mercy) {
        other.damage(this, shield ? shield.type : 'normal');
        this.ignores.set(other, 10);
      }
    }
    return false;
  }
  damage(other, type) {
    if (this.args.invincible) {
      return;
    }
    if (!other) {
      this.pop();
      return;
    }
    const shield = this.args.currentSheild;
    const immune = other.immune(this, shield ? shield.type : 'normal');
    if ((!shield || immune) && !this.args.gone && this.viewport && (immune || other.dashed || other.args.jumping || other.args.bellySliding || other.args.spinning || other instanceof _Projectile.Projectile)) {
      this.pop(other);
    }
  }
  pop(other) {
    const viewport = this.viewport;
    if (!viewport || this.args.gone || this.args.invincible || other && other.args.owner === this) {
      return;
    }
    this.args.gone = true;
    const explosionTag = document.createElement('div');
    explosionTag.classList.add('particle-explosion');
    const explosion = new _Tag.Tag(explosionTag);
    explosion.style({
      '--x': this.args.x,
      '--y': this.args.y - 16
    });
    viewport.particles.add(explosion);
    viewport.onFrameOut(30, () => viewport.particles.remove(explosion));
    viewport.onFrameOut(90, () => this.screen && this.screen.remove());
    this.box && this.box.setAttribute('data-animation', 'broken');
    if (other && other.dashed) {
      if (Math.abs(other.args.xSpeed) > Math.abs(other.args.ySpeed)) {
        other.args.gSpeed = 0;
        other.args.xSpeed = -1.5 * Math.sign(other.args.xSpeed);
        other.args.ySpeed = -10;
      }
      other.dashed = false;
    }
    if (other) {
      if (other.args.doubleSpin) {
        other.args.doubleSpin = 2;
      }
      if (other.occupant) {
        other = other.occupant;
      }
      if (other.args.owner) {
        other = other.args.owner;
      }
      if (other.controllable && typeof this.effect === 'function') {
        let points = 100;
        if (this.args.gold) {
          points = 10000;
        }
        const reward = {
          label: this.name || this.args.name,
          points,
          multiplier: 1
        };
        if (this.args.gold) {
          reward.label = 'Gold ' + reward.label;
          reward.color = 'orange';
          reward.special = true;
        }
        if (!other.isVehicle && other.args.ySpeed > 5 && other.args.ySpeed < 25 && Math.abs(other.args.ySpeed) > Math.abs(other.args.xSpeed)) {
          other.args.cameraMode = 'popping';
        }
        other.args.popCombo += 1;
        other.args.popChain.push(reward);
        if (other.args.ySpeed > 25 && !other.args.bouncing) {
          const reward = {
            label: 'BIG AIR!!!',
            points: 1000,
            multiplier: 2
          };
          other.args.popChain.push(reward);
          other.args.popCombo += 1;
          if (!other.airReward && Math.abs(other.args.xSpeed) > 10) {
            other.args.x = this.args.x;
            other.args.y = this.args.y + -8;
            viewport.onFrameOut(1, () => viewport.args.frozen = 25);
            viewport.args.invert = 'invert';
            viewport.onFrameOut(25, () => viewport.args.invert = '');
            _Sfx.Sfx.play('SICK_TRICK');
            _Sfx.Sfx.play('SICK_TRICK');
          }
          other.airReward = reward;
        }
        const scoreNode = document.createElement('div');
        scoreNode.classList.add('particle-score');
        const scoreTag = new _Tag.Tag(scoreNode);
        scoreTag.style({
          '--x': this.args.x,
          '--y': this.args.y - 16
        });
        switch (true) {
          case this.args.gold:
            // scoreNode.classList.add('score-10000');
            points = 10000;
            break;
          case other.args.popCombo === 1:
            // scoreNode.classList.add('score-100');
            points = 100;
            break;
          case other.args.popCombo === 2:
            // scoreNode.classList.add('score-200');
            points = 200;
            break;
          case other.args.popCombo === 3:
            // scoreNode.classList.add('score-300');
            points = 300;
            break;
          case other.args.popCombo === 4:
            // scoreNode.classList.add('score-400');
            points = 400;
            break;
          case other.args.popCombo === 5:
            // scoreNode.classList.add('score-500');
            points = 500;
            break;
          case other.args.popCombo === 6:
            // scoreNode.classList.add('score-600');
            points = 600;
            break;
          case other.args.popCombo === 7:
            // scoreNode.classList.add('score-700');
            points = 700;
            break;
          case other.args.popCombo === 8:
            // scoreNode.classList.add('score-800');
            points = 800;
            break;
          case other.args.popCombo === 9:
            // scoreNode.classList.add('score-900');
            points = 900;
            break;
          case other.args.popCombo >= 10:
            // scoreNode.classList.add('score-1000');
            points = 1000;
            break;
        }

        // viewport.particles.add(scoreTag);

        // viewport.onFrameOut(80, () => viewport.particles.remove(scoreTag));

        // other.args.score += points;

        this.effect(other);
      }
      const ySpeed = Math.min(other.args.ySpeed, other.ySpeedLast);
      if (other.args.falling && !other.punching) {
        const spinning = other.args.spinning;
        const jumping = other.args.jumping;
        const flying = other.args.flying;
        const xSpeed = other.args.xSpeed || other.args.gSpeed;
        viewport.onFrameOut(1, () => {
          if (ySpeed >= 0) {
            if (other.flyTime < 5) {
              other.args.ySpeed = Math.min(-ySpeed, -7);
            } else {
              other.args.ySpeed = Math.min(-ySpeed, -2);
            }
          } else {
            other.args.ySpeed += 8;
          }
          other.args.spinning = other.args.spinning || spinning;
          other.args.jumping = other.args.jumping || jumping;
          other.args.flying = other.args.flying || flying;
          other.args.xSpeed = xSpeed;
          other.args.falling = true;
        });
      }
      other.dashed = false;
      if (this.viewport.settings.rumble) {
        if (other && other.controller && other.controller.rumble) {
          other.controller.rumble({
            duration: 40,
            strongMagnitude: 0.0,
            weakMagnitude: 1.0
          });
          this.viewport.onTimeout(40, () => {
            other.controller.rumble({
              duration: 110,
              strongMagnitude: 0.75,
              weakMagnitude: 1.0
            });
          });
        }
      }
    }
    if (this.args.target && this.viewport.actorsById[this.args.target]) {
      const target = this.viewport.actorsById[this.args.target];
      if (target) {
        this.viewport.auras.add(target);
        target.activate(other, this);
      }
    }
    _Sfx.Sfx.play('OBJECT_DESTROYED');
    if (typeof ga === 'function') {
      _Analytic.Analytic.report({
        eventCategory: 'badnik',
        eventAction: 'defeated',
        eventLabel: `${viewport.args.actName}::${this.args.name}::${this.args.id}`
      });
    }
    this.viewport.actors.remove(this);
  }
}
exports.CanPop = CanPop;
});

;require.register("mixin/Constrainable.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Constrainable = void 0;
var _Tag = require("curvature/base/Tag");
const Constrainable = {
  initialize: function () {
    if (!this.others.tiedTo) {
      return;
    }
    const _tiedTo = this.others.tiedTo;
    if (_tiedTo && !_tiedTo.hanging.has(this.constructor)) {
      _tiedTo.hanging.set(this.constructor, new Set());
      const hangList = _tiedTo.hanging.get(this.constructor);
      hangList.add(this);
      this.chain = new _Tag.Tag('<div class = "chain">');
      this.sprite.appendChild(this.chain.node);
      this.onRemove(() => hangList.delete(this));
    }
    this.setPos();
  },
  wakeUp: function () {},
  sleep: function () {
    if (!this.viewport || this.args.stay) {
      return;
    }
    if (this.def) {
      this.viewport.onFrameOut(5, () => {
        this.args.x = this.def.get('x');
        this.args.y = this.def.get('y');
        this.args.xSpeed = 0;
        this.args.ySpeed = 0;
        this.viewport.setColCell(this);
      });
    }
  }

  // , findNextStep: function() {
  // 	return false;
  // }
  ,

  setPos: function () {
    let blockers = null;
    blockers = this.getMapSolidAt(this.args.x, this.args.y);
    if (this.hooked && Array.isArray(blockers)) {
      blockers = blockers.filter(b => !this.hooked.has(b)).length;
    }
    if (blockers && !this.getMapSolidAt(this.args.x, this.args.y + 1)) {
      this.args.y++;
    }
    if (!this.others.tiedTo) {
      return;
    }
    const tiedTo = this.others.tiedTo;
    if (!tiedTo) {
      return false;
    }
    this.args.ropeLength = this.args.ropeLength || tiedTo.args.ropeLength;
    this.args.falling = true;
    const xTarget = tiedTo.args.x;
    const yTarget = tiedTo.args.y;
    const xDist = xTarget - this.args.x;
    const yDist = yTarget - this.args.y;
    const angle = Math.atan2(yDist, xDist);
    const dist = Math.hypot(yDist, xDist);
    this.args.distance = dist;
    const maxDist = this.args.ropeLength || 64;
    if (this.chain) {
      this.chain.style({
        '--distance': Math.min(dist, maxDist)
      });
    }
    this.args.groundAngle = -(angle + Math.PI / 2);
    const gravityAngle = angle;
    if (dist > maxDist) {
      const overshot = dist - maxDist;
      const xMove = Math.cos(angle) * maxDist;
      const yMove = Math.sin(angle) * maxDist;
      const xNext = xTarget - xMove;
      const yNext = yTarget - yMove;
      this.args.xSpeed += Math.cos(gravityAngle) * overshot;
      this.args.ySpeed += Math.sin(gravityAngle) * overshot;
      if (this.args.xSpeedMax < Math.abs(this.args.xSpeed)) {
        this.args.xSpeed = this.args.xSpeedMax * Math.sign(this.args.xSpeed);
      }
      if (this.args.ySpeedMax < Math.abs(this.args.ySpeed)) {
        this.args.ySpeed = this.args.ySpeedMax * Math.sign(this.args.ySpeed);
      }
      this.args.gSpeed = this.args.xSpeed;
      this.args.x = xNext;
      this.args.y = yNext;
      if (this.viewport) {
        this.viewport.setColCell(this);
      }
      if (this.args.x === xTarget && !tiedTo.args.xSpeed && !tiedTo.args.gSpeed) {
        this.args.ySpeed = 0;
      }
    }
    if (tiedTo.args.ySpeed > 0 && !tiedTo.args.xSpeed && !this.args.xSpeed) {
      this.args.x = xTarget;
      this.args.y = yTarget + this.args.ropeLength;
    }
  }
};
exports.Constrainable = Constrainable;
});

require.register("mixin/Pushable.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Pushable = void 0;
var _Ring = require("../actor/Ring");
const Pushable = {
  collideA: function (other, type) {
    if (other instanceof _Ring.Ring) {
      return false;
    }
    if (type === -1 || other.isEffect) {
      return false;
    }
    const otherMag = Math.ceil(Math.abs(other.args.gSpeed || other.args.xSpeed));
    const otherDir = Math.sign(other.args.gSpeed || other.args.xSpeed);
    let otherSpeed = otherMag * otherDir;
    if (Math.abs(other.args.ySpeed) > Math.abs(other.args.xSpeed)) {
      return true;
    }
    if (!this.args.falling && type === 1 && otherSpeed <= 0) {
      return false;
    }
    if (!this.args.falling && type === 3 && otherSpeed >= 0) {
      return false;
    }
    const blockTop = this.y - this.args.height;
    if ((type === 1 || type === 3) && (other.y >= this.y || other.y > blockTop)) {
      if (!otherSpeed) {
        return true;
      }
      this.args.gSpeed = otherSpeed;
      this.args.pushed = Math.sign(otherSpeed) || this.args.pushed;
      const tileMap = this.viewport.tileMap;
      const moveBy = type === 1 && 1 || type === 3 && -1;
      const scan = this.scanBottomEdge(moveBy);
      const blockers = tileMap.getSolid(this.x + Math.ceil(this.args.width / 2) * moveBy, this.y);
      if (blockers) {
        return true;
      }
      const radius = this.args.width / 2;
      if (moveBy > 0 && scan === 0) {
        this.args.falling = true;
      } else if (moveBy < 0 && scan === 0) {
        this.args.falling = true;
      } else if (!this.args.falling || scan > 0) {
        const nextCenter = this.bMap('findNextStep', moveBy).get(Platformer);
        const nextWall = this.bMap('findNextStep', moveBy + radius * Math.sign(moveBy)).get(Platformer);
        if ((!nextCenter[1] || nextCenter[2]) && !nextWall[3]) {
          // this.args.x += nextPosition[0] || moveBy;

          const otherRadius = other.args.width;
          const myRadius = this.args.width / 2;
          this.args.x = other.args.x + moveBy * (myRadius + otherRadius);
          return scan === 0;
        }
        return true;
      }
    }
    return true;
  }
};
exports.Pushable = Pushable;
});

;require.register("network/ChatBox.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ChatBox = void 0;
var _View = require("curvature/base/View");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class ChatBox extends _View.View {
  constructor(args, parent) {
    super(args, parent);
    _defineProperty(this, "template", require('./chat-box.html'));
    this.args.outputLines = [];
    const onOpen = event => this.args.outputLines = ['You joined the chat.'];
    const onMessage = event => {
      const packet = JSON.parse(event.detail);
      if (packet.message) {
        this.args.outputLines.push(_View.View.from(`> <span class = "incoming">[[message]]</span>`, {
          message: packet.message
        }));
        this.onNextFrame(() => {
          const chatOutput = this.tags.chatOutput;
          chatOutput && chatOutput.scrollTo(0, chatOutput.scrollHeight);
        });
      }
    };
    this.listen(args.pipe, 'open', onOpen);
    this.listen(args.pipe, 'message', onMessage);
  }
  send(event) {
    if (event && event.key && event.key !== 'Enter') {
      return;
    }
    const message = this.args.chatInput;
    if (!message) {
      return;
    }
    this.args.outputLines.push(`< ${message}`);
    this.args.chatInput = '';
    this.onNextFrame(() => {
      const tag = this.tags.chatOutput;
      tag.scrollTo(0, tag.scrollHeight);
      tag.focus();
    });
    this.args.pipe.send(JSON.stringify({
      message
    }));
  }
}
exports.ChatBox = ChatBox;
});

;require.register("network/CryptoMessage.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CryptoMessage = void 0;
var _Uuid = require("curvature/base/Uuid");
var _CryptoReply = require("./CryptoReply");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class CryptoMessage {
  constructor(_ref) {
    let {
      content,
      sender,
      uuid,
      re,
      foreignKey,
      publicKey
    } = _ref;
    _defineProperty(this, "content", void 0);
    _defineProperty(this, "sender", void 0);
    _defineProperty(this, "uuid", void 0);
    _defineProperty(this, "re", void 0);
    _defineProperty(this, "encryptedSymmetricKey", void 0);
    _defineProperty(this, "foreignKey", void 0);
    _defineProperty(this, "publicKey", void 0);
    this.uuid = uuid || String(new _Uuid.Uuid());
    Object.assign(this, {
      content,
      sender,
      re,
      foreignKey,
      publicKey
    });
  }
  createReply(content) {
    const getSymmetricKey = window.crypto.subtle.generateKey({
      name: "AES-GCM",
      length: 256
    }, true, ["encrypt", "decrypt"]);
    const exportSymmetricKey = getSymmetricKey.then(symmetricKey => window.crypto.subtle.exportKey('raw', symmetricKey));
    const iv = window.crypto.getRandomValues(new Uint8Array(12));
    const encryptSymmetricKey = exportSymmetricKey.then(rawSymmetricKey => {
      const fullKey = new Uint8Array([...iv, ...new Uint8Array(rawSymmetricKey)]);
      return window.crypto.subtle.encrypt({
        name: 'RSA-OAEP'
      }, this.foreignKey, fullKey);
    });
    if (typeof content === 'object') {
      console.warn('Encoding non-string value with JSON.stringify().');
      content = JSON.stringify(content);
    }
    const getContent = fetch('data:text/plain,' + content).then(r => r.arrayBuffer());
    const encryptContent = Promise.all([getSymmetricKey, getContent]).then(_ref2 => {
      let [symmetricKey, contentBuffer] = _ref2;
      return window.crypto.subtle.encrypt({
        name: 'AES-GCM',
        iv
      }, symmetricKey, contentBuffer);
    });
    const exportPublicKey = window.crypto.subtle.exportKey('spki', this.publicKey);
    return Promise.all([encryptContent, encryptSymmetricKey, exportPublicKey]).then(_ref3 => {
      let [encryptedContent, encryptedSymmetricKey, publicKey] = _ref3;
      return new _CryptoReply.CryptoReply({
        packet: btoa(String.fromCharCode(...new Uint8Array(encryptedContent))),
        key: btoa(String.fromCharCode(...new Uint8Array(encryptedSymmetricKey))),
        pub: btoa(String.fromCharCode(...new Uint8Array(publicKey))),
        uuid: this.uuid,
        to: this.sender,
        re: this.re
      });
    });
  }
}
exports.CryptoMessage = CryptoMessage;
});

;require.register("network/CryptoMessageService.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CryptoMessageService = void 0;
var _CryptoMessage = require("./CryptoMessage");
var _Uuid = require("curvature/base/Uuid");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class CryptoMessageService {
  constructor() {
    _defineProperty(this, "requests", new Map());
  }
  invite(to) {
    const uuid = String(new _Uuid.Uuid());
    const generateKeyPair = window.crypto.subtle.generateKey({
      name: 'RSA-OAEP',
      modulusLength: 2048,
      publicExponent: new Uint8Array([1, 0, 1]),
      hash: 'SHA-256'
    }, true, ['encrypt', 'decrypt']);
    generateKeyPair.then(keyPair => this.requests.set(uuid, {
      keyPair
    }));
    return generateKeyPair.then(keyPair => window.crypto.subtle.exportKey('spki', keyPair.publicKey)).then(publicKey => ({
      pub: btoa(String.fromCharCode(...new Uint8Array(publicKey))),
      uuid,
      to
    }));
  }
  accept(message) {
    const rawForeignKey = message.content.pub;
    const messageUuid = message.content.uuid;
    const replyToUuid = message.content.re;
    const sender = message.sender;
    const uuid = String(new _Uuid.Uuid());
    const importForeignKey = fetch('data:text/plain;base64,' + rawForeignKey).then(response => response.arrayBuffer()).then(foreignKey => {
      return window.crypto.subtle.importKey("spki", foreignKey, {
        name: "RSA-OAEP",
        hash: "SHA-256"
      }, true, ["encrypt"]);
    });
    const generateKeyPair = window.crypto.subtle.generateKey({
      name: 'RSA-OAEP',
      modulusLength: 2048,
      publicExponent: new Uint8Array([1, 0, 1]),
      hash: 'SHA-256'
    }, true, ['encrypt', 'decrypt']);
    generateKeyPair.then(keyPair => this.requests.set(uuid, {
      keyPair
    }));
    let decryptContent = Promise.resolve();
    if (message.content.key && this.requests.has(replyToUuid)) {
      const request = this.requests.get(replyToUuid);
      const rawForeignSymmetricKey = message.content.key;
      const rawForeignIv = message.content.iv;
      const rawContent = message.content.packet;
      this.requests.delete(replyToUuid);
      const decryptForeignSymmetricKey = fetch('data:text/plain;base64,' + rawForeignSymmetricKey).then(response => response.arrayBuffer()).then(foreignSymmetricKey => {
        return window.crypto.subtle.decrypt({
          name: "RSA-OAEP"
        }, request.keyPair.privateKey, foreignSymmetricKey);
      }).then(buffer => {
        const fullKey = new Uint8Array(buffer);
        const iv = fullKey.slice(0, 12);
        const key = fullKey.slice(12);
        const importForeignSymmetricKey = window.crypto.subtle.importKey('raw', key, {
          name: "AES-GCM",
          length: 256
        }, true, ["decrypt"]);
        return Promise.all([importForeignSymmetricKey, iv]);
      });
      const fetchContent = fetch('data:text/plain;base64,' + rawContent).then(response => response.arrayBuffer());
      decryptContent = Promise.all([decryptForeignSymmetricKey, fetchContent]).then(_ref => {
        let [foreignSymmetricKey, content] = _ref;
        return window.crypto.subtle.decrypt({
          name: "AES-GCM",
          iv: foreignSymmetricKey[1]
        }, foreignSymmetricKey[0], content);
      }).then(contentBuffer => {
        const blob = new Blob([contentBuffer], {
          type: 'text/plain; charset=utf-8'
        });
        return blob.text();
      });
    }
    return Promise.all([generateKeyPair, importForeignKey, decryptContent]).then(_ref2 => {
      let [{
        publicKey
      }, foreignKey, content] = _ref2;
      return new _CryptoMessage.CryptoMessage({
        uuid,
        foreignKey,
        publicKey,
        content,
        sender,
        re: messageUuid
      });
    });
  }
}
exports.CryptoMessageService = CryptoMessageService;
});

;require.register("network/CryptoReply.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CryptoReply = void 0;
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class CryptoReply {
  constructor(_ref) {
    let {
      packet,
      label,
      uuid,
      key,
      pub,
      re,
      to
    } = _ref;
    _defineProperty(this, "packet", void 0);
    _defineProperty(this, "label", void 0);
    _defineProperty(this, "uuid", void 0);
    _defineProperty(this, "key", void 0);
    _defineProperty(this, "pub", void 0);
    _defineProperty(this, "re", void 0);
    _defineProperty(this, "to", void 0);
    Object.assign(this, {
      packet,
      label,
      uuid,
      key,
      pub,
      re,
      to
    });
  }
}
exports.CryptoReply = CryptoReply;
});

;require.register("network/Lobby.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Lobby = void 0;
var _View = require("curvature/base/View");
var _Uuid = require("curvature/base/Uuid");
var _Bag = require("curvature/base/Bag");
var _LobbyMessage = require("./LobbyMessage");
var _LobbyStatus = require("./LobbyStatus");
var _CryptoMessageService = require("./CryptoMessageService");
var _Bgm = require("../audio/Bgm");
var _Sfx = require("../audio/Sfx");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class Lobby extends _View.View {
  input() {}
  constructor(args, parent) {
    super(args, parent);
    _defineProperty(this, "template", require('./lobby.html'));
    _defineProperty(this, "messageService", new _CryptoMessageService.CryptoMessageService());
    _defineProperty(this, "floodControl", new Map());
    _defineProperty(this, "requests", new Map());
    _defineProperty(this, "users", new Map());
    _defineProperty(this, "serverCandidates", new Set());
    _defineProperty(this, "clientCandidates", new Set());
    _defineProperty(this, "isClient", null);
    _defineProperty(this, "sortByName", (a, b) => a.username.localeCompare(b.username));
    _defineProperty(this, "sortByTime", (a, b) => b.lastSeen - a.lastSeen);
    _defineProperty(this, "sorting", false);
    this.refreshRtc();
    this.args.roomId = this.args.roomId || '!hJzXrccruagKGXTFUQ:matrix.org';
    this.args.invites = new _Bag.Bag();
    this.args.loading = true;
    this.args.userList = [];
    ;
    this.args.users = new _Bag.Bag((i, a, s) => {
      this.sortUsers();
    });
    this.args.motd = 'Welcome to the Sonic 3000 test lobby! We\'re still building and testing, so check back soon for updates. Click a user\'s name on the left to send an invite.';
    this.args.messages = [];
    parent.matrixConnect().then(matrix => {
      this.matrix = matrix;
      this.matrix.putEvent(this.args.roomId, 'sonic-3000.lobby.step-in', {});
      matrix.whoAmI().then(userId => {
        this.user = userId;
        this.args.username = userId.user_id;
      });
      const controller = matrix.listenForRoomEvents(this.args.roomId);
      this.onRemove(() => controller.cancelled = true);
      matrix.joinRoom(this.args.roomId);

      // this.listen(matrix, 'matrix-event', event => console.log(event.detail.type, event));
      this.listen(matrix, 'sonic-3000.lobby.message', event => this.handleLobbyMessage(event));
      this.listen(matrix, 'sonic-3000.lobby.step-out', event => this.handleLobbyStepOut(event));
      this.listen(matrix, 'sonic-3000.lobby.step-in', event => this.handleLobbyStepIn(event));
      this.listen(matrix, 'sonic-3000.lobby.crypto-game-invite', event => this.handleCryptoGameInvite(event));
      this.listen(matrix, 'sonic-3000.lobby.crypto-game-offer', event => this.handleCryptoGameOffer(event));
      this.listen(matrix, 'sonic-3000.lobby.crypto-game-accept', event => this.handleCryptoGameAccept(event));
      this.listen(matrix, 'sonic-3000.lobby.crypto-game-reject', event => this.handleCryptoGameReject(event));
      this.listen(matrix, 'sonic-3000.lobby.crypto-candidate-invite', event => this.handleCryptoCandidateInvite(event));
      this.listen(matrix, 'sonic-3000.lobby.crypto-candidate-present', event => this.handleCryptoCandidatePresent(event));
      this.listen(matrix, 'sonic-3000.lobby.crypto-candidate-ack', event => this.handleCryptoCandidateAck(event));
      this.listen(window, 'unload', event => {
        this.matrix.putEvent(this.args.roomId, 'sonic-3000.lobby.step-out', {});
      });
      this.listen(matrix, 'matrix-event', event => {
        if (!event.detail.sender) {
          return;
        }
        this.checkEventSender(event.detail);
        this.sortUsers();
      });
      const sync = matrix.syncRoomHistory(this.args.roomId, message => {
        if (this.removed) {
          return false;
        }
        if (!message.sender) {
          return;
        }
        if (message.type !== 'sonic-3000.lobby.message') {
          return;
        }
        if (message.origin_server_ts < 1664651274000) {
          this.args.loading = false;
          return;
        }
        if (!message.content.body) {
          return;
        }
        if (this.args.messages.length <= 3) {
          _Sfx.Sfx.play('READY_TONE');
        }
        this.handleLobbyMessage({
          detail: message
        }, this);
      }, Date.now() - 7 * 24 * 60 * 60 * 1000, null, {
        types: ['sonic-3000.lobby.message']
        // types: ['sonic-3000.lobby.*']
        // types: ['sonic-3000.*']
        // types: ['*']
        // , not_types: [
        // 	'sonic-3000.lobby.step-out'
        // 	, 'sonic-3000.lobby.step-in'
        // 	, 'sonic-3000.lobby.crypto-game-invite'
        // 	, 'sonic-3000.lobby.crypto-game-offer'
        // 	, 'sonic-3000.lobby.crypto-game-accept'
        // 	, 'sonic-3000.lobby.crypto-game-reject'
        // 	, 'sonic-3000.lobby.crypto-candidate-invite'
        // 	, 'sonic-3000.lobby.crypto-candidate-present'
        // 	, 'sonic-3000.lobby.crypto-candidate-ack'
        // ]
      });

      const syncUsers = matrix.syncRoomHistory(this.args.roomId, message => {
        if (this.removed) {
          return false;
        }
        if (!message.sender) {
          return;
        }
        this.checkEventSender(message);
      }, Date.now() - 7 * 24 * 60 * 60 * 1000, null
      // , {
      // 	// types: ['sonic-3000.lobby.message']
      // 	// types: ['sonic-3000.lobby.*']
      // 	// types: ['sonic-3000.*']
      // 	// types: ['*']
      // 	types: [
      // 		'sonic-3000.lobby.step-out'
      // 		, 'sonic-3000.lobby.step-in'
      // 		, 'sonic-3000.lobby.crypto-game-invite'
      // 		, 'sonic-3000.lobby.crypto-game-offer'
      // 		, 'sonic-3000.lobby.crypto-game-accept'
      // 		, 'sonic-3000.lobby.crypto-game-reject'
      // 		, 'sonic-3000.lobby.crypto-candidate-invite'
      // 		, 'sonic-3000.lobby.crypto-candidate-present'
      // 		, 'sonic-3000.lobby.crypto-candidate-ack'
      // 	]
      // }
      );

      Promise.all([sync, syncUsers]).then(() => this.args.loading = false);
    });
    this.args.input = '';
  }
  onAttached() {
    _Bgm.Bgm.fadeOut(250);
    this.onTimeout(250, () => _Bgm.Bgm.stop());
  }
  checkEventSender(message) {
    const sender = message.sender;
    const [username, host] = sender.slice(1).split(':');
    if (!this.users.has(sender)) {
      const user = {
        id: sender,
        lastSeen: 0,
        username,
        host
      };
      this.users.set(sender, user);
      this.args.users.add(user);
      this.sortUsers();
    }
    const user = this.users.get(sender);
    user.lastSeen = Math.max(user.lastSeen, message.origin_server_ts);
  }
  sendMessage(event) {
    if (!this.args.input) {
      return;
    }
    if (!this.args.input.trim()) {
      return;
    }
    this.matrix.putEvent(this.args.roomId, 'sonic-3000.lobby.message', {
      msgtype: 'm.text',
      body: this.args.input
    }).then(response => this.args.input = '').catch(error => console.error(error)).finally(() => {
      this.tags.input.focus();
      _Sfx.Sfx.play('WAIT_TONE');
    });
  }
  logOut(event) {
    this.matrix.putEvent(this.args.roomId, 'sonic-3000.lobby.step-out', {});
    this.matrix.logOut();
    this.remove();
  }
  keyup(event) {
    if (event.key !== 'Enter') {
      return;
    }
    this.sendMessage(event);
  }
  sendCryptoGameInvite(event, _ref) {
    let {
      id: to
    } = _ref;
    this.refreshRtc();
    this.messageService.invite(to).then(invitation => this.matrix.putEvent(this.args.roomId, 'sonic-3000.lobby.crypto-game-invite', invitation)).then(response => {
      this.args.messages.push(new _LobbyStatus.LobbyStatus({
        message: `You invited ${to} to play!`,
        time: String(new Date(event.detail.origin_server_ts))
      }));
      this.onNextFrame(() => this.tags.scroller.scrollTop = this.tags.scroller.scrollHeight);
    }).catch(error => console.error(error)).finally(() => this.tags.input.focus());
  }
  handleCryptoGameInvite(event) {
    if (!this.user || event.detail.content.to !== this.user.user_id) {
      return;
    }
    if (!this.floodControl.has(event.detail.sender)) {
      this.floodControl.set(event.detail.sender, {});
    }
    const floodControl = this.floodControl.get(event.detail.sender);
    if (floodControl.invite && Date.now() - floodControl.invite < 15000) {
      this.rejectCryptoGameInvite(event, event.detail, 'flood_control', true);
      return;
    }
    _Sfx.Sfx.play('KNOCK_PLATFORM');
    this.args.messages.push(new _LobbyStatus.LobbyStatus({
      message: `${event.detail.sender} invited you to play!`,
      time: String(new Date(event.detail.origin_server_ts))
    }));
    this.onNextFrame(() => this.tags.scroller.scrollTop = this.tags.scroller.scrollHeight);
    this.args.invites.add(event.detail);
    floodControl.invite = Date.now();
  }
  acceptCryptoGameInvite(event, invite) {
    this.args.invites.delete(invite);
    const replyToUuid = invite.content.uuid;
    const replyToUser = invite.sender;
    this.args.messages.push(new _LobbyStatus.LobbyStatus({
      message: `You accepted the invite from ${invite.sender}!`
    }));
    this.onNextFrame(() => this.tags.scroller.scrollTop = this.tags.scroller.scrollHeight);
    this.isClient = true;
    const getIceCandidates = this.client.getIceCandidates();

    // getIceCandidates.then(candidates => console.log(candidates));

    this.messageService.accept(invite).then(cryptoMessage => {
      Promise.all([getIceCandidates, this.client.offer()]).then(_ref2 => {
        let [candidates, token] = _ref2;
        return cryptoMessage.createReply(JSON.stringify({
          candidates,
          token
        }));
      }).then(reply => this.matrix.putEvent(this.args.roomId, 'sonic-3000.lobby.crypto-game-offer', reply));
    });
    this.onTimeout(200, () => this.args.showInvites = 'hide-invites');
    this.args.showInvites = 'hiding-invites';
    _Sfx.Sfx.play('STAR_TWINKLE');
  }
  rejectCryptoGameInvite(event, invite) {
    let reason = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
    let silent = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    this.args.invites.delete(invite);
    const replyToUuid = invite.content.uuid;
    const replyToUser = invite.sender;
    if (!silent) {
      this.args.messages.push(new _LobbyStatus.LobbyStatus({
        message: `You rejected the invite from ${invite.sender}.`,
        time: String(new Date(event.detail.origin_server_ts))
      }));
      this.onNextFrame(() => this.tags.scroller.scrollTop = this.tags.scroller.scrollHeight);
    }
    this.messageService.accept(invite).then(cryptoMessage => {
      cryptoMessage.createReply(reason).then(reply => this.matrix.putEvent(this.args.roomId, 'sonic-3000.lobby.crypto-game-reject', reply));
    });
    if (!silent) {
      this.onTimeout(200, () => this.args.showInvites = 'hide-invites');
      this.args.showInvites = 'hiding-invites';
      _Sfx.Sfx.play('OBJECT_DESTROYED');
    }
  }
  handleCryptoGameOffer(event) {
    if (!this.user || event.detail.content.to !== this.user.user_id) {
      return;
    }
    const message = event.detail;
    const replyToUuid = message.content.uuid;
    const replyToUser = message.sender;
    this.messageService.accept(message).then(cryptoMessage => {
      this.args.messages.push(new _LobbyStatus.LobbyStatus({
        message: `Initializing RTC handshake...`,
        time: String(new Date(event.detail.origin_server_ts))
      }));
      this.onNextFrame(() => this.tags.scroller.scrollTop = this.tags.scroller.scrollHeight);
      let {
        content: offerString
      } = cryptoMessage;
      const isEncoded = /^s3ktp:\/\/request\/(.+)/.exec(offerString);
      if (isEncoded) {
        offerString = atob(isEncoded[1]);
      }
      const {
        token: offer,
        candidates: remoteCandidates
      } = JSON.parse(offerString);
      const answer = this.server.answer(offer);
      answer.then(() => {
        remoteCandidates.map(c => this.server.addIceCandidate(c));
      });
      Promise.all([this.server.getIceCandidates(), answer]).then(_ref3 => {
        let [candidates, offer] = _ref3;
        // console.log(candidates);
        cryptoMessage.createReply(JSON.stringify({
          candidates,
          token: offer
        })).then(reply => this.matrix.putEvent(this.args.roomId, 'sonic-3000.lobby.crypto-game-accept', reply));
      });
      this.args.messages.push(new _LobbyStatus.LobbyStatus({
        message: `${message.sender} accepted your invite!`,
        time: String(new Date(message.origin_server_ts))
      }));
      _Sfx.Sfx.play('STAR_TWINKLE');
      this.onNextFrame(() => this.tags.scroller.scrollTop = this.tags.scroller.scrollHeight);
    });
  }
  handleCryptoGameAccept(event) {
    if (!this.user || event.detail.content.to !== this.user.user_id) {
      return;
    }
    const message = event.detail;
    const replyToUuid = message.content.uuid;
    const replyToUser = message.sender;
    this.messageService.accept(message).then(cryptoMessage => {
      const {
        token,
        candidates
      } = JSON.parse(cryptoMessage.content);
      this.client.accept(token).then(() => candidates.map(c => this.client.addIceCandidate(c)));
    });

    // this.args.messages.push(new LobbyStatus({message: `Completing RTC handshake...`}));
  }

  handleCryptoGameReject(event) {
    if (!this.user || event.detail.content.to !== this.user.user_id) {
      return;
    }
    const message = event.detail;
    const replyToUuid = message.content.uuid;
    const replyToUser = message.sender;
    this.messageService.accept(message).then(cryptoMessage => {
      let message = `${event.detail.sender} rejected your invite.`;
      if (cryptoMessage.content) {
        message = `${event.detail.sender} rejected your invite: (${cryptoMessage.content})`;
      }
      this.args.messages.push(new _LobbyStatus.LobbyStatus({
        message
      }));
      this.onNextFrame(() => this.tags.scroller.scrollTop = this.tags.scroller.scrollHeight);
    });
  }
  handleLobbyMessage(_ref4) {
    let {
      detail: message
    } = _ref4;
    let fromSync = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    if (message.room_id !== this.args.roomId || !message.content.body) {
      return;
    }
    this.checkEventSender(message);
    const user = this.users.get(message.sender);
    this.args.messages[fromSync ? 'unshift' : 'push'](new _LobbyMessage.LobbyMessage({
      message: message.content.body,
      time: String(new Date(message.origin_server_ts)),
      user
    }));
    this.onNextFrame(() => this.tags.scroller.scrollTop = this.tags.scroller.scrollHeight);
    if (message.sender !== this.args.username) {
      if (!fromSync || this.args.messages.length <= 3) {
        _Sfx.Sfx.play('READY_TONE');
      }
    }
  }
  refreshRtc() {
    const newServer = !this.server; // || this.server.peerServer.connectionState === 'closed';
    const newClient = !this.client; // || this.client.peerClient.connectionState === 'closed';

    this.server = this.server || this.parent.getServer();
    this.client = this.client || this.parent.getClient();
    const server = this.server;
    const client = this.client;
    const onOpen = event => {
      console.log('Connection Opened!');
      this.parent.loadMap({
        mapUrl: '/map/emerald-isle.json',
        networked: true
      });
      this.remove();
    };
    const onClose = event => this.disconnect();
    if (newServer) {
      server.addEventListener('open', onOpen, {
        once: true
      });
      server.addEventListener('close', onClose, {
        once: true
      });
    }
    if (newClient) {
      client.addEventListener('open', onOpen, {
        once: true
      });
      client.addEventListener('close', onClose, {
        once: true
      });
    }

    // server.addEventListener('icecandidate', event => console.log(event.originalEvent.candidate));
    // client.addEventListener('icecandidate', event => console.log(event.originalEvent.candidate));
  }

  toggleMenu() {
    if (!this.args.showMenu || this.args.showMenu == 'hide-menu') {
      this.onTimeout(200, () => this.args.showMenu = 'show-menu');
      this.args.showMenu = 'showing-menu';
    } else {
      this.onTimeout(200, () => this.args.showMenu = 'hide-menu');
      this.args.showMenu = 'hiding-menu';
    }
  }
  toggleInvites() {
    if (!this.args.showInvites || this.args.showInvites == 'hide-invites') {
      this.onTimeout(200, () => this.args.showInvites = 'show-invites');
      this.args.showInvites = 'showing-invites';
    } else {
      this.onTimeout(200, () => this.args.showInvites = 'hide-invites');
      this.args.showInvites = 'hiding-invites';
    }
  }
  disconnect() {
    this.server.close();
    this.client.close();
    this.refreshRtc();
    if (this.parent.args.started) {
      this.parent.quit(2);
    }
    this.parent.args.networked = false;
    this.parent.args.chatBox = null;
  }
  sortUsers() {
    let type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    switch (type) {
      case 'abc':
        this.userSorter = this.sortByName;
        break;
      case 'time':
        this.userSorter = this.sortByTime;
        break;
    }
    if (this.sorting) {
      return;
    }
    this.sorting = true;
    this.onTimeout(100, () => {
      const userList = this.args.users.items();
      userList.sort(this.userSorter || this.sortByTime);
      this.args.userList = userList;
      this.sorting = false;
    });
  }
  closeMotd(event) {
    this.args.motdClosed = 'closed';
  }
  handleLobbyStepOut(event) {
    this.args.messages.push(new _LobbyStatus.LobbyStatus({
      message: `${event.detail.sender} stepped out.`,
      time: String(new Date(event.detail.origin_server_ts))
    }));
    this.onNextFrame(() => this.tags.scroller.scrollTop = this.tags.scroller.scrollHeight);
    _Sfx.Sfx.play('MECHASONIC_SLAP');
  }
  handleLobbyStepIn(event) {
    this.args.messages.push(new _LobbyStatus.LobbyStatus({
      message: `${event.detail.sender} stepped in.`,
      time: String(new Date(event.detail.origin_server_ts))
    }));
    this.onNextFrame(() => this.tags.scroller.scrollTop = this.tags.scroller.scrollHeight);
    _Sfx.Sfx.play('SS_BWIP_HIGH');
  }
}
exports.Lobby = Lobby;
});

;require.register("network/LobbyInvite.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LobbyInvite = void 0;
var _View = require("curvature/base/View");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class LobbyInvite extends _View.View {
  constructor() {
    super(...arguments);
    _defineProperty(this, "template", '<div class = "lobby-invite">invite!</div>');
  }
}
exports.LobbyInvite = LobbyInvite;
});

;require.register("network/LobbyMessage.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LobbyMessage = void 0;
var _View = require("curvature/base/View");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class LobbyMessage extends _View.View {
  constructor() {
    super(...arguments);
    _defineProperty(this, "template", `<span title = "[[user.id]] [[time]]" class = "username">&lt;<b>[[user.username]]</b>&gt;</span>:&nbsp;<span class = "message" cv-bind = "message"></span>`);
    _defineProperty(this, "preserve", true);
  }
}
exports.LobbyMessage = LobbyMessage;
});

;require.register("network/LobbyStatus.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LobbyStatus = void 0;
var _View = require("curvature/base/View");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class LobbyStatus extends _View.View {
  constructor() {
    super(...arguments);
    _defineProperty(this, "template", '<span class = "lobby-status-message" title = [[time]] cv-bind = "message"></span>');
    _defineProperty(this, "preserve", true);
  }
}
exports.LobbyStatus = LobbyStatus;
});

;require.register("network/Rtc.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Rtc = void 0;
class Rtc {}
exports.Rtc = Rtc;
});

;require.register("network/RtcClient.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RtcClient = void 0;
var _Mixin = require("curvature/base/Mixin");
var _EventTargetMixin = require("curvature/mixin/EventTargetMixin");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class RtcClient extends _Mixin.Mixin.with(_EventTargetMixin.EventTargetMixin) {
  constructor(rtcConfig) {
    super();
    _defineProperty(this, "candidateTimeout", 500);
    this.peerClient = new RTCPeerConnection(rtcConfig);
    this.peerClientChannel = this.peerClient.createDataChannel("chat");
    this.peerClientChannel.addEventListener('open', event => {
      const openEvent = new CustomEvent('open', {
        detail: event.data
      });
      openEvent.originalEvent = event;
      this.dispatchEvent(openEvent);
      this.connected = true;
    });
    this.peerClientChannel.addEventListener('close', event => {
      const closeEvent = new CustomEvent('close', {
        detail: event.data
      });
      closeEvent.originalEvent = event;
      this.dispatchEvent(closeEvent);
      this.connected = false;
    });
    this.peerClientChannel.addEventListener('message', event => {
      const messageEvent = new CustomEvent('message', {
        detail: event.data
      });
      messageEvent.originalEvent = event;
      this.dispatchEvent(messageEvent);
    });
    this.peerClient.addEventListener('icecandidate', event => {
      const messageEvent = new CustomEvent('icecandidate', {
        detail: event.data
      });
      messageEvent.originalEvent = event;
      this.dispatchEvent(messageEvent);
    });
  }
  send(input) {
    if (!this.peerClientChannel) {
      return;
    }
    if (this.peerClientChannel.readyState !== 'open') {
      return;
    }
    this.peerClientChannel.send(input);
  }
  close() {
    return this.peerClient.close();
  }
  getIceCandidates() {
    const candidates = new Set();
    return new Promise(accept => this.peerClient.addEventListener('icecandidate', event => {
      candidates.add(event.candidate);
      if (!event.candidate) {
        accept([...candidates]);
        return;
      }
    }));
  }
  addIceCandidate(candidate) {
    this.peerClient.addIceCandidate(candidate);
  }
  offer() {
    return this.peerClient.createOffer().then(offer => this.peerClient.setLocalDescription(offer)).then(() => this.peerClient.localDescription);
  }
  fullOffer() {
    return this.offer().then(offer => this.getIceCandidates().then(candidates => ({
      offer,
      candidates
    })));
  }
  accept(answer) {
    const session = new RTCSessionDescription(answer);
    return this.peerClient.setRemoteDescription(session);
  }
  fullAccept(_ref) {
    let {
      answer,
      candidates
    } = _ref;
    return this.accept(answer).then(() => candidates.map(c => this.addIceCandidate(c)));
  }
}
exports.RtcClient = RtcClient;
});

;require.register("network/RtcClientTask.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RtcClientTask = void 0;
var _Task = require("subspace-console/Task");
var _Tag = require("curvature/base/Tag");
var _RtcClient = require("./RtcClient");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
const Accept = Symbol('accept');
class RtcClientTask extends _Task.Task {
  constructor() {
    super(...arguments);
    _defineProperty(this, "title", 'RTC Client Task');
    _defineProperty(this, "connected", false);
  }
  init() {
    this.client = new _RtcClient.RtcClient({
      iceServers: [{
        urls: 'stun:stun1.l.google.com:19302'
      }, {
        urls: 'stun:stun2.l.google.com:19302'
      }]
    });
    this.finally(() => {
      console.log('Terminating connection...');
      this.client.close();
    });
    this.client.addEventListener('open', () => {
      this.print('Remote peer client accepted!');
    });
    this.client.addEventListener('close', () => {
      this.print('Peer reset connection.');
    });
    this.client.addEventListener('message', event => {
      this.print(`> ${event.detail}`);
    });
    this.client.offerToken.then(token => {
      const tokenString = JSON.stringify(token);
      const encodedToken = `s3ktp://request/${btoa(tokenString)}`;
      this.print(`Client request code: ${encodedToken}`);
      const offerTag = new _Tag.Tag('<textarea style = "display:none">');
      offerTag.innerText = encodedToken;
      document.body.append(offerTag.node);
      offerTag.select();
      document.execCommand("copy");
      offerTag.node.remove();
    });
    return new Promise(accept => {
      this[Accept] = accept;
    });
  }
  main(input) {
    if (!input) {
      return;
    }
    if (!this.client.connected) {
      this.accept(input);
      return;
    }
    this.print(`< ${input}`);
    this.client.send(input);
  }
  accept(answerString) {
    if (!answerString) {
      this.print(`Please supply server's accept string.`);
      return;
    }
    const isEncoded = /^s3ktp:\/\/accept\/(.+)/.exec(answerString);
    if (isEncoded) {
      answerString = atob(isEncoded[1]);
    }
    const answer = JSON.parse(answerString);
    this.client.accept(answer);
  }
}
exports.RtcClientTask = RtcClientTask;
_defineProperty(RtcClientTask, "helpText", 'RTC Client.');
_defineProperty(RtcClientTask, "useText", '');
});

;require.register("network/RtcServer.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RtcServer = void 0;
var _Mixin = require("curvature/base/Mixin");
var _EventTargetMixin = require("curvature/mixin/EventTargetMixin");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class RtcServer extends _Mixin.Mixin.with(_EventTargetMixin.EventTargetMixin) {
  constructor(rtcConfig) {
    super();
    _defineProperty(this, "candidateTimeout", 500);
    this.peerServer = new RTCPeerConnection(rtcConfig);
    this.peerServer.addEventListener('datachannel', event => {
      this.peerServerChannel = event.channel;
      this.peerServerChannel.addEventListener('open', event => {
        const openEvent = new CustomEvent('open', {
          detail: event.data
        });
        openEvent.originalEvent = event;
        this.dispatchEvent(openEvent);
        this.connected = true;
      });
      this.peerServerChannel.addEventListener('close', event => {
        const closeEvent = new CustomEvent('close', {
          detail: event.data
        });
        closeEvent.originalEvent = event;
        this.dispatchEvent(closeEvent);
        this.connected = false;
      });
      this.peerServerChannel.addEventListener('message', event => {
        const messageEvent = new CustomEvent('message', {
          detail: event.data
        });
        messageEvent.originalEvent = event;
        this.dispatchEvent(messageEvent);
      });
      this.peerServerChannel.addEventListener('icecandidate', event => {
        const messageEvent = new CustomEvent('icecandidate', {
          detail: event.data
        });
        messageEvent.originalEvent = event;
        this.dispatchEvent(messageEvent);
      });
    });
  }
  send(input) {
    if (!this.peerServerChannel) {
      return;
    }
    if (this.peerServerChannel.readyState !== 'open') {
      return;
    }
    this.peerServerChannel.send(input);
  }
  close() {
    return this.peerServer.close();
  }
  getIceCandidates() {
    const candidates = new Set();
    return new Promise(accept => this.peerServer.addEventListener('icecandidate', event => {
      candidates.add(event.candidate);
      if (!event.candidate) {
        accept([...candidates]);
        return;
      }
    }));
  }
  addIceCandidate(candidate) {
    this.peerServer.addIceCandidate(candidate);
  }
  answer(offer) {
    return this.peerServer.setRemoteDescription(offer).then(() => this.peerServer.createAnswer()).then(answer => this.peerServer.setLocalDescription(answer)).then(() => this.peerServer.localDescription);
  }
  fullAnswer(_ref) {
    let {
      offer,
      candidates
    } = _ref;
    return this.answer(offer).then(answer => {
      return Promise.all(candidates.map(c => this.addIceCandidate(c))).then(() => {
        return this.getIceCandidates().then(candidates => {
          return {
            answer,
            candidates
          };
        });
      });
    });
  }
}
exports.RtcServer = RtcServer;
});

;require.register("network/RtcServerTask.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RtcServerTask = void 0;
var _Task = require("subspace-console/Task");
var _Tag = require("curvature/base/Tag");
var _RtcServer = require("./RtcServer");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
const Accept = Symbol('accept');
class RtcServerTask extends _Task.Task {
  constructor() {
    super(...arguments);
    _defineProperty(this, "title", 'RTC Server Task');
    _defineProperty(this, "connected", false);
  }
  init() {
    this.server = new _RtcServer.RtcServer({
      iceServers: [{
        urls: 'stun:stun1.l.google.com:19302'
      }, {
        urls: 'stun:stun2.l.google.com:19302'
      }]
    });
    this.finally(() => {
      this.print('Terminating connection...');
      this.server.close();
    });
    this.server.addEventListener('open', () => {
      this.print('Remote peer client accepted!');
    });
    this.server.addEventListener('close', () => {
      this.print('Peer reset connection.');
    });
    this.server.addEventListener('message', event => {
      this.print(`> ${event.detail}`);
    });
    this.server.answerToken.then(token => {
      const tokenString = JSON.stringify(token);
      const encodedToken = `s3ktp://accept/${btoa(tokenString)}`;
      this.print(`Server accept code: ${encodedToken}`);
      const answerTag = new _Tag.Tag('<textarea style = "display:none">');
      answerTag.innerText = encodedToken;
      document.body.append(answerTag.node);
      answerTag.select();
      document.execCommand("copy");
      answerTag.node.remove();
    });
    this.printErr(`Please supply client's request code.`);
    return new Promise(accept => {
      this[Accept] = accept;
    });
  }
  main(input) {
    if (!input) {
      return;
    }
    if (!this.server.connected) {
      this.answer(input);
      return;
    }
    this.print(`< ${input}`);
    this.server.send(input);
  }
  answer(offerString) {
    const isEncoded = /^s3ktp:\/\/request\/(.+)/.exec(offerString);
    console.log(isEncoded);
    if (isEncoded) {
      offerString = atob(isEncoded[1]);
    }
    const offer = JSON.parse(offerString);
    this.server.answer(offer);
  }
  done() {}
}
exports.RtcServerTask = RtcServerTask;
_defineProperty(RtcServerTask, "helpText", 'RTC Server.');
_defineProperty(RtcServerTask, "useText", '');
});

;require.register("network/chat-box.html", function(exports, require, module) {
module.exports = "<div class = \"chatbox\" data-click-barrier>\n\n\t<div class = \"chat-output\" cv-each = \"outputLines:line\" cv-ref = \"chatOutput\">\n\t\t<p>[[line]]</p>\n\t</div>\n\n\t<div class = \"chat-input\">\n\t\t<input cv-bind = \"chatInput\" cv-ref = \"chatInput\" cv-on = \"keydown:send(event)\">\n\t\t<button cv-on = \"click:send\">send</button>\n\t</div>\n\n</div>\n"
});

;require.register("network/lobby.html", function(exports, require, module) {
module.exports = "<div class = \"lobby [[showMenu]] [[showInvites]]\" data-click-barrier>\n\n\t<div class = \"main column\">\n\t\t<div class = \"left-menu\">\n\t\t\t<div>[[username]]</div>\n\t\t\t<button cv-on = \"click:logOut\">Log Out</button>\n\t\t</div>\n\n\t\t<div class = \"topbar row\">\n\t\t\t<div class = \"row\">\n\t\t\t\t<div class = \"burger-button\" cv-on = \"click:toggleMenu\">\n\t\t\t\t\t<div class = \"stripe\"></div>\n\t\t\t\t\t<div class = \"stripe\"></div>\n\t\t\t\t\t<div class = \"stripe\"></div>\n\t\t\t\t</div>\n\t\t\t\t<div class = \"title\">\n\t\t\t\t\t#sonic-3000-test-lobby\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t\t<div>\n\t\t\t\t<div cv-on = \"click:toggleInvites\" class = \"invite button\">\n\t\t\t\t\t<div class = \"amount\" cv-if = \"invites.length\">[[invites.length]]</div>\n\t\t\t\t\t<img class = \"icon\" src = \"/icons/mail.svg\" />\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</div>\n\n\t\t<div class = \"row wide\">\n\n\t\t\t<div class = \"users frame column\">\n\t\t\t\t<div class = \"sort-buttons\">\n\t\t\t\t\t<button class = \"sort-abc\"  cv-on = 'click:sortUsers(\"abc\")'></button>\n\t\t\t\t\t<button class = \"sort-time\" cv-on = 'click:sortUsers(\"time\")'></button>\n\t\t\t\t</div>\n\t\t\t\t<div class = \"scroller\" cv-each = \"userList:user\">\n\t\t\t\t\t<div title = \"[[user.id]]\" class = \"user\" tabindex = \"0\">\n\t\t\t\t\t\t[[user.username]]\n\t\t\t\t\t\t<div class = \"user-list-buttons\">\n\t\t\t\t\t\t\t<button cv-on   = \"click:sendCryptoGameInvite(event, user)\">invite</button>\n<!-- \t\t\t\t\t\t\t<button>message</button>\n\t\t\t\t\t\t\t<button>ignore</button> -->\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t</div>\n\n\t\t\t<div class = \"messages wide column\">\n\t\t\t\t<div class = \"row motd [[motdClosed]]\">\n\t\t\t\t\t<button class=\"close-button\" cv-on = \"click:closeMotd\"></button>\n\t\t\t\t\t<span>&lt;motd&gt;: [[motd]]</span>\n\t\t\t\t</div>\n\t\t\t\t<div class = \"row wide frame\">\n\t\t\t\t\t<div class = \"scroller\" cv-ref = \"scroller\">\n\t\t\t\t\t\t<div cv-if = \"loading\">\n\t\t\t\t\t\t\t<img class = \"loader icon\" src = \"/icons/loader.svg\" />\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<div class = \"column\" cv-each = \"messages:message\">\n\t\t\t\t\t\t\t<span class = \"message\">[[message]]</span>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t\t<div class = \"row\">\n\t\t\t\t\t<input\n\t\t\t\t\t\ttype    = \"text\"\n\t\t\t\t\t\tcv-bind = \"input\"\n\t\t\t\t\t\tcv-on   = \"keyup\"\n\t\t\t\t\t\tcv-ref  = \"input\"\n\t\t\t\t\t/>\n\t\t\t\t\t<button cv-on   = \"click:sendMessage\">send</button>\n\t\t\t\t</div>\n\t\t\t</div>\n\n\t\t\t<div class = \"invites\">\n\t\t\t\t<div cv-if = \"!invites.length\">No pending invites.</div>\n\t\t\t\t<div class = \"column\" cv-each = \"invites:invite:i\">\n\t\t\t\t\t<div class = \"column\">\n\t\t\t\t\t\t<div>[[invite.sender]] invited you to play!</div>\n\t\t\t\t\t\t<div class = \"row\">\n\t\t\t\t\t\t\t<button cv-on = \"click:acceptCryptoGameInvite(event, invite)\">accept</button>\n\t\t\t\t\t\t\t<button cv-on = 'click:rejectCryptoGameInvite(event, invite, \"button_clicked\")'>reject</button>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t</div>\n\n\t\t</div>\n\t</div>\n</div>\n"
});

;require.register("particle/Particle3d.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Particle3d = void 0;
var _Tag = require("curvature/base/Tag");
class Particle3d extends _Tag.Tag {
  constructor() {
    super('<div class = "particle-3d">');
    const front = new _Tag.Tag('<div class = "front-3d">');
    const back = new _Tag.Tag('<div class = "back-3d">');
    const left = new _Tag.Tag('<div class = "right-3d">');
    const right = new _Tag.Tag('<div class = "left-3d">');
    const top = new _Tag.Tag('<div class = "top-3d">');
    const bottom = new _Tag.Tag('<div class = "bottom-3d">');
    this.append(back.node);
    this.append(left.node);
    this.append(right.node);
    this.append(front.node);
    this.append(top.node);
    this.append(bottom.node);
  }
}
exports.Particle3d = Particle3d;
});

;require.register("powerups/BubbleSheild.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BubbleSheild = void 0;
var _Bindable = require("curvature/base/Bindable");
var _Sheild = require("./Sheild");
var _Sfx = require("../audio/Sfx");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class BubbleSheild extends _Sheild.Sheild {
  constructor() {
    super(...arguments);
    _defineProperty(this, "template", `<div class = "sheild bubble-sheild [[bouncing]]"><div class = "bubble-sheild-shine"></div></div>`);
    _defineProperty(this, "protect", true);
    _defineProperty(this, "type", 'water');
  }
  unequip(host) {
    super.unequip(host);
    host.args.bouncing = false;
    this.args.bouncing = false;
    this.args.force = 0;
  }
  acquire(host) {
    const viewport = host.viewport;
    if (!viewport) {
      return;
    }
    if (host.controllable) {
      _Sfx.Sfx.play('WATER_ACQUIRE');
    }
    const invertDamage = event => {
      if (host.args.currentSheild !== _Bindable.Bindable.make(this)) {
        return;
      }
      event.preventDefault();
      const other = event.detail.other;
      other && other.pop && other.pop(host);
      this.onNextFrame(() => {
        host.args.currentSheild = null;
        host.inventory.remove(this);
      });
      host.removeEventListener('damage', invertDamage);
      host.startle(other);
    };
    host.addEventListener('damage', invertDamage);
  }
  immune(host, other) {
    let type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'normal';
    if (type === 'water' || type === 'projectile') {
      return true;
    }
    return false;
  }
  command_0(host, button) {
    if (host.canFly && host.yAxis < 0.55) {
      return;
    }
    if (host.dashed) {
      return;
    }
    if (host.args.standingOn && host.args.standingOn.isVehicle) {
      return;
    }
    this.args.force = 10;
    if (host.args.jumping) {
      host.impulse(14, Math.PI / 2);
      this.args.bouncing = 'bouncing';
      host.args.bouncing = true;
    }
    if (host.args.falling && host.yAxis) {
      return false;
    }
  }
  hold_0() {
    if (this.args.bouncing && this.args.force < 16) {
      this.args.force++;
    }
  }
  update(host) {
    if (host.args.ySpeed < -5) {
      this.onNextFrame(() => {
        host.args.bouncing = false;
        this.args.bouncing = false;
        this.args.force = 0;
      });
    }

    // if(host.canFly)
    // {
    // 	return;
    // }

    if (!host.args.falling) {
      if (this.args.bouncing && this.args.force) {
        // host.args.gSpeed = 0;
        // host.args.xSpeed = 0;

        this.onNextFrame(() => {
          host.args.standingOn = null;
          host.args.bouncing = false;
          host.args.falling = true;
          host.args.jumping = true;
          host.impulse(this.args.force, -Math.PI / 2, true);
        });
        this.args.bouncing = '';
        _Sfx.Sfx.play('WATER_BOUNCE');
        if (host.viewport.settings.rumble) {
          host.controller.rumble({
            duration: 200,
            strongMagnitude: 1.0,
            weakMagnitude: 1.0
          });
        }
      }
    }
  }
}
exports.BubbleSheild = BubbleSheild;
});

;require.register("powerups/ElectricSheild.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ElectricSheild = void 0;
var _Bindable = require("curvature/base/Bindable");
var _Sheild = require("./Sheild");
var _Sfx = require("../audio/Sfx");
var _Tag = require("curvature/base/Tag");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class ElectricSheild extends _Sheild.Sheild {
  constructor() {
    super(...arguments);
    _defineProperty(this, "template", `<div class = "sheild electric-sheild [[boosted]]"></div>`);
    _defineProperty(this, "protect", true);
    _defineProperty(this, "type", 'electric');
    _defineProperty(this, "jumps", 3);
    _defineProperty(this, "attract", new Set());
    _defineProperty(this, "magnetism", 0.25);
    _defineProperty(this, "magnetTimeout", false);
    _defineProperty(this, "particles", new Set());
  }
  acquire(host) {
    const viewport = host.viewport;
    if (!viewport) {
      return;
    }
    if (host.controllable) {
      _Sfx.Sfx.play('ELECTRIC_ACQUIRE');
    }
    const invertDamage = event => {
      if (host.args.currentSheild !== _Bindable.Bindable.make(this)) {
        return;
      }
      event.preventDefault();
      const other = event.detail.other;
      if (this.immune(host, other, event.detail.type)) {
        event.detail.immune = true;
        return;
      }
      other && other.damage && other.damage(host, 'electric');
      this.onNextFrame(() => {
        host.args.currentSheild = null;
        host.inventory.remove(this);
      });
      host.removeEventListener('damage', invertDamage);
      host.startle(other);
      this.drop(host);
    };
    host.addEventListener('damage', invertDamage);
  }
  drop(host) {
    for (const particle of this.particles) {
      viewport.particles.remove(particle);
      this.particles.delete(particle);
    }
  }
  immune(host, other) {
    let type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'normal';
    if (type === 'electric' || type === 'projectile') {
      return true;
    }
    return false;
  }
  command_0(host, button) {
    if (!host.args.falling) {
      return;
    }
    if (host.canFly && (Math.abs(host.yAxis) < 0.55 || host.args.flying)) {
      return;
    }
    if (this.jumps > 0 && host.args.jumping) {
      host.args.ySpeed = 0;
      host.impulse(10, -Math.PI / 2);
      this.jumps--;

      // this.args.boosted = 'boosted';

      this.onTimeout(250, () => this.args.boosted = '');
      _Sfx.Sfx.play('ELECTRIC_JUMP');
      if (host.xAxis && Math.sign(host.xAxis) !== Math.sign(host.args.xSpeed)) {
        host.args.xSpeed = 1 * host.xAxis;
      }
      viewport = host.viewport;
      if (!viewport) {
        return;
      }
      const sparkParticleL = new _Tag.Tag(document.createElement('div'));
      const sparkParticleR = new _Tag.Tag(document.createElement('div'));
      sparkParticleL.classList.add('particle-electric-jump-spark');
      sparkParticleR.classList.add('particle-electric-jump-spark');
      sparkParticleL.style({
        '--x': host.args.x,
        '--y': host.args.y - 30,
        'z-index': 0
      });
      sparkParticleR.style({
        '--x': host.args.x,
        '--y': host.args.y - 30,
        'z-index': 0
      });
      sparkParticleL.age = 0;
      sparkParticleL.y = host.args.y - 30;
      sparkParticleL.x = host.args.x;
      sparkParticleL.d = -1;
      sparkParticleR.age = 0;
      sparkParticleR.y = host.args.y - 30;
      sparkParticleR.x = host.args.x;
      sparkParticleR.d = 1;
      viewport.particles.add(sparkParticleL);
      viewport.particles.add(sparkParticleR);
      viewport.onFrameOut(200, () => viewport.particles.remove(sparkParticleL));
      viewport.onFrameOut(200, () => viewport.particles.remove(sparkParticleR));
      this.particles.add(sparkParticleL);
      this.particles.add(sparkParticleR);
    }
    if (host.canFly && Math.abs(host.yAxis) > 0.55) {
      return false;
    }
  }
  release_6(host, button) {
    // this.magnetism = 0;

    // for(const ring of this.attract)
    // {
    // 	this.onTimeout(3000, () => {
    // 		ring.args.x = ring.def.get('x');
    // 		ring.args.y = ring.def.get('y');
    // 		host.viewport.auras.delete(ring);
    // 		host.viewport.setColCell(ring);
    // 		ring.restore = true;
    // 		ring.args.float = -1;
    // 		ring.noClip = false;
    // 		ring.args.xSpeed  = 0;
    // 		ring.args.ySpeed  = 0;
    // 	});

    // 	this.attract.delete(ring);
    // }
  }

  // hold_6(host, button)
  // {
  // 	const pressure = button.pressure;

  // 	this.magnetize(host,pressure);
  // }

  magnetize(host, pressure) {
    if (!host.controllable) {
      return;
    }
    host.args.xOff = 0;
    host.args.yOff = 32;

    // this.args.boosted = 'boosted';

    this.magnetism = Math.max(0.25, pressure);

    // host.pinch(260 * this.magnetism, 0);

    const Ring = host.viewport.objectPalette.ring;
    const findRing = actor => {
      if (this.attract.has(actor)) {
        return false;
      }
      if (!(actor instanceof Ring)) {
        return false;
      }
      if (actor.args.gone) {
        return false;
      }
      if (actor.restore) {
        return false;
      }
      return true;
    };
    const ring = host.findNearestActor(findRing, 256);
    if (ring) {
      host.viewport.auras.add(ring);
      this.attract.add(ring);
    }
  }
  update(host) {
    for (const sparkParticle of this.particles) {
      sparkParticle.age && sparkParticle.style({
        '--x': sparkParticle.x - (40 - 40 / (sparkParticle.age * 0.35) ** 2) * sparkParticle.d,
        '--y': sparkParticle.y + (sparkParticle.age * 0.35) ** 2
      });
      sparkParticle.age++;
    }
    this.magnetize(host, 2.5);
    if (!host.args.falling && !this.magnetTimeout) {
      this.magnetTimeout = this.onTimeout(100, () => {
        this.magnetTimeout = false;
        this.args.boosted = '';
      });
    }
    if (host.canFly) {
      // return;
    }
    if (!host.args.falling) {
      this.jumps = 3;
    }
    let ringsMoved = 0;
    for (const ring of this.attract) {
      if (ring.args.gone) {
        this.attract.delete(ring);
        ring.attract = null;
        const viewport = host.viewport;
        viewport.onFrameOut(30, () => {
          if (!ring.def) {
            return;
          }
          ring.args.static = false;
          ring.args.xSpeed = 0;
          ring.args.ySpeed = 0;
          ring.args.x = ring.def.get('x');
          ring.args.y = ring.def.get('y');
          viewport.setColCell(ring);
          viewport.onFrameOut(5 * 60, () => {
            viewport.auras.delete(ring);
            ring.args.float = -1;
            ring.noClip = false;
            ring.restore = true;
          });
        });
        continue;
      }
      ring.args.static = false;
      ring.attract = host;
      ring.noClip = true;
      const xDiff = host.x - ring.x;
      const yDiff = host.y - host.args.height / 2 - ring.y;
      const angle = Math.atan2(yDiff, xDiff);
      const distance = Math.hypot(yDiff, xDiff);
      const maxDistance = 512;
      const xDir = Math.sign(xDiff);
      const yDir = Math.sign(yDiff);
      const xSame = Math.sign(ring.args.xSpeed || 0) === xDir;
      const ySame = Math.sign(ring.args.ySpeed || 0) === yDir;
      if (distance > maxDistance) {
        if (ringsMoved > 45) {
          continue;
        }
        ring.args.x = host.x - Math.cos(angle) * maxDistance;
        ring.args.y = host.y - Math.sin(angle) * maxDistance;
      }
      host.viewport.setColCell(ring);
      ringsMoved++;
      const force = (this.magnetism || 0.75) * 2;
      const xMag = Math.max(force, xSame ? 0.45 : 0.55);
      const yMag = Math.max(force, ySame ? 0.45 : 0.45);

      // const xMag = Math.max(this.magnetism, xDiff === xDir ? 0.35 : 0.35);
      // const yMag = Math.max(this.magnetism, yDiff === yDir ? 0.125 : 0.135);

      ring.args.groundAngle = 0;
      const fudge = this.magnetism ? Math.random() : 1;
      if (!xSame || Math.abs(ring.args.xSpeed) < 8 || distance > maxDistance) {
        ring.args.xSpeed += Math.max(0.1, xMag * fudge) * xDir;
      }
      if (!ySame || Math.abs(ring.args.ySpeed) < 8 || distance > maxDistance) {
        ring.args.ySpeed += Math.max(0.1, yMag * fudge) * yDir;
      }
      ring.args.falling = true;
    }
  }
}
exports.ElectricSheild = ElectricSheild;
});

;require.register("powerups/FireSheild.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FireSheild = void 0;
var _Bindable = require("curvature/base/Bindable");
var _Sheild = require("./Sheild");
var _Sfx = require("../audio/Sfx");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class FireSheild extends _Sheild.Sheild {
  constructor() {
    super(...arguments);
    _defineProperty(this, "template", `<div class = "sheild fire-sheild [[boosted]]"></div>`);
    _defineProperty(this, "protect", true);
    _defineProperty(this, "type", 'fire');
    _defineProperty(this, "power", 15);
  }
  acquire(host) {
    const viewport = host.viewport;
    if (!viewport) {
      return;
    }
    if (host.controllable) {
      _Sfx.Sfx.play('FIRE_ACQUIRE');
    }
    const invertDamage = event => {
      if (host.args.currentSheild !== _Bindable.Bindable.make(this)) {
        return;
      }
      event.preventDefault();
      const other = event.detail.other;
      other && other.pop && other.pop(host);
      this.onNextFrame(() => {
        host.args.currentSheild = null;
        host.inventory.remove(this);
      });
      host.removeEventListener('damage', invertDamage);
      host.startle(other);
    };
    host.addEventListener('damage', invertDamage);
  }
  immune(host, other) {
    let type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'normal';
    if (type === 'fire' || type === 'projectile') {
      return true;
    }
    return false;
  }
  update(host) {
    if (!host.args.falling) {
      this.didBoost = false;
      this.power = 15;
    }
  }
  hold_4(host, button) {
    if (this.power <= 0) {
      return;
    }
    this.power--;
    if (host.canFly) {
      // return;
    }
    if (host.args.falling) {
      host.impulse(1, Math.PI);
      if (!this.args.boosted) {
        this.args.boosted = 'boosted';
        host.args.didBoost = true;
        _Sfx.Sfx.play('FIRE_DASH');
        host.viewport.onFrameOut(15, () => this.args.boosted = '');
      }
    } else {
      this.args.boosted = '';
    }
  }
  hold_5(host, button) {
    if (this.power <= 0) {
      return;
    }
    this.power--;
    if (host.canFly) {
      // return;
    }
    if (host.args.falling) {
      host.impulse(1, 0);
      if (!this.args.boosted) {
        this.args.boosted = 'boosted';
        host.args.didBoost = true;
        _Sfx.Sfx.play('FIRE_DASH');
        host.viewport.onFrameOut(15, () => this.args.boosted = '');
      }
    } else {
      this.args.boosted = '';
    }
  }
}
exports.FireSheild = FireSheild;
});

;require.register("powerups/NormalSheild.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NormalSheild = void 0;
var _Bindable = require("curvature/base/Bindable");
var _Sheild = require("./Sheild");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class NormalSheild extends _Sheild.Sheild {
  constructor() {
    super(...arguments);
    _defineProperty(this, "template", `<div class = "sheild normal-sheild"></div>`);
    _defineProperty(this, "protect", true);
    _defineProperty(this, "type", 'normal');
  }
  acquire(host) {
    const viewport = host.viewport;
    if (!viewport) {
      return;
    }
    const invertDamage = event => {
      if (host.args.currentSheild !== _Bindable.Bindable.make(this)) {
        return;
      }
      event.preventDefault();
      const other = event.detail.other;
      other && other.damage && other.damage(host);
      this.onNextFrame(() => {
        host.args.currentSheild = null;
        host.inventory.remove(this);
      });
      host.removeEventListener('damage', invertDamage);
      host.startle(other);
    };
    host.addEventListener('damage', invertDamage);
  }
  immune(host, other) {
    let type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'normal';
    return false;
  }
}
exports.NormalSheild = NormalSheild;
});

;require.register("powerups/Powerup.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Powerup = void 0;
var _Bindable = require("curvature/base/Bindable");
var _View = require("curvature/base/View");
let _Bindable$NoGetters;
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
_Bindable$NoGetters = _Bindable.Bindable.NoGetters;
class Powerup extends _View.View {
  constructor() {
    super(...arguments);
    _defineProperty(this, _Bindable$NoGetters, true);
  }
  equip() {}
  unequip() {}
  acquire() {}
  drop() {}
}
exports.Powerup = Powerup;
});

;require.register("powerups/Sheild.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Sheild = void 0;
var _Powerup = require("./Powerup");
class Sheild extends _Powerup.Powerup {
  // immune(host, other, type = 'normal')
  // {
  // 	if(type === 'fire')
  // 	{
  // 		return true;
  // 	}

  // 	return false;
  // }

  // immune(other, type)
  // {
  // 	return false;
  // }
}
exports.Sheild = Sheild;
});

;require.register("powerups/StarSheild.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.StarSheild = void 0;
var _Sheild = require("./Sheild");
var _Bgm = require("../audio/Bgm");
var _Tag = require("curvature/base/Tag");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class StarSheild extends _Sheild.Sheild {
  constructor() {
    super(...arguments);
    _defineProperty(this, "type", 'star');
    _defineProperty(this, "protect", true);
    _defineProperty(this, "template", `<div class = "sheild star-sheild">
		<div class = "star-sheild-stars"></div>
	</div>`);
    _defineProperty(this, "frame", 0);
    _defineProperty(this, "recycle", []);
  }
  // constructor(...args)
  // {
  // 	super(...args);

  // }

  acquire(host) {
    const viewport = host.viewport;
    if (!viewport) {
      return;
    }
    const previous = host.args.currentSheild;
    const invertDamage = event => {
      event.preventDefault();
      const other = event.detail.other;
      other && other.pop && other.pop(host);
    };
    host.addEventListener('damage', invertDamage);
    viewport.onFrameOut(1560, () => {
      _Bgm.Bgm.stop('STAR_SHIELD');
      host.inventory.remove(this);
      host.removeEventListener('damage', invertDamage);
      host.args.currentSheild = previous;
      this.debindPaused && this.debindPaused();
      delete this.debindPaused;
    });
    host.onRemove(() => _Bgm.Bgm.stop('STAR_SHIELD'));
    _Bgm.Bgm.play('STAR_SHIELD', {
      interlude: true
    });
    if (!viewport.args.audio) {
      _Bgm.Bgm.pause();
    }
  }
  immune() {
    return true;
  }
  drop(host) {
    console.log(this, host);
    this.debindPaused && this.debindPaused();
    delete this.debindPaused;
  }
  update(host) {
    const viewport = host.viewport;
    if (!viewport) {
      return;
    }
    const particle = this.recycle.length ? this.recycle.shift() : new _Tag.Tag(document.createElement('div'));
    particle.node.classList.add('particle-stars');
    const point = host.rotatePoint(0, host.args.height / 2);
    const dashed = host.dashed || host.args.animation === 'springdash';
    let yOffset = -3;
    if (host.args.rolling) {
      yOffset = 3;
    }
    if (dashed) {
      yOffset = -16;
    }
    particle.style({
      '--frame': this.frame++,
      '--x': point[0] + host.x + -3 + host.args.xSpeed,
      '--y': point[1] + host.y + host.args.ySpeed + yOffset,
      'z-index': -1,
      opacity: Math.random() * 2
    });
    particle.preserve = true;
    viewport.particles.add(particle);
    viewport.onFrameOut(10, () => {
      viewport.particles.remove(particle);
      this.recycle.push(particle);
    });
  }
}
exports.StarSheild = StarSheild;
});

;require.register("powerups/SuperSheild.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SuperSheild = void 0;
var _Sheild = require("./Sheild");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class SuperSheild extends _Sheild.Sheild {
  constructor() {
    super(...arguments);
    _defineProperty(this, "template", `<div class = "sheild super-sheild">
		<div class = "super-sheild-shine"></div>
		<div class = "super-sheild-spark"></div>
		<div class = "super-sheild-flare"></div>
	</div>`);
    _defineProperty(this, "type", 'super');
  }
  immune(host, other) {
    let type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'normal';
    if (host.isSuper || host.isHyper) {
      return true;
    }
    return false;
  }
}
exports.SuperSheild = SuperSheild;
});

;require.register("region/BgShadeRegion.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BgShadeRegion = void 0;
var _ShadeRegion = require("./ShadeRegion");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class BgShadeRegion extends _ShadeRegion.ShadeRegion {
  constructor() {
    super(...arguments);
    _defineProperty(this, "currentFilter", -1);
    _defineProperty(this, "filters", ['studio', 'western', 'heat', 'hydro', 'lava', 'frost', 'eight-bit', 'corruption', 'black-hole', 'normal']);
    this.args.type = 'region region-shade bg-region-shade';
  }
}
exports.BgShadeRegion = BgShadeRegion;
});

;require.register("region/BossRegion.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BossRegion = void 0;
var _Region = require("./Region");
class BossRegion extends _Region.Region {
  constructor() {
    super(...arguments);
    this.args.type = 'region boss';
    this.args.hidden = true;
  }
  updateActor(other) {
    if (other.args.falling) {
      return;
    }
    if (!this.args._boss) {
      const boss = this.viewport.actorsById[this.args.boss];
      if (!boss) {
        other.args.bossMode = false;
        return;
      }
      if (!boss.args.hitPoints) {
        other.args.bossMode = false;
      } else {
        other.args.bossMode = true;
      }
    }
  }
}
exports.BossRegion = BossRegion;
});

;require.register("region/CorkscrewRegion.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CorkscrewRegion = void 0;
var _Region = require("./Region");
var _Tag = require("curvature/base/Tag");
class CorkscrewRegion extends _Region.Region {
  static fromDef(objDef) {
    const width = objDef.width;
    const height = objDef.height;
    const x = objDef.x;
    const y = objDef.y;
    const obj = super.fromDef(objDef);
    obj.args.width = width;
    obj.args.height = height;

    // obj.args.x = x - width  / 2;
    obj.args.y = y + height;
    return obj;
  }
  constructor() {
    super(...arguments);
    this.args.type = 'region corkscrew';
    this.args.hidden = true;
  }
  updateActor(other) {
    if (!other.canRoll || other.args.falling && other.args.ySpeed < 0) {
      return;
    }
    if (Math.abs(other.args.xSpeed) < 1 || Math.abs(other.args.ySpeed) > 5) {
      if (other.args.animation === 'corkscrew') {
        other.args.animation = 'walking';
      }
      return;
    }
    other.args.groundAngle = 0;
    const xDist = (other.x - this.x) / this.args.width;
    const shiftFactor = 1 + Math.cos(-Math.PI + xDist * Math.PI * 2);
    const yShift = shiftFactor * this.args.height * 0.5;
    other.args.y = this.y - yShift + -1;
    other.args.ySpeed = 0;
    other.args.xSpeed = Math.max(Math.abs(other.args.xSpeed) || other.args.width) * Math.sign(other.args.xSpeed);
    other.args.mode = 0;
    other.args.ignore = -2;
    other.args.cameraMode = 'corkscrew';
    other.args.xSpeed += Math.sign(other.args.xSpeed) * (-1 + Math.abs(shiftFactor)) * 0.25;
    other.args.gSpeed = other.args.xSpeed;
    if (xDist > 1 || xDist < 0) {
      other.args.animation = 'walking';
      // other.args.falling = false;
      other.args.y = this.y - 1;
      other.args.corkscrew = 0;
    } else {
      other.args.animation = 'corkscrew';
      other.args.corkscrew = xDist;
    }
  }
  collideA(other) {
    return false;
  }
  get solid() {
    return false;
  }
  get isEffect() {
    return true;
  }
}
exports.CorkscrewRegion = CorkscrewRegion;
});

;require.register("region/DarkRegion.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DarkRegion = void 0;
var _Region = require("./Region");
var _Tag = require("curvature/base/Tag");
var _View = require("curvature/base/View");
class DarkRegion extends _Region.Region {
  constructor() {
    super(...arguments);
    this.args.type = 'region region-shade region-dark';
    this.paths = new Map();
    this.actors = new Set();
  }
  onRendered(event) {
    super.onRendered(event);
    this.basePath = `M 0 0
    					L 0 ${32 * 17 + 1}
    					L ${32 * 17} ${32 * 17 + 1}
    					L ${32 * 17} 0
    					Z`;
    this.mask = _View.View.from(`<svg style = "position:absolute; width: calc(100vw + 2px); height: calc(100vh + 2px); top: -1px; left: -1px">
			<defs>
				<clipPath id = "mask-${this.args.id}" clipPathUnits="userSpaceOnUse">
					<path data-lights />
				</clipPath>
			</defs>
		<svg>`);
    this.mask.render(this.tags.sprite);
    this.path = this.mask.findTag('path[data-lights]');
    this.path.attr({
      d: `${this.basePath} ${this.lightPath}`
    });
    this.tags.sprite.style({
      '--maskImage': `url(#mask-${this.args.id})`
    });
  }
  update() {
    super.update();
    if (!this.filterWrapper && this.tags.sprite) {
      this.filterWrapper = new _Tag.Tag('<div class = "region-filter-wrapper">');
      this.colorWrapper = new _Tag.Tag('<div class = "region-color-wrapper">');
      this.filter = new _Tag.Tag('<div class = "region-filter">');
      this.color = new _Tag.Tag('<div class = "region-color">');
      this.filterWrapper.appendChild(this.filter.node);
      this.colorWrapper.appendChild(this.color.node);
      this.tags.sprite.appendChild(this.filterWrapper.node);
      this.tags.sprite.appendChild(this.colorWrapper.node);
    }
  }
  updateEnd() {
    super.updateEnd();
    for (const actor of this.actors) {
      const lightSize = 128;
      const topBoundry = -this.viewport.args.y - (this.args.y - this.args.height);
      const x = actor.x + actor.viewport.args.x;
      const y = actor.y + actor.viewport.args.y - actor.args.height * 0.5 + (topBoundry < 0 ? topBoundry : 0);
      if (!actor.args.polygon) {
        continue;
        this.paths.set(actor, `M ${x} ${y + lightSize * 0.5}
					 A ${lightSize * 0.5} ${lightSize * 0.5}, 0, 1 1, ${x} ${y + -lightSize * 0.5}
					 A ${lightSize * 0.5} ${lightSize * 0.5}, 0, 0 1, ${x} ${y + lightSize * 0.5}
	        		 Z`);
      } else {
        const polygon = Object.assign([], actor.args.polygon);
        const first = polygon.shift();
        const polyPath = polygon.map(p => `L ${x + p.x} ${y + p.y}`).join(' ');
        this.paths.set(actor, `M ${x + first.x} ${y + first.y}
					 ${polyPath}
					 Z`);
      }
    }
    this.path.attr({
      d: this.basePath + ' ' + [...this.paths.values()].join(' ')
    });
    this.actors.clear();
    this.paths.clear();
  }
  updateActor(actor) {
    if (!actor.controllable) {
      // return;
    }
    this.actors.add(actor);
  }
  get solid() {
    return false;
  }
  get isEffect() {
    return true;
  }
}
exports.DarkRegion = DarkRegion;
});

;require.register("region/DebrisRegion.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DebrisRegion = void 0;
var _Region = require("./Region");
var _Tag = require("curvature/base/Tag");
var _View = require("curvature/base/View");
class DebrisRegion extends _Region.Region {
  constructor() {
    var _this$args$active;
    super(...arguments);
    this.args.type = 'region region-shade region-debris';
    this.args.active = (_this$args$active = this.args.active) !== null && _this$args$active !== void 0 ? _this$args$active : true;
  }
  update() {
    if (this.others.switch) {
      this.args.active = this.others.switch.args.active;
    }

    // this.args.hidden = !this.args.active;

    super.update();
    if (!this.filterWrapper && this.tags.sprite) {
      this.filterWrapper = new _Tag.Tag('<div class = "region-filter-wrapper">');
      this.colorWrapper = new _Tag.Tag('<div class = "region-color-wrapper">');
      this.filter = new _Tag.Tag('<div class = "region-filter">');
      this.color = new _Tag.Tag('<div class = "region-color">');
      this.filterWrapper.appendChild(this.filter.node);
      this.colorWrapper.appendChild(this.color.node);
      this.tags.sprite.appendChild(this.filterWrapper.node);
      this.tags.sprite.appendChild(this.colorWrapper.node);
    }
  }
  get solid() {
    return false;
  }
  get isEffect() {
    return true;
  }
}
exports.DebrisRegion = DebrisRegion;
});

;require.register("region/DropVehicleRegion.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DropVehicleRegion = void 0;
var _Region = require("./Region");
var _ObjectPalette = require("../ObjectPalette");
class DropVehicleRegion extends _Region.Region {
  constructor() {
    super(...arguments);
    this.args.type = 'region drop-vehicle';
  }
  updateActor(other) {
    if (!other.controllable) {
      return;
    }
    if (other.isVehicle) {
      return;
    }
    if (!other.args.standingOn) {
      return;
    }
    other.args.standingOn = null;
  }
}
exports.DropVehicleRegion = DropVehicleRegion;
});

;require.register("region/ExitRegion.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ExitRegion = void 0;
var _Region = require("./Region");
class ExitRegion extends _Region.Region {
  constructor() {
    super(...arguments);
    this.args.type = 'region exit';
    this.args.hidden = true;
    this.triggered = false;
  }
  updateActor(other) {
    if (!this.viewport) {
      return;
    }

    // if(this.args.signpost)
    // {
    // 	const signpost = this.viewport.actorsById[ this.args.signpost ];

    // 	if(signpost.args.activeTime < 30)
    // 	{
    // 		other.args.bossMode = true;

    // 		return;
    // 	}
    // }

    if (this.others.boss && this.others.boss.args.hitPoints > 0) {
      return;
    }
    if (other.occupant) {
      other = other.occupant;
    }
    if (!other.controllable) {
      return;
    }
    const viewport = this.viewport;

    // viewport.args.fade = true;

    viewport.clearCheckpoints();
    if (this.triggered) {
      return;
    }
    viewport.onFrameOut(30, () => {
      if (this.triggered) {
        return;
      }

      // viewport.actors.remove(this);

      this.triggered = true;

      // viewport.finishLevel();

      const tally = this.others.signpost && this.others.signpost.tally;
      if (viewport.replay) {
        const t = tally || viewport.clearAct(`${other.args.name} GOT THROUGH\n${viewport.args.actName}`, false);
        t.addEventListener('done', event => viewport.quit(2));
      } else if (this.args.nextStage) {
        const t = tally || viewport.clearAct(`${other.args.name} GOT THROUGH\n${viewport.args.actName}`, false);
        t.addEventListener('done', event => viewport.quit(2, () => viewport.loadMap({
          mapUrl: '/map/' + this.args.nextStage
        })));
      } else {
        const t = tally || viewport.clearAct(`${other.args.name} GOT THROUGH\n${viewport.args.actName}`, false);
        t.addEventListener('done', event => viewport.quit(2));
      }
    });
  }
  get solid() {
    return false;
  }
  get isEffect() {
    return true;
  }
}
exports.ExitRegion = ExitRegion;
});

;require.register("region/ExplodingRegion.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ExplodingRegion = void 0;
var _Region = require("./Region");
var _Sfx = require("../audio/Sfx");
var _Tag = require("curvature/base/Tag");
class ExplodingRegion extends _Region.Region {
  constructor() {
    super(...arguments);
    this.args.type = 'region region-exploding';
  }
  updateActor(actor) {
    if (!this.args.active) {
      return;
    }
    if (actor.controllable) {
      return;
    }
    if (actor.break) {
      actor.break();
      if (!this.viewport.actorIsOnScreen(actor)) {
        this.viewport.actors.remove(actor);
      }
    }
    if (actor.pop) {
      actor.pop();
      if (!this.viewport.actorIsOnScreen(actor)) {
        this.viewport.actors.remove(actor);
      }
    }
  }
  update() {
    super.update();
    const viewport = this.viewport;
    if (!viewport) {
      return;
    }
    if (!this.args.active) {
      if (this.args.target && viewport.actorsById[this.args.target]) {
        const target = viewport.actorsById[this.args.target];
        viewport.auras.delete(target);
      }
      viewport.auras.delete(this);
      return;
    }
    if (!viewport) {
      return;
    }
    if (Math.random() > 0.85) {
      _Sfx.Sfx.play('BOSS_DAMAGED');
    }
    for (let i = 0; i < 1; i++) {
      const explosionTag = document.createElement('div');
      explosionTag.classList.add('particle-explosion');
      const explosion = new _Tag.Tag(explosionTag);
      const xOff = this.args.width * Math.random();
      const yOff = this.args.height * Math.random();
      const left = Math.max(this.x, -this.viewport.args.x);
      const bottom = Math.max(this.y, -this.viewport.args.y);
      const right = Math.min(this.x + this.args.width, -this.viewport.args.x + this.viewport.args.width);
      const top = Math.min(this.y - this.args.height, -this.viewport.args.y - this.viewport.args.height / 2);
      const xRange = right - left;
      const yRange = bottom - top;
      explosion.style({
        '--x': left + xRange * Math.random(),
        '--y': top + yRange * Math.random()
      });
      viewport.particles.add(explosion);
      setTimeout(() => viewport.particles.remove(explosion), 512);
    }
  }
  activate() {
    _Sfx.Sfx.play('BOSS_DAMAGED');
    this.args.active = true;
    this.viewport.onFrameOut(250, () => this.args.active = false);
    if (this.args.target && this.viewport.actorsById[this.args.target]) {
      this.viewport.onFrameOut(60, () => {
        const target = this.viewport.actorsById[this.args.target];
        this.viewport.auras.add(target);
        target.activate(other, this);
      });
    }
  }
}
exports.ExplodingRegion = ExplodingRegion;
});

;require.register("region/FgShadeRegion.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FgShadeRegion = void 0;
var _ShadeRegion = require("./ShadeRegion");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class FgShadeRegion extends _ShadeRegion.ShadeRegion {
  constructor() {
    super(...arguments);
    _defineProperty(this, "currentFilter", -1);
    _defineProperty(this, "filters", ['studio', 'western', 'heat', 'hydro', 'lava', 'frost', 'eight-bit', 'corruption', 'black-hole', 'normal']);
    this.args.type = 'fg-region-shade region region-shade';
  }
}
exports.FgShadeRegion = FgShadeRegion;
});

;require.register("region/ForceRegion.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ForceRegion = void 0;
var _Region = require("./Region");
class ForceRegion extends _Region.Region {
  constructor(args, parent) {
    var _this$args$xForce, _this$args$yForce, _this$args$active;
    super(args, parent);
    this.args.type = 'region region-force';
    this.args.xForce = (_this$args$xForce = this.args.xForce) !== null && _this$args$xForce !== void 0 ? _this$args$xForce : 0;
    this.args.yForce = (_this$args$yForce = this.args.yForce) !== null && _this$args$yForce !== void 0 ? _this$args$yForce : -5;
    this.args.active = (_this$args$active = this.args.active) !== null && _this$args$active !== void 0 ? _this$args$active : 1;
  }
  update() {
    if (!this.originalHeight) {
      this.originalHeight = this.args.height;
    }
    if (this.switch) {
      this.args.active = this.switch.args.active > 0;
    }
    super.update();
  }
  onAttach() {
    if (!this.viewport || !this.args.switch) {
      return;
    }
  }
  wakeUp() {
    this.switch = this.viewport.actorsById[this.args.switch];
  }
  activate() {
    this.args.active = 1;
  }
  updateActor(other) {
    if (other instanceof _Region.Region || other.args.static) {
      return;
    }
    if (this.args.active <= 0) {
      return;
    }
    if (other.args.falling) {
      const xProjected = other.args.xSpeed + Number(this.args.xForce);
      if (Math.abs(xProjected) > Math.abs(this.args.xForceMax) && Math.sign(this.args.xForceMax) === Math.sign(xProjected)) {
        other.args.xSpeed = this.args.xForceMax;
      } else {
        other.args.xSpeed = xProjected;
      }
      const yProjected = other.args.ySpeed + Number(this.args.yForce);
      if (Math.abs(yProjected) > Math.abs(this.args.yForceMax) && Math.sign(this.args.yForceMax) === Math.sign(yProjected)) {
        if (Math.abs(yProjected) >= other.args.gravity || other.args.falling) {
          other.args.ySpeed = this.args.yForceMax;
        }
      } else {
        other.args.ySpeed = yProjected;
      }

      // other.args.animation = 'springdash';
      other.args.groundAngle = 0;
      return;
    }
    let projected;
    switch (other.args.mode) {
      case 0:
        projected = other.args.gSpeed + this.args.xForce;
        if (Math.abs(projected) > Math.abs(this.args.xForceMax) && Math.sign(this.args.xForceMax) === Math.sign(projected)) {
          other.args.gSpeed = this.args.xForceMax;
        } else {
          other.args.gSpeed = projected;
        }
        break;
      case 1:
        other.args.gSpeed += Math.sign(this.args.yForce);
        break;
      case 2:
        other.args.gSpeed -= Math.sign(this.args.xForce);
        break;
      case 3:
        other.args.gSpeed -= Math.sign(this.args.yForce);
        break;
    }
  }
  get solid() {
    return false;
  }
  get isEffect() {
    return true;
  }
}
exports.ForceRegion = ForceRegion;
});

;require.register("region/FrictionRegion.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FrictionRegion = void 0;
var _Region = require("./Region");
var _Tag = require("curvature/base/Tag");
class FrictionRegion extends _Region.Region {
  constructor() {
    var _args$friction;
    let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let parent = arguments.length > 1 ? arguments[1] : undefined;
    super(args, parent);
    this.args.type = 'region region-friction';
    this.args.friction = (_args$friction = args.friction) !== null && _args$friction !== void 0 ? _args$friction : 1;
  }
  get solid() {
    return false;
  }
  get isEffect() {
    return true;
  }
}
exports.FrictionRegion = FrictionRegion;
});

;require.register("region/GrindingRegion.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GrindingRegion = void 0;
var _Region = require("./Region");
var _Tag = require("curvature/base/Tag");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class GrindingRegion extends _Region.Region {
  constructor() {
    super(...arguments);
    _defineProperty(this, "grind", true);
    this.args.type = 'region grinding';
    this.args.hidden = true;
  }
  update() {
    if (!this.originalHeight) {
      this.originalHeight = this.args.height;
    }
    super.update();
  }
  updateActor(other) {
    if (other.args.falling) {
      return;
    }
    other.args.grinding = true;
  }
  collideA(other, type) {
    super.collideA(other, type);
  }
  collideB(other, type) {
    super.collideA(other, type);
  }
  get solid() {
    return false;
  }
  get isEffect() {
    return true;
  }
}
exports.GrindingRegion = GrindingRegion;
});

;require.register("region/KillRegion.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KillRegion = void 0;
var _Region = require("./Region");
class KillRegion extends _Region.Region {
  constructor() {
    super(...arguments);
    this.args.type = 'region kill';
    this.args.hidden = true;
  }
  updateActor(other) {
    if (other.controllable) {
      other.die();
    }
  }
}
exports.KillRegion = KillRegion;
});

;require.register("region/LavaRegion.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LavaRegion = void 0;
var _Region = require("./Region");
var _Ring = require("../actor/Ring");
var _MarbleBlock = require("../actor/MarbleBlock");
var _Tag = require("curvature/base/Tag");
var _Bindable = require("curvature/base/Bindable");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class LavaRegion extends _Region.Region {
  constructor() {
    super(...arguments);
    _defineProperty(this, "isWater", true);
    this.args.type = 'region region-lava';
    this.args.gravity = 0.5;
    this.args.drag = 0.85;
    this.args.density = 15;
    this.skimSpeed = Infinity;
  }
  update() {
    if (!this.filterWrapper && this.tags.sprite) {
      this.filterWrapper = new _Tag.Tag('<div class = "region-filter-wrapper">');
      this.colorWrapper = new _Tag.Tag('<div class = "region-color-wrapper">');
      this.filter = new _Tag.Tag('<div class = "region-filter">');
      this.color = new _Tag.Tag('<div class = "region-color">');
      this.filterWrapper.appendChild(this.filter.node);
      this.colorWrapper.appendChild(this.color.node);
      this.tags.sprite.appendChild(this.filterWrapper.node);
      this.tags.sprite.appendChild(this.colorWrapper.node);
    }
    if (!this.originalHeight) {
      this.originalHeight = this.args.height;
    }
    super.update();
  }
  updateActor(other) {
    if (other instanceof _Ring.Ring) {
      other.args.ySpeed = -Math.abs(other.args.ySpeed || -6);
      return;
    }
    if (other.noClip) {
      return;
    }
    if (!other.controllable && !(other instanceof _Ring.Ring)) {
      return;
    }
    if (other.y < this.y + -this.args.height + 8) {
      return;
    }
    if (other.args.ySpeed < 0 || other.args.ignore) {
      return;
    }
    if (other.args.mercy || other.immune(this, 'fire')) {
      return;
    }
    other.damage(this, 'fire');
  }
  collideA(other, type) {
    if (other.noClip) {
      return;
    }
    if (other instanceof _MarbleBlock.MarbleBlock) {
      return false;
    }
    if (other.args.standingOn && other.args.standingOn !== _Bindable.Bindable.make(this)) {
      return false;
    }
    super.collideA(other, type);
    if (other.args.mercy || other.immune(this, 'fire')) {
      return true;
    }

    // // other.args.ySpeed = Math.min(-8, -(other.args.ySpeed || other.ySpeedLast) * 1.1);
    // // other.args.xSpeed = (other.args.xSpeed || other.xSpeedLast || other.args.gSpeed) * -1.1;
    // // other.args.falling = true;

    // // other.args.y = this.y + -this.args.height + -32;

    other.damage(this, 'fire');
    return true;
  }
  get solid() {
    return true;
  }
  get isEffect() {
    return true;
  }
}
exports.LavaRegion = LavaRegion;
});

;require.register("region/LoadingRegion.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LoadingRegion = void 0;
var _Region = require("./Region");
class LoadingRegion extends _Region.Region {
  constructor() {
    var _this$args$xOffset;
    super(...arguments);
    this.args.hidden = true;
    this.loading = this.loaded = false;
    this.args.xOffset = (_this$args$xOffset = this.args.xOffset) !== null && _this$args$xOffset !== void 0 ? _this$args$xOffset : 0;
  }
  updateActor(other) {
    if (this.others.signpost && !this.others.signpost.args.active) {
      if (this.others.signpostAlt && !this.others.signpostAlt.args.active) {
        return;
      }
    }
    if (!other.controllable) {
      return;
    }
    if (this.loaded || this.loading) {
      return;
    }
    if (!this.loading) {
      this.loading = true;
    }
  }
  updateEnd() {
    super.updateStart();
    if (this.loaded || !this.loading) {
      return;
    }
    const viewport = this.viewport;
    const tileMap = viewport.tileMap;
    const width = tileMap.mapData.width;
    const height = tileMap.mapData.height;
    const xAppend = this.args.x / 32 + this.args.xOffset;
    const yAppend = 0;

    // tileMap.resize(width + 9, height);

    if (this.others.signpost && this.others.signpost.willActivate) {
      viewport.args.frozen = 30;
      viewport.appendMap(this.args.map, xAppend, yAppend);
      // this.others.signpost.waitFor =
      this.loaded = true;
    } else if (this.others.signpostAlt && this.others.signpostAlt.willActivate) {
      viewport.args.frozen = 30;
      viewport.appendMap(this.args.map, xAppend, yAppend);
      // this.others.signpost.waitFor =
      this.loaded = true;
    }

    // viewport.args.zonecard.replay({});

    // this.loaded = true;
  }

  get solid() {
    return false;
  }
  get isEffect() {
    return true;
  }
}
exports.LoadingRegion = LoadingRegion;
});

;require.register("region/PerspectiveRegion.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PerspectiveRegion = void 0;
var _Region = require("./Region");
var _Tag = require("curvature/base/Tag");
class PerspectiveRegion extends _Region.Region {
  constructor(args, parent) {
    var _this$args$destroyTru, _this$args$maxSpeed, _this$args$minSpeed, _this$args$canJump;
    super(args, parent);
    this.args.sticky = true;
    this.args.type = 'region rolling';
    this.args.destroyTruck = (_this$args$destroyTru = this.args.destroyTruck) !== null && _this$args$destroyTru !== void 0 ? _this$args$destroyTru : false;
    this.args.maxSpeed = (_this$args$maxSpeed = this.args.maxSpeed) !== null && _this$args$maxSpeed !== void 0 ? _this$args$maxSpeed : -1;
    this.args.minSpeed = (_this$args$minSpeed = this.args.minSpeed) !== null && _this$args$minSpeed !== void 0 ? _this$args$minSpeed : -1;
    this.args.canJump = (_this$args$canJump = this.args.canJump) !== null && _this$args$canJump !== void 0 ? _this$args$canJump : false;
    this.args.hidden = true;
    this.args.perspective = true;
    this.args.shift = this.args.shift || 600;
    this.args.xPerspective = 0;
  }
  update() {
    if (!this.originalHeight) {
      this.originalHeight = this.args.height;
    }
    super.update();
  }
  updateActor(other) {
    if (other !== this.viewport.controlActor) {
      return;
    }
    let i = (Math.abs(other.realAngle) + -Math.PI) / (Math.PI * 0.5);
    i = -1 + Math.abs(i);
    if (i < 0) {
      i++;
      i = 1 - i;
    }
    i = 1 - i;
    this.args.xPerspective = this.args.shift * i;
    this.viewport.args.xPerspective = this.viewport.args.xPerspective || 0;
    const diff = this.args.xPerspective - this.viewport.args.xPerspective;
    const step = 24;
    this.viewport.args.xPerspective += Math.sign(diff) * step;
    if (Math.abs(diff) < step) {
      this.viewport.args.xPerspective = this.args.xPerspective;
    }
  }
  get solid() {
    return false;
  }
  get isEffect() {
    return true;
  }
}
exports.PerspectiveRegion = PerspectiveRegion;
});

;require.register("region/PhazonRegion.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PhazonRegion = void 0;
var _Region = require("./Region");
var _Ring = require("../actor/Ring");
var _MarbleBlock = require("../actor/MarbleBlock");
var _Tag = require("curvature/base/Tag");
var _Bindable = require("curvature/base/Bindable");
var _LavaBall = require("../actor/LavaBall");
var _Sfx = require("../audio/Sfx");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class PhazonRegion extends _Region.Region {
  constructor() {
    super(...arguments);
    _defineProperty(this, "isWater", true);
    this.args.type = 'region region-phazon';

    // this.entryParticle = '<div class = "particle-splash">';

    this.args.gravity = 0.5;
    this.args.drag = 0.85;
    this.args.density = 15;
    this.skimSpeed = Infinity;
    this.sapped = new Set();
    this.timings = new WeakMap();
    this.onRemove(() => this.sapped.clear());
  }
  update() {
    this.sapped.clear();
    if (!this.filterWrapper && this.tags.sprite) {
      this.filterWrapper = new _Tag.Tag('<div class = "region-filter-wrapper">');
      this.colorWrapper = new _Tag.Tag('<div class = "region-color-wrapper">');
      this.filter = new _Tag.Tag('<div class = "region-filter">');
      this.color = new _Tag.Tag('<div class = "region-color">');
      this.filterWrapper.appendChild(this.filter.node);
      this.colorWrapper.appendChild(this.color.node);
      this.tags.sprite.appendChild(this.filterWrapper.node);
      this.tags.sprite.appendChild(this.colorWrapper.node);
    }
    if (!this.originalHeight) {
      this.originalHeight = this.args.height;
    }
    super.update();
  }
  updateActor(other) {
    if (other instanceof _Ring.Ring) {
      other.args.ySpeed = -Math.abs(other.args.ySpeed || -6);
      return;
    }
    if (other.noClip) {
      return;
    }
    if (!other.controllable && !(other instanceof _Ring.Ring)) {
      return;
    }
    if (other.y < this.y + -this.args.height + 8) {
      return;
    }
    if (other.args.ySpeed < 0 || other.args.ignore) {
      return;
    }
    if (other.args.mercy || other.immune(this, 'fire')) {
      return;
    }
  }
  collideA(other, type) {
    if (other.noClip) {
      return;
    }
    if (other instanceof _MarbleBlock.MarbleBlock || other instanceof _LavaBall.LavaBall) {
      return false;
    }
    if (other.args.standingOn && other.args.standingOn !== _Bindable.Bindable.make(this)) {
      return false;
    }
    other.args.y = Math.round(other.args.y);
    super.collideA(other, type);

    // if(!other.controllable && !other.pushed)
    // {
    // 	return false;
    // }

    if (other.args.mercy || other.immune(this, 'phazon')) {
      return true;
    }
    if (other.controllable && !this.sapped.has(other)) {
      let time = 0;
      if (!this.timings.has(other)) {
        this.timings.set(other, time);
      }
      time = this.timings.get(other);
      time++;
      this.timings.set(other, time);
      if (time % 9 === 0 && (!other.args.float || other.fallTime < 20)) {
        other.sap();
      }
    }
    this.sapped.add(other);
    return true;
  }
  get solid() {
    return true;
  }
  get isEffect() {
    return true;
  }
}
exports.PhazonRegion = PhazonRegion;
});

;require.register("region/RainRegion.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RainRegion = void 0;
var _Region = require("./Region");
var _Tag = require("curvature/base/Tag");
var _View = require("curvature/base/View");
class RainRegion extends _Region.Region {
  constructor() {
    super(...arguments);
    this.args.type = 'region region-shade region-rain';
  }
  update() {
    super.update();
    if (!this.filterWrapper && this.tags.sprite) {
      this.filterWrapper = new _Tag.Tag('<div class = "region-filter-wrapper">');
      this.colorWrapper = new _Tag.Tag('<div class = "region-color-wrapper">');
      this.filter = new _Tag.Tag('<div class = "region-filter">');
      this.color = new _Tag.Tag('<div class = "region-color">');
      this.filterWrapper.appendChild(this.filter.node);
      this.colorWrapper.appendChild(this.color.node);
      this.tags.sprite.appendChild(this.filterWrapper.node);
      this.tags.sprite.appendChild(this.colorWrapper.node);
    }
  }
  get solid() {
    return false;
  }
  get isEffect() {
    return true;
  }
}
exports.RainRegion = RainRegion;
});

;require.register("region/Region.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Region = void 0;
var _Tag = require("curvature/base/Tag");
var _PointActor = require("../actor/PointActor");
class Region extends _PointActor.PointActor {
  static fromDef(objDef) {
    const obj = super.fromDef(objDef);
    obj.args.width = objDef.width;
    obj.args.height = objDef.height;
    obj.args.x = obj.originalX = -0 + Math.floor(objDef.x);
    obj.args.y = obj.originalY = -0 + Math.floor(objDef.y);
    obj.args.static = true;
    return obj;
  }
  constructor() {
    super(...arguments);
    this.args.type = 'region';
    this.args.width = this.args.width || 32;
    this.args.height = this.args.height || 32;
    this.args.density = 0;
    this.args.gravity = 1;
    this.args.drag = 1;
    this.skimSpeed = Infinity;
    this.args.float = -1;
    this.isRegion = true;
    this.skimmers = new WeakSet();
  }
  onRendered() {
    this.mainElem = new _Tag.Tag(this.tags.sprite.parentNode);
    super.onRendered();
  }
  skim(actor) {
    this.skimmers.add(actor);
  }
  updateStart() {
    this.skimmers = new WeakSet();
    super.updateStart();
  }
  update() {
    if (!this.viewport) {
      return;
    }
    if (!this.focus && this.args.focus) {
      this.focus = this.viewport.actorsById[this.args.focus];
    }
    super.update();
    if (this.viewport.args.frameId % this.viewport.settings.frameSkip === 0) {
      var _this$args$color;
      const topBoundry = -this.viewport.args.y - (this.args.y - this.args.height);
      const leftBoundry = -this.viewport.args.x - this.args.x;
      this.mainElem && this.mainElem.style({
        '--viewportWidth': this.viewport.args.width + 'px',
        '--viewportHeight': this.viewport.args.height + 'px',
        '--leftBoundry': leftBoundry + 'px',
        '--topBoundry': topBoundry + 'px',
        '--vpX': this.viewport.args.x + 'px',
        '--vpY': this.viewport.args.y + 'px',
        '--color': (_this$args$color = this.args.color) !== null && _this$args$color !== void 0 ? _this$args$color : 'rgba(0,128,255,0.33)'
      });
    }
  }
  updateActor(other) {}
  get solid() {
    return false;
  }
  get isEffect() {
    return true;
  }
  enter(other) {}
  leave(other) {}
}
exports.Region = Region;
});

;require.register("region/RollingRegion.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RollingRegion = void 0;
var _Region = require("./Region");
var _Tag = require("curvature/base/Tag");
class RollingRegion extends _Region.Region {
  constructor(args, parent) {
    var _this$args$destroyTru, _this$args$maxSpeed, _this$args$minSpeed, _this$args$canJump;
    super(args, parent);
    this.args.sticky = true;
    this.args.type = 'region rolling';
    this.args.destroyTruck = (_this$args$destroyTru = this.args.destroyTruck) !== null && _this$args$destroyTru !== void 0 ? _this$args$destroyTru : false;
    this.args.maxSpeed = (_this$args$maxSpeed = this.args.maxSpeed) !== null && _this$args$maxSpeed !== void 0 ? _this$args$maxSpeed : -1;
    this.args.minSpeed = (_this$args$minSpeed = this.args.minSpeed) !== null && _this$args$minSpeed !== void 0 ? _this$args$minSpeed : -1;
    this.args.canJump = (_this$args$canJump = this.args.canJump) !== null && _this$args$canJump !== void 0 ? _this$args$canJump : false;
    this.args.hidden = true;
  }
  update() {
    if (!this.originalHeight) {
      this.originalHeight = this.args.height;
    }
    super.update();
  }
  updateActor(other) {
    if (!other.controllable) {
      return;
    }
    if (other.args.falling) {
      return;
    }
    other.willStick = false;
    const gSpeedLast = other.args.modeTime > 5 ? other.gSpeedLast : 0;
    if (Math.abs(other.args.gSpeed) < this.args.minSpeed) {
      other.args.gSpeed = this.args.minSpeed * Math.sign(other.args.gSpeed || gSpeedLast || other.args.direction);
    }
    if (this.args.maxSpeed > 0 && Math.abs(other.args.gSpeed) > this.args.maxSpeed) {
      other.args.gSpeed = this.args.maxSpeed * Math.sign(other.args.gSpeed || gSpeedLast || other.args.direction);
      if (other.args.mode === 1) {
        other.args.gSpeed = other.ySpeedLast;
      }
      if (other.args.mode === 3) {
        other.args.gSpeed = -other.ySpeedLast;
      }
    }
    if (!other.args.gSpeed) {
      other.args.gSpeed = 2 * Math.sign(gSpeedLast || other.args.direction);
    }
    if (!other.args.rolling) {
      other.args.rolling = true;
    }
    if (other.willJump) {
      if (!this.args.canJump) {
        other.willJump = false;
      }
    }
  }
  get solid() {
    return false;
  }
  get isEffect() {
    return true;
  }
}
exports.RollingRegion = RollingRegion;
});

;require.register("region/ShadeRegion.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ShadeRegion = void 0;
var _CharacterString = require("../ui/CharacterString");
var _Cylinder = require("../effects/Cylinder");
var _Pinch = require("../effects/Pinch");
var _Region = require("./Region");
var _Tag = require("curvature/base/Tag");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class ShadeRegion extends _Region.Region {
  constructor() {
    super(...arguments);
    _defineProperty(this, "currentFilter", -1);
    _defineProperty(this, "filters", ['western', 'heat', 'hydro', 'lava', 'black-hole', 'normal']);
    this.args.type = 'region region-shade';
  }
  onRendered() {
    super.onRendered();
    this.actorFilterWrapper = new _Tag.Tag('<div class = "region-filter-wrapper">');
    this.actorColorWrapper = new _Tag.Tag('<div class = "region-color-wrapper">');
    this.filterWrapper = new _Tag.Tag('<div class = "region-filter-wrapper">');
    this.colorWrapper = new _Tag.Tag('<div class = "region-color-wrapper">');
    this.actorFilter = new _Tag.Tag('<div class = "region-filter">');
    this.actorColor = new _Tag.Tag('<div class = "region-color">');
    this.filter = new _Tag.Tag('<div class = "region-filter">');
    this.color = new _Tag.Tag('<div class = "region-color">');
    this.filterWrapper.appendChild(this.filter.node);
    this.colorWrapper.appendChild(this.color.node);

    // this.actorFilterWrapper.appendChild(this.actorFilter.node);
    // this.actorColorWrapper.appendChild(this.actorColor.node);

    // this.actorLayer = new Tag('<div class = "actor-layer">');

    // this.actorLayer.appendChild(this.actorFilterWrapper.node);
    // this.actorLayer.appendChild(this.actorColorWrapper.node);

    // this.mainElem.appendChild(this.actorLayer.node);

    this.tags.sprite.appendChild(this.filterWrapper.node);
    this.tags.sprite.appendChild(this.colorWrapper.node);
    this.text = new _CharacterString.CharacterString({
      value: ''
    });
    this.text.render(this.tags.sprite);
    this.cylinder = new _Cylinder.Cylinder({
      id: 'shade-cylinder',
      width: this.args.width,
      height: this.args.height
    });
    this.cylinder.render(this.tags.sprite);
    this.pinch = new _Pinch.Pinch({
      id: 'shade-pinch',
      width: this.args.width,
      height: this.args.height,
      scale: 150
    });
    this.pinch.render(this.tags.sprite);

    // this.args.bindTo('scale', v => {
    // 	this.pinch.args.scale = v;
    // 	this.cylinder.args.scale = v;
    // });

    if (this.args.filter) {
      this.filters = [this.args.filter];
    }
    this.rotateFilter();
  }
  update() {
    super.update();
    this.args.scale = 175 - Math.abs(Math.sin(Date.now() / 200) * 25);
    if (!this.switch && this.args.switch) {
      this.switch = this.viewport.actorsById[this.args.switch];
      if (this.switch) {
        this.switch.args.bindTo('active', v => {
          if (v) {
            this.rotateFilter();
          }
        });
      }
    }
  }
  rotateFilter() {
    if (this.mainElem && this.args.filter) {
      this.mainElem.classList.remove(this.args.filter);
    }
    if (this.mainElem) {
      this.args.filter = this.filters[this.currentFilter++];
      if (this.currentFilter >= this.filters.length) {
        this.currentFilter = 0;
      }
      this.args.filter && this.mainElem.classList.add(this.args.filter);
      if (this.args.filter) {
        this.text.remove();
        this.text = new _CharacterString.CharacterString({
          value: `${this.currentFilter}: ${this.args.filter}`
        });
        this.text.render(this.tags.sprite);
      }
    }
  }
  get solid() {
    return false;
  }
  get isEffect() {
    return true;
  }
}
exports.ShadeRegion = ShadeRegion;
});

;require.register("region/SlidingRegion.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SlidingRegion = void 0;
var _Region = require("./Region");
var _Tag = require("curvature/base/Tag");
class SlidingRegion extends _Region.Region {
  constructor(args, parent) {
    var _this$args$canJump, _this$args$toSpeed;
    super(args, parent);
    this.args.sticky = true;
    this.args.hidden = true;
    this.args.canJump = (_this$args$canJump = this.args.canJump) !== null && _this$args$canJump !== void 0 ? _this$args$canJump : true;
    this.args.type = 'region sliding';
    this.args.toSpeed = (_this$args$toSpeed = this.args.toSpeed) !== null && _this$args$toSpeed !== void 0 ? _this$args$toSpeed : 8;
  }
  updateActor(other) {
    if (other.args.static) {
      return;
    }
    if (other.args.falling) {
      return;
    }
    if (!other.controllable) {
      return;
    }
    other.willStick = false;
    if (Math.abs(this.args.toSpeed - other.args.gSpeed) > 1) {
      other.args.gSpeed += Math.sign(this.args.toSpeed - other.args.gSpeed);
    } else {
      other.args.gSpeed = this.args.toSpeed;
    }
    other.args.rolling = false;
    other.args.sliding = true;
    if (other.willJump) {
      if (!this.args.canJump) {
        other.willJump = false;
      }
    }
  }
  get solid() {
    return false;
  }
  get isEffect() {
    return true;
  }
}
exports.SlidingRegion = SlidingRegion;
});

;require.register("region/SwitchRegion.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SwitchRegion = void 0;
var _Region = require("./Region");
var _Rocket = require("../actor/Rocket");
class SwitchRegion extends _Region.Region {
  constructor() {
    var _args$latch;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    super(...args);
    this.args.type = 'region region-switch';
    this.args.latch = (_args$latch = args.latch) !== null && _args$latch !== void 0 ? _args$latch : this.args.latch;
    this.args.hidden = true;
    this.activated = false;
  }
  onAttach(event) {
    event && event.preventDefault();
    return false;
  }
  activate(actor) {
    if (!this.viewport) {
      return;
    }
    if (this.args.latch && this.activated) {
      return;
    }
    if (this.args.latch) {
      this.args.active = this.activated = true;
    }
    const target = this.viewport.actorsById[this.args.target];
    if (!target || !target.activate) {
      return;
    }
    target.activate(actor, this);
  }
  updateActor(actor) {
    if (this.args.rocket) {
      if (actor instanceof _Rocket.Rocket) {
        const target = this.viewport.actorsById[this.args.target];
        if (!target || !target.activate) {
          return;
        }
        this.viewport.onFrameOut(this.args.delay || 1, () => target.activate(actor, this));
        actor.explode();
      }
      return;
    }
    if (actor.isVehicle && actor.occupant) {
      actor = actor.occupant;
    }
    if (!actor.controllable) {
      return;
    }

    // const target = this.viewport.actorsById[ this.args.target ];

    // if(!target || !target.activate)
    // {
    // 	return;
    // }

    this.viewport.onFrameOut(this.args.delay || 1, () => this.activate(actor));
  }
}
exports.SwitchRegion = SwitchRegion;
});

;require.register("region/ToxicRegion.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ToxicRegion = void 0;
var _Region = require("./Region");
var _Ring = require("../actor/Ring");
var _MarbleBlock = require("../actor/MarbleBlock");
var _Tag = require("curvature/base/Tag");
var _Bindable = require("curvature/base/Bindable");
var _Sfx = require("../audio/Sfx");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class ToxicRegion extends _Region.Region {
  constructor() {
    super(...arguments);
    _defineProperty(this, "isWater", true);
    this.args.type = 'region region-toxic';

    // this.entryParticle = '<div class = "particle-splash">';

    this.args.gravity = 0.5;
    this.args.drag = 0.85;
    this.args.density = 15;
    this.skimSpeed = 0;
    this.sapped = new Set();
    this.timings = new WeakMap();
    this.onRemove(() => this.sapped.clear());
  }
  update() {
    this.sapped.clear();
    if (!this.filterWrapper && this.tags.sprite) {
      this.filterWrapper = new _Tag.Tag('<div class = "region-filter-wrapper">');
      this.colorWrapper = new _Tag.Tag('<div class = "region-color-wrapper">');
      this.filter = new _Tag.Tag('<div class = "region-filter">');
      this.color = new _Tag.Tag('<div class = "region-color">');
      this.filterWrapper.appendChild(this.filter.node);
      this.colorWrapper.appendChild(this.color.node);
      this.tags.sprite.appendChild(this.filterWrapper.node);
      this.tags.sprite.appendChild(this.colorWrapper.node);
    }
    if (!this.originalHeight) {
      this.originalHeight = this.args.height;
    }
    super.update();
  }
  updateActor(other) {
    if (other instanceof _Ring.Ring) {
      other.args.ySpeed = -Math.abs(other.args.ySpeed || -6);
      return;
    }
    if (other.noClip) {
      return;
    }
    if (!other.controllable && !(other instanceof _Ring.Ring)) {
      return;
    }
    if (other.y < this.y + -this.args.height + 8) {
      return;
    }
    if (other.args.ySpeed < 0 || other.args.ignore) {
      return;
    }
    if (other.args.mercy || other.immune(this, 'fire')) {
      return;
    }
  }
  collideA(other, type) {
    if (other.noClip) {
      return;
    }
    if (other instanceof _MarbleBlock.MarbleBlock) {
      return false;
    }
    if (other.args.standingOn && other.args.standingOn !== _Bindable.Bindable.make(this)) {
      return false;
    }
    other.args.y = Math.round(other.args.y);
    super.collideA(other, type);

    // if(!other.controllable && !other.pushed)
    // {
    // 	return false;
    // }

    if (other.args.mercy || other.immune(this, 'toxic')) {
      return true;
    }
    if (other.controllable && !this.sapped.has(other)) {
      let time = 0;
      if (!this.timings.has(other)) {
        this.timings.set(other, time);
      }
      time = this.timings.get(other);
      time++;
      this.timings.set(other, time);
      if (time % 27 === 0 && (!other.args.float || other.fallTime < 20)) {
        other.sap();
      }
    }
    this.sapped.add(other);
    return true;
  }
  get solid() {
    return true;
  }
  get isEffect() {
    return true;
  }
}
exports.ToxicRegion = ToxicRegion;
});

;require.register("region/VehicleRegion.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VehicleRegion = void 0;
var _Region = require("./Region");
var _ObjectPalette = require("../ObjectPalette");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class VehicleRegion extends _Region.Region {
  constructor() {
    super(...arguments);
    _defineProperty(this, "SpawnedFor", Symbol('SpawnedFor'));
    this.args.type = 'region vehicle';
  }
  updateActor(other) {
    if (other[this.SpawnedFor] === false) {
      return;
    }
    if (other[this.SpawnedFor]) {
      const spawned = other[this.SpawnedFor];
      spawned.args.x = other.args.x;
      spawned.args.y = other.args.y;
      spawned.args.xSpeed = other.args.xSpeed;
      spawned.args.ySpeed = other.args.ySpeed;
      spawned.args.gSpeed = other.args.gSpeed;
      other.args.standingOn = spawned;
    }
    if (!other.controllable) {
      return;
    }
    if (other.isVehicle) {
      return;
    }
    if (!other.args.standingOn) {
      const vehicleType = _ObjectPalette.ObjectPalette[this.args.vehicle];
      if (!vehicleType) {
        return;
      }
      const newVehicle = new vehicleType({
        x: other.x,
        y: other.y,
        xSpeed: other.args.xSpeed,
        ySpeed: other.args.ySpeed,
        gSpeed: other.args.gSpeed,
        falling: other.args.falling,
        lockedIn: true
      });
      this.viewport.spawn.add({
        object: newVehicle
      });
      other.args.standingOn = newVehicle;
      other[this.SpawnedFor] = newVehicle;
    }
  }
  leave(other) {
    if (other.occupant) {
      other = other.occupant;
    }
    if (!this.args.restricted) {
      return;
    }
    if (!other.args.standingOn) {
      return;
    }
    if (!other.args.standingOn.isVehicle) {
      return;
    }
    other[this.SpawnedFor] = false;
    const vehicle = other.args.standingOn;
    vehicle.args.lockedIn = false;
    vehicle.dead = true;
    other.args.standingOn = null;
    other.args.x = vehicle.args.x;
    other.args.y = vehicle.args.y;
    other.args.gSpeed = vehicle.args.gSpeed;
    other.args.xSpeed = vehicle.args.xSpeed;
    other.args.ySpeed = vehicle.args.ySpeed;
    other.args.falling = vehicle.args.falling;
  }
}
exports.VehicleRegion = VehicleRegion;
});

;require.register("region/VerticalRegion.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VerticalRegion = void 0;
var _Region = require("./Region");
class VerticalRegion extends _Region.Region {
  constructor() {
    super(...arguments);
    this.args.type = 'region vertical';
    this.args.hidden = true;
  }
  updateActor(other) {
    if (other.args.falling) {
      other.args.xSpeed = 0;
    }
  }
}
exports.VerticalRegion = VerticalRegion;
});

;require.register("region/WaterRegion.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WaterRegion = void 0;
var _Region = require("./Region");
var _Tag = require("curvature/base/Tag");
var _View = require("curvature/base/View");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class WaterRegion extends _Region.Region {
  constructor() {
    super(...arguments);
    _defineProperty(this, "isWater", true);
    this.args.type = 'region region-water';
    this.entryParticle = '<div class = "particle-splash">';
    this.args.gravity = 0.40;
    this.args.drag = 0.85;
    this.args.density = 1;
    this.args.z = 10000;
    this.skimSpeed = 15;
    this.draining = 0;
    this.skimParticles = new Map();
  }
  skim(actor) {
    super.skim(actor);
    if (this.viewport.args.frameId % this.viewport.settings.frameSkip !== 0) {
      return;
    }
    const splashPoint = actor.rotatePoint(actor.args.gSpeed, 3);
    if (this.skimParticles.has(actor)) {
      const stuff = this.skimParticles.get(actor);
      const {
        skimParticle,
        timeout
      } = stuff;
      timeout();
      const newTimeout = this.viewport.onFrameOut(2, () => {
        this.viewport.particles.remove(skimParticle);
        this.skimParticles.delete(actor);
      });
      stuff.timeout = newTimeout;
      skimParticle.style({
        '--x': splashPoint[0] + actor.x,
        '--y': splashPoint[1] + actor.y,
        'z-index': 0,
        '--flip': `${Math.sign(actor.args.gSpeed)}`
      });
      return;
    }
    if (this.viewport) {
      const skimParticle = new _Tag.Tag(`<div class = "particle-skim">`);
      this.viewport.particles.add(skimParticle);
      const timeout = this.viewport.onFrameOut(2, () => {
        this.viewport.particles.remove(skimParticle);
        this.skimParticles.delete(actor);
      });
      this.skimParticles.set(actor, {
        skimParticle,
        timeout
      });
    }
  }
  update() {
    if (!this.viewport) {
      return;
    }
    if (!this.filterWrapper && this.tags.sprite) {
      this.filterWrapper = new _Tag.Tag('<div class = "region-filter-wrapper">');
      this.colorWrapper = new _Tag.Tag('<div class = "region-color-wrapper">');
      this.filter = new _Tag.Tag('<div class = "region-filter">');
      this.color = new _Tag.Tag('<div class = "region-color">');
      this.colorWrapper.appendChild(this.color.node);
      this.filterWrapper.appendChild(this.filter.node);
      this.tags.sprite.appendChild(this.colorWrapper.node);
      this.tags.sprite.appendChild(this.filterWrapper.node);
    }
    if (this.args.controller) {
      const controller = this.viewport.actorsById[this.args.controller];
      if (controller) {
        this.args.height = controller.args.level;
      }
    }
    if (!this.switch && this.args.switch) {
      this.switch = this.viewport.actorsById[this.args.switch];
      if (this.switch) {
        this.switch.args.bindTo('active', v => {
          if (!v && this.draining > 0) {
            // this.draining = -1;
          }
          if (v) {
            this.draining = 1;
          } else {
            this.draining = -1;
          }
        });
      }
    }
    if (!this.originalHeight) {
      this.originalHeight = this.args.height;
    }
    if (this.draining) {
      if (this.draining > 0 && this.args.height >= 32) {
        this.args.height -= 3.5;
      } else if (this.draining < 0 && this.args.height < this.originalHeight) {
        this.args.height += 3.5;
      }
      if (this.args.height <= 0) {
        this.args.display = 'none';
        if (this.draining > 0) {
          this.draining = 0;
        }
      } else {
        this.args.display = 'initial';
      }
    }
    if (this.target && this.args.height !== this.target) {
      var _this$args$drainSpeed, _this$args$fillSpeed;
      const space = this.args.height - this.target;
      const drainSpeed = (_this$args$drainSpeed = this.args.drainSpeed) !== null && _this$args$drainSpeed !== void 0 ? _this$args$drainSpeed : 1;
      const fillSpeed = (_this$args$fillSpeed = this.args.fillSpeed) !== null && _this$args$fillSpeed !== void 0 ? _this$args$fillSpeed : 1;
      const speed = space > 0 ? drainSpeed : fillSpeed;
      if (Math.abs(this.args.height - this.target) > speed) {
        this.args.height -= Math.abs(speed) * Math.sign(space);
      } else {
        this.args.height = this.target;
      }
    }
    super.update();
  }
  updateEnd() {
    super.updateEnd();
    if (this.viewport.args.frameId % this.viewport.settings.frameSkip !== 0) {
      return;
    }
    for (const [actor, {
      skimParticle
    }] of this.skimParticles) {
      const splashPoint = actor.rotatePoint(0, 3);
      skimParticle.style({
        '--x': splashPoint[0] + actor.x + -32 * Math.sign(actor.args.gSpeed),
        '--y': splashPoint[1] + actor.y,
        'z-index': 0,
        '--flip': `${Math.sign(actor.args.gSpeed)}`
      });
    }
  }
  updateActor(other) {
    if (!other.controllable) {
      return;
    }
    if (other.args.y - other.args.height < this.args.y - this.args.height) {
      return;
    }
    if (this.viewport.args.frameId % 5 === 0 && Math.random() > 0.9) {
      const viewport = this.viewport;
      const bubble = new _Tag.Tag('<div class = "particle-bubble">');
      const attach = other.rotatePoint(...other.facePoint);
      const x = other.args.x + attach[0];
      const y = other.args.y + attach[1];
      bubble.style({
        '--startY': y,
        '--size': Math.random()
      });
      const stopHoldingBubble = viewport.onFrameInterval(1, () => {
        const point = other.facePoint;
        const x = other.args.x + point[0];
        const y = other.args.y + point[1];
        if (other.args.y < this.args.y - this.args.height) {
          bubble.style({
            display: 'none'
          });
        }
        if (y < this.args.y - this.args.height) {
          bubble.style({
            display: 'none'
          });
        }
        bubble.style({
          '--x': x,
          '--y': y
        });
      });
      const stopWatchingBubble = viewport.onFrameInterval(1, () => {
        bubble.style({
          '--maxY': this.args.y - this.args.height
        });
      });
      viewport.particles.add(bubble);
      viewport.onTimeout(350, () => {
        bubble.classList.add('float');
        stopHoldingBubble();
      });
      viewport.onTimeout(1000, () => {
        bubble.classList.add('floating');
      });
      setTimeout(() => {
        viewport.particles.remove(bubble);
        stopWatchingBubble();
      }, 1500);
    }
  }
  get solid() {
    return false;
  }
  get isEffect() {
    return true;
  }
}
exports.WaterRegion = WaterRegion;
});

;require.register("region/WaterfallRegion.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WaterfallRegion = void 0;
var _Region = require("./Region");
var _Tag = require("curvature/base/Tag");
var _View = require("curvature/base/View");
class WaterfallRegion extends _Region.Region {
  constructor() {
    super(...arguments);
    this.args.type = 'region region-shade region-waterfall';
    this.args.density = 0;
  }
  update() {
    super.update();
    if (!this.filterWrapper && this.tags.sprite) {
      this.filterWrapper = new _Tag.Tag('<div class = "region-filter-wrapper">');
      this.colorWrapper = new _Tag.Tag('<div class = "region-color-wrapper">');
      this.filter = new _Tag.Tag('<div class = "region-filter">');
      this.color = new _Tag.Tag('<div class = "region-color">');
      this.filterWrapper.appendChild(this.filter.node);
      this.colorWrapper.appendChild(this.color.node);
      this.tags.sprite.appendChild(this.filterWrapper.node);
      this.tags.sprite.appendChild(this.colorWrapper.node);
      this.tags.sprite.style({
        '--maskImage': `url(#mask-${this.args.id})`
      });
    }
  }
  get solid() {
    return false;
  }
  get isEffect() {
    return true;
  }
}
exports.WaterfallRegion = WaterfallRegion;
});

;require.register("replay/Replay.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Replay = void 0;
var _Uuid = require("curvature/base/Uuid");
var _Model = require("curvature/model/Model");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
const buildTag = document.head.querySelector('meta[name="x-build-time"]');
const buildTime = buildTag ? buildTag.getAttribute('content') : null;
class Replay extends _Model.Model {
  constructor() {
    super(...arguments);
    _defineProperty(this, "class", 'Replay');
    _defineProperty(this, "uuid", String(new _Uuid.Uuid()));
    _defineProperty(this, "created", Date.now());
    _defineProperty(this, "local", String(new Date()));
    _defineProperty(this, "tz", Intl.DateTimeFormat().resolvedOptions().timeZone);
    _defineProperty(this, "buildTime", buildTime);
    _defineProperty(this, "map", '');
    _defineProperty(this, "frames", []);
    _defineProperty(this, "keyFrames", []);
    _defineProperty(this, "name", '');
    _defineProperty(this, "lastFrame", 0);
    _defineProperty(this, "firstFrame", 0);
  }
  consume(skeleton) {
    let override = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    const _skeleton = Object.assign(Object.create(null), skeleton);
    _skeleton.keyFrames = Object.assign([], _skeleton.keyFrames);
    _skeleton.frames = Object.assign([], _skeleton.frames);
    _skeleton.frames = _skeleton.frames.map(f => Object.assign([], f));
    _skeleton.uuid = _skeleton.uuid || this.uuid || String(new _Uuid.Uuid());
    super.consume(_skeleton, override = false);
    if (_skeleton.frames) {
      this.keyFrames = _skeleton.frames.filter(f => Object.keys(f[2]).length).map(f => f[0]);
      const frameIds = this.frames.map(f => f[0]);
      this.firstFrame = frameIds.length ? Math.min(...frameIds) : 0;
      this.lastFrame = frameIds.length ? Math.max(...frameIds) : 0;
    }
  }
  getIndexedFrames() {
    const indexed = new Map();
    for (const frame of this.frames) {
      indexed.set(frame[0], frame);
    }
    return indexed;
  }
}
exports.Replay = Replay;
});

;require.register("replay/ReplayDatabase.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ReplayDatabase = void 0;
var _Database = require("curvature/model/Database");
class ReplayDatabase extends _Database.Database {
  _version_1(connection) {
    const replayStore = this.createObjectStore('replays', {
      keyPath: 'id',
      autoIncrement: true
    });
    replayStore.createIndex('buildTime', 'buildTime', {
      unique: false
    });
    replayStore.createIndex('created', 'created', {
      unique: false
    });
    replayStore.createIndex('uuid', 'uuid', {
      unique: true
    });
    replayStore.createIndex('id', 'id', {
      unique: true
    });
  }
  _version_2(connection, instance, event) {
    const transaction = event.target.transaction;
    const replayStore = transaction.objectStore('replays');
    replayStore.createIndex('name', 'name', {
      unique: false
    });
    replayStore.createIndex('map', 'map', {
      unique: false
    });
  }
  _version_3(connection, instance, event) {
    const transaction = event.target.transaction;
    const replayStore = transaction.objectStore('replays');
    replayStore.createIndex('map-id', ['map', 'id'], {
      unique: true
    });
    console.log('existing index names in store', replayStore.indexNames);
  }
}
exports.ReplayDatabase = ReplayDatabase;
});

;require.register("replay/ReplayService.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ReplayService = void 0;
class ReplayService {
  constructor(viewport) {
    this.viewport = viewport;
  }
  startDemo(replay) {
    let offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    const parent = this.viewport;
    parent.reset();
    parent.replayFrames = replay.getIndexedFrames();
    parent.replayStart = parent.replayFrames.get(offset || replay.firstFrame) || {};
    parent.replay = replay;
    parent.maxReplayFrame = replay.lastFrame;
    parent.replayOffset = -1 + replay.firstFrame + offset;
    Router.setQuery('demo', replay.uuid);
    parent.loadMap({
      mapUrl: replay.map
    }).then(() => {
      parent.args.paused = true;
      parent.playback();
    });
  }
}
exports.ReplayService = ReplayService;
});

;require.register("save/Save.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Save = void 0;
var _Uuid = require("curvature/base/Uuid");
var _Model = require("curvature/model/Model");
var _SaveDatabase = require("./SaveDatabase");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class ProgressState {
  constructor() {
    _defineProperty(this, "lastCheckpoint", null);
    _defineProperty(this, "lastZone", null);
    _defineProperty(this, "zonesComplete", {});
    _defineProperty(this, "characters", {});
  } // Object.preventExtensions(this);
}

const openDb = _SaveDatabase.SaveDatabase.open('saves', 1);
class Save extends _Model.Model {
  constructor() {
    super(...arguments);
    // emblems    = {};
    // characters = {};
    _defineProperty(this, "id", null);
    _defineProperty(this, "created", Date.now());
    _defineProperty(this, "emeralds", []);
    _defineProperty(this, "characters", {});
    _defineProperty(this, "zones", {
      // '/map/empty-zone-2.json': {
      // 	emeralds: ['red']
      // 	, emblems: []
      // 	, lastCheckpoint: null
      // }
      // , '/map/emblem-test.json': {
      // 	emeralds: []
      // 	, emblems: []
      // 	, lastCheckpoint: null
      // }
    });
  }
  static from(skeleton) {
    const save = super.from(skeleton);
    save.emeralds = Object.assign([], save.emeralds);
    for (const zone of Object.values(save.zones)) {
      zone.emblems = Object.assign([], zone.emblems);
      zone.chao = Object.assign([], zone.chao);
    }
    return save;
  }
  getCharacterState(name) {
    const save = this.characters[name] || {
      cleared: {}
    };
    return this.characters[name] = save;
  }
  getZoneState(zone) {
    const save = this.zones[zone] || {
      lastCheckpoint: null,
      emblems: [],
      chao: [],
      rings: 0,
      score: 0,
      time: 0
    };
    return this.zones[zone] = save;
  }
  static index() {
    return openDb.then(database => {
      const query = {
        direction: 'next',
        index: 'created',
        store: 'saves'
      };
      const saves = [];
      return database.select(query).each(save => saves.push(save)).then(() => saves);
    });
  }
  save() {
    openDb.then(database => {
      if (this.id) {
        database.update('saves', this);
      } else {
        this.id = String(new _Uuid.Uuid());
        database.insert('saves', this);
      }
    });
  }
  load() {}
}
exports.Save = Save;
});

;require.register("save/SaveDatabase.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SaveDatabase = void 0;
var _Database = require("curvature/model/Database");
class SaveDatabase extends _Database.Database {
  _version_1(database) {
    this.createObjectStore('saves', {
      keyPath: 'id'
    }).createIndex('created', 'created', {
      unique: false
    });
  }
}
exports.SaveDatabase = SaveDatabase;
});

;require.register("sprite/Png.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Png = void 0;
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
const header = [0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A];
class Pixel {
  constructor() {
    let r = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    let g = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    let b = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    let a = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
    _defineProperty(this, "r", 0);
    _defineProperty(this, "g", 0);
    _defineProperty(this, "b", 0);
    _defineProperty(this, "a", 1);
    this.r = r;
    this.g = g;
    this.b = b;
    this.a = a;
  }
  mean() {
    return (this.r + this.g + this.b) / 3;
  }
  hex() {
    let length = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 3;
    if (length === 3) {
      return `${this.r.toString(16).padStart(2, '0')}${this.g.toString(16).padStart(2, '0')}${this.b.toString(16).padStart(2, '0')}`;
    }
    if (length === 4) {
      return `${this.r.toString(16).padStart(2, '0')}${this.g.toString(16).padStart(2, '0')}${this.b.toString(16).padStart(2, '0')}${this.a.toString(16).padStart(2, '0')}`;
    }
  }
  valueOf() {
    return `rgba(${this.r}, ${this.g}, ${this.b}, ${this.a})`;
  }
}
class Chunk {
  constructor() {
    _defineProperty(this, "previous", null);
    _defineProperty(this, "content", null);
    _defineProperty(this, "length", 0);
    _defineProperty(this, "start", 0);
    _defineProperty(this, "type", '');
    _defineProperty(this, "crc", 0);
  }
  get text() {
    return this.bytes.map(b => String.fromCharCode(b)).join('');
  }
  get bytes() {
    const bytes = [];
    for (let i = 0; i < this.length; i++) {
      bytes.push(this.content.getUint8(i));
    }
    return bytes;
  }
}
class Png {
  constructor(source) {
    _defineProperty(this, "buffer", null);
    _defineProperty(this, "width", 0);
    _defineProperty(this, "height", 0);
    _defineProperty(this, "depth", 0);
    _defineProperty(this, "colorType", 0);
    _defineProperty(this, "compression", 0);
    _defineProperty(this, "filter", 0);
    _defineProperty(this, "interlace", 0);
    if (typeof source === 'string') {
      this.ready = fetch(source).then(response => response.arrayBuffer()).then(buffer => {
        this.buffer = buffer;
        this.checkHeader();
        this.indexChunks();
      });
    } else if (typeof source === 'object') {
      if (source instanceof Png) {
        this.ready = Promise.resolve();
        this.buffer = source.buffer.slice(0);
        this.chunks = source.chunks.slice(0);

        // this.checkHeader();
        // this.indexChunks();
      }
    }
  }

  checkHeader() {
    const bytes = new Uint8Array(this.buffer);
    for (const i in header) {
      if (header[i] !== bytes[i]) {
        throw new Error('Png is not valid.');
      }
    }
  }
  readIhdr() {
    const ihdr = this.chunks[0];
    this.width = ihdr.content.getUint32(0);
    this.height = ihdr.content.getUint32(4);
    this.depth = ihdr.content.getUint8(8);
    this.colorType = ihdr.content.getUint8(9);
    this.compression = ihdr.content.getUint8(10);
    this.filter = ihdr.content.getUint8(11);
    this.interlace = ihdr.content.getUint8(12);
  }
  get palette() {
    const palette = [];
    for (const i in this.chunks) {
      const chunk = this.chunks[i];
      if (chunk.type !== 'PLTE') {
        continue;
      }
      for (let ii = 0; ii < chunk.bytes.length; ii += 3) {
        const color = new Pixel(chunk.bytes[ii + 0], chunk.bytes[ii + 1], chunk.bytes[ii + 2]);
        palette.push(color);
      }
      return palette;
    }
  }
  recolor() {
    let colorMap = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const palette = this.palette;
    const newPalette = [];
    for (const i in palette) {
      const color = palette[i];
      const hex = color.hex();
      if (colorMap[hex]) {
        const newColor = colorMap[hex];
        const newR = newColor.substring(0, 2);
        const newG = newColor.substring(2, 4);
        const newB = newColor.substring(4, 6);
        const triplet = [newR, newG, newB].map(x => parseInt(x, 16));
        newPalette.push(...triplet);
      } else {
        newPalette.push(color.r, color.g, color.b);
      }
    }
    const newPng = new Png(this);
    for (const i in newPng.chunks) {
      const chunk = newPng.chunks[i];
      if (chunk.type !== 'PLTE') {
        continue;
      }
      const newBytes = new Uint8Array(newPng.buffer);
      const crcPointer = new DataView(newPng.buffer, chunk.start + chunk.length, 4);
      newBytes.set(newPalette, chunk.start);
      crcPointer.setUint32(0, newPng.runCrc(chunk));
    }
    return newPng;
  }
  runCrc(chunk) {
    if (!Png.crcTable) {
      Png.crcTable = new Uint32Array(256);
      for (let n = 0; n < 256; n++) {
        let c = n;
        for (let k = 0; k < 8; k++) {
          if ((c & 1) == 1) {
            c = 0xEDB88320 ^ c >>> 1;
          } else {
            c = c >>> 1;
          }
        }
        Png.crcTable[n] = c;
      }
    }
    let crc = 0xFFFFFFFF;
    const bytes = new Uint8Array(this.buffer);
    const chunkBytes = bytes.slice(chunk.start - 4, chunk.start + chunk.length);
    for (const i in chunkBytes) {
      const byte = chunkBytes[i];
      crc = Png.crcTable[(crc ^ byte) & 0xFF] ^ crc >>> 8;
    }
    crc = (crc ^ 0xFFFFFFFF) >>> 0;
    return crc;
  }
  indexChunks() {
    const chunks = [];
    let pos = 8;
    while (pos < this.buffer.byteLength) {
      const lengthView = new DataView(this.buffer, pos, 4);
      pos += 4;
      const typeView = new DataView(this.buffer, pos, 4);
      pos += 4;
      const chunk = new Chunk();
      chunk.start = pos;
      chunk.length = lengthView.getUint32();
      for (let i = 0; i < 4; i++) {
        const byte = typeView.getUint8(i);
        const char = String.fromCharCode(byte);
        chunk.type += char;
      }
      chunk.content = new DataView(this.buffer, pos, chunk.length);
      pos += chunk.length;
      const crcView = new DataView(this.buffer, pos, 4);
      chunk.crc = crcView.getUint32();
      chunk.previous = chunks[chunks.length - 1];
      chunks.push(chunk);
      pos += 4;
    }
    this.chunks = chunks;
  }
  toBlob() {
    return new Blob([new Uint8Array(this.buffer)], {
      type: 'image/png'
    });
  }
  toUrl() {
    return URL.createObjectURL(this.toBlob());
  }
  toDataUri() {
    if (this.getDataUri) {
      return this.getDataUri;
    }
    const reader = new FileReader();
    reader.readAsDataURL(this.toBlob());
    this.getDataUri = new Promise(accept => reader.addEventListener('load', event => accept(event.target.result)));
    return this.getDataUri;
  }
}
exports.Png = Png;
Png.Pixel = Pixel;
Png.Chunk = Chunk;
});

require.register("tally/TallyBoard.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TallyBoard = void 0;
var _Bindable = require("curvature/base/Bindable");
var _Mixin = require("curvature/base/Mixin");
var _EventTargetMixin = require("curvature/mixin/EventTargetMixin");
var _View = require("curvature/base/View");
var _Sfx = require("../audio/Sfx");
var _Bgm = require("../audio/Bgm");
var _TallyCounter = require("./TallyCounter");
var _CharacterString = require("../ui/CharacterString");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class TallyBoard extends _Mixin.Mixin.with(class {}, _EventTargetMixin.EventTargetMixin) {
  constructor() {
    super(...arguments);
    _defineProperty(this, "totalLabel", new _CharacterString.CharacterString({
      value: 'Total:',
      color: 'yellow'
    }));
    _defineProperty(this, "totalValue", new _CharacterString.CharacterString({
      value: '0'
    }));
    _defineProperty(this, "inventoryCounter", new _CharacterString.CharacterString({
      value: '-'
    }));
    _defineProperty(this, "inventoryBump", '');
    _defineProperty(this, "inventory", _Bindable.Bindable.make([]));
    _defineProperty(this, "hasInventory", false);
    _defineProperty(this, "counters", _Bindable.Bindable.make([]));
    _defineProperty(this, "totaling", false);
    _defineProperty(this, "totaled", false);
    _defineProperty(this, "total", 0);
    _defineProperty(this, "step", 200);
    _defineProperty(this, "age", 0);
    _defineProperty(this, "almostDone", false);
    _defineProperty(this, "done", false);
    _defineProperty(this, "doneAge", 0);
  }
  // constructor(){}

  update(viewport) {
    let totaled = true;
    let totaling = false;
    this.hasInventory = !!viewport.args.inventory.length;
    let beat = 15;
    let delay = 30;
    for (const counter of this.counters) {
      if (delay + beat + counter.index * beat === this.age) {
        _Sfx.Sfx.play('TALLY_SCORE');
        if (!counter.started) {
          counter.started = true;
          counter.display.args.value = counter.points;
          counter.display.args.color = 'white';
          counter.bump = 'bump';
        }
      }
      if (delay + 2 * beat + beat * (this.counters.length + viewport.args.inventory.length) + beat * counter.index > this.age) {
        totaled = false;
        continue;
      }
      counter.started = true;
      if (counter.display.args.value > 0) {
        const inc = Math.min(this.step, counter.display.args.value);
        this.total += inc;
        viewport.controlActor.args.score += inc;
        counter.display.args.value = Math.max(0, counter.display.args.value - this.step);
        totaling = true;
        totaled = false;
      }
    }
    let i = 0;
    for (const item of viewport.args.inventory) {
      i++;
      if (delay + (this.counters.length + i) * beat > this.age) {
        totaled = false;
        continue;
      }
      if (!item.tallied) {
        this.inventoryBump = '';
        viewport.onFrameOut(1, () => {
          _Sfx.Sfx.play('TALLY_SCORE');
          this.inventoryBump = 'bump';
        });
        this.inventory.push(item);
        this.inventoryCounter.args.value = (Number(this.inventoryCounter.args.value) || 0) + item.points;
        item.tallied = true;
      }
    }
    if (Number(this.inventoryCounter.args.value) > 0) {
      if (delay + (this.counters.length + i + 2) * beat + beat * 2 < this.age) {
        const inc = Math.min(this.step, Number(this.inventoryCounter.args.value) || 0);
        this.total += inc;
        viewport.controlActor.args.score += inc;
        this.inventoryCounter.args.value = Math.max(0, (Number(this.inventoryCounter.args.value) || 0) - this.step);
        totaling = true;
      }
      totaled = false;
    }
    if (totaling) {
      if (!this.totaling) {
        this.dispatchEvent('totalingstarted');
        this.totaling = true;
      }
    }
    if (!totaling) {
      if (this.totaling) {
        this.dispatchEvent('totalingdone');
        // this.totaling = false;
      }
    }

    this.totaled = totaled;
    if (this.totaled && this.totaling) {
      _Sfx.Sfx.play('TOTAL_SCORE');
      this.doneAge = this.age;
    }
    if (this.doneAge && this.age == this.doneAge + 60) {
      if (!this.almostDone) {
        this.almostDone = true;
        this.dispatchEvent('almostdone');
      }
    }
    if (this.doneAge && this.age > this.doneAge + 120) {
      if (!this.done) {
        this.done = true;
        this.dispatchEvent('done');
      }
    }
    this.totalValue.args.value = this.total;
    if (totaled) {
      this.totaling = false;
    }
    if (this.totaling && !this.totaled) {
      _Sfx.Sfx.play('SWITCH_HIT');
    }
    this.age++;
  }
  view() {
    return _View.View.from(require('./tally-board.html'), this);
  }
  addCounter(_ref) {
    let {
      type = 'label',
      label = 'counter',
      value = 0,
      required = true
    } = _ref;
    if (!value && !required) {
      return;
    }
    const counter = new _TallyCounter.TallyCounter();
    counter.display = new _CharacterString.CharacterString({
      value: '-',
      color: 'grey'
    });
    counter.points = value;
    counter.label = new _CharacterString.CharacterString({
      value: label,
      color: 'yellow'
    });
    counter.index = this.counters.length;
    this.counters.push(counter);

    // console.log(counter);
  }
}
exports.TallyBoard = TallyBoard;
});

;require.register("tally/TallyCounter.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TallyCounter = void 0;
var _Bindable = require("curvature/base/Bindable");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class TallyCounter {
  constructor() {
    _defineProperty(this, "multiplier", 1);
    _defineProperty(this, "points", 0);
    _defineProperty(this, "value", 0);
    _defineProperty(this, "type", TallyCounter.TYPE_LABEL);
    _defineProperty(this, "label", '');
    _defineProperty(this, "icon", '');
    _defineProperty(this, "items", []);
    _defineProperty(this, "started", 0);
    _defineProperty(this, "display", 0);
    _defineProperty(this, "visible", 0);
    _defineProperty(this, "index", 0);
    return _Bindable.Bindable.make(this);
  }
}
exports.TallyCounter = TallyCounter;
TallyCounter.TYPE_LABEL = 0;
TallyCounter.TYPE_ICONS = 1;
TallyCounter.TYPE_ITEMS = 2;
});

require.register("tally/tally-board.html", function(exports, require, module) {
module.exports = "<div class = \"tally-board\">\n\t<div class = \"tally-board-content\" cv-each = \"counters:counter\">\n\t\t<div class = \"tally-board-row\">\n\t\t\t<div>[[counter.label]]</div>\n\t\t\t<div class = \"tally-item [[counter.bump]]\">[[counter.display]]</div>\n\t\t</div>\n\t</div>\n\t<div class = \"tally-board-content tally-board-inventory\" cv-if = \"hasInventory\">\n\t\t<div class = \"tally-board-row\">\n\t\t\t<div cv-each = \"inventory:item\"><img loading=\"lazy\" src = \"[[item.tallyIcon]]\" class = \"inventory-icon\" /></div>\n\t\t\t<div class = \"tally-item [[inventoryBump]]\">[[inventoryCounter]]</div>\n\t\t</div>\n\t</div>\n\t</div>\n\t<div class = \"tally-board-row tally-board-total\">\n\t\t<div>[[totalLabel]]</div>\n\t\t<div>[[totalValue]]</div>\n\t</div>\n</div>\n"
});

;require.register("tileMap/Elicit.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Elicit = void 0;
var _Mixin = require("curvature/base/Mixin");
var _EventTargetMixin = require("curvature/mixin/EventTargetMixin");
var _PromiseMixin = require("curvature/mixin/PromiseMixin");
class Elicit extends _Mixin.Mixin.with(_EventTargetMixin.EventTargetMixin, _PromiseMixin.PromiseMixin) {
  constructor(url) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    super();
    this.fetch = fetch(url, options).then(response => this.handleFetch(response));
  }
  headers() {
    return this.fetch.then(_ref => {
      let {
        response,
        stream
      } = _ref;
      return response.headers;
    });
  }
  stream(url) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return this.fetch.then(_ref2 => {
      let {
        response,
        stream
      } = _ref2;
      return new Response(stream, {
        headers: response.headers
      });
    });
  }
  objectUrl(url) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return this.stream(url, options).then(response => response.blob()).then(blob => URL.createObjectURL(blob));
  }
  emitProgressEvent(length, received) {
    const done = length ? received / length : 0;
    this.dispatchEvent(new CustomEvent('progress', {
      detail: {
        length,
        received,
        done
      }
    }));
  }
  iterateDownload(reader, controller, length) {
    this.emitProgressEvent(length, 0);
    let received = 0;
    const iterate = () => {
      reader.read().then(_ref3 => {
        let {
          done,
          value
        } = _ref3;
        if (done) {
          this[_PromiseMixin.PromiseMixin.Accept]();
          controller.close();
          return;
        }
        controller.enqueue(value);
        received += value.length;
        this.emitProgressEvent(length, received);
        return iterate();
      });
    };
    return iterate();
  }
  handleFetch(response) {
    const reader = response.body.getReader();
    const length = response.headers.get('Content-Length');
    const elicit = this;
    const stream = new ReadableStream({
      start(controller) {
        elicit.iterateDownload(reader, controller, length);
      }
    });
    return {
      response,
      stream
    };
  }
}
exports.Elicit = Elicit;
});

;require.register("tileMap/TileMap.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TileMap = void 0;
var _Tag = require("curvature/base/Tag");
var _Mixin = require("curvature/base/Mixin");
var _Bindable = require("curvature/base/Bindable");
var _EventTargetMixin = require("curvature/mixin/EventTargetMixin");
var _Elicit = require("./Elicit");
class TileMap extends _Mixin.Mixin.with(_EventTargetMixin.EventTargetMixin) {
  constructor(args, parent) {
    super();
    this.preloaders = new Map();
    this.meta = new Map();
    this.heightMask = null;
    this.tileImages = new Map();
    this.tileNumberCache = new Map();
    this.tileSetCache = new Map();
    this.tileCache = new Map();
    this.heightMasks = new Map();
    this.heightMaskCache = new Map();
    this.prefixed = new Map();
    this.mapDirectory = '/map';
    this.tileLayers = [];
    this.destructibleLayers = [];
    this.collisionLayers = [];
    this.objectLayers = [];

    // this.mapVars = new Map;

    const url = args.mapUrl;
    this.mapData = null;
    this.mapUrl = url;
    this.maps = new Map();
    this.replacements = new Map();
    this.loaded = new Map();
    this.emptyCache = new Map();
    this.solidCache = new Map();
    if (String(url).substr(-4) === 'json') {
      const elicit = new _Elicit.Elicit(url);
      elicit.addEventListener('progress', event => {
        const {
          received,
          length,
          done
        } = event.detail;
        const type = 'map';
        this.dispatchEvent(new CustomEvent('level-progress', {
          detail: {
            length,
            received,
            done,
            url
          }
        }));
      });
      this.ready = elicit.stream().then(response => response.json()).then(tilemapData => {
        this.maps.set(tilemapData, [0, 0]);
        this.mapData = tilemapData;
        if (tilemapData && tilemapData.properties) {
          for (const property of tilemapData.properties) {
            const name = property.name.replace(/-/g, '_');
            this.meta.set(name, property.value);
          }
        }
        this.desparseLayers(tilemapData);
        this.loadLayers(tilemapData);
        return this.loadTilesets(tilemapData);
      });
    } else if (String(url).substr(-3) === 'png') {
      this.ready = this.fromImage(url, 32);
    }
    Object.preventExtensions(this);
  }
  desparseLayers(tilemapData) {
    // console.time('desparse');

    for (const layer of tilemapData.layers) {
      if (layer.type !== 'tilelayer' || !layer.sparsed || layer.data) {
        continue;
      }
      const desparsed = layer.data = Object.create(null);
      while (layer.sparsed.length) {
        const tileNo = Number(layer.sparsed.pop());
        const tileId = Number(layer.sparsed.pop());
        if (!tileNo) {
          console.log({
            tileId,
            tileNo
          });
        }
        desparsed[tileId] = tileNo;
      }
    }
  }
  preloadMap(url) {
    if (this.preloaders.has(url)) {
      return this.preloaders.get(url);
    }
    const elicit = new _Elicit.Elicit(url);

    // elicit.addEventListener('progress', event => {
    // const {received, length, done} = event.detail;
    // const type = 'map';
    // this.dispatchEvent(new CustomEvent(
    // 	'level-progress', {detail: {length, received, done, url}}
    // ));
    // });

    const res = elicit.stream().then(response => response.json());
    this.preloaders.set(url, res);
    return res;
  }
  append(url, xOffset, yOffset) {
    let maxObjectId = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
    return this.preloadMap(url).then(data => {
      const width = this.mapData.width;
      const overlap = -width + xOffset;
      const newWidth = width + data.width + overlap;
      const height = this.mapData.height;
      const newHeight = Math.max(height, height + data.height + -Math.round(yOffset / 32));
      this.maps.set(data, [xOffset, yOffset]);
      this.resize(newWidth, height);
      this.desparseLayers(data);
      let lastGid = 0;
      for (const tileset of this.mapData.tilesets) {
        lastGid += tileset.tilecount;
      }
      for (const tileset of data.tilesets) {
        tileset.firstgid += lastGid;
      }
      for (const newLayer of data.layers) {
        const newData = Object.create(null);
        const sizeOffset = this.mapData.width - newLayer.width;
        const offset = xOffset + yOffset * this.mapData.width;
        if (!newLayer.data) {
          continue;
        }
        for (let i of Object.keys(newLayer.data)) {
          const tileId = Number(i);
          const tileNo = Number(newLayer.data[i]);
          const row = Math.floor(tileId / newLayer.width);
          delete newLayer.data[i];
          newData[row * sizeOffset + offset + tileId] = tileNo + lastGid;
        }
        Object.assign(newLayer.data, newData);
        for (const existingLayer of this.mapData.layers) {
          if (newLayer.name !== existingLayer.name) {
            continue;
          }
          Object.assign(existingLayer.data, newLayer.data);
          existingLayer.layer.setMeta(newLayer, maxObjectId);
        }
      }
      for (const newTileset of data.tilesets) {
        this.mapData.tilesets.push(newTileset);
      }
      this.tileNumberCache.clear();
      return this.loadTilesets(data).then(() => {
        return {
          defs: this.getObjectDefs(data, lastGid),
          data
        };
      });
    });
  }
  resize(newWidth, newHeight) {
    let tileLayers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.tileLayers;
    const mapData = this.mapData;
    const originalWidth = mapData.width;
    const originalHeight = mapData.height;
    mapData.width = newWidth;
    mapData.height = newHeight;
    const offset = newWidth - originalWidth;
    for (const layer of tileLayers) {
      const newData = Object.create(null);
      for (const [i, tileNo] of Object.entries(layer.data)) {
        const tileId = Number(i);
        const row = Math.floor(tileId / originalWidth);
        newData[row * offset + tileId] = tileNo;
      }
      layer.data = newData;
    }
    this.tileNumberCache.clear();
  }
  offset(xOffset, yOffset) {
    let tileLayers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.tileLayers;
    const offset = xOffset + yOffset * this.mapData.width;
    for (const layer of tileLayers) {
      const newData = Object.create(null);
      for (const [i, tileNo] of Object.entries(layer.data)) {
        const tileId = Number(i);
        newData[offset + tileId] = tileNo;
      }
      layer.data = newData;
    }
    this.tileNumberCache.clear();
  }
  loadTilesets(mapData) {
    const setHeightMasks = [];
    const imageProgress = new Map();
    const imageSize = new Map();
    this.emptyCache.clear();
    this.solidCache.clear();
    for (const tileset of mapData.tilesets) {
      const image = new Image();
      this.tileImages.set(tileset, image);
      if (!this.prefixed.has(tileset)) {
        this.prefixed.set(tileset, String(this.mapDirectory + '/' + tileset.image).replace(/\/\/+/g, '/'));
      }
      const imageUrl = this.prefixed.get(tileset);
      tileset.original = tileset.image = imageUrl;
      const fetchImage = new _Elicit.Elicit(imageUrl);
      fetchImage.addEventListener('progress', event => {
        const {
          received,
          length,
          done
        } = event.detail;
        imageProgress.set(fetchImage, received);
        imageSize.set(fetchImage, length);
        const imagesProgress = [...imageProgress.values()].reduce((a, b) => Number(a) + Number(b));
        const imagesLength = [...imageSize.values()].reduce((a, b) => Number(a) + Number(b));
        const imagesDone = imagesProgress / imagesLength;
        this.dispatchEvent(new CustomEvent('texture-progress', {
          detail: {
            length: imagesLength,
            received: imagesProgress,
            done: imagesDone,
            url: imageUrl
          }
        }));
      });
      const heightMask = fetchImage.objectUrl().then(url => new Promise(accept => {
        tileset.cachedImage = url;
        image.addEventListener('load', event => {
          if (!this.replacements.has(imageUrl)) {
            this.replacements.set(imageUrl, url);
          }
          this.loaded.set(imageUrl, url);
          const heightMask = document.createElement('canvas');
          heightMask.width = image.width;
          heightMask.height = image.height;
          heightMask.getContext('2d').drawImage(image, 0, 0, image.width, image.height);
          this.heightMasks.set(tileset, heightMask.getContext('2d').getImageData(0, 0, heightMask.width, heightMask.height));
          accept(heightMask);
        }, {
          once: true
        });
        image.src = url;
      }));
      setHeightMasks.push(heightMask);
    }
    return Promise.all(setHeightMasks);
  }
  loadLayers(tilemapData) {
    const layerGroup = Object.create(null);
    const layers = tilemapData.layers || [];
    tilemapData.layers.forEach((layer, index) => {
      layer.offsetX = false;
      layer.offsetY = false;
      layer.offsetXChanged = false;
      layer.offsetYChanged = false;
      layer.destroyed = false;
      layer.layer = null;
      layer.index = null;
      Object.preventExtensions(layer);
    });
    this.objectLayers = tilemapData.layers.filter(l => l.type === 'objectLayers');
    this.tileLayers = tilemapData.layers.filter(l => l.type === 'tilelayer');
    this.tileLayers.forEach((layer, index) => layer.index = index);

    // layerGroup.objectLayers = this.objectLayers;
    layerGroup.tileLayers = this.tileLayers;
    this.collisionLayers = this.tileLayers.filter(l => {
      if (!l.name.match(/^Collision\s\d+/)) {
        return false;
      }
      return true;
    });
    this.destructibleLayers = this.tileLayers.filter(l => {
      if (!l.name.match(/^Destructible\s\d+/)) {
        return false;
      }
      return true;
    });
    layerGroup.destructibleLayers = this.destructibleLayers;
    layerGroup.collisionLayers = this.collisionLayers;
  }
  coordsToTile(x, y, layerId) {
    const blockSize = this.blockSize;
    let offsetX = 0;
    let offsetY = 0;
    if (this.tileLayers[layerId]) {
      var _this$tileLayers$laye, _this$tileLayers$laye2;
      offsetX = (_this$tileLayers$laye = this.tileLayers[layerId].offsetX) !== null && _this$tileLayers$laye !== void 0 ? _this$tileLayers$laye : 0;
      offsetY = (_this$tileLayers$laye2 = this.tileLayers[layerId].offsetY) !== null && _this$tileLayers$laye2 !== void 0 ? _this$tileLayers$laye2 : 0;
    }
    return [Math.floor((x - offsetX) / blockSize), Math.floor((y - offsetY) / blockSize)];
  }
  getTileNumber(x, y) {
    let layerId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    // const tileKey = x + ',' + y + ',' + layerId;
    // const cached  = this.tileNumberCache.get(tileKey);

    // if(cached !== undefined)
    // {
    // 	return cached;
    // }

    const tileLayers = this.tileLayers;
    if (!tileLayers[layerId]) {
      // this.tileNumberCache.set(tileKey, false);
      return false;
    }
    const mapData = this.mapData;
    const mapWidth = mapData.width;
    const mapHeight = mapData.height;
    if (x >= mapWidth || x < 0) {
      if (x < 0 || !this.meta.get('wrapX')) {
        if (layerId !== 0) {
          // this.tileNumberCache.set(tileKey, false);
          return false;
        }

        // this.tileNumberCache.set(tileKey, 1);

        return 1;
      } else {
        if (x < 0 && x % mapWidth !== 0) {
          y++;
        }
        x = x % mapWidth;
      }
    }
    if (y >= mapHeight || y < 0) {
      if (y < 0 || !this.meta.get('wrapY')) {
        if (layerId !== 0) {
          // this.tileNumberCache.set(tileKey, false);

          return false;
        }

        // this.tileNumberCache.set(tileKey, 1);

        return 1;
      } else {
        y = y % mapHeight;
      }
    }
    const tileIndex = y * mapWidth + x;
    if (tileIndex in tileLayers[layerId].data) {
      const layer = tileLayers[layerId];
      const tile = layer.data[tileIndex];
      const tileNumber = tile > 0 ? tile - 1 : 0;
      if (this.checkEmpty(tileNumber)) {
        // this.tileNumberCache.set(tileKey, false);
        return false;
      }

      // this.tileNumberCache.set(tileKey, tileNumber);

      return tileNumber;
    }

    // this.tileNumberCache.set(tileKey, false);

    return false;
  }
  getObjectDefs() {
    let mapData = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.mapData;
    let startGid = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    if (!mapData) {
      return;
    }
    return mapData.layers.filter(layer => layer.type === 'objectgroup').map(layer => layer.objects).flat().map(o => {
      if (typeof o.gid !== 'undefined') {
        o.gid += startGid;
      }
      return o;
    });
  }
  getTile(tileNumber) {
    const cached = this.tileCache.get(tileNumber);
    if (cached !== undefined) {
      if (this.replacements.has(cached[3])) {
        cached[2] = this.replacements.get(cached[3]);
      } else if (this.loaded.has(cached[3])) {
        cached[2] = this.loaded.get(cached[3]);
      }
      return cached;
    }
    const blockSize = this.blockSize;
    let x = 0;
    let y = 0;
    let src = '';
    let original = '';
    const tileset = this.getTileset(tileNumber);
    const image = this.tileImages.get(tileset);
    if (tileset && !tileset.meta && tileset.properties) {
      tileset.meta = Object.create(null);
      for (const property of tileset.properties) {
        tileset.meta[property.name] = property.value;
      }
    }
    if (tileNumber) {
      const localTileNumber = tileNumber + -tileset.firstgid + 1;
      const blocksWide = Math.ceil(image.width / blockSize);
      x = localTileNumber % blocksWide;
      y = Math.floor(localTileNumber / blocksWide);
      src = tileset.image;
      original = tileset.original;
    }
    const result = [x, y, src, original, tileset];
    Object.preventExtensions(result);
    this.tileCache.set(tileNumber, result);
    return result;
  }
  getSolid(xInput, yInput) {
    let layerInput = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    xInput = Math.trunc(xInput);
    yInput = Math.trunc(yInput);
    let offsetX = 0;
    let offsetY = 0;
    let tileNumber;
    let checkLayers;
    if (!(layerInput instanceof Map)) {
      checkLayers = new Map();
      checkLayers.set(this.tileLayers[0], true);
      checkLayers.set(this.tileLayers[layerInput], true);
    } else {
      checkLayers = layerInput;
    }
    for (const [layer, willCheck] of checkLayers) {
      if (!willCheck || !layer) {
        continue;
      }
      const layerId = layer.index;
      if (this.tileLayers[layerId]) {
        var _this$tileLayers$laye3, _this$tileLayers$laye4;
        offsetX = (_this$tileLayers$laye3 = this.tileLayers[layerId].offsetX) !== null && _this$tileLayers$laye3 !== void 0 ? _this$tileLayers$laye3 : 0;
        offsetY = (_this$tileLayers$laye4 = this.tileLayers[layerId].offsetY) !== null && _this$tileLayers$laye4 !== void 0 ? _this$tileLayers$laye4 : 0;
      }
      tileNumber = this.getTileNumber(Math.floor((xInput - offsetX) / this.blockSize), Math.floor((yInput - offsetY) / this.blockSize), layerId);
      const solidLayerCount = this.collisionLayers.length;
      if (layerId <= 3) {
        if (tileNumber === 0) {
          continue;
        }
        if (tileNumber === 1) {
          return this.tileLayers[layerId];
        }
      }
      const tileSet = this.getTileset(tileNumber);
      const mapData = this.mapData;
      const blockSize = mapData.tilewidth;
      const tileCoords = this.getTile(tileNumber);
      const tilePosX = tileCoords[0] * blockSize;
      const tilePosY = tileCoords[1] * blockSize;
      const x = Number(xInput) % blockSize;
      const y = Number(yInput) % blockSize;
      const xPixel = tilePosX + x;
      const yPixel = tilePosY + y;
      const heightMask = this.heightMasks.get(tileSet);
      const iPixel = (xPixel + yPixel * heightMask.width) * 4;
      if (heightMask.data[iPixel + 3] === 255) {
        return this.tileLayers[layerId];
      }
    }
  }
  getColor(xInput, yInput, layerInput) {
    let offsetX = 0;
    let offsetY = 0;
    if (this.tileLayers[layerInput]) {
      var _this$tileLayers$laye5, _this$tileLayers$laye6;
      offsetX = (_this$tileLayers$laye5 = this.tileLayers[layerInput].offsetX) !== null && _this$tileLayers$laye5 !== void 0 ? _this$tileLayers$laye5 : 0;
      offsetY = (_this$tileLayers$laye6 = this.tileLayers[layerInput].offsetY) !== null && _this$tileLayers$laye6 !== void 0 ? _this$tileLayers$laye6 : 0;
    }
    const tileNumber = this.getTileNumber(Math.floor((xInput - offsetX) / this.blockSize), Math.floor((yInput - offsetY) / this.blockSize), layerInput);
    const tileSet = this.getTileset(tileNumber);
    const mapData = this.mapData;
    const blockSize = mapData.tilewidth;
    const tileCoords = this.getTile(tileNumber);
    const tilePos = [tileCoords[0] * blockSize, tileCoords[1] * blockSize];
    const x = Number(xInput) % blockSize;
    const y = Number(yInput) % blockSize;
    const xPixel = tilePos[0] + x;
    const yPixel = tilePos[1] + y;
    const heightMask = this.heightMasks.get(tileSet);
    const iPixel = (xPixel + yPixel * heightMask.width) * 4;
    return (heightMask.data[iPixel + 0] << 24) + (heightMask.data[iPixel + 1] << 16) + (heightMask.data[iPixel + 2] << 8) + (heightMask.data[iPixel + 3] << 0);
  }
  checkEmpty(tileNumber) {
    if (this.emptyCache.has(tileNumber)) {
      return this.emptyCache.get(tileNumber);
    }
    const tile = this.getTile(tileNumber);
    const tileSet = this.getTileset(tileNumber);
    const mapData = this.mapData;
    const blockSize = mapData.tilewidth;
    const tileCoords = this.getTile(tileNumber);
    const tilePos = [tileCoords[0] * blockSize, tileCoords[1] * blockSize];
    for (let x = 0; x < blockSize; x++) for (let y = 0; y < blockSize; y++) {
      const xPixel = tilePos[0] + x;
      const yPixel = tilePos[1] + y;
      const heightMask = this.heightMasks.get(tileSet);
      const iPixel = (xPixel + yPixel * heightMask.width) * 4;
      if (heightMask.data[iPixel + 3] > 0) {
        this.emptyCache.set(tileNumber, false);
        return false;
      }
    }
    this.emptyCache.set(tileNumber, true);
    return true;
  }
  checkFull(tileNumber) {
    if (this.solidCache.has(tileNumber)) {
      return this.solidCache.get(tileNumber);
    }
    const tile = this.getTile(tileNumber);
    const tileSet = this.getTileset(tileNumber);
    const mapData = this.mapData;
    const blockSize = mapData.tilewidth;
    const tileCoords = this.getTile(tileNumber);
    const tilePos = [tileCoords[0] * blockSize, tileCoords[1] * blockSize];
    for (let x = 0; x < blockSize; x++) for (let y = 0; y < blockSize; y++) {
      const xPixel = tilePos[0] + x;
      const yPixel = tilePos[1] + y;
      const heightMask = this.heightMasks.get(tileSet);
      const iPixel = (xPixel + yPixel * heightMask.width) * 4;
      if (heightMask.data[iPixel + 3] < 255) {
        this.solidCache.set(tileNumber, false);
        return false;
      }
    }
    this.solidCache.set(tileNumber, true);
    return true;
  }
  getTileset(tileNumber) {
    tileNumber = Number(tileNumber);
    const cache = this.tileSetCache;
    if (cache.has(tileNumber)) {
      const cached = cache.get(tileNumber);
      if (this.replacements.has(cached.original)) {
        cached.image = this.replacements.get(cached.original);
      }
      return cached;
    }
    if (!this.mapData) {
      return;
    }
    for (const i in this.mapData.tilesets) {
      const tileset = this.mapData.tilesets[i];
      if (tileNumber + 1 >= tileset.firstgid) {
        const nextTileset = this.mapData.tilesets[Number(i) + 1];
        if (nextTileset) {
          if (tileNumber + 1 < nextTileset.firstgid) {
            cache.set(tileNumber, tileset);
            if (this.replacements.has(tileset.original)) {
              tileset.image = this.replacements.get(tileset.original);
            }
            return tileset;
          }
        } else {
          cache.set(tileNumber, tileset);
          if (this.replacements.has(tileset.original)) {
            tileset.image = this.replacements.get(tileset.original);
          }
          return tileset;
        }
      }
    }
  }
  unreplace() {
    this.replacements.clear();
    this.tileCache.clear();
  }
  reset() {
    this.tileSetCache.clear();
    this.replacements.clear();
    this.tileCache.clear();
    for (let i = 0; i < this.tileLayers.length; i++) {
      const layer = this.tileLayers[i];
      layer.destroyed = false;
    }
    for (const tileset of this.mapData.tilesets) {
      tileset.image = tileset.original;
    }
    this.loadTilesets(this.mapData);
  }
  castRay(startX, startY, angle) {
    let maxDistance = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 320;
    let layerId = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
    const checkLayers = layerId instanceof Map ? new Map([...layerId.entries()].filter(x => x[1]))
    // : new Map([[this.tileLayers[0], true], [this.tileLayers[layerId], true]]);
    : new Map();
    const xOffDir = new Map();
    const yOffDir = new Map();
    if (!(layerId instanceof Map)) for (const layer of this.tileLayers) {
      if (!layer.layer || !layer.layer.meta || !layer.layer.meta.solid) {
        continue;
      }
      if (layer.layer.meta.switchable && layer.index !== layerId) {
        continue;
      }

      // if(layer.layer.meta.platform)
      // {
      // 	if(angle < 0 || angle > Math.PI)
      // 	{
      // 		continue;
      // 	}
      // }

      checkLayers.set(layer, true);
      xOffDir.set(layer.index, Math.sign(layer.layer.args.offsetX));
      yOffDir.set(layer.index, Math.sign(layer.layer.args.offsetY));
    }

    // startX = Math.trunc(startX);
    // startY = Math.trunc(startY);

    maxDistance = Math.ceil(maxDistance);
    const cos = Math.cos(angle);
    const sin = Math.sin(angle);
    const endX = startX + (Math.abs(cos) > Number.EPSILON ? cos : 0) * maxDistance;
    const endY = startY + (Math.abs(sin) > Number.EPSILON ? sin : 0) * maxDistance;
    const bs = this.blockSize;
    const dx = endX - startX;
    const dy = endY - startY;
    const ox = Math.sign(dx);
    const oy = Math.sign(dy);
    const sx = dx ? Math.hypot(1, dy / dx) : 0;
    const sy = dy ? Math.hypot(1, dx / dy) : 0;
    let currentDistance = 0;
    if (this.getSolid(startX, startY, layerId)) {
      return [startX, startY];
    }
    let initMode;
    const txy = this.coordsToTile(startX, startY, layerId) || this.coordsToTile(startX, startY, 0);
    for (const [layer, willCheck] of checkLayers) {
      if (!willCheck) {
        continue;
      }
      if (initMode = this.getTileNumber(txy[0], txy[1], layer.index)) {
        break;
      }
    }
    let modeX = initMode;
    let modeY = initMode;
    let oldModeX = false;
    let oldModeY = false;
    let bf = initMode ? 1 : 1;
    const ax = ox > 0 ? bs - startX % bs : startX % bs + 1;
    const ay = oy > 0 ? bs - startY % bs : startY % bs + 1;
    let checkX = initMode ? 0 : ax;
    let checkY = initMode ? 0 : ay;
    let rayX = checkX * sx * ox;
    let rayY = checkY * sy * oy;
    const magX = Math.abs(rayX);
    const magY = Math.abs(rayY);
    const pa = new Set();
    const pb = new Set();
    const solidsX = new Set();
    const solidsY = new Set();
    window.logPoints && console.time('rayCast');
    let iterations = 0;
    while (Math.abs(currentDistance) < maxDistance && !solidsX.size && !solidsY.size) {
      if (ox && (!oy || Math.abs(rayX) < Math.abs(rayY))) {
        const mag = Math.abs(rayX);
        let px = startX + mag * Math.cos(angle);
        let py = startY + mag * Math.sin(angle);
        if (ox > 0 && px % 1 > 0.99999) px = Math.round(px);
        if (oy > 0 && py % 1 > 0.99999) py = Math.round(py);
        if (ox < 0 && px % 1 < 0.00001) px = Math.round(px);
        if (oy < 0 && py % 1 < 0.00001) py = Math.round(py);
        const [tx, ty] = this.coordsToTile(px, py, layerId);
        oldModeX = modeX;
        for (const [layer, willCheck] of checkLayers) {
          const layerId = layer.index;
          if (!willCheck) {
            continue;
          }
          if (modeX = this.getTileNumber(tx, ty, layerId)) {
            break;
          }
          if (!modeX && (xOffDir.has(layerId) || yOffDir.has(layerId))) {
            if (modeX = this.getTileNumber(tx + -xOffDir.get(layerId), ty, layerId)) {
              break;
            }
            if (modeX = this.getTileNumber(tx, ty + -yOffDir.get(layerId), layerId)) {
              break;
            }
            if (modeX = this.getTileNumber(tx + -xOffDir.get(layerId), ty + -yOffDir.get(layerId), layerId)) {
              break;
            }
          }
        }
        bf = modeX ? 1 : bs;
        if (!modeX && oldModeX) {
          bf = ox < 0 ? (startX + -checkX + 1) % bs : bs - (startX + checkX) % bs;
        }
        window.logPoints && pa.add([px, py, `rayX tile-${tx}-${ty} mode-${modeX} bf-${bf} layer-${layerId} `]);

        // for(const layerId of checkLayers)
        // {
        // }
        if (this.getSolid(px, py, checkLayers)) {
          solidsX.add([px, py]);
          break;
        }
        currentDistance = Math.abs(rayX);
        checkX += bf;
        rayX = checkX * sx * ox;
      } else {
        const mag = Math.abs(rayY);
        let px = startX + mag * Math.cos(angle);
        let py = startY + mag * Math.sin(angle);
        if (ox > 0 && px % 1 > 0.99999) px = Math.round(px);
        if (ox < 0 && px % 1 < 0.00001) px = Math.round(px);
        if (oy > 0 && py % 1 > 0.99999) py = Math.round(py);
        if (oy < 0 && py % 1 < 0.00001) py = Math.round(py);
        const [tx, ty] = this.coordsToTile(px, py, layerId);
        oldModeY = modeY;
        for (const [layer, willCheck] of checkLayers) {
          const layerId = layer.index;
          if (!willCheck) {
            continue;
          }
          if (modeY = this.getTileNumber(tx, ty, layerId)) {
            break;
          }
          if (!modeY && (xOffDir.has(layerId) || yOffDir.has(layerId))) {
            if (modeY = this.getTileNumber(tx, ty + -yOffDir.get(layerId), layerId)) {
              break;
            }
            if (modeY = this.getTileNumber(tx + -xOffDir.get(layerId), ty, layerId)) {
              break;
            }
            if (modeY = this.getTileNumber(tx + -xOffDir.get(layerId), ty + -yOffDir.get(layerId), layerId)) {
              break;
            }
          }
        }
        bf = modeY ? 1 : bs;
        if (!modeY && oldModeY) {
          bf = oy < 0 ? (startY + -checkY + 1) % bs : bs - (startY + checkY) % bs;
        }
        window.logPoints && pb.add([px, py, `rayY tile-${tx}-${ty} mode-${modeY} bf-${bf} layer-${layerId} `]);

        // for(const layerId of checkLayers)
        // {
        // 	if(this.getSolid(px, py, layerId))
        // 	{
        // 		solidsY.add([px, py]);
        // 		break;
        // 	}
        // }
        if (this.getSolid(px, py, checkLayers)) {
          solidsY.add([px, py]);
          break;
        }
        currentDistance = Math.abs(rayY);
        checkY += bf;
        rayY = checkY * sy * oy;
      }
      iterations++;
    }
    const points = [...solidsX, ...solidsY];
    const distSquares = points.map(s => (s[0] - startX) ** 2 + (s[1] - startY) ** 2);
    const minDistSq = Math.min(...distSquares);
    const nearest = points[distSquares.indexOf(minDistSq)];
    if (nearest) {
      if (ox > 0 && nearest[0] % 1 > 0.99999) nearest[0] = Math.round(nearest[0]);
      if (ox < 0 && nearest[0] % 1 < 0.00001) nearest[0] = Math.round(nearest[0]);
      if (oy > 0 && nearest[1] % 1 > 0.99999) nearest[1] = Math.round(nearest[1]);
      if (oy < 0 && nearest[1] % 1 < 0.00001) nearest[1] = Math.round(nearest[1]);
    }
    window.logPoints && console.timeEnd('rayCast');
    window.logPoints && console.log({
      iterations
    });
    if (window.logPoints) {
      window.logPoints(startX, startY, 'start');
      window.logPoints(endX, endY, 'end');
      [...pa].map(p => window.logPoints(p[0], p[1], p[2]));
      [...pb].map(p => window.logPoints(p[0], p[1], p[2]));

      // [...solidsX].map(p => window.logPoints(p[0],p[1],p[2]));
      // [...solidsY].map(p => window.logPoints(p[0],p[1],p[2]));

      nearest && window.logPoints(nearest[0], nearest[1], 'nearest');
    }
    if (Math.sqrt(minDistSq) > maxDistance) {
      return;
    }
    return nearest;
  }
  getCollisionMap() {
    const collisionMap = new Map();
    for (const layer of this.tileLayers) {
      let solid = false;
      if (layer.name.substr(0, 9) === 'Collision') {
        solid = true;
      } else if (layer.name.substr(0, 6) === 'Moving') {
        solid = true;
      }
      collisionMap.set(layer, solid);
    }
    return collisionMap;
  }
  negSafeMod(a, b) {
    if (a >= 0) return a % b;
    return (b + a % b) % b;
  }
  get blockSize() {
    return this.mapData.tilewidth;
  }
  fromImage(url, blockSize) {
    return new Promise(accept => {
      const image = new Image();
      image.addEventListener('load', event => {
        // const heightMask = new Tag('<canvas>');

        // heightMask.width  = image.width;
        // heightMask.height = image.height;

        const tilecount = Math.floor(image.width * image.height / 32 ** 2);
        const tileset = {
          columns: Math.floor(image.width / blockSize),
          firstgid: 1,
          image: url.substr(4),
          original: url.substr(4),
          imageheight: image.height,
          imagewidth: image.width,
          margin: 0,
          name: "image-map",
          spacing: 0,
          tileheight: blockSize,
          tilewidth: blockSize,
          tilecount
        };
        const layer = {
          "data": Object.assign(Object.create(null), [...Array(tilecount)].map((_, k) => k)),
          "width": Math.floor(image.width / blockSize),
          "height": Math.floor(image.height / blockSize),
          "id": 1,
          "name": "Tile Layer 1",
          "opacity": 1,
          "properties": [{
            "name": "solid",
            "type": "bool",
            "value": true
          }],
          "type": "tilelayer",
          "visible": true,
          "x": 0,
          "y": 0
        };
        const mapData = {
          tilewidth: blockSize,
          tileheight: blockSize,
          layers: [layer],
          tilesets: [tileset],
          width: Math.floor(image.width / blockSize),
          height: Math.floor(image.height / blockSize)
        };
        this.mapData = mapData;
        console.log(mapData);
        this.loadLayers(mapData);
        this.loadTilesets(mapData).then(accept);

        // this.tileImages.set(tileset, image);

        // console.log(tileset, layer);

        // heightMask.getContext('2d').drawImage(
        // 	image, 0, 0, image.width, image.height
        // );

        // this.heightMasks.set(tileset, heightMask.getContext('2d').getImageData(0, 0, heightMask.width, heightMask.height));

        // new Elicit(url).objectUrl().then(url => tileset.image = tileset.cachedImage = url);
      }, {
        once: true
      });
      image.src = url;
    });
  }
}
exports.TileMap = TileMap;
});

;require.register("timer/Countdown.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Countdown = void 0;
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class Countdown {
  constructor(time, callback) {
    _defineProperty(this, "time", 0);
    _defineProperty(this, "callback", () => console.warn('No callback set!'));
    this.time = time;
    this.callback = callback;
  }
  extend(time) {
    this.time += time;
  }
  extendTo(time) {
    this.time = Math.max(time, this.time);
  }
  update() {
    if (this.time > 0) {
      this.time--;
    }
    if (this.time <= 0) {
      this.callback();
      this.time = 0;
    }
  }
}
exports.Countdown = Countdown;
});

;require.register("titlecard/Titlecard.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Titlecard = void 0;
var _View = require("curvature/base/View");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
const Accept = Symbol('Accept');
class Titlecard extends _View.View {
  constructor() {
    let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let parent = arguments.length > 1 ? arguments[1] : undefined;
    super(args, parent);
    _defineProperty(this, "template", require('./titlecard.html'));
    this.args.firstLine = args.firstLine || 'First Line';
    this.args.secondLine = args.secondLine || 'Second Line';
    this.args.creditLine = args.creditLine || 'Credit Line';
    this.args.actNumber = args.actNumber || 1;
    this.args.animation = 'start';
    this.played = new Promise(accept => this[Accept] = accept);
  }
  replay(updates) {
    Object.assign(this.args, updates);
    this.args.replay = 'replay';
    const playing = new Promise(accept => {
      const waitFor = this.args.waitFor || Promise.resolve();
      let timeAcc = 75;
      this.onTimeout(timeAcc, () => this.onNextFrame(() => this.args.animation = ''));
      timeAcc += 75;
      this.onTimeout(timeAcc, () => this.onNextFrame(() => this.args.animation = 'opening'));
      timeAcc += 500;
      waitFor.finally(() => {
        this.onTimeout(timeAcc, () => this.onNextFrame(() => this.args.animation = 'opening2'));
        timeAcc += 750;
        this.onTimeout(timeAcc, () => this.onNextFrame(() => this.args.animation = 'closing'));
        this.onTimeout(timeAcc, () => {
          accept([new Promise(acceptDone => this.onTimeout(timeAcc + 750, acceptDone))]);
          this[Accept]();
        });
        timeAcc += 1000;
        this.onTimeout(timeAcc, () => this.onNextFrame(() => this.args.animation = 'closed'));
        timeAcc += 2500;
        this.onTimeout(timeAcc, () => this.onNextFrame(() => {
          this.args.animation = 'done';
          this.playing = false;
        }));
      });
    });
    this.playing = playing;
  }
  play(event) {
    if (this.playing) {
      return this.playing;
    }
    const playing = new Promise(accept => {
      const waitFor = this.args.waitFor || Promise.resolve();
      let timeAcc = 750;
      this.onTimeout(timeAcc, () => this.onNextFrame(() => this.args.animation = ''));
      timeAcc += 750;
      this.onTimeout(timeAcc, () => this.onNextFrame(() => this.args.animation = 'opening'));
      timeAcc += 500;
      waitFor.finally(() => {
        this.onTimeout(timeAcc, () => this.onNextFrame(() => this.args.animation = 'opening2'));
        timeAcc += 750;
        this.onTimeout(timeAcc, () => this.onNextFrame(() => this.args.animation = 'closing'));
        this.onTimeout(timeAcc, () => {
          accept([new Promise(acceptDone => this.onTimeout(timeAcc + 750, acceptDone))]);
          this[Accept]();
        });
        timeAcc += 1000;
        timeAcc += 1000;
        this.onTimeout(timeAcc, () => this.onNextFrame(() => this.args.animation = 'closed'));
        timeAcc += 2500;
        this.onTimeout(timeAcc, () => this.onNextFrame(() => {
          this.args.animation = 'done';
          this.playing = false;
        }));
      });
    });
    this.playing = playing;

    // return playing;
  }
}
exports.Titlecard = Titlecard;
});

;require.register("titlecard/titlecard.html", function(exports, require, module) {
module.exports = "<div class = \"titlecard [[replay]] [[animation]]\">\n\n\t<div class = \"titlecard-field\"></div>\n\n\t<div class = \"titlecard-bottom-border\">\n\t\t<div class = \"titlecard-border-text\">[[creditLine]]</div>\n\t</div>\n\n\t<div class = \"titlecard-left-border\">\n\t\t<div class = \"titlecard-border-shadow\"></div>\n\t\t<div class = \"titlecard-border-color\"></div>\n\t</div>\n\n\t<div class = \"titlecard-title\">\n\n\t\t<div class = \"titlecard-title-box\">\n\n\t\t\t<div class = \"titlecard-title-line-1\">[[firstLine]]</div>\n\n\t\t\t<div class = \"titlecard-title-line-2\">\n\t\t\t\t[[secondLine]]<div class = \"titlecard-title-number\">[[actNumber]]</div>\n\t\t\t</div>\n\n\t\t</div>\n\n\t</div>\n\n</div>\n"
});

;require.register("trace/Trace.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Trace = void 0;
var _Uuid = require("curvature/base/Uuid");
var _Model = require("curvature/model/Model");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
const buildTag = document.head.querySelector('meta[name="x-build-time"]');
const buildTime = buildTag ? buildTag.getAttribute('content') : null;
class Trace extends _Model.Model {
  constructor() {
    super(...arguments);
    _defineProperty(this, "class", 'Trace');
    _defineProperty(this, "uuid", String(new _Uuid.Uuid()));
    _defineProperty(this, "created", Date.now());
    _defineProperty(this, "local", String(new Date()));
    _defineProperty(this, "tz", Intl.DateTimeFormat().resolvedOptions().timeZone);
    _defineProperty(this, "stack", '');
    _defineProperty(this, "message", '');
    _defineProperty(this, "timeStamp", null);
    _defineProperty(this, "filename", null);
    _defineProperty(this, "lineno", null);
    _defineProperty(this, "colno", null);
    _defineProperty(this, "buildTime", buildTime);
    _defineProperty(this, "replay", null);
  }
  consume(skeleton) {
    let override = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    super.consume(skeleton, override);
    this.uuid = skeleton.uuid || this.uuid || String(new _Uuid.Uuid());
  }
}
exports.Trace = Trace;
});

;require.register("trace/TraceDatabase.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TraceDatabase = void 0;
var _Database = require("curvature/model/Database");
class TraceDatabase extends _Database.Database {
  _version_1(database) {
    const errorStore = this.createObjectStore('traces', {
      keyPath: 'id',
      autoIncrement: true
    });
    errorStore.createIndex('position', ['filename', 'lineno', 'colno'], {
      unique: false
    });
    errorStore.createIndex('filename', 'uuid', {
      unique: false
    });
    errorStore.createIndex('lineno', 'lineno', {
      unique: false
    });
    errorStore.createIndex('colno', 'colno', {
      unique: false
    });
    errorStore.createIndex('created', 'created', {
      unique: false
    });
    errorStore.createIndex('uuid', 'uuid', {
      unique: true
    });
    errorStore.createIndex('id', 'id', {
      unique: true
    });
  }
}
exports.TraceDatabase = TraceDatabase;
});

;require.register("ui/CharacterString.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CharacterString = void 0;
var _View = require("curvature/base/View");
var _Bindable = require("curvature/base/Bindable");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class CharacterString extends _View.View {
  constructor() {
    let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let parent = arguments.length > 1 ? arguments[1] : undefined;
    args[_Bindable.Bindable.NoGetters] = true;
    super(args, parent);
    _defineProperty(this, "template", `<div cv-ref = "main" class = "hud-character-string [[hide]] [[color]] [[font]] [[classes]]" cv-each = "chars:char:c"><span
				class = "hud-character"
				data-type  = "[[char.type]]"
				data-value = "[[char.pos]]"
				data-index = "[[c]]"
				style      = "--value:[[char.pos]];--index:[[c]];"
			>[[char.original]]</span></div>`);
    this[_Bindable.Bindable.NoGetters] = true;
    const chars = [];
    chars[_Bindable.Bindable.NoGetters] = true;
    this.args.chars = chars;
    this.args.classes = this.args.classes || '';
    this.args.scale = this.args.scale || 1;
    const high = this.args.high;
    const med = this.args.med;
    const low = this.args.low;
    this.args.bindTo('value', v => {
      // if(Math.abs(v) < low)
      // {
      // 	this.args.color = '';
      // }
      // else if(Math.abs(v) > low)
      // {
      // 	this.args.color = 'yellow';
      // }
      // else if(Math.abs(v) > med)
      // {
      // 	this.args.color = 'orange';
      // }
      // else if(Math.abs(v) > high)
      // {
      // 	this.args.color = 'red';
      // }
      // else if(this.args.flash > 0)
      // {
      // 	this.args.color = this.args.flashColor;
      // }
      // else
      // {
      // 	this.args.color = '';
      // }

      const chars = String(v).split('').map(this.characterToModel.bind(this));
      if (chars.length < this.args.chars.length) {
        for (let i = chars.length; i < this.args.chars.length; i++) {
          this.characterToModel(-2, i);
        }

        // this.args.chars.splice(chars.length);
      }

      Object.assign(this.args.chars, chars);
    });
  }
  characterToModel(pos, i) {
    let original = pos;
    let type = 'number';
    if (pos === ' ' || Number(pos) != pos) {
      switch (pos) {
        case ' ':
          pos = -1;
          type = 'number';
          break;
        case '-':
          pos = 11;
          type = 'number';
          break;
        case ':':
          pos = 10;
          type = 'number';
          break;
        case '.':
          pos = 12;
          type = 'number';
          break;
        case '/':
          pos = 13;
          type = 'number';
          break;
        case ',':
          pos = 14;
          type = 'number';
          break;
        case '?':
          pos = 15;
          type = 'number';
          break;
        case '!':
          pos = 16;
          type = 'number';
          break;
        case '@':
          pos = 17;
          type = 'number';
          break;
        case '#':
          pos = 18;
          type = 'number';
          break;
        case '$':
          pos = 19;
          type = 'number';
          break;
        case '%':
          pos = 20;
          type = 'number';
          break;
        case '^':
          pos = 21;
          type = 'number';
          break;
        case '&':
          pos = 22;
          type = 'number';
          break;
        case '*':
          pos = 23;
          type = 'number';
          break;
        case '(':
          pos = 24;
          type = 'number';
          break;
        case ')':
          pos = 25;
          type = 'number';
          break;
        case '⏺':
          pos = 0;
          type = 'symbol2';
          break;
        case '▶':
          pos = 1;
          type = 'symbol2';
          break;
        case '⏸':
          pos = 2;
          type = 'symbol2';
          break;
        case '⏹':
          pos = 3;
          type = 'symbol2';
          break;
        case '⏮':
          pos = 4;
          type = 'symbol2';
          break;
        case '⏭':
          pos = 5;
          type = 'symbol2';
          break;
        case '\'':
          pos = 6;
          type = 'symbol2';
          break;
        case '"':
          pos = 7;
          type = 'symbol2';
          break;
        case '"':
          pos = 8;
          type = 'symbol2';
          break;
        case '=':
          pos = 9;
          type = 'symbol2';
          break;
        case '+':
          pos = 10;
          type = 'symbol2';
          break;
        case '[':
          pos = 11;
          type = 'symbol2';
          break;
        case ']':
          pos = 12;
          type = 'symbol2';
          break;
        case '{':
          pos = 13;
          type = 'symbol2';
          break;
        case '}':
          pos = 14;
          type = 'symbol2';
          break;
        case '\\':
          pos = 15;
          type = 'symbol2';
          break;
        case ';':
          pos = 16;
          type = 'symbol2';
          break;
        case '~':
          pos = 17;
          type = 'symbol2';
          break;
        case '|':
          pos = 18;
          type = 'symbol2';
          break;
        case '_':
          pos = 19;
          type = 'symbol2';
          break;
        case '>':
          pos = 20;
          type = 'symbol2';
          break;
        case '<':
          pos = 21;
          type = 'symbol2';
          break;
        case '⯇':
          pos = 22;
          type = 'symbol2';
          break;
        case '⯅':
          pos = 23;
          type = 'symbol2';
          break;
        case '⯆':
          pos = 24;
          type = 'symbol2';
          break;

        // ⯈

        case '`':
          pos = 25;
          type = 'symbol2';
          break;
        default:
          pos = String(pos).toLowerCase().charCodeAt(0) - 97;
          type = 'letter';
          break;
      }
    }
    if (this.args.chars[i]) {
      this.args.chars[i].original = original;
      this.args.chars[i].type = type;
      this.args.chars[i].pos = pos;
      return this.args.chars[i];
    }
    return {
      pos,
      type,
      original
    };
  }
}
exports.CharacterString = CharacterString;
});

;require.register("ui/ClickSwitch.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ClickSwitch = void 0;
var _View = require("curvature/base/View");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class ClickSwitch extends _View.View {
  constructor() {
    super(...arguments);
    _defineProperty(this, "template", require('./click-switch.html'));
  }
  toggle() {
    this.args.active = !this.args.active;
  }
}
exports.ClickSwitch = ClickSwitch;
});

;require.register("ui/HudFrame.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.HudFrame = void 0;
var _View = require("curvature/base/View");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class HudFrame extends _View.View {
  constructor() {
    super(...arguments);
    _defineProperty(this, "template", `<div class = "hud-frame [[type]] [[alert]]">
		<div class = "hud-value">[[value]]</div>
	</div>`);
  }
}
exports.HudFrame = HudFrame;
});

;require.register("ui/click-switch.html", function(exports, require, module) {
module.exports = "<div class = \"switch\" data-active = \"[[active]]\"  cv-on = \"click:toggle(event)\">\n\n\t<div class = \"label labelOff\">\n\t\t<img src = \"/ui/mute.svg\" />\n\t</div>\n\n\t<div class = \"slide\">\n\t\t<div class = \"head\"></div>\n\t</div>\n\n\t<div class = \"label labelOn\">\n\t\t<img src = \"/ui/unmute.svg\" />\n\t</div>\n\n</div>\n"
});

;require.register("viewport/Layer.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Layer = void 0;
var _Bindable = require("curvature/base/Bindable");
var _View = require("curvature/base/View");
var _Tag = require("curvature/base/Tag");
var _Bag = require("curvature/base/Bag");
var _TitleScreenCard = require("../intro/TitleScreenCard");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class Layer extends _View.View {
  constructor(args, parent) {
    args[_Bindable.Bindable.NoGetters] = true;
    super(args, parent);
    _defineProperty(this, "template", require('./layer.html'));
    this[_Bindable.Bindable.NoGetters] = true;
    this.args.width = args.width || 320;
    this.args.height = args.height || 200;
    this.args.blockSize = args.blockSize || 32;
    this.x = 0;
    this.y = 0;
    this.viewport = args.viewport;
    this.hidden = false;
    this.args.offsetX = 0;
    this.args.offsetY = 0;
    this.args.parallax = this.args.parallax || 0;
    this.args.layerId = 0 || this.args.layerId;
    Object.defineProperty(this, 'blocksXY', {
      value: new Map()
    });
    Object.defineProperty(this, 'blocks', {
      value: new _Bag.Bag()
    });
    Object.defineProperty(this, 'blockMeta', {
      value: new Map()
    });
    Object.defineProperty(this, 'blockSrcs', {
      value: new Map()
    });
    this.args.blocks = this.blocks.list;
    this.meta = Object.create(null);
    const viewport = this.args.viewport;
    const layers = viewport.tileMap.tileLayers;
    const layerDef = layers[this.args.layerId];
    this.setMeta(layerDef);
    if (this.meta.offsetX) {
      this.args.offsetX = this.meta.offsetX;
    }
    if (this.meta.offsetY) {
      this.args.offsetY = this.meta.offsetY;
    }
    if (this.meta.hidden) {
      this.args.hidden = this.meta.hidden;
    }
    layerDef['offsetX'] = this.args.offsetX;
    layerDef['offsetY'] = this.args.offsetY;
    layerDef.layer = this;

    // if(this.args.name.match(/^(Collision|Grinding)\s\d+/))
    // {
    // 	if(this.args.name.match(/[12]$/))
    // 	{
    // 		this.meta.switchable = true;
    // 	}

    // 	this.meta.solid = true;
    // }

    if (this.args.name.match(/^(Grinding)\s\d+/)) {
      this.meta.grinding = true;
    }
    this.offsetXChanged = 0;
    this.offsetYChanged = 0;
    this.fallSpeed = 0;
    Object.preventExtensions(this);
    const resetBlocks = () => [...this.blockMeta.values()].forEach(b => b.reset = true);
    this.args.bindTo('width', resetBlocks, {
      wait: 0
    });
    this.args.bindTo('height', resetBlocks, {
      wait: 0
    });
  }
  setMeta(layerDef) {
    let maxObjectId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    if (layerDef.properties) {
      for (const property of layerDef.properties) {
        this.meta[property.name] = property.value;
        if (property.type === 'object') {
          this.meta[property.name] += maxObjectId;
        }
      }
    }
  }
  move() {
    if (this.meta.controller === undefined) {
      return;
    }
    const viewport = this.args.viewport;
    const layers = viewport.tileMap.tileLayers;
    const layerDef = layers[this.args.layerId];
    const controller = viewport.actorsById[this.meta.controller];
    this.offsetXChanged = 0;
    this.offsetYChanged = 0;
    if (layerDef) {
      layerDef.offsetXChanged = 0;
      layerDef.offsetYChanged = 0;
    }
    if (controller) {
      if (layerDef) {
        layerDef['offsetX'] = this.args.offsetX;
        layerDef['offsetY'] = this.args.offsetY;
      }
      const changedX = (controller.args.xLayer || 0) - this.args.offsetX;
      const changedY = (controller.args.yLayer || 0) - this.args.offsetY;
      this.args.offsetX = controller.args.xLayer || 0;
      this.args.offsetY = controller.args.yLayer || 0;
      if (layerDef) {
        layerDef[`offsetXChanged`] = changedX;
        layerDef[`offsetYChanged`] = changedY;
      }
      this[`offsetXChanged`] = changedX;
      this[`offsetYChanged`] = changedY;
    } else {
      this.args.offsetX = 0;
      this.args.offsetY = 0;
    }
    this.fallSpeed = this.fallSpeed || 0;
  }
  onAttach(event) {
    const viewport = this.args.viewport;
    const layers = viewport.tileMap.tileLayers;
    const layerDef = layers[this.args.layerId];
    const controller = viewport.actorsById[this.meta.controller];
    if (!layerDef) {
      return;
    }
    this.args.bindTo('destroyed', v => {
      const viewport = this.args.viewport;
      const layers = viewport.tileMap.tileLayers;
      const layerDef = layers[this.args.layerId];
      layerDef.destroyed = !!v;
      if (controller) {
        controller.args.destroyed = !!v;
      }
    });
  }
  update(tileMap, zBuf) {
    const viewport = this.args.viewport;
    if (viewport.args.frameId % viewport.settings.frameSkip !== 0) {
      return;
    }
    if (this.args.hidden) {
      if (!this.hidden) {
        this.blocks.list.forEach(b => {
          b.style({
            display: 'none'
          });
          b.remove();
        });
        this.hidden = true;
      }
      return;
    }
    if (this.args.destroyed && this.tags.background) {
      const tileMap = viewport.tileMap;
      const layerId = this.args.layerId;
      const layers = tileMap.tileLayers;
      const layerDef = layers[layerId];
      layerDef.destroyed = true;
      this.tags.background.style({
        display: 'none'
      });
      this.args.hidden = true;
      return;
    }
    const blockSize = this.args.blockSize;
    const blocksWide = Math.ceil(this.args.width / blockSize) + 1;
    const blocksHigh = Math.ceil(this.args.height / blockSize) + 1;
    const blocksXY = this.blocksXY;
    const centerX = blocksWide / 2;
    const centerY = blocksHigh / 2;
    const blocks = this.blocks;
    const blockMetas = this.blockMeta;
    const blockSrcs = this.blockSrcs;
    const offsetX = this.args.offsetX;
    const offsetY = this.args.offsetY;
    const layerId = this.args.layerId;
    let startColumn = -1;
    let endColumn = +1 + blocksWide;
    let ii = 0;
    let willDisable = true;
    for (let i = startColumn; i < endColumn; i += Math.sign(blocksWide)) {
      const tileX = i + -Math.ceil(this.x / blockSize) + -Math.ceil(offsetX / blockSize) + (offsetX > 0 ? 1 : 0);
      for (let j = 0; j < blocksHigh; j += Math.sign(blocksHigh)) {
        const tileY = j + Math.floor(-this.y / blockSize) + (this.offsetYChange < 0 ? -Math.ceil(offsetY / blockSize) : -Math.floor(offsetY / blockSize)) + (offsetY < 0 ? -1 : 0);
        const blockId = tileMap.getTileNumber(tileX, tileY, layerId);
        const xy = `${i},${j}`;
        let block, reset;
        if (!blocksXY.has(xy) || (reset = blockMetas.get(xy).reset)) {
          if (!reset) {
            block = new _Tag.Tag(document.createElement('div'));
            const meta = Object.create(null, {
              visible: {
                value: false,
                writable: true
              },
              reset: {
                value: false,
                writable: true
              },
              src: {
                value: null,
                writable: true
              },
              x: {
                value: null,
                writable: true
              },
              y: {
                value: null,
                writable: true
              }
            });
            Object.preventExtensions(meta);
            blocksXY.set(xy, block);
            blockMetas.set(xy, meta);
          } else {
            const meta = blockMetas.get(xy);
            block = blocksXY.get(xy);
            meta.reset = false;
            meta.visible = false;
            meta.src = null;
            block.style({
              'background-image': `none`,
              display: 'none'
            });
          }
          const transX = blockSize * i;
          const transY = blockSize * j;
          const scale = '1.016';
          block.style({
            transform: `translate(${transX}px, ${transY}px) scale(${scale}, ${scale})`,
            display: 'none',
            width: blockSize + 'px',
            height: blockSize + 'px',
            position: 'absolute',
            left: 0,
            top: 0
          });
          blocks.add(block);
        } else {
          block = blocksXY.get(xy);
        }
        const blockMeta = blockMetas.get(xy);
        const covered = zBuf.get(xy);
        const isMoving = String(this.args.name).substr(0, 6) !== 'Moving';
        if (tileMap.checkEmpty(blockId) || covered > this.args.layerId && isMoving) {
          if (blockMeta.visible) {
            block.style({
              display: 'none'
            });
          }
          blockMeta.visible = false;
          blockMeta.src = null;
          continue;
        }
        if (blockId !== false && tileMap.checkFull(blockId) && isMoving) {
          zBuf.set(xy, this.args.layerId);
        }
        const tileXY = [];
        if (layerId && blockId === false) {
          tileXY[0] = -1;
          tileXY[1] = -1;
        } else {
          const t = tileMap.getTile(blockId);
          tileXY[0] = t[0];
          tileXY[1] = t[1];
          tileXY[2] = t[2];
          tileXY[3] = t[3];
          tileXY[4] = t[4];
          // Object.assign(tileXY, tileMap.getTile(blockId));
        }

        const tileset = tileXY[4];

        // const existingOffsetX = blockMeta.x;
        // const existingOffsetY = blockMeta.y;
        // const existingSrc     = blockMeta.src;

        if (tileset && tileset.meta && tileset.meta.animated) {
          var _tileset$meta$speed;
          const frames = tileset.meta.frames;
          const oneFrame = viewport.args.frameId;
          const speed = (_tileset$meta$speed = tileset.meta.speed) !== null && _tileset$meta$speed !== void 0 ? _tileset$meta$speed : 1;
          const speedFrame = Math.floor(oneFrame / speed);
          const frameIndex = speedFrame % frames;
          tileXY[1] += tileset.meta.frameSize * frameIndex;
        }
        const blockX = -1 * (tileXY[0] * blockSize);
        const blockY = -1 * (tileXY[1] * blockSize);
        const blockSrc = tileXY[2];
        if (blockId !== false && blockId !== 0) {
          willDisable = false;
        }
        if (blockMeta.x !== blockX || blockMeta.y !== blockY || blockMeta.src !== blockSrc) {
          if (blockId !== false && blockId !== 0) {
            const blockOffset = blockX + 'px ' + blockY + 'px';
            block.style({
              display: 'initial',
              'background-position': blockOffset,
              'background-image': `url(${blockSrc})`
              // , '--screenX': (centerX - ii) / centerX
              // , '--screenY': (j - centerY) / centerY
            });

            blockMeta.visible = true;
          } else if (blockMeta.visible) {
            block.style({
              display: 'none'
            });
            blockMeta.visible = false;
          }
          blockMeta.src = blockSrc;
          blockMeta.x = blockX;
          blockMeta.y = blockY;
        }
      }
      ii++;
    }
    if (this.tags.background) {
      const background = this.tags.background;
      if (willDisable) {
        background.style({
          display: 'none'
        });
      } else if (this.tags.background) {
        background.style({
          display: 'initial',
          '--offsetX': -offsetX % blockSize,
          '--offsetY': -offsetY % blockSize,
          '--xPerspective': this.viewport.args.xPerspective,
          '--parallax': this.args.parallax
        });
      }
    }
  }
}
exports.Layer = Layer;
});

;require.register("viewport/Plot.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Plot = void 0;
var _View = require("curvature/base/View");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class Plot extends _View.View {
  constructor(args, parent) {
    super(args, parent);
    _defineProperty(this, "template", `<svg style = "--x:[[x]];--y:[[y]]" cv-each = "points:point" class = "plot">
		<circle cx="[[point.x]]" cy="[[point.y]]" r="2" class="[[point.color]]" />
	</svg>`);
    this.args.points = [];
    this.points = new Set();
    this.count = 0;
    this.max = 2048;

    // this.addPoint('50%', '50%', 'red');
  }

  clearPoints() {
    for (const point of this.args.points) {
      Object.assign(point, {
        x: 0,
        y: 0,
        color: 'hidden'
      });
    }
    this.count = 0;
  }
  addPoint(x, y, color) {
    color += ` point-${this.count}`;
    const index = this.count++ % this.max;
    if (this.args.points.length >= this.max) {
      Object.assign(this.args.points[index], {
        x,
        y,
        color
      });
      return;
    }
    this.args.points.push({
      x,
      y,
      color
    });
  }
}
exports.Plot = Plot;
});

;require.register("viewport/Viewport.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Viewport = void 0;
var _Bindable = require("curvature/base/Bindable");
var _Bag = require("curvature/base/Bag");
var _Tag = require("curvature/base/Tag");
var _Uuid = require("curvature/base/Uuid");
var _View = require("curvature/base/View");
var _Router = require("curvature/base/Router");
var _Keyboard = require("curvature/input/Keyboard");
var _Sequence = require("curvature/input/Sequence");
var _Elicit = require("curvature/net/Elicit");
var _QuadCell = require("../QuadCell");
var _Countdown = require("../timer/Countdown");
var _Bgm = require("../audio/Bgm");
var _Sfx = require("../audio/Sfx");
var _TileMap = require("../tileMap/TileMap");
var _Titlecard = require("../titlecard/Titlecard");
var _Particle3d = require("../particle/Particle3d");
var _MarbleGarden = require("../backdrop/MarbleGarden");
var _ProtoLabrynth = require("../backdrop/ProtoLabrynth");
var _MysticCave = require("../backdrop/MysticCave");
var _Series = require("../intro/Series");
var _Card = require("../intro/Card");
var _TitleScreenCard = require("../intro/TitleScreenCard");
var _ThankYouCard = require("../intro/ThankYouCard");
var _LoadingCard = require("../intro/LoadingCard");
var _BootCard = require("../intro/BootCard");
var _DebianCard = require("../intro/DebianCard");
var _WebkitCard = require("../intro/WebkitCard");
var _GamepadCard = require("../intro/GamepadCard");
var _NewgroundsCard = require("../intro/NewgroundsCard");
var _WarningCard = require("../intro/WarningCard");
var _SaneCard = require("../intro/SaneCard");
var _NoWayCard = require("../intro/NoWayCard");
var _SeanCard = require("../intro/SeanCard");
var _PauseMenu = require("../Menu/PauseMenu.js");
var _MainMenu = require("../Menu/MainMenu.js");
var _LayerSwitch = require("../actor/LayerSwitch");
var _Region = require("../region/Region");
var _CharacterString = require("../ui/CharacterString");
var _HudFrame = require("../ui/HudFrame");
var _Layer = require("./Layer");
var _Plot = require("./Plot");
var _Controller = require("../controller/Controller");
var _BackdropPalette = require("../BackdropPalette");
var _ObjectPalette = require("../ObjectPalette");
var _ScriptPalette = require("../ScriptPalette");
var _ClickSwitch = require("../ui/ClickSwitch");
var _Console = require("subspace-console/Console");
var _Input = require("../console/task/Input");
var _Impulse = require("../console/task/Impulse");
var _Mark = require("../console/task/Mark");
var _Settings = require("../console/task/Settings");
var _Move = require("../console/task/Move");
var _Pos = require("../console/task/Pos");
var _Spawn = require("../console/task/Spawn");
var _Chao = require("../console/task/Chao");
var _Socket = require("subspace-client/Socket");
var _RtcClient = require("../network/RtcClient");
var _RtcServer = require("../network/RtcServer");
var _Classifier = require("../Classifier");
var _ChatBox = require("../network/ChatBox");
var _Platformer = require("../actor/Platformer");
var _Sonic = require("../actor/Sonic");
var _Tails = require("../actor/Tails");
var _Knuckles = require("../actor/Knuckles");
var _Seymour = require("../actor/Seymour");
var _Chalmers = require("../actor/Chalmers");
var _SaveDatabase = require("../save/SaveDatabase");
var _Save = require("../save/Save");
var _TraceDatabase = require("../trace/TraceDatabase");
var _Trace = require("../trace/Trace");
var _ReplayDatabase = require("../replay/ReplayDatabase");
var _Replay = require("../replay/Replay");
var _Platformer2 = require("../behavior/Platformer");
var _Matrix = require("matrix-api/Matrix");
var _GamepadConfig = require("../controller/GamepadConfig");
var _TallyBoard = require("../tally/TallyBoard");
var _Emblem = require("../actor/Emblem");
var _Analytic = require("../lib/Analytic");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
const ActorPointCache = Symbol('actor-point-cache');
const ColCellNear = Symbol('collision-cells-near');
const ColCells = Symbol('collision-cells');
const ColCell = Symbol('collision-cell');
const Run = Symbol('run');
class Viewport extends _View.View {
  constructor() {
    let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let parent = arguments.length > 1 ? arguments[1] : undefined;
    args[_Bindable.Bindable.NoGetters] = true;
    super(args, parent);
    _defineProperty(this, "secretsFound", new Set());
    _defineProperty(this, "template", require('./viewport.html'));
    this.listen(window, 'error', event => this.handleUncaughtException(event));
    window.viewport = this;
    this.listen(window, 'focus', event => {
      if (this.focusDelay) {
        this.focusDelay();
      }
      this.focusDelay = this.onFrameOut(45, () => this.args.focusMe.args.hide = 'hide hidden');
      this.args.focusMe.args.hide = 'hide';
      this.onFrameOut(60, () => {
        if (this.args.focusMe.args.hide) {
          this.args.focusMe.args.hide = 'hide hidden';
        }
      });
      this.args.windowFocused = 'window-focused';
    });
    this.listen(window, 'blur', event => {
      if (this.focusDelay) {
        this.focusDelay();
      }
      if (this.gamepad) {
        this.args.focusMe.args.hide = 'hide hidden';
        return;
      }
      this.focusDelay = this.onFrameOut(1, () => this.args.focusMe.args.hide = '');
      this.args.focusMe.args.hide = 'hide';
      this.args.windowFocused = 'window-blurred';
    });
    this.args.windowFocused = document.hasFocus() ? 'window-focused' : 'window-blurred';
    this[_Bindable.Bindable.NoGetters] = true;
    _Router.Router.listen(this, {
      '': () => ''
    });
    this.args.agent = 'unknown';
    if (String(navigator.userAgent).match('Chrome')) {
      this.args.agent = 'chrome';
    } else if (String(navigator.userAgent).match('Firefox')) {
      this.args.agent = 'firefox';
    }
    this.args.screenEffects = new _Bag.Bag();
    this.meta = {};
    this.customColor = _Bindable.Bindable.make({
      h: 0,
      s: 1,
      v: 1
    });

    // this.args.bindTo('emblems', console.trace);

    this.args.combo = [];
    this.args.invert = '';

    // this.args.plot = new Plot;

    this.args.publishTime = 0;
    this.netId = String(new _Uuid.Uuid());

    // this.subspaceConnect();

    this.netPlayers = new Map();
    this.args.controlCardShown = new Set();
    this.bytesReceived = 0;
    this.args.mainPallet = '';
    this.args.customColor = {
      h: 0,
      s: 1,
      v: 1
    };
    this.args.inventory = [];
    this.loadSaves().then(saves => {
      if (saves.length) {
        this.currentSave = _Save.Save.from(saves[0]);
      } else {
        this.currentSave = new _Save.Save();
      }
    });
    this.characters = {
      'Sonic': _Sonic.Sonic,
      'Tails': _Tails.Tails,
      'Knuckles': _Knuckles.Knuckles,
      'platformer': _Platformer.PlatformActor
    };
    this.objectPalette = _ObjectPalette.ObjectPalette;
    this.scriptPalette = _ScriptPalette.ScriptPalette;
    this.zoneScript = null;
    this.timers = new Map();
    this.args.paused = false;
    this.args.freeze = false;
    this.quadCell = null;
    this.visible = new Set();
    this.callIntervals = new Map();
    this.callFrames = new Map();
    this.callRenderedFrames = new Map();
    this.willDetach = new Map();
    this.backdrops = new Map();
    this.checkpoints = new Map();
    this.zeroFrame = false;
    this.spawnedDefs = new Map();
    this.defsByMap = new Map();
    this.actorsByMap = new Map();

    // this.actorPointCache = new Map;

    this.args.replayQuickExit = false;
    this.args.replayBanners = true;
    this.maxObjectId = 0;
    this.maxGid = 0;
    this.args.loadingMap = false;
    this.maps = new Map();
    this.server = null;
    this.client = null;
    this.args.networked = false;
    this.args.tallyBoard = null;
    this.args.mouse = 'moved';
    this.settings = _Bindable.Bindable.make({
      audio: true,
      blur: true,
      smoothing: false,
      displace: true,
      scaling: true,
      rumble: true,
      showHud: true,
      shortcuts: true,
      showFps: true,
      debugOsd: false,
      outline: 1,
      frameSkip: 1,
      musicVol: 50,
      sfxVol: 75,
      username: 'player',
      graphicsLevel: 'High',
      matrixUrl: 'https://matrix.org/_matrix',
      matrixRoom: '!hJzXrccruagKGXTFUQ:matrix.org',
      iceServer1: 'stun:stun1.l.google.com:19302',
      iceServer2: 'stun:stun2.l.google.com:19302'
    });
    this.defaults = Object.assign({}, this.settings);
    this.args.shakeX = 0;
    this.args.shakeY = 0;
    this.args.level = '';
    let mapUrl = '';
    const inputMapUrl = _Router.Router.query.map;
    let noMenu = false;
    if (inputMapUrl && inputMapUrl.match(/^\w/)) {
      mapUrl = '/map/' + inputMapUrl;
      noMenu = true;
    }
    this.args.startFrameId = 0;
    this.args.actStartFrameId = 0;
    this.args.lastFrameId = -1;
    if (mapUrl) {
      this.loadMap({
        mapUrl
      }).catch(error => {
        console.warn(error);
        this.args.titlecard = new _Series.Series({
          cards: [new _NoWayCard.NoWayCard({
            errorString: `Cannot load map "${inputMapUrl}"!`,
            timeout: -1
          })]
        }, this);
        this.args.titlecard.play();
      });
    }
    this.sprites = new _Bag.Bag();
    this.world = null;
    let noIntro = _Router.Router.query.nointro;
    const cards = [];
    if (noMenu) {
      noIntro = true;
    }
    if (!noIntro) {
      cards.push(...this.introCards());
    } else {
      cards.push(new _MainMenu.MainMenu({
        timeout: -1
      }, this));
    }
    this.args.titlecard = new _Series.Series({
      cards
    }, this);
    if (!mapUrl) {
      this.args.titlecard.play();
    }
    this.args.noIntro = noIntro ? 'no-intro' : '';

    // const debugKeys = [
    // 	'ArrowUp'
    // 	, 'ArrowUp'
    // 	, 'ArrowDown'
    // 	, 'ArrowDown'
    // 	, 'ArrowUp'
    // 	, 'ArrowUp'
    // 	, 'ArrowUp'
    // 	, 'ArrowUp'
    // ];

    const debugKeys = ['Button12', 'Button12', 'Button13', 'Button13', 'Button12', 'Button12', 'Button12', 'Button12'];
    const debugSeq = new _Sequence.Sequence({
      keys: debugKeys,
      timing: 750
    });

    // const konamiKeys = [
    // 	'ArrowUp'
    // 	, 'ArrowUp'
    // 	, 'ArrowDown'
    // 	, 'ArrowDown'
    // 	, 'ArrowLeft'
    // 	, 'ArrowRight'
    // 	, 'ArrowLeft'
    // 	, 'ArrowRight'
    // 	, 'KeyB'
    // 	, 'KeyA'
    // 	, 'Enter'
    // ];

    const konamiKeysA = ['Button12', 'Button12', 'Button13', 'Button13', 'Button14', 'Button15', 'Button14', 'Button15', 'Button1201', 'Button14', 'Button1200'];
    const konamiKeysB = ['Button12', 'Button12', 'Button13', 'Button13', 'Button14', 'Button15', 'Button14', 'Button15', 'Button1201', 'Button1200', 'Button1209'];
    const konamiSeqA = new _Sequence.Sequence({
      keys: konamiKeysA,
      timing: 750
    });
    const konamiSeqB = new _Sequence.Sequence({
      keys: konamiKeysB,
      timing: 750
    });
    this.konamiSeqA = konamiSeqA;
    this.konamiSeqB = konamiSeqB;
    this.debugSeq = debugSeq;
    const gravityKeys = ['KeyS', 'KeyV', 'KeyG', 'KeyR', 'KeyA', 'KeyV'];
    const gravitySeq = new _Sequence.Sequence({
      keys: gravityKeys,
      timing: 750
    });
    this.sequences = [debugSeq, konamiSeqA, konamiSeqB, gravitySeq];
    this.args.debugEnabled = _Router.Router.query.debugEnabled;
    this.args.debugEditMode = false;
    this.args.debugObjectCursor = 0;
    this.args.debugObjectName = new _CharacterString.CharacterString({
      value: ''
    });
    this.debugBank = {};
    this.args.interacted = false;
    debugSeq.addEventListener('complete', event => {
      if (this.args.debugEnabled) {
        return;
      }
      this.args.debugEnabled = true;
      console.log('Debug variable set.');
      this.args.topLine.args.value = '';
      this.args.topLine.args.hide = 'hide hidden';
      this.onTimeout(1, () => {
        this.args.topLine.args.value = ' Debug variable set! ';
        this.args.topLine.args.hide = '';
      });
      this.onTimeout(1500, () => {
        this.args.topLine.args.hide = 'hide';
      });
      this.onTimeout(1750, () => {
        this.args.topLine.args.hide = 'hide hidden';
      });
    });

    // konamiSeq.addEventListener('advance', event => {
    // 	console.log(event);
    // });

    // konamiSeqA.addEventListener('cancel', event => {
    // 	console.log(event);
    // 	console.log(this.controlActor.controller);
    // });

    const konamiComplete = event => {
      if (this.args.masterCheat) {
        return;
      }
      this.args.masterCheat = true;
      this.args.topLine.args.value = '';
      this.args.topLine.args.hide = 'hide hidden';
      this.onTimeout(1, () => {
        this.args.topLine.args.value = ' Master cheat detected. ';
        this.args.topLine.args.hide = '';
      });
      console.log('Master cheat detected.');
      this.args.paused = false;
      this.onTimeout(1500, () => {
        this.args.topLine.args.value = '';
        this.args.status.args.hide = 'hide';
      });
      this.onTimeout(1750, () => {
        this.args.topLine.args.hide = 'hide hidden';
      });
    };
    konamiSeqA.addEventListener('complete', konamiComplete);
    konamiSeqB.addEventListener('complete', konamiComplete);
    gravitySeq.addEventListener('complete', event => {
      if (!this.controlActor) {
        return;
      }
      this.controlActor.gravityCheat = !this.controlActor.gravityCheat;
      this.args.topLine.args.value = '';
      this.args.topLine.args.hide = 'hide hidden';
      this.onTimeout(1, () => {
        this.args.topLine.args.value = ` Gravity cheat ${this.controlActor.gravityCheat ? 'on' : 'off'}. `;
        this.args.topLine.args.hide = '';
      });
      this.onTimeout(1500, () => {
        this.args.topLine.args.value = '';
        this.args.status.args.hide = 'hide';
      });
      this.onTimeout(1750, () => {
        this.args.topLine.args.hide = 'hide hidden';
      });
      if (this.controlActor.gravityCheat) {
        this.controlActor.args.gravity *= 0.5;
      } else {
        this.controlActor.args.gravity *= 2;
      }
    });
    this.args.pauseMenu = new _PauseMenu.PauseMenu({}, this);
    this.particleObserver = new IntersectionObserver((entries, observer) => {
      for (const entry of entries) {
        if (entry.intersectionRation === 0) {
          entry.target.style.display = 'none';
          entry.target.remove();
        } else {
          delete entry.target.style.display;
        }
      }
    }, {
      threshold: 0
    });
    this.particles = new _Bag.Bag((i, s, a) => {
      if (a === _Bag.Bag.ITEM_ADDED) {
        i.node && this.particleObserver.observe(i.node);
        i.node && this.tags.particles.appendChild(i.node);
      } else if (a === _Bag.Bag.ITEM_REMOVED) {
        if (i.preserve) {
          i.node.remove();
        } else {
          i.remove();
        }
      }
    });
    this[Run] = 0;
    this.effects = new _Bag.Bag();
    this.maxCameraBound = 64;
    this.cameraBound = 64;
    this.args.particles = this.particles.list;
    this.args.effects = this.effects.list;
    this.args.maxFps = 69;
    this.args.currentActor = '';
    this.args.xMouse = 0;
    this.args.YMouse = 0;
    this.args.xMouseOffset = 0;
    this.args.YMouseOffset = 0;
    this.mouseState = {
      position: [0, 0],
      buttons: []
    };
    this.args.xOffset = 0.5;
    this.args.yOffset = 0.5;
    this.args.xOffsetTarget = 0.5;
    this.args.yOffsetTarget = 0.75;
    this.args.topLine = new _CharacterString.CharacterString({
      value: ''
    });
    this.args.status = new _CharacterString.CharacterString({
      value: ''
    });
    this.args.focusMe = new _CharacterString.CharacterString({
      value: ''
    });
    this.args.topLine.args.hide = 'hide hidden';
    this.args.status.args.hide = 'hide hidden';
    this.args.focusMe.args.hide = 'hide hidden';
    this.args.labelChar = new _CharacterString.CharacterString({
      value: 'Char: '
    });
    this.args.labelX = new _CharacterString.CharacterString({
      value: 'x pos: '
    });
    this.args.labelY = new _CharacterString.CharacterString({
      value: 'y pos: '
    });
    this.args.demoIndicator = null;
    this.args.labelGround = new _CharacterString.CharacterString({
      value: 'Grounded: '
    });
    this.args.labelCamera = new _CharacterString.CharacterString({
      value: 'Camera: '
    });
    this.args.labelAngle = new _CharacterString.CharacterString({
      value: 'Gnd theta: '
    });
    this.args.labelGSpeed = new _CharacterString.CharacterString({
      value: 'Gnd spd: '
    });
    this.args.labelXSpeed = new _CharacterString.CharacterString({
      value: 'X air spd: '
    });
    this.args.labelYSpeed = new _CharacterString.CharacterString({
      value: 'Y air spd: '
    });
    this.args.labelLayer = new _CharacterString.CharacterString({
      value: 'Layer: '
    });
    this.args.labelMode = new _CharacterString.CharacterString({
      value: 'Mode: '
    });
    this.args.labelActors = new _CharacterString.CharacterString({
      value: 'Actors: '
    });
    this.args.labelRegions = new _CharacterString.CharacterString({
      value: 'Regions: '
    });
    this.args.labelFrame = new _CharacterString.CharacterString({
      value: 'Frame ID: '
    });
    this.args.labelIgnore = new _CharacterString.CharacterString({
      value: 'Ignore: '
    });
    this.args.labelFps = new _CharacterString.CharacterString({
      value: 'FPS: '
    });
    this.args.labelAirAngle = new _CharacterString.CharacterString({
      value: 'Air theta: '
    });
    this.args.char = new _CharacterString.CharacterString({
      value: '...'
    });
    this.args.xPos = new _CharacterString.CharacterString({
      value: 0
    });
    this.args.yPos = new _CharacterString.CharacterString({
      value: 0
    });
    this.args.layer = new _CharacterString.CharacterString({
      value: 0
    });
    this.args.gSpeed = new _CharacterString.CharacterString({
      value: 0,
      high: 199,
      med: 99,
      low: 49
    });
    this.args.ground = new _CharacterString.CharacterString({
      value: ''
    });
    this.args.xSpeed = new _CharacterString.CharacterString({
      value: 0
    });
    this.args.ySpeed = new _CharacterString.CharacterString({
      value: 0
    });
    this.args.mode = new _CharacterString.CharacterString({
      value: 0
    });
    this.args.angle = new _CharacterString.CharacterString({
      value: 0
    });
    this.args.ignore = new _CharacterString.CharacterString({
      value: 0
    });
    this.args.actorCount = new _CharacterString.CharacterString({
      value: 0
    });
    this.args.regionCount = new _CharacterString.CharacterString({
      value: 0
    });
    this.args.xPerspective = 0;
    this.args.cameraMode = new _CharacterString.CharacterString({
      value: 0
    });
    this.args.airAngle = new _CharacterString.CharacterString({
      value: 0
    });
    this.args.nowPlaying = new _CharacterString.CharacterString({
      value: 'Now playing'
    });
    this.args.trackName = new _CharacterString.CharacterString({
      value: ''
    });
    this.args.hideNowPlaying = 'hide-now-playing';
    this.args.hiddenNowPlaying = 'hidden-now-playing';
    _Sfx.Sfx.addEventListener('play', event => {
      if (!this.args.audio) {
        event.preventDefault();
      }
    });
    _Bgm.Bgm.addEventListener('play', event => {
      this.bgm = this.meta.bgm;
      if (!this.args.audio) {
        event.preventDefault();
        this.args.hideNowPlaying = 'hide-now-playing';
        this.onFrameOut(60, () => {
          if (this.args.hideNowPlaying) this.args.hiddenNowPlaying = 'hidden-now-playing';
        });
        return;
      }
      if (!event.detail) {
        this.args.trackName.args.value = '';
        this.args.audioComment = '';
        this.args.hideNowPlaying = 'hide-now-playing';
        this.args.hiddenNowPlaying = 'hidden-now-playing';
        return;
      } else {
        this.args.trackName.args.value = event.detail.TIT2 + ' by ' + event.detail.TPE1;
        this.args.audioComment = event.detail.COMM;
        const secret = Math.random();
        this.args.secretIcon = secret > 0.99 ? 100 : secret > 0.9 ? 10 : '0';
      }
      if (this.args.trackName.args.value) {
        let played = Promise.resolve();
        if (this.args.zonecard) {
          played = this.args.zonecard.played;
        }
        played.then(() => {
          if (!this.args.started) {
            return;
          }
          this.args.hiddenNowPlaying = '';
          this.onFrameOut(60, () => this.args.hideNowPlaying = '');
          if (!this.timers.has(_Bgm.Bgm)) {
            this.timers.set(_Bgm.Bgm, new _Countdown.Countdown(600, () => {
              this.args.hideNowPlaying = 'hide-now-playing';
            }));
          } else {
            this.timers.get(_Bgm.Bgm).extendTo(600);
          }
        });
      }
    });
    _Bgm.Bgm.addEventListener('stop', event => {});
    _Bgm.Bgm.addEventListener('pause', event => {});
    _Bgm.Bgm.addEventListener('unpause', event => {
      this.args.audio || event.preventDefault();
    });
    this.args.fpsSprite = new _CharacterString.CharacterString({
      value: 0
    });
    this.args.frame = new _CharacterString.CharacterString({
      value: 0
    });
    this.args.scoreLabel = new _CharacterString.CharacterString({
      value: 'SCORE:',
      color: 'yellow'
    });
    this.args.timerLabel = new _CharacterString.CharacterString({
      value: 'TIME: ',
      color: 'yellow'
    });
    this.args.ringLabel = new _CharacterString.CharacterString({
      value: 'RINGS: ',
      color: 'yellow'
    });
    this.args.actClearLabel = new _CharacterString.CharacterString({
      value: '',
      color: 'yellow'
    });
    this.args.dialogLines = [];
    this.args.perfectBonusLabel = new _CharacterString.CharacterString({
      value: 'PERFECT BONUS: ',
      color: 'yellow'
    });
    this.args.perfectBonus = new _CharacterString.CharacterString({
      value: 0
    });
    this.args.speedBonusLabel = new _CharacterString.CharacterString({
      value: 'SPEED BONUS: ',
      color: 'yellow'
    });
    this.args.speedBonus = new _CharacterString.CharacterString({
      value: 0
    });
    this.args.skidBonusLabel = new _CharacterString.CharacterString({
      value: 'SKID BONUS: ',
      color: 'yellow'
    });
    this.args.skidBonus = new _CharacterString.CharacterString({
      value: 0
    });
    this.args.ringBonusLabel = new _CharacterString.CharacterString({
      value: 'RING BONUS: ',
      color: 'yellow'
    });
    this.args.ringBonus = new _CharacterString.CharacterString({
      value: 0
    });
    this.args.timeBonusLabel = new _CharacterString.CharacterString({
      value: 'TIME BONUS: ',
      color: 'yellow'
    });
    this.args.timeBonus = new _CharacterString.CharacterString({
      value: 0
    });
    this.args.airBonusLabel = new _CharacterString.CharacterString({
      value: 'AIR TIME: ',
      color: 'yellow'
    });
    this.args.airBonus = new _CharacterString.CharacterString({
      value: '0%'
    });
    this.args.totalBonusLabel = new _CharacterString.CharacterString({
      value: 'TOTAL: ',
      color: 'yellow'
    });
    this.args.totalBonus = new _CharacterString.CharacterString({
      value: 0
    });
    this.args.rings = new _CharacterString.CharacterString({
      value: 0
    });
    this.args.score = new _CharacterString.CharacterString({
      value: 0
    });
    this.args.timer = new _CharacterString.CharacterString({
      value: '00:00'
    });
    this.args.prompt = new _CharacterString.CharacterString({
      value: ''
    });
    this.args.ntsc = 'ntsc';
    this.args.frameId = -1;
    this.settings.bindTo('scaling', v => this.fitScale(false), {
      wait: 0
    });
    this.settings.bindTo('graphicsLevel', v => {
      switch (v) {
        case 'High':
          this.settings.displace = true;
          this.settings.scaling = true;
          this.settings.blur = true;
          break;
        case 'Medium':
          this.settings.scaling = true;
          this.settings.displace = true;
          this.settings.blur = false;
          break;
        case 'Low':
          this.settings.scaling = true;
          this.settings.displace = false;
          this.settings.blur = false;
          break;
        case 'Very Low':
          this.settings.displace = false;
          this.settings.scaling = false;
          this.settings.blur = false;
          break;
      }
      if (this.args.agent === 'firefox') {
        this.settings.displace = false;
        this.settings.blur = false;
      }
    });
    if (this.args.agent === 'firefox') {
      this.settings.displace = false;
      this.settings.blur = false;
    }
    this.settings.bindTo('displace', v => this.args.displacement = v ? 'on' : 'off');
    this.settings.bindTo('outline', v => this.args.outline = v);
    this.settings.bindTo('debugOsd', v => this.args.debugOsd = v);
    this.settings.bindTo('showHud', v => this.args.showHud = v);
    this.settings.bindTo('shortcuts', v => this.args.shortcuts = v);
    this.settings.bindTo('showFps', v => this.args.showFps = v);
    this.settings.bindTo('smoothing', v => this.args.smoothing = v);
    this.settings.bindTo('musicVol', v => _Bgm.Bgm.setVolume(v / 100));
    this.settings.bindTo('sfxVol', v => _Sfx.Sfx.setVolume(v / 100));
    this.args.emeralds = [
      // 'green'
      // , 'cyan'
      // , 'white'
      // , 'orangered'
      // , 'yellow'
      // , 'purple'
    ];
    for (const setting in this.settings) {
      const val = localStorage.getItem('sonic-3000-setting-v0.0.0=' + setting);
      try {
        var _JSON$parse;
        this.settings[setting] = (_JSON$parse = JSON.parse(val)) !== null && _JSON$parse !== void 0 ? _JSON$parse : this.settings[setting];
      } catch (e) {
        console.warn(e);
      }
    }
    this.settings.bindTo((v, k) => {
      localStorage.setItem('sonic-3000-setting-v0.0.0=' + k, JSON.stringify(v));
    });
    const urlChar = _Router.Router.query.char ? String(_Router.Router.query.char).substr(0, 1).toUpperCase() + String(_Router.Router.query.char).substr(1) : false;
    this.args.selectedChar = this.args.selectedChar || urlChar || 'Sonic';
    this.args.blockSize = 32;
    this.args.populated = false;
    this.args.willStick = false;
    this.args.stayStuck = false;
    this.args.willStick = true;
    this.args.stayStuck = true;
    this.args.scale = 1;
    this.args.tileScale = 1;
    this.args.width = 32 * 16;
    this.args.height = 32 * 9;
    this.args.bindTo('tileScale', v => {
      const x = 16;
      const y = 9;
      this.args.width = 32 * x * v;
      this.args.height = 32 * y * v;
      if (this.args.layers) for (const layer of this.args.layers) {
        layer.args.width = 32 * x * v;
        layer.args.height = 32 * y * v;
      }
      if (this.args.fgLayers) for (const layer of this.args.fgLayers) {
        layer.args.width = 32 * x * v;
        layer.args.height = 32 * y * v;
      }
      this.fitScale();
    }, {
      wait: 1
    });

    // if(Router.query.tinyScale)
    // {
    // 	this.args.width  = 32 * 8;
    // 	this.args.height = 32 * 4.5;
    // 	this.args.scale  = 4;
    // }

    // if(Router.query.noScale)
    // {
    // 	this.args.width  = 32 * 14 * 2;
    // 	this.args.height = 32 * 8  * 2;
    // 	this.args.scale  = 2;
    // }

    // if(Router.query.bigScale)
    // {
    // 	this.args.width  = 32 * 60;
    // 	this.args.height = 32 * 34;
    // 	this.args.scale  = 1;
    // }

    this.collisionCache = new Map();
    this.collisions = new Map();
    this.args.x = this.args.x || 0;
    this.args.y = this.args.y || 0;
    this.args.xDelta = this.args.x || 0;
    this.args.yDelta = this.args.y || 0;
    this.args.yDeltaDecay = 0;

    // this.args.bindTo(['x','y'], (v, k, t) => isNaN(v) && console.trace(k, v));
    // this.args.bindTo(['xOffset', 'xOffsetTarget'], (v, k, t) => isNaN(v) && console.trace(k, v));

    this.args.fgLayers = [];
    this.args.layers = [];
    this.args.animation = '';
    this.regions = new Set();
    this.spawn = new Set();
    this.auras = new Set();
    this.recent = new Set();
    this.actorsByName = {};
    this.actorsById = {};
    window.actors = this.actorsById;
    this.playable = new Set();
    this.actors = new _Bag.Bag((i, s, a) => {
      if (a == _Bag.Bag.ITEM_ADDED) {
        i.viewport = this;

        // this.quadCell.insert(i, i.args);
        // this.quadCell.insert(i, {x: i.args.x - i.args.width / 2, y: i.args.y});
        // this.quadCell.insert(i, {x: i.args.x + i.args.width / 2, y: i.args.y});

        this.setColCell(i);
        if (i instanceof _Region.Region) {
          this.regions.add(i);
        }
        if (i.controllable) {
          this.playable.add(i);
        }
        this.actorsByName[i.args.name] = i;
        this.actorsById[i.args.id] = i;
        this.objectDb.add(i);
        i.onSpawned && i.onSpawned(this);
      } else if (a == _Bag.Bag.ITEM_REMOVED) {
        i.viewport = null;
        this.playable.delete(i);
        if (i instanceof _Region.Region) {
          this.regions.delete(i);
        }
        delete this.actorsByName[i.args.name];
        delete this.actorsById[i.args.name];
        delete this.actorsById[i.args.id];
        for (const [, actors] of this.actorsByMap) {
          delete actors[i.oid];
        }
        this.recent.delete(i);
        this.auras.delete(i);
        this.updateStarted.delete(i);
        this.updateEnded.delete(i);
        this.updated.delete(i);

        // this.quadCell.remove(i);
        this.objectDb.remove(i);

        // console.log(i, i[ColCell].has(i), i[ColCell]);

        const cell = this.getColCell(i);
        if (i[ColCell]) {
          i[ColCell].delete(i);
        }
        if (i[ColCells]) {
          i[ColCells].forEach(c => c.delete(i));
        }
        if (cell) {
          cell.delete(i);
        }

        // console.log(i[ColCell].has(i));

        delete i[ColCell];
        if (!i.removed && i.firstNode && i.firstNode.isConnected) {
          i.remove();
        }
        i.onDespawned && i.onDespawned(this);
      }
    });
    const critiera = [/^Art\s+$/, /^Collision\s+$/, /^Destructible\s+$/];
    const comparator = () => {};
    this.layerDb = new _Classifier.Classifier(critiera, comparator);
    this.objectDb = new _Classifier.Classifier(Object.values(_ObjectPalette.ObjectPalette));
    this.blocks = new _Bag.Bag();
    this.args.blocks = this.blocks.list;
    this.args.actors = this.actors.list;
    this.listen(window, 'gamepadconnected', event => this.padConnected(event));
    this.listen(window, 'gamepaddisconnected', event => this.padRemoved(event));
    this.colCellDiv = 0.75 * Math.max(this.args.width, this.args.height);
    this.colCellCache = new Map();
    this.colCells = new Map();
    this[ActorPointCache] = new Map();
    this.startTime = null;
    this.args.audio = false;
    this.nextControl = false;
    this.updateStarted = new Set();
    this.updateEnded = new Set();
    this.updated = new Set();
    this.args.xBlur = 0;
    this.args.yBlur = 0;
    this.args.isReplaying = false;
    this.args.isRecording = false;
    this.args._isRecording = false;
    this.replayFrames = new Map();
    this.replayOffset = 0;
    this.replayStart = null;
    this.replay = null;
    this.maxReplayFrame = 0;
    this.lastFrame = {
      input: {},
      args: {}
    };
    this.args.standalone = '';
    this.args.fullscreen = '';
    this.args.initializing = 'initializing';
    this.args.muteSwitch = new _ClickSwitch.ClickSwitch();
    this.args.muteSwitch.args.active = false;
    this.args.bindTo('interacted', v => {
      if (!v) return;
      this.args.muteSwitch.args.active = this.getAudioSetting();
      this.args.muteSwitch.args.bindTo('active', v => this.args.audio = v);
      this.args.bindTo('audio', v => {
        var _this$meta$bgm_delay;
        localStorage.setItem('sonic-3000-audio-enabled', v);
        const frameId = this.args.frameId - this.args.startFrameId;
        this.onNextFrame(() => v ? _Sfx.Sfx.unpause() : _Sfx.Sfx.pause());
        if (frameId > ((_this$meta$bgm_delay = this.meta.bgm_delay) !== null && _this$meta$bgm_delay !== void 0 ? _this$meta$bgm_delay : 0)) {
          this.onNextFrame(() => v ? _Bgm.Bgm.unpause() : _Bgm.Bgm.pause());
        }
        this.args.muteSwitch.args.active = v;
      });
    });
    this.args.showConsole = null;
    this.listen(document, 'keydown', event => {
      if (event.key === 'Escape') {
        this.args.showConsole = false;
      }
      if (event.key === 'F10' || event.key === '`') {
        if (!this.args.subspace) {
          this.args.subspace = new _Console.Console({
            scroller: this.tags.subspace,
            path: {
              'input': _Input.Input,
              'mark': _Mark.Mark,
              'impulse': _Impulse.Impulse,
              'move': _Move.Move,
              'pos': _Pos.Pos,
              'set': _Settings.Settings,
              'spawn': _Spawn.Spawn,
              'chao': _Chao.Chao
            }
          });
        }
        if (this.args.networked) {
          this.args.showConsole = false;
        } else {
          this.args.showConsole = this.args.showConsole ? null : 'showConsole';
        }
        event.preventDefault();
      }
    });
    this.args.bindTo('shakeY', (v, k, t, d, p) => {
      if (!this.controlActor || !this.controlActor.controller || !this.controlActor.controller.rumble) {
        return;
      }
      if (Math.abs(v) > 40 && Math.abs(v) > Math.abs(p)) {
        this.controlActor.controller && this.controlActor.controller.rumble({
          duration: 4 * v,
          strongMagnitude: 1.0,
          weakMagnitude: 1.0
        });
      } else if (Math.abs(v) > 20 && Math.abs(v) > Math.abs(p)) {
        this.controlActor.controller && this.controlActor.controller.rumble({
          duration: 8 * v,
          strongMagnitude: v / 20,
          weakMagnitude: 1.0
        });
      } else if (Math.abs(v) > 1) {
        this.controlActor.controller && this.controlActor.controller.rumble({
          duration: 16 * v,
          strongMagnitude: 0.1,
          weakMagnitude: 1.0
        });
      }
    });
    this.args.bindTo('showConsole', v => {
      if (!this.args.subspace) {
        return;
      }
      if (v) {
        this.onNextFrame(() => this.args.subspace.focus());
        this.args.showConsole = 'showConsole';
      } else {
        this.onNextFrame(() => this.tags.viewport.focus());
        this.args.showConsole = null;
      }
    });
    this.controller = new _Controller.Controller({
      deadZone: 0.2
    });
    this.controller.zero();
    this.matrix = new _Matrix.Matrix(this.settings.matrixUrl, {
      interval: 0
      // , storage: localStorage
    });
  }

  loadWorld(_ref) {
    let {
      worldUrl,
      networked = false
    } = _ref;
    let firstMapLoaded = false;
    const loader = new _Elicit.Elicit(worldUrl);
    loader.json().then(world => {
      const maps = world.maps.sort((a, b) => {
        if (a.x === b.x) {
          return a.y - b.y;
        }
        return a.x - b.x;
      });
      let xMin = Math.min(...maps.map(m => m.x));
      let yMin = Math.min(...maps.map(m => m.y));
      let xMax = Math.max(...maps.map(m => m.x + m.width));
      let yMax = Math.max(...maps.map(m => m.y + m.height));
      for (const map of maps) {
        map.x -= xMin;
        map.y -= yMin;
      }
      const firstMap = maps.shift();
      this.loadMap({
        mapUrl: '/map/' + firstMap.fileName,
        networked
      }).then(() => {
        const blockSize = this.tileMap.mapData.tilewidth;

        // this.tileMap.offset(0, );

        // console.log(-xMin / blockSize, -yMin / blockSize);

        this.tileMap.resize(xMax, yMax);
        for (const map of maps) {
          console.log(map);
          const mapUrl = '/map/' + map.fileName;
          this.appendMap(mapUrl, map.x / blockSize, map.y / blockSize);
        }
      });
    });
  }
  loadSaves() {
    let reload = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    if (reload || !this.getSaveIndex) {
      return this.getSaveIndex = _Save.Save.index();
    }
    return this.getSaveIndex;
  }
  getZoneState(zone) {
    var _this$currentMap;
    const currentSave = this.currentSave;
    const currentZone = (_this$currentMap = this.currentMap) !== null && _this$currentMap !== void 0 ? _this$currentMap : '';
    return currentSave ? currentSave.getZoneState(zone || currentZone) : {};
  }
  getCharacterState(name) {
    const currentSave = this.currentSave;
    if (name) {
      const charState = currentSave.getCharacterState(name);
      return charState;
    }
    if (this.controlActor && this.controlActor.args.canonical) {
      const charState = currentSave.getCharacterState(this.controlActor.args.canonical);
      return charState;
    }
  }
  loadMap(_ref2) {
    let {
      mapUrl,
      networked = false,
      useCheckpoint = true
    } = _ref2;
    this.maps.clear();
    this.maps.set(mapUrl, {
      x: 0,
      y: 0
    });
    const tileMap = new _TileMap.TileMap({
      mapUrl
    });
    this.baseMap = this.currentMap = mapUrl;
    this.args.networked = networked;
    this.tileMap = tileMap;
    this.args.started = false;
    this.args.running = false;
    const load = new _LoadingCard.LoadingCard({
      timeout: -1,
      text: 'loading ... 0%'
    }, this);
    let inputType = 'kb';
    if (!this.args.selectedChar || this.args.selectedChar === 'Sonic' || this.args.selectedChar === 'Tails' || this.args.selectedChar === 'Knuckles') {
      inputType = this.args.inputType;
      if (inputType === 'input-generic') {
        inputType = 'input-xbox';
      }
      if (this.controller && this.controller.buttons && this.controller.buttons[6] && this.controller.buttons[7] && this.controller.buttons[6].time > 0 && this.controller.buttons[7].time > 0) {
        this.args.controlCardShown.delete(this.args.selectedChar);
        inputType = 'input-dreamcast';
      } else if (this.controller && this.controller.buttons && this.controller.buttons[10] && this.controller.buttons[10].time > 0) {
        this.args.controlCardShown.delete(this.args.selectedChar);
        inputType = 'input-gamecube';
      } else if (this.controller && this.controller.buttons && this.controller.buttons[8] && this.controller.buttons[8].time > 0) {
        this.args.controlCardShown.delete(this.args.selectedChar);
      }
    }
    const controllerCard = new _GamepadConfig.GamepadConfig({
      inputType,
      char: this.args.selectedChar,
      timeout: -1,
      caption: 'loading ... 0%'
    });
    tileMap.addEventListener('level-progress', event => {
      const {
        received,
        length,
        done
      } = event.detail;
      load.args.text = `loading level ... ${(done * 100).toFixed(4)}%`;
      controllerCard.args.caption = `loading level ... ${(done * 100).toFixed(4)}%`;
    });
    tileMap.addEventListener('texture-progress', event => {
      const {
        received,
        length,
        done
      } = event.detail;
      load.args.text = `loading textures ... ${(done * 100).toFixed(4)}%`;
      controllerCard.args.caption = `loading textures ... ${(done * 100).toFixed(4)}%`;
      if (done === 1) {
        load.args.text = `initializing...`;
        controllerCard.args.caption = `initializing...`;
      }
    });
    tileMap.ready.then(() => {
      const defList = Object.create(null);
      [...tileMap.getObjectDefs()].forEach(d => defList[d.oid || d.id] = d);
      this.defsByMap.set(this.currentMap, defList);
      if (this.tileMap.mapData && this.tileMap.mapData.properties) {
        for (const property of this.tileMap.mapData.properties) {
          const name = property.name.replace(/-/g, '_');
          this.meta[name] = property.value;
        }
      }
      this.args.fgLayers.length = 0;
      this.args.layers.length = 0;
      const layers = this.tileMap.tileLayers;
      const layerCount = layers.length;
      const blockSize = this.tileMap.mapData.tilewidth;
      this.args.blockSize = blockSize;
      for (let i = 0; i < layerCount; i++) {
        const layer = new _Layer.Layer({
          layerId: i,
          blockSize,
          viewport: this,
          name: layers[i].name,
          width: this.args.width,
          height: this.args.height,
          parallax: layers[i].parallaxx,
          perspective: this.args.xPerspective
        });
        if (layers[i].name.substring(0, 10) === 'Foreground') {
          this.args.fgLayers.push(layer);
        } else {
          this.args.layers.push(layer);
        }
        if (layers[i].name.substring(0, 9) === 'Collision') {
          layer.meta.solid = true;
        } else if (layers[i].name.substring(0, 6) === 'Moving' && layers[i].name.substring(0, 10) !== 'Moving Art') {
          layer.meta.solid = true;
        }
        if (this.meta.theme !== 'construct') {
          if (layers[i].name.substring(0, 9) === 'Collision') {
            layer.args.hidden = true;
          } else if (layers[i].name.substring(0, 6) === 'Moving' && layers[i].name.substring(0, 10) !== 'Moving Art') {
            layer.args.hidden = true;
          } else {
            var _layer$args$hidden;
            layer.args.hidden = (_layer$args$hidden = layer.args.hidden) !== null && _layer$args$hidden !== void 0 ? _layer$args$hidden : false;
          }
        }
      }
    });
    let waiter = new Promise(a => setTimeout(a, 7250));
    const cardShown = this.args.controlCardShown.has(this.args.selectedChar) && !this.args.networked;
    const willShowCard = !cardShown && !this.args.map && (!this.args.selectedChar || this.args.selectedChar === 'Sonic' || this.args.selectedChar === 'Tails' || this.args.selectedChar === 'Knuckles');
    if (!this.replay && willShowCard && !_Router.Router.query.map) {
      this.args.titlecard = new _Series.Series({
        cards: [controllerCard]
      }, this);
      this.args.controlCardShown.add(this.args.selectedChar);
    } else {
      this.args.titlecard = new _Series.Series({
        cards: [load]
      }, this);
      waiter = Promise.resolve();
    }
    this.args.titlecard.play();
    const all = Promise.all([tileMap.ready, waiter]);
    all.then(() => load.args.text = `starting level`);
    all.then(() => this.startLevel({
      useCheckpoint
    }));
    return all;
  }
  fullscreen() {
    this.exitFullscreen();
    this.args.focusMe.args.hide = 'hide';
    this.initScale = this.args.scale;
    this.showStatus(3500, ' hit escape to revert. ');
    this.tags.frame.node.requestFullscreen().then(res => {
      this.onTimeout(100, () => {
        this.fitScale();
        this.args.fullscreen = 'fullscreen';
      });
    }).catch(e => console.error(e));
  }
  exitFullscreen() {
    if (document.fullscreenElement) {
      document.exitFullscreen();
      this.showStatus(0, '');
      this.args.focusMe.args.hide = '';
      this.args.fullscreen = '';
      return;
    }
  }
  fitScale() {
    let fill = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    if (!this.settings.scaling) {
      this.args.scale = 1;
    } else {
      const hScale = window.innerHeight / this.args.height;
      const vScale = window.innerWidth / this.args.width;
      if (fill) {
        this.args.scale = hScale > vScale ? hScale : vScale;
      } else {
        this.args.scale = hScale > vScale ? vScale : hScale;
      }
    }
    this.tags.frame && this.tags.frame.style({
      '--width': this.args.width * this.args.tileScale,
      '--height': this.args.height * this.args.tileScale,
      '--scale': this.args.scale
    });
  }
  showStatus(timeout, text) {
    this.args.status.args.hide = '';
    this.args.status.args.value = '';
    this.args.status.args.value = text;
    if (timeout >= 0) {
      if (this.statusTimeout) {
        clearTimeout(this.statusTimeout);
        this.statusTimeout = null;
      }
      this.statusTimeout = this.onTimeout(timeout, () => {
        this.args.status.args.hide = 'hide';
      });
      this.statusTimeout = this.onTimeout(timeout * 2, () => {
        this.args.status.args.hide = 'hide hidden';
      });
    }
  }
  getAudioSetting() {
    var _localStorage$getItem;
    return !!JSON.parse((_localStorage$getItem = localStorage.getItem('sonic-3000-audio-enabled')) !== null && _localStorage$getItem !== void 0 ? _localStorage$getItem : true);
  }
  onAttached(event) {
    _Settings.Settings.viewport = this;
    _Impulse.Impulse.viewport = this;
    _Input.Input.viewport = this;
    _Mark.Mark.viewport = this;
    _Move.Move.viewport = this;
    _Pos.Pos.viewport = this;
    _Spawn.Spawn.viewport = this;
    _Chao.Chao.viewport = this;
    this.buildDetect();
    this.cpuDetect();
    this.gpuDetect();
    this.onTimeout(100, () => this.fitScale(false));
    this.onTimeout(5500, () => this.args.ntsc = '');
    const audioWasEnabled = this.getAudioSetting();
    const enableKeyboardMessage = ' Click here to enable keyboard control. ';
    const enableAudioMessage = ' Click here to enable audio. ';
    this.onTimeout(_Router.Router.query.map || _Router.Router.query.nointro ? 0 : 36000, () => {
      this.args.bindTo('interacted', v => {
        const focusMeMessage = !v && audioWasEnabled ? enableAudioMessage : enableKeyboardMessage;
        const oldMessage = this.args.focusMe.args.value;
        if (oldMessage === focusMeMessage) {
          return;
        }
        this.args.focusMe.args.value = '';
        this.args.focusMe.args.value = focusMeMessage;
      }, {
        wait: 250
      });
    });

    // this.listen(this.tags.frame, 'click', (event) => {
    // 	if(event.target === this.tags.frame.node)
    // 	{
    // 		this.tags.viewport.focus();
    // 	}
    // });

    this.settings.bindTo('blur', v => {
      if (v) {
        this.tags.blurDistance.setAttribute('style', `filter:url(#motionBlur)`);
        this.tags.blurDistanceFg.setAttribute('style', `filter:url(#motionBlur)`);
      } else {
        this.tags.blurDistance.setAttribute('style', ``);
        this.tags.blurDistanceFg.setAttribute('style', ``);
      }
    });
    this.listen(window, 'resize', event => {
      this.onTimeout(100, () => this.fitScale(false));
    });
    this.listen(document, 'fullscreenchange', event => {
      this.onTimeout(100, () => this.fitScale(false));
      if (!document.fullscreenElement) {
        this.args.scale = this.initScale;
        this.args.fullscreen = '';
        return;
      }
    });
    this.tags.frame.style({
      '--width': this.args.width,
      '--height': this.args.height,
      '--scale': this.args.scale
    });
    if (!this.startTime) {
      this.startTime = 0;
    }
    this.args.started = false;
    this.args.running = false;
    this.args.paused = false;
    this.listen(document.body, 'click', event => {
      let element = event.target;
      while (element && element.matches) {
        if (element.matches('[data-click-barrier]')) {
          return;
        }
        element = element.parentNode;
      }
      if (this.tags.viewport.contains(document.activeElement)) {
        return;
      }
      this.tags.viewport.focus();
    }, {
      capture: true
    });
    this.args.scale = this.args.scale || 1;
    const keyboard = _Keyboard.Keyboard.get();
    keyboard.listening = true;
    keyboard.focusElement = this.tags.viewport.node;
    keyboard.codes.bindTo((v, k, t, d) => {
      if (this.controller && this.controller.keyIsMapped(k)) {
        return;
      }
      if (v === -1) {
        this.sequences.map(s => s.check(k));
      }
    });
    this.tags.viewport.node.focus();
    if (0 || window.matchMedia('(display-mode: standalone)').matches || window.matchMedia('(display-mode: fullscreen)').matches) {
      this.args.standalone = 'standalone';
      document.title = 'Sonic 3000';
      this.listen(window, 'resize', () => this.fitScale(false));
      this.onTimeout(100, () => this.fitScale(false));
    }
    this.onTimeout(100, () => this.args.initializing = '');
  }
  setZoneCard() {
    let replay = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    if (!replay) {
      this.args.zonecard = new _Titlecard.Titlecard({
        waitFor: this.tileMap.ready
      }, this);
    }
    const line1 = this.meta.titlecard_title_1;
    const line2 = this.meta.titlecard_title_2;
    const author = this.meta.titlecard_author;
    const number = this.meta.titlecard_number;
    this.args.zonecard.args.firstLine = line1;
    this.args.zonecard.args.secondLine = line2;
    this.args.zonecard.args.creditLine = author;
    this.args.zonecard.args.actNumber = number;
    this.args.actName = `${line1} ${line2} ${number}`;
    if (!replay) {
      this.args.titlecard = new _Series.Series({
        cards: [this.args.zonecard]
      }, this);
      return this.args.titlecard.play();
    }
    return Promise.resolve();
  }
  fillBackground() {
    const backdropClass = _BackdropPalette.BackdropPalette[this.meta.backdrop];
    delete this.args.backdrop;
    if (backdropClass) {
      this.args.backdrop = new backdropClass();
    } else {
      this.args.backdrop = null;
    }
    this.args.theme = this.meta.theme || 'construct';
    this.args.bg = this.meta.backdrop;
  }
  startLevel() {
    let refresh = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
    performance.mark('init-start');
    this.populateMap();
    this.levelFinished = false;
    if (!this.args.isReplaying) {
      this.args._isRecording = !this.args.networked;
    }
    this.args.debugEditMode = false;
    this.clearDialog();
    this.hideDialog();
    this.args.mouse = 'hide';
    this.args.currentSheild = null;
    this.args.hasFire = false;
    this.args.hasWater = false;
    this.args.hasElectric = false;
    this.args.hasNormal = false;
    if (this.meta.zoneScript && _ScriptPalette.ScriptPalette[this.meta.zoneScript]) {
      this.zoneScript = new _ScriptPalette.ScriptPalette[this.meta.zoneScript]();
    }
    _Bgm.Bgm.stop('MENU_THEME');
    if (_Bgm.Bgm.playing && this.meta.bgm !== this.bgm) {
      _Bgm.Bgm.stop();
    }
    if (!this.meta.bgm) {
      _Bgm.Bgm.fadeOut(250);
    }
    if (!this.args.audio) {
      _Bgm.Bgm.pause();
    }
    if (refresh) {
      this.setZoneCard();
      this.zeroFrame = false;
    }
    this.fillBackground();
    if (this.args.networked && !this.remotePlayer) {
      const sonic = new _Sonic.Sonic({
        name: 'Player 1',
        id: String(new _Uuid.Uuid())
      }, this);
      const tails = new _Sonic.Sonic({
        name: 'Player 2',
        id: String(new _Uuid.Uuid())
      }, this);
      if (this.args.playerId === 1) {
        this.nextControl = sonic;
        this.remotePlayer = tails;
        tails.args.netplayer = true;
      } else if (this.args.playerId === 2) {
        this.remotePlayer = sonic;
        this.nextControl = tails;
        sonic.args.netplayer = true;
      }
      const startDef = this.defsByName.get('player-start');
      sonic.args.x = startDef.x;
      sonic.args.y = startDef.y;
      tails.args.x = startDef.x;
      tails.args.y = startDef.y;
      this.spawn.add({
        object: sonic
      });
      this.spawn.add({
        object: tails
      });
      this.auras.add(sonic);
      this.auras.add(tails);
      this.actors.add(sonic);
      this.actors.add(tails);
    }
    for (const layer of [...this.args.fgLayers, ...this.args.layers]) {
      layer.args.destroyed = false;
    }
    if (!this.args.networked) {
      const actors = this.actors.list;
      if (!this.playableIterator) {
        this.playableIterator = this.playable.entries();
      }
      if (Object.values(this.args.actors)[0] && Object.values(this.args.actors)[0].controllable) {
        this.nextControl = Object.values(this.args.actors)[0];
      }
    }
    if (this.nextControl && this.nextControl.controller) {
      this.nextControl.controller.zero();
    }
    if (this.controller) {
      this.controller.zero();
    }
    _Keyboard.Keyboard.get().reset();
    this.args.started = false;
    _Bgm.Bgm.unpause();
    this.args.zonecard.played.then(() => {
      performance.mark('init-end');
      performance.measure('init-marker', 'init-start', 'init-end');
      const zoneState = this.getZoneState();
      if (!this.replay) {
        for (const emblemId of zoneState.emblems) {
          if (!this.actorsById[emblemId]) {
            continue;
          }
          const emblem = this.actorsByMap.get(this.currentMap)[emblemId];
          if (!emblem || emblem.mapUrl !== this.currentMap || !(emblem instanceof _Emblem.Emblem)) {
            continue;
          }
          emblem.existing = 'existing';
          if (this.nextControl && !this.nextControl.args.emblems.includes(emblem)) {
            this.nextControl.args.emblems.push(emblem);
          }
        }
        for (const emerald of this.currentSave.emeralds) {
          if (!this.args.emeralds.includes(emerald)) {
            this.args.emeralds.push(emerald);
          }
        }
      }
      this.args.startFrameId = this.args.frameId - this.replayOffset;
      this.args.actStartFrameId = this.args.startFrameId;
      if (this.replayStart) {
        if (this.nextControl) {
          for (let i in this.replayStart[2]) {
            Object.assign(this.nextControl.args, this.replayStart[2][i]);
            break;
          }
          this.nextControl.controller.replay(this.replayStart[1] || {});
          this.nextControl.readInput();
        }
      } else if (_Router.Router.query.start) {
        const start = _Router.Router.query.start;
        if (start.match(/\d+(\.\d+)?,\d+(\.\d+)?/)) {
          const [x = 128, y = 128] = start.split(',');
          this.nextControl.args.x = Number(x);
          this.nextControl.args.y = Number(y);
        } else if (this.defsByName.has(start)) {
          const point = this.defsByName.get(start);
          this.nextControl.args.x = Number(point.x);
          this.nextControl.args.y = Number(point.y);
        }
        if (Number(_Router.Router.query.noClip)) {
          this.nextControl.args.float = -1;
          this.nextControl.noClip = 1;
        }
      } else if (!this.replay && !this.args.isReplaying && !this.args.isRecording && !this.args.networked) {
        this.args.demoIndicator = null;
        if (this.nextControl) {
          const storedPosition = this.getCheckpoint(this.nextControl.args.canonical);
          if (storedPosition) {
            const checkpoint = storedPosition ? this.actorsByMap.get(this.currentMap)[storedPosition.checkpointId] : null;
            if (checkpoint) {
              this.args.startFrameId = this.args.frameId - storedPosition.frames;
              this.args.actStartFrameId = this.args.startFrameId;
              checkpoint.args.wasActive = true;
              checkpoint.args.active = true;
              this.nextControl.args.x = checkpoint.x;
              this.nextControl.args.y = checkpoint.y;
              if (this.nextControl.follower) {
                this.nextControl.follower.args.x = checkpoint.x;
                this.nextControl.follower.args.y = checkpoint.y;
                this.setColCell(this.nextControl.follower);
              }
              this.args.xOffset = 0.5;
              this.args.yOffset = 0.5;
              _Bgm.Bgm.play(this.meta.bgm, {
                loop: true
              });
            }
          }
        }
      }
      if (Number(_Router.Router.query.pause)) {
        this.args.pauseMenu.args.hideMenu = 'pause-menu-hide';
        this.args.paused = Number(_Router.Router.query.pause);
      }
      if (this.nextControl.follower) {
        this.nextControl.follower.args.x = this.nextControl.x;
        this.nextControl.follower.args.y = this.nextControl.y;
        this.setColCell(this.nextControl.follower);
      }
      if (_Router.Router.query.impulse) {
        const impulse = _Router.Router.query.impulse;
        console.log(impulse);
        if (impulse.match(/-?\d+(\.\d+)?,-?\d+(\.\d+)?/)) {
          const [x = 0, y = 0] = impulse.split(',');
          console.log({
            x,
            y
          });
          this.nextControl.args.xSpeed = Number(x);
          this.nextControl.args.ySpeed = Number(y);
        }
      }
      if (_Router.Router.query.rings) {
        this.nextControl.args.rings = Number(_Router.Router.query.rings);
      }
      this.args.level = 'level';
      this.args.fade = false;
      this.args.started = true;
      this.args.running = true;
      this.startTime = Date.now();
      this.onFrameOut(30, () => this.args.fade = 'hide');
      _Analytic.Analytic.report({
        eventCategory: 'zone',
        eventAction: 'started',
        eventLabel: `${this.args.actName}`
      });
    });
  }
  finishLevel() {
    if (!this.replay) {
      this.saveReplay('#008000').catch(() => {});
    }
    this.levelFinished = true;
  }
  saveReplay(color) {
    const replay = new _Replay.Replay();
    replay.consume({
      color,
      map: this.baseMap,
      frames: [...this.replayFrames.values()]
    });
    if (replay.lastFrame - replay.firstFrame < 30) {
      return Promise.reject();
    }
    return _ReplayDatabase.ReplayDatabase.open('replays', 3).then(database => {
      delete replay.id;
      const res = database.insert('replays', replay).then(() => replay);
      this.replayFrames = new Map();
      this.replayOffset = 0;
      this.replayStart = null;
      this.replay = null;
      return res;
    });
  }
  takeInput(controller) {
    const keyboard = _Keyboard.Keyboard.get();
    keyboard.update();
    if (!this.gamepad && !this.args.cutScene) {
      controller.readInput({
        keyboard
      });
      this.args.inputType = 'input-keyboard';
    } else if (!this.args.cutScene) {
      const gamepads = navigator.getGamepads();
      const active = controller.readInput({
        keyboard,
        gamepads
      });
      for (const device of active) {
        if (device === keyboard) {
          continue;
        }
        const gamepad = device;
        if (gamepad) {
          this.gamepad = gamepad;
          const gamepadId = String(gamepad.id);
          if (gamepadId.match(/x-?bo?x/i)) {
            this.args.inputType = 'input-xbox';
          } else if (gamepadId.match(/ps[345]/i) || gamepadId.match(/playstation/i) || gamepadId.match(/duals(hock|ense)/i) || gamepadId.match(/ds[45]/i)) {
            this.args.inputType = 'input-playstation';
          } else {
            this.args.inputType = 'input-generic';
          }
        } else {
          this.args.inputName = 'keyboard';
          this.args.inputType = 'input-keyboard';
        }
      }
    } else {
      this.controlActor.args.idleTime = 0;
    }
    if (this.controlActor && this.args.debugEditMode) {
      if (controller.buttons[0] && controller.buttons[0].time === 1) {
        const defKeys = Object.keys(_ObjectPalette.ObjectPalette);
        const debugObjectType = defKeys[this.args.debugObjectCursor];
        if (!this.debugBank[debugObjectType]) {
          this.debugBank[debugObjectType] = new _ObjectPalette.ObjectPalette[debugObjectType]();
        }
        const spawnObject = this.debugBank[debugObjectType];
        this.spawn.add({
          object: spawnObject
        });
        if (spawnObject.controllable) {
          spawnObject.args.name = 'SPAWN';
          this.playable.add(spawnObject);
        }
        spawnObject[Run] = this[Run];
        spawnObject.args.x = this.controlActor.args.x;
        spawnObject.args.y = this.controlActor.args.y;
        delete this.debugBank[debugObjectType];
      }
      if (controller.buttons[1] && controller.buttons[1].time === 1) {
        this.args.debugObjectCursor++;
        const defKeys = Object.keys(_ObjectPalette.ObjectPalette);
        if (this.args.debugObjectCursor >= defKeys.length) {
          this.args.debugObjectCursor = 0;
        }
        const debugObjectType = defKeys[this.args.debugObjectCursor];
        if (!this.debugBank[debugObjectType]) {
          this.debugBank[debugObjectType] = new _ObjectPalette.ObjectPalette[debugObjectType]();
        }
        while (this.tags.spawnPreview.node.firstChild) {
          this.tags.spawnPreview.node.firstChild.remove();
        }
        this.debugBank[debugObjectType].render(this.tags.spawnPreview.node);
        this.args.debugObjectName.args.value = debugObjectType;
      }
      if (controller.buttons[2] && controller.buttons[2].time === 1) {
        this.args.debugObjectCursor--;
        const defKeys = Object.keys(_ObjectPalette.ObjectPalette);
        if (this.args.debugObjectCursor <= 0) {
          this.args.debugObjectCursor = defKeys.length - 1;
        }
        const debugObjectType = defKeys[this.args.debugObjectCursor];
        if (!this.debugBank[debugObjectType]) {
          this.debugBank[debugObjectType] = new _ObjectPalette.ObjectPalette[debugObjectType]();
        }
        while (this.tags.spawnPreview.node.firstChild) {
          this.tags.spawnPreview.node.firstChild.remove();
        }
        this.debugBank[debugObjectType].render(this.tags.spawnPreview.node);
        this.args.debugObjectName.args.value = debugObjectType;
      }
    }
    if (this.args.debugEnabled) {
      // if(!this.args.plot)
      // {
      // 	this.args.plot = new Plot;
      // }

      if (controller.buttons[8] && controller.buttons[8].time === 1) {
        this.args.debugEditMode = !this.args.debugEditMode;
        this.settings.debugOsd = this.args.debugEditMode;
      }
    }
    if (controller.buttons[2011] && controller.buttons[2011].time === 1) {
      this.fullscreen();
    }
    if (controller.buttons[2008] && controller.buttons[2008].time === 1) {
      this.args.muteSwitch.args.active = !this.args.muteSwitch.args.active;
    }
    if (controller.buttons[2009] && controller.buttons[2009].time === 1) {
      this.settings.debugOsd = !this.settings.debugOsd;
    }
    if (controller.buttons[1050] && controller.buttons[1050].time === 1) {
      if (this.args.fullscreen) {
        this.exitFullscreen();
      }
    }
    if (controller.buttons[1020] && controller.buttons[1020].time === 1) {
      if (this.args.started) {
        this.args.paused ? this.unpauseGame() : this.pauseGame();
      }
    }
    if (!this.args.networked && controller.buttons[1011] && controller.buttons[1011].time > 0) {
      this.args.pauseMenu.input(controller);
    }
    if (this.replay && this.replay.auto && controller.buttons[1209] && controller.buttons[1209].time > 0) {
      this.quit(this.args.replayQuickExit ? 2 : 1);
    }
    if (!this.args.networked && !this.args.paused) {
      if (!this.dontSwitch && controller.buttons[11] && controller.buttons[11].time === 1) {
        this.playableIterator = this.playableIterator || this.playable.entries();
        let next = this.playableIterator.next();
        if (next.done) {
          this.playableIterator = false;
          this.playableIterator = this.playable.entries();
          next = this.playableIterator.next();
        }
        if (next.value) {
          this.nextControl = next.value[0];
          this.dontSwitch = 3;
        }
      }
    }
    if (this.args.started) {
      if (this.controlActor) {
        this.args.currentSheild = this.controlActor.args.currentSheild ? this.controlActor.args.currentSheild.type : '';
      }
      const pauseButton = 9;
      if (controller.buttons[pauseButton] && controller.buttons[pauseButton].active && controller.buttons[pauseButton].time === 1) {
        if (this.args.paused) {
          this.unpauseGame();
        } else {
          this.pauseGame();
        }
      }
      if (!this.args.isReplaying && (this.args.isRecording || this.args._isRecording)) {
        if (this.args.isRecording && !this.args.demoIndicator) {
          this.args.demoIndicator = new _CharacterString.CharacterString({
            value: '⏺ REC',
            color: 'red'
          });
        }
        const frame = this.args.frameId - this.args.startFrameId;
        const input = controller.serialize();
        let args = {},
          _args = {},
          _input = {};
        if (this.controlActor) {
          args = {
            [this.controlActor.args.id]: {
              x: this.controlActor.args.x,
              y: this.controlActor.args.y,
              mode: this.controlActor.args.mode,
              falling: this.controlActor.args.falling,
              groundAngle: this.controlActor.args.groundAngle,
              gSpeed: this.controlActor.args.gSpeed,
              xSpeed: this.controlActor.args.xSpeed,
              ySpeed: this.controlActor.args.ySpeed
            }
          };
        }
        let changed = false;
        if (frame % 60 === 0 || this.replayFrames.size === 0) for (let i in args) {
          _args[i] = _args[i] || {};
          this.lastFrame.args[i] = this.lastFrame.args[i] || {};
          let _changed = false;
          for (let j in args[i]) {
            if (args[i][j] !== this.lastFrame.args[i][j]) {
              this.lastFrame.args[i][j] = _args[i][j] = args[i][j];
              changed = _changed = true;
            }
          }
          if (!_changed) {
            delete _args[i];
          }
        }
        for (let i in input) {
          _input[i] = _input[i] || {};
          this.lastFrame.input[i] = this.lastFrame.input[i] || {};
          for (let j in input[i]) {
            if (input[i][j] !== this.lastFrame.input[i][j]) {
              this.lastFrame.input[i][j] = _input[i][j] = input[i][j];
              changed = true;
            }
          }
        }
        if (_input.axes && !Object.keys(_input.axes).length) {
          delete _input.axes;
        }
        if (_input.buttons && !Object.keys(_input.buttons).length) {
          delete _input.buttons;
        } else {
          delete _input.buttons[1011];
        }
        if (changed && this.controlActor && !this.controlActor.args.dead) {
          this.replayFrames.set(frame, [frame, _input, _args]);
        }
      }
    }
    controller.update({
      gamepad: this.gamepad
    });
  }
  moveCamera() {
    if (!this.controlActor) {
      return;
    }
    if (!this.zeroFrame) {
      this.args.x = -this.controlActor.args.x;
      this.args.y = -this.controlActor.args.y;
    }
    this.zeroFrame = true;
    if (this.cameraBound <= this.maxCameraBound) {
      this.cameraBound = this.maxCameraBound;
    } else if (this.cameraBound < Infinity) {
      this.cameraBound -= 0.05 * this.cameraBound;
    } else {
      this.maxCameraBound = this.cameraBound = Math.hypot(this.args.x + this.controlActor.args.x, this.args.y + this.controlActor.args.y);
    }
    let cameraSpeed = 25;
    let actor = this.controlActor;
    let groundBias = 0;
    if (actor.args.standingOn) {
      groundBias = actor.args.standingOn.args.cameraBias;
      if (actor.args.standingOn.isVehicle) {
        actor = actor.args.standingOn;
      }
    }
    if (actor.focused) {
      if (this.cameraMode !== 'panning' && actor.args.cameraMode === 'panning') {
        const focus = actor.focused;
        this.cameraBound = this.maxCameraBound = Math.max(Math.abs(focus.x - actor.args.x), Math.abs(focus.y - actor.args.y));
        this.args.x -= actor.args.x - focus.x;
        this.args.y -= actor.args.y - focus.y;
      }
      this.cameraMode = actor.args.cameraMode;
      actor = actor.focused;
    } else {
      this.cameraMode = actor.args.cameraMode;
    }
    const highJump = actor.args.highJump;
    const deepJump = actor.args.deepJump;
    const falling = actor.args.falling;
    const fallSpeed = actor.args.ySpeed;
    switch (this.cameraMode) {
      case 'panning':
        this.args.xOffsetTarget = 0.5;
        this.args.yOffsetTarget = 0.85;
        cameraSpeed = 8;
        break;
      case 'boost-ring':
        const angle = actor.args.angle;
        if (!angle || Math.abs(angle - Math.PI) < 0.1) {
          this.args.xOffsetTarget = 0.5;
          this.args.yOffsetTarget = 0.5;
          cameraSpeed = 24;
        } else {
          this.args.xOffsetTarget = 0.5 - 0.5 * Math.cos(angle);
          this.args.yOffsetTarget = 0.5 - 0.2 * Math.sin(angle);
          cameraSpeed = 16;
        }
        break;
      case 'cross-cannon':
        this.args.xOffsetTarget = 0.5;
        this.args.yOffsetTarget = 0.4;
        cameraSpeed = 18;
        break;
      case 'cross-cannon-quick':
        this.args.xOffsetTarget = 0.5;
        this.args.yOffsetTarget = 0.4;
        cameraSpeed = 5;
        break;
      case 'cutScene':
        this.args.xOffsetTarget = [0.50, 0.25, 0.50, 0.75][actor.args.mode];
        this.args.yOffsetTarget = [0.75, 0.50, 0.25, 0.50][actor.args.mode];
        this.maxCameraBound = 64;
        cameraSpeed = 15;
        break;
      case 'corkscrew':
        this.args.xOffsetTarget = 0.5;
        this.args.yOffsetTarget = 0.75;
        this.maxCameraBound = 96;
        cameraSpeed = 64;
        break;
      case 'normal':
        this.args.xOffsetTarget = [0.50, 0.45, 0.50, 0.55][actor.args.mode];
        this.args.yOffsetTarget = [0.50, 0.50, 0.50, 0.50][actor.args.mode];
        this.maxCameraBound = actor.args.falling ? 64 : 48;
        cameraSpeed = 12;
        if (actor.args.mode === 0) {
          cameraSpeed = 9;
        }
        break;
      case 'walker':
        const xWalk = 0.50 + -0.35 * Math.sign(actor.args.direction) * (actor.args.falling ? 0.65 : 1);
        const yWalk = 0.50 + (actor.args.falling ? -0.15 : 0);
        this.args.xOffsetTarget = [xWalk, 0.45, 0.50, 0.55][actor.args.mode];
        this.args.yOffsetTarget = [yWalk, 0.50, 0.50, 0.50][actor.args.mode];
        this.maxCameraBound = 96;
        cameraSpeed = 16;
        break;
      case 'perspective':
        this.args.xOffsetTarget = [0.50, 0.60, 0.50, 0.40][actor.args.mode];
        this.args.yOffsetTarget = [0.50, 0.50, 0.50, 0.50][actor.args.mode];
        this.maxCameraBound = 96;
        cameraSpeed = 12;
        break;
      case 'climbing':
        this.args.xOffsetTarget = [0.50, 0.33, 0.50, 0.66][actor.args.mode];
        this.args.yOffsetTarget = [0.50, 0.50, 0.50, 0.50][actor.args.mode];
        this.maxCameraBound = 48;
        cameraSpeed = 24;
        break;
      case 'airplane':
        {
          const xSpeed = actor.args.xSpeed;
          const absSpeed = Math.abs(xSpeed);
          const shiftSpeed = 5;
          cameraSpeed = 20;
          const speedBias = Math.max(absSpeed / 100, 0.45) * -Math.sign(xSpeed);
          this.args.xOffsetTarget = 0.5 + speedBias;
          this.args.yOffsetTarget = 0.5;
          break;
        }

      // case 'railcar-aerial':
      // case 'railcar-normal':
      // 	this.args.xOffsetTarget = 0.5;
      // 	this.args.yOffsetTarget = 0.5;
      // 	this.maxCameraBound = 0;
      // 	cameraSpeed = 0;

      // 	break;

      case 'aerial':
        this.args.xOffsetTarget = 0.5;
        cameraSpeed = 24;
        if (!actor.args.flying && (deepJump || highJump)) {
          if (fallSpeed < 0) {
            this.args.yOffsetTarget = 0.75;
          } else {
            this.args.yOffsetTarget = 0.35;

            // cameraSpeed = 15;
          }
        } else {
          this.args.yOffsetTarget = 0.5;
        }
        break;
      case 'popping':
        this.args.xOffsetTarget = 0.5;
        this.args.yOffsetTarget = 0.25;
        this.maxCameraBound = 64;
        cameraSpeed = 6;
        break;
      case 'hooked':
        this.args.xOffsetTarget = 0.50;
        this.args.yOffsetTarget = 0.60;
        this.maxCameraBound = 1;
        cameraSpeed = 25;
        break;
      case 'tube':
        this.args.xOffsetTarget = 0.50;
        this.args.yOffsetTarget = 0.50;
        this.maxCameraBound = 64;
        cameraSpeed = 24;
        break;
      case 'cinematic':
        this.args.xOffsetTarget = 0.50;
        this.args.yOffsetTarget = 0.50;
        this.maxCameraBound = 1;
        cameraSpeed = 0;
        break;
      case 'cliff':
        this.args.xOffsetTarget = 0.50 + -0.1 * actor.args.direction;
        this.args.yOffsetTarget = 0.30;
        cameraSpeed = 9;
        break;
      case 'bridge':
        this.args.xOffsetTarget = 0.50;
        this.args.yOffsetTarget = 0.35;
        cameraSpeed = 9;
        break;
      case 'boss':
        this.args.xOffsetTarget = 0.50;
        this.args.yOffsetTarget = 0.72;
        this.maxCameraBound = 64;
        cameraSpeed = 24;
        break;
      case 'draggable':
        this.args.xOffsetTarget = 0.5;
        this.args.yOffsetTarget = 0.5;
        this.maxCameraBound = 48;
        cameraSpeed = 3;
        break;
      case 'locked':
        this.args.xOffsetTarget = 0.50;
        this.args.yOffsetTarget = 0.25;
        this.maxCameraBound = 32;
        cameraSpeed = 16;
        break;
      default:
        this.maxCameraBound = 64;
        cameraSpeed = 25;
        break;
    }
    const biasModes = ['normal', 'perspective', 'bridge', 'cliff', 'aerial', 'tube', 'hooked', 'cutScene', 'hooked', 'corkscrew'];
    if (biasModes.includes(this.cameraMode) && !actor.args.pushing && actor.args.modeTime > 0) {
      let biaser = actor;
      if (actor.args.standingOn && actor.args.standingOn.invertsBias) {
        biaser = actor.args.standingOn;
      }
      let gSpeed = biaser.args.gSpeed;
      let xSpeed = biaser.args.xSpeed;
      if (actor.args.hangingFrom) {
        xSpeed = actor.args.hangingFrom.args.xSpeed;
      }
      if (biaser.args.standingLayer) {
        gSpeed += biaser.args.standingLayer.offsetXChanged;
      }
      const grounded = !biaser.args.falling;
      const absSpeed = Math.abs(grounded ? gSpeed : xSpeed);
      const shiftSpeed = 17;
      let speedBias = Math.abs(biaser.xLast - biaser.args.x) > 1 && Math.min(absSpeed / shiftSpeed, 1) * -Math.sign(gSpeed || xSpeed);
      if (biaser !== actor) {
        speedBias *= 4;
      }
      switch (biaser.args.mode) {
        case 0:
          this.args.xOffsetTarget += speedBias * 0.4;
          break;
        case 1:
          this.args.yOffsetTarget += speedBias * 0.4;
          break;
        case 2:
          this.args.xOffsetTarget -= speedBias * 0.4;
          break;
        case 3:
          this.args.yOffsetTarget -= speedBias * 0.4;
          break;
      }
      this.args.speedBias = speedBias;
    }
    this.args.xOffsetTarget = Math.max(0, Math.min(1, this.args.xOffsetTarget));
    if (actor.args.jumping && actor.args.fallTime > 15) {
      this.maxCameraBound = 128;
      if (deepJump || highJump) {
        cameraSpeed *= 0.75;
      }
    }
    let ySpeedBias = 0;
    let ySpeedMax = 512;
    let ySpeed = 0;
    if (this.cameraMode !== 'boss' && this.cameraMode !== 'rocket' && actor.args.modeTime > 0) {
      if (!actor.args.falling && actor.args.mode === 1) {
        ySpeedMax = actor.args.gSpeedMax;
        ySpeed = actor.args.gSpeed / 12;
      } else if (!actor.args.falling && actor.args.mode === 3) {
        ySpeedMax = actor.args.gSpeedMax;
        ySpeed = -actor.args.gSpeed / 12;
      }
      if (actor.args.rolling) {
        ySpeed /= 4;
      }
      if (actor.args.falling && actor.args.ySpeed > 0) {
        if (deepJump || highJump) {
          ySpeed = actor.args.ySpeed;
        }
        if (actor.args.ySpeed > 0) {
          ySpeedBias += actor.args.ySpeed > 24 ? 0.5 : 0;
        } else {
          ySpeedBias += actor.args.deepJump || actor.args.ySpeed < -24 ? -0.5 : 0;
        }
      }
      if (actor.args.hangingFrom) {
        ySpeed = actor.args.ySpeed;
      }
      ySpeedBias += ySpeed / ySpeedMax;
      if (actor.args.hangingFrom) {
        ySpeedBias += 0.2;
      }
    }
    if (actor.args.climbing) {
      ySpeedBias = -0.33 * Math.sign(actor.args.gSpeed) * (Math.max(4, Math.abs(actor.args.gSpeed)) / 4) * (actor.args.mode === 1 ? -1 : 1);
    }
    this.args.yOffsetTarget += groundBias + actor.args.cameraBias - ySpeedBias;
    if (actor.args.mode === 0 && Math.abs(actor.args.groundAngle - -Math.PI / 4) < 0.001) {
      this.args.yOffsetTarget -= 0.25 * Math.sign(actor.args.y - actor.yLast);
    }
    if (cameraSpeed) {
      const xOffsetDiff = this.args.xOffsetTarget - this.args.xOffset;
      const yOffsetDiff = this.args.yOffsetTarget - this.args.yOffset;
      this.args.xOffset += xOffsetDiff / cameraSpeed;
      this.args.yOffset += yOffsetDiff / cameraSpeed;
    } else {
      this.args.xOffset = this.args.xOffsetTarget;
      this.args.yOffset = this.args.yOffsetTarget;
    }
    const center = actor.rotatePoint(0, -actor.args.height / 2);
    if (actor.cofocused) {
      if (!actor.cofocusPoint) {
        actor.cofocusPoint = {};
      }
      actor.cofocusPoint.x = (actor.args.x + actor.cofocused.args.x) * 0.5;
      actor.cofocusPoint.y = (actor.args.y + actor.cofocused.args.y) * 0.5;
    } else {
      actor.cofocusPoint = null;
    }
    const actorX = center[0] + (actor.cofocused ? -actor.cofocusPoint.x : -actor.args.x);
    const actorY = center[1] + (actor.cofocused ? -actor.cofocusPoint.y : -actor.args.y);
    const xNext = actorX + center[0] + this.args.width * Number(this.args.xOffset);
    const yNext = actorY + center[1] + this.args.height * Number(this.args.yOffset);
    const xDiff = this.args.x + -xNext;
    const yDiff = this.args.y + -yNext;
    const distance = Math.hypot(xDiff, yDiff);
    const angle = Math.atan2(yDiff, xDiff);
    const maxDistance = this.cameraBound;
    const dragDistance = Math.min(maxDistance, distance);
    const snapFactor = Math.abs(dragDistance / maxDistance);
    const snapFrames = this.cameraMode === 'panning' ? 6 : 12;
    const snapSpeed = dragDistance / snapFrames;
    let x = xNext + dragDistance * Math.cos(angle);
    let y = yNext + dragDistance * Math.sin(angle);
    if (snapFactor * snapSpeed > 0.1) {
      x = x - snapFactor * Math.cos(angle) * snapSpeed;
      y = y - snapFactor * Math.sin(angle) * snapSpeed / 2;
    }
    const xMin = actor.screenLock ? -(actor.screenLock.xMin + 0) : 0;
    if (x > xMin && !this.meta.wrapX) {
      x = xMin;
    }
    if (y > 0 && !this.meta.wrapY) {
      y = 0;
    }
    const playableHeight = this.meta.deathLine || this.tileMap.mapData.height * this.tileMap.mapData.tileheight;
    const xMax = actor.screenLock ? -(actor.screenLock.xMax - this.args.width) : -(this.tileMap.mapData.width * this.tileMap.mapData.tilewidth) + this.args.width;
    const yMax = -playableHeight + this.args.height;
    if (x < xMax && !this.meta.wrapX) {
      x = xMax;
    }
    if (y < yMax && !this.meta.wrapY) {
      y = yMax;
    }
    this.args.shakeX *= -0.95;
    this.args.shakeY *= -0.95;
    this.args.shakeX = Math.abs(this.args.shakeX) < 0.1 ? 0 : this.args.shakeX;
    this.args.shakeY = Math.abs(this.args.shakeY) < 0.1 ? 0 : this.args.shakeY;
    let xFine = x;
    let yFine = y;
    const prevX = this.args.x;
    const prevY = this.args.y;
    if (actor.args.dead && !actor.args.respawning) {
      xFine = x + this.args.shakeX;
      this.args.x = Number(xFine.toFixed(3));
    } else {
      xFine = x + this.args.shakeX;
      yFine = y + this.args.shakeY;
      this.args.x = Number(xFine.toFixed(3));
      this.args.y = Number(yFine.toFixed(3));
    }
    this.args.yDelta = this.args.y - prevY;
    if (Math.abs(this.args.yDelta) > 12) {
      this.args.yDeltaDecay += 0.75 * Math.sign(this.args.yDelta);
    }
    this.args.yDeltaDecay *= 0.85;
  }
  applyMotionBlur() {
    if (this.args.frameId % this.settings.frameSkip !== 0) {
      return;
    }
    const controlActor = this.controlActor;
    if (this.settings.blur && controlActor && this.tags.blur) {
      const xMoved = this.args.x - this.xPrev;
      const yMoved = this.args.y - this.yPrev;
      const blurDenominator = 6;
      let xBlur = (Number(xMoved) / blurDenominator) ** 2;
      let yBlur = (Number(yMoved) / blurDenominator) ** 2;
      const maxBlur = 32;
      xBlur = xBlur < maxBlur ? xBlur : maxBlur;
      yBlur = yBlur < maxBlur ? yBlur : maxBlur;
      let blur = Math.max(0, -1 + 0.25 * Math.hypot(xBlur, yBlur));
      const blurAngle = Math.atan2(yMoved, xMoved);
      if (this.args.frozen > 0) {
        blur = 0;
      }
      if (blur > 0.5) {
        this.tags.blurAngle.setAttribute('style', `transform:rotate(calc(1rad * ${blurAngle}))`);
        this.tags.blurAngleFg.setAttribute('style', `transform:rotate(calc(1rad * ${blurAngle}))`);
        this.tags.blurAngleCancel.setAttribute('style', `transform:rotate(calc(-1rad * ${blurAngle}))`);
        this.tags.blurAngleCancelFg.setAttribute('style', `transform:rotate(calc(-1rad * ${blurAngle}))`);
        this.tags.blur.setAttribute('stdDeviation', `${blur}, 0`);
      } else {
        this.tags.blurAngle.setAttribute('style', `transform:none;`);
        this.tags.blurAngleFg.setAttribute('style', `transform:none;`);
        this.tags.blurAngleCancel.setAttribute('style', `transform:none;`);
        this.tags.blurAngleCancelFg.setAttribute('style', `transform:none;`);
        this.tags.blur.removeAttribute('stdDeviation');
      }
      this.xPrev = this.args.x;
      this.yPrev = this.args.y;
    } else {
      this.tags.blurAngle.setAttribute('style', `transform:none;`);
      this.tags.blurAngleFg.setAttribute('style', `transform:none;`);
      this.tags.blurAngleCancel.setAttribute('style', `transform:none;`);
      this.tags.blurAngleCancelFg.setAttribute('style', `transform:none;`);
      this.tags.blur.removeAttribute('stdDeviation');
    }
  }
  updateBackground() {
    if (this.args.frameId % this.settings.frameSkip !== 0) {
      return;
    }
    let controlActor = this.controlActor;
    if (controlActor && controlActor.standingOn && controlActor.standingOn.isVehicle) {
      controlActor = this.controlActor.standingOn;
    }
    this.tags.bgFilters.style({
      '--x': this.args.x,
      '--y': this.args.y
    });
    if (this.args.plot) {
      this.args.plot.args.x = Number(this.args.x).toFixed(2);
      this.args.plot.args.y = Number(this.args.y).toFixed(2);
    }
    this.tags.content.style({
      '--xPos': this.args.x,
      '--yPos': this.args.y,
      '--xPerspective': this.args.xPerspective,
      '--outlineWidth': this.settings.outline + 'px'
    });

    // this.tags.tilt.style({
    // 	'--yDelta': this.args.yDeltaDecay
    // });

    const xMod = this.args.x <= 0 ? this.args.x % this.args.blockSize : (-this.args.blockSize + this.args.x % this.args.blockSize) % this.args.blockSize;
    const yMod = this.args.y <= 0 ? this.args.y % this.args.blockSize : (-this.args.blockSize + this.args.y % this.args.blockSize) % this.args.blockSize;
    this.tags.background.style({
      transform: `translate( ${xMod.toFixed(2)}px, ${yMod.toFixed(2)}px )`
    });
    this.tags.foreground.style({
      transform: `translate( ${xMod.toFixed(2)}px, ${yMod.toFixed(2)}px )`
    });
    this.tags.frame.style({
      '--width': this.args.width,
      '--height': this.args.height,
      '--scale': this.args.scale
    });
  }
  updateBackdrops() {
    if (this.args.frameId % this.settings.frameSkip !== 0) {
      return;
    }
    for (const [, backdrop] of this.backdrops) {
      if (!backdrop.view) {
        const args = {};
        let backdropType = '';
        for (const property of backdrop.properties) {
          if (property.name === 'backdrop') {
            backdropType = property.value;
            continue;
          }
          args[property.name] = property.value;
        }
        args.width = backdrop.width;
        args.height = backdrop.height;
        args.bX = backdrop.x;
        args.bY = backdrop.y;
        const backdropClass = _BackdropPalette.BackdropPalette[backdropType];
        if (backdropClass) {
          backdrop.view = new backdropClass(args, this);
          backdrop.view.render(this.tags.backdrops);
        }
      }
      const leftIntersect = this.args.width + -this.args.x + -backdrop.x;
      const topIntersect = this.args.height + -this.args.y + -backdrop.y;
      const rightIntersect = -(-backdrop.width + -this.args.x + -backdrop.x);
      const bottomIntersect = -(-backdrop.height + -this.args.y + -backdrop.y);
      const xMax = this.tileMap ? -(this.tileMap.mapData.width * 32) : 2 ** 9;
      const yMax = this.tileMap ? -(this.tileMap.mapData.height * 32) : 2 ** 9;
      backdrop.view && Object.assign(backdrop.view.args, {
        x: this.args.x,
        xOffset: -this.args.x + -backdrop.x,
        xPan: this.args.x + this.args.xPerspective * 1.5,
        xMax: xMax,
        y: this.args.y + backdrop.y,
        yMax: this.args.y + backdrop.y + -backdrop.view.stacked,
        stacked: -backdrop.view.stacked + 'px',
        frame: this.args.frameId,
        top: topIntersect,
        bottom: bottomIntersect
      });
    }
    const tWidth = this.tileMap.mapData.tilewidth;
    const tHeight = this.tileMap.mapData.tileheight;
    const mWidth = this.tileMap.mapData.width;
    const mHeight = this.tileMap.mapData.height;
    this.tileMap && this.tileMap.ready.then(() => {
      const xMax = this.tileMap ? -(mWidth * tHeight) : 2 ** 9;
      const yMax = this.tileMap ? -(mHeight * tHeight) : 2 ** 9;
      this.args.backdrop && Object.assign(this.args.backdrop.args, {
        x: 0,
        xPan: this.args.x + this.args.xPerspective * 1.5,
        y: this.args.y + this.args.yOffset,
        xMax: xMax !== null && xMax !== void 0 ? xMax : 0,
        yMax: yMax !== null && yMax !== void 0 ? yMax : 0,
        frame: this.args.frameId,
        stacked: -this.args.backdrop.stacked + 'px'
      });
    });
  }
  spawnFromDef(objDef) {
    const objType = objDef.type || objDef.class || objDef.name;
    if (objDef.id > this.maxObjectId) {
      this.maxObjectId = objDef.id;
    }
    if (objType === 'particle') {
      const particle = new _Particle3d.Particle3d();
      particle.style({
        '--x': objDef.x,
        '--y': objDef.y
      });
      this.particles.add(particle.node);
    }
    if (objType === 'backdrop') {
      this.backdrops.set(objDef.id, objDef);
      return;
    }
    if (!_ObjectPalette.ObjectPalette[objType]) {
      return;
    }
    const objClass = _ObjectPalette.ObjectPalette[objType];
    const rawActor = objClass.fromDef(objDef);
    rawActor[Run] = this[Run];
    rawActor[_Bindable.Bindable.NoGetters] = true;
    const actor = _Bindable.Bindable.make(rawActor);
    actor.oid = objDef.oid || objDef.id;
    actor.name = actor.name || objDef.name;
    actor.startFrame = this.args.frameId || 0;
    this.actors.add(actor);
    return actor;
  }
  spawnInitialObjects(objDefs, mapUrl) {
    const spawned = new Set();
    for (let i in objDefs) {
      this.defsByName.set(objDefs[i].name, objDefs[i]);
      this.objDefs.set(objDefs[i].id, objDefs[i]);
      const actor = this.spawnFromDef(objDefs[i]);
      if (actor) {
        actor.mapUrl = mapUrl;
        spawned.add(actor);
        if (!this.actorsByMap.has(mapUrl)) {
          this.actorsByMap.set(mapUrl, Object.create(null));
        }
        this.actorsByMap.get(mapUrl)[actor.oid] = actor;
      }
    }
    if (this.defsByName.has('player-start') && !this.args.started) {
      const start = this.defsByName.get('player-start');
      this.args.x = -start.x;
      this.args.y = -start.y;
    }
    for (const actor of this.actors.items()) {
      if (!spawned.has(actor)) {
        continue;
      }
      for (const o in actor.others) {
        actor.others[o] = this.actorsById[actor.others[o]];
      }
      if (actor.objDef && actor.objDef.properties) {
        for (const property of actor.objDef.properties) {
          if (property.type === 'object') {
            actor.otherDefs[property.name] = this.objDefs.get(property.value);
          }
        }
      }
      if (this.actorIsOnScreen(actor)) {
        actor.args.display = actor.defaultDisplay || null;
        actor.render(this.tags.actors);
      } else {
        actor.args.display = 'none';
        actor.render();
        actor.detach();
      }
      if (actor.onAttach && actor.onAttach() === false || actor.args.hidden) {
        actor.args.display = 'none';
        actor.detach();
      }
      if (actor.controllable) {
        actor.args.display = actor.defaultDisplay || null;
      }
    }
    for (const actor of this.actors.items()) {
      actor.initialize && actor.initialize();
      actor.vizi = false;
    }
    if (!this.args.started) {
      this.args.started = true;
      this.update();
      this.args.started = false;
    }
  }
  appendMap(url, x, y) {
    this.maps.set(url, {
      x,
      y
    });
    this.args.loadingMap = true;
    return this.tileMap.preloadMap(url).then(mapData => {
      const newBottom = y + mapData.height;
      if (newBottom > this.tileMap.mapData.height) {
        const yDiff = newBottom - this.tileMap.mapData.height;
        this.tileMap.resize(this.tileMap.mapData.width, newBottom);
        this.offsetMap(0, yDiff);
        y = 0;
      }
      return this.tileMap.append(url, x, y, this.maxObjectId);
    }).then(_ref3 => {
      let {
        defs,
        data
      } = _ref3;
      this.currentMap = url;
      const zoneState = this.getZoneState();
      this.controlActor.args.emblems.splice(0);
      const maxObjectId = this.maxObjectId;
      let newMaxObjectId = 0;
      for (const def of defs) {
        def.oid = def.id;
        def.id += maxObjectId;
        def.x += x * this.tileMap.mapData.tilewidth;
        def.y += y * this.tileMap.mapData.tileheight;
        newMaxObjectId = Math.max(newMaxObjectId, def.id);
        if (!def.properties) {
          continue;
        }
        for (const prop of def.properties) {
          if (prop.type === 'object') {
            prop.value += maxObjectId;
          }
        }
      }
      const defList = Object.create(null);
      [...defs].forEach(d => defList[d.oid] = d);
      this.defsByMap.set(this.currentMap, defList);
      this.maxObjectId = newMaxObjectId;
      for (const prop of Object.values(data.properties)) {
        const name = prop.name.replace(/-/g, '_');
        this.meta[name] = prop.value;
      }
      const spawn = this.spawnInitialObjects(defs, url);
      const newStart = this.defsByName.get('player-start');
      if (newStart) {
        this.storeCheckpoint(this.controlActor.args.canonical, newStart.oid || newStart.args.id);
      }
      for (const emblemId of zoneState.emblems) {
        const emblem = this.actorsByMap.get(this.currentMap)[emblemId];
        if (!emblem || emblem.mapUrl !== url) {
          continue;
        }
        emblem.existing = 'existing';
        if (this.controlActor && !this.controlActor.args.emblems.includes(emblem)) {
          this.controlActor.args.emblems.push(emblem);
        }
      }
      return spawn;
    }).finally(() => this.args.loadingMap = false);
  }
  offsetMap(x, y) {
    for (const actor of this.actors.items()) {
      actor.args.x += x * this.tileMap.blockSize;
      actor.args.y += y * this.tileMap.blockSize;
      this.setColCell(actor);
    }
    this.args.x -= x * this.tileMap.blockSize;
    this.args.y -= y * this.tileMap.blockSize;
    if (this.meta.deathLine) {
      this.meta.deathLine += y * this.tileMap.blockSize;
    }
    this.tileMap.offset(x, y);
  }
  populateMap() {
    if (this.args.populated) {
      return;
    }
    const mapWidth = this.tileMap.mapData.width * 32 + 64;
    const mapHeight = this.tileMap.mapData.height * 32 + 64;

    // this.quadCell = new QuadCell(
    // 	this.args.width * 2
    // 	, {x: mapWidth/2, y: mapHeight/2}
    // 	, {x: mapWidth, y: mapHeight}
    // );

    this.args.populated = true;
    this.defsByName = new Map();
    this.objDefs = new Map();
    for (const [id, backdrop] of this.backdrops) {
      if (backdrop.view) {
        backdrop.view.remove();
        backdrop.view = undefined;
      }
      this.backdrops.delete(id);
    }
    for (const particle of Object.entries(this.particles.list)) {
      if (particle) {
        this.particles.remove(particle);
      }
    }
    const selectedChar = String(this.args.selectedChar || _Router.Router.query.char || 'Sonic').toLowerCase();
    const charClass = _ObjectPalette.ObjectPalette[selectedChar] || _Sonic.Sonic;
    const character = new charClass({
      name: selectedChar
    }, this);

    // const objDefs = this.tileMap.getObjectDefs();

    for (const [mapUrl, objDefs] of this.defsByMap) {
      this.spawnInitialObjects(objDefs, mapUrl);
    }
    if (!this.args.networked) {
      var _startDef$z;
      let startType = 'player-start';
      if (!character.canRoll && this.defsByName.has('wide-player-start')) {
        startType = 'wide-player-start';
      }
      const startDef = this.defsByName.get(startType);
      character.args.x = startDef ? startDef.x : mapWidth / 2;
      character.args.y = startDef ? startDef.y : mapHeight / 2;
      character.args.z = startDef ? (_startDef$z = startDef.z) !== null && _startDef$z !== void 0 ? _startDef$z : 10 : 10;
      character.args.animation = 'dropping';
      const followerChar = String(this.args.followerChar || _Router.Router.query.follower || '').toLowerCase();
      if (followerChar) {
        const charClass = _ObjectPalette.ObjectPalette[followerChar] || _Tails.Tails;
        const follower = new charClass({
          following: true,
          name: followerChar,
          x: character.args.x,
          y: character.args.y,
          z: character.args.z - 1
        }, this);
        this.spawn.add({
          object: follower
        });
        this.auras.add(follower);
        this.actors.add(follower);
        character.follower = follower;
      }
      this.spawn.add({
        object: character
      });
      this.auras.add(character);
      this.actors.add(character);
      if (startDef && startDef.properties) {
        for (const property of startDef.properties) {
          character.args[property.name] = property.value;
        }
      }
      this.nextControl = character;
    }
    this.onFrameOut(1, () => {
      if (character.follower) {
        character.follower.args.x = character.args.x;
        character.follower.args.y = character.args.y;
      }
    });
    if (!this.replayStart) for (const [id, actor] of Object.entries(this.actors.list)) {
      if (!actor || actor.args.npc) {
        continue;
      }
      if (!actor.controllable) {
        continue;
      }
      const position = this.getCheckpoint(actor.args.canonical);
      if (position && position.checkpointId) {
        const checkpointDef = this.defsByMap.get(this.currentMap)[position.checkpointId];
        const checkpointObj = this.actorsByMap.get(this.currentMap)[position.checkpointId];
        if (checkpointDef) {
          actor.args.x = checkpointDef.x;
          actor.args.y = checkpointDef.y;
        }
        if (checkpointObj) {
          checkpointObj.args.active = true;
        }
      }
    }
  }
  actorIsOnScreen(actor) {
    let margin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 512;
    if (!actor) {
      return;
    }
    const width = this.args.width;
    const height = this.args.height;
    const camLeft = -this.args.x + -16 + -margin;
    const camRight = -this.args.x + 16 + margin + width;
    const camTop = -this.args.y - margin;
    const camBottom = -this.args.y + height + margin * 0.5;
    const actorWidth = actor.args.width;
    const actorTop = actor.args.y - actor.args.height;
    const actorLeft = actor.args.x - (actor.isRegion ? 0 : actorWidth / 2);
    const actorRight = actor.args.x + (actor.isRegion ? actorWidth : actorWidth / 2);
    if (camLeft > actorRight || actorLeft > camRight) {
      return false;
    }
    if (camTop > actor.args.y || actorTop > camBottom) {
      return false;
    }
    return true;
  }
  spawnActors() {
    const actorDoc = new DocumentFragment();
    const regionDoc = new DocumentFragment();
    let actorSpawned = false;
    let regionSpawned = false;
    for (const spawn of this.spawn) {
      if (spawn.frame) {
        if (spawn.frame <= this.args.frameId) {
          this.spawn.delete(spawn);
          spawn.object[_Bindable.Bindable.NoGetters] = true;
          spawn.object[Run] = this[Run];
          spawn.object.startFrame = this.args.frameId || 0;
          spawn.object.args.id = ++this.maxObjectId;
          this.actors.add(_Bindable.Bindable.make(spawn.object));
          const isRegion = spawn.object instanceof _Region.Region;
          const doc = actorDoc;
          spawn.object.render(doc);
          spawn.object.onRendered();
          if (spawn.object.onAttach && spawn.object.onAttach() === false) {
            if (!spawn.object.args.hidden) {
              spawn.object.detach();
            }
          }
          this.setColCell(spawn.object);
          actorSpawned = true;
          spawn.object.initialize && spawn.object.initialize();
        }
      } else {
        this.spawn.delete(spawn);
        spawn.object[_Bindable.Bindable.NoGetters] = true;
        spawn.object[Run] = this[Run];
        spawn.object.startFrame = this.args.frameId || 0;
        spawn.object.args.id = ++this.maxObjectId;
        this.actors.add(_Bindable.Bindable.make(spawn.object));
        spawn.object.render(actorDoc);
        spawn.object.onRendered();
        spawn.object.onAttached && spawn.object.onAttached();
        if (spawn.object.onAttach && spawn.object.onAttach() === false) {
          spawn.object.detach();
        }
        actorSpawned = true;
        spawn.object.initialize && spawn.object.initialize();
      }
    }
    if (actorSpawned) {
      this.tags.actors.append(actorDoc);
    }
    if (regionSpawned) {
      this.tags.actors.append(regionDoc);
    }
  }
  actorUpdateStart(actor) {
    if (this.updateStarted.has(actor)) {
      return;
    }
    this.updateStarted.add(actor);
    actor.updateStart();
    if (actor.colliding) {
      actor.colliding = false;
    }
    actor.moved = false;
  }
  actorUpdate(actor) {
    if (this.updated.has(actor)) {
      return;
    }
    this.updated.add(actor);
    actor.update();
  }
  actorUpdateEnd(actor) {
    if (this.updateEnded.has(actor)) {
      return;
    }
    this.updateEnded.add(actor);
    actor.args.colliding = actor.colliding;
    actor.updateEnd();
    if (actor.moved && !actor.removed) {
      this.setColCell(actor);
    }

    // this.quadCell.remove(actor, actor.args);

    // this.quadCell.insert(actor, actor.args);

    // this.quadCell.insert(actor, {x: actor.args.x - actor.args.width / 2, y: actor.args.y});
    // this.quadCell.insert(actor, {x: actor.args.x + actor.args.width / 2, y: actor.args.y});
  }

  nearbyActors(x, y) {
    let regions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    const nearbyCells = this.getNearbyColCells(x, y);
    const result = new Set();
    for (const actors of nearbyCells) {
      for (const actor of actors) {
        if (regions && !actor.isRegion) {
          continue;
        }
        result.add(actor);
      }
    }
    return result;
  }
  update() {
    const frameId = this.args.frameId - this.args.startFrameId;
    if (this.zoneScript && this.args.started && this.args.paused === false) {
      this.zoneScript.update(frameId, this);
    }
    if (this.args.started && this.meta.bgm && frameId === (this.meta.bgm_delay || 1)) {
      _Bgm.Bgm.play(this.meta.bgm, {
        loop: true
      });
    }
    if (this.socket && this.args.frameId % 120 === 0) {
      this.socket.publish('keepalive', '');
    }
    if (this.args.loadingMap) {
      return;
    }
    if (this.args.paused > 0) {
      this.args.paused--;
    }
    if (this.args.frozen > 0) {
      this.args.frozen--;
    }
    if (this.tallyBoard && !this.args.paused && this.controlActor) {
      this.tallyBoard.update(this);
      this.args.score.args.value = String(this.controlActor.args.score).padStart(4, ' ');
      if (!this.tallyBoard.done) {
        this.args.frozen = 1;
      }
    }
    const controller = this.controlActor ? this.controlActor.controller : this.controller;
    for (const b in controller.buttons) {
      if (controller.buttonIsMapped(b)) {
        continue;
      }
      if (controller.buttons[b].active && controller.buttons[b].time === 1) {
        this.debugSeq.check(`Button${b}`);
        this.konamiSeqA.check(`Button${b}`);
        this.konamiSeqB.check(`Button${b}`);
      }
    }
    if (this.args.frameId % 600 === 0) {
      ga('set', 'metric1', this.args.frameId / 60);
      if (typeof ga === 'function') {
        _Analytic.Analytic.report({
          eventCategory: 'fps-check',
          eventAction: `fps-check::${navigator.platform}::cores_${navigator.hardwareConcurrency}`,
          eventLabel: `${this.args.actName}`,
          eventValue: Math.trunc(this.args.fps),
          Value: Math.trunc(this.args.fps)
        });
      }
    }
    if (!this.args.started) {
      this.startTime = Date.now();
      if (controller) {
        this.takeInput(controller);
        if (this.args.titlecard) {
          this.args.titlecard.input(controller);
        }
      }
    }
    if (this.args.paused !== false) {
      this.takeInput(controller);
      this.args.pauseMenu.input(controller);
    }
    if (this.args.paused === false || this.args.paused > 0 || this.args.networked) {
      this.callFrameOuts();
      this.callRenderedFrameOut();
      this.callFrameIntervals();
      for (const [key, timer] of this.timers) {
        timer.update();
      }
      this.args.lastFrameId = this.args.frameId;
      if (this.args.cutScene) {
        this.args.startFrameId++;
        this.args.showHud = false;
      } else if (this.settings.showHud) {
        this.args.showHud = true;
      }
      if (!this.args.debugEditMode) {
        this.args.frameId++;
      }
      if (this.args.debugOsd) {
        this.args.frame.args.value = this.args.frameId;
      }
    }
    if (!this.args.networked && this.args.started && this.args.paused !== false && this.args.paused <= 0) {
      return;
    }
    if (!this.args.networked && this.args.frozen > 0) {
      this.args.startFrameId++;
      this.args.blur = 0;
      return;
    }
    if (!this.args.started && this.args.frameId > 0) {
      return;
    }
    if (this.tileMap && this.tileMap.mapData) {
      this.updateBackdrops();
    }
    for (const [detachee, detacher] of this.willDetach) {
      this.willDetach.delete(detachee);
      detacher();
    }
    if (!Number(this.args.rings.args.value)) {
      this.args.ringLabel.args.color = 'red-alert';
    } else {
      this.args.ringLabel.args.color = 'yellow';
    }
    this.args.fpsSprite.args.value = Number(this.args.fps).toFixed(0).padStart(2, '0');
    const time = (this.args.frameId - this.args.actStartFrameId) / 60;
    let minutes = String(Math.trunc(Math.abs(time) / 60)).padStart(2, '0');
    let seconds = String(Math.trunc(Math.abs(time) % 60)).padStart(2, '0');
    const neg = time < 0 ? '-' : '';
    if (neg) {
      minutes = Number(minutes);
    }
    this.args.timer.args.value = `${neg}${minutes}:${seconds}`;
    if (this.dontSwitch > 0) {
      this.dontSwitch--;
    }
    if (this.dontSwitch < 0) {
      this.dontSwitch = 0;
    }
    this.args.rippleFrame = this.args.frameId % 128;
    this.args.displaceWater = this.args.frameId % 128;
    this[ActorPointCache].clear();
    if (!this.args.isReplaying && !this.args.isRecording) {
      this.args.demoIndicator = null;
    }
    this.updateBackground();
    if (this.controlActor) {
      if (this.args.isReplaying) {
        const keyboard = _Keyboard.Keyboard.get();
        if (keyboard.getKeyCode('NumpadAdd') > 0) {
          this.focus();
          this.args.paused = 1;
          this.args.pauseMenu.args.hideMenu = 'pause-menu-hide';
        }
        if (!this.args.demoIndicator) {
          this.args.demoIndicator = new _CharacterString.CharacterString({
            value: '▶ PLAY',
            color: 'green'
          });
        }
        this.onFrameOut(60, () => {
          if (this.args.focusMe.args.hide) {
            this.args.focusMe.args.hide = 'hide hidden';
          }
        });
        const frameId = this.args.frameId - this.args.startFrameId;
        if (frameId < this.maxReplayFrame) {
          const actor = this.controlActor;
          this.lastInput = this.lastInput || {};
          this.lastInput.axes = this.lastInput.axes || {};
          this.lastInput.buttons = this.lastInput.buttons || {};
          if (this.replayFrames.has(frameId)) {
            const [_, input, args] = this.replayFrames.get(frameId);
            const frame = {
              frame: _,
              input,
              args
            };
            if (frame.args) {
              for (const actorId in frame.args) {
                Object.assign(actor.args, frame.args[actorId]);
                actor.args.ignore = 0;
                actor.args.respawning = false;
                actor.args.dead = false;
                actor.noClip = false;
              }
            }
            if (frame.input && frame.input.buttons) {
              delete frame.input.buttons[9];
            }
            if (frame.input) {
              Object.assign(this.lastInput.axes, frame.input.axes || {});
              Object.assign(this.lastInput.buttons, frame.input.buttons || {});
              actor.controller.replay(this.lastInput);
              actor.readInput();

              // console.log(frameId, JSON.stringify(this.lastInput));
            } else {
              actor.controller.replay(this.lastInput);
              actor.readInput();
            }
          } else {
            // console.log(frameId, JSON.stringify(this.lastInput));
            actor.controller.replay(this.lastInput);
            actor.readInput();
          }
          this.args.hasRecording = true;
          if (this.args.replayBanners && this.args.frameId - this.args.startFrameId < 5) {
            this.args.topLine.args.hide = 'hide hidden';
            this.args.status.args.hide = 'hide hidden';
            this.args.focusMe.args.hide = 'hide hidden';
            this.onTimeout(1, () => {
              // this.args.topLine.args.value = '    i cant believe its not canvas!    ';
              // this.args.topLine.args.hide = '';

              // this.args.status.args.value = '    click here to exit demo.    ';
              // this.args.status.args.hide = '';
            });
          }
        } else {
          this.args.topLine.args.hide = 'hide hidden';
          this.args.status.args.hide = 'hide hidden';
          this.replayFrames = new Map();
          this.replayOffset = 0;
          this.replayStart = null;
          // this.replay = null;

          this.args.isReplaying = false;
          this.args._isRecording = false;
          this.onFrameOut(30, () => this.quit(this.args.replayQuickExit ? 2 : 1));
        }
      } else {
        if (this.gamepad) {
          this.args.focusMe.args.hide = 'hide hidden';
        }
        this.controlActor.controller && this.takeInput(this.controlActor.controller);
        if (!this.args.cutScene) {
          this.controlActor.readInput();
        }
      }
    }
    if (this.controlActor && this.controlActor.args.respawning && !this.args.isReplaying) {
      this.replay = null;
    }
    if (!this.args.isReplaying && this.controlActor && this.controlActor.args.dead) {
      this.onFrameOut(30, () => {
        if (this.replayFrames.size) {
          this.saveReplay('#804000').catch(() => {});
          this.replayFrames = new Map();
        }
      });
    }
    this.collisionCache = new Map();
    this.collisions = new Map();
    this.updateStarted.clear();
    this.updated.clear();
    this.updateEnded.clear();
    if (this.controlActor) {
      this.controlActor.setCameraMode();
    }
    const zBuf = new Map();
    const layers = [...this.args.layers, ...this.args.fgLayers];
    for (let i = layers.length; i > 0; i--) {
      const layer = layers[i - 1];
      layer.x = this.args.x;
      layer.y = this.args.y;
      layer.update(this.tileMap, zBuf);
    }
    for (let i = layers.length; i > 0; i--) {
      const layer = layers[i - 1];
      layer.move();
    }
    if (this.args.running && !this.args.debugEditMode) {
      const updatable = new Set();
      for (const region of this.regions) {
        if (!this.actorIsOnScreen(region, 768)) {
          continue;
        }
        updatable.add(region);
      }
      for (const actor of this.auras) {
        if (!actor || actor.removed) {
          this.auras.delete(actor);
          continue;
        }
        if (actor !== this.controlActor) {
          updatable.add(actor);
        }
        const nearbyActors = this.nearbyActors(actor.args.x, actor.args.y);
        for (const actor of nearbyActors) {
          if (actor !== this.controlActor && !actor.removed) {
            updatable.add(actor);
          }
        }
      }
      for (const actor of updatable) {
        if (actor[Run] === this[Run] && !actor.removed) {
          this.actorUpdateStart(actor);
        }
      }
      if (this.controlActor) {
        if (this.controlActor[Run] === this[Run]) {
          this.actorUpdateStart(this.controlActor);
        }
      }
      for (const actor of updatable) {
        if (actor[Run] === this[Run] && !actor.removed) {
          this.actorUpdate(actor);
        }
      }
      if (this.controlActor) {
        if (this.controlActor[Run] === this[Run]) {
          this.actorUpdate(this.controlActor);
        }
      }
      for (const actor of updatable) {
        if (actor[Run] === this[Run] && !actor.removed) {
          this.actorUpdateEnd(actor);
        }
      }
      if (this.controlActor) {
        if (this.controlActor[Run] === this[Run]) {
          this.actorUpdateEnd(this.controlActor);
        }
      }
      for (const actor of updatable) {
        if (actor.moved && !actor.removed && actor[Run] === this[Run]) {
          this.setColCell(actor);
        }
      }
      if (this.controlActor) {
        if (this.controlActor[Run] === this[Run]) {
          this.setColCell(this.controlActor);
        }
      }
      if (this.collisions) {
        for (const [collider, collidees] of this.collisions) {
          for (const [collidee, type] of collidees) {
            if (!collidee) {
              continue;
            }
            collidee.pause(false);
          }
        }
      }
      if (this.controlActor) {
        this.args.score.args.value = String(this.controlActor.args.score).padStart(4, ' ');
        this.args.rings.args.value = String(this.controlActor.args.rings).padStart(4, ' ');
        this.args.emblems = this.controlActor.args.emblems;
        this.args.hasRings = !!this.controlActor.args.rings;
        this.args.hasEmeralds = !!this.controlActor.args.emeralds;
        this.args.char.args.value = this.controlActor.args.name;
        this.args.charName = this.controlActor.args.name;
        if (this.args.debugOsd) {
          this.args.xPos.args.value = Number(this.controlActor.args.x).toFixed(3);
          this.args.yPos.args.value = Number(this.controlActor.args.y).toFixed(3);
          this.args.layer.args.value = Number(this.controlActor.args.layer);
          this.args.ground.args.value = this.controlActor.args.landed;
          this.args.gSpeed.args.value = Number(this.controlActor.args.gSpeed).toFixed(3);
          this.args.xSpeed.args.value = Number(this.controlActor.args.xSpeed).toFixed(3);
          this.args.ySpeed.args.value = Number(this.controlActor.args.ySpeed).toFixed(3);
          this.args.angle.args.value = (Math.round(this.controlActor.args.groundAngle * 1000) / 1000).toFixed(3);
          this.args.airAngle.args.value = (Math.round(this.controlActor.args.airAngle * 1000) / 1000).toFixed(3);
          this.args.actorCount.args.value = this.actors.size;
          this.args.regionCount.args.value = this.regions.size;
          this.args.ignore.args.value = this.controlActor.args.ignore;
          const modes = ['FLOOR (0)', 'L-WALL (1)', 'CEILING (2)', 'R-WALL (3)'];
          this.args.mode.args.value = modes[Math.floor(this.controlActor.args.mode)] || Math.floor(this.controlActor.args.mode);
          this.args.cameraMode.args.value = this.controlActor.args.cameraMode;
        }
      }
    } else if (this.args.running && this.args.debugEditMode) {
      if (this.controlActor) {
        this.controlActor.args.x += controller.axes[0].magnitude * 4;
        this.controlActor.args.y += controller.axes[1].magnitude * 4;
        this.controlActor.args.respawning = false;
        this.controlActor.args.dead = false;
        this.controlActor.noClip = false;
        this.controlActor.args.xSpeed = 0;
        this.controlActor.args.ySpeed = 0;
        this.controlActor.args.gSpeed = 0;
      }
    }
    const width = this.args.width;
    const height = this.args.height;
    const margin = 16;
    const camLeft = -this.args.x + -16 + -margin;
    const camRight = -this.args.x + width + -16 + margin;
    const camTop = -this.args.y - margin;
    const camBottom = -this.args.y + height + margin;
    const inAuras = new WeakSet();
    if (this.controlActor) {
      const actorDoc = new DocumentFragment();
      const regionDoc = new DocumentFragment();
      let wakeActors = false;
      let wakeRegions = false;
      let focusedActor = this.controlActor;
      if (this.controlActor.focused) {
        focusedActor = this.controlActor.focused;
      }
      const nearbyActors = this.nearbyActors(focusedActor.args.x, focusedActor.args.y) || [];
      const nearbyRegions = this.nearbyActors(focusedActor.args.x, focusedActor.args.y, true) || [];
      for (const actorList of [nearbyActors, nearbyRegions]) {
        for (const actor of actorList) {
          if (actor[Run] !== this[Run]) {
            continue;
          }
          if (!actor.args.hidden && !actor.nodes.length) {
            actor.render(this.tags.actors);
          }
          const margin = 0.5 * Math.max(actor.args.width, actor.args.height);
          const actorIsOnScreen = this.actorIsOnScreen(actor, margin);
          if (actorIsOnScreen && !(actor instanceof _LayerSwitch.LayerSwitch)) {
            actor.args.display = actor.defaultDisplay || null;
            if (!actor.vizi) {
              if (!actor.nodes.length) {
                if (actor.onAttach && actor.onAttach() === false) {
                  actor.detach();
                }
              }
              if (!actor.args.hidden) {
                if (actor instanceof _Region.Region) {
                  actor.nodes.map(n => actorDoc.append(n));
                  wakeActors = true;
                } else {
                  actor.nodes.map(n => actorDoc.append(n));
                  wakeActors = true;
                }
              }
              actor.wakeUp();
            }
            this.willDetach.delete(actor);
            this.visible.add(actor);
            if (!actor.args.hidden) {
              actor.vizi = true;
            }
          }
          inAuras.add(actor);
          this.recent.add(actor);
        }
      }
      for (const actor of new Set([...this.recent, ...this.visible])) {
        if (actor.removed) {
          this.visible.delete(actor);
          this.recent.delete(actor);
          continue;
        }
        if (actor[Run] !== this[Run]) {
          this.recent.delete(actor);
          continue;
        }
        const actorIsOnScreen = !actor.args.hidden && this.actorIsOnScreen(actor, 256);
        if (actor.vizi && !actorIsOnScreen) {
          this.willDetach.set(actor, () => {
            actor.sleep();
            actor.args.display = 'none';
            actor.detach();
            this.visible.delete(actor);
            actor.vizi = false;
            actor.willhide = null;
            this.willDetach.delete(actor);
          });
          this.recent.delete(actor);
        }
      }
      if (wakeActors) {
        this.tags.actors.append(actorDoc);
      }
      if (wakeRegions) {
        this.tags.actors.append(regionDoc);
      }
    }
    if (this.nextControl) {
      !this.args.networked && this.auras.clear();
      this.controlActor && this.controlActor.sprite && this.controlActor.sprite.parentNode && this.controlActor.sprite.parentNode.classList.remove('actor-selected');
      if (this.controlActor) {
        this.controlActor.args.selected = false;
      }
      this.controlActor = this.nextControl;
      this.controlActor.args.selected = true;
      this.auras.add(this.controlActor);
      this.controlActor.args.display = this.controlActor.defaultDisplay || null;
      this.controlActor.nodes.map(n => this.tags.actors.append(n));
      this.visible.add(this.controlActor);
      this.controlActor.vizi = true;
      this.args.maxSpeed = null;
      this.nextControl = null;
    }
    this.updated.forEach(actor => {
      if (actor.args.standingLayer) {
        const groundShift = actor.args.standingLayer.offsetXChanged;
        if (groundShift) {
          const spaceLeft = actor.bMap('scanForward', groundShift).get(_Platformer2.Platformer);
          if (spaceLeft === false) {
            actor.args.x += groundShift || 0;
          } else {
            actor.args.x += spaceLeft * Math.sign(groundShift);
          }
        }
        actor.args.y += actor.args.standingLayer.offsetYChanged || 0;
      }
    });
    if (this.controlActor) {
      this.moveCamera();
      this.applyMotionBlur();
      this.args.popTopLine = this.args.popTopLine || this.getUnusedCharString({
        color: 'yellow'
      });
      this.args.popBottomLine = this.args.popBottomLine || this.getUnusedCharString({
        color: 'yellow'
      });
      let multiply = 0;
      let base = 0;
      let showCombo = this.controlActor.args.popChain.length > 1;
      let len = 0;
      if (this.controlActor.args.popChain.length) {
        if (this.controlActor.args.popChain[0].special) {
          showCombo = true;
        }
        len = this.controlActor.args.popChain.length;
        const cutOff = Math.max(0, len - 4);
        if (!len) {
          for (const item of this.args.combo) {
            // this.pooledCharStringDetached(item.score);
            this.pooledCharStringDetached(item.label);
          }
        }
        let pulse = false;
        for (let i = 0; i < len; i++) {
          const pop = this.controlActor.args.popChain[i];
          multiply += pop.multiplier;
          base += pop.points;
          const c = i + -cutOff;
          if (i >= cutOff) {
            this.args.combo[c] = this.args.combo[c] || {
              label: this.getUnusedCharString(),
              score: null,
              index: i
            };
            this.args.combo[c].label = this.args.combo[c].label || this.getUnusedCharString();
            if (this.args.combo[c].index !== i) {
              pulse = true;
            }

            // this.args.combo[c].score.args.value = pop.points;
            this.args.combo[c].label.args.value = String(pop.label).replace(/-/g, ' ');
            this.args.combo[c].index = i;
            if (pop.color) {
              this.args.combo[c].label.args.color = pop.color;
            } else if (pop.multiplier > 1) {
              this.args.combo[c].label.args.color = 'orange';
            } else {
              this.args.combo[c].label.args.color = 'white';
            }
          } else if (i < cutOff && this.args.combo[c]) {
            // this.pooledCharStringDetached(this.args.combo[c].score);
            this.pooledCharStringDetached(this.args.combo[c].label);
          }
        }
        if (pulse) {
          const last = this.args.combo[this.args.combo.length + -1];
          last.label.args.classes = 'pulse';
          this.onFrameOut(1, () => last.label.args.classes = '');
          // this.onFrameOut(30, () => last.label.args.classes = '');
        }

        this.args.combo.length = Math.min(4, Math.max(0, -cutOff + this.controlActor.args.popChain.length));
      } else {
        for (const item of this.args.combo) {
          // this.pooledCharStringDetached(item.score);
          this.pooledCharStringDetached(item.label);
        }
        this.args.combo.length = 0;
      }
      this.args.popTopLine.args.value = base + ' x ' + multiply;
      this.args.popBottomLine.args.value = len > 4 ? '+' + (len - 4) : '';
      this.args.showCombo = showCombo;
    }
    if (this.args.networked && this.controlActor) {
      const netState = {
        frame: this.serializePlayer()
      };
      if (this.args.playerId === 1) {
        this.server.send(JSON.stringify(netState));
      } else if (this.args.playerId === 2) {
        this.client.send(JSON.stringify(netState));
      }
    }
    if (this.socket && this.args.publishTime <= 0) {
      this.packPlayerFrame().arrayBuffer().then(buffer => this.socket.publish(0, buffer));
      this.args.publishTime = 10;
    } else {
      this.args.publishTime--;
    }
    this.spawnActors();
    if (this.controlActor && this.controlActor.isSuper && !this.controlActor.isHyper && this.controlActor.args.rings && this.controlActor.args.minRingsHyper && this.controlActor.args.rings >= this.controlActor.args.minRingsHyper) {
      this.args.prompt.args.value = '❸ ℍ ';
    } else if (this.controlActor && !this.controlActor.isSuper && !this.controlActor.isHyper && this.controlActor.args.rings && this.controlActor.args.minRingsSuper && this.controlActor.args.rings >= this.controlActor.args.minRingsSuper) {
      this.args.prompt.args.value = '❸ 𝕊 ';
    } else {
      this.args.prompt.args.value = '';
    }
    if (this.args.fps < 30) {
      this.settings.frameSkip = 3;
    } else if (this.args.fps < 20) {
      this.settings.frameSkip = 2;
    } else {
      this.settings.frameSkip = 1;
    }
    for (const b in this.mouseState.buttons) {
      if (this.mouseState.buttons[b]) {
        this.mouseState.buttons[b]++;
      }
    }
  }
  populateCharStringPool() {
    if (!this.charStringPool) {
      this.charStringPool = new Set();
      this.charStringOpen = new Set();
      for (let i = 0; i < 30; i++) {
        const charString = _Bindable.Bindable.make(new _CharacterString.CharacterString({
          value: ' '.repeat(10)
        }));
        charString.preserve = true;
        this.charStringPool.add(charString);
        this.charStringOpen.add(charString);
      }
    }
  }
  getUnusedCharString() {
    let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    this.populateCharStringPool();
    for (const charString of this.charStringOpen) {
      this.charStringOpen.delete(charString);
      Object.assign(charString.args, args);
      if (!args.value) {
        charString.args.value = '';
      }
      return charString;
    }
  }
  pooledCharStringDetached(charString) {
    this.charStringOpen.add(charString);
  }
  resetCharStringPool() {
    this.populateCharStringPool();
    for (const charString of this.charStringPool) {
      this.charStringOpen.add(charString);
    }
  }
  click(event) {
    if (this.args.isReplaying) {
      this.controlActor && this.controlActor.controller.zero();
      this.stop();
      this.args.topLine.args.hide = 'hide hidden';
      this.args.status.args.hide = 'hide hidden';
      this.quit(this.args.replayQuickExit ? 2 : 1);
    }
  }
  regionsAtPoint(x, y) {
    var _nearbyActors;
    let nearbyActors = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    const regions = new Set();
    nearbyActors = (_nearbyActors = nearbyActors) !== null && _nearbyActors !== void 0 ? _nearbyActors : this.nearbyActors(x, y, true);
    for (const region of nearbyActors) {
      if (!region.isRegion) {
        continue;
      }
      if (region[Run] !== this[Run]) {
        this.regions.delete(region);
        continue;
      }
      const regionArgs = region.args;
      const regionX = regionArgs.x;
      const regionY = regionArgs.y;
      const width = regionArgs.width;
      const height = regionArgs.height;
      const offset = Math.floor(width / 2);
      const left = regionX;
      const right = regionX + width;
      const top = regionY - height;
      const bottom = regionY;
      if (x >= left && right > x) {
        if (bottom >= y && y > top) {
          regions.add(region);
        }
      }
    }
    return regions;
  }
  actorsAtPoint(x, y) {
    var _options$nearbyActors;
    let w = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    let h = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
    let options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {
      ghosts: false,
      nearbyActors: null
    };
    // x = Math.trunc(x);
    // y = Math.trunc(y);

    // const cacheKey = x+'::'+y+'::'+w+'::'+h;
    // const actorPointCache = this[ActorPointCache];

    // if(actorPointCache.has(cacheKey))
    // {
    // 	return Array.from(actorPointCache.get(cacheKey));
    // }

    const nearbyActors = (_options$nearbyActors = options.nearbyActors) !== null && _options$nearbyActors !== void 0 ? _options$nearbyActors : this.nearbyActors(x, y);
    if (!nearbyActors.size) {
      return [];
    }
    const actors = new Set();
    for (const actor of nearbyActors) {
      if (!options.ghosts && actor.isGhost) {
        continue;
      }
      const myRadius = Math.max(Math.floor(w / 2), 0);
      const isRegion = actor.isRegion;
      const myLeft = x - myRadius;
      const myRight = x + myRadius;
      const actorArgs = actor.args;
      const actorX = actorArgs.x;
      const width = actorArgs.width;
      const offset = width / 2;
      const otherLeft = actorX - (isRegion ? 0 : offset);
      const otherRight = actorX + (isRegion ? width : offset);

      // if(myRight < otherLeft || otherRight <= myLeft)
      if (myRight < otherLeft || otherRight < myLeft) {
        continue;
      }
      const myTop = y - Math.max(h, 0);
      const myBottom = y;
      const actorY = actorArgs.y;
      const height = actorArgs.height;
      const otherTop = actorY - height;
      const otherBottom = actorY;
      if (otherBottom < myTop || myBottom < otherTop) {
        continue;
      }
      actors.add(actor);
    }
    const list = Array.from(actors.values());

    // if(actors.size)
    // {
    // 	actorPointCache.set(cacheKey, list);
    // }

    return list;
  }
  actorsAtLine(x1, y1, x2, y2) {
    const testActors = new Set();
    const cellX1 = Math.floor(x1 / this.colCellDiv);
    const cellY1 = Math.floor(y1 / this.colCellDiv);
    const cellX2 = Math.floor(x2 / this.colCellDiv);
    const cellY2 = Math.floor(y2 / this.colCellDiv);
    for (let x = 0; x < 3 + Math.abs(cellX1 + -cellX2); x++) for (let y = 0; y < 3 + Math.abs(cellY1 + -cellY2); y++) {
      const name = x + Math.min(cellX1, cellX2) + -1 + ':' + (y + Math.min(cellY1, cellY2) + -1);
      if (!this.colCells.has(name)) {
        continue;
      }
      for (const actor of this.colCells.get(name)) {
        testActors.add(actor);
      }
    }
    const actors = new Map();
    for (const actor of testActors) {
      if (actor.isGhost) {
        continue;
      }
      const intersection = this.actorIntersectsLine(actor, x1, y1, x2, y2);
      if (!intersection) {
        continue;
      }
      const distance = Math.hypot(x1 - intersection[0], y1 - intersection[1]);
      actors.set(actor, {
        intersection,
        distance
      });
    }
    return new Map(Array.from(actors.entries()).sort((a, b) => a[1].distance - b[1].distance));
  }
  lineIntersectsLine(a1x, a1y, a2x, a2y, b1x, b1y, b2x, b2y) {
    const ax = a2x - a1x;
    const ay = a2y - a1y;
    const bx = b2x - b1x;
    const by = b2y - b1y;
    const crossProduct = ax * by - ay * bx;

    // Parallel Lines cannot intersect
    if (crossProduct === 0) {
      return false;
    }
    const cx = b1x - a1x;
    const cy = b1y - a1y;

    // Is our point within the bounds of line a?
    const d = (cx * ay - cy * ax) / crossProduct;
    if (d < 0 || d > 1) {
      return false;
    }

    // Is our point within the bounds of line b?
    const e = (cx * by - cy * bx) / crossProduct;
    if (e < 0 || e > 1) {
      return false;
    }
    return [a1x + e * ax, a1y + e * ay];
  }
  actorIntersectsLine(actor, b1x, b1y, b2x, b2y) {
    const actorArgs = actor.args;
    const width = actorArgs.width;
    const height = actorArgs.height;
    const bottom = actorArgs.y;
    const top = bottom - height;
    const left = actorArgs.x - (actor.isRegion ? 0 : width * 0.5);
    const right = left + width;
    if (left < b1x && b1x < right && top < b1y && b1y < bottom) {
      return [b1x, b1y];
    }
    const points = [];
    const bounds = actor.getBoundingLines();
    let min = Infinity,
      closest;
    for (const line of bounds) {
      const point = this.lineIntersectsLine(line[0], line[1], line[2], line[3], b1x, b1y, b2x, b2y);
      if (!point) {
        continue;
      }
      const dist = Math.hypot(b1x - point[0], b1y - point[1]);
      if (dist < min) {
        min = dist;
        closest = point;
      }
    }
    return closest;

    // if(!points.length)
    // {
    // 	if(left < b2x && b2x < right && top < b2y && b2y < bottom)
    // 	{
    // 		return [b2x, b2y];
    // 	}

    // 	return false;
    // }

    // const distances = points.map(point => Math.hypot(b1x - point[0], b1y - point[1]));

    // const closest = points[ distances.indexOf(Math.min(...distances)) ];

    // return closest;
  }

  padConnected(event) {
    this.gamepad = event.gamepad;
    console.log(this.gamepad);
    const shortName = String(this.gamepad.id).replace(/\(.\)/, ' ').replace(/\s?\(.+/, '');
    this.showStatus(2500, ' Gamepad connected: ' + shortName + ' ');
    this.args.focusMe.args.hide = 'hide';
    this.interact();
    if (typeof ga === 'function') {
      _Analytic.Analytic.report({
        eventCategory: 'gamepad',
        eventAction: 'connected',
        eventLabel: event.gamepad.id
      });
    }
  }
  padRemoved(event) {
    if (!this.gamepad) {
      return;
    }
    const shortName = String(this.gamepad.id).replace(/\(.\)/, ' ').replace(/\s?\(.+/, '');
    this.showStatus(2500, ' Gamepad disconnected: ' + shortName + ' ');
    if (this.args.started) {
      this.pauseGame();
    }
    if (this.gamepad.index === event.gamepad.index) {
      this.gamepad = null;
    }
    if (typeof ga === 'function') {
      _Analytic.Analytic.report({
        eventCategory: 'gamepad',
        eventAction: 'disconnected',
        eventLabel: event.gamepad.id
      });
    }
  }
  getColCell(point) {
    const colCellDiv = this.colCellDiv;
    const colCells = this.colCells;
    const cellX = Math.floor(point.x / colCellDiv);
    const cellY = Math.floor(point.y / colCellDiv);
    const name = `${cellX}:${cellY}`;
    if (!colCells.has(name)) {
      const cell = new Set();
      colCells.set(name, cell);
      cell.name = name;
      return cell;
    }
    return colCells.get(name);
  }
  getColCells(actor) {
    const colCellDiv = this.colCellDiv;
    const actorTop = actor.args.y - actor.args.height;
    const actorWidth = actor.args.width;
    const actorLeft = actor.args.x - (actor.isRegion ? 0 : actorWidth / 2);
    const actorRight = actor.args.x + (actor.isRegion ? actorWidth : actorWidth / 2);
    const cellMinX = -1 + Math.floor(actorLeft / colCellDiv);
    const cellMaxX = Math.ceil(actorRight / colCellDiv);
    const cellMinY = -1 + Math.floor(actorTop / colCellDiv);
    const cellMaxY = Math.ceil(actor.args.y / colCellDiv);
    const cells = new Set();
    for (let x = cellMinX; x <= cellMaxX; x++) {
      for (let y = cellMinY; y <= cellMaxY; y++) {
        const cell = this.getColCell({
          x: x * colCellDiv,
          y: y * colCellDiv
        });
        cell.add(actor);
        cells.add(cell);
      }
    }
    return cells;
  }
  actorsInCells(cells) {
    const actors = new Set();
    for (const cell of cells) {
      for (const actor of cell) {
        actors.add(actor);
      }
    }
    return actors;
  }
  setColCell(actor) {
    if (actor.removed) {
      return;
    }
    if (!_Bindable.Bindable.isBindable(actor)) {
      console.log(actor);
    }
    actor[_Bindable.Bindable.NoGetters] = true;
    actor = _Bindable.Bindable.make(actor);
    const cell = this.getColCell(actor.args);
    if (actor[ColCell] && actor[ColCell] !== cell) {
      actor[ColCell].delete(actor);
    }
    cell.add(actor);
    actor[ColCell] = cell;
    if (!actor.isRegion) {
      return cell;
    }
    const prevCells = actor[ColCells];
    actor[ColCells] = this.getColCells(actor);
    if (prevCells) for (const prevCell of prevCells) {
      if (!actor[ColCells].has(prevCell)) {
        prevCell.delete(actor);
      }
    }
    return cell;
  }
  getNearbyColCells(actorX, actorY) {
    // const actorX = actor.args.x;
    // const actorY = actor.args.y;

    const colCellDiv = this.colCellDiv;
    const cellX = Math.floor(actorX / colCellDiv);
    const cellY = Math.floor(actorY / colCellDiv);
    const name = `${cellX}::${cellY}`;
    let cache = this.colCellCache.get(name);
    if (cache) {
      return cache; //.filter(set=>set.size);
    }

    const space = colCellDiv;
    const colA = actorX - space * 2;
    const colB = actorX - space;
    const colC = actorX;
    const colD = actorX + space;
    const colE = actorX + space * 2;
    const rowA = actorY - space * 2;
    const rowB = actorY - space;
    const rowC = actorY;
    const rowD = actorY + space;
    const rowE = actorY + space * 2;
    this.colCellCache.set(name, cache = [
    // this.getColCell({x:colA, y:rowA})
    // , this.getColCell({x:colA, y:rowB})
    // , this.getColCell({x:colA, y:rowC})
    // , this.getColCell({x:colA, y:rowD})
    // , this.getColCell({x:colA, y:rowE})

    // , this.getColCell({x:colB, y:rowA})
    this.getColCell({
      x: colB,
      y: rowB
    }), this.getColCell({
      x: colB,
      y: rowC
    }), this.getColCell({
      x: colB,
      y: rowD
    })
    // , this.getColCell({x:colB, y:rowE})

    // , this.getColCell({x:colC, y:rowA})
    , this.getColCell({
      x: colC,
      y: rowB
    }), this.getColCell({
      x: colC,
      y: rowC
    }), this.getColCell({
      x: colC,
      y: rowD
    })
    // , this.getColCell({x:colC, y:rowE})

    // , this.getColCell({x:colD, y:rowA})
    , this.getColCell({
      x: colD,
      y: rowB
    }), this.getColCell({
      x: colD,
      y: rowC
    }), this.getColCell({
      x: colD,
      y: rowD
    })
    // , this.getColCell({x:colD, y:rowE})

    // , this.getColCell({x:colE, y:rowA})
    // , this.getColCell({x:colE, y:rowB})
    // , this.getColCell({x:colE, y:rowC})
    // , this.getColCell({x:colE, y:rowD})
    // , this.getColCell({x:colE, y:rowE})
    ]);

    return cache; //.filter(set=>set.size);
  }

  screenFilter(filterName) {
    this.args.screenFilter = filterName;
  }
  reset() {
    console.clear();
    this[Run]++;
    this.stop();
    this.args.currentSheild = null;
    this.args.hasFire = false;
    this.args.hasWater = false;
    this.args.hasElectric = false;
    this.args.hasNormal = false;
    this.clearDialog();
    this.hideDialog();
    this.replayFrames = new Map();
    // this.replayOffset = 0;
    // this.replay = null;

    this.visible.clear();
    this.callFrames.clear();
    this.callIntervals.clear();
    this.collisionCache.clear();
    this.collisions.clear();
    this.colCellCache.clear();
    this.colCells.clear();
    this.regions.clear();
    this.spawn.clear();
    this.auras.clear();
    this.updateStarted.clear();
    this.updateEnded.clear();
    this.updated.clear();
    this[ActorPointCache].clear();
    this.objectDb = new _Classifier.Classifier(Object.values(_ObjectPalette.ObjectPalette));
    this.args.actClear = false;
    this.args.cutScene = false;
    this.args.fade = false;
    this.onFrameOut(30, () => this.args.fade = 'hide');
    this.args.xOffset = 0.5;
    this.args.yOffset = 0.5;
    this.args.screenEffects = new _Bag.Bag();
    if (this.tileMap) {
      this.tileMap.unreplace();
      const layers = this.tileMap.tileLayers;
      for (const layerDef of layers) {
        layerDef.offsetX = 0;
        layerDef.offsetY = 0;
        layerDef.offsetXChanged = 0;
        layerDef.offsetYChanged = 0;
      }
      for (const layer of [...this.args.layers, ...this.args.fgLayers]) {
        layer.args.destroyed = false;
        layer.args.offsetX = 0;
        layer.args.offsetY = 0;
        layer.args.offsetXChanged = 0;
        layer.args.offsetYChanged = 0;
      }
    }
    for (const actor of this.actors.items()) {
      this.actors.remove(actor);
    }
    this.controlActor && this.actors.remove(this.controlActor);
    this.nextControl = null;
    this.actorsById = {};
    for (const [id, effect] of Object.entries(this.effects.list)) {
      effect && this.effects.remove(effect);
    }
    for (const [id, particle] of Object.entries(this.particles.list)) {
      particle && this.particles.remove(particle);
    }
    this.spawn.clear();
    this[ActorPointCache].clear();
    this.args.isRecording = false;
    this.args.isReplaying = false;
    this.args.populated = false;
    this.controlActor = null;
    // this.args.frameId   = -1;

    this.tags.viewport.focus();
    this.args.paused = true;
  }
  quit() {
    let quick = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    let after = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    if (!this.replay && !this.levelFinished) {
      this.saveReplay('#FFF').catch(() => {});
    }
    this.baseMap = this.currentMap = null;
    if (this.args.networked) {
      this.server && this.server.close();
      this.client && this.client.close();
      this.actors.remove(this.remotePlayer);
      this.actors.remove(this.controlActor);
      this.controlActor = this.remotePlayer = null;
    }
    this.args.fade = this.args.fade === true ? this.args.fade : false;
    this.onNextFrame(() => this.args.fade = true);
    this.onFrameOut(45, () => {
      this.args.actClear = false;
      this.args.cutScene = false;
      this.args.screenEffects = new _Bag.Bag();
      this.callFrames.clear();
      this.callIntervals.clear();
      this.collisionCache.clear();
      this.collisions.clear();
      this.colCellCache.clear();
      this.colCells.clear();
      this.regions.clear();
      this.spawn.clear();
      this.auras.clear();
      this.replayFrames = new Map();
      this.replayOffset = 0;
      this.replayStart = null;
      this.replay = null;
      this.args.timeBonus.args.value = 0;
      this.args.ringBonus.args.value = 0;
      this.args.speedBonus.args.value = 0;
      this.args.totalBonus.args.value = 0;
      this.defsByMap.clear();
      this.actorsByMap.clear();
      this.meta = {};
      this.willDetach.clear();
      this.objectDb.clear();
      this.args.currentSheild = null;
      this.args.hasFire = false;
      this.args.hasWater = false;
      this.args.hasElectric = false;
      this.args.hasNormal = false;
      this.args.isRecording = false;
      this.args.isReplaying = false;
      this.playableIterator = false;
      this.args.populated = false;
      this.args.paused = false;
      this.args.started = false;
      this.controlActor = null;
      this.args.frameId = -1;
      this.args.timer.args.value = '';
      this.args.rings.args.value = 0;
      // this.emeralds.args.value = 0;
      // this.coins.args.value    = 0;

      this.args.hasRings = false;
      this.args.hasCoins = false;
      this.args.hasEmeralds = false;
      this.args.char.args.value = '';
      this.args.charName = '';
      this.args.level = false;
      const layers = this.args.layers;
      const layerCount = layers.length;
      this.recent.clear();
      this.visible.clear();
      this[ActorPointCache].clear();
      for (const actor of this.actors.items()) {
        this.actors.remove(actor);
      }
      for (const particle of this.particles.items()) {
        this.particles.remove(particle);
        particle.remove();
      }
      for (const layer of [...this.args.layers, ...this.args.fgLayers]) {
        layer.args.destroyed = false;
      }
      for (const layer of this.args.layers) {
        layer.remove();
      }
      for (const layer of this.args.fgLayers) {
        layer.remove();
      }
      this.args.layers.splice(0);
      this.args.fgLayers.splice(0);
      this.args.bg = this.args.backdrop = null;
      for (const [k, v] of this.backdrops) {
        v.view.remove();
      }
      this.backdrops.clear();
      if (after) {
        this.onFrameOut(15, () => after());
      } else {
        const cards = [];
        if (quick === 2 || this.args.networked) {
          const menu = new _MainMenu.MainMenu({
            timeout: -1
          }, this);
          if (this.args.networked) {
            menu.args.initialPath = ['Multiplayer'];
          }
          cards.push(menu);
        } else if (quick) {
          _Bgm.Bgm.fadeOut(2000);
          cards.push(...this.homeCards());
        } else {
          _Bgm.Bgm.fadeOut(3000);
          cards.push(...this.returnHomeCards());
        }
        this.onFrameOut(15, () => {
          this.args.titlecard = new _Series.Series({
            cards
          }, this);
          this.args.titlecard.play();
        });
      }
    });
    _Keyboard.Keyboard.get().reset();
    this.controller.zero();
  }
  introCards() {
    return [new _LoadingCard.LoadingCard({
      timeout: 3500,
      text: 'loading'
    }, this), new _BootCard.BootCard({
      timeout: 3500
    }), new _WarningCard.WarningCard({
      timeout: 8500
    }), new _DebianCard.DebianCard({
      timeout: 4500
    }), new _WebkitCard.WebkitCard({
      timeout: 3500
    }), new _NewgroundsCard.NewgroundsCard({
      timeout: 2500
    }), new _SaneCard.SaneCard({
      timeout: 4500
    }), new _GamepadCard.GamepadCard({
      timeout: 25000000
    }), new _SeanCard.SeanCard({
      timeout: 5000
    }, this), ...this.homeCards()];
  }
  homeCards() {
    return [new _TitleScreenCard.TitleScreenCard({
      timeout: 51000
    }, this), new _MainMenu.MainMenu({
      timeout: -1
    }, this)];
  }
  returnHomeCards() {
    return [new _ThankYouCard.ThankYouCard({
      timeout: 5000
    }, this), ...this.homeCards()];
  }
  playCards() {
    this.args.titlecard.play();
  }
  record() {
    this.args.demoIndicator = null;
    this.reset();
    this.args.frameId = 0;
    this.replayFrames = new Map();
    this.args.isRecording = true;
    this.args.isReplaying = false;
    this.args.hasRecording = true;
    this.args.paused = false;
    this.startLevel();
  }
  playback() {
    this.args.demoIndicator = null;
    this.args.frameId = 0;
    this.args.isReplaying = true;
    this.args.isRecording = false;
    this.lastInput = {};
    this.startLevel();
    this.args.paused = false;
  }
  stop() {
    if (this.args.isRecording) {
      const replay = JSON.stringify(this.replayFrames.entries());
      localStorage.setItem('replay', replay);
    }
    this.args.isReplaying = false;
    this.args.isRecording = false;
    this.args.paused = false;
    this.controlActor && this.controlActor.controller.zero();
    this.tags.viewport.focus();
  }
  focus() {
    this.tags.viewport && this.tags.viewport.focus();
  }
  getServer() {
    let refresh = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    if (!refresh && this.server && this.server.peerServer && this.server.peerServer.connectionState === 'new') {
      return this.server;
    }
    const rtcConfig = {
      iceServers: [{
        urls: this.settings.iceServer1
      }, {
        urls: this.settings.iceServer2
      }]
    };
    const server = refresh || !this.server ? new _RtcServer.RtcServer(rtcConfig) : this.server || new _RtcServer.RtcServer(rtcConfig);
    const onOpen = event => {
      // console.log('Connection opened!');
      this.args.chatBox = new _ChatBox.ChatBox({
        pipe: server
      });
      this.args.playerId = 1;
    };
    const onMessage = event => {
      // const actors = this.actors.list;

      if (this.remotePlayer) {
        const packet = JSON.parse(event.detail);
        const actor = this.remotePlayer;
        if (packet.frame) {
          if (packet.frame.frame > this.args.frameId) {
            this.args.frameId = packet.frame.frame;
          }
          if (packet.frame.input) {
            actor.controller.replay(packet.frame.input);
            actor.readInput();
          }
          if (packet.frame.args) {
            Object.assign(actor.args, packet.frame.args);
          }
          actor.noClip = actor.args.dead;
        }
      }
    };
    const onClose = event => {
      this.actors.remove(this.remotePlayer);
      this.quit(2);
    };
    this.listen(server, 'open', onOpen, {
      once: true
    });
    this.listen(server, 'close', onClose, {
      once: true
    });
    this.listen(server, 'message', onMessage);
    this.server = server;
    return server;
  }
  getClient() {
    let refresh = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    if (!refresh && this.client && this.client.peerClient && this.client.peerClient.connectionState === 'new') {
      return this.client;
    }
    const rtcConfig = {
      iceServers: [{
        urls: this.settings.iceServer1
      }, {
        urls: this.settings.iceServer2
      }]
    };

    // const client = (!refresh && this.client) || new RtcClient(rtcConfig);
    const client = refresh || !this.client ? new _RtcClient.RtcClient(rtcConfig) : this.client || new _RtcClient.RtcClient(rtcConfig);
    const onOpen = event => {
      // console.log('Connection opened!')
      this.args.chatBox = new _ChatBox.ChatBox({
        pipe: client
      });
      this.args.playerId = 2;
    };
    const onMessage = event => {
      // const actors = this.actors.list;

      if (this.remotePlayer) {
        const packet = JSON.parse(event.detail);
        const actor = this.remotePlayer;
        if (packet.frame) {
          if (packet.frame.frame > this.args.frameId) {
            this.args.frameId = packet.frame.frame;
          }
          if (packet.frame.input) {
            actor.controller.replay(packet.frame.input);
            actor.readInput();
          }
          if (packet.frame.args) {
            Object.assign(actor.args, packet.frame.args);
          }
          actor.noClip = actor.args.dead;
        }
      }
    };
    const onClose = event => this.quit(2);
    this.listen(client, 'open', onOpen, {
      once: true
    });
    this.listen(client, 'close', onClose, {
      once: true
    });
    this.listen(client, 'message', onMessage);
    this.client = client;
    return client;
  }
  serializePlayer() {
    if (!this.controlActor || !this.controlActor.controller) {
      return {};
    }
    const frame = this.args.frameId;
    const input = this.controlActor.controller.serialize();
    const actorArgs = this.controlActor.args;
    const args = {
      x: actorArgs.x,
      y: actorArgs.y,
      gSpeed: actorArgs.gSpeed,
      xSpeed: actorArgs.xSpeed,
      ySpeed: actorArgs.ySpeed,
      direction: actorArgs.direction,
      facing: actorArgs.facing,
      falling: actorArgs.falling,
      rolling: actorArgs.rolling,
      jumping: actorArgs.jumping,
      flying: actorArgs.flying,
      float: actorArgs.float,
      angle: actorArgs.angle,
      mode: actorArgs.mode,
      rings: actorArgs.rings,
      groundAngle: actorArgs.groundAngle,
      respawning: actorArgs.respawning,
      dead: actorArgs.dead ? true : false
    };
    return {
      frame,
      input,
      args
    };
  }
  packPlayerFrame() {
    const actorArgs = this.controlActor.args;
    const axisInts = new Int8Array(8);
    const buttonInts = new Int8Array(16);
    const playerInts = new Int32Array(11);
    const playerFloats = new Float32Array(7);
    const gameInts = new Int32Array(1);
    playerInts[0] = actorArgs.direction;
    playerInts[1] = actorArgs.facing === 'left' ? -1 : 1;
    playerInts[2] = actorArgs.falling;
    playerInts[3] = actorArgs.rolling;
    playerInts[4] = actorArgs.jumping;
    playerInts[5] = actorArgs.flying;
    playerInts[6] = actorArgs.float;
    playerInts[7] = actorArgs.mode;
    playerInts[8] = actorArgs.rings;
    playerInts[9] = actorArgs.respawning;
    playerInts[10] = Number(actorArgs.dead);
    playerFloats[0] = actorArgs.x;
    playerFloats[1] = actorArgs.y;
    playerFloats[2] = actorArgs.gSpeed;
    playerFloats[3] = actorArgs.xSpeed;
    playerFloats[4] = actorArgs.ySpeed;
    playerFloats[5] = actorArgs.angle;
    playerFloats[6] = actorArgs.groundAngle;
    gameInts[0] = this.args.frameId;
    const {
      axes,
      buttons
    } = this.controlActor.controller.serialize();
    for (const i in axisInts) {
      var _axes$i;
      axisInts[i] = 127 * ((_axes$i = axes[i]) !== null && _axes$i !== void 0 ? _axes$i : 0);
    }
    for (const i in buttonInts) {
      var _buttons$i;
      buttonInts[i] = 127 * ((_buttons$i = buttons[i]) !== null && _buttons$i !== void 0 ? _buttons$i : 0);
    }
    const packed = new Blob([axisInts.buffer, buttonInts.buffer, playerInts.buffer, playerFloats.buffer, gameInts.buffer]);
    return packed;
  }
  unpackPlayerFrame(buffer) {
    const axisView = new DataView(buffer, 0);
    const buttonView = new DataView(buffer, 8);
    const playerIntView = new DataView(buffer, 24);
    const playerFloatView = new DataView(buffer, 68);
    const gameIntView = new DataView(buffer, 96);
    const input = {
      axes: {},
      buttons: {}
    };
    const args = {};
    for (let i = 0; i < 8; i++) {
      input.axes[i] = axisView.getInt8(i) / 127;
    }
    for (let i = 0; i < 16; i++) {
      input.buttons[i] = buttonView.getInt8(i) / 127;
    }
    args.direction = playerIntView.getInt32(0, true);
    args.facing = playerIntView.getInt32(4, true) === -1 ? 'left' : 'right';
    args.falling = playerIntView.getInt32(8, true);
    args.rolling = playerIntView.getInt32(12, true);
    args.jumping = playerIntView.getInt32(16, true);
    args.flying = playerIntView.getInt32(20, true);
    args.float = playerIntView.getInt32(24, true);
    args.mode = playerIntView.getInt32(28, true);
    args.rings = playerIntView.getInt32(32, true);
    args.respawning = playerIntView.getInt32(36, true);
    args.dead = playerIntView.getInt32(40, true);
    args.x = playerFloatView.getFloat32(0, true);
    args.y = playerFloatView.getFloat32(4, true);
    args.gSpeed = playerFloatView.getFloat32(8, true);
    args.xSpeed = playerFloatView.getFloat32(12, true);
    args.ySpeed = playerFloatView.getFloat32(16, true);
    args.angle = playerFloatView.getFloat32(20, true);
    args.groundAngle = playerFloatView.getFloat32(24, true);
    const frame = gameIntView.getInt32(0, true);
    return {
      frame: {
        input,
        args,
        frame
      }
    };
  }
  onRenderedFrameOut(frames, callback) {
    if (frames < 0) {
      callback();
      return;
    }
    this.callRenderedFrames.set(callback, frames);
  }
  onFrameOut(frames, callback) {
    if (frames <= 0) {
      callback();
      return;
    }
    const callFrame = this.args.frameId + frames;
    if (!this.callFrames.has(callFrame)) {
      this.callFrames.set(callFrame, new Set());
    }
    const callbacks = this.callFrames.get(callFrame);
    callbacks.add(callback);
    return () => callbacks.delete(callback);
  }
  onFrameInterval(interval, callback) {
    if (frames <= 0) {
      return;
    }
    const callInterval = interval;
    if (!this.callIntervals.has(callInterval)) {
      this.callIntervals.set(callInterval, new Set());
    }
    const callbacks = this.callIntervals.get(callInterval);
    callbacks.add(callback);
    return () => callbacks.delete(callback);
  }
  callFrameOuts() {
    for (let i = this.args.lastFrameId; i <= this.args.frameId; i++) {
      if (!this.callFrames.has(i)) {
        continue;
      }
      const callbacks = this.callFrames.get(i);
      for (const callback of callbacks) {
        callback();
      }
      this.callFrames.delete(i);
    }
  }
  callRenderedFrameOut() {
    if (this.args.frameId % this.settings.frameSkip !== 0) {
      return;
    }
    for (const [callback, framesLeft] of this.callRenderedFrames) {
      if (framesLeft <= 0) {
        callback();
        continue;
      }
      this.callRenderedFrames.set(callback, -1 + frames);
    }
  }
  callFrameIntervals() {
    for (let i = this.args.lastFrameId; i <= this.args.frameId; i++) {
      for (const [interval, callbacks] of this.callIntervals) {
        if (i % interval === 0) {
          for (const callback of callbacks) {
            callback();
          }
        }
      }
    }
  }
  pauseGame() {
    this.focus();
    this.args.mouse = 'moved';
    this.args.paused = -1;
    this.args.pauseMenu.focusFirst();
    _Bgm.Bgm.pause();
    this.onTimeout(6, () => {
      this.controller && this.controller.zero();
    });
  }
  unpauseGame() {
    this.args.pauseMenu.reset();
    _Bgm.Bgm.unpause();
    this.args.mouse = 'hide';
    this.onTimeout(15, () => {
      this.controller && this.controller.zero();
    });
    this.onTimeout(30, () => {
      this.focus();
    });
    this.onTimeout(60, () => {
      this.args.paused = false;
    });
  }
  mousemove(event) {
    const xOrigin = event.currentTarget.offsetLeft;
    const yOrigin = event.currentTarget.offsetTop;
    const xMouse = (event.pageX + -xOrigin) / this.args.scale;
    const yMouse = (event.pageY + -yOrigin) / this.args.scale;
    this.args.xMouseOffset = xMouse;
    this.args.yMouseOffset = yMouse;
    this.args.mouse = 'moved';
    if (this.mouseMoveTimeout) {
      clearTimeout(this.mouseMoveTimeout);
      this.mouseMoveTimeout = null;
    }
    this.mouseMoveTimeout = this.onTimeout(800, () => {
      this.args.mouse = 'hide';
    });
  }
  mousedown(event) {
    this.setMouseButtons(event);
  }
  mouseup(event) {
    this.setMouseButtons(event);
  }
  setMouseButtons(event) {
    for (let i = 0; i < 8; i++) {
      const bit = 2 ** i;
      this.mouseState.buttons[i] = this.mouseState.buttons[i] || 0;
      if (event.buttons & bit) {
        this.mouseState.buttons[i]++;
      } else {
        this.mouseState.buttons[i] = 0;
      }
    }
  }
  hyphenate(string) {
    return String(string).replace(/\s/g, '-').toLowerCase();
  }
  storeCheckpoint(name, checkpointId) {
    if (!this.checkpoints[this.currentMap]) {
      this.checkpoints[this.currentMap] = {};
    }
    const checkpointsByActor = this.checkpoints[this.currentMap];
    checkpointsByActor[name] = {
      checkpointId,
      frames: this.args.frameId - this.args.startFrameId
    };
    localStorage.setItem(`checkpoints:::${this.currentMap}`, JSON.stringify(this.checkpoints[this.currentMap]));
  }
  getCheckpoint(name) {
    if (!this.checkpoints[this.currentMap]) {
      const checkpointSource = localStorage.getItem(`checkpoints:::${this.currentMap}`) || '{}';
      this.checkpoints[this.currentMap] = JSON.parse(checkpointSource) || {};
    }
    const checkpointsByActor = this.checkpoints[this.currentMap];
    const currentCheckpoint = checkpointsByActor[name];
    return currentCheckpoint;
  }
  setCheckpoint(mapUrl, storedCheckpoint) {
    const checkpointSource = localStorage.setItem(`checkpoints:::${mapUrl}`, JSON.stringify(storedCheckpoint));
  }
  clearCheckpoints() {
    let name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    if (!this.controlActor) {
      return;
    }
    if (name === null) {
      name = this.controlActor.args.canonical;
    }
    if (!this.checkpoints[this.currentMap]) {
      this.checkpoints[this.currentMap] = {};
    }
    const checkpointsByActor = this.checkpoints[this.currentMap];
    delete checkpointsByActor[name];
    localStorage.setItem(`checkpoints:::${this.currentMap}`, JSON.stringify(this.checkpoints[this.currentMap]));
  }
  showCenterMessage(message, color) {
    this.args.centerMessage = new _CharacterString.CharacterString({
      value: message,
      color
    });
  }
  hideCenterMessage() {
    this.args.centerMessage = false;
  }
  showDialog() {
    let lines = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    let classes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
    this.args.dialog = true;
    this.clearDialog();
    lines = lines.map(t => new _CharacterString.CharacterString({
      value: t
    }));
    let offset = 0;
    for (const line of lines) {
      line.offset = offset;
      offset += line.args.value.length;
    }
    this.args.dialogLines = lines;
    this.args.dialogClasses = classes;
  }
  hideDialog(message) {
    this.clearDialog();
    this.args.dialog = false;
  }
  clearDialog() {
    this.args.dialogLines = [];
  }
  clearAct(message) {
    let showZonecard = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    const zoneState = this.getZoneState();
    if (this.controlActor && this.controlActor.args.canonical) {
      const charState = this.getCharacterState(this.controlActor.args.canonical);
      if (charState) {
        if (!(this.currentMap in charState.cleared)) {
          charState.cleared[this.currentMap] = {
            firstCleared: Date.now()
          };
        }
        charState.cleared[this.currentMap].clearCount = charState.cleared[this.currentMap].clearCount || 0;
        charState.cleared[this.currentMap].lastCleared = Date.now();
        charState.cleared[this.currentMap].clearCount++;
      }
    }
    this.args.actClearLabel.args.value = message;
    const rings = this.controlActor.args.rings;
    const frames = this.args.frameId - this.args.startFrameId;
    const time = frames / 60;
    const air = this.controlActor.args.airTimeTotal / (this.controlActor.args.airTimeTotal + this.controlActor.args.groundTimeTotal);
    const speedBonus = Math.trunc(this.controlActor.args.clearSpeed * 10);
    const ringBonus = rings * 100;
    const airBonus = Math.round(10000 * (air || 0));
    let timeBonus = 0;
    const seconds = Math.trunc(Math.abs(time));
    if (seconds < 30) {
      timeBonus = 50000;
    } else if (seconds < 45) {
      timeBonus = 10000;
    } else if (seconds < 60) {
      timeBonus = 5000;
    } else if (seconds < 90) {
      timeBonus = 4000;
    } else if (seconds < 120) {
      timeBonus = 3000;
    } else if (seconds < 180) {
      timeBonus = 2000;
    } else if (seconds < 240) {
      timeBonus = 1000;
    } else {
      timeBonus = 500;
    }
    const totalBonus = timeBonus + ringBonus + speedBonus + airBonus;
    const score = totalBonus;
    this.args.actClear = true;
    this.args.skidBonusValue = this.controlActor.args.dragBonus || 0;

    // this.args.timeBonus.args.value  = 0;
    // this.args.ringBonus.args.value  = 0;
    // this.args.airBonus.args.value   = 0;
    // this.args.speedBonus.args.value = 0;
    // this.args.skidBonus.args.value  = 0;
    // this.args.totalBonus.args.value = 0;

    const skidBonus = this.controlActor.args.dragBonus || 0;

    // this.onFrameOut(45 * 1, () => this.args.timeBonus.args.value  = timeBonus);
    // this.onFrameOut(45 * 2, () => this.args.ringBonus.args.value  = ringBonus);
    // this.onFrameOut(45 * 3, () => this.args.speedBonus.args.value = speedBonus);
    // this.onFrameOut(45 * 4, () => this.args.skidBonus.args.value  = skidBonus);
    // this.onFrameOut(45 * 5, () => this.args.airBonus.args.value   = airBonus);
    // this.onFrameOut(45 * 6, () => this.args.totalBonus.args.value = totalBonus);
    // this.onFrameOut(45 * 7, () => this.args.actClear = false);

    // tallyBoard.addCounter({label:'Skid Bonus:',  value: skidBonus||30000});

    const tallyBoard = new _TallyBoard.TallyBoard();
    tallyBoard.addCounter({
      label: 'Time Bonus:',
      value: timeBonus
    });
    tallyBoard.addCounter({
      label: 'Ring Bonus:',
      value: ringBonus
    });
    if (speedBonus) {
      tallyBoard.addCounter({
        label: 'Speed Bonus:',
        value: speedBonus
      });
    }
    tallyBoard.addCounter({
      label: 'Air Bonus:',
      value: airBonus
    });
    _Bgm.Bgm.play('ACT_CLEAR', {
      interlude: true
    });
    tallyBoard.update(this);

    // tallyBoard.addEventListener('almostdone', console.log);
    // tallyBoard.addEventListener('totalingstarted', console.log);

    if (showZonecard) {
      tallyBoard.addEventListener('totalingdone', event => this.setZoneCard(true));
    }
    tallyBoard.addEventListener('done', event => {
      this.controlActor.args.clearSpeed = 0;
      this.args.tallyBoard = null;
      this.tallyBoard = false;
      this.args.actStartFrameId = this.args.frameId;
      this.args.actClear = false;
      this.args.inventory.splice(0);
      _Bgm.Bgm.stop('ACT_CLEAR');
      if (showZonecard) {
        this.args.zonecard.replay();
      }
    });
    this.tallyBoard = tallyBoard;
    this.args.tallyBoard = tallyBoard.view();
    if (!zoneState.time || zoneState.time > frames) {
      zoneState.time = frames;
    }
    if (!zoneState.rings || zoneState.rings < rings) {
      zoneState.rings = rings;
    }
    if (!zoneState.air || zoneState.air < air) {
      zoneState.air = air;
    }
    if (!zoneState.score || zoneState.score < score) {
      zoneState.score = score;
    }
    this.currentSave.save();
    return tallyBoard;
  }
  cpuDetect() {
    try {
      _Analytic.Analytic.report({
        eventCategory: 'cpu',
        eventAction: 'cores',
        eventLabel: `core check`,
        eventValue: navigator.hardwareConcurrency
      });
    } catch (error) {
      _Analytic.Analytic.report({
        eventCategory: 'cpu',
        eventAction: 'cpu detect fail',
        eventLabel: `Cpu Detect Failure: ${error}`
      });
    }
  }
  gpuDetect() {
    try {
      this.gpuDetector = this.gpuDetector || document.createElement('canvas').getContext('webgl');
      const debug = this.gpuDetector.getExtension('WEBGL_debug_renderer_info');
      const vendor = this.gpuDetector.getParameter(debug.UNMASKED_VENDOR_WEBGL);
      const gpu = this.gpuDetector.getParameter(debug.UNMASKED_RENDERER_WEBGL);
      _Analytic.Analytic.report({
        eventCategory: 'gpu',
        eventAction: 'gpu detect',
        eventLabel: `${vendor} :: ${gpu}`
      });
    } catch (error) {
      _Analytic.Analytic.report({
        eventCategory: 'gpu',
        eventAction: 'gpu detect fail',
        eventLabel: `Gpu Detect Failure: ${error}`
      });
    }
  }
  buildDetect() {
    const buildTag = document.head.querySelector('meta[name="x-build-time"]');
    const build = buildTag.getAttribute('content');
    _Analytic.Analytic.report({
      eventCategory: 'build',
      eventAction: 'build check',
      eventLabel: build
    });
  }
  interact() {
    this.args.interacted = true;
  }
  matrixConnect() {
    let refresh = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    if (!this.settings.matrixUrl) {
      console.error('No matrixUrl defined!!!');
    }
    const redirectUrl = location.origin + '/accept-sso';
    if (!refresh && this.matrix) {
      if (!this.matrix.isLoggedIn) {
        return this.matrix.logIn(redirectUrl).then(() => this.matrix);
      }
      return Promise.resolve(this.matrix);
    }
    return this.matrix.logIn(redirectUrl).then(() => this.matrix);
  }
  subspaceConnect() {
    this.socket = _Socket.Socket.get('ws://localhost:9998');
    this.socket.subscribe('open', () => {
      console.log('socket ready!');
      fetch('http://localhost:2020/auth?api').then(r => r.text()).then(token => {
        console.log(token);
        this.socket.send(`auth ${token}`);
        const channel = 'testing';
        const message = 'This is the payload.';
        this.socket.subscribe('message', (event, message, channel, origin, originId, originalChannel) => {
          if (origin === 'user') {
            return;
          }
          console.log(event.data);
          if (event.data[0] !== '{') {
            return;
          }
          const packet = JSON.parse(event.data);
          if ('youruid' in packet) {
            this.netId = packet.youruid;
          }
        });
        this.socket.send('uid');
        this.socket.subscribe('message:0', (event, message, channel, origin, originId, originalChannel) => {
          this.bytesReceived += message.length || message.byteLength;
          if (origin !== 'user') {
            console.log(message);
            return;
          }
          if (!this.controlActor || originId === this.netId) {
            return;
          }
          const packet = this.unpackPlayerFrame(message);
          if (!this.netPlayers.has(originId)) {
            const netPlayer = new _Sonic.Sonic({
              name: 'Player ' + originId,
              id: String(new _Uuid.Uuid()),
              netplayer: true
            }, this);
            this.netPlayers.set(originId, netPlayer);
            this.spawn.add({
              object: netPlayer
            });
            this.actors.add(netPlayer);
            this.auras.add(netPlayer);
          }
          const netPlayer = this.netPlayers.get(originId);
          if (packet.frame) {
            if (packet.frame.frame > this.args.frameId) {
              this.args.frameId = packet.frame.frame;
            }
            if (packet.frame.input) {
              netPlayer.controller.replay(packet.frame.input);
              netPlayer.readInput();
            }
            if (packet.frame.args) {
              Object.assign(netPlayer.args, packet.frame.args);
            }
            netPlayer.noClip = netPlayer.args.dead;
          }

          // console.log('message received!', {event, message, channel, origin, originId, originalChannel});
        });

        this.socket.publish(channel, message);
      });
    });
    this.socket.subscribe('close', () => {
      console.log('socket closed!');
      this.quit(2);
    });
  }
  nowPlayingClicked(event) {
    if (!this.args.audioComment) {
      return;
    }
    console.log(this.args.audioComment);
    if (this.args.audioComment.substr(0, 8) !== 'https://') {
      return;
    }
    this.pauseGame();
    window.open(this.args.audioComment, 'audio-credit');
  }
  handleUncaughtException(event) {
    console.error(event.error);
    _Analytic.Analytic.report({
      eventCategory: 'error',
      eventAction: `${event.error.message} @ ${event.filename}:${event.lineno}:${event.colno}`,
      eventLabel: event.error.stack
    });
    _TraceDatabase.TraceDatabase.open('traces', 1).then(database => {
      const trace = _Trace.Trace.from(event.error);
      delete trace.id;
      console.log(JSON.stringify(trace));
      trace.consume(event);
      console.log(JSON.stringify(trace));
      console.log(trace, event);
      if (!this.currentMap) {
        return;
      }
      database.insert('traces', trace).then(() => {
        if (this.replay) {
          trace.replay = this.replay.uuid;
          database.update('traces', trace);
          return;
        }
        this.saveReplay('#FF0000').then(replay => {
          trace.replay = replay.uuid;
          database.update('traces', trace);
        }).catch(() => {});
      });
    });
  }
  get mouse() {
    this.mouseState.position[0] = this.args.xMouseOffset + -this.args.x;
    this.mouseState.position[1] = this.args.yMouseOffset + -this.args.y;
    return this.mouseState;
  }
}
exports.Viewport = Viewport;
});

;require.register("viewport/layer.html", function(exports, require, module) {
module.exports = "<div data-name = \"[[name]]\" class = \"viewport-background\" cv-each = \"blocks:block:b\" cv-ref = \"background\" data-layer = \"[[layerId]]\">[[block]]</div>\n"
});

;require.register("viewport/viewport.html", function(exports, require, module) {
module.exports = "<section class = \"filters\" cv-each = \"effects:effect\">[[effect]]</section>\n\n<div class = \"viewport-frame [[initializing]] [[standalone]] [[secret]] [[level]] [[noIntro]] [[inputType]] [[ntsc]] [[windowFocused]]\" data-theme = \"[[theme]]\" data-bg = \"[[bg]]\" data-agent = \"[[agent]]\" cv-ref = \"frame\" data-paused = \"[[paused]]\" data-smoothing = [[smoothing]] data-character = \"[[selectedChar]]\" data-loading-map = \"[[loadingMap]]\" cv-on = \"mousedown:interact:c;keydown:interact:c;\">\n\t<div class = \"viewport [[standalone]] [[fullscreen]] displacement-[[displacement]] mouse-[[mouse]] [[theme]] [[hideNowPlaying]] [[hiddenNowPlaying]] [[invert]]\" cv-ref = \"viewport\" tabindex=\"0\" cv-on = \"click;mousemove;mousedown;mouseup;\">\n\n\t\t<svg height=\"32\" width=\"32\">\n\t\t<defs>\n\t\t\t<filter id=\"motionBlur\" x=\"0%\"\n y=\"0%\" width=\"100%\" height=\"100%\">\n\t\t\t\t<feGaussianBlur\n\t\t\t\t\tin = \"SourceGraphic\"\n\t\t\t\t\tedgeMode = \"duplicate\"\n\t\t\t\t\tstdDeviation = \"0,0\"\n\t\t\t\t\tcv-ref = \"blur\"\n\t\t\t\t/>\n\t\t\t</filter>\n\t\t</defs>\n\t\t</svg>\n\n\t\t<svg height=\"100\" width=\"100\">\n\t\t<defs>\n\t\t\t<filter id=\"waterBlur\">\n\t\t\t\t<feGaussianBlur in=\"SourceGraphic\" stdDeviation=\"0.25,0\" />\n\t\t\t</filter>\n\n\t\t\t<filter id=\"dilate\">\n\t\t\t\t<feMorphology operator=\"dilate\" radius=\"0.25\" result = \"expanded\"/>\n\t\t\t\t<feMerge>\n\t\t\t\t\t<feMergeNode in=\"expanded\" />\n\t\t\t\t\t<feMergeNode in=\"SourceGraphic\" />\n\t\t\t\t</feMerge>\n\t\t\t</filter>\n\n\t\t\t<filter id = \"waves\"\n\t\t\t\tcolor-interpolation-filters=\"sRGB\"\n\t\t\t\tx      =\"0%\"\n\t\t\t\ty      =\"0%\"\n\t\t\t\theight =\"100%\"\n\t\t\t\twidth  =\"100%\"\n\t\t\t>\n\t\t\t\t<feFlood\n\t\t\t\t\tflood-color=\"#408000\"\n\t\t\t\t\tresult = \"DisplacementGreen\"\n\t\t\t\t></feFlood>\n\n\t\t\t\t<feImage\n\t\t\t\t\txlink:href=\"/effects/wave.png\"\n\t\t\t\t\tresult=\"DisplacementSource\"\n\t\t\t\t\theight=\"64\"\n\t\t\t\t\twidth=\"64\"\n\t\t\t\t></feImage>\n\n\t\t\t\t<feTile\n\t\t\t\t\tin=\"DisplacementSource\"\n\t\t\t\t\tresult=\"DisplacementTile\"\n\t\t\t\t></feTile>\n\n\t\t\t\t<feComposite\n\t\t\t\t\tin  = \"DisplacementTile\"\n\t\t\t\t\tin2 = \"DisplacementGreen\"\n\t\t\t\t\tresult =\"DisplacementField\"\n\t\t\t\t\toperator =\"over\"\n\t\t\t\t></feComposite>\n\n\t\t\t\t<feOffset\n\t\t\t\t\tin  = \"DisplacementField\"\n\t\t\t\t\tout = \"DisplacementOffset\"\n\t\t\t\t\tdx  = \"0\"\n\t\t\t\t>\n\t\t\t\t\t<animate\n\t\t\t\t\t\tattributeName=\"dy\"\n\t\t\t\t\t\tvalues = \"0;-64\"\n\t\t\t\t\t\tdur=\"1500ms\"\n\t\t\t\t\t\trepeatCount=\"indefinite\" />\n\n\t\t\t\t</feOffset>\n\n\t\t\t\t<feDisplacementMap\n\t\t\t\t\tin=\"SourceGraphic\"\n\t\t\t\t\tin2=\"DisplacementOffset\"\n\t\t\t\t\tresult=\"Displaced\"\n\t\t\t\t\txChannelSelector=\"R\"\n\t\t\t\t\tyChannelSelector=\"G\"\n\t\t\t\t\tscale=\"4\"\n\t\t\t\t></feDisplacementMap>\n\n\t\t\t\t<feGaussianBlur\n\t\t\t\t\tin=\"Displaced\"\n\t\t\t\t\tstdDeviation=\"0.35\"\n\t\t\t\t></feGaussianBlur>\n\t\t\t</filter>\n\n\t\t\t<filter id = \"ntsc\"\n\t\t\t\tcolor-interpolation-filters=\"sRGB\"\n\t\t\t\tx      = \"0%\"\n\t\t\t\ty      = \"0%\"\n\t\t\t\twidth  = \"100%\"\n\t\t\t\theight = \"200%\"\n\t\t\t>\n\t\t\t\t<feFlood\n\t\t\t\t\tflood-color=\"#808000\"\n\t\t\t\t\tresult = \"DisplacementGreen\"\n\t\t\t\t></feFlood>\n\n\t\t\t\t<feImage\n\t\t\t\t\txlink:href=\"/effects/ntsc-static.png\"\n\t\t\t\t\tresult =\"DisplacementSource\"\n\t\t\t\t\twidth  = \"128\"\n\t\t\t\t\theight = \"128\"\n\t\t\t\t></feImage>\n\n\t\t\t\t<feTile\n\t\t\t\t\tin=\"DisplacementSource\"\n\t\t\t\t\tresult=\"DisplacementTile\"\n\t\t\t\t></feTile>\n\n\t\t\t\t<feComposite\n\t\t\t\t\tin  = \"DisplacementTile\"\n\t\t\t\t\tin2 = \"DisplacementGreen\"\n\t\t\t\t\tresult =\"DisplacementField\"\n\t\t\t\t\toperator =\"over\"\n\t\t\t\t></feComposite>\n\n\t\t\t\t<feOffset\n\t\t\t\t\tin  = \"DisplacementField\"\n\t\t\t\t\tout = \"DisplacementOffset\"\n\t\t\t\t\tdx  = \"0\"\n\t\t\t\t\tdy  = \"0\"\n\t\t\t\t>\n\t\t\t\t\t<animate\n\t\t\t\t\t\tattributeName=\"dy\"\n\t\t\t\t\t\tvalues = \"-128;0\"\n\t\t\t\t\t\tbegin=\"2000ms\"\n\t\t\t\t\t\tdur=\"2000ms\"\n\t\t\t\t\t\trepeatCount=\"8\"\n\t\t\t\t\t></animate>\n\n\t\t\t\t</feOffset>\n\n\t\t\t\t<feDisplacementMap\n\t\t\t\t\tin=\"SourceGraphic\"\n\t\t\t\t\tin2=\"DisplacementOffset\"\n\t\t\t\t\tresult=\"Displaced\"\n\t\t\t\t\txChannelSelector=\"R\"\n\t\t\t\t\tyChannelSelector=\"G\"\n\t\t\t\t\tscale = \"0\"\n\t\t\t\t>\n\t\t\t\t\t<animate\n\t\t\t\t\t\tattributeName=\"scale\"\n\t\t\t\t\t\tvalues = \"512;192;0\"\n\t\t\t\t\t\tbegin=\"2000ms\"\n\t\t\t\t\t\tdur=\"2000ms\"\n\t\t\t\t\t\trepeatCount=\"1\"\n\t\t\t\t\t></animate>\n\n\t\t\t\t</feDisplacementMap>\n\t\t\t</filter>\n\n\t\t</defs>\n\t\t</svg>\n\n\t\t<div class = \"viewport-zoom\">\n\n\t\t\t[[backdrop]]\n\n\t\t\t<div class = \"backdrops\" cv-ref =\"backdrops\"></div>\n\n\t\t\t<div class = \"viewport-tilt\" cv-ref = \"tilt\">\n\t\t\t\t<div class = \"blurAngle\" cv-ref = \"blurAngle\">\n\t\t\t\t<div class = \"blurDistance\" cv-ref = \"blurDistance\">\n\t\t\t\t<div class = \"blurAngleCancel\" cv-ref = \"blurAngleCancel\">\n\t\t\t\t\t<div\n\t\t\t\t\t\tcv-ref  = \"background\"\n\t\t\t\t\t\tclass   = \"viewport-bg-layers\"\n\t\t\t\t\t\tcv-each = \"layers:layer\"\n\t\t\t\t\t>[[layer]]</div>\n\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t\t</div>\n\n\t\t\t\t<div class = \"filters filters-background\" cv-ref = \"bgFilters\"></div>\n\n\t\t\t\t<div cv-ref = \"content\" class = \"viewport-content\">\n\t\t\t\t\t<div cv-ref = \"actors\" class = \"viewport-actors\"></div>\n\t\t\t\t\t<div cv-ref = \"particles\" class = \"viewport-particles\"></div>\n\t\t\t\t</div>\n\n\t\t\t\t<div class = \"blurAngle\" cv-ref = \"blurAngleFg\">\n\t\t\t\t<div class = \"blurDistance\" cv-ref = \"blurDistanceFg\">\n\t\t\t\t<div class = \"blurAngleCancel\" cv-ref = \"blurAngleCancelFg\">\n\t\t\t\t\t<div\n\t\t\t\t\t\tcv-ref  = \"foreground\"\n\t\t\t\t\t\tclass   = \"viewport-bg-layers viewport-fg-layers\"\n\t\t\t\t\t\tcv-each = \"fgLayers:layer\"\n\t\t\t\t\t>[[layer]]</div>\n\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</div>\n\n \t\t[[plot]]\n\n \t\t<div class = \"viewport-overlay\">\n \t\t\t<div class = \"debug-spawn\" cv-if = \"debugEditMode\">\n \t\t\t\t<div class = \"debug-spawn\" cv-ref = \"spawnPreview\"></div>\n \t\t\t\t<div class = \"debug-spawn\">[[debugObjectName]]</div>\n \t\t\t</div>\n\n\t\t\t<div class = \"hud now-loading\"></div>\n\n\t\t\t<div class = \"hud hud-top-right hud-table combo-table\">\n\t\t\t\t<span cv-if = \"showCombo\">\n\t\t\t\t\t<span>\n\t\t\t\t\t\t<span class = \"combo-list\" cv-each = \"combo:pop:p\">\n\t\t\t\t\t\t\t<div>[[pop.label]]</div>\n\t\t\t\t\t\t</span>\n\t\t\t\t\t\t<span class = \"comboTopLine\" cv-if = \"combo\">[[popBottomLine]]</span>\n\t\t\t\t\t</span>\n\t\t\t\t\t<span class = \"comboTopLine\" cv-if = \"combo\">[[popTopLine]]</span>\n\t\t\t\t</span>\n\t\t\t\t<span class = \"comboFail\">[[comboFail]]</span>\n\t\t\t\t<span class = \"comboResult\">[[comboResult]]</span>\n\t\t\t</div>\n\n\t\t\t<div class = \"hud hud-top-right hud-table quick-form\">[[quickForm]]</div>\n\n\t\t\t<div class = \"hud hud-top-right hud-table\"  cv-if = \"debugOsd\">\n\t\t\t\t<table>\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<td colspan = \"2\">[[char]]</td>\n\t\t\t\t\t</tr>\n\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<td>[[labelGround]]</td>\n\t\t\t\t\t\t<td>[[ground]]</td>\n\t\t\t\t\t</tr>\n\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<td>[[labelCamera]]</td>\n\t\t\t\t\t\t<td>[[cameraMode]]</td>\n\t\t\t\t\t</tr>\n\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<td>[[labelMode]]</td>\n\t\t\t\t\t\t<td>[[mode]]</td>\n\t\t\t\t\t</tr>\n\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<td>[[labelX]]</td>\n\t\t\t\t\t\t<td>[[xPos]]</td>\n\t\t\t\t\t</tr>\n\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<td>[[labelY]]</td>\n\t\t\t\t\t\t<td>[[yPos]]</td>\n\t\t\t\t\t</tr>\n\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<td>[[labelLayer]]</td>\n\t\t\t\t\t\t<td>[[layer]]</td>\n\t\t\t\t\t</tr>\n\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<td>[[labelGSpeed]]</td>\n\t\t\t\t\t\t<td>[[gSpeed]]</td>\n\t\t\t\t\t</tr>\n\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<td>[[labelXSpeed]]</td>\n\t\t\t\t\t\t<td>[[xSpeed]]</td>\n\t\t\t\t\t</tr>\n\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<td>[[labelYSpeed]]</td>\n\t\t\t\t\t\t<td>[[ySpeed]]</td>\n\t\t\t\t\t</tr>\n\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<td>[[labelAirAngle]]</td>\n\t\t\t\t\t\t<td>[[airAngle]]</td>\n\t\t\t\t\t</tr>\n\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<td>[[labelAngle]]</td>\n\t\t\t\t\t\t<td>[[angle]]</td>\n\t\t\t\t\t</tr>\n\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<td>[[labelActors]]</td>\n\t\t\t\t\t\t<td>[[actorCount]]</td>\n\t\t\t\t\t</tr>\n\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<td>[[labelRegions]]</td>\n\t\t\t\t\t\t<td>[[regionCount]]</td>\n\t\t\t\t\t</tr>\n\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<td>[[labelFrame]]</td>\n\t\t\t\t\t\t<td>[[frame]]</td>\n\t\t\t\t\t</tr>\n\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<td>[[labelIgnore]]</td>\n\t\t\t\t\t\t<td>[[ignore]]</td>\n\t\t\t\t\t</tr>\n\n\t\t\t\t</table>\n\t\t\t</div>\n\n\t\t\t<div class = \"hud hud-top-right\" cv-if = \"showHud\">\n\n\t\t\t\t<div class = \"char-hud\">\n\t\t\t\t\t[[prompt]] [[char]]\n\t\t\t\t\t<div class = \"char-icon [[charName|hyphenate]]\"></div>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<div class = \"emblem-hud\" cv-each = \"emblems:emblem:e\">\n\t\t\t\t\t\t<img loading=\"lazy\" src = \"/custom/hud-emblem.png\" class = \"[[emblem.existing]]\" />\n\t\t\t\t\t</div>\n\t\t\t\t\t<div class = \"collectible-hud\" cv-each = \"inventory:item\">\n\t\t\t\t\t\t<span cv-if = \"item.icon\">\n\t\t\t\t\t\t\t<img loading=\"lazy\" src = \"[[item.icon]]\" class = \"inventory-icon\" />\n\t\t\t\t\t\t</span>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t\t<div class = \"emerald-hud\" cv-each = \"emeralds:emerald:e\">\n\t\t\t\t\t<img loading=\"lazy\" src = \"/Sonic/emerald-[[emerald]]-mini.png\" />\n\t\t\t\t</div>\n\t\t\t</div>\n\n\t\t\t<div class = \"hud hud-bottom-right\">\n\n\t\t\t\t<div cv-if = \"showHud\" class =\"sheild-hud [[currentSheild]] [[hasElectric]] [[hasFire]] [[hasWater]] [[hasNormal]]\">\n\t\t\t\t\t<div class = \"sheild-icon sheild-electric\"></div>\n\t\t\t\t\t<div class = \"sheild-icon sheild-normal\"></div>\n\t\t\t\t\t<div class = \"sheild-icon sheild-fire\"></div>\n\t\t\t\t\t<div class = \"sheild-icon sheild-water\"></div>\n\t\t\t\t</div>\n\n\t\t\t\t<span class = \"contents\" cv-if = \"showFps\">\n\t\t\t\t\t<table>\n\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t<td>[[labelFps]]</td>\n\t\t\t\t\t\t\t<td>[[fpsSprite]]</td>\n\t\t\t\t\t\t</tr>\n\t\t\t\t\t</table>\n\t\t\t\t</span>\n\t\t\t</div>\n\n\t\t\t<div class = \"hud hud-dark hud-bottom-left\" cv-if = \"showHud\" data-extra = \"[[audioComment]]\" data-secret-icon = [[secretIcon]] cv-on = \"click:nowPlayingClicked\">\n\t\t\t\t[[nowPlaying]]\n\t\t\t\t[[trackName]]\n\t\t\t</div>\n\n\t\t\t<div class = \"hud hud-top-left hud-table\"  cv-if = \"showHud\">\n\t\t\t\t<table>\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<td>[[scoreLabel]]</td><td>[[score]]</td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<td>[[timerLabel]]</td><td>[[timer]]</td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<td>[[ringLabel]]</td><td>[[rings]]</td>\n\t\t\t\t\t</tr>\n\t\t\t\t</table>\n\t\t\t\t<!-- <div class = \"demo-hud\" cv-if = \"demoIndicator\">[[demoIndicator]]</div> -->\n\t\t\t</div>\n\n\t\t\t<div class = \"hud hud-dark hud-centered\" cv-if = \"actClear\">\n\t\t\t\t<div class = \"centered act-cleared\">[[actClearLabel]]</div>\n\t\t\t\t[[tallyBoard]]\n\t\t\t</div>\n\n\t\t\t<div class = \"hud hud-dark hud-centered\" cv-if = \"centerMessage\">\n\t\t\t\t[[centerMessage]]\n\t\t\t</div>\n\n\t\t\t<div class = \"hud hud-dark hud-centered-raised\" cv-if = \"dialog\">\n\t\t\t\t<div class = \"dialog-frame [[dialogClasses]]\">\n\t\t\t\t\t<div class = \"dialog-icon\">\n\t\t\t\t\t</div>\n\t\t\t\t\t<div cv-each = \"dialogLines:line\" class = \"dialog-text\">\n\t\t\t\t\t\t<span style = \"--text-offset:[[line.offset]]\">[[line]]</span>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t</div>\n\n\t\t\t<div class = \"screen-effects\" cv-each = \"screenEffects:effect\">\n\t\t\t\t[[effect]]\n\t\t\t</div>\n\n\t\t\t<section class = \"pause-menu full\" cv-if = \"paused\">[[pauseMenu]]</section>\n\n\t\t\t[[titlecard]]\n\n\t\t\t<div class = \"topLine\">\n\t\t\t\t<div class = \"status-message\">[[topLine]]</div>\n\t\t\t</div>\n\n\t\t\t<div class = \"focus-me\">\n\t\t\t\t<div class = \"status-message\">[[focusMe]]</div>\n\t\t\t</div>\n\n\t\t\t<div class = \"status-message\">[[status]]</div>\n\t\t\t<section class = \"contents\" cv-if = \"networked\">[[chatBox]]</section>\n\t\t\t<!-- <div class = \"filters filters-foreground\" cv-ref = \"fgFilters\"></div> -->\n\t\t\t<div class = \"console [[showConsole]]\" cv-ref = \"subspace\" tab-index = \"0\">[[subspace]]</div>\n\t\t\t<div class = \"shade\" data-fade = \"[[fade]]\"></div>\n\n\t\t</div>\n\n\t\t<div class = \"quick-controls\" cv-if = \"shortcuts\">\n\t\t\t[[muteSwitch]]\n\t\t\t<div class = \"button\" cv-on = \"click:fullscreen()\">\n\t\t\t\t<image src = \"/ui/fullscreen.svg\" />\n\t\t\t</div>\n\t\t</div>\n\n\t</div>\n</div>\n"
});

;require.register("zoneScripts/ChaoGarden.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ChaoGarden = void 0;
var _Spring = require("../actor/Spring");
var _OrbSmall = require("../actor/OrbSmall");
var _WoodenCrate = require("../actor/WoodenCrate");
var _SkidDust = require("../behavior/SkidDust");
var _Chao = require("../actor/Chao");
class ChaoGarden {
  update(frameId, viewport) {
    if (frameId === 0) {
      const zoneState = viewport.getZoneState();
      if (zoneState.chao) for (const chaoData of zoneState.chao) {
        const chao = new _Chao.Chao();
        chao.load(chaoData);
        viewport.spawn.add({
          object: chao
        });
      }
    }

    // if(!viewport.controlActor)
    // {
    // 	return;
    // }

    // if(!frameId)
    // {
    // }
  }
}
exports.ChaoGarden = ChaoGarden;
});

;require.register("zoneScripts/InfiniteRuin.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.InfiniteRuin = void 0;
var _Spring = require("../actor/Spring");
var _OrbSmall = require("../actor/OrbSmall");
var _WoodenCrate = require("../actor/WoodenCrate");
var _SkidDust = require("../behavior/SkidDust");
var _Ring = require("../actor/Ring");
class InfiniteRuin {
  update(frameId, viewport) {
    if (!viewport.controlActor) {
      return;
    }

    // if(frameId > 120)
    // {
    // 	viewport.arg.fake = 'fail';
    // }

    if (viewport.controlActor.args.dead || viewport.controlActor.args.startled) {
      return;
    }
    if (frameId < 30 && viewport.controlActor) {
      viewport.controlActor.args.gSpeed = 15;
    }
    let freq = 120;
    if (frameId < 600) {
      freq = 150;
    }
    if (frameId > 1200) {
      freq = 100;
    }
    if (frameId > 1800) {
      freq = 90;
    }
    if (frameId > 120 && frameId % freq === 0 && viewport.controlActor) {
      let rand = Math.random();
      this.spawnRings(viewport, rand > 0.25 ? 32 : 0);
      if (frameId < 900) {
        rand = 0;
      }
      if (frameId < 900) {
        rand *= 0.79;
      }
      if (viewport.objectDb.has(_WoodenCrate.WoodenCrate)) {
        if (viewport.objectDb.get(_WoodenCrate.WoodenCrate).size) {
          rand = 0;
        }
      }
      if (rand > 0.5) {
        this.spawnBox(viewport);
      } else {
        this.spawnOrb(viewport);
      }
    }
  }
  spawnOrb(viewport) {
    const thing = new _OrbSmall.OrbSmall();
    const type = Math.trunc(Math.random() * 8);
    thing.args.xSpeed = viewport.controlActor.args.gSpeed || viewport.controlActor.args.xSpeed;
    thing.args.gSpeed = viewport.controlActor.args.gSpeed || viewport.controlActor.args.xSpeed;
    switch (type) {
      case 0:
        thing.args.x = viewport.controlActor.args.x + 320;
        thing.args.y = 928 - 320;
        thing.args.friction = 0.75;
        thing.args.bounce = 0.75;
        break;
      case 1:
        thing.args.x = viewport.controlActor.args.x + 320;
        thing.args.y = 928 - 320;
        thing.args.friction = 0.70;
        thing.args.bounce = 0.75;
        break;
      case 2:
        thing.args.x = viewport.controlActor.args.x + 400;
        thing.args.y = 928 - 0;
        thing.args.decel = 0.05;
        thing.args.bounce = 0.0;
        thing.args.gSpeed = 18;
        thing.args.xSpeed = 18;
        break;
      case 3:
        thing.args.x = viewport.controlActor.args.x + 400;
        thing.args.y = 928 - 0;
        thing.args.decel = 0.2;
        thing.args.bounce = 0.0;
        thing.args.gSpeed = 18;
        thing.args.xSpeed = 18;
        break;
      case 4:
        thing.args.x = viewport.controlActor.args.x + 400;
        thing.args.y = 928 - 48;
        thing.args.friction = 0.90;
        thing.args.decel = 0.15;
        thing.args.bounce = 0.999;
        break;
      case 5:
        thing.args.x = viewport.controlActor.args.x + 400;
        thing.args.y = 928 - 24;
        thing.args.friction = 0.80;
        thing.args.decel = 0.15;
        thing.args.bounce = 0.999;
        break;
      case 6:
        thing.args.x = viewport.controlActor.args.x + 320;
        thing.args.y = 928 - 320;
        thing.args.friction = 0.75;
        thing.args.bounce = 0.70;
        break;
      case 7:
        thing.args.x = viewport.controlActor.args.x + 320;
        thing.args.y = 928 - 320;
        thing.args.friction = 0.70;
        thing.args.bounce = 0.80;
        break;
    }
    thing.args.canHide = true;
    viewport.spawn.add({
      object: thing
    });
  }
  spawnBox(viewport) {
    let thing;
    thing = new _WoodenCrate.WoodenCrate();
    let type = Math.trunc(Math.random() * 8);
    thing.args.x = viewport.controlActor.args.x + 320;
    thing.args.y = 928 - 320;
    thing.args.friction = 0.76;
    thing.args.bounce = 0.65;
    thing.args.contains = 'ring-monitor';
    thing.alwaysSkidding = true;
    thing.dustFreq = 5;
    thing.behaviors.add(new _SkidDust.SkidDust());
    thing.args.xSpeed = viewport.controlActor.args.gSpeed || viewport.controlActor.args.xSpeed;
    thing.args.gSpeed = viewport.controlActor.args.gSpeed || viewport.controlActor.args.xSpeed;
    viewport.spawn.add({
      object: thing
    });
  }
  spawnRings(viewport) {
    let offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    for (let i = 0; i < 3; i++) {
      const thing = new _Ring.Ring();
      const type = Math.trunc(Math.random() * 8);
      thing.args.x = viewport.controlActor.args.x + 320 + i * 32;
      thing.args.y = 928 + -16 + -offset;
      viewport.spawn.add({
        object: thing
      });
    }
  }
  spawnSpring(viewport) {
    let thing;
    thing = new _Spring.Spring();
    let type = Math.trunc(Math.random() * 8);
    thing.args.x = viewport.controlActor.args.x + 320;
    thing.args.y = 928 - 320;
    thing.args.decel = 0.03;
    thing.args.power = 10;
    thing.args.width = 32;
    thing.args.height = 16;
    thing.args.angle = -Math.PI / 2;
    thing.args.groundAngle = 0;
    thing.args.static = false;
    thing.args.canHide = true;
    thing.alwaysSkidding = true;
    thing.float = 0;
    thing.dustFreq = 5;
    thing.behaviors.add(new _SkidDust.SkidDust());
    thing.args.xSpeed = viewport.controlActor.args.gSpeed || viewport.controlActor.args.xSpeed;
    thing.args.gSpeed = viewport.controlActor.args.gSpeed || viewport.controlActor.args.xSpeed;
    viewport.spawn.add({
      object: thing
    });
    const originalSleep = thing.sleep;
    thing.sleep = () => viewport.actors.remove(thing);
  }
}
exports.InfiniteRuin = InfiniteRuin;
});

;require.register("___globals___", function(exports, require, module) {
  
});})();require('___globals___');

"use strict";

/* jshint ignore:start */
(function () {
  var WebSocket = window.WebSocket || window.MozWebSocket;
  var br = window.brunch = window.brunch || {};
  var ar = br['auto-reload'] = br['auto-reload'] || {};
  if (!WebSocket || ar.disabled) return;
  if (window._ar) return;
  window._ar = true;
  var cacheBuster = function (url) {
    var date = Math.round(Date.now() / 1000).toString();
    url = url.replace(/(\&|\\?)cacheBuster=\d*/, '');
    return url + (url.indexOf('?') >= 0 ? '&' : '?') + 'cacheBuster=' + date;
  };
  var browser = navigator.userAgent.toLowerCase();
  var forceRepaint = ar.forceRepaint || browser.indexOf('chrome') > -1;
  var reloaders = {
    page: function () {
      window.location.reload(true);
    },
    stylesheet: function () {
      [].slice.call(document.querySelectorAll('link[rel=stylesheet]')).filter(function (link) {
        var val = link.getAttribute('data-autoreload');
        return link.href && val != 'false';
      }).forEach(function (link) {
        link.href = cacheBuster(link.href);
      });

      // Hack to force page repaint after 25ms.
      if (forceRepaint) setTimeout(function () {
        document.body.offsetHeight;
      }, 25);
    },
    javascript: function () {
      var scripts = [].slice.call(document.querySelectorAll('script'));
      var textScripts = scripts.map(function (script) {
        return script.text;
      }).filter(function (text) {
        return text.length > 0;
      });
      var srcScripts = scripts.filter(function (script) {
        return script.src;
      });
      var loaded = 0;
      var all = srcScripts.length;
      var onLoad = function () {
        loaded = loaded + 1;
        if (loaded === all) {
          textScripts.forEach(function (script) {
            eval(script);
          });
        }
      };
      srcScripts.forEach(function (script) {
        var src = script.src;
        script.remove();
        var newScript = document.createElement('script');
        newScript.src = cacheBuster(src);
        newScript.async = true;
        newScript.onload = onLoad;
        document.head.appendChild(newScript);
      });
    }
  };
  var port = ar.port || 9485;
  var host = br.server || window.location.hostname || 'localhost';
  var connect = function () {
    var connection = new WebSocket('ws://' + host + ':' + port);
    connection.onmessage = function (event) {
      if (ar.disabled) return;
      var message = event.data;
      var reloader = reloaders[message] || reloaders.page;
      reloader();
    };
    connection.onerror = function () {
      if (connection.readyState) connection.close();
    };
    connection.onclose = function () {
      window.setTimeout(connect, 1000);
    };
  };
  connect();
})();
/* jshint ignore:end */
;
//# sourceMappingURL=app.js.map