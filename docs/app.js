(function() {
  'use strict';

  var globals = typeof global === 'undefined' ? self : global;
  if (typeof globals.require === 'function') return;

  var modules = {};
  var cache = {};
  var aliases = {};
  var has = {}.hasOwnProperty;

  var expRe = /^\.\.?(\/|$)/;
  var expand = function(root, name) {
    var results = [], part;
    var parts = (expRe.test(name) ? root + '/' + name : name).split('/');
    for (var i = 0, length = parts.length; i < length; i++) {
      part = parts[i];
      if (part === '..') {
        results.pop();
      } else if (part !== '.' && part !== '') {
        results.push(part);
      }
    }
    return results.join('/');
  };

  var dirname = function(path) {
    return path.split('/').slice(0, -1).join('/');
  };

  var localRequire = function(path) {
    return function expanded(name) {
      var absolute = expand(dirname(path), name);
      return globals.require(absolute, path);
    };
  };

  var initModule = function(name, definition) {
    var hot = hmr && hmr.createHot(name);
    var module = {id: name, exports: {}, hot: hot};
    cache[name] = module;
    definition(module.exports, localRequire(name), module);
    return module.exports;
  };

  var expandAlias = function(name) {
    var val = aliases[name];
    return (val && name !== val) ? expandAlias(val) : name;
  };

  var _resolve = function(name, dep) {
    return expandAlias(expand(dirname(name), dep));
  };

  var require = function(name, loaderPath) {
    if (loaderPath == null) loaderPath = '/';
    var path = expandAlias(name);

    if (has.call(cache, path)) return cache[path].exports;
    if (has.call(modules, path)) return initModule(path, modules[path]);

    throw new Error("Cannot find module '" + name + "' from '" + loaderPath + "'");
  };

  require.alias = function(from, to) {
    aliases[to] = from;
  };

  var extRe = /\.[^.\/]+$/;
  var indexRe = /\/index(\.[^\/]+)?$/;
  var addExtensions = function(bundle) {
    if (extRe.test(bundle)) {
      var alias = bundle.replace(extRe, '');
      if (!has.call(aliases, alias) || aliases[alias].replace(extRe, '') === alias + '/index') {
        aliases[alias] = bundle;
      }
    }

    if (indexRe.test(bundle)) {
      var iAlias = bundle.replace(indexRe, '');
      if (!has.call(aliases, iAlias)) {
        aliases[iAlias] = bundle;
      }
    }
  };

  require.register = require.define = function(bundle, fn) {
    if (bundle && typeof bundle === 'object') {
      for (var key in bundle) {
        if (has.call(bundle, key)) {
          require.register(key, bundle[key]);
        }
      }
    } else {
      modules[bundle] = fn;
      delete cache[bundle];
      addExtensions(bundle);
    }
  };

  require.list = function() {
    var list = [];
    for (var item in modules) {
      if (has.call(modules, item)) {
        list.push(item);
      }
    }
    return list;
  };

  var hmr = globals._hmr && new globals._hmr(_resolve, require, modules, cache);
  require._cache = cache;
  require.hmr = hmr && hmr.wrap;
  require.brunch = true;
  globals.require = require;
})();

(function() {
var global = typeof window === 'undefined' ? this : window;
var __makeRelativeRequire = function(require, mappings, pref) {
  var none = {};
  var tryReq = function(name, pref) {
    var val;
    try {
      val = require(pref + '/node_modules/' + name);
      return val;
    } catch (e) {
      if (e.toString().indexOf('Cannot find module') === -1) {
        throw e;
      }

      if (pref.indexOf('node_modules') !== -1) {
        var s = pref.split('/');
        var i = s.lastIndexOf('node_modules');
        var newPref = s.slice(0, i).join('/');
        return tryReq(name, newPref);
      }
    }
    return none;
  };
  return function(name) {
    if (name in mappings) name = mappings[name];
    if (!name) return;
    if (name[0] !== '.' && pref) {
      var val = tryReq(name, pref);
      if (val !== none) return val;
    }
    return require(name);
  }
};

require.register("curvature/animate/Ease.js", function(exports, require, module) {
  require = __makeRelativeRequire(require, {}, "curvature");
  (function() {
    "use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Ease = void 0;
var _Mixin = require("../base/Mixin");
var _PromiseMixin = require("../mixin/PromiseMixin");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
var Ease = /*#__PURE__*/function (_Mixin$with) {
  _inherits(Ease, _Mixin$with);
  var _super = _createSuper(Ease);
  function Ease(interval) {
    var _this;
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    _classCallCheck(this, Ease);
    _this = _super.call(this);
    _this.interval = interval;
    _this.terminal = false;
    _this.initial = false;
    _this.timeout = false;
    _this.final = false;
    _this.canceled = false;
    _this.done = false;
    _this.calculate = _this.calculate || 'calculate' in options ? options.calculate : false;
    _this.bounded = 'bounded' in options ? options.bounded : true;
    _this.repeat = 'repeat' in options ? options.repeat : 1;
    _this.reverse = 'reverse' in options ? options.reverse : false;
    return _this;
  }
  _createClass(Ease, [{
    key: "start",
    value: function start() {
      this.done = false;
      requestAnimationFrame(() => {
        this.initial = Date.now();
        this.terminal = this.initial + this.interval;
        if (this.repeat >= 0) {
          this.terminal = this.initial + this.interval * this.repeat;
          this.timeout = setTimeout(() => {
            if (this.done) {
              return this.reverse ? 0 : 1;
            }
            this.done = true;
            this[_PromiseMixin.PromiseMixin.Accept](this.reverse ? 0 : 1);
          }, this.interval * this.repeat);
        }
      });
    }
  }, {
    key: "cancel",
    value: function cancel() {
      if (this.done) {
        return this.final;
      }
      clearTimeout(this.timeout);
      this.final = this.current();
      this.canceled = this.done = true;
      this[_PromiseMixin.PromiseMixin.Reject](this.final);
      return this.final;
    }
  }, {
    key: "fraction",
    value: function fraction() {
      if (this.done) {
        return this.reverse ? 0 : 1;
      }
      if (this.initial === false) {
        return this.reverse ? 1 : 0;
      }
      var elapsed = Date.now() - this.initial;
      if (elapsed / this.interval >= this.repeat) {
        return this.reverse ? 0 : 1;
      }
      var fraction = elapsed % this.interval / this.interval;
      return this.reverse ? 1 - fraction : fraction;
    }
  }, {
    key: "current",
    value: function current() {
      var t = this.fraction();
      if (this.calculate) {
        return this.calculate(t);
      }
      return t;
    }
  }]);
  return Ease;
}(_Mixin.Mixin.with(_PromiseMixin.PromiseMixin));
exports.Ease = Ease;
  })();
});

require.register("curvature/animate/ease/CubicInOut.js", function(exports, require, module) {
  require = __makeRelativeRequire(require, {}, "curvature");
  (function() {
    "use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CubicInOut = void 0;
var _Ease2 = require("../Ease");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var CubicInOut = /*#__PURE__*/function (_Ease) {
  _inherits(CubicInOut, _Ease);
  var _super = _createSuper(CubicInOut);
  function CubicInOut() {
    var _this;
    _classCallCheck(this, CubicInOut);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _defineProperty(_assertThisInitialized(_this), "calculate", t => t < .5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1);
    return _this;
  }
  return _createClass(CubicInOut);
}(_Ease2.Ease);
exports.CubicInOut = CubicInOut;
  })();
});

require.register("curvature/animate/ease/QuintInOut.js", function(exports, require, module) {
  require = __makeRelativeRequire(require, {}, "curvature");
  (function() {
    "use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.QuintInOut = void 0;
var _Ease2 = require("../Ease");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var QuintInOut = /*#__PURE__*/function (_Ease) {
  _inherits(QuintInOut, _Ease);
  var _super = _createSuper(QuintInOut);
  function QuintInOut() {
    var _this;
    _classCallCheck(this, QuintInOut);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _defineProperty(_assertThisInitialized(_this), "calculate", t => t < .5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t);
    return _this;
  }
  return _createClass(QuintInOut);
}(_Ease2.Ease);
exports.QuintInOut = QuintInOut;
  })();
});

require.register("curvature/base/Bag.js", function(exports, require, module) {
  require = __makeRelativeRequire(require, {}, "curvature");
  (function() {
    "use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Bag = void 0;
var _Bindable = require("./Bindable");
var _Mixin = require("./Mixin");
var _EventTargetMixin = require("../mixin/EventTargetMixin");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
var toId = int => Number(int);
var fromId = id => parseInt(id);
var Mapped = Symbol('Mapped');
var Has = Symbol('Has');
var Add = Symbol('Add');
var Remove = Symbol('Remove');
var Delete = Symbol('Delete');
var Bag = /*#__PURE__*/function (_Mixin$with) {
  _inherits(Bag, _Mixin$with);
  var _super = _createSuper(Bag);
  function Bag() {
    var _this;
    var changeCallback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;
    _classCallCheck(this, Bag);
    _this = _super.call(this);
    _this.changeCallback = changeCallback;
    _this.content = new Map();
    _this.current = 0;
    _this.length = 0;
    _this.list = _Bindable.Bindable.makeBindable([]);
    _this.meta = Symbol('meta');
    _this.type = undefined;
    return _this;
  }
  _createClass(Bag, [{
    key: "has",
    value: function has(item) {
      if (this[Mapped]) {
        return this[Mapped].has(item);
      }
      return this[Has](item);
    }
  }, {
    key: Has,
    value: function value(item) {
      return this.content.has(item);
    }
  }, {
    key: "add",
    value: function add(item) {
      if (this[Mapped]) {
        return this[Mapped].add(item);
      }
      return this[Add](item);
    }
  }, {
    key: Add,
    value: function value(item) {
      if (item === undefined || !(item instanceof Object)) {
        throw new Error('Only objects may be added to Bags.');
      }
      if (this.type && !(item instanceof this.type)) {
        console.error(this.type, item);
        throw new Error("Only objects of type ".concat(this.type, " may be added to this Bag."));
      }
      item = _Bindable.Bindable.make(item);
      if (this.content.has(item)) {
        return;
      }
      var adding = new CustomEvent('adding', {
        detail: {
          item: item
        }
      });
      if (!this.dispatchEvent(adding)) {
        return;
      }
      var id = toId(this.current++);
      this.content.set(item, id);
      this.list[id] = item;
      if (this.changeCallback) {
        this.changeCallback(item, this.meta, Bag.ITEM_ADDED, id);
      }
      var add = new CustomEvent('added', {
        detail: {
          item: item,
          id: id
        }
      });
      this.dispatchEvent(add);
      this.length = this.size;
      return id;
    }
  }, {
    key: "remove",
    value: function remove(item) {
      if (this[Mapped]) {
        return this[Mapped].remove(item);
      }
      return this[Remove](item);
    }
  }, {
    key: Remove,
    value: function value(item) {
      if (item === undefined || !(item instanceof Object)) {
        throw new Error('Only objects may be removed from Bags.');
      }
      if (this.type && !(item instanceof this.type)) {
        console.error(this.type, item);
        throw new Error("Only objects of type ".concat(this.type, " may be removed from this Bag."));
      }
      item = _Bindable.Bindable.make(item);
      if (!this.content.has(item)) {
        if (this.changeCallback) {
          this.changeCallback(item, this.meta, 0, undefined);
        }
        return false;
      }
      var removing = new CustomEvent('removing', {
        detail: {
          item: item
        }
      });
      if (!this.dispatchEvent(removing)) {
        return;
      }
      var id = this.content.get(item);
      delete this.list[id];
      this.content.delete(item);
      if (this.changeCallback) {
        this.changeCallback(item, this.meta, Bag.ITEM_REMOVED, id);
      }
      var remove = new CustomEvent('removed', {
        detail: {
          item: item,
          id: id
        }
      });
      this.dispatchEvent(remove);
      this.length = this.size;
      return item;
    }
  }, {
    key: "delete",
    value: function _delete(item) {
      if (this[Mapped]) {
        return this[Mapped].delete(item);
      }
      this[Delete](item);
    }
  }, {
    key: Delete,
    value: function value(item) {
      this.remove(item);
    }
  }, {
    key: "map",
    value: function map() {
      var mapper = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : x => x;
      var filter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : x => x;
      var mappedItems = new WeakMap();
      var mappedBag = new Bag();
      mappedBag[Mapped] = this;
      this.addEventListener('added', event => {
        var item = event.detail.item;
        if (!filter(item)) {
          return;
        }
        if (mappedItems.has(item)) {
          return;
        }
        var mapped = mapper(item);
        mappedItems.set(item, mapped);
        mappedBag[Add](mapped);
      });
      this.addEventListener('removed', event => {
        var item = event.detail.item;
        if (!mappedItems.has(item)) {
          return;
        }
        var mapped = mappedItems.get(item);
        mappedItems.delete(item);
        mappedBag[Remove](mapped);
      });
      return mappedBag;
    }
  }, {
    key: "size",
    get: function get() {
      return this.content.size;
    }
  }, {
    key: "items",
    value: function items() {
      return Array.from(this.content.entries()).map(entry => entry[0]);
    }
  }]);
  return Bag;
}(_Mixin.Mixin.with(_EventTargetMixin.EventTargetMixin));
exports.Bag = Bag;
Object.defineProperty(Bag, 'ITEM_ADDED', {
  configurable: false,
  enumerable: false,
  writable: true,
  value: 1
});
Object.defineProperty(Bag, 'ITEM_REMOVED', {
  configurable: false,
  enumerable: false,
  writable: true,
  value: -1
});
  })();
});

require.register("curvature/base/Bindable.js", function(exports, require, module) {
  require = __makeRelativeRequire(require, {}, "curvature");
  (function() {
    "use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Bindable = void 0;
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
var Ref = Symbol('ref');
var Original = Symbol('original');
var Deck = Symbol('deck');
var Binding = Symbol('binding');
var SubBinding = Symbol('subBinding');
var BindingAll = Symbol('bindingAll');
var IsBindable = Symbol('isBindable');
var Wrapping = Symbol('wrapping');
var Names = Symbol('Names');
var Executing = Symbol('executing');
var Stack = Symbol('stack');
var ObjSymbol = Symbol('object');
var Wrapped = Symbol('wrapped');
var Unwrapped = Symbol('unwrapped');
var GetProto = Symbol('getProto');
var OnGet = Symbol('onGet');
var OnAllGet = Symbol('onAllGet');
var BindChain = Symbol('bindChain');
var Descriptors = Symbol('Descriptors');
var Before = Symbol('Before');
var After = Symbol('After');
var NoGetters = Symbol('NoGetters');
var TypedArray = Object.getPrototypeOf(Int8Array);
var SetIterator = Set.prototype[Symbol.iterator];
var MapIterator = Map.prototype[Symbol.iterator];
var win = (typeof globalThis === "undefined" ? "undefined" : _typeof(globalThis)) === 'object' ? globalThis : (typeof window === "undefined" ? "undefined" : _typeof(window)) === 'object' ? window : (typeof self === "undefined" ? "undefined" : _typeof(self)) === 'object' ? self : void 0;
var excludedClasses = [win.Node, win.File, win.Map, win.Set, win.WeakMap, win.WeakSet, win.ArrayBuffer, win.ResizeObserver, win.MutationObserver, win.PerformanceObserver, win.IntersectionObserver, win.IDBCursor, win.IDBCursorWithValue, win.IDBDatabase, win.IDBFactory, win.IDBIndex, win.IDBKeyRange, win.IDBObjectStore, win.IDBOpenDBRequest, win.IDBRequest, win.IDBTransaction, win.IDBVersionChangeEvent, win.Event, win.CustomEvent, win.FileSystemFileHandle, win.RTCPeerConnection].filter(x => typeof x === 'function');
var Bindable = /*#__PURE__*/function () {
  function Bindable() {
    _classCallCheck(this, Bindable);
  }
  _createClass(Bindable, null, [{
    key: "isBindable",
    value: function isBindable(object) {
      if (!object || !object[IsBindable]) {
        return false;
      }
      return object[IsBindable] === Bindable;
    }
  }, {
    key: "onDeck",
    value: function onDeck(object, key) {
      return object[Deck].get(key) || false;
    }
  }, {
    key: "ref",
    value: function ref(object) {
      return object[Ref] || object || false;
    }
  }, {
    key: "makeBindable",
    value: function makeBindable(object) {
      return this.make(object);
    }
  }, {
    key: "shuck",
    value: function shuck(original, seen) {
      seen = seen || new Map();
      var clone = Object.create({});
      if (original instanceof TypedArray || original instanceof ArrayBuffer) {
        var _clone = original.slice(0);
        seen.set(original, _clone);
        return _clone;
      }
      var properties = Object.keys(original);
      for (var i in properties) {
        var ii = properties[i];
        if (ii.substring(0, 3) === '___') {
          continue;
        }
        var alreadyCloned = seen.get(original[ii]);
        if (alreadyCloned) {
          clone[ii] = alreadyCloned;
          continue;
        }
        if (original[ii] === original) {
          seen.set(original[ii], clone);
          clone[ii] = clone;
          continue;
        }
        if (original[ii] && _typeof(original[ii]) === 'object') {
          var originalProp = original[ii];
          if (Bindable.isBindable(original[ii])) {
            originalProp = original[ii][Original];
          }
          clone[ii] = this.shuck(originalProp, seen);
        } else {
          clone[ii] = original[ii];
        }
        seen.set(original[ii], clone[ii]);
      }
      if (Bindable.isBindable(original)) {
        delete clone.bindTo;
        delete clone.isBound;
      }
      return clone;
    }
  }, {
    key: "make",
    value: function make(object) {
      var _this = this;
      if (!object || !['function', 'object'].includes(_typeof(object))) {
        return object;
      }
      if (object[Ref]) {
        return object[Ref];
      }
      if (object[IsBindable]) {
        return object;
      }
      if (Object.isSealed(object) || Object.isFrozen(object) || !Object.isExtensible(object) || excludedClasses.find(x => object instanceof x)) {
        return object;
      }
      Object.defineProperty(object, IsBindable, {
        configurable: false,
        enumerable: false,
        writable: false,
        value: Bindable
      });
      Object.defineProperty(object, Ref, {
        configurable: true,
        enumerable: false,
        writable: true,
        value: false
      });
      Object.defineProperty(object, Original, {
        configurable: false,
        enumerable: false,
        writable: false,
        value: object
      });
      Object.defineProperty(object, Deck, {
        configurable: false,
        enumerable: false,
        writable: false,
        value: new Map()
      });
      Object.defineProperty(object, Binding, {
        configurable: false,
        enumerable: false,
        writable: false,
        value: Object.create(null)
      });
      Object.defineProperty(object, SubBinding, {
        configurable: false,
        enumerable: false,
        writable: false,
        value: new Map()
      });
      Object.defineProperty(object, BindingAll, {
        configurable: false,
        enumerable: false,
        writable: false,
        value: new Set()
      });
      Object.defineProperty(object, Executing, {
        enumerable: false,
        writable: true
      });
      Object.defineProperty(object, Wrapping, {
        enumerable: false,
        writable: true
      });
      Object.defineProperty(object, Stack, {
        configurable: false,
        enumerable: false,
        writable: false,
        value: []
      });
      Object.defineProperty(object, Before, {
        configurable: false,
        enumerable: false,
        writable: false,
        value: new Set()
      });
      Object.defineProperty(object, After, {
        configurable: false,
        enumerable: false,
        writable: false,
        value: new Set()
      });
      Object.defineProperty(object, Wrapped, {
        configurable: false,
        enumerable: false,
        writable: false,
        value: Object.preventExtensions(new Map())
      });
      Object.defineProperty(object, Unwrapped, {
        configurable: false,
        enumerable: false,
        writable: false,
        value: Object.preventExtensions(new Map())
      });
      Object.defineProperty(object, Descriptors, {
        configurable: false,
        enumerable: false,
        writable: false,
        value: Object.preventExtensions(new Map())
      });
      var bindTo = function bindTo(property) {
        var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var bindToAll = false;
        if (Array.isArray(property)) {
          var debinders = property.map(p => bindTo(p, callback, options));
          return () => debinders.forEach(d => d());
        }
        if (property instanceof Function) {
          options = callback || {};
          callback = property;
          bindToAll = true;
        }
        if (options.delay >= 0) {
          callback = _this.wrapDelayCallback(callback, options.delay);
        }
        if (options.throttle >= 0) {
          callback = _this.wrapThrottleCallback(callback, options.throttle);
        }
        if (options.wait >= 0) {
          callback = _this.wrapWaitCallback(callback, options.wait);
        }
        if (options.frame) {
          callback = _this.wrapFrameCallback(callback, options.frame);
        }
        if (options.idle) {
          callback = _this.wrapIdleCallback(callback);
        }
        if (bindToAll) {
          object[BindingAll].add(callback);
          if (!('now' in options) || options.now) {
            for (var i in object) {
              callback(object[i], i, object, false);
            }
          }
          return () => {
            object[BindingAll].delete(callback);
          };
        }
        if (!object[Binding][property]) {
          object[Binding][property] = new Set();
        }

        // let bindIndex = object[Binding][property].length;

        if (options.children) {
          var original = callback;
          callback = function callback() {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            var v = args[0];
            var subDebind = object[SubBinding].get(original);
            if (subDebind) {
              object[SubBinding].delete(original);
              subDebind();
            }
            if (_typeof(v) !== 'object') {
              original(...args);
              return;
            }
            var vv = Bindable.make(v);
            if (Bindable.isBindable(vv)) {
              object[SubBinding].set(original, vv.bindTo(function () {
                for (var _len2 = arguments.length, subArgs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                  subArgs[_key2] = arguments[_key2];
                }
                return original(...args, ...subArgs);
              }, Object.assign({}, options, {
                children: false
              })));
            }
            original(...args);
          };
        }
        object[Binding][property].add(callback);
        if (!('now' in options) || options.now) {
          callback(object[property], property, object, false);
        }
        var debinder = () => {
          var subDebind = object[SubBinding].get(callback);
          if (subDebind) {
            object[SubBinding].delete(callback);
            subDebind();
          }
          if (!object[Binding][property]) {
            return;
          }
          if (!object[Binding][property].has(callback)) {
            return;
          }
          object[Binding][property].delete(callback);
        };
        if (options.removeWith && options.removeWith instanceof View) {
          options.removeWith.onRemove(() => debinder);
        }
        return debinder;
      };
      Object.defineProperty(object, 'bindTo', {
        configurable: false,
        enumerable: false,
        writable: false,
        value: bindTo
      });
      var ___before = callback => {
        object[Before].add(callback);
        return () => object[Before].delete(callback);
      };
      var ___after = callback => {
        object[After].add(callback);
        return () => object[After].delete(callback);
      };
      Object.defineProperty(object, BindChain, {
        configurable: false,
        enumerable: false,
        writable: false,
        value: (path, callback) => {
          var parts = path.split('.');
          var node = parts.shift();
          var subParts = parts.slice(0);
          var debind = [];
          debind.push(object.bindTo(node, (v, k, t, d) => {
            var rest = subParts.join('.');
            if (subParts.length === 0) {
              callback(v, k, t, d);
              return;
            }
            if (v === undefined) {
              v = t[k] = this.make({});
            }
            debind = debind.concat(v[BindChain](rest, callback));
          }));
          return () => debind.forEach(x => x());
        }
      });
      Object.defineProperty(object, '___before', {
        configurable: false,
        enumerable: false,
        writable: false,
        value: ___before
      });
      Object.defineProperty(object, '___after', {
        configurable: false,
        enumerable: false,
        writable: false,
        value: ___after
      });
      var isBound = () => {
        if (object[BindingAll].size) {
          return true;
        }
        for (var callbacks of Object.values(object[Binding])) {
          if (callbacks.size) {
            return true;
          }
          // for(let callback of callbacks)
          // {
          // 	if(callback)
          // 	{
          // 		return true;
          // 	}
          // }
        }

        return false;
      };
      Object.defineProperty(object, 'isBound', {
        configurable: false,
        enumerable: false,
        writable: false,
        value: isBound
      });
      var _loop = function _loop(i) {
        var descriptors = Object.getOwnPropertyDescriptors(object);
        if (object[i] && _typeof(object[i]) === 'object' && !(object[i] instanceof Promise)) {
          if (!excludedClasses.find(excludeClass => object[i] instanceof excludeClass) && Object.isExtensible(object[i]) && !Object.isSealed(object[i])) {
            object[i] = Bindable.make(object[i]);
          }
        }
      };
      for (var i in object) {
        _loop(i);
      }
      var descriptors = object[Descriptors];
      var wrapped = object[Wrapped];
      var stack = object[Stack];
      var set = (target, key, value) => {
        if (value && _typeof(value) === 'object' && Object.isExtensible(object) && !Object.isSealed(object) && !excludedClasses.find(x => object instanceof x)) {
          value = Bindable.make(value);
          if (target[key] === value) {
            return true;
          }
        }
        if (wrapped.has(key)) {
          wrapped.delete(key);
        }
        var onDeck = object[Deck];
        var isOnDeck = onDeck.has(key);
        var valOnDeck = isOnDeck && onDeck.get(key);

        // if(onDeck[key] !== undefined && onDeck[key] === value)
        if (isOnDeck && valOnDeck === value) {
          return true;
        }
        if (key.slice && key.slice(-3) === '___') {
          return true;
        }
        if (target[key] === value || typeof value === 'number' && isNaN(valOnDeck) && isNaN(value)) {
          return true;
        }
        onDeck.set(key, value);
        for (var callback of object[BindingAll]) {
          callback(value, key, target, false);
        }
        if (key in object[Binding]) {
          for (var _callback of object[Binding][key]) {
            _callback(value, key, target, false, target[key]);
          }
        }
        onDeck.delete(key);
        var excluded = win.File && target instanceof win.File && key == 'lastModifiedDate';
        if (!excluded) {
          Reflect.set(target, key, value);
        }
        if (Array.isArray(target) && object[Binding]['length']) {
          for (var _i in object[Binding]['length']) {
            var _callback2 = object[Binding]['length'][_i];
            _callback2(target.length, 'length', target, false, target.length);
          }
        }
        return true;
      };
      var deleteProperty = (target, key) => {
        var onDeck = object[Deck];
        var isOnDeck = onDeck.has(key);
        if (isOnDeck) {
          return true;
        }
        if (!(key in target)) {
          return true;
        }
        if (descriptors.has(key)) {
          var descriptor = descriptors.get(key);
          if (descriptor && !descriptor.configurable) {
            return false;
          }
          descriptors.delete(key);
        }
        onDeck.set(key, null);
        if (wrapped.has(key)) {
          wrapped.delete(key);
        }
        for (var callback of object[BindingAll]) {
          callback(undefined, key, target, true, target[key]);
        }
        if (key in object[Binding]) {
          for (var binding of object[Binding][key]) {
            binding(undefined, key, target, true, target[key]);
          }
        }
        Reflect.deleteProperty(target, key);
        onDeck.delete(key);
        return true;
      };
      var construct = (target, args) => {
        var key = 'constructor';
        for (var callback of target[Before]) {
          callback(target, key, object[Stack], undefined, args);
        }
        var instance = Bindable.make(new target[Original](...args));
        for (var _callback3 of target[After]) {
          _callback3(target, key, object[Stack], instance, args);
        }
        return instance;
      };
      var get = (target, key) => {
        if (wrapped.has(key)) {
          return wrapped.get(key);
        }
        if (key === Ref || key === Original || key === 'apply' || key === 'isBound' || key === 'bindTo' || key === '__proto__' || key === 'constructor') {
          return object[key];
        }
        var descriptor;
        if (descriptors.has(key)) {
          descriptor = descriptors.get(key);
        } else {
          descriptor = Object.getOwnPropertyDescriptor(object, key);
          descriptors.set(key, descriptor);
        }
        if (descriptor && !descriptor.configurable && !descriptor.writable) {
          return object[key];
        }
        if (OnAllGet in object) {
          return object[OnAllGet](key);
        }
        if (OnGet in object && !(key in object)) {
          return object[OnGet](key);
        }
        if (descriptor && !descriptor.configurable && !descriptor.writable) {
          wrapped.set(key, object[key]);
          return object[key];
        }
        if (typeof object[key] === 'function') {
          if (Names in object[key]) {
            return object[key];
          }
          object[Unwrapped].set(key, object[key]);
          var prototype = Object.getPrototypeOf(object);
          var isMethod = prototype[key] === object[key];
          var objRef = typeof Promise === 'function' && object instanceof Promise || typeof Storage === 'function' && object instanceof Storage || typeof object[Symbol.iterator] === 'function' && key === 'next' || typeof Map === 'function' && object instanceof Map || typeof Set === 'function' && object instanceof Set || typeof Date === 'function' && object instanceof Date || typeof WeakMap === 'function' && object instanceof WeakMap || typeof WeakSet === 'function' && object instanceof WeakSet || typeof EventTarget === 'function' && object instanceof EventTarget || typeof MapIterator === 'function' && object.prototype === MapIterator || typeof SetIterator === 'function' && object.prototype === SetIterator || typeof TypedArray === 'function' && object instanceof TypedArray || typeof ArrayBuffer === 'function' && object instanceof ArrayBuffer || typeof ResizeObserver === 'function' && object instanceof ResizeObserver || typeof MutationObserver === 'function' && object instanceof MutationObserver || typeof PerformanceObserver === 'function' && object instanceof PerformanceObserver || typeof IntersectionObserver === 'function' && object instanceof IntersectionObserver ? object : object[Ref];
          var wrappedMethod = function _target() {
            object[Executing] = key;
            stack.unshift(key);
            for (var _len3 = arguments.length, providedArgs = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
              providedArgs[_key3] = arguments[_key3];
            }
            for (var beforeCallback of object[Before]) {
              beforeCallback(object, key, stack, object, providedArgs);
            }
            var ret;
            if (this instanceof _target ? this.constructor : void 0) {
              ret = new (object[Unwrapped].get(key))(...providedArgs);
            } else {
              var func = object[Unwrapped].get(key);
              if (isMethod) {
                ret = func.apply(objRef || object, providedArgs);
              } else {
                ret = func(...providedArgs);
              }
            }
            for (var afterCallback of object[After]) {
              afterCallback(object, key, stack, object, providedArgs);
            }
            object[Executing] = null;
            stack.shift();
            return ret;
          };
          wrappedMethod[Names] = wrappedMethod[Names] || new WeakMap();
          wrappedMethod[Names].set(object, key);
          wrappedMethod[OnAllGet] = key => {
            var selfName = wrappedMethod[Names].get(object);
            return object[selfName][key];
          };
          var result = Bindable.make(wrappedMethod);
          wrapped.set(key, result);
          return result;
        }
        return object[key];
      };
      var getPrototypeOf = target => {
        if (GetProto in object) {
          return object[GetProto];
        }
        return Reflect.getPrototypeOf(target);
      };
      var handlerDef = {
        get: {
          value: get
        },
        set: {
          value: set
        },
        construct: {
          value: construct
        },
        getPrototypeOf: {
          value: getPrototypeOf
        },
        deleteProperty: {
          value: deleteProperty
        }
      };
      if (object[NoGetters]) {
        delete handlerDef.getPrototypeOf;
        delete handlerDef.get;
      }
      var handler = Object.create(null, handlerDef);
      Object.defineProperty(object, Ref, {
        configurable: false,
        enumerable: false,
        writable: false,
        value: new Proxy(object, handler)
      });
      return object[Ref];
    }
  }, {
    key: "clearBindings",
    value: function clearBindings(object) {
      var clearObj = o => Object.keys(o).map(k => delete o[k]);
      var maps = func => function () {
        for (var _len4 = arguments.length, os = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
          os[_key4] = arguments[_key4];
        }
        return os.map(func);
      };
      var clearObjs = maps(clearObj);
      object[BindingAll].clear();
      clearObjs(object[Wrapped], object[Binding], object[After], object[Before]);
    }
  }, {
    key: "resolve",
    value: function resolve(object, path) {
      var owner = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var node;
      var pathParts = path.split('.');
      var top = pathParts[0];
      while (pathParts.length) {
        if (owner && pathParts.length === 1) {
          var obj = this.make(object);
          return [obj, pathParts.shift(), top];
        }
        node = pathParts.shift();
        if (!(node in object) || !object[node] || !(_typeof(object[node]) === 'object')) {
          object[node] = Object.create(null);
        }
        object = this.make(object[node]);
      }
      return [this.make(object), node, top];
    }
  }, {
    key: "wrapDelayCallback",
    value: function wrapDelayCallback(callback, delay) {
      return function () {
        for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
          args[_key5] = arguments[_key5];
        }
        return setTimeout(() => callback(...args), delay);
      };
    }
  }, {
    key: "wrapThrottleCallback",
    value: function wrapThrottleCallback(callback, throttle) {
      var _this2 = this;
      this.throttles.set(callback, false);
      return function () {
        if (_this2.throttles.get(callback, true)) {
          return;
        }
        callback(...arguments);
        _this2.throttles.set(callback, true);
        setTimeout(() => {
          _this2.throttles.set(callback, false);
        }, throttle);
      };
    }
  }, {
    key: "wrapWaitCallback",
    value: function wrapWaitCallback(callback, wait) {
      var _this3 = this;
      return function () {
        for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
          args[_key6] = arguments[_key6];
        }
        var waiter;
        if (waiter = _this3.waiters.get(callback)) {
          _this3.waiters.delete(callback);
          clearTimeout(waiter);
        }
        waiter = setTimeout(() => callback(...args), wait);
        _this3.waiters.set(callback, waiter);
      };
    }
  }, {
    key: "wrapFrameCallback",
    value: function wrapFrameCallback(callback, frames) {
      return function () {
        for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
          args[_key7] = arguments[_key7];
        }
        requestAnimationFrame(() => callback(...args));
      };
    }
  }, {
    key: "wrapIdleCallback",
    value: function wrapIdleCallback(callback) {
      return function () {
        for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
          args[_key8] = arguments[_key8];
        }
        // Compatibility for Safari 08/2020
        var req = window.requestIdleCallback || requestAnimationFrame;
        req(() => callback(...args));
      };
    }
  }]);
  return Bindable;
}();
exports.Bindable = Bindable;
_defineProperty(Bindable, "waiters", new WeakMap());
_defineProperty(Bindable, "throttles", new WeakMap());
Object.defineProperty(Bindable, 'OnGet', {
  configurable: false,
  enumerable: false,
  writable: false,
  value: OnGet
});
Object.defineProperty(Bindable, 'NoGetters', {
  configurable: false,
  enumerable: false,
  writable: false,
  value: NoGetters
});
Object.defineProperty(Bindable, 'GetProto', {
  configurable: false,
  enumerable: false,
  writable: false,
  value: GetProto
});
Object.defineProperty(Bindable, 'OnAllGet', {
  configurable: false,
  enumerable: false,
  writable: false,
  value: OnAllGet
});
  })();
});

require.register("curvature/base/Cache.js", function(exports, require, module) {
  require = __makeRelativeRequire(require, {}, "curvature");
  (function() {
    "use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Cache = void 0;
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var Cache = /*#__PURE__*/function () {
  function Cache() {
    _classCallCheck(this, Cache);
  }
  _createClass(Cache, null, [{
    key: "store",
    value: function store(key, value, expiry) {
      var bucket = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'standard';
      var expiration = 0;
      if (expiry) {
        expiration = expiry * 1000 + new Date().getTime();
      }
      if (!this.buckets) {
        this.buckets = new Map();
      }
      if (!this.buckets.has(bucket)) {
        this.buckets.set(bucket, new Map());
      }
      var eventEnd = new CustomEvent('cvCacheStore', {
        cancelable: true,
        detail: {
          key: key,
          value: value,
          expiry: expiry,
          bucket: bucket
        }
      });
      if (document.dispatchEvent(eventEnd)) {
        this.buckets.get(bucket).set(key, {
          value: value,
          expiration: expiration
        });
      }
    }
  }, {
    key: "load",
    value: function load(key) {
      var defaultvalue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var bucket = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'standard';
      var eventEnd = new CustomEvent('cvCacheLoad', {
        cancelable: true,
        detail: {
          key: key,
          defaultvalue: defaultvalue,
          bucket: bucket
        }
      });
      if (!document.dispatchEvent(eventEnd)) {
        return defaultvalue;
      }
      if (this.buckets && this.buckets.has(bucket) && this.buckets.get(bucket).has(key)) {
        var entry = this.buckets.get(bucket).get(key);
        // console.log(this.bucket[bucket][key].expiration, (new Date).getTime());
        if (entry.expiration === 0 || entry.expiration > new Date().getTime()) {
          return this.buckets.get(bucket).get(key).value;
        }
      }
      return defaultvalue;
    }
  }]);
  return Cache;
}();
exports.Cache = Cache;
  })();
});

require.register("curvature/base/Config.js", function(exports, require, module) {
  require = __makeRelativeRequire(require, {}, "curvature");
  (function() {
    "use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Config = void 0;
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
var AppConfig = {};
var _require = require;
var win = (typeof globalThis === "undefined" ? "undefined" : _typeof(globalThis)) === 'object' ? globalThis : (typeof window === "undefined" ? "undefined" : _typeof(window)) === 'object' ? window : (typeof self === "undefined" ? "undefined" : _typeof(self)) === 'object' ? self : void 0;
try {
  AppConfig = _require('/Config').Config;
} catch (error) {
  win.devMode === true && console.error(error);
  AppConfig = {};
}
var Config = /*#__PURE__*/function () {
  function Config() {
    _classCallCheck(this, Config);
  }
  _createClass(Config, null, [{
    key: "get",
    value: function get(name) {
      return this.configs[name];
    }
  }, {
    key: "set",
    value: function set(name, value) {
      this.configs[name] = value;
      return this;
    }
  }, {
    key: "dump",
    value: function dump() {
      return this.configs;
    }
  }, {
    key: "init",
    value: function init() {
      for (var _len = arguments.length, configs = new Array(_len), _key = 0; _key < _len; _key++) {
        configs[_key] = arguments[_key];
      }
      for (var i in configs) {
        var config = configs[i];
        if (typeof config === 'string') {
          config = JSON.parse(config);
        }
        for (var name in config) {
          var value = config[name];
          return this.configs[name] = value;
        }
      }
      return this;
    }
  }]);
  return Config;
}();
exports.Config = Config;
Object.defineProperty(Config, 'configs', {
  configurable: false,
  enumerable: false,
  writable: false,
  value: AppConfig
});
  })();
});

require.register("curvature/base/Dom.js", function(exports, require, module) {
  require = __makeRelativeRequire(require, {}, "curvature");
  (function() {
    "use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Dom = void 0;
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var traversals = 0;
var Dom = /*#__PURE__*/function () {
  function Dom() {
    _classCallCheck(this, Dom);
  }
  _createClass(Dom, null, [{
    key: "mapTags",
    value: function mapTags(doc, selector, callback, startNode, endNode) {
      var result = [];
      var started = true;
      if (startNode) {
        started = false;
      }
      var ended = false;
      var _globalThis$window = globalThis.window,
        Node = _globalThis$window.Node,
        Element = _globalThis$window.Element,
        NodeFilter = _globalThis$window.NodeFilter,
        document = _globalThis$window.document;
      var treeWalker = document.createTreeWalker(doc, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT, {
        acceptNode: (node, walker) => {
          if (!started) {
            if (node === startNode) {
              started = true;
            } else {
              return NodeFilter.FILTER_SKIP;
            }
          }
          if (endNode && node === endNode) {
            ended = true;
          }
          if (ended) {
            return NodeFilter.FILTER_SKIP;
          }
          if (selector) {
            if (node instanceof Element) {
              if (node.matches(selector)) {
                return NodeFilter.FILTER_ACCEPT;
              }
            }
            return NodeFilter.FILTER_SKIP;
          }
          return NodeFilter.FILTER_ACCEPT;
        }
      }, false);
      var traversal = traversals++;
      while (treeWalker.nextNode()) {
        result.push(callback(treeWalker.currentNode, treeWalker));
      }
      return result;
    }
  }, {
    key: "dispatchEvent",
    value: function dispatchEvent(doc, event) {
      doc.dispatchEvent(event);
      this.mapTags(doc, false, node => {
        node.dispatchEvent(event);
      });
    }
  }]);
  return Dom;
}();
exports.Dom = Dom;
  })();
});

require.register("curvature/base/Mixin.js", function(exports, require, module) {
  require = __makeRelativeRequire(require, {}, "curvature");
  (function() {
    "use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Mixin = void 0;
var _Bindable = require("./Bindable");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var Constructor = Symbol('constructor');
var MixinList = Symbol('mixinList');
var Mixin = /*#__PURE__*/function () {
  function Mixin() {
    _classCallCheck(this, Mixin);
  }
  _createClass(Mixin, null, [{
    key: "from",
    value: function from(baseClass) {
      for (var _len = arguments.length, mixins = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        mixins[_key - 1] = arguments[_key];
      }
      var newClass = /*#__PURE__*/function (_baseClass) {
        _inherits(newClass, _baseClass);
        var _super = _createSuper(newClass);
        function newClass() {
          var _this;
          _classCallCheck(this, newClass);
          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }
          var instance = baseClass.constructor ? _this = _super.call(this, ...args) : null;
          for (var mixin of mixins) {
            if (mixin[Mixin.Constructor]) {
              mixin[Mixin.Constructor].apply(_assertThisInitialized(_this));
            }
            switch (_typeof(mixin)) {
              case 'function':
                Mixin.mixClass(mixin, newClass);
                break;
              case 'object':
                Mixin.mixObject(mixin, _assertThisInitialized(_this));
                break;
            }
          }
          return _possibleConstructorReturn(_this, instance);
        }
        return _createClass(newClass);
      }(baseClass);
      return newClass;
    }
  }, {
    key: "make",
    value: function make() {
      for (var _len3 = arguments.length, classes = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        classes[_key3] = arguments[_key3];
      }
      var base = classes.pop();
      return Mixin.to(base, ...classes);
    }
  }, {
    key: "to",
    value: function to(base) {
      var descriptors = {};
      for (var _len4 = arguments.length, mixins = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
        mixins[_key4 - 1] = arguments[_key4];
      }
      mixins.map(mixin => {
        switch (_typeof(mixin)) {
          case 'object':
            Object.assign(descriptors, Object.getOwnPropertyDescriptors(mixin));
            break;
          case 'function':
            Object.assign(descriptors, Object.getOwnPropertyDescriptors(mixin.prototype));
            break;
        }
        delete descriptors.constructor;
        Object.defineProperties(base.prototype, descriptors);
      });
    }
  }, {
    key: "with",
    value: function _with() {
      for (var _len5 = arguments.length, mixins = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
        mixins[_key5] = arguments[_key5];
      }
      return this.from( /*#__PURE__*/function () {
        function _class() {
          _classCallCheck(this, _class);
        }
        return _createClass(_class);
      }(), ...mixins);
    }
  }, {
    key: "mixObject",
    value: function mixObject(mixin, instance) {
      for (var func of Object.getOwnPropertyNames(mixin)) {
        if (typeof mixin[func] === 'function') {
          instance[func] = mixin[func].bind(instance);
          continue;
        }
        instance[func] = mixin[func];
      }
      for (var _func of Object.getOwnPropertySymbols(mixin)) {
        if (typeof mixin[_func] === 'function') {
          instance[_func] = mixin[_func].bind(instance);
          continue;
        }
        instance[_func] = mixin[_func];
      }
    }
  }, {
    key: "mixClass",
    value: function mixClass(cls, newClass) {
      for (var func of Object.getOwnPropertyNames(cls.prototype)) {
        if (['name', 'prototype', 'length'].includes(func)) {
          continue;
        }
        var descriptor = Object.getOwnPropertyDescriptor(newClass, func);
        if (descriptor && !descriptor.writable) {
          continue;
        }
        if (typeof cls[func] !== 'function') {
          newClass.prototype[func] = cls.prototype[func];
          continue;
        }
        newClass.prototype[func] = cls.prototype[func].bind(newClass.prototype);
      }
      for (var _func2 of Object.getOwnPropertySymbols(cls.prototype)) {
        if (typeof cls[_func2] !== 'function') {
          newClass.prototype[_func2] = cls.prototype[_func2];
          continue;
        }
        newClass.prototype[_func2] = cls.prototype[_func2].bind(newClass.prototype);
      }
      var _loop = function _loop() {
        if (['name', 'prototype', 'length'].includes(_func3)) {
          return "continue";
        }
        var descriptor = Object.getOwnPropertyDescriptor(newClass, _func3);
        if (descriptor && !descriptor.writable) {
          return "continue";
        }
        if (typeof cls[_func3] !== 'function') {
          newClass[_func3] = cls[_func3];
          return "continue";
        }
        var prev = newClass[_func3] || false;
        var meth = cls[_func3].bind(newClass);
        newClass[_func3] = function () {
          prev && prev(...arguments);
          return meth(...arguments);
        };
      };
      for (var _func3 of Object.getOwnPropertyNames(cls)) {
        var _ret = _loop();
        if (_ret === "continue") continue;
      }
      var _loop2 = function _loop2() {
        if (typeof cls[_func4] !== 'function') {
          newClass.prototype[_func4] = cls[_func4];
          return "continue";
        }
        var prev = newClass[_func4] || false;
        var meth = cls[_func4].bind(newClass);
        newClass[_func4] = function () {
          prev && prev(...arguments);
          return meth(...arguments);
        };
      };
      for (var _func4 of Object.getOwnPropertySymbols(cls)) {
        var _ret2 = _loop2();
        if (_ret2 === "continue") continue;
      }
    }
  }, {
    key: "mix",
    value: function mix(mixinTo) {
      var constructors = [];
      var allStatic = {};
      var allInstance = {};
      var mixable = _Bindable.Bindable.makeBindable(mixinTo);
      var _loop3 = function _loop3(base) {
        var instanceNames = Object.getOwnPropertyNames(base.prototype);
        var staticNames = Object.getOwnPropertyNames(base);
        var prefix = /^(before|after)__(.+)/;
        var _loop5 = function _loop5(_methodName2) {
          var match = _methodName2.match(prefix);
          if (match) {
            switch (match[1]) {
              case 'before':
                mixable.___before((t, e, s, o, a) => {
                  if (e !== match[2]) {
                    return;
                  }
                  var method = base[_methodName2].bind(o);
                  return method(...a);
                });
                break;
              case 'after':
                mixable.___after((t, e, s, o, a) => {
                  if (e !== match[2]) {
                    return;
                  }
                  var method = base[_methodName2].bind(o);
                  return method(...a);
                });
                break;
            }
            return "continue";
          }
          if (allStatic[_methodName2]) {
            return "continue";
          }
          if (typeof base[_methodName2] !== 'function') {
            return "continue";
          }
          allStatic[_methodName2] = base[_methodName2];
        };
        for (var _methodName2 of staticNames) {
          var _ret3 = _loop5(_methodName2);
          if (_ret3 === "continue") continue;
        }
        var _loop6 = function _loop6(_methodName3) {
          var match = _methodName3.match(prefix);
          if (match) {
            switch (match[1]) {
              case 'before':
                mixable.___before((t, e, s, o, a) => {
                  if (e !== match[2]) {
                    return;
                  }
                  var method = base.prototype[_methodName3].bind(o);
                  return method(...a);
                });
                break;
              case 'after':
                mixable.___after((t, e, s, o, a) => {
                  if (e !== match[2]) {
                    return;
                  }
                  var method = base.prototype[_methodName3].bind(o);
                  return method(...a);
                });
                break;
            }
            return "continue";
          }
          if (allInstance[_methodName3]) {
            return "continue";
          }
          if (typeof base.prototype[_methodName3] !== 'function') {
            return "continue";
          }
          allInstance[_methodName3] = base.prototype[_methodName3];
        };
        for (var _methodName3 of instanceNames) {
          var _ret4 = _loop6(_methodName3);
          if (_ret4 === "continue") continue;
        }
      };
      for (var base = this; base && base.prototype; base = Object.getPrototypeOf(base)) {
        _loop3(base);
      }
      for (var methodName in allStatic) {
        mixinTo[methodName] = allStatic[methodName].bind(mixinTo);
      }
      var _loop4 = function _loop4(_methodName) {
        mixinTo.prototype[_methodName] = function () {
          for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
            args[_key6] = arguments[_key6];
          }
          return allInstance[_methodName].apply(this, args);
        };
      };
      for (var _methodName in allInstance) {
        _loop4(_methodName);
      }
      return mixable;
    }
  }]);
  return Mixin;
}();
exports.Mixin = Mixin;
Mixin.Constructor = Constructor;
  })();
});

require.register("curvature/base/Pool.js", function(exports, require, module) {
  require = __makeRelativeRequire(require, {}, "curvature");
  (function() {
    "use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Pool = void 0;
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var Pool = /*#__PURE__*/function () {
  function Pool(_ref) {
    var max = _ref.max,
      init = _ref.init;
    _classCallCheck(this, Pool);
    _defineProperty(this, "backlog", []);
    _defineProperty(this, "running", new Set());
    _defineProperty(this, "max", 1);
    _defineProperty(this, "init", item => new Promise(item));
    this.init = init || this.init;
    this.max = max || this.max;
  }
  _createClass(Pool, [{
    key: "add",
    value: function add(item) {
      var onCompleted = () => {
        this.running.delete(item);
        if (!this.backlog.length) {
          return;
        }
        var next = this.backlog.shift();
        var wrapped = this.init(next);
        wrapped.finally(onCompleted);
        this.running.add(next);
      };
      if (this.running.size < this.max) {
        var wrapped = this.init(item);
        wrapped.finally(onCompleted);
        this.running.add(item);
      } else {
        this.backlog.push(item);
      }
    }
  }]);
  return Pool;
}();
exports.Pool = Pool;
  })();
});

require.register("curvature/base/Router.js", function(exports, require, module) {
  require = __makeRelativeRequire(require, {}, "curvature");
  (function() {
    "use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Router = void 0;
var _View = require("./View");
var _Cache = require("./Cache");
var _Config = require("./Config");
var _Routes = require("./Routes");
var _win$CustomEvent;
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
var NotFoundError = Symbol('NotFound');
var InternalError = Symbol('Internal');
var win = (typeof globalThis === "undefined" ? "undefined" : _typeof(globalThis)) === 'object' ? globalThis : (typeof window === "undefined" ? "undefined" : _typeof(window)) === 'object' ? window : (typeof self === "undefined" ? "undefined" : _typeof(self)) === 'object' ? self : void 0;
win.CustomEvent = (_win$CustomEvent = win.CustomEvent) !== null && _win$CustomEvent !== void 0 ? _win$CustomEvent : win.Event;
var Router = /*#__PURE__*/function () {
  function Router() {
    _classCallCheck(this, Router);
  }
  _createClass(Router, null, [{
    key: "wait",
    value: function wait(view) {
      var event = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'DOMContentLoaded';
      var node = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : document;
      node.addEventListener(event, () => {
        this.listen(view);
      });
    }
  }, {
    key: "listen",
    value: function listen(listener) {
      var routes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      this.listener = listener || this.listener;
      this.routes = routes || listener.routes;
      Object.assign(this.query, this.queryOver({}));
      var listen = event => {
        event.preventDefault();
        if (event.state && 'routedId' in event.state) {
          if (event.state.routedId <= this.routeCount) {
            this.history.splice(event.state.routedId);
            this.routeCount = event.state.routedId;
          } else if (event.state.routedId > this.routeCount) {
            this.history.push(event.state.prev);
            this.routeCount = event.state.routedId;
          }
          this.state = event.state;
        } else {
          if (this.prevPath !== null && this.prevPath !== location.pathname) {
            this.history.push(this.prevPath);
          }
        }
        if (!this.isOriginLimited(location)) {
          this.match(location.pathname, listener);
        } else {
          this.match(this.nextPath, listener);
        }
      };
      window.addEventListener('cvUrlChanged', listen);
      window.addEventListener('popstate', listen);
      var route = !this.isOriginLimited(location) ? location.pathname + location.search : false;
      if (!this.isOriginLimited(location) && location.hash) {
        route += location.hash;
      }
      var state = {
        routedId: this.routeCount,
        url: location.pathname,
        prev: this.prevPath
      };
      if (!this.isOriginLimited(location)) {
        history.replaceState(state, null, location.pathname);
      }
      this.go(route !== false ? route : '/');
    }
  }, {
    key: "go",
    value: function go(path) {
      var silent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var configTitle = _Config.Config.get('title');
      if (configTitle) {
        document.title = configTitle;
      }
      var state = {
        routedId: this.routeCount,
        prev: this.prevPath,
        url: location.pathname
      };
      if (silent === -1) {
        this.match(path, this.listener, true);
      } else if (this.isOriginLimited(location)) {
        this.nextPath = path;
      } else if (silent === 2 && location.pathname !== path) {
        history.replaceState(state, null, path);
      } else if (location.pathname !== path) {
        history.pushState(state, null, path);
      }
      if (!silent || silent < 0) {
        if (silent === false) {
          this.path = null;
        }
        if (!silent) {
          if (path.substring(0, 1) === '#') {
            window.dispatchEvent(new HashChangeEvent('hashchange'));
          } else {
            window.dispatchEvent(new CustomEvent('cvUrlChanged'));
          }
        }
      }
      this.prevPath = path;
    }
  }, {
    key: "processRoute",
    value: function processRoute(routes, selected, args) {
      var result = false;
      if (typeof routes[selected] === 'function') {
        if (routes[selected].prototype instanceof _View.View) {
          result = new routes[selected](args);
        } else {
          result = routes[selected](args);
        }
      } else {
        result = routes[selected];
      }
      return result;
    }
  }, {
    key: "handleError",
    value: function handleError(error, routes, selected, args, listener, path, prev, forceRefresh) {
      if (typeof document !== 'undefined') {
        document.dispatchEvent(new CustomEvent('cvRouteError', {
          detail: {
            error: error,
            path: path,
            prev: prev,
            view: listener,
            routes: routes,
            selected: selected
          }
        }));
      }
      var result = win['devMode'] ? 'Unexpected error: ' + String(error) : 'Unexpected error.';
      if (routes[InternalError]) {
        args[InternalError] = error;
        result = this.processRoute(routes, InternalError, args);
      }
      this.update(listener, path, result, routes, selected, args, forceRefresh);
    }
  }, {
    key: "match",
    value: function match(path, listener) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var event = null,
        request = null,
        forceRefresh = false;
      if (options === true) {
        forceRefresh = options;
      }
      if (options && _typeof(options) === 'object') {
        forceRefresh = options.forceRefresh;
        event = options.event;
      }
      if (typeof document !== 'undefined' && this.path === path && !forceRefresh) {
        return;
      }
      var origin = 'http://example.com';
      if (typeof document !== 'undefined') {
        origin = this.isOriginLimited(location) ? origin : location.origin;
        this.queryString = location.search;
      }
      var url = new URL(path, origin);
      path = this.path = url.pathname;
      if (typeof document === 'undefined') {
        this.queryString = url.search;
      }
      var prev = this.prevPath;
      var current = listener && listener.args ? listener.args.content : null;
      var routes = this.routes || listener && listener.routes || _Routes.Routes.dump();
      var query = new URLSearchParams(this.queryString);
      if (event && event.request) {
        this.request = event.request;
      }
      for (var key in Object.keys(this.query)) {
        delete this.query[key];
      }
      for (var _ref3 of query) {
        var _ref2 = _slicedToArray(_ref3, 2);
        var _key = _ref2[0];
        var value = _ref2[1];
        this.query[_key] = value;
      }
      var args = {},
        selected = false,
        result = '';
      if (path.substring(0, 1) === '/') {
        path = path.substring(1);
      }
      path = path.split('/');
      for (var i in this.query) {
        args[i] = this.query[i];
      }
      L1: for (var _i2 in routes) {
        var route = _i2.split('/');
        if (route.length < path.length && route[route.length - 1] !== '*') {
          continue;
        }
        L2: for (var j in route) {
          if (route[j].substr(0, 1) == '%') {
            var argName = null;
            var groups = /^%(\w+)\??/.exec(route[j]);
            if (groups && groups[1]) {
              argName = groups[1];
            }
            if (!argName) {
              throw new Error("".concat(route[j], " is not a valid argument segment in route \"").concat(_i2, "\""));
            }
            if (!path[j]) {
              if (route[j].substr(route[j].length - 1, 1) == '?') {
                args[argName] = '';
              } else {
                continue L1;
              }
            } else {
              args[argName] = path[j];
            }
          } else if (route[j] !== '*' && path[j] !== route[j]) {
            continue L1;
          }
        }
        selected = _i2;
        result = routes[_i2];
        if (route[route.length - 1] === '*') {
          args.pathparts = path.slice(route.length - 1);
        }
        break;
      }
      var eventStart = new CustomEvent('cvRouteStart', {
        cancelable: true,
        detail: {
          path: path,
          prev: prev,
          root: listener,
          selected: selected,
          routes: routes
        }
      });
      if (typeof document !== 'undefined') {
        if (!document.dispatchEvent(eventStart)) {
          return;
        }
      }
      if (!forceRefresh && listener && current && result instanceof Object && current instanceof result && !(result instanceof Promise) && current.update(args)) {
        listener.args.content = current;
        return true;
      }
      if (!(selected in routes)) {
        routes[selected] = routes[NotFoundError];
      }
      try {
        result = this.processRoute(routes, selected, args);
        if (result === false) {
          result = this.processRoute(routes, NotFoundError, args);
        }
        if (typeof document === 'undefined') {
          if (!(result instanceof Promise)) {
            return Promise.resolve(result);
          }
          return result;
        }
        if (!(result instanceof Promise)) {
          return this.update(listener, path, result, routes, selected, args, forceRefresh);
        }
        return result.then(realResult => this.update(listener, path, realResult, routes, selected, args, forceRefresh)).catch(error => {
          this.handleError(error, routes, selected, args, listener, path, prev, forceRefresh);
        });
      } catch (error) {
        this.handleError(error, routes, selected, args, listener, path, prev, forceRefresh);
      }
    }
  }, {
    key: "update",
    value: function update(listener, path, result, routes, selected, args, forceRefresh) {
      if (!listener) {
        return;
      }
      var prev = this.prevPath;
      var event = new CustomEvent('cvRoute', {
        cancelable: true,
        detail: {
          result: result,
          path: path,
          prev: prev,
          view: listener,
          routes: routes,
          selected: selected
        }
      });
      if (result !== false) {
        if (listener.args.content instanceof _View.View) {
          listener.args.content.pause(true);
          listener.args.content.remove();
        }
        if (document.dispatchEvent(event)) {
          listener.args.content = result;
        }
        if (result instanceof _View.View) {
          result.pause(false);
          result.update(args, forceRefresh);
        }
      }
      var eventEnd = new CustomEvent('cvRouteEnd', {
        cancelable: true,
        detail: {
          result: result,
          path: path,
          prev: prev,
          view: listener,
          routes: routes,
          selected: selected
        }
      });
      document.dispatchEvent(eventEnd);
    }
  }, {
    key: "isOriginLimited",
    value: function isOriginLimited(_ref4) {
      var origin = _ref4.origin;
      return origin === 'null' || origin === 'file://';
    }
  }, {
    key: "queryOver",
    value: function queryOver() {
      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var params = new URLSearchParams(location.search);
      var finalArgs = {};
      var query = {};
      for (var pair of params) {
        query[pair[0]] = pair[1];
      }
      finalArgs = Object.assign(finalArgs, query, args);
      delete finalArgs['api'];
      return finalArgs;

      // for(let i in query)
      // {
      // 	finalArgs[i] = query[i];
      // }

      // for(let i in args)
      // {
      // 	finalArgs[i] = args[i];
      // }
    }
  }, {
    key: "queryToString",
    value: function queryToString() {
      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var fresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var parts = [],
        finalArgs = args;
      if (!fresh) {
        finalArgs = this.queryOver(args);
      }
      for (var i in finalArgs) {
        if (finalArgs[i] === '') {
          continue;
        }
        parts.push(i + '=' + encodeURIComponent(finalArgs[i]));
      }
      return parts.join('&');
    }
  }, {
    key: "setQuery",
    value: function setQuery(name, value, silent) {
      var args = this.queryOver();
      args[name] = value;
      if (value === undefined) {
        delete args[name];
      }
      var queryString = this.queryToString(args, true);
      this.go(location.pathname + (queryString ? '?' + queryString : '?'), silent);
    }
  }]);
  return Router;
}();
exports.Router = Router;
Object.defineProperty(Router, 'query', {
  configurable: false,
  enumerable: false,
  writable: false,
  value: {}
});
Object.defineProperty(Router, 'history', {
  configurable: false,
  enumerable: false,
  writable: false,
  value: []
});
Object.defineProperty(Router, 'routeCount', {
  configurable: false,
  enumerable: false,
  writable: true,
  value: 0
});
Object.defineProperty(Router, 'prevPath', {
  configurable: false,
  enumerable: false,
  writable: true,
  value: null
});
Object.defineProperty(Router, 'queryString', {
  configurable: false,
  enumerable: false,
  writable: true,
  value: null
});
Object.defineProperty(Router, 'InternalError', {
  configurable: false,
  enumerable: false,
  writable: false,
  value: InternalError
});
Object.defineProperty(Router, 'NotFoundError', {
  configurable: false,
  enumerable: false,
  writable: false,
  value: NotFoundError
});
  })();
});

require.register("curvature/base/Routes.js", function(exports, require, module) {
  require = __makeRelativeRequire(require, {}, "curvature");
  (function() {
    "use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Routes = void 0;
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var AppRoutes = {};
var _require = require;
var imported = false;
var runImport = () => {
  if (imported) {
    return;
  }
  ;
  try {
    Object.assign(AppRoutes, _require('Routes').Routes || {});
  } catch (error) {
    globalThis.devMode === true && console.warn(error);
  }
  imported = true;
};
var Routes = /*#__PURE__*/function () {
  function Routes() {
    _classCallCheck(this, Routes);
  }
  _createClass(Routes, null, [{
    key: "get",
    value: function get(name) {
      runImport();
      return this.routes[name];
    }
  }, {
    key: "dump",
    value: function dump() {
      runImport();
      return this.routes;
    }
  }]);
  return Routes;
}();
exports.Routes = Routes;
Object.defineProperty(Routes, 'routes', {
  configurable: false,
  enumerable: false,
  writable: false,
  value: AppRoutes
});
  })();
});

require.register("curvature/base/RuleSet.js", function(exports, require, module) {
  require = __makeRelativeRequire(require, {}, "curvature");
  (function() {
    "use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RuleSet = void 0;
var _Dom = require("./Dom");
var _Tag = require("./Tag");
var _View = require("./View");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var RuleSet = /*#__PURE__*/function () {
  function RuleSet() {
    _classCallCheck(this, RuleSet);
  }
  _createClass(RuleSet, [{
    key: "add",
    value: function add(selector, callback) {
      this.rules = this.rules || {};
      this.rules[selector] = this.rules[selector] || [];
      this.rules[selector].push(callback);
      return this;
    }
  }, {
    key: "apply",
    value: function apply() {
      var doc = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document;
      var view = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      RuleSet.apply(doc, view);
      for (var selector in this.rules) {
        for (var i in this.rules[selector]) {
          var callback = this.rules[selector][i];
          var wrapped = RuleSet.wrap(doc, callback, view);
          var nodes = doc.querySelectorAll(selector);
          for (var node of nodes) {
            wrapped(node);
          }
        }
      }
    }
  }, {
    key: "purge",
    value: function purge() {
      if (!this.rules) {
        return;
      }
      for (var _ref3 of Object.entries(this.rules)) {
        var _ref2 = _slicedToArray(_ref3, 2);
        var k = _ref2[0];
        var v = _ref2[1];
        if (!this.rules[k]) {
          continue;
        }
        for (var kk in this.rules[k]) {
          delete this.rules[k][kk];
        }
      }
    }
  }], [{
    key: "add",
    value: function add(selector, callback) {
      this.globalRules = this.globalRules || {};
      this.globalRules[selector] = this.globalRules[selector] || [];
      this.globalRules[selector].push(callback);
      return this;
    }
  }, {
    key: "apply",
    value: function apply() {
      var doc = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document;
      var view = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      for (var selector in this.globalRules) {
        for (var i in this.globalRules[selector]) {
          var callback = this.globalRules[selector][i];
          var wrapped = this.wrap(doc, callback, view);
          var nodes = doc.querySelectorAll(selector);
          for (var node of nodes) {
            wrapped(node);
          }
        }
      }
    }
  }, {
    key: "wait",
    value: function wait() {
      var event = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'DOMContentLoaded';
      var node = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document;
      var listener = ((event, node) => () => {
        node.removeEventListener(event, listener);
        return this.apply();
      })(event, node);
      node.addEventListener(event, listener);
    }
  }, {
    key: "wrap",
    value: function wrap(doc, originalCallback) {
      var view = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var callback = originalCallback;
      if (originalCallback instanceof _View.View || originalCallback && originalCallback.prototype && originalCallback.prototype instanceof _View.View) {
        callback = () => originalCallback;
      }
      return element => {
        if (typeof element.___cvApplied___ === 'undefined') {
          Object.defineProperty(element, '___cvApplied___', {
            enumerable: false,
            writable: false,
            value: new WeakSet()
          });
        }
        if (element.___cvApplied___.has(originalCallback)) {
          return;
        }
        var direct, parentView;
        if (view) {
          direct = parentView = view;
          if (view.viewList) {
            parentView = view.viewList.parent;
          }
        }
        var tag = new _Tag.Tag(element, parentView, null, undefined, direct);
        var parent = tag.element.parentNode;
        var sibling = tag.element.nextSibling;
        var result = callback(tag);
        if (result !== false) {
          element.___cvApplied___.add(originalCallback);
        }
        if (result instanceof HTMLElement) {
          result = new _Tag.Tag(result);
        }
        if (result instanceof _Tag.Tag) {
          if (!result.element.contains(tag.element)) {
            while (tag.element.firstChild) {
              result.element.appendChild(tag.element.firstChild);
            }
            tag.remove();
          }
          if (sibling) {
            parent.insertBefore(result.element, sibling);
          } else {
            parent.appendChild(result.element);
          }
        }
        if (result && result.prototype && result.prototype instanceof _View.View) {
          result = new result({}, view);
        }
        if (result instanceof _View.View) {
          if (view) {
            view.cleanup.push(() => result.remove());
            view.cleanup.push(view.args.bindTo((v, k, t) => {
              t[k] = v;
              result.args[k] = v;
            }));
            view.cleanup.push(result.args.bindTo((v, k, t, d) => {
              t[k] = v;
              view.args[k] = v;
            }));
          }
          tag.clear();
          result.render(tag.element);
        }
      };
    }
  }]);
  return RuleSet;
}();
exports.RuleSet = RuleSet;
  })();
});

require.register("curvature/base/SetMap.js", function(exports, require, module) {
  require = __makeRelativeRequire(require, {}, "curvature");
  (function() {
    "use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SetMap = void 0;
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var SetMap = /*#__PURE__*/function () {
  function SetMap() {
    _classCallCheck(this, SetMap);
    _defineProperty(this, "_map", new Map());
  }
  _createClass(SetMap, [{
    key: "has",
    value: function has(key) {
      return this._map.has(key);
    }
  }, {
    key: "get",
    value: function get(key) {
      return this._map.get(key);
    }
  }, {
    key: "getOne",
    value: function getOne(key) {
      var set = this.get(key);
      for (var entry of set) {
        return entry;
      }
    }
  }, {
    key: "add",
    value: function add(key, value) {
      var set = this._map.get(key);
      if (!set) {
        this._map.set(key, set = new Set());
      }
      return set.add(value);
    }
  }, {
    key: "remove",
    value: function remove(key, value) {
      var set = this._map.get(key);
      if (!set) {
        return;
      }
      var res = set.delete(value);
      if (!set.size) {
        this._map.delete(key);
      }
      return res;
    }
  }, {
    key: "values",
    value: function values() {
      return new Set(...[...this._map.values()].map(set => [...set.values()]));
    }
  }]);
  return SetMap;
}();
exports.SetMap = SetMap;
  })();
});

require.register("curvature/base/Tag.js", function(exports, require, module) {
  require = __makeRelativeRequire(require, {}, "curvature");
  (function() {
    "use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Tag = void 0;
var _Bindable = require("./Bindable");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var CurrentStyle = Symbol('CurrentStyle');
var styler = function styler(styles) {
  if (!this.node) {
    return;
  }
  for (var property in styles) {
    var stringedProperty = String(styles[property]);
    if (this[CurrentStyle].has(property) && this[CurrentStyle].get(property) === styles[property]) {
      continue;
    }
    if (property[0] === '-') {
      this.node.style.setProperty(property, stringedProperty);
    } else {
      this.node.style[property] = stringedProperty;
    }
    if (styles[property] !== undefined) {
      this[CurrentStyle].set(property, styles[property]);
    } else {
      this[CurrentStyle].delete(property);
    }
  }
};
var getter = function getter(name) {
  var _this = this;
  if (typeof this[name] === 'function') {
    return this[name];
  }
  if (this.node && typeof this.node[name] === 'function') {
    return function () {
      return _this.node[name](...arguments);
    };
  }
  if (name === 'style') {
    return this.proxy.style;
  }
  if (this.node && name in this.node) {
    return this.node[name];
  }
  return this[name];
};
var Tag = /*#__PURE__*/function () {
  function Tag(element, parent, ref, index, direct) {
    _classCallCheck(this, Tag);
    if (typeof element === 'string') {
      var subdoc = document.createRange().createContextualFragment(element);
      element = subdoc.firstChild;
    }
    this.element = _Bindable.Bindable.makeBindable(element);
    this.node = this.element;
    this.parent = parent;
    this.direct = direct;
    this.ref = ref;
    this.index = index;
    this.cleanup = [];
    this[_Bindable.Bindable.OnAllGet] = getter.bind(this);
    this[CurrentStyle] = new Map();
    var boundStyler = _Bindable.Bindable.make(styler.bind(this));
    Object.defineProperty(this, 'style', {
      value: boundStyler
    });
    this.proxy = _Bindable.Bindable.make(this);
    this.proxy.style.bindTo((v, k, t, d) => {
      if (this[CurrentStyle].has(k) && this[CurrentStyle].get(k) === v) {
        return;
      }
      this.node.style[k] = v;
      if (!d && v !== undefined) {
        this[CurrentStyle].set(k, v);
      } else {
        this[CurrentStyle].delete(k);
      }
    });
    this.proxy.bindTo((v, k) => {
      if (k === 'index') {
        return;
      }
      if (k in element && element[k] !== v) {
        element[k] = v;
      }
      return false;
    });
    return this.proxy;
  }
  _createClass(Tag, [{
    key: "attr",
    value: function attr(attributes) {
      for (var attribute in attributes) {
        if (attributes[attribute] === undefined) {
          this.node.removeAttribute(attribute);
        } else if (attributes[attribute] === null) {
          this.node.setAttribute(attribute, '');
        } else {
          this.node.setAttribute(attribute, attributes[attribute]);
        }
      }
      return this;
    }
  }, {
    key: "remove",
    value: function remove() {
      if (this.node) {
        this.node.remove();
      }
      _Bindable.Bindable.clearBindings(this);
      var cleanup;
      while (cleanup = this.cleanup.shift()) {
        cleanup();
      }
      this.clear();
      if (!this.node) {
        return;
      }
      var detachEvent = new Event('cvDomDetached');
      this.node.dispatchEvent(detachEvent);
      this.node = this.element = this.ref = this.parent = undefined;
    }
  }, {
    key: "clear",
    value: function clear() {
      if (!this.node) {
        return;
      }
      var detachEvent = new Event('cvDomDetached');
      while (this.node.firstChild) {
        this.node.firstChild.dispatchEvent(detachEvent);
        this.node.removeChild(this.node.firstChild);
      }
    }
  }, {
    key: "pause",
    value: function pause() {
      var paused = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
    }
  }, {
    key: "listen",
    value: function listen(eventName, callback, options) {
      var node = this.node;
      node.addEventListener(eventName, callback, options);
      var remove = () => {
        node.removeEventListener(eventName, callback, options);
      };
      var remover = () => {
        remove();
        remove = () => console.warn('Already removed!');
      };
      this.parent.onRemove(() => remover());
      return remover;
    }
  }]);
  return Tag;
}();
exports.Tag = Tag;
  })();
});

require.register("curvature/base/Uuid.js", function(exports, require, module) {
  require = __makeRelativeRequire(require, {}, "curvature");
  (function() {
    "use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Uuid = void 0;
var _Symbol$toPrimitive;
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
var win = (typeof globalThis === "undefined" ? "undefined" : _typeof(globalThis)) === 'object' ? globalThis : (typeof window === "undefined" ? "undefined" : _typeof(window)) === 'object' ? window : (typeof self === "undefined" ? "undefined" : _typeof(self)) === 'object' ? self : void 0;
var crypto = win.crypto;
_Symbol$toPrimitive = Symbol.toPrimitive;
var Uuid = /*#__PURE__*/function () {
  function Uuid() {
    var uuid = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var version = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 4;
    _classCallCheck(this, Uuid);
    _defineProperty(this, "uuid", null);
    _defineProperty(this, "version", 4);
    if (uuid) {
      if (typeof uuid !== 'string' && !(uuid instanceof Uuid) || !uuid.match(/[0-9A-Fa-f]{8}(-[0-9A-Fa-f]{4}){3}-[0-9A-Fa-f]{12}/)) {
        throw new Error("Invalid input for Uuid: \"".concat(uuid, "\""));
      }
      this.version = version;
      this.uuid = uuid;
    } else if (crypto && typeof crypto.randomUUID === 'function') {
      this.uuid = crypto.randomUUID();
    } else {
      var init = [1e7] + -1e3 + -4e3 + -8e3 + -1e11;
      var rand = crypto && typeof crypto.randomUUID === 'function' ? () => crypto.getRandomValues(new Uint8Array(1))[0] : () => Math.trunc(Math.random() * 256);
      this.uuid = init.replace(/[018]/g, c => (c ^ rand() & 15 >> c / 4).toString(16));
    }
    Object.freeze(this);
  }
  _createClass(Uuid, [{
    key: _Symbol$toPrimitive,
    value: function value() {
      return this.toString();
    }
  }, {
    key: "toString",
    value: function toString() {
      return this.uuid;
    }
  }, {
    key: "toJson",
    value: function toJson() {
      return {
        version: this.version,
        uuid: this.uuid
      };
    }
  }]);
  return Uuid;
}();
exports.Uuid = Uuid;
  })();
});

require.register("curvature/base/View.js", function(exports, require, module) {
  require = __makeRelativeRequire(require, {}, "curvature");
  (function() {
    "use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.View = void 0;
var _Bindable = require("./Bindable");
var _ViewList = require("./ViewList");
var _Router = require("./Router");
var _Uuid = require("./Uuid");
var _Dom = require("./Dom");
var _Tag = require("./Tag");
var _Bag = require("./Bag");
var _RuleSet = require("./RuleSet");
var _Mixin = require("./Mixin");
var _EventTargetMixin = require("../mixin/EventTargetMixin");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
var dontParse = Symbol('dontParse');
var expandBind = Symbol('expandBind');
var uuid = Symbol('uuid');
var View = /*#__PURE__*/function (_Mixin$with) {
  _inherits(View, _Mixin$with);
  var _super = _createSuper(View);
  function View() {
    var _this;
    var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var mainView = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    _classCallCheck(this, View);
    _this = _super.call(this, args, mainView);
    _this[_EventTargetMixin.EventTargetMixin.Parent] = mainView;
    Object.defineProperty(_assertThisInitialized(_this), 'args', {
      value: _Bindable.Bindable.make(args)
    });
    Object.defineProperty(_assertThisInitialized(_this), uuid, {
      value: _this.constructor.uuid()
    });
    Object.defineProperty(_assertThisInitialized(_this), 'nodesAttached', {
      value: new _Bag.Bag((i, s, a) => {})
    });
    Object.defineProperty(_assertThisInitialized(_this), 'nodesDetached', {
      value: new _Bag.Bag((i, s, a) => {})
    });
    Object.defineProperty(_assertThisInitialized(_this), '_onRemove', {
      value: new _Bag.Bag((i, s, a) => {})
    });
    Object.defineProperty(_assertThisInitialized(_this), 'cleanup', {
      value: []
    });
    Object.defineProperty(_assertThisInitialized(_this), 'parent', {
      value: mainView,
      writable: true
    });
    Object.defineProperty(_assertThisInitialized(_this), 'views', {
      value: new Map()
    });
    Object.defineProperty(_assertThisInitialized(_this), 'viewLists', {
      value: new Map()
    });
    Object.defineProperty(_assertThisInitialized(_this), 'withViews', {
      value: new Map()
    });
    Object.defineProperty(_assertThisInitialized(_this), 'tags', {
      value: _Bindable.Bindable.make({})
    });
    Object.defineProperty(_assertThisInitialized(_this), 'nodes', {
      value: _Bindable.Bindable.make([])
    });
    Object.defineProperty(_assertThisInitialized(_this), 'timeouts', {
      value: new Map()
    });
    Object.defineProperty(_assertThisInitialized(_this), 'intervals', {
      value: new Map()
    });
    Object.defineProperty(_assertThisInitialized(_this), 'frames', {
      value: []
    });
    Object.defineProperty(_assertThisInitialized(_this), 'ruleSet', {
      value: new _RuleSet.RuleSet()
    });
    Object.defineProperty(_assertThisInitialized(_this), 'preRuleSet', {
      value: new _RuleSet.RuleSet()
    });
    Object.defineProperty(_assertThisInitialized(_this), 'subBindings', {
      value: {}
    });
    Object.defineProperty(_assertThisInitialized(_this), 'templates', {
      value: {}
    });
    Object.defineProperty(_assertThisInitialized(_this), 'postMapping', {
      value: new Set()
    });
    Object.defineProperty(_assertThisInitialized(_this), 'eventCleanup', {
      value: []
    });
    Object.defineProperty(_assertThisInitialized(_this), 'unpauseCallbacks', {
      value: new Map()
    });
    Object.defineProperty(_assertThisInitialized(_this), 'interpolateRegex', {
      value: /(\[\[((?:\$+)?[\w\.\|-]+)\]\])/g
    });
    Object.defineProperty(_assertThisInitialized(_this), 'rendered', {
      value: new Promise((accept, reject) => Object.defineProperty(_assertThisInitialized(_this), 'renderComplete', {
        value: accept
      }))
    });
    _this.onRemove(() => {
      if (!_this[_EventTargetMixin.EventTargetMixin.Parent]) {
        return;
      }
      _this[_EventTargetMixin.EventTargetMixin.Parent] = null;
    });
    _this.controller = _assertThisInitialized(_this);
    _this.template = "";
    _this.firstNode = null;
    _this.lastNode = null;
    _this.viewList = null;
    _this.mainView = null;
    _this.preserve = false;
    _this.removed = false;
    _this.loaded = Promise.resolve(_assertThisInitialized(_this));

    // return Bindable.make(this);
    return _this;
  }
  _createClass(View, [{
    key: "_id",
    get: function get() {
      return this[uuid];
    }
  }, {
    key: "onFrame",
    value: function onFrame(callback) {
      var stopped = false;
      var cancel = () => {
        stopped = true;
      };
      var c = timestamp => {
        if (this.removed || stopped) {
          return;
        }
        if (!this.paused) {
          callback(Date.now());
        }
        requestAnimationFrame(c);
      };
      requestAnimationFrame(() => c(Date.now()));
      this.frames.push(cancel);
      return cancel;
    }
  }, {
    key: "onNextFrame",
    value: function onNextFrame(callback) {
      return requestAnimationFrame(() => callback(Date.now()));
    }
  }, {
    key: "onIdle",
    value: function onIdle(callback) {
      return requestIdleCallback(() => callback(Date.now()));
    }
  }, {
    key: "onTimeout",
    value: function onTimeout(time, callback) {
      var timeoutInfo = {
        timeout: null,
        callback: null,
        time: time,
        fired: false,
        created: new Date().getTime(),
        paused: false
      };
      var wrappedCallback = () => {
        callback();
        timeoutInfo.fired = true;
        this.timeouts.delete(timeoutInfo.timeout);
      };
      var timeout = setTimeout(wrappedCallback, time);
      timeoutInfo.callback = wrappedCallback;
      timeoutInfo.timeout = timeout;
      this.timeouts.set(timeoutInfo.timeout, timeoutInfo);
      return timeout;
    }
  }, {
    key: "clearTimeout",
    value: function (_clearTimeout) {
      function clearTimeout(_x) {
        return _clearTimeout.apply(this, arguments);
      }
      clearTimeout.toString = function () {
        return _clearTimeout.toString();
      };
      return clearTimeout;
    }(function (timeout) {
      if (!this.timeouts.has(timeout)) {
        return;
      }
      var timeoutInfo = this.timeouts.get(timeout);
      clearTimeout(timeoutInfo.timeout);
      this.timeouts.delete(timeoutInfo.timeout);
    })
  }, {
    key: "onInterval",
    value: function onInterval(time, callback) {
      var timeout = setInterval(callback, time);
      this.intervals.set(timeout, {
        timeout: timeout,
        callback: callback,
        time: time,
        paused: false
      });
      return timeout;
    }
  }, {
    key: "clearInterval",
    value: function clearInterval(timeout) {
      if (!this.intervals.has(timeout)) {
        return;
      }
      var timeoutInfo = this.intervals.get(timeout);
      clearTimeout(timeoutInfo.timeout);
      this.intervals.delete(timeoutInfo.timeout);
    }
  }, {
    key: "pause",
    value: function pause() {
      var paused = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;
      if (paused === undefined) {
        this.paused = !this.paused;
      }
      this.paused = paused;
      if (this.paused) {
        for (var _ref3 of this.timeouts) {
          var _ref2 = _slicedToArray(_ref3, 2);
          var callback = _ref2[0];
          var timeout = _ref2[1];
          if (timeout.fired) {
            this.timeouts.delete(timeout.timeout);
            continue;
          }
          clearTimeout(timeout.timeout);
          timeout.paused = true;
          timeout.time = Math.max(0, timeout.time - (Date.now() - timeout.created));
        }
        for (var _ref6 of this.intervals) {
          var _ref5 = _slicedToArray(_ref6, 2);
          var _callback = _ref5[0];
          var _timeout = _ref5[1];
          clearInterval(_timeout.timeout);
          _timeout.paused = true;
        }
      } else {
        for (var _ref9 of this.timeouts) {
          var _ref8 = _slicedToArray(_ref9, 2);
          var _callback2 = _ref8[0];
          var _timeout2 = _ref8[1];
          if (!_timeout2.paused) {
            continue;
          }
          if (_timeout2.fired) {
            this.timeouts.delete(_timeout2.timeout);
            continue;
          }
          _timeout2.timeout = setTimeout(_timeout2.callback, _timeout2.time);
          _timeout2.paused = false;
        }
        for (var _ref12 of this.intervals) {
          var _ref11 = _slicedToArray(_ref12, 2);
          var _callback3 = _ref11[0];
          var _timeout3 = _ref11[1];
          if (!_timeout3.paused) {
            continue;
          }
          _timeout3.timeout = setInterval(_timeout3.callback, _timeout3.time);
          _timeout3.paused = false;
        }
        for (var _ref15 of this.unpauseCallbacks) {
          var _ref14 = _slicedToArray(_ref15, 2);
          var _callback4 = _ref14[1];
          _callback4();
        }
        this.unpauseCallbacks.clear();
      }
      for (var _ref18 of this.viewLists) {
        var _ref17 = _slicedToArray(_ref18, 2);
        var tag = _ref17[0];
        var viewList = _ref17[1];
        viewList.pause(!!paused);
      }
      for (var i in this.tags) {
        if (Array.isArray(this.tags[i])) {
          for (var j in this.tags[i]) {
            this.tags[i][j].pause(!!paused);
          }
          continue;
        }
        this.tags[i].pause(!!paused);
      }
    }
  }, {
    key: "render",
    value: function render() {
      var parentNode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var insertPoint = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var outerView = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var document = globalThis.window.document;
      if (parentNode instanceof View) {
        parentNode = parentNode.firstNode.parentNode;
      }
      if (insertPoint instanceof View) {
        insertPoint = insertPoint.firstNode;
      }
      if (this.firstNode) {
        return this.reRender(parentNode, insertPoint, outerView);
      }
      this.dispatchEvent(new CustomEvent('render'));
      var templateIsFragment = _typeof(this.template) === 'object' && typeof this.template.cloneNode === 'function';
      var templateParsed = templateIsFragment || View.templates.has(this.template);
      var subDoc;
      if (templateParsed) {
        if (templateIsFragment) {
          subDoc = this.template.cloneNode(true);
        } else {
          subDoc = View.templates.get(this.template).cloneNode(true);
        }
      } else {
        subDoc = document.createRange().createContextualFragment(this.template);
      }
      if (!templateParsed && !templateIsFragment) {
        View.templates.set(this.template, subDoc.cloneNode(true));
      }
      this.mainView || this.preRuleSet.apply(subDoc, this);
      this.mapTags(subDoc);
      this.mainView || this.ruleSet.apply(subDoc, this);
      if (globalThis.devMode === true) {
        this.firstNode = document.createComment("Template ".concat(this._id, " Start"));
        this.lastNode = document.createComment("Template ".concat(this._id, " End"));
      } else {
        this.firstNode = document.createTextNode('');
        this.lastNode = document.createTextNode('');
      }
      this.nodes.push(this.firstNode, ...Array.from(subDoc.childNodes), this.lastNode);
      this.postRender(parentNode);
      this.dispatchEvent(new CustomEvent('rendered'));
      if (!this.dispatchAttach()) {
        return;
      }
      if (parentNode) {
        if (insertPoint) {
          parentNode.insertBefore(this.firstNode, insertPoint);
          parentNode.insertBefore(this.lastNode, insertPoint);
        } else {
          parentNode.appendChild(this.firstNode);
          parentNode.appendChild(this.lastNode);
        }
        parentNode.insertBefore(subDoc, this.lastNode);
        var rootNode = parentNode.getRootNode();
        if (rootNode.isConnected) {
          this.attached(rootNode, parentNode);
          this.dispatchAttached(rootNode, parentNode, outerView);
        } else if (outerView) {
          var firstDomAttach = event => {
            var rootNode = parentNode.getRootNode();
            this.attached(rootNode, parentNode);
            this.dispatchAttached(rootNode, parentNode, outerView);
            outerView.removeEventListener('attached', firstDomAttach);
          };
          outerView.addEventListener('attached', firstDomAttach);
        }
      }
      this.renderComplete(this.nodes);
      return this.nodes;
    }
  }, {
    key: "dispatchAttach",
    value: function dispatchAttach() {
      var CustomEvent = globalThis.window.CustomEvent;
      return this.dispatchEvent(new CustomEvent('attach', {
        cancelable: true,
        target: this
      }));
    }
  }, {
    key: "dispatchAttached",
    value: function dispatchAttached(rootNode, parentNode) {
      var view = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
      var CustomEvent = globalThis.window.CustomEvent;
      this.dispatchEvent(new CustomEvent('attached', {
        detail: {
          view: view || this,
          node: parentNode,
          root: rootNode,
          mainView: this
        }
      }));
      this.dispatchDomAttached(view);
      for (var callback of this.nodesAttached.items()) {
        callback(rootNode, parentNode);
      }
    }
  }, {
    key: "dispatchDomAttached",
    value: function dispatchDomAttached(view) {
      var _globalThis$window = globalThis.window,
        Node = _globalThis$window.Node,
        CustomEvent = _globalThis$window.CustomEvent;
      this.nodes.filter(n => n.nodeType !== Node.COMMENT_NODE).forEach(child => {
        if (!child.matches) {
          return;
        }
        child.dispatchEvent(new CustomEvent('cvDomAttached', {
          target: child,
          detail: {
            view: view || this,
            mainView: this
          }
        }));
        _Dom.Dom.mapTags(child, false, (tag, walker) => {
          if (!tag.matches) {
            return;
          }
          tag.dispatchEvent(new CustomEvent('cvDomAttached', {
            target: tag,
            detail: {
              view: view || this,
              mainView: this
            }
          }));
        });
      });
    }
  }, {
    key: "reRender",
    value: function reRender(parentNode, insertPoint, outerView) {
      var CustomEvent = globalThis.window.CustomEvent;
      var willReRender = this.dispatchEvent(new CustomEvent('reRender'), {
        cancelable: true,
        target: this,
        view: outerView
      });
      if (!willReRender) {
        return;
      }
      var subDoc = new DocumentFragment();
      if (this.firstNode.isConnected) {
        var detach = this.nodesDetached.items();
        for (var i in detach) {
          detach[i]();
        }
      }
      subDoc.append(...this.nodes);
      if (parentNode) {
        if (insertPoint) {
          parentNode.insertBefore(this.firstNode, insertPoint);
          parentNode.insertBefore(this.lastNode, insertPoint);
        } else {
          parentNode.appendChild(this.firstNode);
          parentNode.appendChild(this.lastNode);
        }
        parentNode.insertBefore(subDoc, this.lastNode);
        this.dispatchEvent(new CustomEvent('reRendered'), {
          cancelable: true,
          target: this,
          view: outerView
        });
        var rootNode = parentNode.getRootNode();
        if (rootNode.isConnected) {
          this.attached(rootNode, parentNode);
          this.dispatchAttached(rootNode, parentNode);
        }
      }
      return this.nodes;
    }
  }, {
    key: "mapTags",
    value: function mapTags(subDoc) {
      _Dom.Dom.mapTags(subDoc, false, (tag, walker) => {
        if (tag[dontParse]) {
          return;
        }
        if (tag.matches) {
          tag = this.mapInterpolatableTag(tag);
          tag = tag.matches('[cv-template]') && this.mapTemplateTag(tag) || tag;
          tag = tag.matches('[cv-slot]') && this.mapSlotTag(tag) || tag;
          tag = tag.matches('[cv-prerender]') && this.mapPrendererTag(tag) || tag;
          tag = tag.matches('[cv-link]') && this.mapLinkTag(tag) || tag;
          tag = tag.matches('[cv-attr]') && this.mapAttrTag(tag) || tag;
          tag = tag.matches('[cv-expand]') && this.mapExpandableTag(tag) || tag;
          tag = tag.matches('[cv-ref]') && this.mapRefTag(tag) || tag;
          tag = tag.matches('[cv-on]') && this.mapOnTag(tag) || tag;
          tag = tag.matches('[cv-each]') && this.mapEachTag(tag) || tag;
          tag = tag.matches('[cv-bind]') && this.mapBindTag(tag) || tag;
          tag = tag.matches('[cv-with]') && this.mapWithTag(tag) || tag;
          tag = tag.matches('[cv-if]') && this.mapIfTag(tag) || tag;
          tag = tag.matches('[cv-view]') && this.mapViewTag(tag) || tag;
        } else {
          tag = this.mapInterpolatableTag(tag);
        }
        if (tag !== walker.currentNode) {
          walker.currentNode = tag;
        }
      });
      this.postMapping.forEach(c => c());
    }
  }, {
    key: "mapExpandableTag",
    value: function mapExpandableTag(tag) {
      // const tagCompiler = this.compileExpandableTag(tag);
      // const newTag = tagCompiler(this);
      // tag.replaceWith(newTag);
      // return newTag;

      var existing = tag[expandBind];
      if (existing) {
        existing();
        tag[expandBind] = false;
      }
      var _Bindable$resolve = _Bindable.Bindable.resolve(this.args, tag.getAttribute('cv-expand'), true),
        _Bindable$resolve2 = _slicedToArray(_Bindable$resolve, 2),
        proxy = _Bindable$resolve2[0],
        expandProperty = _Bindable$resolve2[1];
      tag.removeAttribute('cv-expand');
      if (!proxy[expandProperty]) {
        proxy[expandProperty] = {};
      }
      proxy[expandProperty] = _Bindable.Bindable.make(proxy[expandProperty]);
      this.onRemove(tag[expandBind] = proxy[expandProperty].bindTo((v, k, t, d, p) => {
        if (d || v === undefined) {
          tag.removeAttribute(k, v);
          return;
        }
        if (v === null) {
          tag.setAttribute(k, '');
          return;
        }
        tag.setAttribute(k, v);
      }));

      // let expandProperty = tag.getAttribute('cv-expand');
      // let expandArg = Bindable.makeBindable(
      // 	this.args[expandProperty] || {}
      // );

      // tag.removeAttribute('cv-expand');

      // for(let i in expandArg)
      // {
      // 	if(i === 'name' || i === 'type')
      // 	{
      // 		continue;
      // 	}

      // 	let debind = expandArg.bindTo(i, ((tag,i)=>(v)=>{
      // 		tag.setAttribute(i, v);
      // 	})(tag,i));

      // 	this.onRemove(()=>{
      // 		debind();
      // 		if(expandArg.isBound())
      // 		{
      // 			Bindable.clearBindings(expandArg);
      // 		}
      // 	});
      // }

      return tag;
    }

    // compileExpandableTag(sourceTag)
    // {
    // 	return (bindingView) => {

    // 		const tag = sourceTag.cloneNode(true);

    // 		let expandProperty = tag.getAttribute('cv-expand');
    // 		let expandArg = Bindable.make(
    // 			bindingView.args[expandProperty] || {}
    // 		);

    // 		tag.removeAttribute('cv-expand');

    // 		for(let i in expandArg)
    // 		{
    // 			if(i === 'name' || i === 'type')
    // 			{
    // 				continue;
    // 			}

    // 			let debind = expandArg.bindTo(i, ((tag,i)=>(v)=>{
    // 				tag.setAttribute(i, v);
    // 			})(tag,i));

    // 			bindingView.onRemove(()=>{
    // 				debind();
    // 				if(expandArg.isBound())
    // 				{
    // 					Bindable.clearBindings(expandArg);
    // 				}
    // 			});
    // 		}

    // 		return tag;
    // 	};
    // }
  }, {
    key: "mapAttrTag",
    value: function mapAttrTag(tag) {
      var tagCompiler = this.compileAttrTag(tag);
      var newTag = tagCompiler(this);
      tag.replaceWith(newTag);
      return newTag;

      // let attrProperty = tag.getAttribute('cv-attr');

      // tag.removeAttribute('cv-attr');

      // let pairs = attrProperty.split(',');
      // let attrs = pairs.map((p) => p.split(':'));

      // for (let i in attrs)
      // {
      // 	let proxy        = this.args;
      // 	let bindProperty = attrs[i][1];
      // 	let property     = bindProperty;

      // 	if(bindProperty.match(/\./))
      // 	{
      // 		[proxy, property] = Bindable.resolve(
      // 			this.args
      // 			, bindProperty
      // 			, true
      // 		);
      // 	}

      // 	let attrib = attrs[i][0];

      // 	this.onRemove(proxy.bindTo(
      // 		property
      // 		, (v)=>{
      // 			if(v == null)
      // 			{
      // 				tag.setAttribute(attrib, '');
      // 				return;
      // 			}
      // 			tag.setAttribute(attrib, v);
      // 		}
      // 	));
      // }

      // return tag;
    }
  }, {
    key: "compileAttrTag",
    value: function compileAttrTag(sourceTag) {
      var attrProperty = sourceTag.getAttribute('cv-attr');
      var pairs = attrProperty.split(/[,;]/);
      var attrs = pairs.map(p => p.split(':'));
      sourceTag.removeAttribute('cv-attr');
      return bindingView => {
        var tag = sourceTag.cloneNode(true);
        var _loop = function _loop() {
          var bindProperty = attrs[i][1] || attrs[i][0];
          var _Bindable$resolve3 = _Bindable.Bindable.resolve(bindingView.args, bindProperty, true),
            _Bindable$resolve4 = _slicedToArray(_Bindable$resolve3, 2),
            proxy = _Bindable$resolve4[0],
            property = _Bindable$resolve4[1];
          var attrib = attrs[i][0];
          bindingView.onRemove(proxy.bindTo(property, (v, k, t, d) => {
            if (d || v === undefined) {
              tag.removeAttribute(attrib, v);
              return;
            }
            if (v === null) {
              tag.setAttribute(attrib, '');
              return;
            }
            tag.setAttribute(attrib, v);
          }));
        };
        for (var i in attrs) {
          _loop();
        }
        return tag;
      };
    }
  }, {
    key: "mapInterpolatableTag",
    value: function mapInterpolatableTag(tag) {
      var _this2 = this;
      var regex = this.interpolateRegex;
      var _globalThis$window2 = globalThis.window,
        Node = _globalThis$window2.Node,
        document = _globalThis$window2.document;
      if (tag.nodeType === Node.TEXT_NODE) {
        var original = tag.nodeValue;
        if (!this.interpolatable(original)) {
          return tag;
        }
        var header = 0;
        var match;
        var _loop2 = function _loop2() {
          var bindProperty = match[2];
          var unsafeHtml = false;
          var unsafeView = false;
          var propertySplit = bindProperty.split('|');
          var transformer = false;
          if (propertySplit.length > 1) {
            transformer = _this2.stringTransformer(propertySplit.slice(1));
            bindProperty = propertySplit[0];
          }
          if (bindProperty.substr(0, 2) === '$$') {
            unsafeHtml = true;
            unsafeView = true;
            bindProperty = bindProperty.substr(2);
          }
          if (bindProperty.substr(0, 1) === '$') {
            unsafeHtml = true;
            bindProperty = bindProperty.substr(1);
          }
          if (bindProperty.substr(0, 3) === '000') {
            expand = true;
            bindProperty = bindProperty.substr(3);
            return "continue";
          }
          var staticPrefix = original.substring(header, match.index);
          header = match.index + match[1].length;
          var staticNode = document.createTextNode(staticPrefix);
          staticNode[dontParse] = true;
          tag.parentNode.insertBefore(staticNode, tag);
          var dynamicNode;
          if (unsafeHtml) {
            dynamicNode = document.createElement('div');
          } else {
            dynamicNode = document.createTextNode('');
          }
          dynamicNode[dontParse] = true;
          var proxy = _this2.args;
          var property = bindProperty;
          if (bindProperty.match(/\./)) {
            var _Bindable$resolve5 = _Bindable.Bindable.resolve(_this2.args, bindProperty, true);
            var _Bindable$resolve6 = _slicedToArray(_Bindable$resolve5, 2);
            proxy = _Bindable$resolve6[0];
            property = _Bindable$resolve6[1];
          }
          tag.parentNode.insertBefore(dynamicNode, tag);
          if (_typeof(proxy) !== 'object') {
            return "break";
          }
          proxy = _Bindable.Bindable.make(proxy);
          var debind = proxy.bindTo(property, (v, k, t) => {
            if (t[k] !== v && (t[k] instanceof View || t[k] instanceof Node || t[k] instanceof _Tag.Tag)) {
              if (!t[k].preserve) {
                t[k].remove();
              }
            }
            dynamicNode.nodeValue = '';
            if (unsafeView && !(v instanceof View)) {
              var _v;
              var unsafeTemplate = (_v = v) !== null && _v !== void 0 ? _v : '';
              v = new View(_this2.args, _this2);
              v.template = unsafeTemplate;
            }
            if (transformer) {
              v = transformer(v);
            }
            if (v instanceof View) {
              v[_EventTargetMixin.EventTargetMixin.Parent] = _this2;
              v.render(tag.parentNode, dynamicNode, _this2);
              var cleanup = () => {
                if (!v.preserve) {
                  v.remove();
                }
              };
              _this2.onRemove(cleanup);
              v.onRemove(() => _this2._onRemove.remove(cleanup));
            } else if (v instanceof Node) {
              tag.parentNode.insertBefore(v, dynamicNode);
              _this2.onRemove(() => v.remove());
            } else if (v instanceof _Tag.Tag) {
              if (v.node) {
                tag.parentNode.insertBefore(v.node, dynamicNode);
                _this2.onRemove(() => v.remove());
              } else {
                v.remove();
              }
            } else {
              if (v instanceof Object && v.__toString instanceof Function) {
                v = v.__toString();
              }
              if (unsafeHtml) {
                dynamicNode.innerHTML = v;
              } else {
                dynamicNode.nodeValue = v;
              }
            }
            dynamicNode[dontParse] = true;
          });
          _this2.onRemove(debind);
        };
        while (match = regex.exec(original)) {
          var _ret = _loop2();
          if (_ret === "continue") continue;
          if (_ret === "break") break;
        }
        var staticSuffix = original.substring(header);
        var staticNode = document.createTextNode(staticSuffix);
        staticNode[dontParse] = true;
        tag.parentNode.insertBefore(staticNode, tag);
        tag.nodeValue = '';
      } else if (tag.nodeType === Node.ELEMENT_NODE) {
        var _loop3 = function _loop3() {
          if (!_this2.interpolatable(tag.attributes[i].value)) {
            return "continue";
          }
          var header = 0;
          var match;
          var original = tag.attributes[i].value;
          var attribute = tag.attributes[i];
          var bindProperties = {};
          var segments = [];
          while (match = regex.exec(original)) {
            segments.push(original.substring(header, match.index));
            if (!bindProperties[match[2]]) {
              bindProperties[match[2]] = [];
            }
            bindProperties[match[2]].push(segments.length);
            segments.push(match[1]);
            header = match.index + match[1].length;
          }
          segments.push(original.substring(header));
          var _loop4 = function _loop4() {
            var proxy = _this2.args;
            var property = j;
            var propertySplit = j.split('|');
            var transformer = false;
            var longProperty = j;
            if (propertySplit.length > 1) {
              transformer = _this2.stringTransformer(propertySplit.slice(1));
              property = propertySplit[0];
            }
            if (property.match(/\./)) {
              var _Bindable$resolve7 = _Bindable.Bindable.resolve(_this2.args, property, true);
              var _Bindable$resolve8 = _slicedToArray(_Bindable$resolve7, 2);
              proxy = _Bindable$resolve8[0];
              property = _Bindable$resolve8[1];
            }
            var matching = [];
            var bindProperty = j;
            var matchingSegments = bindProperties[longProperty];

            // const changeAttribute = (v, k, t, d) => {
            // 	tag.setAttribute(attribute.name, segments.join(''));
            // };

            _this2.onRemove(proxy.bindTo(property, (v, k, t, d) => {
              if (transformer) {
                v = transformer(v);
              }
              for (var _i2 in bindProperties) {
                for (var _j in bindProperties[longProperty]) {
                  segments[bindProperties[longProperty][_j]] = t[_i2];
                  if (k === property) {
                    segments[bindProperties[longProperty][_j]] = v;
                  }
                }
              }
              if (!_this2.paused) {
                // changeAttribute(v,k,t,d);
                tag.setAttribute(attribute.name, segments.join(''));
              } else {
                // this.unpauseCallbacks.set(attribute, () => changeAttribute(v,k,t,d));
                _this2.unpauseCallbacks.set(attribute, () => tag.setAttribute(attribute.name, segments.join('')));
              }
            }));

            // this.onRemove(()=>{
            // 	if(!proxy.isBound())
            // 	{
            // 		Bindable.clearBindings(proxy);
            // 	}
            // });
          };
          for (var j in bindProperties) {
            _loop4();
          }
        };
        for (var i = 0; i < tag.attributes.length; i++) {
          var _ret2 = _loop3();
          if (_ret2 === "continue") continue;
        }
      }
      return tag;
    }
  }, {
    key: "mapRefTag",
    value: function mapRefTag(tag) {
      var refAttr = tag.getAttribute('cv-ref');
      var _refAttr$split = refAttr.split(':'),
        _refAttr$split2 = _slicedToArray(_refAttr$split, 3),
        refProp = _refAttr$split2[0],
        _refAttr$split2$ = _refAttr$split2[1],
        refClassname = _refAttr$split2$ === void 0 ? null : _refAttr$split2$,
        _refAttr$split2$2 = _refAttr$split2[2],
        refKey = _refAttr$split2$2 === void 0 ? null : _refAttr$split2$2;
      var refClass = _Tag.Tag;
      if (refClassname) {
        refClass = this.stringToClass(refClassname);
      }
      tag.removeAttribute('cv-ref');
      Object.defineProperty(tag, '___tag___', {
        enumerable: false,
        writable: true
      });
      this.onRemove(() => {
        tag.___tag___ = null;
        tag.remove();
      });
      var parent = this;
      var direct = this;
      if (this.viewList) {
        parent = this.viewList.parent;
        // if(!this.viewList.parent.tags[refProp])
        // {
        // 	this.viewList.parent.tags[refProp] = [];
        // }

        // let refKeyVal = this.args[refKey];

        // this.viewList.parent.tags[refProp][refKeyVal] = new refClass(
        // 	tag, this, refProp, refKeyVal
        // );
      }
      // else
      // {
      // 	this.tags[refProp] = new refClass(
      // 		tag, this, refProp
      // 	);
      // }

      var tagObject = new refClass(tag, this, refProp, undefined, direct);
      tag.___tag___ = tagObject;
      this.tags[refProp] = tagObject;
      while (parent) {
        var refKeyVal = this.args[refKey];
        if (refKeyVal !== undefined) {
          if (!parent.tags[refProp]) {
            parent.tags[refProp] = [];
          }
          parent.tags[refProp][refKeyVal] = tagObject;
        } else {
          parent.tags[refProp] = tagObject;
        }
        if (!parent.parent) {
          break;
        }
        parent = parent.parent;
      }
      return tag;
    }
  }, {
    key: "mapBindTag",
    value: function mapBindTag(tag) {
      var bindArg = tag.getAttribute('cv-bind');
      var proxy = this.args;
      var property = bindArg;
      var top = null;
      if (bindArg.match(/\./)) {
        var _Bindable$resolve9 = _Bindable.Bindable.resolve(this.args, bindArg, true);
        var _Bindable$resolve10 = _slicedToArray(_Bindable$resolve9, 3);
        proxy = _Bindable$resolve10[0];
        property = _Bindable$resolve10[1];
        top = _Bindable$resolve10[2];
      }
      if (proxy !== this.args) {
        this.subBindings[bindArg] = this.subBindings[bindArg] || [];
        this.onRemove(this.args.bindTo(top, () => {
          while (this.subBindings.length) {
            this.subBindings.shift()();
          }
        }));
      }
      var unsafeHtml = false;
      if (property.substr(0, 1) === '$') {
        property = property.substr(1);
        unsafeHtml = true;
      }
      var autoEventStarted = false;
      var debind = proxy.bindTo(property, (v, k, t, d, p) => {
        if ((p instanceof View || p instanceof Node || p instanceof _Tag.Tag) && p !== v) {
          p.remove();
        }
        if (['INPUT', 'SELECT', 'TEXTAREA'].includes(tag.tagName)) {
          var _type = tag.getAttribute('type');
          if (_type && _type.toLowerCase() === 'checkbox') {
            tag.checked = !!v;
          } else if (_type && _type.toLowerCase() === 'radio') {
            tag.checked = v == tag.value;
          } else if (_type !== 'file') {
            if (tag.tagName === 'SELECT') {
              var selectOption = () => {
                for (var i = 0; i < tag.options.length; i++) {
                  var option = tag.options[i];
                  if (option.value == v) {
                    tag.selectedIndex = i;
                  }
                }
              };
              selectOption();
              this.nodesAttached.add(selectOption);
            } else {
              tag.value = v == null ? '' : v;
            }
          }
          if (autoEventStarted) {
            tag.dispatchEvent(new CustomEvent('cvAutoChanged', {
              bubbles: true
            }));
          }
          autoEventStarted = true;
        } else {
          if (v instanceof View) {
            for (var node of tag.childNodes) {
              node.remove();
            }
            v[_EventTargetMixin.EventTargetMixin.Parent] = this;
            v.render(tag, null, this);
          } else if (v instanceof Node) {
            tag.insert(v);
          } else if (v instanceof _Tag.Tag) {
            tag.append(v.node);
          } else if (unsafeHtml) {
            if (tag.innerHTML !== v) {
              v = String(v);
              if (tag.innerHTML === v.substring(0, tag.innerHTML.length)) {
                tag.innerHTML += v.substring(tag.innerHTML.length);
              } else {
                for (var _node of tag.childNodes) {
                  _node.remove();
                }
                tag.innerHTML = v;
              }
              _Dom.Dom.mapTags(tag, false, t => t[dontParse] = true);
            }
          } else {
            if (tag.textContent !== v) {
              for (var _node2 of tag.childNodes) {
                _node2.remove();
              }
              tag.textContent = v;
            }
          }
        }
      });
      if (proxy !== this.args) {
        this.subBindings[bindArg].push(debind);
      }
      this.onRemove(debind);
      var type = tag.getAttribute('type');
      var multi = tag.getAttribute('multiple');
      var inputListener = event => {
        if (event.target !== tag) {
          return;
        }
        if (type && type.toLowerCase() === 'checkbox') {
          if (tag.checked) {
            proxy[property] = event.target.getAttribute('value');
          } else {
            proxy[property] = false;
          }
        } else if (event.target.matches('[contenteditable=true]')) {
          proxy[property] = event.target.innerHTML;
        } else if (type === 'file' && multi) {
          var files = Array.from(event.target.files);
          var current = proxy[property] || _Bindable.Bindable.onDeck(proxy, property);
          if (!current || !files.length) {
            proxy[property] = files;
          } else {
            var _loop5 = function _loop5(i) {
              if (files[i] !== current[i]) {
                files[i].toJSON = () => {
                  return {
                    name: file[i].name,
                    size: file[i].size,
                    type: file[i].type,
                    date: file[i].lastModified
                  };
                };
                current[i] = files[i];
                return "break";
              }
            };
            for (var i in files) {
              var _ret3 = _loop5(i);
              if (_ret3 === "break") break;
            }
          }
        } else if (type === 'file' && !multi && event.target.files.length) {
          var _file = event.target.files.item(0);
          _file.toJSON = () => {
            return {
              name: _file.name,
              size: _file.size,
              type: _file.type,
              date: _file.lastModified
            };
          };
          proxy[property] = _file;
        } else {
          proxy[property] = event.target.value;
        }
      };
      if (type === 'file' || type === 'radio') {
        tag.addEventListener('change', inputListener);
      } else {
        tag.addEventListener('input', inputListener);
        tag.addEventListener('change', inputListener);
        tag.addEventListener('value-changed', inputListener);
      }
      this.onRemove(() => {
        if (type === 'file' || type === 'radio') {
          tag.removeEventListener('change', inputListener);
        } else {
          tag.removeEventListener('input', inputListener);
          tag.removeEventListener('change', inputListener);
          tag.removeEventListener('value-changed', inputListener);
        }
      });
      tag.removeAttribute('cv-bind');
      return tag;
    }
  }, {
    key: "mapOnTag",
    value: function mapOnTag(tag) {
      var referents = String(tag.getAttribute('cv-on'));
      referents.split(';').map(a => a.split(':')).forEach(a => {
        a = a.map(a => a.trim());
        var argLen = a.length;
        var eventName = String(a.shift()).trim();
        var callbackName = String(a.shift() || eventName).trim();
        var eventFlags = String(a.shift() || '').trim();
        var argList = [];
        var groups = /(\w+)(?:\(([$\w\s-'",]+)\))?/.exec(callbackName);
        if (groups) {
          callbackName = groups[1].replace(/(^[\s\n]+|[\s\n]+$)/, '');
          if (groups[2]) {
            argList = groups[2].split(',').map(s => s.trim());
          }
        }
        if (!argList.length) {
          argList.push('$event');
        }
        if (!eventName || argLen === 1) {
          eventName = callbackName;
        }
        var eventMethod;
        var parent = this;
        var _loop6 = function _loop6() {
          var controller = parent.controller;
          if (typeof controller[callbackName] === 'function') {
            eventMethod = function eventMethod() {
              controller[callbackName](...arguments);
            };
            return "break";
          } else if (typeof parent[callbackName] === 'function') {
            eventMethod = function eventMethod() {
              parent[callbackName](...arguments);
            };
            return "break";
          }
          if (parent.parent) {
            parent = parent.parent;
          } else {
            return "break";
          }
        };
        while (parent) {
          var _ret4 = _loop6();
          if (_ret4 === "break") break;
        }
        var eventListener = event => {
          var argRefs = argList.map(arg => {
            var match;
            if (Number(arg) == arg) {
              return arg;
            } else if (arg === 'event' || arg === '$event') {
              return event;
            } else if (arg === '$view') {
              return parent;
            } else if (arg === '$controller') {
              return controller;
            } else if (arg === '$tag') {
              return tag;
            } else if (arg === '$parent') {
              return this.parent;
            } else if (arg === '$subview') {
              return this;
            } else if (arg in this.args) {
              return this.args[arg];
            } else if (match = /^['"]([\w-]+?)["']$/.exec(arg)) {
              return match[1];
            }
          });
          if (!(typeof eventMethod === 'function')) {
            throw new Error("".concat(callbackName, " is not defined on View object.") + "\n" + "Tag:" + "\n" + "".concat(tag.outerHTML));
          }
          eventMethod(...argRefs);
        };
        var eventOptions = {};
        if (eventFlags.includes('p')) {
          eventOptions.passive = true;
        } else if (eventFlags.includes('P')) {
          eventOptions.passive = false;
        }
        if (eventFlags.includes('c')) {
          eventOptions.capture = true;
        } else if (eventFlags.includes('C')) {
          eventOptions.capture = false;
        }
        if (eventFlags.includes('o')) {
          eventOptions.once = true;
        } else if (eventFlags.includes('O')) {
          eventOptions.once = false;
        }
        switch (eventName) {
          case '_init':
            eventListener();
            break;
          case '_attach':
            this.nodesAttached.add(eventListener);
            break;
          case '_detach':
            this.nodesDetached.add(eventListener);
            break;
          default:
            tag.addEventListener(eventName, eventListener, eventOptions);
            this.onRemove(() => {
              tag.removeEventListener(eventName, eventListener, eventOptions);
            });
            break;
        }
        return [eventName, callbackName, argList];
      });
      tag.removeAttribute('cv-on');
      return tag;
    }
  }, {
    key: "mapLinkTag",
    value: function mapLinkTag(tag) {
      // const tagCompiler = this.compileLinkTag(tag);

      // const newTag = tagCompiler(this);

      // tag.replaceWith(newTag);

      // return newTag;

      var linkAttr = tag.getAttribute('cv-link');
      tag.setAttribute('href', linkAttr);
      var linkClick = event => {
        event.preventDefault();
        if (linkAttr.substring(0, 4) === 'http' || linkAttr.substring(0, 2) === '//') {
          globalThis.open(tag.getAttribute('href', linkAttr));
          return;
        }
        _Router.Router.go(tag.getAttribute('href'));
      };
      tag.addEventListener('click', linkClick);
      this.onRemove(((tag, eventListener) => () => {
        tag.removeEventListener('click', eventListener);
        tag = undefined;
        eventListener = undefined;
      })(tag, linkClick));
      tag.removeAttribute('cv-link');
      return tag;
    }

    // compileLinkTag(sourceTag)
    // {
    // 	const linkAttr = sourceTag.getAttribute('cv-link');
    // 	sourceTag.removeAttribute('cv-link');
    // 	return (bindingView) => {
    // 		const tag = sourceTag.cloneNode(true);
    // 		tag.setAttribute('href', linkAttr);
    // 		return tag;
    // 	};
    // }
  }, {
    key: "mapPrendererTag",
    value: function mapPrendererTag(tag) {
      var prerenderAttr = tag.getAttribute('cv-prerender');
      var prerendering = globalThis.prerenderer || navigator.userAgent.match(/prerender/i);
      tag.removeAttribute('cv-prerender');
      if (prerendering) {
        globalThis.prerenderer = globalThis.prerenderer || true;
      }
      if (prerenderAttr === 'never' && prerendering || prerenderAttr === 'only' && !prerendering) {
        this.postMapping.add(() => tag.parentNode.removeChild(tag));
      }
      return tag;
    }
  }, {
    key: "mapWithTag",
    value: function mapWithTag(tag) {
      var _this3 = this;
      var withAttr = tag.getAttribute('cv-with');
      var carryAttr = tag.getAttribute('cv-carry');
      var viewAttr = tag.getAttribute('cv-view');
      tag.removeAttribute('cv-with');
      tag.removeAttribute('cv-carry');
      tag.removeAttribute('cv-view');
      var viewClass = viewAttr ? this.stringToClass(viewAttr) : View;
      var subTemplate = new DocumentFragment();
      [...tag.childNodes].forEach(n => subTemplate.appendChild(n));
      var carryProps = [];
      if (carryAttr) {
        carryProps = carryAttr.split(',').map(s => s.trim());
      }
      var debind = this.args.bindTo(withAttr, (v, k, t, d) => {
        if (this.withViews.has(tag)) {
          this.withViews.delete(tag);
        }
        while (tag.firstChild) {
          tag.removeChild(tag.firstChild);
        }
        var view = new viewClass({}, this);
        this.onRemove((view => () => {
          view.remove();
        })(view));
        view.template = subTemplate;
        var _loop7 = function _loop7() {
          var debind = _this3.args.bindTo(carryProps[i], (v, k) => {
            view.args[k] = v;
          });
          view.onRemove(debind);
          _this3.onRemove(() => {
            debind();
            view.remove();
          });
        };
        for (var i in carryProps) {
          _loop7();
        }
        var _loop8 = function _loop8() {
          if (_typeof(v) !== 'object') {
            return "continue";
          }
          v = _Bindable.Bindable.make(v);
          var debind = v.bindTo(_i3, (vv, kk, tt, dd) => {
            if (!dd) {
              view.args[kk] = vv;
            } else if (kk in view.args) {
              delete view.args[kk];
            }
          });
          var debindUp = view.args.bindTo(_i3, (vv, kk, tt, dd) => {
            if (!dd) {
              v[kk] = vv;
            } else if (kk in v) {
              delete v[kk];
            }
          });
          _this3.onRemove(() => {
            debind();
            if (!v.isBound()) {
              _Bindable.Bindable.clearBindings(v);
            }
            view.remove();
          });
          view.onRemove(() => {
            debind();
            if (!v.isBound()) {
              _Bindable.Bindable.clearBindings(v);
            }
          });
        };
        for (var _i3 in v) {
          var _ret5 = _loop8();
          if (_ret5 === "continue") continue;
        }
        view.render(tag, null, this);
        this.withViews.set(tag, view);
      });
      this.onRemove(() => {
        this.withViews.delete(tag);
        debind();
      });
      return tag;
    }
  }, {
    key: "mapViewTag",
    value: function mapViewTag(tag) {
      var viewAttr = tag.getAttribute('cv-view');
      tag.removeAttribute('cv-view');
      var subTemplate = new DocumentFragment();
      [...tag.childNodes].forEach(n => subTemplate.appendChild(n));
      var parts = viewAttr.split(':');
      var viewName = parts.shift();
      var viewClass = parts.length ? this.stringToClass(parts[0]) : View;
      var view = new viewClass(this.args, this);
      this.views.set(tag, view);
      this.views.set(viewName, view);
      this.onRemove(() => {
        view.remove();
        this.views.delete(tag);
        this.views.delete(viewName);
      });
      view.template = subTemplate;
      view.render(tag, null, this);
      return tag;
    }
  }, {
    key: "mapEachTag",
    value: function mapEachTag(tag) {
      var eachAttr = tag.getAttribute('cv-each');
      var viewAttr = tag.getAttribute('cv-view');
      tag.removeAttribute('cv-each');
      tag.removeAttribute('cv-view');
      var viewClass = viewAttr ? this.stringToClass(viewAttr) : View;
      var subTemplate = new DocumentFragment();
      [...tag.childNodes].forEach(n => subTemplate.appendChild(n));
      var _eachAttr$split = eachAttr.split(':'),
        _eachAttr$split2 = _slicedToArray(_eachAttr$split, 3),
        eachProp = _eachAttr$split2[0],
        asProp = _eachAttr$split2[1],
        keyProp = _eachAttr$split2[2];
      var proxy = this.args;
      var property = eachProp;
      if (eachProp.match(/\./)) {
        var _Bindable$resolve11 = _Bindable.Bindable.resolve(this.args, eachProp, true);
        var _Bindable$resolve12 = _slicedToArray(_Bindable$resolve11, 2);
        proxy = _Bindable$resolve12[0];
        property = _Bindable$resolve12[1];
      }
      var debind = proxy.bindTo(property, (v, k, t, d, p) => {
        if (v instanceof _Bag.Bag) {
          v = v.list;
        }
        if (this.viewLists.has(tag)) {
          this.viewLists.get(tag).remove();
        }
        var viewList = new _ViewList.ViewList(subTemplate, asProp, v, this, keyProp, viewClass);
        var viewListRemover = () => viewList.remove();
        this.onRemove(viewListRemover);
        viewList.onRemove(() => this._onRemove.remove(viewListRemover));
        var debindA = this.args.bindTo((v, k, t, d) => {
          if (k === '_id') {
            return;
          }
          if (!d) {
            viewList.subArgs[k] = v;
          } else {
            if (k in viewList.subArgs) {
              delete viewList.subArgs[k];
            }
          }
        });
        var debindB = viewList.args.bindTo((v, k, t, d, p) => {
          if (k === '_id' || k === 'value' || String(k).substring(0, 3) === '___') {
            return;
          }
          if (!d) {
            if (k in this.args) {
              this.args[k] = v;
            }
          } else {
            delete this.args[k];
          }
        });
        viewList.onRemove(debindA);
        viewList.onRemove(debindB);
        this.onRemove(debindA);
        this.onRemove(debindB);
        while (tag.firstChild) {
          tag.removeChild(tag.firstChild);
        }
        this.viewLists.set(tag, viewList);
        viewList.render(tag, null, this);
      });
      this.onRemove(debind);
      return tag;
    }
  }, {
    key: "mapIfTag",
    value: function mapIfTag(tag) {
      var sourceTag = tag;
      var viewProperty = sourceTag.getAttribute('cv-view');
      var ifProperty = sourceTag.getAttribute('cv-if');
      var isProperty = sourceTag.getAttribute('cv-is');
      var inverted = false;
      var defined = false;
      sourceTag.removeAttribute('cv-view');
      sourceTag.removeAttribute('cv-if');
      sourceTag.removeAttribute('cv-is');
      var viewClass = viewProperty ? this.stringToClass(viewProperty) : View;
      if (ifProperty.substr(0, 1) === '!') {
        ifProperty = ifProperty.substr(1);
        inverted = true;
      }
      if (ifProperty.substr(0, 1) === '?') {
        ifProperty = ifProperty.substr(1);
        defined = true;
      }
      var subTemplate = new DocumentFragment();
      [...sourceTag.childNodes].forEach(n => subTemplate.appendChild(n));
      var bindingView = this;
      var ifDoc = new DocumentFragment();

      // let view = new viewClass(Object.assign({}, this.args), bindingView);
      var view = new viewClass(this.args, bindingView);
      view.tags.bindTo((v, k) => this.tags[k] = v, {
        removeWith: this
      });
      view.template = subTemplate;
      var proxy = bindingView.args;
      var property = ifProperty;
      if (ifProperty.match(/\./)) {
        var _Bindable$resolve13 = _Bindable.Bindable.resolve(bindingView.args, ifProperty, true);
        var _Bindable$resolve14 = _slicedToArray(_Bindable$resolve13, 2);
        proxy = _Bindable$resolve14[0];
        property = _Bindable$resolve14[1];
      }
      view.render(ifDoc, null, this);
      var propertyDebind = proxy.bindTo(property, (v, k) => {
        var o = v;
        if (defined) {
          v = v !== null && v !== undefined;
        }
        if (v instanceof _Bag.Bag) {
          v = v.list;
        }
        if (Array.isArray(v)) {
          v = !!v.length;
        }
        if (isProperty !== null) {
          v = o == isProperty;
        }
        if (inverted) {
          v = !v;
        }
        if (v) {
          tag.appendChild(ifDoc);
          [...ifDoc.childNodes].forEach(node => _Dom.Dom.mapTags(node, false, (tag, walker) => {
            if (!tag.matches) {
              return;
            }
            tag.dispatchEvent(new CustomEvent('cvDomAttached', {
              target: tag,
              detail: {
                view: view || this,
                mainView: this
              }
            }));
          }));
        } else {
          view.nodes.forEach(n => ifDoc.appendChild(n));
          _Dom.Dom.mapTags(ifDoc, false, (tag, walker) => {
            if (!tag.matches) {
              return;
            }
            new CustomEvent('cvDomDetached', {
              target: tag,
              detail: {
                view: view || this,
                mainView: this
              }
            });
          });
        }
      }, {
        children: Array.isArray(proxy[property])
      });

      // const propertyDebind = this.args.bindChain(property, onUpdate);

      bindingView.onRemove(propertyDebind);

      // const debindA = this.args.bindTo((v,k,t,d) => {
      // 	if(k === '_id')
      // 	{
      // 		return;
      // 	}

      // 	if(!d)
      // 	{
      // 		view.args[k] = v;
      // 	}
      // 	else if(k in view.args)
      // 	{
      // 		delete view.args[k];
      // 	}

      // });

      // const debindB = view.args.bindTo((v,k,t,d,p) => {
      // 	if(k === '_id' || String(k).substring(0,3) === '___')
      // 	{
      // 		return;
      // 	}

      // 	if(k in this.args)
      // 	{
      // 		if(!d)
      // 		{
      // 			this.args[k] = v;
      // 		}
      // 		else
      // 		{
      // 			delete this.args[k];
      // 		}
      // 	}
      // });

      var viewDebind = () => {
        propertyDebind();
        // debindA();
        // debindB();
        bindingView._onRemove.remove(propertyDebind);
        // bindingView._onRemove.remove(bindableDebind);
      };

      bindingView.onRemove(viewDebind);
      this.onRemove(() => {
        // debindA();
        // debindB();
        view.remove();
        if (bindingView !== this) {
          bindingView.remove();
        }
      });
      return tag;
    }

    // compileIfTag(sourceTag)
    // {
    // 	let ifProperty = sourceTag.getAttribute('cv-if');
    // 	let inverted   = false;

    // 	sourceTag.removeAttribute('cv-if');

    // 	if(ifProperty.substr(0, 1) === '!')
    // 	{
    // 		ifProperty = ifProperty.substr(1);
    // 		inverted   = true;
    // 	}

    // 	const subTemplate = new DocumentFragment;

    // 	[...sourceTag.childNodes].forEach(
    // 		n => subTemplate.appendChild(n.cloneNode(true))
    // 	);

    // 	return (bindingView) => {

    // 		const tag = sourceTag.cloneNode();

    // 		const ifDoc = new DocumentFragment;

    // 		let view = new View({}, bindingView);

    // 		view.template = subTemplate;
    // 		// view.parent   = bindingView;

    // 		bindingView.syncBind(view);

    // 		let proxy    = bindingView.args;
    // 		let property = ifProperty;

    // 		if(ifProperty.match(/\./))
    // 		{
    // 			[proxy, property] = Bindable.resolve(
    // 				bindingView.args
    // 				, ifProperty
    // 				, true
    // 			);
    // 		}

    // 		let hasRendered = false;

    // 		const propertyDebind = proxy.bindTo(property, (v,k) => {

    // 			if(!hasRendered)
    // 			{
    // 				const renderDoc = (bindingView.args[property] || inverted)
    // 					? tag : ifDoc;

    // 				view.render(renderDoc);

    // 				hasRendered = true;

    // 				return;
    // 			}

    // 			if(Array.isArray(v))
    // 			{
    // 				v = !!v.length;
    // 			}

    // 			if(inverted)
    // 			{
    // 				v = !v;
    // 			}

    // 			if(v)
    // 			{
    // 				tag.appendChild(ifDoc);
    // 			}
    // 			else
    // 			{
    // 				view.nodes.forEach(n=>ifDoc.appendChild(n));
    // 			}

    // 		});

    // 		// let cleaner = bindingView;

    // 		// while(cleaner.parent)
    // 		// {
    // 		// 	cleaner = cleaner.parent;
    // 		// }

    // 		bindingView.onRemove(propertyDebind);

    // 		let bindableDebind = () => {

    // 			if(!proxy.isBound())
    // 			{
    // 				Bindable.clearBindings(proxy);
    // 			}

    // 		};

    // 		let viewDebind = ()=>{
    // 			propertyDebind();
    // 			bindableDebind();
    // 			bindingView._onRemove.remove(propertyDebind);
    // 			bindingView._onRemove.remove(bindableDebind);
    // 		};

    // 		view.onRemove(viewDebind);

    // 		return tag;
    // 	};
    // }
  }, {
    key: "mapTemplateTag",
    value: function mapTemplateTag(tag) {
      // const templateName = tag.getAttribute('cv-template');

      // tag.removeAttribute('cv-template');

      // this.templates[ templateName ] = tag.tagName === 'TEMPLATE'
      // 	? tag.cloneNode(true).content
      // 	: new DocumentFragment(tag.innerHTML);

      var templateName = tag.getAttribute('cv-template');
      tag.removeAttribute('cv-template');
      var source = tag.innerHTML;
      if (!View.templates.has(source)) {
        View.templates.set(source, document.createRange().createContextualFragment(tag.innerHTML));
      }
      this.templates[templateName] = View.templates.get(source);
      this.postMapping.add(() => tag.remove());
      return tag;
    }
  }, {
    key: "mapSlotTag",
    value: function mapSlotTag(tag) {
      var templateName = tag.getAttribute('cv-slot');
      var template = this.templates[templateName];
      if (!template) {
        var parent = this;
        while (parent) {
          template = parent.templates[templateName];
          if (template) {
            break;
          }
          parent = this.parent;
        }
        if (!template) {
          console.error("Template ".concat(templateName, " not found."));
          return;
        }
      }
      tag.removeAttribute('cv-slot');
      while (tag.firstChild) {
        tag.firstChild.remove();
      }
      tag.appendChild(template.cloneNode(true));
      return tag;
    }

    // syncBind(subView)
    // {
    // 	let debindA = this.args.bindTo((v,k,t,d)=>{
    // 		if(k === '_id')
    // 		{
    // 			return;
    // 		}

    // 		if(subView.args[k] !== v)
    // 		{
    // 			subView.args[k] = v;
    // 		}
    // 	});

    // 	let debindB = subView.args.bindTo((v,k,t,d,p)=>{

    // 		if(k === '_id')
    // 		{
    // 			return;
    // 		}

    // 		let newRef = v;
    // 		let oldRef = p;

    // 		if(newRef instanceof View)
    // 		{
    // 			newRef = newRef.___ref___;
    // 		}

    // 		if(oldRef instanceof View)
    // 		{
    // 			oldRef = oldRef.___ref___;
    // 		}

    // 		if(newRef !== oldRef && oldRef instanceof View)
    // 		{
    // 			p.remove();
    // 		}

    // 		if(k in this.args)
    // 		{
    // 			this.args[k] = v;
    // 		}

    // 	});

    // 	this.onRemove(debindA);
    // 	this.onRemove(debindB);

    // 	subView.onRemove(()=>{
    // 		this._onRemove.remove(debindA);
    // 		this._onRemove.remove(debindB);
    // 	});
    // }
  }, {
    key: "postRender",
    value: function postRender(parentNode) {}
  }, {
    key: "attached",
    value: function attached(parentNode) {}
  }, {
    key: "interpolatable",
    value: function interpolatable(str) {
      return !!String(str).match(this.interpolateRegex);
    }
  }, {
    key: "remove",
    value: function remove() {
      var now = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      if (!this.dispatchEvent(new CustomEvent('remove', {
        detail: {
          view: this
        },
        cancelable: true
      }))) {
        return;
      }
      var remover = () => {
        for (var i in this.tags) {
          if (Array.isArray(this.tags[i])) {
            this.tags[i] && this.tags[i].forEach(t => t.remove());
            this.tags[i].splice(0);
          } else {
            this.tags[i] && this.tags[i].remove();
            this.tags[i] = undefined;
          }
        }
        for (var _i4 in this.nodes) {
          this.nodes[_i4] && this.nodes[_i4].dispatchEvent(new Event('cvDomDetached'));
          this.nodes[_i4] && this.nodes[_i4].remove();
          this.nodes[_i4] = undefined;
        }
        this.nodes.splice(0);
        this.firstNode = this.lastNode = undefined;
      };
      if (now) {
        remover();
      } else {
        requestAnimationFrame(remover);
      }
      var callbacks = this._onRemove.items();
      for (var callback of callbacks) {
        callback();
        this._onRemove.remove(callback);
      }
      for (var cleanup of this.cleanup) {
        cleanup && cleanup();
      }
      this.cleanup.length = 0;
      for (var _ref21 of this.viewLists) {
        var _ref20 = _slicedToArray(_ref21, 2);
        var tag = _ref20[0];
        var viewList = _ref20[1];
        viewList.remove();
      }
      this.viewLists.clear();
      for (var _ref24 of this.timeouts) {
        var _ref23 = _slicedToArray(_ref24, 2);
        var _callback5 = _ref23[0];
        var timeout = _ref23[1];
        clearTimeout(timeout.timeout);
        this.timeouts.delete(timeout.timeout);
      }
      for (var interval of this.intervals) {
        clearInterval(interval);
      }
      this.intervals.length = 0;
      for (var frame of this.frames) {
        frame();
      }
      this.frames.length = 0;
      this.preRuleSet.purge();
      this.ruleSet.purge();
      this.removed = true;
      this.dispatchEvent(new CustomEvent('removed', {
        detail: {
          view: this
        },
        cancelable: true
      }));
    }
  }, {
    key: "findTag",
    value: function findTag(selector) {
      for (var i in this.nodes) {
        var result = void 0;
        if (!this.nodes[i].querySelector) {
          continue;
        }
        if (this.nodes[i].matches(selector)) {
          return new _Tag.Tag(this.nodes[i], this, undefined, undefined, this);
        }
        if (result = this.nodes[i].querySelector(selector)) {
          return new _Tag.Tag(result, this, undefined, undefined, this);
        }
      }
    }
  }, {
    key: "findTags",
    value: function findTags(selector) {
      var topLevel = this.nodes.filter(n => n.matches && n.matches(selector));
      var subLevel = this.nodes.filter(n => n.querySelectorAll).map(n => [...n.querySelectorAll(selector)]).flat().map(n => new _Tag.Tag(n, this, undefined, undefined, this)) || [];
      return topLevel.concat(subLevel);
    }
  }, {
    key: "onRemove",
    value: function onRemove(callback) {
      if (callback instanceof Event) {
        return;
      }
      this._onRemove.add(callback);
    }
  }, {
    key: "update",
    value: function update() {}
  }, {
    key: "beforeUpdate",
    value: function beforeUpdate(args) {}
  }, {
    key: "afterUpdate",
    value: function afterUpdate(args) {}
  }, {
    key: "stringTransformer",
    value: function stringTransformer(methods) {
      return x => {
        for (var m in methods) {
          var parent = this;
          var method = methods[m];
          while (parent && !parent[method]) {
            parent = parent.parent;
          }
          if (!parent) {
            return;
          }
          x = parent[methods[m]](x);
        }
        return x;
      };
    }
  }, {
    key: "stringToClass",
    value: function stringToClass(refClassname) {
      if (View.refClasses.has(refClassname)) {
        return View.refClasses.get(refClassname);
      }
      var refClassSplit = refClassname.split('/');
      var refShortClass = refClassSplit[refClassSplit.length - 1];
      var refClass = require(refClassname);
      View.refClasses.set(refClassname, refClass[refShortClass]);
      return refClass[refShortClass];
    }
  }, {
    key: "preventParsing",
    value: function preventParsing(node) {
      node[dontParse] = true;
    }
  }, {
    key: "toString",
    value: function toString() {
      return this.nodes.map(n => n.outerHTML).join(' ');
    }
  }, {
    key: "listen",
    value: function listen(node, eventName, callback, options) {
      if (typeof node === 'string') {
        options = callback;
        callback = eventName;
        eventName = node;
        node = this;
      }
      if (node instanceof View) {
        return this.listen(node.nodes, eventName, callback, options);
      }
      if (Array.isArray(node)) {
        return node.map(n => this.listen(n, eventName, callback, options));
        // .forEach(r => r());
      }

      if (node instanceof _Tag.Tag) {
        return this.listen(node.element, eventName, callback, options);
      }
      node.addEventListener(eventName, callback, options);
      var remove = () => node.removeEventListener(eventName, callback, options);
      var remover = () => {
        remove();
        remove = () => {};
      };
      this.onRemove(() => remover());
      return remover;
    }
  }, {
    key: "detach",
    value: function detach() {
      for (var n in this.nodes) {
        this.nodes[n].remove();
      }
      return this.nodes;
    }
  }], [{
    key: "from",
    value: function from(template) {
      var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var mainView = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var view = new this(args, mainView);
      view.template = template;
      return view;
    }
  }, {
    key: "isView",
    value: function isView() {
      return View;
    }
  }, {
    key: "uuid",
    value: function uuid() {
      return new _Uuid.Uuid();
    }
  }]);
  return View;
}(_Mixin.Mixin.with(_EventTargetMixin.EventTargetMixin));
exports.View = View;
Object.defineProperty(View, 'templates', {
  value: new Map()
});
Object.defineProperty(View, 'refClasses', {
  value: new Map()
});
  })();
});

require.register("curvature/base/ViewList.js", function(exports, require, module) {
  require = __makeRelativeRequire(require, {}, "curvature");
  (function() {
    "use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ViewList = void 0;
var _Bindable = require("./Bindable");
var _SetMap = require("./SetMap");
var _Bag = require("./Bag");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var ViewList = /*#__PURE__*/function () {
  function ViewList(template, subProperty, list, parent) {
    var keyProperty = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
    var viewClass = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;
    _classCallCheck(this, ViewList);
    this.removed = false;
    this.args = _Bindable.Bindable.makeBindable(Object.create(null));
    this.args.value = _Bindable.Bindable.makeBindable(list || Object.create(null));
    this.subArgs = _Bindable.Bindable.makeBindable(Object.create(null));
    this.views = [];
    this.cleanup = [];
    this.viewClass = viewClass;
    this._onRemove = new _Bag.Bag();
    this.template = template;
    this.subProperty = subProperty;
    this.keyProperty = keyProperty;
    this.tag = null;
    this.downDebind = [];
    this.upDebind = [];
    this.paused = false;
    this.parent = parent;
    this.viewCount = 0;
    this.rendered = new Promise((accept, reject) => {
      Object.defineProperty(this, 'renderComplete', {
        configurable: false,
        writable: true,
        value: accept
      });
    });
    this.willReRender = false;
    this.args.___before((t, e, s, o, a) => {
      if (e == 'bindTo') {
        return;
      }
      this.paused = true;
    });
    this.args.___after((t, e, s, o, a) => {
      if (e == 'bindTo') {
        return;
      }
      this.paused = s.length > 1;
      this.reRender();
    });
    var debind = this.args.value.bindTo((v, k, t, d) => {
      if (this.paused) {
        return;
      }
      var kk = k;
      if (_typeof(k) === 'symbol') {
        return;
      }
      if (isNaN(k)) {
        kk = '_' + k;
      }
      if (d) {
        if (this.views[kk]) {
          this.views[kk].remove(true);
        }
        delete this.views[kk];
        for (var i in this.views) {
          if (!this.views[i]) {
            continue;
          }
          if (isNaN(i)) {
            this.views[i].args[this.keyProperty] = i.substr(1);
            continue;
          }
          this.views[i].args[this.keyProperty] = i;
        }
      } else if (!this.views[kk]) {
        if (this.willReRender === false) {
          this.willReRender = requestAnimationFrame(() => {
            this.willReRender = false;
            this.reRender();
          });
        }
      } else if (this.views[kk] && this.views[kk].args) {
        this.views[kk].args[this.keyProperty] = k;
        this.views[kk].args[this.subProperty] = v;
      }
    });
    this._onRemove.add(debind);
    Object.preventExtensions(this);
  }
  _createClass(ViewList, [{
    key: "render",
    value: function render(tag) {
      var _this = this;
      var renders = [];
      var _loop = function _loop(view) {
        view.viewList = _this;
        view.render(tag, null, _this.parent);
        renders.push(view.rendered.then(() => view));
      };
      for (var view of this.views) {
        _loop(view);
      }
      this.tag = tag;
      Promise.all(renders).then(views => this.renderComplete(views));
      this.parent.dispatchEvent(new CustomEvent('listRendered', {
        detail: {
          detail: {
            key: this.subProperty,
            value: this.args.value
          }
        }
      }));
    }
  }, {
    key: "reRender",
    value: function reRender() {
      var _this2 = this;
      if (this.paused || !this.tag) {
        return;
      }
      var views = [];
      var existingViews = new _SetMap.SetMap();
      for (var i in this.views) {
        var view = this.views[i];
        if (view === undefined) {
          views[i] = view;
          continue;
        }
        var rawValue = view.args[this.subProperty];
        existingViews.add(rawValue, view);
        views[i] = view;
      }
      var finalViews = [];
      var finalViewSet = new Set();
      this.downDebind.length && this.downDebind.forEach(d => d && d());
      this.upDebind.length && this.upDebind.forEach(d => d && d());
      this.upDebind.length = 0;
      this.downDebind.length = 0;
      var minKey = Infinity;
      var anteMinKey = Infinity;
      var _loop2 = function _loop2() {
        var found = false;
        var k = _i;
        if (isNaN(k)) {
          k = '_' + _i;
        } else if (String(k).length) {
          k = Number(k);
        }
        if (_this2.args.value[_i] !== undefined && existingViews.has(_this2.args.value[_i])) {
          var existingView = existingViews.getOne(_this2.args.value[_i]);
          if (existingView) {
            existingView.args[_this2.keyProperty] = _i;
            finalViews[k] = existingView;
            finalViewSet.add(existingView);
            found = true;
            if (!isNaN(k)) {
              minKey = Math.min(minKey, k);
              k > 0 && (anteMinKey = Math.min(anteMinKey, k));
            }
            existingViews.remove(_this2.args.value[_i], existingView);
          }
        }
        if (!found) {
          var viewArgs = Object.create(null);
          var _view = finalViews[k] = new _this2.viewClass(viewArgs, _this2.parent);
          if (!isNaN(k)) {
            minKey = Math.min(minKey, k);
            k > 0 && (anteMinKey = Math.min(anteMinKey, k));
          }
          finalViews[k].template = _this2.template;
          finalViews[k].viewList = _this2;
          finalViews[k].args[_this2.keyProperty] = _i;
          finalViews[k].args[_this2.subProperty] = _this2.args.value[_i];
          _this2.upDebind[k] = viewArgs.bindTo(_this2.subProperty, (v, k, t, d) => {
            var index = viewArgs[_this2.keyProperty];
            if (d) {
              delete _this2.args.value[index];
              return;
            }
            _this2.args.value[index] = v;
          });
          _this2.downDebind[k] = _this2.subArgs.bindTo((v, k, t, d) => {
            if (d) {
              delete viewArgs[k];
              return;
            }
            viewArgs[k] = v;
          });
          var upDebind = () => {
            _this2.upDebind.filter(x => x).forEach(d => d());
            _this2.upDebind.length = 0;
          };
          var downDebind = () => {
            _this2.downDebind.filter(x => x).forEach(d => d());
            _this2.downDebind.length = 0;
          };
          _view.onRemove(() => {
            _this2._onRemove.remove(upDebind);
            _this2._onRemove.remove(downDebind);
            _this2.upDebind[k] && _this2.upDebind[k]();
            _this2.downDebind[k] && _this2.downDebind[k]();
            delete _this2.upDebind[k];
            delete _this2.downDebind[k];
          });
          _this2._onRemove.add(upDebind);
          _this2._onRemove.add(downDebind);
          viewArgs[_this2.subProperty] = _this2.args.value[_i];
        }
      };
      for (var _i in this.args.value) {
        _loop2();
      }
      for (var _i2 in views) {
        if (views[_i2] && !finalViewSet.has(views[_i2])) {
          views[_i2].remove(true);
        }
      }
      if (Array.isArray(this.args.value)) {
        var localMin = minKey === 0 && finalViews[1] !== undefined && finalViews.length > 1 || anteMinKey === Infinity ? minKey : anteMinKey;
        var renderRecurse = function renderRecurse() {
          var i = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
          var ii = finalViews.length - i - 1;
          while (ii > localMin && finalViews[ii] === undefined) {
            ii--;
          }
          if (ii < localMin) {
            return Promise.resolve();
          }
          if (finalViews[ii] === _this2.views[ii]) {
            if (finalViews[ii] && !finalViews[ii].firstNode) {
              finalViews[ii].render(_this2.tag, finalViews[ii + 1], _this2.parent);
              return finalViews[ii].rendered.then(() => renderRecurse(Number(i) + 1));
            } else {
              var split = 500;
              if (i === 0 || i % split) {
                return renderRecurse(Number(i) + 1);
              } else {
                return new Promise(accept => requestAnimationFrame(() => accept(renderRecurse(Number(i) + 1))));
              }
            }
          }
          finalViews[ii].render(_this2.tag, finalViews[ii + 1], _this2.parent);
          _this2.views.splice(ii, 0, finalViews[ii]);
          return finalViews[ii].rendered.then(() => renderRecurse(i + 1));
        };
        this.rendered = renderRecurse();
      } else {
        var renders = [];
        var leftovers = Object.assign(Object.create(null), finalViews);
        var isInt = x => parseInt(x) === x - 0;
        var keys = Object.keys(finalViews).sort((a, b) => {
          if (isInt(a) && isInt(b)) {
            return Math.sign(a - b);
          }
          if (!isInt(a) && !isInt(b)) {
            return 0;
          }
          if (!isInt(a) && isInt(b)) {
            return -1;
          }
          if (isInt(a) && !isInt(b)) {
            return 1;
          }
        });
        var _loop3 = function _loop3(_i3) {
          delete leftovers[_i3];
          if (finalViews[_i3].firstNode && finalViews[_i3] === _this2.views[_i3]) {
            return "continue";
          }
          finalViews[_i3].render(_this2.tag, null, _this2.parent);
          renders.push(finalViews[_i3].rendered.then(() => finalViews[_i3]));
        };
        for (var _i3 of keys) {
          var _ret = _loop3(_i3);
          if (_ret === "continue") continue;
        }
        for (var _i4 in leftovers) {
          delete this.args.views[_i4];
          leftovers.remove(true);
        }
        this.rendered = Promise.all(renders);
      }
      for (var _i5 in finalViews) {
        if (isNaN(_i5)) {
          finalViews[_i5].args[this.keyProperty] = _i5.substr(1);
          continue;
        }
        finalViews[_i5].args[this.keyProperty] = _i5;
      }
      this.views = Array.isArray(this.args.value) ? [...finalViews] : finalViews;
      this.viewCount = finalViewSet.size;
      finalViewSet.clear();
      this.willReRender = false;
      this.rendered.then(() => {
        this.parent.dispatchEvent(new CustomEvent('listRendered', {
          detail: {
            detail: {
              key: this.subProperty,
              value: this.args.value,
              tag: this.tag
            }
          }
        }));
        this.tag.dispatchEvent(new CustomEvent('listRendered', {
          detail: {
            detail: {
              key: this.subProperty,
              value: this.args.value,
              tag: this.tag
            }
          }
        }));
      });
      return this.rendered;
    }
  }, {
    key: "pause",
    value: function pause() {
      var _pause = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      for (var i in this.views) {
        this.views[i].pause(_pause);
      }
    }
  }, {
    key: "onRemove",
    value: function onRemove(callback) {
      this._onRemove.add(callback);
    }
  }, {
    key: "remove",
    value: function remove() {
      for (var i in this.views) {
        this.views[i] && this.views[i].remove(true);
      }
      var onRemove = this._onRemove.items();
      for (var _i6 in onRemove) {
        this._onRemove.remove(onRemove[_i6]);
        onRemove[_i6]();
      }
      var cleanup;
      while (this.cleanup.length) {
        cleanup = this.cleanup.pop();
        cleanup();
      }
      this.views = [];
      while (this.tag && this.tag.firstChild) {
        this.tag.removeChild(this.tag.firstChild);
      }
      if (this.subArgs) {
        _Bindable.Bindable.clearBindings(this.subArgs);
      }
      _Bindable.Bindable.clearBindings(this.args);

      // if(this.args.value && !this.args.value.isBound())
      // {
      // 	Bindable.clearBindings(this.args.value);
      // }

      this.removed = true;
    }
  }]);
  return ViewList;
}();
exports.ViewList = ViewList;
  })();
});

require.register("curvature/input/Keyboard.js", function(exports, require, module) {
  require = __makeRelativeRequire(require, {}, "curvature");
  (function() {
    "use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Keyboard = void 0;
var _Bindable = require("../base/Bindable");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var Keyboard = /*#__PURE__*/function () {
  function Keyboard() {
    _classCallCheck(this, Keyboard);
    this.maxDecay = 120;
    this.comboTime = 500;
    this.listening = false;
    this.focusElement = document.body;
    this[_Bindable.Bindable.NoGetters] = true;
    Object.defineProperty(this, 'combo', {
      value: _Bindable.Bindable.make([])
    });
    Object.defineProperty(this, 'whichs', {
      value: _Bindable.Bindable.make({})
    });
    Object.defineProperty(this, 'codes', {
      value: _Bindable.Bindable.make({})
    });
    Object.defineProperty(this, 'keys', {
      value: _Bindable.Bindable.make({})
    });
    Object.defineProperty(this, 'pressedWhich', {
      value: _Bindable.Bindable.make({})
    });
    Object.defineProperty(this, 'pressedCode', {
      value: _Bindable.Bindable.make({})
    });
    Object.defineProperty(this, 'pressedKey', {
      value: _Bindable.Bindable.make({})
    });
    Object.defineProperty(this, 'releasedWhich', {
      value: _Bindable.Bindable.make({})
    });
    Object.defineProperty(this, 'releasedCode', {
      value: _Bindable.Bindable.make({})
    });
    Object.defineProperty(this, 'releasedKey', {
      value: _Bindable.Bindable.make({})
    });
    Object.defineProperty(this, 'keyRefs', {
      value: _Bindable.Bindable.make({})
    });
    document.addEventListener('keyup', event => {
      if (!this.listening) {
        return;
      }
      if (!(this.keys[event.key] > 0) && this.focusElement && document.activeElement !== this.focusElement && (!this.focusElement.contains(document.activeElement) || document.activeElement.matches('input,textarea'))) {
        return;
      }
      event.preventDefault();
      this.releasedWhich[event.which] = Date.now();
      this.releasedCode[event.code] = Date.now();
      this.releasedKey[event.key] = Date.now();
      this.whichs[event.which] = -1;
      this.codes[event.code] = -1;
      this.keys[event.key] = -1;
    });
    document.addEventListener('keydown', event => {
      if (!this.listening) {
        return;
      }
      if (this.focusElement && document.activeElement !== this.focusElement && (!this.focusElement.contains(document.activeElement) || document.activeElement.matches('input,textarea'))) {
        return;
      }
      event.preventDefault();
      if (event.repeat) {
        return;
      }
      this.combo.push(event.code);
      clearTimeout(this.comboTimer);
      this.comboTimer = setTimeout(() => this.combo.splice(0), this.comboTime);
      this.pressedWhich[event.which] = Date.now();
      this.pressedCode[event.code] = Date.now();
      this.pressedKey[event.key] = Date.now();
      if (this.keys[event.key] > 0) {
        return;
      }
      this.whichs[event.which] = 1;
      this.codes[event.code] = 1;
      this.keys[event.key] = 1;
    });
    var windowBlur = event => {
      for (var i in this.keys) {
        if (this.keys[i] < 0) {
          continue;
        }
        this.releasedKey[i] = Date.now();
        this.keys[i] = -1;
      }
      for (var _i in this.codes) {
        if (this.codes[_i] < 0) {
          continue;
        }
        this.releasedCode[_i] = Date.now();
        this.codes[_i] = -1;
      }
      for (var _i2 in this.whichs) {
        if (this.whichs[_i2] < 0) {
          continue;
        }
        this.releasedWhich[_i2] = Date.now();
        this.whichs[_i2] = -1;
      }
    };
    window.addEventListener('blur', windowBlur);
    window.addEventListener('visibilitychange', () => {
      if (document.visibilityState === 'visible') {
        return;
      }
      windowBlur();
    });
  }
  _createClass(Keyboard, [{
    key: "getKeyRef",
    value: function getKeyRef(keyCode) {
      var keyRef = this.keyRefs[keyCode] = this.keyRefs[keyCode] || _Bindable.Bindable.make({});
      return keyRef;
    }
  }, {
    key: "getKeyTime",
    value: function getKeyTime(key) {
      var released = this.releasedKey[key];
      var pressed = this.pressedKey[key];
      if (!pressed) {
        return 0;
      }
      if (!released || released < pressed) {
        return Date.now() - pressed;
      }
      return (Date.now() - released) * -1;
    }
  }, {
    key: "getCodeTime",
    value: function getCodeTime(code) {
      var released = this.releasedCode[code];
      var pressed = this.pressedCode[code];
      if (!pressed) {
        return 0;
      }
      if (!released || released < pressed) {
        return Date.now() - pressed;
      }
      return (Date.now() - released) * -1;
    }
  }, {
    key: "getWhichTime",
    value: function getWhichTime(code) {
      var released = this.releasedWhich[code];
      var pressed = this.pressedWhich[code];
      if (!pressed) {
        return 0;
      }
      if (!released || released < pressed) {
        return Date.now() - pressed;
      }
      return (Date.now() - released) * -1;
    }
  }, {
    key: "getKey",
    value: function getKey(key) {
      if (!this.keys[key]) {
        return 0;
      }
      return this.keys[key];
    }
  }, {
    key: "getKeyCode",
    value: function getKeyCode(code) {
      if (!this.codes[code]) {
        return 0;
      }
      return this.codes[code];
    }
  }, {
    key: "reset",
    value: function reset() {
      for (var i in this.keys) {
        delete this.keys[i];
      }
      for (var i in this.codes) {
        delete this.codes[i];
      }
      for (var i in this.whichs) {
        delete this.whichs[i];
      }
    }
  }, {
    key: "update",
    value: function update() {
      for (var i in this.keys) {
        if (this.keys[i] > 0) {
          this.keys[i]++;
        } else if (this.keys[i] > -this.maxDecay) {
          this.keys[i]--;
        } else {
          delete this.keys[i];
        }
      }
      for (var i in this.codes) {
        var released = this.releasedCode[i];
        var pressed = this.pressedCode[i];
        var keyRef = this.getKeyRef(i);
        if (this.codes[i] > 0) {
          keyRef.frames = this.codes[i]++;
          keyRef.time = pressed ? Date.now() - pressed : 0;
          keyRef.down = true;
          if (!released || released < pressed) {
            return;
          }
          return (Date.now() - released) * -1;
        } else if (this.codes[i] > -this.maxDecay) {
          keyRef.frames = this.codes[i]--;
          keyRef.time = released - Date.now();
          keyRef.down = false;
        } else {
          keyRef.frames = 0;
          keyRef.time = 0;
          keyRef.down = false;
          delete this.codes[i];
        }
      }
      for (var i in this.whichs) {
        if (this.whichs[i] > 0) {
          this.whichs[i]++;
        } else if (this.whichs[i] > -this.maxDecay) {
          this.whichs[i]--;
        } else {
          delete this.whichs[i];
        }
      }
    }
  }], [{
    key: "get",
    value: function get() {
      return this.instance = this.instance || _Bindable.Bindable.make(new this());
    }
  }]);
  return Keyboard;
}();
exports.Keyboard = Keyboard;
  })();
});

require.register("curvature/input/Sequence.js", function(exports, require, module) {
  require = __makeRelativeRequire(require, {}, "curvature");
  (function() {
    "use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Sequence = void 0;
var _Bindable = require("../base/Bindable");
var _Mixin = require("../base/Mixin");
var _EventTargetMixin = require("../mixin/EventTargetMixin");
var _Bindable$NoGetters;
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
_Bindable$NoGetters = _Bindable.Bindable.NoGetters;
var Sequence = /*#__PURE__*/function (_Mixin$with) {
  _inherits(Sequence, _Mixin$with);
  var _super = _createSuper(Sequence);
  function Sequence(_ref) {
    var _this;
    var callback = _ref.callback,
      keys = _ref.keys,
      timing = _ref.timing,
      gamepad = _ref.gamepad;
    _classCallCheck(this, Sequence);
    _this = _super.call(this);
    _defineProperty(_assertThisInitialized(_this), _Bindable$NoGetters, true);
    _defineProperty(_assertThisInitialized(_this), "lastTap", false);
    _defineProperty(_assertThisInitialized(_this), "recent", []);
    _defineProperty(_assertThisInitialized(_this), "callback", () => {});
    _defineProperty(_assertThisInitialized(_this), "timing", 500);
    _defineProperty(_assertThisInitialized(_this), "keys", '');
    var _ref2 = [callback, timing, keys, gamepad];
    _this.callback = _ref2[0];
    _this.timing = _ref2[1];
    _this.keys = _ref2[2];
    _this.gamepad = _ref2[3];
    return _this;
  }
  _createClass(Sequence, [{
    key: "check",
    value: function check(k) {
      var recent = this.recent;
      var now = Date.now();
      if (now + -this.lastTap > this.timing) {
        recent.splice(0);
      }
      recent.push({
        code: k,
        time: Date.now()
      });
      var current = recent.map(r => r.code).join(',');
      var konami = this.keys.join(',');
      this.lastTap = now;
      var matched = [];
      for (var i in recent) {
        var r = recent[i];
        var matchable = recent.slice(i);
        var chunk = matchable.map(r => r.code).join(',');
        if (chunk === konami.substr(0, chunk.length)) {
          matched.push(...matchable);
          this.dispatchEvent(new CustomEvent('advance', {
            detail: {
              matched: matched,
              recent: recent,
              keys: this.keys,
              length: matchable.length
            }
          }));
          break;
        }
      }
      if (!matched.length) {
        this.dispatchEvent(new CustomEvent('cancel', {
          detail: {
            matched: matched,
            recent: recent,
            keys: this.keys,
            length: matched.length
          }
        }));
        return;
      }
      if (konami === current.substr(-konami.length)) {
        this.dispatchEvent(new CustomEvent('complete', {
          detail: {
            matched: matched,
            recent: recent,
            keys: this.keys,
            length: matched.length
          }
        }));
      }
    }
  }]);
  return Sequence;
}(_Mixin.Mixin.with(_EventTargetMixin.EventTargetMixin));
exports.Sequence = Sequence;
  })();
});

require.register("curvature/mixin/EventTargetMixin.js", function(exports, require, module) {
  require = __makeRelativeRequire(require, {}, "curvature");
  (function() {
    "use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EventTargetMixin = void 0;
var _Mixin = require("../base/Mixin");
var _EventTargetMixin;
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
var EventTargetParent = Symbol('EventTargetParent');
var CallHandler = Symbol('CallHandler');
var Capture = Symbol('Capture');
var Bubble = Symbol('Bubble');
var Target = Symbol('Target');
var HandlersBubble = Symbol('HandlersBubble');
var HandlersCapture = Symbol('HandlersCapture');
var EventTargetMixin = (_EventTargetMixin = {}, _defineProperty(_EventTargetMixin, _Mixin.Mixin.Constructor, function () {
  this[HandlersCapture] = new Map();
  this[HandlersBubble] = new Map();
}), _defineProperty(_EventTargetMixin, "dispatchEvent", function dispatchEvent() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  var event = args[0];
  if (typeof event === 'string') {
    event = new CustomEvent(event);
    args[0] = event;
  }
  event.cvPath = event.cvPath || [];
  event.cvTarget = event.cvCurrentTarget = this;
  var result = this[Capture](...args);
  if (event.cancelable && (result === false || event.cancelBubble)) {
    return result;
  }
  var handlers = [];
  if (this[HandlersCapture].has(event.type)) {
    var handlerMap = this[HandlersCapture].get(event.type);
    var newHandlers = [...handlerMap];
    newHandlers.forEach(h => h.push(handlerMap));
    handlers.push(...newHandlers);
  }
  if (this[HandlersBubble].has(event.type)) {
    var _handlerMap = this[HandlersBubble].get(event.type);
    var _newHandlers = [..._handlerMap];
    _newHandlers.forEach(h => h.push(_handlerMap));
    handlers.push(..._newHandlers);
  }
  handlers.push([() => this[CallHandler](...args), {}, null]);
  for (var _ref3 of handlers) {
    var _ref2 = _slicedToArray(_ref3, 3);
    var handler = _ref2[0];
    var options = _ref2[1];
    var map = _ref2[2];
    if (options.once) {
      map.delete(handler);
    }
    result = handler(event);
    if (event.cancelable && result === false) {
      break;
    }
  }
  if (!event.cancelable || !event.cancelBubble && result !== false) {
    this[Bubble](...args);
  }
  if (!this[EventTargetParent]) {
    Object.freeze(event.cvPath);
  }
  return event.returnValue;
}), _defineProperty(_EventTargetMixin, "addEventListener", function addEventListener(type, callback) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  if (options === true) {
    options = {
      useCapture: true
    };
  }
  var handlers = HandlersBubble;
  if (options.useCapture) {
    handlers = HandlersCapture;
  }
  if (!this[handlers].has(type)) {
    this[handlers].set(type, new Map());
  }
  this[handlers].get(type).set(callback, options);
  if (options.signal) {
    options.signal.addEventListener('abort', event => this.removeEventListener(type, callback, options), {
      once: true
    });
  }
}), _defineProperty(_EventTargetMixin, "removeEventListener", function removeEventListener(type, callback) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  if (options === true) {
    options = {
      useCapture: true
    };
  }
  var handlers = HandlersBubble;
  if (options.useCapture) {
    handlers = HandlersCapture;
  }
  if (!this[handlers].has(type)) {
    return;
  }
  this[handlers].get(type).delete(callback);
}), _defineProperty(_EventTargetMixin, Capture, function () {
  var event = arguments.length <= 0 ? undefined : arguments[0];
  event.cvPath.push(this);
  if (!this[EventTargetParent]) {
    return;
  }
  var result = this[EventTargetParent][Capture](...arguments);
  if (event.cancelable && (result === false || event.cancelBubble)) {
    return;
  }
  if (!this[EventTargetParent][HandlersCapture].has(event.type)) {
    return;
  }
  event.cvCurrentTarget = this[EventTargetParent];
  var type = event.type;
  var handlers = this[EventTargetParent][HandlersCapture].get(type);
  for (var _ref6 of handlers) {
    var _ref5 = _slicedToArray(_ref6, 2);
    var handler = _ref5[0];
    var options = _ref5[1];
    if (options.once) {
      handlers.delete(handler);
    }
    result = handler(event);
    if (event.cancelable && (result === false || event.cancelBubble)) {
      break;
    }
  }
  return result;
}), _defineProperty(_EventTargetMixin, Bubble, function () {
  var event = arguments.length <= 0 ? undefined : arguments[0];
  if (!event.bubbles || !this[EventTargetParent] || event.cancelBubble) {
    return;
  }
  if (!this[EventTargetParent][HandlersBubble].has(event.type)) {
    return this[EventTargetParent][Bubble](...arguments);
  }
  var result;
  event.cvCurrentTarget = this[EventTargetParent];
  var type = event.type;
  var handlers = this[EventTargetParent][HandlersBubble].get(event.type);
  for (var _ref9 of handlers) {
    var _ref8 = _slicedToArray(_ref9, 2);
    var handler = _ref8[0];
    var options = _ref8[1];
    if (options.once) {
      handlers.delete(handler);
    }
    result = handler(event);
    if (event.cancelable && result === false) {
      return result;
    }
  }
  result = this[EventTargetParent][CallHandler](...arguments);
  if (event.cancelable && (result === false || event.cancelBubble)) {
    return result;
  }
  return this[EventTargetParent][Bubble](...arguments);
}), _defineProperty(_EventTargetMixin, CallHandler, function () {
  var event = arguments.length <= 0 ? undefined : arguments[0];
  if (event.defaultPrevented) {
    return;
  }
  var defaultHandler = "on".concat(event.type[0].toUpperCase() + event.type.slice(1));
  if (typeof this[defaultHandler] === 'function') {
    return this[defaultHandler](event);
  }
}), _EventTargetMixin);
exports.EventTargetMixin = EventTargetMixin;
Object.defineProperty(EventTargetMixin, 'Parent', {
  value: EventTargetParent
});
  })();
});

require.register("curvature/mixin/PromiseMixin.js", function(exports, require, module) {
  require = __makeRelativeRequire(require, {}, "curvature");
  (function() {
    "use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PromiseMixin = void 0;
var _Mixin = require("../base/Mixin");
var _PromiseMixin;
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var _Promise = Symbol('Promise');
var Accept = Symbol('Accept');
var Reject = Symbol('Reject');
var PromiseMixin = (_PromiseMixin = {}, _defineProperty(_PromiseMixin, _Mixin.Mixin.Constructor, function () {
  this[_Promise] = new Promise((accept, reject) => {
    this[Accept] = accept;
    this[Reject] = reject;
  });
}), _defineProperty(_PromiseMixin, "then", function then() {
  return this[_Promise].then(...arguments);
}), _defineProperty(_PromiseMixin, "catch", function _catch() {
  return this[_Promise].catch(...arguments);
}), _defineProperty(_PromiseMixin, "finally", function _finally() {
  return this[_Promise].finally(...arguments);
}), _PromiseMixin);
exports.PromiseMixin = PromiseMixin;
Object.defineProperty(PromiseMixin, 'Reject', {
  value: Reject
});
Object.defineProperty(PromiseMixin, 'Accept', {
  value: Accept
});
  })();
});

require.register("curvature/model/Database.js", function(exports, require, module) {
  require = __makeRelativeRequire(require, {}, "curvature");
  (function() {
    "use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Database = void 0;
var _Bindable = require("../base/Bindable");
var _Mixin = require("../base/Mixin");
var _EventTargetMixin = require("../mixin/EventTargetMixin");
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
var BeforeWrite = Symbol('BeforeWrite');
var AfterWrite = Symbol('AfterWrite');
var BeforeDelete = Symbol('BeforeDelete');
var AfterDelete = Symbol('AfterDelete');
var BeforeInsert = Symbol('BeforeInsert');
var AfterInsert = Symbol('AfterInsert');
var BeforeUpdate = Symbol('BeforeUpdate');
var AfterUpdate = Symbol('AfterUpdate');
var BeforeRead = Symbol('BeforeRead');
var AfterRead = Symbol('AfterRead');
var PrimaryKey = Symbol('PrimaryKey');
var Connection = Symbol('Connection');
var Instances = Symbol('Instances');
var HighWater = Symbol('HighWater');
var Metadata = Symbol('Metadata');
var Timers = Symbol('Timers');
var Target = Symbol('Target');
var Store = Symbol('Store');
var Fetch = Symbol('Each');
var Name = Symbol('Name');
var Bank = Symbol('Bank');
var Database = /*#__PURE__*/function (_Mixin$with) {
  _inherits(Database, _Mixin$with);
  var _super = _createSuper(Database);
  function Database(connection) {
    var _this;
    _classCallCheck(this, Database);
    _this = _super.call(this);
    Object.defineProperty(_assertThisInitialized(_this), Connection, {
      value: connection
    });
    Object.defineProperty(_assertThisInitialized(_this), Name, {
      value: connection.name
    });
    Object.defineProperty(_assertThisInitialized(_this), Timers, {
      value: {}
    });
    Object.defineProperty(_assertThisInitialized(_this), Metadata, {
      value: {}
    });
    Object.defineProperty(_assertThisInitialized(_this), Bank, {
      value: {}
    });
    return _this;
  }
  _createClass(Database, [{
    key: "select",
    value: function select(_ref) {
      var store = _ref.store,
        index = _ref.index,
        _ref$range = _ref.range,
        range = _ref$range === void 0 ? undefined : _ref$range,
        _ref$ranges = _ref.ranges,
        ranges = _ref$ranges === void 0 ? [] : _ref$ranges,
        _ref$direction = _ref.direction,
        direction = _ref$direction === void 0 ? 'next' : _ref$direction,
        _ref$limit = _ref.limit,
        limit = _ref$limit === void 0 ? 0 : _ref$limit,
        _ref$offset = _ref.offset,
        offset = _ref$offset === void 0 ? 0 : _ref$offset,
        _ref$type = _ref.type,
        type = _ref$type === void 0 ? false : _ref$type,
        _ref$origin = _ref.origin,
        origin = _ref$origin === void 0 ? undefined : _ref$origin,
        _ref$map = _ref.map,
        map = _ref$map === void 0 ? undefined : _ref$map;
      var transaction = this[Connection].transaction(store, "readonly");
      var storeObject = transaction.objectStore(store);
      var indexObject = index ? storeObject.index(index) : storeObject;
      if (range !== undefined && (!ranges || !ranges.length)) {
        ranges = [range];
      }
      var params = [type, indexObject, direction, ranges, limit, offset, origin, map];
      var existing = null;
      return {
        finally: c => (existing || (existing = this[Fetch](...params)(e => e))).finally(c),
        catch: c => (existing || (existing = this[Fetch](...params)(e => e))).catch(c),
        then: c => (existing || (existing = this[Fetch](...params)(e => e))).then(c),
        each: c => existing || (existing = this[Fetch](...params)(c)),
        one: c => existing || (existing = this[Fetch](...Object.assign(params, [,,,, 1]))(c))
      };
    }
  }, {
    key: "insert",
    value: function insert(storeName, records) {
      var origin = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var inserts = this.inserts(_defineProperty({}, storeName, records), origin);
      return inserts[0];
    }
  }, {
    key: "inserts",
    value: function inserts(storesToRecords) {
      var _this2 = this;
      var origin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var storeNames = Object.keys(storesToRecords);
      var transaction = this[Connection].transaction(storeNames, 'readwrite');
      var inserts = [];
      var _loop = function _loop() {
        _ref3 = _slicedToArray(_ref4, 2);
        var storeName = _ref3[0];
        var records = _ref3[1];
        var store = transaction.objectStore(storeName);
        var bank = _this2[Bank][storeName] = _this2[Bank][storeName] || {};
        var list = true;
        if (!Array.isArray(records)) {
          records = [records];
          list = false;
        }
        var results = records.map(record => new Promise((accept, reject) => {
          record = _Bindable.Bindable.make(record);
          var detail = {
            database: _this2,
            record: record,
            store: storeName,
            type: 'write',
            subType: 'insert',
            origin: origin
          };
          detail.key = Database.getPrimaryKey(record);
          var cancelable = true;
          var writeEvent = new CustomEvent('write', {
            cancelable: cancelable,
            detail: detail
          });
          var eventResult = _this2.dispatchEvent(writeEvent);
          if (!eventResult) {
            transaction.abort && transaction.abort();
            return;
          }
          var beforeWriteResult = record[Database.BeforeWrite] ? record[Database.BeforeWrite](detail) : null;
          var beforeInsertResult = record[Database.BeforeInsert] ? record[Database.BeforeInsert](detail) : null;
          var request = store.add(Object.assign({}, _Bindable.Bindable.shuck(record)));
          if (beforeWriteResult === false || beforeInsertResult === false) {
            transaction.abort && transaction.abort();
            return;
          }
          request.onerror = error => {
            _this2.dispatchEvent(new CustomEvent('writeError', {
              detail: detail
            }));
            transaction.abort && transaction.abort();
            reject(error);
          };
          request.onsuccess = event => {
            var pk = event.target.result;
            transaction.addEventListener('complete', event => {
              if (store.autoIncrement) {
                record.id = pk;
              }
              record[Database.AfterInsert] && record[Database.AfterInsert](detail);
              record[Database.AfterWrite] && record[Database.AfterWrite](detail);
              bank[pk] = record;
              record[PrimaryKey] = Symbol.for(pk);
              accept(record);
              if (!_this2[Metadata][storeName]) {
                _this2[Metadata][storeName] = _this2.getStoreMeta(storeName, 'store', {});
              }
              if (_this2[Metadata][storeName]) {
                var currentHighMark = _this2.checkHighWaterMark(storeName, record);
                var currentLowMark = _this2.checkLowWaterMark(storeName, record);
                var metadata = _this2[Metadata][storeName];
                var recordMark = record[metadata.highWater];
                if (origin.setHighWater && currentHighMark < recordMark) {
                  _this2.setHighWaterMark(storeName, record, origin, 'insert');
                }
                if (origin.setLowWater && currentLowMark > recordMark) {
                  _this2.setLowWaterMark(storeName, record, origin, 'insert');
                }
              }
            });
          };
        }));
        var finalResult;
        if (list) {
          finalResult = Promise.all(results);
        } else {
          finalResult = results[0];
        }
        inserts.push(finalResult);
      };
      for (var _ref4 of Object.entries(storesToRecords)) {
        var _ref3;
        _loop();
      }

      // Promise.all(inserts).then(() => transaction.commit && transaction.commit());

      return inserts;
    }
  }, {
    key: "update",
    value: function update(storeName, record) {
      var origin = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var updates = this.updates(_defineProperty({}, storeName, [record]), origin);
      return updates[0];
    }
  }, {
    key: "updates",
    value: function updates(storesToRecords) {
      var _this3 = this;
      var origin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var storeNames = Object.keys(storesToRecords);
      var transaction = this[Connection].transaction(storeNames, 'readwrite');
      var updates = [];
      var _loop2 = function _loop2() {
        _ref6 = _slicedToArray(_ref7, 2);
        var storeName = _ref6[0];
        var records = _ref6[1];
        var store = transaction.objectStore(storeName);
        var _loop3 = function _loop3(record) {
          if (!record[PrimaryKey]) {
            throw Error('Value provided is not a DB record!');
          }
          updates.push(new Promise((accept, reject) => {
            var detail = {
              database: _this3,
              key: Database.getPrimaryKey(record),
              record: record,
              store: storeName,
              type: 'write',
              subType: 'update',
              origin: origin
            };
            var cancelable = true;
            var writeEvent = new CustomEvent('write', {
              cancelable: cancelable,
              detail: detail
            });
            var eventResult = _this3.dispatchEvent(writeEvent);
            if (!eventResult) {
              transaction.abort && transaction.abort();
              return;
            }
            var beforeWriteResult = record[Database.BeforeWrite] ? record[Database.BeforeWrite](detail) : null;
            var beforeUpdateResult = record[Database.BeforeUpdate] ? record[Database.BeforeUpdate](detail) : null;
            if (beforeWriteResult === false || beforeUpdateResult === false) {
              transaction.abort && transaction.abort();
              return;
            }
            var requestA = store.delete(record.id);
            requestA.onerror = error => {
              _this3.dispatchEvent(new CustomEvent('writeError', {
                detail: detail
              }));
              reject(error);
            };
            requestA.onsuccess = event => {
              var requestB = store.put(Object.assign({}, _Bindable.Bindable.shuck(record)));
              requestB.onerror = error => {
                _this3.dispatchEvent(new CustomEvent('writeError', {
                  detail: detail
                }));
                reject(error);
              };
              requestB.onsuccess = event => {
                accept(writeEvent);
                transaction.oncomplete = event => {
                  record[Database.AfterInsert] && record[Database.AfterInsert](detail);
                  record[Database.AfterWrite] && record[Database.AfterWrite](detail);
                  if (!_this3[Metadata][storeName]) {
                    _this3[Metadata][storeName] = _this3.getStoreMeta(storeName, 'store', {});
                  }
                  if (_this3[Metadata][storeName]) {
                    var currentHighMark = _this3.checkHighWaterMark(storeName, record);
                    var currentLowMark = _this3.checkLowWaterMark(storeName, record);
                    var metadata = _this3[Metadata][storeName];
                    var recordMark = record[metadata.highWater];
                    if (origin.setHighWater && currentHighMark < recordMark) {
                      _this3.setHighWaterMark(storeName, record, origin, 'insert');
                    }
                    if (origin.setLowWater && currentLowMark > recordMark) {
                      _this3.setLowWaterMark(storeName, record, origin, 'insert');
                    }
                  }
                };
              };
            };
          }));
        };
        for (var record of records) {
          _loop3(record);
        }
      };
      for (var _ref7 of Object.entries(storesToRecords)) {
        var _ref6;
        _loop2();
      }
      Promise.all(updates).then(() => transaction.commit && transaction.commit());
      return updates;
    }
  }, {
    key: "delete",
    value: function _delete(storeName, record) {
      var origin = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var deletes = this.deletes(_defineProperty({}, storeName, [record]), origin);
      return deletes[0];
    }
  }, {
    key: "deletes",
    value: function deletes(storesToRecords) {
      var _this4 = this;
      var origin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var storeNames = Object.keys(storesToRecords);
      var transaction = this[Connection].transaction(storeNames, 'readwrite');
      var deletes = [];
      var _loop4 = function _loop4() {
        _ref9 = _slicedToArray(_ref10, 2);
        var storeName = _ref9[0];
        var records = _ref9[1];
        var store = transaction.objectStore(storeName);
        var _loop5 = function _loop5(record) {
          if (!record[PrimaryKey]) {
            throw Error('Value provided is not a DB record!');
          }
          deletes.push(new Promise((accept, reject) => {
            var detail = {
              database: _this4,
              record: record,
              key: Database.getPrimaryKey(record),
              store: storeName,
              type: 'write',
              subType: 'delete',
              origin: origin
            };
            var cancelable = true;
            var writeEvent = new CustomEvent('write', {
              cancelable: cancelable,
              detail: detail
            });
            var eventResult = _this4.dispatchEvent(writeEvent);
            if (!eventResult) {
              transaction.abort && transaction.abort();
              return;
            }
            var beforeDeleteResult = record[Database.BeforeDelete] ? record[Database.BeforeDelete](detail) : null;
            if (beforeDeleteResult === false) {
              transaction.abort && transaction.abort();
              return;
            }
            var request = store.delete(record.id);
            request.onerror = error => {
              detail.original = error;
              var deleteEvent = new CustomEvent('writeError', {
                detail: detail
              });
              _this4.dispatchEvent(deleteEvent);
              reject(error);
            };
            request.onsuccess = event => {
              accept(writeEvent);
              transaction.oncomplete = event => {
                record[PrimaryKey] = undefined;
                record[Database.AfterDelete] && record[Database.AfterDelete](detail);
                detail.original = event;
              };
            };
          }));
        };
        for (var record of records) {
          _loop5(record);
        }
      };
      for (var _ref10 of Object.entries(storesToRecords)) {
        var _ref9;
        _loop4();
      }
      Promise.all(deletes).then(() => transaction.commit && transaction.commit());
      return deletes;
    }
  }, {
    key: "clear",
    value: function clear(storeName) {
      return new Promise((accept, reject) => {
        var trans = this[Connection].transaction([storeName], 'readwrite');
        var store = trans.objectStore(storeName);
        var request = store.clear();
        var detail = {
          database: this[Name],
          store: storeName,
          type: 'write',
          subType: 'clear',
          origin: origin
        };
        request.onerror = error => {
          detail.original = error;
          var deleteEvent = new CustomEvent('writeError', {
            detail: detail
          });
          this.dispatchEvent(deleteEvent);
          reject(error);
        };
        request.onsuccess = event => {
          detail.original = event;
          var writeEvent = new CustomEvent('write', {
            detail: detail
          });
          this.dispatchEvent(writeEvent);
          trans.commit && trans.commit();
          accept(writeEvent);
        };
      });
    }
  }, {
    key: "listStores",
    value: function listStores() {
      return [...this[Connection].objectStoreNames];
    }
  }, {
    key: "listIndexes",
    value: function listIndexes(storeName) {
      var trans = this[Connection].transaction([storeName]);
      var store = trans.objectStore(storeName);
      return [...store.indexNames];
    }
  }, {
    key: Fetch,
    value: function value(type, index, direction, ranges, limit, offset, origin, map) {
      var processRange = (range, callback) => new Promise((accept, reject) => {
        if (range instanceof IDBKeyRange) {
          // NOOP
        } else if (!Array.isArray(range)) {
          if (typeof range !== 'undefined' && range !== null) {
            range = IDBKeyRange.only(range);
          }
        } else if (range.length === 0) {
          range = undefined;
        } else if (range.length === 1) {
          range = IDBKeyRange.only(range[0]);
        } else {
          if (range[0] === undefined && range[1] === undefined) {
            range = undefined;
          } else if (range[0] === undefined) {
            var _range$;
            range = IDBKeyRange.upperBound(range[1], (_range$ = range[2]) !== null && _range$ !== void 0 ? _range$ : true);
          } else if (range[1] === undefined) {
            var _range$2;
            range = IDBKeyRange.lowerBound(range[0], (_range$2 = range[2]) !== null && _range$2 !== void 0 ? _range$2 : false);
          } else {
            var _range$3, _range$4;
            range = IDBKeyRange.bound(range[0], range[1], (_range$3 = range[2]) !== null && _range$3 !== void 0 ? _range$3 : false, (_range$4 = range[3]) !== null && _range$4 !== void 0 ? _range$4 : true);
          }
        }
        var request = index.openCursor(range, direction);
        var i = 0;
        var resultHandler = event => {
          var cursor = event.target.result;
          if (!cursor) {
            return accept({
              record: null,
              result: null,
              index: i
            });
          }
          var source = cursor.source;
          var storeName = source.objectStore ? source.objectStore.name : index.name;
          this[Bank][storeName] = this[Bank][storeName] || {};
          var bank = this[Bank][storeName];
          var pk = cursor.primaryKey;
          var value = type ? type.from(cursor.value) : cursor.value;
          var bindableValue = _Bindable.Bindable.makeBindable(value);
          var detail = {
            database: this[Name],
            key: Database.getPrimaryKey(bindableValue),
            record: value,
            store: index.name,
            type: 'read',
            subType: 'select',
            origin: origin
          };
          var beforeReadResult = value[Database.BeforeRead] ? value[Database.BeforeRead](detail) : null;
          if (offset > i++ || beforeReadResult === false) {
            return cursor.continue();
          }
          if (bank[pk]) {
            Object.assign(bank[pk], value);
          } else {
            value[PrimaryKey] = Symbol.for(pk);
            bank[pk] = value;
          }
          detail.record = value;
          bank[pk][Database.AfterRead] && bank[pk][Database.AfterRead](detail);
          var cancelable = true;
          var eventResult = this.dispatchEvent(new CustomEvent('read', {
            detail: detail,
            cancelable: cancelable
          }));
          if (eventResult) {
            var record = type ? type.from(bank[pk]) : bank[pk];
            record[PrimaryKey] = Symbol.for(pk);
            var mapped = map ? map(record) : record;
            var result = callback ? callback(mapped, i) : mapped;
            if (limit && i - offset >= limit) {
              offset += limit;
              return accept({
                mapped: mapped,
                result: result,
                index: i
              });
            }
          }
          cursor.continue();
        };
        request.addEventListener('success', resultHandler);
      });
      var results = [];
      ranges = ranges && ranges.length ? ranges.slice() : [[]];
      var processResult = (result, callback) => {
        results.push(result);
        if (ranges.length) {
          return processRange(ranges.shift(), callback).then(result => processResult(result, callback));
        }
        if (results.length === 1) {
          return results[0];
        }
        return results;
      };
      return callback => processRange(ranges.shift(), callback).then(result => processResult(result, callback));
    }
  }, {
    key: "getObjectStores",
    value: function getObjectStores(storeName) {
      return [...this[Connection].objectStoreNames];
    }
  }, {
    key: "getStoreIndexes",
    value: function getStoreIndexes(storeName) {
      var transaction = this[Connection].transaction([storeName], 'readonly');
      var storeObject = transaction.objectStore(storeName);
      var indexes = [...storeObject.indexNames];
      transaction.abort();
      return indexes;
    }
  }, {
    key: "setStoreMeta",
    value: function setStoreMeta(storeName, key, value) {
      localStorage.setItem("::::cvdb::".concat(storeName, "::").concat(key), JSON.stringify(value));
    }
  }, {
    key: "getStoreMeta",
    value: function getStoreMeta(storeName, key) {
      var notFound = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var source = localStorage.getItem("::::cvdb::".concat(storeName, "::").concat(key));
      var value = source !== null ? JSON.parse(source) : notFound;
      if (value === null) {
        return notFound;
      }
      return value;
    }
  }, {
    key: "createObjectStore",
    value: function createObjectStore(storeName, options) {
      var store = this[Connection].createObjectStore(storeName, options);
      this.setStoreMeta(storeName, 'store', options);
      return store;
    }
  }, {
    key: "deleteObjectStore",
    value: function deleteObjectStore(storeName) {
      return this[Connection].deleteObjectStore(storeName);
    }
  }, {
    key: "checkHighWaterMark",
    value: function checkHighWaterMark(storeName, record) {
      var origin = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
      var currentMark = this.getStoreMeta(storeName, 'highWater', 0);
      return currentMark;
    }
  }, {
    key: "setHighWaterMark",
    value: function setHighWaterMark(storeName, record) {
      var origin = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
      var subType = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;
      var metadata = this[Metadata][storeName];
      var recordMark = record[metadata.highWater];
      var currentMark = this.getStoreMeta(storeName, 'highWater', 0);
      this.setStoreMeta(storeName, 'highWater', recordMark);
      this.dispatchEvent(new CustomEvent('highWaterMoved', {
        detail: {
          database: this[Name],
          record: record,
          store: storeName,
          type: 'highWaterMoved',
          subType: subType,
          origin: origin,
          oldValue: currentMark,
          value: recordMark
        }
      }));
    }
  }, {
    key: "checkLowWaterMark",
    value: function checkLowWaterMark(storeName, record) {
      var origin = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
      var currentMark = this.getStoreMeta(storeName, 'lowWater', Infinity);
      return currentMark;
    }
  }, {
    key: "setLowWaterMark",
    value: function setLowWaterMark(storeName, record) {
      var origin = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
      var subType = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;
      var metadata = this[Metadata][storeName];
      var recordMark = record[metadata.highWater];
      var currentMark = this.getStoreMeta(storeName, 'lowWater', null);
      this.setStoreMeta(storeName, 'lowWater', recordMark);
      this.dispatchEvent(new CustomEvent('lowWaterMoved', {
        detail: {
          database: this[Name],
          record: record,
          store: storeName,
          type: 'lowWaterMoved',
          subType: subType,
          origin: origin,
          oldValue: currentMark,
          value: recordMark
        }
      }));
    }
  }], [{
    key: "open",
    value: function open(dbName) {
      var version = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      if (this[Instances][dbName]) {
        return this[Instances][dbName];
      }
      return this[Instances][dbName] = new Promise((accept, reject) => {
        var request = indexedDB.open(dbName, version);
        request.onerror = error => {
          Database.dispatchEvent(new CustomEvent('error', {
            detail: {
              database: this[Name],
              error: error,
              store: undefined,
              type: 'read',
              subType: 'select'
            }
          }));
          reject(error);
        };
        request.onsuccess = event => {
          var instance = new this(event.target.result);
          accept(instance);
        };
        request.onupgradeneeded = event => {
          var connection = event.target.result;
          connection.addEventListener('error', error => console.error(error));
          var instance = new this(connection);
          for (var v = event.oldVersion + 1; v <= version; v += 1) {
            instance['_version_' + v](connection, instance, event);
          }
        };
      });
    }
  }, {
    key: "getPrimaryKey",
    value: function getPrimaryKey(record) {
      return record[PrimaryKey] ? record[PrimaryKey] : null;
    }
  }, {
    key: "destroyDatabase",
    value: function destroyDatabase() {
      return new Promise((accept, reject) => {
        var request = indexedDB.delete(dbName);
        request.onerror = error => {
          Database.dispatchEvent(new CustomEvent('error', {
            detail: {
              database: dbName,
              error: error,
              type: 'destroy'
            }
          }));
          reject(error);
        };
        request.onsuccess = event => {
          delete this[Instances][dbName];
          accept(dbName);
        };
      });
    }
  }]);
  return Database;
}(_Mixin.Mixin.with(_EventTargetMixin.EventTargetMixin));
exports.Database = Database;
Object.defineProperty(Database, Instances, {
  value: []
});
Object.defineProperty(Database, 'BeforeDelete', {
  value: BeforeDelete
});
Object.defineProperty(Database, 'AfterDelete', {
  value: AfterDelete
});
Object.defineProperty(Database, 'BeforeWrite', {
  value: BeforeWrite
});
Object.defineProperty(Database, 'AfterWrite', {
  value: AfterWrite
});
Object.defineProperty(Database, 'BeforeInsert', {
  value: BeforeInsert
});
Object.defineProperty(Database, 'AfterInsert', {
  value: AfterInsert
});
Object.defineProperty(Database, 'BeforeUpdate', {
  value: BeforeUpdate
});
Object.defineProperty(Database, 'AfterUpdate', {
  value: AfterUpdate
});
Object.defineProperty(Database, 'BeforeRead', {
  value: BeforeRead
});
Object.defineProperty(Database, 'AfterRead', {
  value: AfterRead
});
Object.defineProperty(Database, 'PKSymbol', {
  value: PrimaryKey
});
Object.defineProperty(Database, 'PrimaryKey', {
  value: PrimaryKey
});
try {
  Object.defineProperty(Database, Target, {
    value: new EventTarget()
  });
} catch (error) {
  Object.defineProperty(Database, Target, {
    value: document.createDocumentFragment()
  });
}
var _loop6 = function _loop6(method) {
  Object.defineProperty(Database, method, {
    value: function value() {
      return Database[Target][method](...arguments);
    }
  });
};
for (var method of ['addEventListener', 'removeEventListener', 'dispatchEvent']) {
  _loop6(method);
}
  })();
});

require.register("curvature/model/Model.js", function(exports, require, module) {
  require = __makeRelativeRequire(require, {}, "curvature");
  (function() {
    "use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Model = void 0;
var _Cache = require("../base/Cache");
var _Bindable = require("../base/Bindable");
var _Database = require("./Database");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var Changed = Symbol('Changed');
var Deleted = Symbol('Deleted');
var Saved = Symbol('Saved');
var Keys = Symbol('Keys');
var Model = /*#__PURE__*/function () {
  function Model() {
    _classCallCheck(this, Model);
    _defineProperty(this, "id", void 0);
    _defineProperty(this, "class", void 0);
    Object.defineProperty(this, Changed, {
      value: _Bindable.Bindable.make({})
    });
    Object.defineProperty(this, Deleted, {
      writable: true,
      value: false
    });
    Object.defineProperty(this, Saved, {
      writable: true,
      value: false
    });
    Object.defineProperty(this, Keys, {
      writable: true,
      value: new Set()
    });
    return _Bindable.Bindable.make(this);
  }
  _createClass(Model, [{
    key: "consume",
    value: function consume(skeleton) {
      var override = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var keyProps = Model.keyProps;
      var setProp = (property, value) => {
        if (value && _typeof(value) === 'object' && value.constructor.keyProps) {
          var subKeyProps = value.constructor.keyProps;
          var propCacheKey = subKeyProps.map(prop => value[prop]).join('::');
          var bucket = 'models-by-type-and-publicId';
          var propCached = _Cache.Cache.load(propCacheKey, false, bucket);
          if (propCached) {
            propCached.consume(value);
            value = propCached;
          }
        }
        if (!override && this[Changed][property]) {
          return;
        }
        this[property] = value;
      };
      if (_Database.Database.PKSymbol in skeleton) {
        setProp(_Database.Database.PKSymbol, skeleton[_Database.Database.PKSymbol]);
      }
      this[Keys] = new Set([...this[Keys], ...Object.keys(this), ...Object.keys(skeleton)]);
      for (var property of this[Keys]) {
        if (!override && this[Changed][property]) {
          continue;
        }
        if (keyProps.includes(property)) {
          continue;
        }
        if (property in skeleton) {
          setProp(property, skeleton[property]);
        }
      }
    }
  }, {
    key: "changed",
    value: function changed() {
      this[Saved] = false;
    }
  }, {
    key: "markDeleted",
    value: function markDeleted() {
      for (var property in this[Changed]) {
        this[Changed][property] = false;
      }
      this[Deleted] = true;
      this[Saved] = false;
    }
  }, {
    key: "markStored",
    value: function markStored() {
      for (var property in this) {
        this[Changed][property] = false;
      }
      this[Deleted] = false;
      this[Saved] = true;
    }
  }, {
    key: "isSaved",
    value: function isSaved() {
      return this[Saved];
    }
  }], [{
    key: "keyProps",
    get: function get() {
      return ['id', 'class'];
    }
  }, {
    key: "from",
    value: function from(skeleton) {
      var isSaved = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var keyProps = this.keyProps;
      var cacheProps = keyProps.map(prop => skeleton[prop]);
      cacheProps.unshift(this.name);
      var cacheKey = cacheProps.join('::');
      var bucket = 'models-by-type-and-publicId';
      var cached = _Cache.Cache.load(cacheKey, false, bucket);
      var instance = cached ? cached : new this();
      for (var keyProp of keyProps) {
        var _ref, _instance$keyProp;
        instance[keyProp] = (_ref = (_instance$keyProp = instance[keyProp]) !== null && _instance$keyProp !== void 0 ? _instance$keyProp : skeleton[keyProp]) !== null && _ref !== void 0 ? _ref : null;
      }
      instance.consume(skeleton);
      if (!cached) {
        _Cache.Cache.store(cacheKey, instance, 0, bucket);
        var changed = false;
        instance.bindTo((v, k, t, d) => {
          if (_typeof(k) === 'symbol') {
            return;
          }
          if (v === t[k]) {
            return;
          }
          instance[Changed][k] = changed;
          instance[Saved] = !!(changed ? false : instance[Saved]);
        });
        if (Object.keys(instance[Changed]).length === 0) {
          instance[Saved] = isSaved;
        }
        changed = true;
      }
      return instance;
    }
  }]);
  return Model;
}();
exports.Model = Model;
Object.defineProperty(Model, 'Changed', {
  value: Changed
});
Object.defineProperty(Model, 'Deleted', {
  value: Deleted
});
Object.defineProperty(Model, 'Saved', {
  value: Saved
});
  })();
});

require.register("curvature/net/Elicit.js", function(exports, require, module) {
  require = __makeRelativeRequire(require, {}, "curvature");
  (function() {
    "use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Elicit = void 0;
var _Mixin = require("curvature/base/Mixin");
var _EventTargetMixin = require("curvature/mixin/EventTargetMixin");
var _PromiseMixin = require("curvature/mixin/PromiseMixin");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var IterateDownload = Symbol('IterateDownload');
var Retry = Symbol('Retry');
var HandleFirstByte = Symbol('HandleFirstByte');
var HandleProgress = Symbol('HandleProgress');
var HandleComplete = Symbol('HandleComplete');
var HandleHeaders = Symbol('HandleHeaders');
var HandleClose = Symbol('HandleClose');
var HandleError = Symbol('HandleError');
var HandleOpen = Symbol('HandleOpen');
var HandleFail = Symbol('HandleFail');
var FetchDeferrer = Symbol('FetchDeferrer');
var LastChunkSize = Symbol('LastChunkSize');
var LastChunkTime = Symbol('LastChunkTime');
var Options = Symbol('Options');
var Fetch = Symbol('Fetch');
var Type = Symbol('Type');
var Url = Symbol('Url');
var RetriesLeft = Symbol('RetriesLeft');
var TimeoutLeft = Symbol('TimeoutLeft');
var Timeout = Symbol('Timeout');
var Timer = Symbol('Timer');
var Canceller = Symbol('Canecller');
var Cancelled = Symbol('Caneclled');
var Paused = Symbol('Paused');
var Received = Symbol('Received');
var Length = Symbol('Length');
var Opened = Symbol('Opened');
var Closed = Symbol('Closed');
var Start = Symbol('Start');
var First = Symbol('First');
var End = Symbol('End');
var Elicit = /*#__PURE__*/function (_Mixin$with) {
  _inherits(Elicit, _Mixin$with);
  var _super = _createSuper(Elicit);
  function Elicit(url) {
    var _this2;
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    _classCallCheck(this, Elicit);
    _this2 = _super.call(this);
    _this2[RetriesLeft] = options.retries || 5;
    _this2[Timeout] = options.timeout || 4500;
    _this2[TimeoutLeft] = options.maxTimeout || _this2[Timeout] * _this2[RetriesLeft];
    _this2[FetchDeferrer] = null;
    _this2[LastChunkTime] = 0;
    _this2[LastChunkSize] = 0;
    _this2[Cancelled] = false;
    _this2[Received] = 0;
    _this2[Paused] = false;
    _this2[Closed] = 0;
    _this2[Options] = Object.assign({}, options);
    _this2[Url] = url;
    if (!options.defer) {
      _this2.open();
    } else {
      _this2[Fetch] = new Promise(accept => _this2[FetchDeferrer] = accept);
    }
    return _this2;
  }
  _createClass(Elicit, [{
    key: "open",
    value: function open() {
      if (this[Opened] && !this[Closed]) {
        return;
      }
      if (!this[Start]) {
        this[Start] = Date.now();
      }
      this[Canceller] = new AbortController();
      this[Options].signal = this[Canceller].signal;
      this[Opened] = Date.now();
      this[Closed] = 0;
      this[First] = 0;
      this[Fetch] = fetch(this[Url], this[Options]).then(response => this[HandleOpen](response)).catch(error => this[HandleError](error));
      var onTimeout = () => {
        if (!this[First]) {
          this[Canceller].abort();
          this[HandleClose]();
          this[TimeoutLeft] = Math.max(0, this[TimeoutLeft] - this[Timeout]);
          if (this[TimeoutLeft]) {
            return;
          }
          this[HandleFail](new Error('Timed out.'));
        }
      };
      this[Timer] = setTimeout(onTimeout, this[Timeout]);
    }
  }, {
    key: "headers",
    value: function headers() {
      return this[Fetch].then(_ref => {
        var response = _ref.response,
          stream = _ref.stream;
        return response.headers;
      });
    }
  }, {
    key: "json",
    value: function json() {
      return this[Fetch].then(_ref2 => {
        var response = _ref2.response,
          stream = _ref2.stream;
        var wrapped = new Response(stream, {
          headers: {
            'Content-Type': 'application/json'
          }
        });
        return wrapped.json();
      });
    }
  }, {
    key: "text",
    value: function text() {
      return this[Fetch].then(_ref3 => {
        var response = _ref3.response,
          stream = _ref3.stream;
        var wrapped = new Response(stream, {
          headers: {
            'Content-Type': this.type
          }
        });
        return wrapped.text();
      });
    }
  }, {
    key: "css",
    value: function css() {
      return this.text().then(css => {
        var sheet = new CSSStyleSheet();
        sheet.replace(css);
        return sheet;
      });
    }
  }, {
    key: "blob",
    value: function blob() {
      return this[Fetch].then(_ref4 => {
        var response = _ref4.response,
          stream = _ref4.stream;
        var wrapped = new Response(stream, {
          headers: {
            'Content-Type': response.headers.get('Content-Type')
          }
        });
        return wrapped.blob();
      });
    }
  }, {
    key: "objectUrl",
    value: function objectUrl() {
      return this.blob().then(blob => URL.createObjectURL(blob));
    }
  }, {
    key: "dataUri",
    value: function dataUri() {
      return this.blob().then(blob => new Promise((accept, reject) => {
        var reader = new FileReader();
        reader.onload = event => accept(reader.result);
        reader.onerror = event => reject(reader.error);
        reader.onabort = event => reject(new Error("Read aborted"));
        reader.readAsDataURL(blob);
      }));
    }
  }, {
    key: "buffer",
    value: function buffer() {
      return this[Fetch].then(_ref5 => {
        var response = _ref5.response,
          stream = _ref5.stream;
        var wrapped = new Response(stream, {
          headers: {
            'Content-Type': response.headers.get('Content-Type')
          }
        });
        return wrapped.arrayBuffer();
      });
    }
  }, {
    key: "bytes",
    value: function bytes() {
      return this.buffer().then(buffer => new Uint8Array(buffer));
    }
  }, {
    key: "cancel",
    value: function cancel() {
      if (!this.emitCancelEvent()) {
        return;
      }
      this[Canceller].abort();
      this[Cancelled] = true;
      this.emitCancelledEvent();
    }
  }, {
    key: "pause",
    value: function pause() {
      if (this[End] || this[Paused] || this[Closed]) {
        return;
      }
      if (!this.emitPauseEvent()) {
        return;
      }
      this[Paused] = true;
      this.emitPausedEvent();
    }
  }, {
    key: "unpause",
    value: function unpause() {
      if (this[End] || !this[Paused]) {
        return;
      }
      if (!this.emitUnpauseEvent()) {
        return;
      }
      this[Paused] = false;
      this.emitUnpausedEvent();
    }
  }, {
    key: "done",
    get: function get() {
      return !!this[End];
    }
  }, {
    key: "type",
    get: function get() {
      return this[Type];
    }
  }, {
    key: "totalTime",
    get: function get() {
      if (!this[End]) {
        return Date.now() - this[Start];
      }
      return this[End] - this[Start];
    }
  }, {
    key: "waitTime",
    get: function get() {
      if (!this[First]) {
        return Date.now() - this[Opened];
      }
      return this[First] - this[Opened];
    }
  }, {
    key: "loadTime",
    get: function get() {
      if (!this[Opened]) {
        return 0;
      }
      if (!this[Closed]) {
        return Date.now() - this[First];
      }
      return this[Closed] - this[First];
    }
  }, {
    key: "speed",
    get: function get() {
      if (!this[Opened]) {
        return 0;
      }
      var time;
      if (this[End]) {
        time = this[End] - this[LastChunkTime];
      } else {
        time = Date.now() - this[LastChunkTime];
      }
      if (!time) {
        time = 0.01;
      }
      return this[LastChunkSize] / time;
    }
  }, {
    key: "received",
    get: function get() {
      return this[Received];
    }
  }, {
    key: "length",
    get: function get() {
      return this[Length];
    }
  }, {
    key: "isPaused",
    get: function get() {
      return this[Paused];
    }
  }, {
    key: IterateDownload,
    value: function value(reader, controller, length) {
      this[HandleProgress](length, 0, null);
      var lastTime = Date.now();
      var lastSize = 1;
      var handleChunk = _ref6 => {
        var done = _ref6.done,
          value = _ref6.value;
        if (done) {
          controller.close();
          return this[HandleComplete]();
        }
        controller.enqueue(value);
        this[Received] += value.length;
        if (!this[First]) {
          this[HandleFirstByte](value);
        }
        this[HandleProgress](length, this[Received], value);
        this[LastChunkTime] = lastTime;
        this[LastChunkSize] = lastSize;
        lastTime = Date.now();
        lastSize = value.length;
        return iterate();
      };
      var iterate = () => {
        if (this[Cancelled]) {
          return reader.cancel();
        }
        if (this[Paused]) {
          return new Promise(accept => {
            setTimeout(() => accept(iterate()), 100);
          });
        }
        return reader.read().then(chunk => handleChunk(chunk)).catch(error => this[HandleError](error));
      };
      return iterate();
    }
  }, {
    key: Retry,
    value: function value() {
      if (!this.emitRetryEvent()) {
        return;
      }
      if (this[RetriesLeft] <= 0) {
        return;
      }
      this[Canceller].abort();
      this[HandleClose]();
      this[Received] = 0;
      this[RetriesLeft]--;
      return this.open();
    }
  }, {
    key: HandleOpen,
    value: function value(response) {
      var reader = response.body.getReader();
      var length = this[Length] || Number(response.headers.get('Content-Length'));
      var type = this[type] || response.headers.get('Content-Type');
      this[Length] = length;
      this[Type] = type;
      this[HandleHeaders](response.headers);
      if (this[FetchDeferrer]) {
        this[FetchDeferrer](this[Fetch]);
      }
      var _this = this;
      var stream = new ReadableStream({
        start: function start(controller) {
          _this[IterateDownload](reader, controller, length);
        }
      });
      return {
        response: response,
        stream: stream
      };
    }
  }, {
    key: HandleClose,
    value: function value() {
      this[Closed] = Date.now();
      this.emitCloseEvent();
    }
  }, {
    key: HandleHeaders,
    value: function value(headers) {
      this.emitHeadersEvent(headers);
    }
  }, {
    key: HandleProgress,
    value: function value(length, received, _value) {
      this.emitProgressEvent(length, received, _value);
    }
  }, {
    key: HandleComplete,
    value: function value() {
      this[End] = Date.now();
      this[HandleClose]();
      this.emitCompleteEvent();
      this[_PromiseMixin.PromiseMixin.Accept]();
    }
  }, {
    key: HandleError,
    value: function value(error) {
      console.warn("[".concat(error.constructor.name, "] ").concat(error.code, ": ").concat(error.message), error);
      if (!this.emitErrorEvent(error)) {
        return this[Retry]();
      }
      return this[HandleFail](error);
    }
  }, {
    key: HandleFail,
    value: function value(error) {
      this[End] = Date.now();
      this[HandleClose]();
      this.emitFailEvent(error);
      return this[_PromiseMixin.PromiseMixin.Reject](error);
    }
  }, {
    key: HandleFirstByte,
    value: function value(received) {
      clearInterval(this[Timer]);
      this[First] = Date.now();
      this.emitFirstByteEvent(received);
    }
  }, {
    key: "emitProgressEvent",
    value: function emitProgressEvent(length, received, value) {
      var done = length ? received / length : 0;
      var totalTime = this.totalTime;
      var loadTime = this.loadTime;
      var waitTime = this.waitTime;
      var speed = this.speed;
      return this.dispatchEvent(new CustomEvent('progress', {
        detail: {
          length: length,
          received: received,
          done: done,
          speed: speed,
          loadTime: loadTime,
          waitTime: waitTime,
          totalTime: totalTime,
          value: value
        }
      }));
    }
  }, {
    key: "emitOpenEvent",
    value: function emitOpenEvent() {
      return this.dispatchEvent(new CustomEvent('open'));
    }
  }, {
    key: "emitCloseEvent",
    value: function emitCloseEvent() {
      return this.dispatchEvent(new CustomEvent('close'));
    }
  }, {
    key: "emitFirstByteEvent",
    value: function emitFirstByteEvent(received) {
      return this.dispatchEvent(new CustomEvent('firstByte', {
        detail: {
          received: received
        }
      }));
    }
  }, {
    key: "emitHeadersEvent",
    value: function emitHeadersEvent(headers) {
      return this.dispatchEvent(new CustomEvent('headers', {
        detail: {
          headers: headers
        }
      }));
    }
  }, {
    key: "emitCompleteEvent",
    value: function emitCompleteEvent() {
      return this.dispatchEvent(new CustomEvent('complete'));
    }
  }, {
    key: "emitErrorEvent",
    value: function emitErrorEvent() {
      return this.dispatchEvent(new CustomEvent('error', {
        cancelable: this[RetriesLeft] > 0
      }));
    }
  }, {
    key: "emitRetryEvent",
    value: function emitRetryEvent() {
      return this.dispatchEvent(new CustomEvent('retry', {
        cancelable: true
      }));
    }
  }, {
    key: "emitFailEvent",
    value: function emitFailEvent() {
      return this.dispatchEvent(new CustomEvent('fail'));
    }
  }, {
    key: "emitPauseEvent",
    value: function emitPauseEvent() {
      return this.dispatchEvent(new CustomEvent('pause', {
        cancelable: true
      }));
    }
  }, {
    key: "emitPausedEvent",
    value: function emitPausedEvent() {
      this.dispatchEvent(new CustomEvent('paused'));
    }
  }, {
    key: "emitUnpauseEvent",
    value: function emitUnpauseEvent() {
      return this.dispatchEvent(new CustomEvent('unpause', {
        cancelable: true
      }));
    }
  }, {
    key: "emitUnpausedEvent",
    value: function emitUnpausedEvent() {
      this.dispatchEvent(new CustomEvent('unpaused'));
    }
  }, {
    key: "emitCancelEvent",
    value: function emitCancelEvent() {
      return this.dispatchEvent(new CustomEvent('cancel', {
        cancelable: true
      }));
    }
  }, {
    key: "emitCancelledEvent",
    value: function emitCancelledEvent() {
      return this.dispatchEvent(new CustomEvent('cancelled'));
    }
  }], [{
    key: "pool",
    value: function pool(elicit) {
      var maxPool = 5;
      elicit.finally(() => {
        this.running.delete(elicit);
        if (!this.backlog.length) {
          return;
        }
        var next = this.backlog.shift();
        this.running.add(next);
        next.open();
      });
      if (this.running.size < maxPool) {
        this.running.add(elicit);
        elicit.open();
      } else {
        this.backlog.push(elicit);
      }
    }
  }]);
  return Elicit;
}(_Mixin.Mixin.with(_EventTargetMixin.EventTargetMixin, _PromiseMixin.PromiseMixin)); // elicit.addEventListener('open', event => console.log(event));
// elicit.addEventListener('close', event => console.log(event));
// elicit.addEventListener('firstByte', event => console.log(event));
// elicit.addEventListener('headers', event => console.log(event));
// elicit.addEventListener('complete', event => console.log(event));
// elicit.addEventListener('error', event => console.log(event));
// elicit.addEventListener('fail', event => console.log(event));
// elicit.addEventListener('pause', event => console.log(event));
// elicit.addEventListener('paused', event => console.log(event));
// elicit.addEventListener('unpause', event => console.log(event));
// elicit.addEventListener('unpaused', event => console.log(event));
// elicit.addEventListener('cancelled', event => console.log(event));
// elicit.addEventListener('cancel', event => console.log(event));
exports.Elicit = Elicit;
_defineProperty(Elicit, "backlog", []);
_defineProperty(Elicit, "running", new Set());
  })();
});

require.register("matrix-api/Matrix.js", function(exports, require, module) {
  require = __makeRelativeRequire(require, {}, "matrix-api");
  (function() {
    "use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Matrix = void 0;

var _Uuid = require("curvature/base/Uuid");

var _Mixin = require("curvature/base/Mixin");

var _EventTargetMixin = require("curvature/mixin/EventTargetMixin");

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var Matrix = function (_Mixin$with) {
  _inherits(Matrix, _Mixin$with);

  var _super = _createSuper(Matrix);

  function Matrix(baseUrl) {
    var _options$storage, _options$interval;

    var _this;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Matrix);

    _this = _super.call(this);

    _defineProperty(_assertThisInitialized(_this), "ssoUuid", String(new _Uuid.Uuid()));

    _defineProperty(_assertThisInitialized(_this), "isLoggedIn", false);

    _defineProperty(_assertThisInitialized(_this), "loggingIn", null);

    _this.baseUrl = baseUrl || 'https://matrix.org/_matrix';
    _this.clientUrl = "".concat(_this.baseUrl, "/client/v3");
    _this.mediaUrl = "".concat(_this.baseUrl, "/media/v3");
    _this.profileCache = new Map();
    _this.mediaCache = new Map();
    _this.storage = (_options$storage = options.storage) !== null && _options$storage !== void 0 ? _options$storage : globalThis.sessionStorage;
    _this.interval = (_options$interval = options.interval) !== null && _options$interval !== void 0 ? _options$interval : false;
    return _this;
  }

  _createClass(Matrix, [{
    key: "isLoggedIn",
    get: function get() {
      if (this.isLoggedIn) {
        this.dispatchEvent(new CustomEvent('logged-in'));
      }

      var tokenJson = this.storage.getItem('matrix:access-token') || 'false';
      var token = JSON.parse(tokenJson);
      return this.storage.getItem('matrix:access-token');
    }
  }, {
    key: "initSso",
    value: function initSso(redirectUri) {
      var _this2 = this;

      var windowRef = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : window;

      if (this.storage.getItem('matrix:access-token')) {
        this.isLoggedIn = true;
        this.dispatchEvent(new CustomEvent('logged-in'));
        return;
      }

      var query = new URLSearchParams({
        redirectUrl: redirectUri
      });
      var path = "login/sso/redirect?".concat(query);
      var width = 400;
      var height = 600;
      var left = window.screenX + window.outerWidth / 2 + width / 2;
      var top = window.screenY + window.outerHeight / 2 - height / 2;
      var options = "width=".concat(width, ",height=").concat(height, ",screenX=").concat(left, ",screenY=").concat(top);
      var ssoPopup = windowRef.open("".concat(this.clientUrl, "/").concat(path), "matrix-login-".concat(this.ssoUuid), options);

      var ssoListener = function ssoListener(event) {
        if (event.origin !== location.origin) {
          return;
        }

        if (event.source === window) {
          return;
        }

        if (typeof event.data !== 'string') {
          return;
        }

        var request = JSON.parse(event.data);

        if (request.type !== 's.sso.complete') {
          return;
        }

        _this2.storage.setItem('matrix:access-token', JSON.stringify(request.data));

        _this2.isLoggedIn = true;

        _this2.dispatchEvent(new CustomEvent('logged-in'));

        windowRef.removeEventListener('message', ssoListener);
      };

      windowRef.addEventListener('message', ssoListener);
    }
  }, {
    key: "completeSso",
    value: function completeSso(loginToken) {
      var path = 'login';
      var body = {
        type: "m.login.token",
        token: loginToken,
        txn_id: (1 / Math.random()).toString(36)
      };
      fetch("".concat(this.clientUrl, "/").concat(path), {
        method: 'POST',
        body: JSON.stringify(body)
      }).then(function (response) {
        return response.json();
      }).then(function (response) {
        window.opener.postMessage(JSON.stringify({
          type: 's.sso.complete',
          data: response
        }), location.origin);
        window.close();
      });
    }
  }, {
    key: "logIn",
    value: function logIn(redirectUri) {
      var _this3 = this;

      var windowRef = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : window;

      if (!this.loggingIn) {
        this.loggingIn = new Promise(function (accept) {
          _this3.loggingIn = null;

          _this3.addEventListener('logged-in', function (event) {
            accept(event);
          }, {
            once: true
          });
        });
      }

      this.initSso(redirectUri, windowRef);
      return this.loggingIn;
    }
  }, {
    key: "logOut",
    value: function logOut() {
      this.storage.removeItem('matrix:access-token');
      this.isLoggedIn = false;
      this.loggingIn = null;
      this.dispatchEvent(new CustomEvent('logged-out'));
    }
  }, {
    key: "getGuestToken",
    value: function getGuestToken() {
      var _this4 = this;

      var tokenJson = this.storage.getItem('matrix:access-token') || 'false';
      var token = JSON.parse(tokenJson);

      if (token && token.isGuest) {
        return Promise.resolve(token);
      }

      var query = new URLSearchParams({
        kind: 'guest'
      });
      var getToken = fetch("".concat(this.clientUrl, "/register?").concat(query), {
        method: 'POST',
        body: '{}'
      }).then(function (response) {
        return response.json();
      });
      getToken.then(function (token) {
        token.isGuest = true;
        _this4.isLoggedIn = true;

        _this4.storage.setItem('matrix:access-token', JSON.stringify(token));
      });
      return getToken;
    }
  }, {
    key: "getToken",
    value: function getToken() {
      var tokenJson = this.storage.getItem('matrix:access-token') || 'false';
      var token = JSON.parse(tokenJson);

      if (token) {
        return Promise.resolve(token);
      }

      return matrix.getGuestToken();
    }
  }, {
    key: "listenForServerEvents",
    value: function listenForServerEvents() {
      var _this5 = this;

      var token = JSON.parse(this.storage.getItem('matrix:access-token') || 'false');

      if (!token) {
        return Promise.reject('No access token found.');
      }

      var query = new URLSearchParams({
        access_token: token.access_token
      });
      var listener = "".concat(this.clientUrl, "/events?").concat(query);
      fetch(listener).then(function (response) {
        return response.json();
      }).then(function (response) {
        return _this5.streamServerEvents(response);
      });
    }
  }, {
    key: "listenForRoomEvents",
    value: function listenForRoomEvents(room_id, controller) {
      var _this6 = this;

      var from = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';

      if (controller && controller.cancelled) {
        return;
      }

      var token = JSON.parse(this.storage.getItem('matrix:access-token') || 'false');

      if (!token) {
        return Promise.reject('No access token found.');
      }

      var query = new URLSearchParams({
        access_token: token.access_token,
        room_id: room_id,
        from: from
      });
      var listener = "".concat(this.clientUrl, "/events?").concat(query);
      controller = controller || {
        cancelled: false
      };
      fetch(listener).then(function (response) {
        return response.json();
      }).then(function (response) {
        return _this6.streamServerEvents(response, room_id, controller);
      });
      return controller;
    }
  }, {
    key: "streamServerEvents",
    value: function streamServerEvents(chunkList, room_id, controller) {
      var _this7 = this;

      if (controller && controller.cancelled) {
        return;
      }

      if (!this.interval) {
        if (room_id) {
          this.listenForRoomEvents(room_id, controller, chunkList.end);
        } else {
          this.listenForServerEvents();
        }
      } else {
        setTimeout(function () {
          if (room_id) {
            _this7.listenForRoomEvents(room_id, controller, chunkList.end);
          } else {
            _this7.listenForServerEvents();
          }
        }, this.interval);
      }

      chunkList.chunk && chunkList.chunk.forEach(function (event) {
        var detail = {};

        if (!event.event_id) {
          event.event_id = "local:".concat(new _Uuid.Uuid());
        }

        Object.assign(detail, event);

        _this7.dispatchEvent(new CustomEvent('matrix-event', {
          detail: detail
        }));

        _this7.dispatchEvent(new CustomEvent(detail.type, {
          detail: detail
        }));
      });
    }
  }, {
    key: "getUserProfile",
    value: function getUserProfile(userId) {
      if (this.profileCache.has(userId)) {
        return this.profileCache.get(userId);
      }

      var getProfile = fetch("".concat(this.clientUrl, "/profile/").concat(userId)).then(function (response) {
        return response.json();
      });
      this.profileCache.set(userId, getProfile);
      return getProfile;
    }
  }, {
    key: "getUserData",
    value: function getUserData(type) {
      var token = JSON.parse(this.storage.getItem('matrix:access-token') || 'false');

      if (!token) {
        return Promise.reject('No access token found.');
      }

      var query = new URLSearchParams({
        access_token: token.access_token
      });
      return fetch("".concat(this.clientUrl, "/user/").concat(token.user_id, "/account_data/").concat(type, "?").concat(query)).then(function (response) {
        return response.json();
      });
    }
  }, {
    key: "putUserData",
    value: function putUserData(type, body) {
      var token = JSON.parse(this.storage.getItem('matrix:access-token') || 'false');

      if (!token) {
        return;
      }

      var query = new URLSearchParams({
        access_token: token.access_token
      });
      var endpoint = "".concat(this.clientUrl, "/user/").concat(token.user_id, "/account_data/").concat(type, "?").concat(query);
      return fetch(endpoint, {
        method: 'PUT',
        body: body
      }).then(function (response) {
        if (!response.ok) {
          var error = new Error("HTTP status code: " + response.status);
          error.status = response.status;
          error.response = response;
          throw error;
        }

        return response;
      }).then(function (response) {
        return response.json();
      });
    }
  }, {
    key: "getMediaUrl",
    value: function getMediaUrl(mxcUrl) {
      var url = new URL(mxcUrl);
      return "".concat(this.mediaUrl, "/download/").concat(url.pathname.substr(2));
    }
  }, {
    key: "getMedia",
    value: function getMedia(mxcUrl) {
      if (this.mediaCache.has(mxcUrl)) {
        return this.mediaCache.get(mxcUrl);
      }

      var getUrl = fetch(this.getMediaUrl(mxcUrl)).then(function (response) {
        return Promise.all([response.arrayBuffer(), response.headers.get('Content-type')]);
      }).then(function (_ref) {
        var _ref2 = _slicedToArray(_ref, 2),
            buffer = _ref2[0],
            type = _ref2[1];

        return URL.createObjectURL(new Blob([buffer], {
          type: type
        }));
      });
      this.mediaCache.set(mxcUrl, getUrl);
      return getUrl;
    }
  }, {
    key: "postMedia",
    value: function postMedia(body, filename) {
      var tokenJson = this.storage.getItem('matrix:access-token') || 'false';
      var token = JSON.parse(tokenJson);

      if (!token) {
        return;
      }

      var query = new URLSearchParams({
        access_token: token.access_token
      });
      var url = "".concat(this.mediaUrl, "/upload?").concat(query);
      var headers = new Headers({
        'Content-Type': body.type
      });
      var method = 'POST';
      var options = {
        method: method,
        headers: headers,
        body: body
      };
      return fetch(url, options).then(function (response) {
        return response.json();
      });
    }
  }, {
    key: "putEvent",
    value: function putEvent(roomId, type, body) {
      var tokenJson = this.storage.getItem('matrix:access-token') || 'false';
      var token = JSON.parse(tokenJson);

      if (!token) {
        return;
      }

      var query = new URLSearchParams({
        access_token: token.access_token
      });
      var url = "".concat(this.clientUrl, "/rooms/").concat(roomId, "/send/").concat(type, "/").concat(Math.random().toString(36), "?").concat(query);
      var headers = new Headers({
        'Content-Type': 'application/json'
      });
      var method = 'PUT';
      var keepalive = true;

      var options = _defineProperty({
        method: method,
        headers: headers,
        keepalive: keepalive,
        body: JSON.stringify(body)
      }, "keepalive", keepalive);

      return fetch(url, options).then(function (response) {
        return response.json();
      });
    }
  }, {
    key: "getEvent",
    value: function getEvent(roomId, eventId) {
      var tokenJson = this.storage.getItem('matrix:access-token') || 'false';
      var token = JSON.parse(tokenJson);

      if (!token) {
        return;
      }

      var query = new URLSearchParams({
        access_token: token.access_token
      });
      var url = "".concat(this.clientUrl, "/rooms/").concat(roomId, "/event/").concat(eventId, "?").concat(query);
      var headers = new Headers({
        'Content-Type': 'application/json'
      });
      var method = 'GET';
      var options = {
        method: method,
        headers: headers
      };
      return fetch(url, options).then(function (response) {
        return response.json();
      });
    }
  }, {
    key: "sync",
    value: function sync() {
      var tokenJson = this.storage.getItem('matrix:access-token') || 'false';
      var token = JSON.parse(tokenJson);

      if (!token) {
        return Promise.resolve();
      }

      var query = new URLSearchParams({
        full_state: true,
        access_token: token.access_token
      });
      var syncer = "".concat(this.clientUrl, "/sync?").concat(query);
      return fetch(syncer).then(function (response) {
        return response.json();
      });
    }
  }, {
    key: "getRoomState",
    value: function getRoomState(room_id) {
      var tokenJson = this.storage.getItem('matrix:access-token') || 'false';
      var token = JSON.parse(tokenJson);

      if (!token) {
        return Promise.resolve();
      }

      var query = new URLSearchParams({
        access_token: token.access_token
      });
      var syncer = "".concat(this.clientUrl, "/rooms/").concat(room_id, "/state?").concat(query);
      return fetch(syncer).then(function (response) {
        return response.json();
      });
    }
  }, {
    key: "syncRoom",
    value: function syncRoom(room_id) {
      var from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var filter = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

      if (!this.isLoggedIn) {
        return Promise.reject('Logged out.');
      }

      var token = JSON.parse(this.storage.getItem('matrix:access-token') || 'false');

      if (!token) {
        return Promise.reject('No access token found.');
      }

      var query = new URLSearchParams({
        access_token: token.access_token,
        room_id: room_id,
        dir: 'b',
        from: from ? from : '',
        filter: filter ? JSON.stringify(filter) : ''
      });
      var syncer = "".concat(this.clientUrl, "/rooms/").concat(room_id, "/messages?").concat(query);
      var controller = new AbortController();
      var signal = controller.signal;

      var abort = function abort() {
        return controller.abort();
      };

      this.addEventListener('logged-out', abort, {
        once: true
      });
      var fetchFrame = fetch(syncer, {
        signal: signal
      }).then(function (response) {
        return response.json();
      });
      fetchFrame["finally"](this.removeEventListener('logged-out', abort));
      return fetchFrame;
    }
  }, {
    key: "syncRoomHistory",
    value: function syncRoomHistory(room) {
      var _this8 = this;

      var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var to = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var from = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      var filter = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
      return this.syncRoom(room, from, filter).then(function (frame) {
        if (!_this8.isLoggedIn) {
          return Promise.reject('Logged out.');
        }

        var cancelable = true;
        var detail = {
          frame: frame
        };
        var event = new CustomEvent('roomSyncFrame', {
          detail: detail,
          cancelable: cancelable
        });

        if (!_this8.dispatchEvent(event)) {
          return;
        }

        if (callback && frame.chunk) {
          var _iterator = _createForOfIteratorHelper(frame.chunk),
              _step;

          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var message = _step.value;

              if (!_this8.isLoggedIn) {
                return Promise.reject('Logged out.');
              }

              if (to && message.origin_server_ts <= to) {
                return Promise.resolve();
              }

              if (callback(message) === false) {
                return Promise.resolve();
              }
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        }

        return new Promise(function (accept) {
          var _this8$interval;

          return setTimeout(function () {
            return accept(frame.chunk.length && _this8.syncRoomHistory(room, callback, to, frame.end, filter));
          }, (_this8$interval = _this8.interval) !== null && _this8$interval !== void 0 ? _this8$interval : 0);
        });
      });
    }
  }, {
    key: "getCurrentUserId",
    value: function getCurrentUserId() {
      var tokenJson = this.storage.getItem('matrix:access-token') || 'false';
      var token = JSON.parse(tokenJson);

      if (!token) {
        return;
      }

      return token.user_id;
    }
  }, {
    key: "createRoom",
    value: function createRoom(name, topic, visibility) {
      var initial_state = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
      var body = JSON.stringify({
        name: name,
        topic: topic,
        visibility: visibility,
        initial_state: initial_state
      });
      var token = JSON.parse(this.storage.getItem('matrix:access-token') || 'false');

      if (!token) {
        return Promise.resolve();
      }

      var query = new URLSearchParams({
        access_token: token.access_token
      });
      var url = "".concat(this.clientUrl, "/createRoom?").concat(query);
      var method = 'POST';
      return fetch(url, {
        body: body,
        method: method
      }).then(function (response) {
        return response.json();
      });
    }
  }, {
    key: "joinRoom",
    value: function joinRoom(room_id) {
      var token = JSON.parse(this.storage.getItem('matrix:access-token') || 'false');

      if (!token) {
        return Promise.reject('No access token found.');
      }

      var query = new URLSearchParams({
        access_token: token.access_token
      });
      fetch("".concat(this.clientUrl, "/rooms/").concat(room_id, "/join?").concat(query), {
        method: 'POST'
      }).then(function (response) {
        return response.json();
      });
    }
  }, {
    key: "leaveRoom",
    value: function leaveRoom(room_id) {
      var token = JSON.parse(this.storage.getItem('matrix:access-token') || 'false');

      if (!token) {
        return Promise.reject('No access token found.');
      }

      var query = new URLSearchParams({
        access_token: token.access_token
      });
      fetch("".concat(this.clientUrl, "/rooms/").concat(room_id, "/leave?").concat(query), {
        method: 'POST'
      }).then(function (response) {
        return response.json();
      });
    }
  }, {
    key: "whoAmI",
    value: function whoAmI() {
      var token = JSON.parse(this.storage.getItem('matrix:access-token') || 'false');

      if (!token) {
        return Promise.reject('No access token found.');
      }

      var query = new URLSearchParams({
        access_token: token.access_token
      });
      return fetch("".concat(this.clientUrl, "/account/whoami?").concat(query)).then(function (response) {
        return response.json();
      });
    }
  }]);

  return Matrix;
}(_Mixin.Mixin["with"](_EventTargetMixin.EventTargetMixin));

exports.Matrix = Matrix;
  })();
});

require.register("sixgram/Actions.js", function(exports, require, module) {
  require = __makeRelativeRequire(require, {}, "sixgram");
  (function() {
    "use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.HOME = exports.LEAVE = exports.ENTER = exports.INSERT = exports.IGNORE = void 0;
var IGNORE = 0;
exports.IGNORE = IGNORE;
var INSERT = 1;
exports.INSERT = INSERT;
var ENTER = 2;
exports.ENTER = ENTER;
var LEAVE = 3;
exports.LEAVE = LEAVE;
var HOME = 4;
exports.HOME = HOME;
  })();
});

require.register("sixgram/Chunk.js", function(exports, require, module) {
  require = __makeRelativeRequire(require, {}, "sixgram");
  (function() {
    "use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Chunk = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Chunk = function Chunk() {
  _classCallCheck(this, Chunk);

  this.depth = 0;
  this.match = null;
  this.type = 'normal';
  this.list = [];
};

exports.Chunk = Chunk;
  })();
});

require.register("sixgram/Parser.js", function(exports, require, module) {
  require = __makeRelativeRequire(require, {}, "sixgram");
  (function() {
    "use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Parser = void 0;

var _Chunk = require("./Chunk");

var _Actions = require("./Actions");

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Parser = /*#__PURE__*/function () {
  function Parser(tokens, modes) {
    _classCallCheck(this, Parser);

    this.tokens = tokens || {};
    this.modes = modes || {};
  }

  _createClass(Parser, [{
    key: "parse",
    value: function parse(source) {
      this.index = 0;
      this.mode = 'normal';
      this.stack = [];

      if (!(this.mode in this.modes)) {
        throw new Error("Mode ".concat(this.mode, " does not exist on parser."), this);
      }

      var chunk = new _Chunk.Chunk();
      var mode = this.modes[this.mode];
      chunk.type = this.mode;

      while (this.index < source.length) {
        var matched = false;

        for (var tokenName in mode) {
          var token = this.tokens[tokenName];
          var search = token.exec(source.substr(this.index));

          if (!search || search.index > 0) {
            continue;
          }

          if (!mode[tokenName]) {
            throw new Error("Invalid token type \"".concat(tokenName, "\" found in mode \"").concat(this.mode, "\"."));
            continue;
          }

          var value = search[0];
          var actions = _typeof(mode[tokenName]) === 'object' ? mode[tokenName] : [mode[tokenName]];
          matched = true;
          this.index += value.length;
          var type = 'normal';

          for (var i in actions) {
            var action = actions[i];

            if (typeof action === 'string') {
              if (!(action in this.modes)) {
                throw new Error("Mode \"".concat(action, "\" does not exist."));
              }

              this.mode = action;
              mode = this.modes[this.mode];
              type = action;
              continue;
            }

            switch (action) {
              case _Actions.INSERT:
                chunk.list.push(value);
                break;

              case _Actions.ENTER:
                var newChunk = new _Chunk.Chunk();
                newChunk.depth = chunk.depth + 1;
                newChunk.match = value;
                newChunk.groups = _toConsumableArray(value.match(token)).slice(1);
                newChunk.mode = type;
                newChunk.type = tokenName;
                chunk.list.push(newChunk);
                this.stack.push(chunk);
                chunk = newChunk; // this.mode = chunk.type;

                break;

              case _Actions.LEAVE:
                if (!this.stack.length) {// throw new Warning(`Already at the top of the stack.`)
                } else {
                  chunk = this.stack.pop();
                  this.mode = chunk.type;
                  mode = this.modes[this.mode];
                }

                break;

              case _Actions.HOME:
                this.stack.splice(0);
                mode = this.modes['normal'];
                break;
            }
          }

          break;
        }

        if (!matched) {
          break;
        }
      }

      if (this.stack.length) {
        throw new Error('Did not return to top of stack!');
      }

      return this.stack.shift() || chunk;
    }
  }]);

  return Parser;
}();

exports.Parser = Parser;
  })();
});

require.register("sixgram/Renderer.js", function(exports, require, module) {
  require = __makeRelativeRequire(require, {}, "sixgram");
  (function() {
    "use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Renderer = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Renderer = /*#__PURE__*/function () {
  function Renderer(ops) {
    _classCallCheck(this, Renderer);

    this.ops = ops || {};
  }

  _createClass(Renderer, [{
    key: "process",
    value: function process(tree) {
      var output = '';

      for (var i in tree.list) {
        var chunk = tree.list[i];

        if (this.ops[tree.type]) {
          var processed = this.ops[tree.type](chunk, tree);

          if (processed !== false) {
            output += processed;
          }
        } else if (chunk !== false) {
          output += chunk;
        }
      }

      return output;
    }
  }]);

  return Renderer;
}();

exports.Renderer = Renderer;
  })();
});

require.register("subspace-client/Channel.js", function(exports, require, module) {
  require = __makeRelativeRequire(require, {}, "subspace-client");
  (function() {
    "use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Channel = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Channel = /*#__PURE__*/function () {
  function Channel() {
    _classCallCheck(this, Channel);
  }

  _createClass(Channel, null, [{
    key: "scalar",
    value: function scalar(data, type) {
      var buffer = new Uint8Array(data).buffer;

      if (type == 'float') {
        return new Float64Array(buffer)[0];
      } else if (type == 'Int32') {
        return new Int32Array(buffer)[0];
      }
    }
  }, {
    key: "namePart",
    value: function namePart(name, part) {
      return name.split(':')[part] || null;
    }
  }, {
    key: "isWildcard",
    value: function isWildcard(name) {
      return /\*/.exec(name);
    }
  }, {
    key: "isRange",
    value: function isRange(name) {// return /\*/.exec(name);
    }
  }, {
    key: "containsRange",
    value: function containsRange(name) {// return /\*/.exec(name);
    }
  }, {
    key: "compareNames",
    value: function compareNames(a, b) {
      var rangeForm = /^(\d+)\-?(\d+)?$/;
      var result = [];
      var splitA = a.toString().split(':');
      var splitB = b.toString().split(':');
      var nodes = splitA.length;
      var cmpA;
      var cmpB;

      if (nodes < splitB.length) {
        nodes = splitB.length;
      }

      for (var i = 0; i < nodes; i++) {
        if (splitA.length > i) {
          cmpA = splitA[i];
        } else if (splitA[splitA.length - 1] == '*') {
          cmpA = splitA[splitA.length - 1];
        } else {
          return false;
        }

        if (splitB.length > i) {
          cmpB = splitB[i];
        } else if (splitB[splitB.length - 1] == '*') {
          cmpB = splitB[splitB.length - 1];
        } else {
          return false;
        }

        var returnNode = cmpA !== '*' ? cmpA : cmpB;

        if (cmpA !== cmpB) {
          if (cmpA !== '*' && cmpB !== '*') {
            var mA = rangeForm.exec(cmpA);
            var mB = rangeForm.exec(cmpB);

            if (mA && mB) {
              var a1 = mA[1];
              var a2 = mA[1];
              var b1 = mB[1];
              var b2 = mB[1];

              if (mA[2]) {
                a2 = mA[2];
              }

              if (mB[2]) {
                b2 = mB[2];
              }

              if (a1 >= b1 && a2 <= b2) {
                returnNode = "".concat(a1, "-").concat(a2);
              } else if (a1 <= b1 && a2 > b2) {
                returnNode = "".concat(b1, "-").concat(b2);
              } else if (a2 <= b2 && a2 >= b1) {
                returnNode = "".concat(b1, "-").concat(a2);
              } else if (a1 <= b2 && a1 >= b1) {
                returnNode = "".concat(a1, "-").concat(b2);
              }

              if (b2 <= a2 && b2 >= a1) {
                returnNode = "".concat(a1, "-").concat(b2);
              } else if (b1 <= a2 && b1 >= a1) {
                returnNode = "".concat(b1, "-").concat(a2);
              } else {
                return false;
              }
            } else {
              return false;
            }
          }
        }

        result.push(returnNode);
      }

      return result.join(':');
    }
  }]);

  return Channel;
}();

exports.Channel = Channel;
  })();
});

require.register("subspace-client/Socket.js", function(exports, require, module) {
  require = __makeRelativeRequire(require, {}, "subspace-client");
  (function() {
    "use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Socket = void 0;

var _Channel = require("./Channel");

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Socket = /*#__PURE__*/function () {
  _createClass(Socket, null, [{
    key: "get",
    value: function get(url) {
      var refresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (!this.sockets) {
        this.sockets = {};
      }

      if (refresh || !this.sockets[url]) {
        this.sockets[url] = new this(new WebSocket(url));
      }

      return this.sockets[url];
    }
  }]);

  function Socket(socket) {
    _classCallCheck(this, Socket);

    this.socket = socket;
    socket.binaryType = 'arraybuffer';
    this.data = {};
    this.listenerCount = {};
    this.openQueue = [];
    this._onSend = [];
  }

  _createClass(Socket, [{
    key: "subscribe",
    value: function subscribe(type, wildType, callback) {
      var splitType = type.split(':');
      var mainType = splitType.shift();
      var channel = splitType.join(':');

      if (wildType instanceof Function) {
        callback = wildType;
        wildType = channel;
      }

      if (channel) {
        if (!(channel in this.listenerCount)) {
          this.listenerCount[channel] = 0;
        }

        this.listenerCount[channel]++;
        this.send("sub ".concat(channel));
      }

      var finalCallback = function (mainType, wildType, channel, callback) {
        return function (event) {
          var packet = {};

          try {
            if (typeof event.data == 'string') {
              packet = JSON.parse(event.data);
            } else if (event.data instanceof ArrayBuffer) {
              var channelNumber = new Uint16Array(event.data, 4, 1)[0];

              if (!wildType || _Channel.Channel.compareNames(wildType, channelNumber)) {
                callback(event, event.data.slice(6), channelNumber, new Uint16Array(event.data, 0, 1)[0] ? 'user' : 'server', new Uint16Array(event.data, 2, 1)[0], null, {});
                return;
              }
            } else if (mainType !== 'message') {
              callback(event);
              return;
            }
          } catch (e) {
            if (mainType !== 'message') {
              callback(event);
            }

            return;
          }

          if (_typeof(packet) !== 'object') {
            if (channel === '') {
              callback(event, event.data, null, 'server', 0, null, packet);
            }

            return;
          }

          if (!wildType) {
            callback(event, packet.message, null, packet.origin, packet.originId, null, packet);
          }

          if (wildType && 'channel' in packet) {
            if (_Channel.Channel.compareNames(wildType, packet.channel)) {
              callback(event, packet.message, packet.channel, packet.origin, packet.originId, packet.originalChannel, packet);
            }
          }
        };
      }(mainType, wildType, channel, callback);

      this.socket.addEventListener(mainType, finalCallback);
      return finalCallback;
    }
  }, {
    key: "unsubscribe",
    value: function unsubscribe(type, callback) {
      var splitType = type.split(':');
      var mainType = splitType.shift();
      var channel = splitType.join(':');

      if (!channel) {
        return;
      }

      this.listenerCount[channel]--;

      if (channel in this.listenerCount && this.listenerCount[channel] > 0) {} else {
        this.socket.removeEventListener(mainType, callback);
        this.send("unsub ".concat(channel));
      }
    }
  }, {
    key: "publish",
    value: function publish(channel, message) {
      if (channel == parseInt(channel)) {
        if (message instanceof ArrayBuffer) {
          message = new Uint8Array(message);
        } else if (message.byteLength) {
          message = new Uint8Array(message.buffer);
        } else if (!Array.isArray(message)) {
          message = [message];
        }

        var channelBytes = new Uint8Array(new Uint16Array([channel]).buffer);
        var sendBuffer = new Uint8Array(channelBytes.byteLength + message.byteLength);
        sendBuffer.set(channelBytes, 0);
        sendBuffer.set(message, channelBytes.byteLength);
        this.send(sendBuffer);
        return;
      }

      this.send("pub ".concat(channel, " ").concat(message));
    }
  }, {
    key: "say",
    value: function say(channel, users, message) {
      var cc = [];
      var bcc = [];

      if (Array.isArray(users)) {
        Object.assign(cc, users);
      } else if (users.cc || users.bcc) {
        if (Array.isArray(users.cc)) {
          Object.assign(cc, users.cc);
        }

        if (Array.isArray(users.bcc)) {
          Object.assign(bcc, users.bcc);
        }
      }

      if (!cc && !bcc) {
        var userListString = 'CANNOT STRINGIFY USERLIST';

        try {
          userListString = JSON.stringify(users);
        } catch (error) {
          userlistString += ' ' + error.message;
        }

        throw error('Invalid userlist provided:' + userListString);
      }

      var ccString = cc.length ? "".concat(cc.length, " ").concat(cc.join(' ')) : "0";
      var bccString = bcc.length ? "".concat(bcc.length, " ").concat(bcc.join(' ')) : "0";
      this.send("say ".concat(channel, " ").concat(ccString, " ").concat(bccString, " ").concat(message));
    }
  }, {
    key: "send",
    value: function send(message) {
      var _this = this;

      if (this.socket.readyState !== this.socket.OPEN) {
        return new Promise(function (accept, reject) {
          var connectionOpened = function (c) {
            return function (event) {
              while (_this.openQueue.length) {
                var _message = _this.openQueue.shift();

                _this.send(_message);
              }

              _this.socket.removeEventListener('open', c);

              accept();
            };
          }(connectionOpened);

          _this.socket.addEventListener('open', connectionOpened);

          _this.openQueue.unshift(message);
        });
      }

      for (var i in this._onSend) {
        this._onSend[i](message);
      }

      this.socket.send(message);
      return Promise.resolve();
    }
  }, {
    key: "onSend",
    value: function onSend(callback) {
      this._onSend.push(callback);
    }
  }, {
    key: "close",
    value: function close(message) {
      this.socket.close();
    }
  }, {
    key: "ping",
    value: function ping() {// this.socket.ping();
    }
  }, {
    key: "pong",
    value: function pong() {// this.socket.pong();
    }
  }]);

  return Socket;
}();

exports.Socket = Socket;
  })();
});

require.register("subspace-console/Console.js", function(exports, require, module) {
  require = __makeRelativeRequire(require, {}, "subspace-console");
  (function() {
    "use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Console = void 0;

var _View2 = require("curvature/base/View");

var _Bag = require("curvature/base/Bag");

var _MeltingText = require("./view/MeltingText");

var _EchoMessage = require("./view/EchoMessage");

var _Task = require("./Task");

var _Path = require("./Path");

var _Renderer = require("./ansi/Renderer");

var _Parser = require("./ansi/Parser");

function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var Console = /*#__PURE__*/function (_View) {
  _inherits(Console, _View);

  var _super = _createSuper(Console);

  function Console() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Console);

    _this = _super.call(this, args);
    var defaults = {
      init: false,
      path: _Path.Path
    };
    var allOptions = Object.assign({}, defaults, options);
    _this.template = "<div class = \"terminal [[inverted]]\" cv-on = \"click:focus(event)\">\n\t<div class = \"output\" cv-each = \"output:line:l\" cv-ref = \"output:curvature/base/Tag\">\n\t\t<p>[[line]]</p>\n\t</div>\n\t<div class = \"bottom\">\n\t\t<div>[[prompt]]&nbsp;</div>\n\t\t<div>\n\t\t\t<form cv-on = \"submit:cancel(event)\">\n\t\t\t\t<textarea\n\t\t\t\t\tcv-bind = \"input\"\n\t\t\t\t\tcv-on   = \":keydown(event);:keyup(event)\"\n\t\t\t\t\tcv-ref  = \"input:curvature/base/Tag\"\n\t\t\t\t\trow     = \"1\"\n\t\t\t\t></textarea>\n\t\t\t</form>\n\n\t\t\t<form cv-on = \"submit:cancel(event)\">\n\t\t\t\t<input\n\t\t\t\t\tautocomplete = \"one-time-code\"\n\t\t\t\t\tname    = \"pw-input\"\n\t\t\t\t\ttype    = \"password\"\n\t\t\t\t\tcv-bind = \"input\"\n\t\t\t\t\tcv-ref  = \"password:curvature/base/Tag\"\n\t\t\t\t\tcv-on   = \":keydown(event,false);:keyup(event,false)\"\n\t\t\t\t/>\n\t\t\t</form>\n\n\t\t\t<input\n\t\t\t\tcv-on  = \"input:fileLoaded(event)\"\n\t\t\t\tcv-ref = \"file:curvature/base/Tag\"\n\t\t\t\tname   = \"file-input\"\n\t\t\t\ttype   = \"file\"\n\t\t\t\tstyle  = \"display: none\"\n\t\t\t/>\n\t\t</div>\n\t</div>\n</div>\n\n<div class = \"scanlines\"></div>\n";
    _this.args.input = '';
    _this.args.output = [];
    _this.args.inverted = '';
    _this.localEcho = true;
    _this.postToken = null;
    _this.args.prompt = '::';
    _this.routes = {};
    _this.args.passwordMode = false;
    _this.tasks = [];
    _this.external = options.external || [];
    _this.taskList = new _Bag.Bag();
    _this.taskList.type = _Task.Task;
    _this.max = 10;
    _this.historyCursor = -1;
    _this.history = [];
    _this.env = new Map();

    _this.args.output.___after(function (t, k, o, a) {
      if (k !== 'push') {
        return;
      }

      _this.onNextFrame(function () {
        return _this.scrollToBottom();
      });
    });

    if (allOptions.init) {
      _this.runScript(allOptions.init);
    }

    _this.scroller = allOptions.scroller || document.body;
    _this.path = allOptions.path || {};
    _this.originalInput = '';
    return _this;
  }

  _createClass(Console, [{
    key: "runCommand",
    value: function runCommand(command) {
      var _this2 = this;

      if (this.historyCursor != 0) {
        this.history.unshift(command);
      }

      return new Promise(function (accept) {
        var task;

        if (command.substring(0, 1) === '/') {
          if (!_this2.args.passwordMode) {
            var output = new _EchoMessage.EchoMessage({
              message: command
            });

            _this2.args.output.push(output);
          }

          var unescaped = _this2.unescape(command.substr(1));

          task = _this2.interpret(unescaped);
        } else if (_this2.tasks.length) {
          if (!_this2.args.passwordMode) {
            var _output = new _EchoMessage.EchoMessage({
              message: command,
              prompt: _this2.tasks[0].prompt
            });

            _this2.args.output.push(_output);
          }

          var _unescaped = _this2.unescape(command);

          task = _this2.tasks[0].write(_unescaped) || Promise.resolve();
        } else {
          if (!_this2.args.passwordMode) {
            _this2.args.output.push(":: ".concat(command));
          }

          var _unescaped2 = _this2.unescape(command);

          task = _this2.interpret(_unescaped2);
        }

        if (!(task instanceof _Task.Task) && !(task instanceof Promise)) {
          task = Promise.resolve(task);
        }

        _this2.historyCursor = -1;
        _this2.originalInput = _this2.args.input = '';
        task.then(function (result) {
          return accept(result);
        });
      })["catch"](function (error) {
        _this2.args.output.push("Unexpected error: ".concat(error));
      });
    }
  }, {
    key: "runScript",
    value: function runScript(url) {
      var _this3 = this;

      fetch(url + '?api=txt').then(function (response) {
        return response.text();
      }).then(function (init) {
        var lines = init.split("\n");

        var process = function process(lines) {
          if (!lines.length) {
            return;
          }

          var line = lines.shift();

          if (line && line[0] == '!') {
            _this3.args.output.push(line.substring(1));

            process(lines);
          } else if (line) {
            _this3.runCommand(line).then(function () {
              return process(lines);
            });
          } else {
            process(lines);
          }
        };

        process(lines);
      });
    }
  }, {
    key: "postRender",
    value: function postRender() {
      var _this4 = this;

      var inputBox = this.tags.input.element;
      var passwordBox = this.tags.password.element;
      this.args.bindTo('input', function (v) {
        inputBox.style.height = 'auto';
        inputBox.style.height = inputBox.scrollHeight + 'px';
      }, {
        frame: 1
      });
      this.args.bindTo('passwordMode', function (v) {
        if (v) {
          inputBox.style.display = 'none';
          passwordBox.style.display = 'unset';
        } else {
          inputBox.style.display = 'unset';
          passwordBox.style.display = 'none';
        }
      });
      this.args.bindTo('passwordMode', function (v) {
        _this4.focus(null, v);
      }, {
        frame: 1
      });
    }
  }, {
    key: "focus",
    value: function focus() {
      var event = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var passwordMode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      if (event) {
        event.preventDefault();
      }

      if (event && event.target && event.target.matches('input,textarea')) {
        return;
      }

      if (window.getSelection().toString()) {
        return;
      }

      if (passwordMode || this.args.passwordMode) {
        this.tags.password.element.focus();
        return;
      }

      this.tags.input.element.focus();
    }
  }, {
    key: "interpret",
    value: function interpret(input) {
      var _this5 = this;

      this.historyCursor = -1;
      var expressions = input.split(/\s*\;\s*/);
      var lastTask = null;

      var _iterator = _createForOfIteratorHelper(expressions),
          _step;

      try {
        var _loop = function _loop() {
          var expression = _step.value;

          var task = _this5.pipe(expression.split(/\s*\|\s*/));

          if (task) {
            _this5.tasks.unshift(task);

            var output = function output(event) {
              var line = event.detail;

              if (_typeof(line) === 'object') {
                _this5.args.output.push(line);
              } else {
                var prompt = task.outPrompt || task.prompt || _this5.args.prompt || '::';

                var rendered = _this5.parseAnsi(line, prompt);

                _this5.args.output.push(rendered);
              }
            };

            var error = function error(event) {
              console.error(event);
              var line = event.detail;
              var errorPrompt = task.errorPrompt || '!!';

              var rendered = _this5.parseAnsi(line, errorPrompt);

              _this5.args.output.push(rendered);
            };

            task.addEventListener('output', output);
            task.addEventListener('error', error);
            task.execute();
            task["catch"](function (error) {
              return console.error(error);
            });
            task["catch"](function (error) {
              return _this5.args.output.push("!! ".concat(error));
            });
            _this5.args.prompt = task.prompt;
            task["finally"](function (done) {
              task.removeEventListener('error', error);
              task.removeEventListener('output', output);

              _this5.tasks.shift();

              if (_this5.tasks.length) {
                _this5.args.prompt = _this5.tasks[0].prompt;
              } else {
                _this5.args.prompt = '::';
              }
            });
          }

          lastTask = task;
        };

        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          _loop();
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      return lastTask;
    }
  }, {
    key: "pipe",
    value: function pipe(commands, previousTask) {
      var task = null;
      var commandString = commands.shift();
      var args = commandString.trim().split(' ');
      var command = args.shift().trim();

      if (command.length > 1 && command.substr(-1) == "?") {
        command = command.substr(0, command.length - 1);

        if (command in this.path) {
          this.args.output.push("?? ".concat(this.path[command].helpText));
          this.args.output.push("?? ".concat(this.path[command].useText));
        }

        return;
      }

      if (command in this.path) {
        var cmdClass = this.path[command];
        task = _construct(cmdClass, [args, previousTask, this].concat(_toConsumableArray(this.external)));
      } else {
        switch (command) {
          case 'clear':
            this.args.output.splice(0);
            break;

          case 'z':
            this.args.output.splice(0);
            this.args.output.push(new _MeltingText.MeltingText({
              input: '!!!'
            }));
            break;

          case 'commands':
          case '?':
            this.args.output.push("   Subspace Console 0.29a \xA92018-2021 Sean Morris");

            for (var cmd in this.path) {
              this.args.output.push(" * ".concat(cmd, " - ").concat(this.path[cmd].helpText));
              this.path[cmd].useText && this.args.output.push("   ".concat(this.path[cmd].useText));
              this.args.output.push("  ");
            }

            break;

          default:
            this.args.output.push("!! Bad command: ".concat(command));
        }
      }

      if (commands.length) {
        return this.pipe(commands, task);
      }

      return task;
    }
  }, {
    key: "keydown",
    value: function keydown(event, autocomplete) {
      switch (event.key) {
        case 'Tab':
          if (autocomplete) {
            break;
          }

          event.preventDefault();
          break;

        case 'Enter':
          if (!event.ctrlKey) {
            event.preventDefault();
          }

          break;
      }
    }
  }, {
    key: "keyup",
    value: function keyup(event, autocomplete) {
      var _this6 = this;

      switch (event.key) {
        case 'ArrowDown':
          this.historyCursor--;

          if (this.historyCursor <= -1) {
            this.historyCursor = -1;
            this.args.input = this.originalInput;
            return;
          }

          this.args.input = this.history[this.historyCursor];
          this.onNextFrame(function () {
            var element = _this6.tags.input.element;
            element.selectionStart = element.value.length;
            element.selectionEnd = element.value.length;
          });
          break;

        case 'ArrowUp':
          if (this.historyCursor == -1) {
            this.originalInput = this.args.input;
          }

          this.historyCursor++;

          if (this.historyCursor >= this.history.length) {
            this.historyCursor--;
            return;
          }

          this.args.input = this.history[this.historyCursor];
          this.onNextFrame(function () {
            var element = _this6.tags.input.element;
            element.selectionStart = element.value.length;
            element.selectionEnd = element.value.length;
          });
          break;

        case 'Escape':
          if (this.tasks.length) {
            this.tasks[0]["finally"](function () {
              return _this6.args.output.push(":: Killed.");
            });
            this.tasks[0].signal(_Task.Task.KILL);
          }

          this.args.passwordMode = false;
          break;

        case 'Tab':
          event.preventDefault();

          if (!this.args.input) {
            break;
          }

          var search = this.args.input;
          var sigil = '';

          if (this.args.input[0] === '/') {
            search = this.args.input.substr(1);
            sigil = this.args.input.substr(0, 1);
            break;
          }

          for (var cmd in this.path) {
            if (cmd.length < search.length) {
              continue;
            }

            if (search === cmd.substr(0, search.length)) {
              this.args.input = sigil + cmd;
              break;
            }
          }

          break;

        case 'Enter':
          if (!event.ctrlKey) {
            event.preventDefault();
          } else {
            return;
          }

          this.runCommand(this.args.input);
          this.args.input = '';
          break;

        default:
          this.historyCursor = -1;
          this.scrollToBottom();
          break;
      }
    }
  }, {
    key: "cancel",
    value: function cancel(event) {
      event.preventDefault();
      event.stopPropagation();
    }
  }, {
    key: "scrollToBottom",
    value: function scrollToBottom() {
      var scroller = (this.scroller === document.body ? window : this.scroller) || window;
      var scrollTo = this.scroller.scrollHeight;
      this.onNextFrame(function () {
        scroller.scrollTo({
          behavior: 'smooth',
          left: 0,
          top: scrollTo
        });
      });
    }
  }, {
    key: "parseAnsi",
    value: function parseAnsi(line, prompt) {
      line = line.replace(/</g, '&lt;').replace(/>/g, '&gt;');
      var renderer = new _Renderer.Renderer();

      var parsed = _Parser.Parser.parse(line);

      var wrapped = renderer.process(parsed);

      if (!prompt) {
        return _View2.View.from("<span class =\"ansi\">".concat(wrapped, "</span>"));
      }

      var promptEsc = prompt.replace(/</g, '&lt;').replace(/>/g, '&gt;');

      var rendered = _View2.View.from("".concat(promptEsc, " <span class =\"ansi\">").concat(wrapped, "</span>"));

      return rendered;
    }
  }, {
    key: "unescape",
    value: function unescape(string) {
      return string.replace(/\\n/gm, '\n').replace(/\\r/gm, '\r').replace(/\\t/gm, '\t').replace(/\\e/gm, "\x1B").replace(/\\u001b/gm, "\x1B");
    }
  }, {
    key: "write",
    value: function write() {
      for (var _len = arguments.length, lines = new Array(_len), _key = 0; _key < _len; _key++) {
        lines[_key] = arguments[_key];
      }

      for (var _i = 0, _lines = lines; _i < _lines.length; _i++) {
        var line = _lines[_i];

        if (typeof line === 'string') {
          var unescaped = this.unescape(line);
          var parsed = this.parseAnsi(unescaped);
          this.args.output.push(parsed);
          continue;
        }

        this.args.output.push(line);
      }
    }
  }]);

  return Console;
}(_View2.View);

exports.Console = Console;
  })();
});

require.register("subspace-console/Path.js", function(exports, require, module) {
  require = __makeRelativeRequire(require, {}, "subspace-console");
  (function() {
    "use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Path = void 0;

var _Task = require("subspace-console/Task");

var Path = {};
exports.Path = Path;
  })();
});

require.register("subspace-console/Task.js", function(exports, require, module) {
  require = __makeRelativeRequire(require, {}, "subspace-console");
  (function() {
    "use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Task = void 0;

var _Bindable = require("curvature/base/Bindable");

var _Mixin = require("curvature/base/Mixin");

var _Target = require("./mixin/Target");

var _TaskSignals = require("./mixin/TaskSignals");

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var taskId = 0;
var target = Symbol('target');
var Accept = Symbol('accept');
var Reject = Symbol('reject');
var Execute = Symbol('execute');

var Task = /*#__PURE__*/function (_Mixin$with) {
  _inherits(Task, _Mixin$with);

  var _super = _createSuper(Task);

  function Task() {
    var _this;

    var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var prev = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var term = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

    _classCallCheck(this, Task);

    _this = _super.call(this);

    _defineProperty(_assertThisInitialized(_this), "title", 'Generic Task');

    _defineProperty(_assertThisInitialized(_this), "prompt", '::');

    _this.args = args;
    _this.prev = prev;
    _this.term = term;
    _this.status = -1;
    _this.thread = new Promise(function (accept, reject) {
      _this[Accept] = accept;
      _this[Reject] = reject;
    });
    _this.id = taskId++;
    return _possibleConstructorReturn(_this, _assertThisInitialized(_this));
  }

  _createClass(Task, [{
    key: "then",
    value: function then(callback) {
      return this.thread.then(callback);
    }
  }, {
    key: "catch",
    value: function _catch(callback) {
      return this.thread["catch"](callback);
    }
  }, {
    key: "finally",
    value: function _finally(callback) {
      return this.thread["finally"](callback);
    }
  }, {
    key: "print",
    value: function print(detail) {
      this.dispatchEvent(new CustomEvent('output', {
        detail: detail
      }));
    }
  }, {
    key: "printErr",
    value: function printErr(detail) {
      this.dispatchEvent(new CustomEvent('error', {
        detail: detail
      }));
    }
  }, {
    key: "write",
    value: function write(line) {
      return this.main(line);
    }
  }, {
    key: "signal",
    value: function signal(signalName) {
      if (this["signal::".concat(signalName)]) {
        this["signal::".concat(signalName)]();
      }

      switch (signalName) {
        case 'close':
          if (this.dispatchEvent(new CustomEvent('close'))) {
            this.status > 0 ? this[Reject]() : this[Accept]();
          }

          break;

        case 'kill':
          this.status > 0 ? this[Reject]() : this[Accept]();
          break;
      }
    }
  }, {
    key: "execute",
    value: function execute() {
      return this[Execute](this.prev);
    }
  }, {
    key: Execute,
    value: function value() {
      var _this2 = this;

      var onOutputEvent = function onOutputEvent(_ref) {
        var detail = _ref.detail;
        return _this2.write(detail);
      };

      var init = this.init.apply(this, _toConsumableArray(this.args));
      var prev = this.prev;

      if (prev) {
        prev.addEventListener('output', onOutputEvent);
      }

      if (!(init instanceof Promise)) {
        init = Promise.resolve(init);
      }

      if (prev) {
        prev[Execute]();
        return Promise.allSettled([prev, init])["finally"](function () {
          prev.then(function (r) {
            return _this2[Accept](r);
          });
          prev["catch"](function (e) {
            return _this2[Reject](r);
          });
          prev.removeEventListener('output', onOutputEvent);
          return _this2.done();
        });
      } else {
        return Promise.allSettled([init]).then(function (result) {
          try {
            _this2.main(undefined);

            _this2[Accept]();
          } catch (_unused) {
            _this2[Reject]();
          }

          _this2.done();
        });
      }
    }
  }, {
    key: "init",
    value: function init() {}
  }, {
    key: "main",
    value: function main() {
      var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    }
  }, {
    key: "done",
    value: function done(results) {
      return this.status;
    }
  }]);

  return Task;
}(_Mixin.Mixin["with"](_Target.Target, _TaskSignals.TaskSignals));

exports.Task = Task;
  })();
});

require.register("subspace-console/ansi/Colors255.js", function(exports, require, module) {
  require = __makeRelativeRequire(require, {}, "subspace-console");
  (function() {
    "use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Colors255 = void 0;
var Colors255 = {
  "0": {
    "r": 0,
    "g": 0,
    "b": 0
  },
  "1": {
    "r": 128,
    "g": 0,
    "b": 0
  },
  "2": {
    "r": 0,
    "g": 128,
    "b": 0
  },
  "3": {
    "r": 128,
    "g": 128,
    "b": 0
  },
  "4": {
    "r": 0,
    "g": 0,
    "b": 128
  },
  "5": {
    "r": 128,
    "g": 0,
    "b": 128
  },
  "6": {
    "r": 0,
    "g": 128,
    "b": 128
  },
  "7": {
    "r": 192,
    "g": 192,
    "b": 192
  },
  "8": {
    "r": 128,
    "g": 128,
    "b": 128
  },
  "9": {
    "r": 255,
    "g": 0,
    "b": 0
  },
  "10": {
    "r": 0,
    "g": 255,
    "b": 0
  },
  "11": {
    "r": 255,
    "g": 255,
    "b": 0
  },
  "12": {
    "r": 0,
    "g": 0,
    "b": 255
  },
  "13": {
    "r": 255,
    "g": 0,
    "b": 255
  },
  "14": {
    "r": 0,
    "g": 255,
    "b": 255
  },
  "15": {
    "r": 255,
    "g": 255,
    "b": 255
  },
  "16": {
    "r": 0,
    "g": 0,
    "b": 0
  },
  "17": {
    "r": 0,
    "g": 0,
    "b": 95
  },
  "18": {
    "r": 0,
    "g": 0,
    "b": 135
  },
  "19": {
    "r": 0,
    "g": 0,
    "b": 175
  },
  "20": {
    "r": 0,
    "g": 0,
    "b": 215
  },
  "21": {
    "r": 0,
    "g": 0,
    "b": 255
  },
  "22": {
    "r": 0,
    "g": 95,
    "b": 0
  },
  "23": {
    "r": 0,
    "g": 95,
    "b": 95
  },
  "24": {
    "r": 0,
    "g": 95,
    "b": 135
  },
  "25": {
    "r": 0,
    "g": 95,
    "b": 175
  },
  "26": {
    "r": 0,
    "g": 95,
    "b": 215
  },
  "27": {
    "r": 0,
    "g": 95,
    "b": 255
  },
  "28": {
    "r": 0,
    "g": 135,
    "b": 0
  },
  "29": {
    "r": 0,
    "g": 135,
    "b": 95
  },
  "30": {
    "r": 0,
    "g": 135,
    "b": 135
  },
  "31": {
    "r": 0,
    "g": 135,
    "b": 175
  },
  "32": {
    "r": 0,
    "g": 135,
    "b": 215
  },
  "33": {
    "r": 0,
    "g": 135,
    "b": 255
  },
  "34": {
    "r": 0,
    "g": 175,
    "b": 0
  },
  "35": {
    "r": 0,
    "g": 175,
    "b": 95
  },
  "36": {
    "r": 0,
    "g": 175,
    "b": 135
  },
  "37": {
    "r": 0,
    "g": 175,
    "b": 175
  },
  "38": {
    "r": 0,
    "g": 175,
    "b": 215
  },
  "39": {
    "r": 0,
    "g": 175,
    "b": 255
  },
  "40": {
    "r": 0,
    "g": 215,
    "b": 0
  },
  "41": {
    "r": 0,
    "g": 215,
    "b": 95
  },
  "42": {
    "r": 0,
    "g": 215,
    "b": 135
  },
  "43": {
    "r": 0,
    "g": 215,
    "b": 175
  },
  "44": {
    "r": 0,
    "g": 215,
    "b": 215
  },
  "45": {
    "r": 0,
    "g": 215,
    "b": 255
  },
  "46": {
    "r": 0,
    "g": 255,
    "b": 0
  },
  "47": {
    "r": 0,
    "g": 255,
    "b": 95
  },
  "48": {
    "r": 0,
    "g": 255,
    "b": 135
  },
  "49": {
    "r": 0,
    "g": 255,
    "b": 175
  },
  "50": {
    "r": 0,
    "g": 255,
    "b": 215
  },
  "51": {
    "r": 0,
    "g": 255,
    "b": 255
  },
  "52": {
    "r": 95,
    "g": 0,
    "b": 0
  },
  "53": {
    "r": 95,
    "g": 0,
    "b": 95
  },
  "54": {
    "r": 95,
    "g": 0,
    "b": 135
  },
  "55": {
    "r": 95,
    "g": 0,
    "b": 175
  },
  "56": {
    "r": 95,
    "g": 0,
    "b": 215
  },
  "57": {
    "r": 95,
    "g": 0,
    "b": 255
  },
  "58": {
    "r": 95,
    "g": 95,
    "b": 0
  },
  "59": {
    "r": 95,
    "g": 95,
    "b": 95
  },
  "60": {
    "r": 95,
    "g": 95,
    "b": 135
  },
  "61": {
    "r": 95,
    "g": 95,
    "b": 175
  },
  "62": {
    "r": 95,
    "g": 95,
    "b": 215
  },
  "63": {
    "r": 95,
    "g": 95,
    "b": 255
  },
  "64": {
    "r": 95,
    "g": 135,
    "b": 0
  },
  "65": {
    "r": 95,
    "g": 135,
    "b": 95
  },
  "66": {
    "r": 95,
    "g": 135,
    "b": 135
  },
  "67": {
    "r": 95,
    "g": 135,
    "b": 175
  },
  "68": {
    "r": 95,
    "g": 135,
    "b": 215
  },
  "69": {
    "r": 95,
    "g": 135,
    "b": 255
  },
  "70": {
    "r": 95,
    "g": 175,
    "b": 0
  },
  "71": {
    "r": 95,
    "g": 175,
    "b": 95
  },
  "72": {
    "r": 95,
    "g": 175,
    "b": 135
  },
  "73": {
    "r": 95,
    "g": 175,
    "b": 175
  },
  "74": {
    "r": 95,
    "g": 175,
    "b": 215
  },
  "75": {
    "r": 95,
    "g": 175,
    "b": 255
  },
  "76": {
    "r": 95,
    "g": 215,
    "b": 0
  },
  "77": {
    "r": 95,
    "g": 215,
    "b": 95
  },
  "78": {
    "r": 95,
    "g": 215,
    "b": 135
  },
  "79": {
    "r": 95,
    "g": 215,
    "b": 175
  },
  "80": {
    "r": 95,
    "g": 215,
    "b": 215
  },
  "81": {
    "r": 95,
    "g": 215,
    "b": 255
  },
  "82": {
    "r": 95,
    "g": 255,
    "b": 0
  },
  "83": {
    "r": 95,
    "g": 255,
    "b": 95
  },
  "84": {
    "r": 95,
    "g": 255,
    "b": 135
  },
  "85": {
    "r": 95,
    "g": 255,
    "b": 175
  },
  "86": {
    "r": 95,
    "g": 255,
    "b": 215
  },
  "87": {
    "r": 95,
    "g": 255,
    "b": 255
  },
  "88": {
    "r": 135,
    "g": 0,
    "b": 0
  },
  "89": {
    "r": 135,
    "g": 0,
    "b": 95
  },
  "90": {
    "r": 135,
    "g": 0,
    "b": 135
  },
  "91": {
    "r": 135,
    "g": 0,
    "b": 175
  },
  "92": {
    "r": 135,
    "g": 0,
    "b": 215
  },
  "93": {
    "r": 135,
    "g": 0,
    "b": 255
  },
  "94": {
    "r": 135,
    "g": 95,
    "b": 0
  },
  "95": {
    "r": 135,
    "g": 95,
    "b": 95
  },
  "96": {
    "r": 135,
    "g": 95,
    "b": 135
  },
  "97": {
    "r": 135,
    "g": 95,
    "b": 175
  },
  "98": {
    "r": 135,
    "g": 95,
    "b": 215
  },
  "99": {
    "r": 135,
    "g": 95,
    "b": 255
  },
  "100": {
    "r": 135,
    "g": 135,
    "b": 0
  },
  "101": {
    "r": 135,
    "g": 135,
    "b": 95
  },
  "102": {
    "r": 135,
    "g": 135,
    "b": 135
  },
  "103": {
    "r": 135,
    "g": 135,
    "b": 175
  },
  "104": {
    "r": 135,
    "g": 135,
    "b": 215
  },
  "105": {
    "r": 135,
    "g": 135,
    "b": 255
  },
  "106": {
    "r": 135,
    "g": 175,
    "b": 0
  },
  "107": {
    "r": 135,
    "g": 175,
    "b": 95
  },
  "108": {
    "r": 135,
    "g": 175,
    "b": 135
  },
  "109": {
    "r": 135,
    "g": 175,
    "b": 175
  },
  "110": {
    "r": 135,
    "g": 175,
    "b": 215
  },
  "111": {
    "r": 135,
    "g": 175,
    "b": 255
  },
  "112": {
    "r": 135,
    "g": 215,
    "b": 0
  },
  "113": {
    "r": 135,
    "g": 215,
    "b": 95
  },
  "114": {
    "r": 135,
    "g": 215,
    "b": 135
  },
  "115": {
    "r": 135,
    "g": 215,
    "b": 175
  },
  "116": {
    "r": 135,
    "g": 215,
    "b": 215
  },
  "117": {
    "r": 135,
    "g": 215,
    "b": 255
  },
  "118": {
    "r": 135,
    "g": 255,
    "b": 0
  },
  "119": {
    "r": 135,
    "g": 255,
    "b": 95
  },
  "120": {
    "r": 135,
    "g": 255,
    "b": 135
  },
  "121": {
    "r": 135,
    "g": 255,
    "b": 175
  },
  "122": {
    "r": 135,
    "g": 255,
    "b": 215
  },
  "123": {
    "r": 135,
    "g": 255,
    "b": 255
  },
  "124": {
    "r": 175,
    "g": 0,
    "b": 0
  },
  "125": {
    "r": 175,
    "g": 0,
    "b": 95
  },
  "126": {
    "r": 175,
    "g": 0,
    "b": 135
  },
  "127": {
    "r": 175,
    "g": 0,
    "b": 175
  },
  "128": {
    "r": 175,
    "g": 0,
    "b": 215
  },
  "129": {
    "r": 175,
    "g": 0,
    "b": 255
  },
  "130": {
    "r": 175,
    "g": 95,
    "b": 0
  },
  "131": {
    "r": 175,
    "g": 95,
    "b": 95
  },
  "132": {
    "r": 175,
    "g": 95,
    "b": 135
  },
  "133": {
    "r": 175,
    "g": 95,
    "b": 175
  },
  "134": {
    "r": 175,
    "g": 95,
    "b": 215
  },
  "135": {
    "r": 175,
    "g": 95,
    "b": 255
  },
  "136": {
    "r": 175,
    "g": 135,
    "b": 0
  },
  "137": {
    "r": 175,
    "g": 135,
    "b": 95
  },
  "138": {
    "r": 175,
    "g": 135,
    "b": 135
  },
  "139": {
    "r": 175,
    "g": 135,
    "b": 175
  },
  "140": {
    "r": 175,
    "g": 135,
    "b": 215
  },
  "141": {
    "r": 175,
    "g": 135,
    "b": 255
  },
  "142": {
    "r": 175,
    "g": 175,
    "b": 0
  },
  "143": {
    "r": 175,
    "g": 175,
    "b": 95
  },
  "144": {
    "r": 175,
    "g": 175,
    "b": 135
  },
  "145": {
    "r": 175,
    "g": 175,
    "b": 175
  },
  "146": {
    "r": 175,
    "g": 175,
    "b": 215
  },
  "147": {
    "r": 175,
    "g": 175,
    "b": 255
  },
  "148": {
    "r": 175,
    "g": 215,
    "b": 0
  },
  "149": {
    "r": 175,
    "g": 215,
    "b": 95
  },
  "150": {
    "r": 175,
    "g": 215,
    "b": 135
  },
  "151": {
    "r": 175,
    "g": 215,
    "b": 175
  },
  "152": {
    "r": 175,
    "g": 215,
    "b": 215
  },
  "153": {
    "r": 175,
    "g": 215,
    "b": 255
  },
  "154": {
    "r": 175,
    "g": 255,
    "b": 0
  },
  "155": {
    "r": 175,
    "g": 255,
    "b": 95
  },
  "156": {
    "r": 175,
    "g": 255,
    "b": 135
  },
  "157": {
    "r": 175,
    "g": 255,
    "b": 175
  },
  "158": {
    "r": 175,
    "g": 255,
    "b": 215
  },
  "159": {
    "r": 175,
    "g": 255,
    "b": 255
  },
  "160": {
    "r": 215,
    "g": 0,
    "b": 0
  },
  "161": {
    "r": 215,
    "g": 0,
    "b": 95
  },
  "162": {
    "r": 215,
    "g": 0,
    "b": 135
  },
  "163": {
    "r": 215,
    "g": 0,
    "b": 175
  },
  "164": {
    "r": 215,
    "g": 0,
    "b": 215
  },
  "165": {
    "r": 215,
    "g": 0,
    "b": 255
  },
  "166": {
    "r": 215,
    "g": 95,
    "b": 0
  },
  "167": {
    "r": 215,
    "g": 95,
    "b": 95
  },
  "168": {
    "r": 215,
    "g": 95,
    "b": 135
  },
  "169": {
    "r": 215,
    "g": 95,
    "b": 175
  },
  "170": {
    "r": 215,
    "g": 95,
    "b": 215
  },
  "171": {
    "r": 215,
    "g": 95,
    "b": 255
  },
  "172": {
    "r": 215,
    "g": 135,
    "b": 0
  },
  "173": {
    "r": 215,
    "g": 135,
    "b": 95
  },
  "174": {
    "r": 215,
    "g": 135,
    "b": 135
  },
  "175": {
    "r": 215,
    "g": 135,
    "b": 175
  },
  "176": {
    "r": 215,
    "g": 135,
    "b": 215
  },
  "177": {
    "r": 215,
    "g": 135,
    "b": 255
  },
  "178": {
    "r": 215,
    "g": 175,
    "b": 0
  },
  "179": {
    "r": 215,
    "g": 175,
    "b": 95
  },
  "180": {
    "r": 215,
    "g": 175,
    "b": 135
  },
  "181": {
    "r": 215,
    "g": 175,
    "b": 175
  },
  "182": {
    "r": 215,
    "g": 175,
    "b": 215
  },
  "183": {
    "r": 215,
    "g": 175,
    "b": 255
  },
  "184": {
    "r": 215,
    "g": 215,
    "b": 0
  },
  "185": {
    "r": 215,
    "g": 215,
    "b": 95
  },
  "186": {
    "r": 215,
    "g": 215,
    "b": 135
  },
  "187": {
    "r": 215,
    "g": 215,
    "b": 175
  },
  "188": {
    "r": 215,
    "g": 215,
    "b": 215
  },
  "189": {
    "r": 215,
    "g": 215,
    "b": 255
  },
  "190": {
    "r": 215,
    "g": 255,
    "b": 0
  },
  "191": {
    "r": 215,
    "g": 255,
    "b": 95
  },
  "192": {
    "r": 215,
    "g": 255,
    "b": 135
  },
  "193": {
    "r": 215,
    "g": 255,
    "b": 175
  },
  "194": {
    "r": 215,
    "g": 255,
    "b": 215
  },
  "195": {
    "r": 215,
    "g": 255,
    "b": 255
  },
  "196": {
    "r": 255,
    "g": 0,
    "b": 0
  },
  "197": {
    "r": 255,
    "g": 0,
    "b": 95
  },
  "198": {
    "r": 255,
    "g": 0,
    "b": 135
  },
  "199": {
    "r": 255,
    "g": 0,
    "b": 175
  },
  "200": {
    "r": 255,
    "g": 0,
    "b": 215
  },
  "201": {
    "r": 255,
    "g": 0,
    "b": 255
  },
  "202": {
    "r": 255,
    "g": 95,
    "b": 0
  },
  "203": {
    "r": 255,
    "g": 95,
    "b": 95
  },
  "204": {
    "r": 255,
    "g": 95,
    "b": 135
  },
  "205": {
    "r": 255,
    "g": 95,
    "b": 175
  },
  "206": {
    "r": 255,
    "g": 95,
    "b": 215
  },
  "207": {
    "r": 255,
    "g": 95,
    "b": 255
  },
  "208": {
    "r": 255,
    "g": 135,
    "b": 0
  },
  "209": {
    "r": 255,
    "g": 135,
    "b": 95
  },
  "210": {
    "r": 255,
    "g": 135,
    "b": 135
  },
  "211": {
    "r": 255,
    "g": 135,
    "b": 175
  },
  "212": {
    "r": 255,
    "g": 135,
    "b": 215
  },
  "213": {
    "r": 255,
    "g": 135,
    "b": 255
  },
  "214": {
    "r": 255,
    "g": 175,
    "b": 0
  },
  "215": {
    "r": 255,
    "g": 175,
    "b": 95
  },
  "216": {
    "r": 255,
    "g": 175,
    "b": 135
  },
  "217": {
    "r": 255,
    "g": 175,
    "b": 175
  },
  "218": {
    "r": 255,
    "g": 175,
    "b": 215
  },
  "219": {
    "r": 255,
    "g": 175,
    "b": 255
  },
  "220": {
    "r": 255,
    "g": 215,
    "b": 0
  },
  "221": {
    "r": 255,
    "g": 215,
    "b": 95
  },
  "222": {
    "r": 255,
    "g": 215,
    "b": 135
  },
  "223": {
    "r": 255,
    "g": 215,
    "b": 175
  },
  "224": {
    "r": 255,
    "g": 215,
    "b": 215
  },
  "225": {
    "r": 255,
    "g": 215,
    "b": 255
  },
  "226": {
    "r": 255,
    "g": 255,
    "b": 0
  },
  "227": {
    "r": 255,
    "g": 255,
    "b": 95
  },
  "228": {
    "r": 255,
    "g": 255,
    "b": 135
  },
  "229": {
    "r": 255,
    "g": 255,
    "b": 175
  },
  "230": {
    "r": 255,
    "g": 255,
    "b": 215
  },
  "231": {
    "r": 255,
    "g": 255,
    "b": 255
  },
  "232": {
    "r": 8,
    "g": 8,
    "b": 8
  },
  "233": {
    "r": 18,
    "g": 18,
    "b": 18
  },
  "234": {
    "r": 28,
    "g": 28,
    "b": 28
  },
  "235": {
    "r": 38,
    "g": 38,
    "b": 38
  },
  "236": {
    "r": 48,
    "g": 48,
    "b": 48
  },
  "237": {
    "r": 58,
    "g": 58,
    "b": 58
  },
  "238": {
    "r": 68,
    "g": 68,
    "b": 68
  },
  "239": {
    "r": 78,
    "g": 78,
    "b": 78
  },
  "240": {
    "r": 88,
    "g": 88,
    "b": 88
  },
  "241": {
    "r": 98,
    "g": 98,
    "b": 98
  },
  "242": {
    "r": 108,
    "g": 108,
    "b": 108
  },
  "243": {
    "r": 118,
    "g": 118,
    "b": 118
  },
  "244": {
    "r": 128,
    "g": 128,
    "b": 128
  },
  "245": {
    "r": 138,
    "g": 138,
    "b": 138
  },
  "246": {
    "r": 148,
    "g": 148,
    "b": 148
  },
  "247": {
    "r": 158,
    "g": 158,
    "b": 158
  },
  "248": {
    "r": 168,
    "g": 168,
    "b": 168
  },
  "249": {
    "r": 178,
    "g": 178,
    "b": 178
  },
  "250": {
    "r": 188,
    "g": 188,
    "b": 188
  },
  "251": {
    "r": 198,
    "g": 198,
    "b": 198
  },
  "252": {
    "r": 208,
    "g": 208,
    "b": 208
  },
  "253": {
    "r": 218,
    "g": 218,
    "b": 218
  },
  "254": {
    "r": 228,
    "g": 228,
    "b": 228
  },
  "255": {
    "r": 238,
    "g": 238,
    "b": 238
  }
};
exports.Colors255 = Colors255;
  })();
});

require.register("subspace-console/ansi/Parser.js", function(exports, require, module) {
  require = __makeRelativeRequire(require, {}, "subspace-console");
  (function() {
    "use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Parser = void 0;

var _Actions = require("sixgram/Actions");

var _Parser = require("sixgram/Parser");

var tokens = {
  reset: /\u001b\[(0);?m/,
  graphics: /\u001b\[(\d+);?(\d+)?;?([\d;]*)?./,
  escaped: /\\([^e])/,
  characters: /[\s\S]+?(?=\x1B|$)/
};
var modes = {
  normal: {
    reset: [_Actions.IGNORE, _Actions.ENTER, _Actions.LEAVE],
    escaped: [_Actions.IGNORE, _Actions.ENTER, _Actions.LEAVE],
    graphics: [_Actions.IGNORE, _Actions.ENTER, _Actions.LEAVE],
    characters: [_Actions.INSERT]
  }
};
var Parser = new _Parser.Parser(tokens, modes);
exports.Parser = Parser;
  })();
});

require.register("subspace-console/ansi/Renderer.js", function(exports, require, module) {
  require = __makeRelativeRequire(require, {}, "subspace-console");
  (function() {
    "use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Renderer = void 0;

var _Renderer = require("sixgram/Renderer");

var _pallete = require("./pallete");

var _Colors = require("./Colors255");

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var audio = typeof window.AudioContext === 'function' ? new window.AudioContext() : false;

if (audio) {
  var _gainNode = audio.createGain();

  _gainNode.connect(audio.destination);

  _gainNode.gain.value = 10 * 0.01;
}

var Renderer = /*#__PURE__*/function (_BaseRenderer) {
  _inherits(Renderer, _BaseRenderer);

  var _super = _createSuper(Renderer);

  function Renderer() {
    var _this;

    _classCallCheck(this, Renderer);

    _this = _super.call(this, {
      normal: function normal(chunk, parent) {
        return _this.setGraphicsMode(chunk, parent);
      }
    });

    _defineProperty(_assertThisInitialized(_this), "style", {});

    return _this;
  }

  _createClass(Renderer, [{
    key: "reset",
    value: function reset() {
      for (var _i = 0, _Object$entries = Object.entries(this.style); _i < _Object$entries.length; _i++) {
        var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 1),
            k = _Object$entries$_i[0];

        delete this.style[k];
      }
    }
  }, {
    key: "beep",
    value: function beep() {
      if (!audio) {
        return;
      }

      var oscillator = audio.createOscillator();
      oscillator.connect(gainNode);
      oscillator.frequency.value = 840;
      oscillator.type = "square";
      oscillator.start(audio.currentTime);
      oscillator.stop(audio.currentTime + 200 * 0.001);
    }
  }, {
    key: "setGraphicsMode",
    value: function setGraphicsMode(chunk, parent) {
      if (typeof chunk === 'string') {
        if (chunk === '') {
          return false;
        }

        var styleString = '';

        for (var _i2 = 0, _Object$entries2 = Object.entries(this.style); _i2 < _Object$entries2.length; _i2++) {
          var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i2], 2),
              key = _Object$entries2$_i[0],
              val = _Object$entries2$_i[1];

          styleString += "".concat(key, ": ").concat(val, "; ");
        }

        return "<span class = \"ansi\" style = \"".concat(styleString, "\">").concat(chunk, "</span>");
      }

      if (_typeof(chunk) === 'object') {
        if (chunk.type === 'escaped' && chunk.groups[0] === 'a') {
          this.beep();
        }

        if (chunk.type === 'graphics' || chunk.type === 'reset') {
          for (var g = 0; g < chunk.groups.length; g++) {
            var group = Number(chunk.groups[g]);

            if (chunk.groups[g] === '') {
              return false;
            }

            switch (group) {
              case 0:
                for (var _key in this.style) {
                  delete this.style[_key];
                }

                break;

              case 1:
                this.style['filter'] = 'contrast(1.25)'; // this.style['text-shadow'] = '1px 1px 1px rgba(0,0,0,0.25), 0px 0px 1px rgba(0,0,0,0.125)';

                this.style['font-weight'] = 'bold';
                this.style['opacity'] = 1;
                break;

              case 2:
                this.style['filter'] = 'brightness(0.85)';
                this.style['font-weight'] = 'light';
                this.style['opacity'] = 0.75;
                break;

              case 3:
                this.style['font-style'] = 'italic';
                break;

              case 4:
                this.style['text-decoration'] = 'underline';
                break;

              case 5:
                this.style['animation'] = 'var(--ansiBlink)';
                break;

              case 7:
                this.style['filter'] = 'invert(1)';
                break;

              case 8:
                this.style['filter'] = 'contrast(0.5)';
                this.style['opacity'] = 0.1;
                break;

              case 9:
                this.style['text-decoration'] = 'line-through';
                break;

              case 10:
                this.style['font-family'] = 'var(--base-font))';
                break;

              case 11:
              case 12:
              case 13:
              case 14:
              case 15:
              case 16:
              case 17:
              case 18:
              case 19:
                this.style['font-family'] = "var(--alt-font-no-".concat(group, ")");
                break;

              case 20:
                this.style['font-family'] = 'var(--alt-font-fraktur)';
                this.style['font-size'] = '1.1rem';
                break;

              case 21:
                this.style['font-weight'] = 'initial';
                break;

              case 22:
                this.style['font-weight'] = 'initial';
                break;

              case 23:
                this.style['font-weight'] = 'initial';
                this.style['font-style'] = 'initial';
                break;

              case 24:
                this.style['text-decoration'] = 'none';
                this.style['font-family'] = 'sans-serif';
                this.style['font-size'] = '12pt';
                break;

              case 25:
                this.style['animation'] = 'none';
                break;

              case 26:
                this.style['text-transform'] = 'full-width';
                break;

              case 27:
                this.style['filter'] = 'initial';
                break;

              case 28:
                this.style['opacity'] = 'initial';
                break;

              case 29:
                this.style['text-decoration'] = 'initial';
                break;

              case 30:
                this.style['color'] = _pallete.pallete.black;
                break;

              case 31:
                this.style['color'] = _pallete.pallete.red;
                break;

              case 32:
                this.style['color'] = _pallete.pallete.green;
                break;

              case 33:
                this.style['color'] = _pallete.pallete.yellow;
                break;

              case 34:
                this.style['color'] = _pallete.pallete.blue;
                break;

              case 35:
                this.style['color'] = _pallete.pallete.magenta;
                break;

              case 36:
                this.style['color'] = _pallete.pallete.cyan;
                break;

              case 37:
                this.style['color'] = _pallete.pallete.white;
                break;

              case 38:
                if (chunk.groups[1 + g] == 2) {
                  var _chunk$groups$split = chunk.groups[2 + g].split(';'),
                      _chunk$groups$split2 = _slicedToArray(_chunk$groups$split, 3),
                      rd = _chunk$groups$split2[0],
                      gr = _chunk$groups$split2[1],
                      bl = _chunk$groups$split2[2];

                  this.style['color'] = "rgb(".concat(rd, ",").concat(gr, ",").concat(bl, ")");
                }

                if (chunk.groups[1 + g] == 5) {
                  var _Colors255$Number = _Colors.Colors255[Number(chunk.groups[2 + g])],
                      _rd = _Colors255$Number.r,
                      _gr = _Colors255$Number.g,
                      _bl = _Colors255$Number.b;

                  this.style['color'] = "rgb(".concat(_rd, ",").concat(_gr, ",").concat(_bl, ")");
                }

                g += 2;
                break;

              case 39:
                this.style['color'] = 'var(--fgColor)';
                break;

              case 40:
                this.style['background-color'] = _pallete.pallete.black;
                break;

              case 41:
                this.style['background-color'] = _pallete.pallete.red;
                break;

              case 42:
                this.style['background-color'] = _pallete.pallete.green;
                break;

              case 43:
                this.style['background-color'] = _pallete.pallete.yellow;
                break;

              case 44:
                this.style['background-color'] = _pallete.pallete.blue;
                break;

              case 45:
                this.style['background-color'] = _pallete.pallete.magenta;
                break;

              case 46:
                this.style['background-color'] = _pallete.pallete.cyan;
                break;

              case 47:
                this.style['background-color'] = _pallete.pallete.white;
                break;

              case 48:
                if (chunk.groups[1 + g] == 2) {
                  var _chunk$groups$split3 = chunk.groups[2 + g].split(';'),
                      _chunk$groups$split4 = _slicedToArray(_chunk$groups$split3, 3),
                      _rd2 = _chunk$groups$split4[0],
                      _gr2 = _chunk$groups$split4[1],
                      _bl2 = _chunk$groups$split4[2];

                  this.style['background-color'] = "rgb(".concat(_rd2, ",").concat(_gr2, ",").concat(_bl2, ")");
                }

                if (chunk.groups[1 + g] == 5) {
                  var _Colors255$Number2 = _Colors.Colors255[Number(chunk.groups[2 + g])],
                      _rd3 = _Colors255$Number2.r,
                      _gr3 = _Colors255$Number2.g,
                      _bl3 = _Colors255$Number2.b;

                  this.style['background-color'] = "rgb(".concat(_rd3, ",").concat(_gr3, ",").concat(_bl3, ")");
                }

                g += 2;
                break;

              case 49:
                this.style['background-color'] = 'var(--bgColor)';
                break;

              case 50:
                this.style['text-transform'] = 'initial';
                break;

              case 51:
                this.style['border'] = '1px solid currentColor';
                break;

              case 52:
                this.style['border'] = '1px solid currentColor';
                this.style['border-radius'] = '1em';
                break;

              case 53:
                this.style['text-decoration'] = 'overline';
                break;

              case 54:
                this.style['border'] = 'initial';
                break;

              case 55:
                this.style['border'] = 'initial';
                break;
            }
          }
        }

        return false;
      }
    }
  }]);

  return Renderer;
}(_Renderer.Renderer);

exports.Renderer = Renderer;
  })();
});

require.register("subspace-console/ansi/pallete.js", function(exports, require, module) {
  require = __makeRelativeRequire(require, {}, "subspace-console");
  (function() {
    "use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.pallete = void 0;
var pallete = {
  black: 'var(--ansi-black, #000000)',
  dBlack: 'var(--ansi-black-dark, #343434)',
  bBlack: 'var(--ansi-black-light, #888888)',
  red: 'var(--ansi-red, #c0002c)',
  dRed: 'var(--ansi-red-dark, #4a132b)',
  bRed: 'var(--ansi-red-light, #ff7869)',
  green: 'var(--ansi-green, #80a763)',
  dGreen: 'var(--ansi-green-dark, #326f38)',
  bGreen: 'var(--ansi-green-light, #93d393)',
  yellow: 'var(--ansi-yellow, #e3c651)',
  dYellow: 'var(--ansi-yellow-dark, #baa447)',
  bYellow: 'var(--ansi-yellow-light, #fdc253)',
  blue: 'var(--ansi-blue, #5485c0)',
  dBlue: 'var(--ansi-blue-dark, #38577d)',
  bBlue: 'var(--ansi-blue-light, #77aff2)',
  magenta: 'var(--ansi-magenta, #C61B6E)',
  dMagenta: 'var(--ansi-magenta-dark, #935894)',
  bMagenta: 'var(--ansi-magenta-light, #bf83c0)',
  cyan: 'var(--ansi-cyan, #57c2c0)',
  dCyan: 'var(--ansi-cyan-dark, #2d5695)',
  bCyan: 'var(--ansi-cyan-light, #cef6f5)',
  white: 'var(--ansi-cyan, #e0e0e0)',
  dWhite: 'var(--ansi-cyan-dark, #b0b0b0)',
  bWhite: 'var(--ansi-cyan-light, #ffffff)'
};
exports.pallete = pallete;
  })();
});

require.register("subspace-console/mixin/Target.js", function(exports, require, module) {
  require = __makeRelativeRequire(require, {}, "subspace-console");
  (function() {
    "use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Target = void 0;

var _Mixin = require("curvature/base/Mixin");

var _Target;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var target = Symbol('target');
var index = 0;
var Target = (_Target = {}, _defineProperty(_Target, _Mixin.Mixin.Constructor, function () {
  try {
    this[target] = new EventTarget();
  } catch (error) {
    this[target] = document.createDocumentFragment();
  }

  this[target].x = index++;
}), _defineProperty(_Target, "dispatchEvent", function dispatchEvent() {
  var _this$target;

  (_this$target = this[target]).dispatchEvent.apply(_this$target, arguments);
}), _defineProperty(_Target, "addEventListener", function addEventListener() {
  var _this$target2;

  (_this$target2 = this[target]).addEventListener.apply(_this$target2, arguments);
}), _defineProperty(_Target, "removeEventListener", function removeEventListener() {
  var _this$target3;

  (_this$target3 = this[target]).removeEventListener.apply(_this$target3, arguments);
}), _Target);
exports.Target = Target;
  })();
});

require.register("subspace-console/mixin/TaskSignals.js", function(exports, require, module) {
  require = __makeRelativeRequire(require, {}, "subspace-console");
  (function() {
    "use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TaskSignals = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var TaskSignals = /*#__PURE__*/function () {
  function TaskSignals() {
    _classCallCheck(this, TaskSignals);
  }

  _createClass(TaskSignals, [{
    key: 'signal::kill',
    value: function signalKill() {
      console.log('KILL!');
      this.status > 0 ? this[Reject]() : this[Accept]();
    }
  }, {
    key: 'signal::close',
    value: function signalClose() {
      if (this.dispatchEvent(new CustomEvent('error', {
        detail: detail
      }))) {
        this.status > 0 ? this[Reject]() : this[Accept]();
      }
    }
  }]);

  return TaskSignals;
}();

exports.TaskSignals = TaskSignals;

_defineProperty(TaskSignals, "KILL", 'kill');

_defineProperty(TaskSignals, "CLOSE", 'close');
  })();
});

require.register("subspace-console/view/EchoMessage.js", function(exports, require, module) {
  require = __makeRelativeRequire(require, {}, "subspace-console");
  (function() {
    "use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EchoMessage = void 0;

var _View2 = require("curvature/base/View");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var EchoMessage = /*#__PURE__*/function (_View) {
  _inherits(EchoMessage, _View);

  var _super = _createSuper(EchoMessage);

  function EchoMessage() {
    var _this;

    var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, EchoMessage);

    _this = _super.call(this, args);
    _this.args.prompt = _this.args.prompt || '<<';
    _this.template = "<span>[[prompt]]&nbsp;</span><span class = \"text\">[[message]]</span>";
    return _this;
  }

  return EchoMessage;
}(_View2.View);

exports.EchoMessage = EchoMessage;
  })();
});

require.register("subspace-console/view/MeltingText.js", function(exports, require, module) {
  require = __makeRelativeRequire(require, {}, "subspace-console");
  (function() {
    "use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MeltingText = void 0;

var _View = require("curvature/base/View");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var MeltingText = /*#__PURE__*/function (_BaseView) {
  _inherits(MeltingText, _BaseView);

  var _super = _createSuper(MeltingText);

  function MeltingText(args) {
    var _this;

    _classCallCheck(this, MeltingText);

    _this = _super.call(this, args);
    _this.last = _this.init = Date.now();
    _this.charUp = [// '\u030d', /*     ̍     */		'\u030e', /*     ̎     */		'\u0304', /*     ̄     */		'\u0305', /*     ̅     */
    // '\u033f', /*     ̿     */		'\u0311', /*     ̑     */		'\u0306', /*     ̆     */		'\u0310', /*     ̐     */
    // '\u0352', /*     ͒     */		'\u0357', /*     ͗     */		'\u0351', /*     ͑     */		'\u0307', /*     ̇     */
    // '\u0308', /*     ̈     */		'\u030a', /*     ̊     */		'\u0342', /*     ͂     */		'\u0343', /*     ̓     */
    "\u0344",
    /*     ̈́     */

    /*	'\u034a', /*     ͊     */

    /*	'\u034b', /*     ͋     */

    /*	'\u034c', /*     ͌     */
    "\u0303",
    /*     ̃     */

    /*	'\u0302', /*     ̂     */

    /*	'\u030c', /*     ̌     */

    /*	'\u0350', /*     ͐     */
    "\u0300"
    /*     ̀     */
    //	'\u0301', /*     ́     */		'\u030b', /*     ̋     */		'\u030f', /*     ̏     */
    // '\u0312', /*     ̒     */		'\u0313', /*     ̓     */		'\u0314', /*     ̔     */		'\u033d', /*     ̽     */
    // '\u0309', /*     ̉     */		'\u0363', /*     ͣ     */		'\u0364', /*     ͤ     */		'\u0365', /*     ͥ     */
    // '\u0366', /*     ͦ     */		'\u0367', /*     ͧ     */		'\u0368', /*     ͨ     */		'\u0369', /*     ͩ     */
    // '\u036a', /*     ͪ     */		'\u036b', /*     ͫ     */		'\u036c', /*     ͬ     */		'\u036d', /*     ͭ     */
    // '\u036e', /*     ͮ     */		'\u036f', /*     ͯ     */		'\u033e', /*     ̾     */		'\u035b', /*     ͛     */
    ];
    _this.charMid = ["\u0315",
    /*     ̕     */
    "\u031B",
    /*     ̛     */
    "\u0340",
    /*     ̀     */
    "\u0341",
    /*     ́     */
    "\u0358",
    /*     ͘     */
    "\u0321",
    /*     ̡     */
    "\u0322",
    /*     ̢     */
    "\u0327",
    /*     ̧     */
    "\u0328",
    /*     ̨     */
    "\u0334",
    /*     ̴     */
    "\u0335",
    /*     ̵     */
    "\u0336",
    /*     ̶     */
    "\u034F",
    /*     ͏     */
    "\u035C",
    /*     ͜     */
    "\u035D",
    /*     ͝     */
    "\u035E",
    /*     ͞     */
    "\u035F",
    /*     ͟     */
    "\u0360",
    /*     ͠     */

    /*'\u0362',      ͢     */
    "\u0338",
    /*     ̸     */
    "\u0337",
    /*     ̷     */
    "\u0361"
    /*     ͡     */

    /*'\u0489'     ҉_     */
    ];
    _this.charDown = [// '\u0316', /*     ̖     */		'\u0317', /*     ̗     */		'\u0318', /*     ̘     */		'\u0319', /*     ̙     */
    // '\u0316', /*     ̖     */		'\u0317', /*     ̗     */		'\u0318', /*     ̘     */		'\u0319', /*     ̙     */
    // '\u0320', /*     ̠     */		'\u0324', /*     ̤     */		'\u0325', /*     ̥     */		'\u0326', /*     ̦     */
    // '\u0329', /*     ̩     */		'\u032a', /*     ̪     */		'\u032b', /*     ̫     */		'\u032c', /*     ̬     */
    // '\u032d', /*     ̭     */		'\u032e', /*     ̮     */		'\u032f', /*     ̯     */		'\u0330', /*     ̰     */
    // '\u0331', /*     ̱     */		'\u0332', /*     ̲     */		'\u0333', /*     ̳     */		'\u0339', /*     ̹     */
    "\u033A",
    /*     ̺     */
    "\u033B",
    /*     ̻     */
    "\u033C",
    /*     ̼     */
    "\u0345"
    /*     ͅ     */
    //'\u0347', /*     ͇     */		'\u0348', /*     ͈     */		'\u0349', /*     ͉     */		'\u034d', /*     ͍     */
    //'\u034e', /*     ͎     */		'\u0353', /*     ͓     */		'\u0354', /*     ͔     */		'\u0355', /*     ͕     */
    // '\u0356', /*     ͖     */		'\u0359', /*     ͙     */		'\u035a', /*     ͚     */		'\u0323' /*     ̣     */
    ];
    _this.template = "\n\t\t\t<div cv-bind = \"output\" class = \"melting\"></div>\n\t\t";
    _this.args.input = "Magic is no more than the art of employing consciously invisible means to produce visible effects. Will, love, and imagination are magic powers that everyone possesses; and whoever knows how to develop them to their fullest extent is a magician. Magic has but one dogma, namely, that the seen is the measure of the unseen\n"; // this.args.input      = 'anything';

    _this.args.output = 'uh.';
    _this.corruptors = [];
    _this.maxMaxCorrupt = 25;
    _this.maxCorrupt = 0;
    _this.type = '';

    _this.onFrame(function () {
      _this.typewriter(_this.args.input);
    });

    _this.onInterval(16 * 4, function () {
      var selection = window.getSelection();

      if (selection.anchorOffset !== selection.focusOffset) {
        return;
      }

      if (selection.anchorNode !== selection.focusNode) {
        return;
      }

      _this.args.output = _this.corrupt(_this.type); // this.args.output = this.type;
    });

    _this.args.bindTo('input', function (v) {
      _this.type = '';
      _this.corruptors = [];
    });

    return _this;
  }

  _createClass(MeltingText, [{
    key: "age",
    value: function age() {
      return this.init - Date.now();
    }
  }, {
    key: "lastFrame",
    value: function lastFrame() {
      return this.last - Date.now();
    }
  }, {
    key: "corrupt",
    value: function corrupt(v) {
      if (v.length * 1.15 < this.args.input.length) {
        return this.type;
      }

      var chars = v.split('');

      var random = function random(x) {
        return parseInt(Math.random() * x);
      };

      if (random(1024) < 256 && this.maxCorrupt < this.maxMaxCorrupt) {
        this.maxCorrupt += 5;
      }

      for (var _i in chars) {
        this.corruptors[_i] = this.corruptors[_i] || [];

        if (chars[_i].match(/\W/)) {
          continue;
        }

        var charSets = [// this.charDown // Melt Slow
        this.charDown, this.charMid // Melt
        // this.charDown, this.charUp,   this.charMid, // Boil
        // this.charMid, this.charUp, // Burn
        // this.charMid // Simmer
        // this.charUp // Rain
        ];
        var charSet = charSets[random(charSets.length)];

        if (random(8192) < 1) {
          this.corruptors[_i].unshift(charSet[random(charSet.length)]);
        }

        if (this.corruptors[_i].length < this.maxCorrupt) {
          this.corruptors[_i].unshift(charSet[random(charSet.length)]);
        }

        if (random(2048) < 1 && this.maxCorrupt > 25) {
          this.corruptors[_i].splice(5 * random(5));
        }

        this.corruptors[_i].push(this.corruptors[_i].shift());
      }

      for (var i in chars) {
        if (this.corruptors[i]) {
          chars[i] += this.corruptors[i].join('');
        }
      }

      return chars.join('');
    }
  }, {
    key: "typewriter",
    value: function typewriter(v) {
      this.type = this.type || '';

      if (this.type !== v) {
        this.type += v.substr(this.type.length, 1);
        this.onTimeout(150, function () {
          var max = window.scrollY + window.innerHeight;

          if (document.body.scrollHeight > max) {
            window.scrollTo({
              top: document.body.scrollHeight,
              left: 0,
              behavior: 'smooth'
            });
          }
        });
      } else {
        return true;
      }

      return false;
    }
  }]);

  return MeltingText;
}(_View.View);

exports.MeltingText = MeltingText;
  })();
});
require.register("BackdropPalette.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BackdropPalette = void 0;
var _MarbleGarden = require("backdrop/MarbleGarden");
var _ProtoLabrynth = require("backdrop/ProtoLabrynth");
var _Industrial = require("backdrop/Industrial");
var _MysticCave = require("backdrop/MysticCave");
var _WestSideCloudy = require("backdrop/WestSideCloudy");
var _WestSideDay = require("backdrop/WestSideDay");
var _WestSide = require("backdrop/WestSide");
var _AngelIsland = require("backdrop/AngelIsland");
var _Wood = require("backdrop/Wood");
var _Underground = require("backdrop/Underground");
var _Moon = require("backdrop/Moon");
var _SouthRidge = require("backdrop/SouthRidge");
var _MushroomHill = require("backdrop/MushroomHill");
var _IceCap = require("backdrop/IceCap");
var _City = require("backdrop/City");
var _DarkClouds = require("backdrop/DarkClouds");
var _Overcast = require("backdrop/Overcast");
var _ScrapBrainDark = require("backdrop/ScrapBrainDark");
var _PhazonMines = require("backdrop/PhazonMines");
var _Desert = require("backdrop/Desert");
const BackdropPalette = {
  'west-side-cloudy': _WestSideCloudy.WestSideCloudy,
  'west-side-day': _WestSideDay.WestSideDay,
  'west-side': _WestSide.WestSide,
  'angel-island': _AngelIsland.AngelIsland,
  'wood': _Wood.Wood,
  'moon': _Moon.Moon,
  'south-ridge': _SouthRidge.SouthRidge,
  'proto-labrynth': _ProtoLabrynth.ProtoLabrynth,
  'marble-garden': _MarbleGarden.MarbleGarden,
  'industrial': _Industrial.Industrial,
  'mystic-cave': _MysticCave.MysticCave,
  'underground': _Underground.Underground,
  'mushroom-hill': _MushroomHill.MushroomHill,
  'ice-cap': _IceCap.IceCap,
  'city': _City.City,
  'dark-clouds': _DarkClouds.DarkClouds,
  'overcast': _Overcast.Overcast,
  'scrap-brain-dark': _ScrapBrainDark.ScrapBrainDark,
  'phazon-mines': _PhazonMines.PhazonMines,
  'desert': _Desert.Desert
};
exports.BackdropPalette = BackdropPalette;
});

;require.register("Classifier.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Classifier = void 0;
var _Mixin = require("curvature/base/Mixin");
var _EventTargetMixin = require("curvature/mixin/EventTargetMixin");
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let Classifier = /*#__PURE__*/function (_Mixin$with) {
  _inherits(Classifier, _Mixin$with);
  var _super = _createSuper(Classifier);
  function Classifier(criteria) {
    var _this;
    let comparator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : (criterion, item) => item instanceof criterion;
    _classCallCheck(this, Classifier);
    _this = _super.call(this);
    _this.compare = comparator;
    _this.index = new Map();
    for (const i in criteria) {
      _this.index.set(criteria[i], new Set());
    }
    return _this;
  }
  _createClass(Classifier, [{
    key: "add",
    value: function add(object) {
      const before = new CustomEvent('adding', {
        detail: {
          object: object
        }
      });
      if (!this.dispatchEvent(before)) {
        return;
      }
      const indexes = new Set();
      for (const _ref of this.index.entries()) {
        var _ref2 = _slicedToArray(_ref, 2);
        const index = _ref2[0];
        const list = _ref2[1];
        if (this.compare(index, object)) {
          indexes.add(index);
          list.add(object);
        }
      }
      const after = new CustomEvent('added', {
        detail: {
          object: object,
          indexes: indexes
        }
      });
      this.dispatchEvent(after);
    }
  }, {
    key: "remove",
    value: function remove(object) {
      const before = new CustomEvent('removing', {
        detail: {
          object: object
        }
      });
      if (!this.dispatchEvent(before)) {
        return;
      }
      const indexes = new Set();
      for (const _ref3 of this.index.entries()) {
        var _ref4 = _slicedToArray(_ref3, 2);
        const index = _ref4[0];
        const list = _ref4[1];
        if (this.compare(index, object)) {
          indexes.add(index);
          list.delete(object);
        }
      }
      const after = new CustomEvent('added', {
        detail: {
          object: object,
          indexes: indexes
        }
      });
      this.dispatchEvent(after);
    }
  }, {
    key: "clear",
    value: function clear() {
      this.index.clear();
    }
  }, {
    key: "get",
    value: function get(key) {
      return this.index.get(key);
    }
  }, {
    key: "count",
    value: function count(key) {
      return this.index.has(key) && this.get(key).size;
    }
  }, {
    key: "has",
    value: function has(key) {
      return !!this.count(key);
    }
  }]);
  return Classifier;
}(_Mixin.Mixin.with(_EventTargetMixin.EventTargetMixin));
exports.Classifier = Classifier;
});

;require.register("Menu/ButtonSelect.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ButtonSelect = void 0;
var _View2 = require("curvature/base/View");
var _CharacterString = require("../ui/CharacterString");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let ButtonSelect = /*#__PURE__*/function (_View) {
  _inherits(ButtonSelect, _View);
  var _super = _createSuper(ButtonSelect);
  function ButtonSelect() {
    var _this;
    _classCallCheck(this, ButtonSelect);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _defineProperty(_assertThisInitialized(_this), "template", '<div class = "button-select">[[prompt]] [[_button]] <button cv-on = "click:remove">exit</button></div>');
    // buttons  = ['⓿', '❶', '❷', '❸', '❹', '❺', '❻', '❼', '❽', '❾', '❿', '⓫', '↑', '↓', '←', '→'];
    _defineProperty(_assertThisInitialized(_this), "buttons", ['⓿', '❶', '❷', '❸', '❹', '❺', '❽', '❾', '❽', '❿', '⓫', null, '↑', '↓', '←', '→']);
    return _this;
  }
  _createClass(ButtonSelect, [{
    key: "onRendered",
    value: function onRendered(event) {
      this.args.prompt = new _CharacterString.CharacterString({
        value: 'Select a button!',
        font: 'small-menu-font'
      });
      this.args._button = new _CharacterString.CharacterString({
        value: '',
        font: 'small-menu-font'
      });
    }
  }, {
    key: "input",
    value: function input(controller) {
      for (const b in controller.buttons) {
        if (b > 100) {
          continue;
        }
        const button = controller.buttons[b];
        if (!button.pressure) {
          continue;
        }
        this.args._button.args.value = this.buttons[b];
        this.args.button = b;
      }
    }
  }]);
  return ButtonSelect;
}(_View2.View);
exports.ButtonSelect = ButtonSelect;
});

;require.register("Menu/CharacterPreview.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CharacterPreview = void 0;
var _View2 = require("curvature/base/View");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let CharacterPreview = /*#__PURE__*/function (_View) {
  _inherits(CharacterPreview, _View);
  var _super = _createSuper(CharacterPreview);
  function CharacterPreview() {
    var _this;
    _classCallCheck(this, CharacterPreview);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _defineProperty(_assertThisInitialized(_this), "preserve", true);
    _defineProperty(_assertThisInitialized(_this), "template", `<div class = "character-preview" data-character = "[[setting]]">
	<div class = "character"></div>
	<div class = "emeralds" cv-each = "emeralds:emerald">
		<img style = "--x:[[emerald.x]];--y:[[emerald.y]];" src = "/Sonic/emerald-[[emerald.type|suffix]][[emerald.color]]-mini.png" />
	</div>
	<div class = "rings"></div>
	<div class = "score"></div>
</div>`);
    return _this;
  }
  _createClass(CharacterPreview, [{
    key: "onAttached",
    value: function onAttached() {
      const type = 'super';
      const emeralds = this.args.emeralds = [{
        x: 0,
        y: 0,
        type: type,
        color: 'red-alt'
      }, {
        x: 0,
        y: 0,
        type: type,
        color: 'yellow'
      }, {
        x: 0,
        y: 0,
        type: type,
        color: 'green'
      }, {
        x: 0,
        y: 0,
        type: type,
        color: 'cyan'
      }, {
        x: 0,
        y: 0,
        type: type,
        color: 'white'
      } //
      , {
        x: 0,
        y: 0,
        type: type,
        color: 'purple'
      } //
      , {
        x: 0,
        y: 0,
        type: type,
        color: 'pink'
      } //
      ];

      // if(this.parent && this.parent.currentSave)
      // for(const storedEmerald of this.parent.currentSave.emeralds)
      // {
      // 	// this.args.emeralds.push({x: 0, y: 0, type, color: storedEmerald});
      // 	this.args.emeralds.push({x: 0, y: 0, color: storedEmerald});
      // }

      const spacing = emeralds.length;
      this.onFrame(() => {
        let e = 0;
        if (spacing) for (const emerald of emeralds) {
          const time = Date.now() / 400;
          const roll = e++ * (Math.PI * 2) / spacing + time;
          emerald.x = Math.cos(roll);
          emerald.y = Math.sin(roll);
        }
      });
    }
  }, {
    key: "suffix",
    value: function suffix(type) {
      return type ? `${type}-` : ``;
    }
  }]);
  return CharacterPreview;
}(_View2.View);
exports.CharacterPreview = CharacterPreview;
});

;require.register("Menu/DemoMenu.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DemoMenu = void 0;
var _ReplayDatabase = require("../replay/ReplayDatabase");
var _Replay = require("../replay/Replay");
var _Router = require("curvature/base/Router");
const startDemo = function startDemo(parent, menu, replay) {
  let offset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
  parent.reset();
  parent.replayFrames = replay.getIndexedFrames();
  parent.replayStart = parent.replayFrames.get(offset || replay.firstFrame) || {};
  parent.replay = replay;
  parent.maxReplayFrame = replay.lastFrame;
  parent.replayOffset = -1 + replay.firstFrame + offset;
  _Router.Router.setQuery('demo', replay.uuid);
  parent.loadMap({
    mapUrl: replay.map
  }).then(() => {
    parent.args.paused = true;
    parent.playback();
  });
};
const loadChildren = function loadChildren(parent, menu) {
  let offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  return _ReplayDatabase.ReplayDatabase.open('replays', 3).then(database => {
    const store = 'replays';
    const limit = 10;
    const type = _Replay.Replay;
    const direction = 'prev';
    let index = 'id';
    let range = [];
    if (parent.baseMap) {
      index = 'map-id';
      range = [[parent.baseMap, 0], [parent.baseMap, Infinity]];
    }
    const query = {
      store: store,
      index: index,
      direction: direction,
      limit: limit,
      offset: offset,
      type: type,
      range: range
    };
    const children = {};
    if (!offset) {
      children['Import'] = {
        callback: () => {
          const fileInput = document.createElement('input');
          fileInput.setAttribute('type', 'file');
          fileInput.click();
          fileInput.addEventListener('change', event => {
            const files = event.target.files;
            for (const file of files) file.text().then(json => {
              const skel = JSON.parse(json);
              delete skel.id;
              delete skel.uuid;
              const replay = _Replay.Replay.from(skel);
              delete replay.id;
              database.insert('replays', replay);
            });
          }, {
            once: true
          });
        }
      };
    }
    return database.select(query).each(replay => {
      const duration = replay.lastFrame - replay.firstFrame;

      // if(duration < 120)
      // {
      // 	database.delete('replays', replay);
      // }

      const min = String(Math.trunc(duration / (60 * 60))).padStart(1, '0');
      const sec = String(Math.trunc(duration / 60) % 60).padStart(2, '0');
      const durationLabel = `${min}:${sec}`;
      let childName = `${durationLabel}] ${new Date(replay.created).toLocaleString('en-US')}`;
      let subtext = replay.map;
      if (replay.name) {
        childName = durationLabel + '] ' + replay.name;
        subtext = new Date(replay.created).toLocaleString('en-US') + ' ' + replay.map;
      }
      children[childName] = {
        subtext: subtext,
        color: replay.color,
        children: {
          'Replay': {
            callback: () => startDemo(parent, menu, replay)
          },
          'Skip to': {
            children: () => {
              const subchildren = {};
              for (const offset of replay.keyFrames) {
                const min = String(Math.trunc(offset / (60 * 60))).padStart(2, '0');
                const sec = String(Math.trunc(offset / 60) % 60).padStart(2, '0');
                const time = `${min}:${sec}`;
                subchildren[time] = {
                  callback: () => startDemo(parent, menu, replay, offset)
                };
              }
              console.log(subchildren);
              return subchildren;
            }
          },
          'Options': {
            children: {
              Banners: {
                input: 'boolean',
                revert: () => parent.args.replayBanners = true,
                set: value => parent.args.replayBanners = value,
                get: () => parent.args.replayBanners
              },
              'Quick Exit': {
                input: 'boolean',
                revert: () => parent.args.replayQuickExit = false,
                set: value => parent.args.replayQuickExit = value,
                get: () => parent.args.replayQuickExit
              }
            }
          },
          'Export': {
            callback: () => {
              const fileContents = new Blob([JSON.stringify(replay)], {
                type: 'text/json'
              });
              const fileUrl = URL.createObjectURL(fileContents);
              const fileLink = document.createElement('a');
              fileLink.href = fileUrl;
              fileLink.download = `${replay.name || replay.uuid}.json`;
              fileLink.click();
            }
          },
          'Rename': {
            children: {
              name: {
                input: 'string',
                set: value => {
                  replay.name = value;
                  database.update('replays', replay);
                },
                get: () => replay.name
              },
              color: {
                input: 'string',
                set: value => {
                  replay.color = value;
                  database.update('replays', replay);
                },
                get: () => replay.color
              }
            }
          },
          'Delete': {
            children: {
              No: {
                callback: () => {
                  menu.back(1);
                }
              },
              Yes: {
                callback: () => {
                  delete children[childName];
                  database.delete('replays', replay);
                  // database.select({query, limit: 1, offset: -1 + limit + offset}).each(replay => {
                  // 	children[ childName ];
                  // });
                  menu.back(2);
                }
              }
            }
          }
        }
      };
    }).then(results => {
      if (results.mapped) {
        children['Next ' + limit] = {
          children: () => loadChildren(parent, menu, offset + limit)
        };
      }
      return children;
    });
  });
};
const DemoMenu = {
  subtext: 'View error log.',
  children: loadChildren
};
exports.DemoMenu = DemoMenu;
});

require.register("Menu/MainMenu.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MainMenu = void 0;
var _Bindable = require("curvature/base/Bindable");
var _Router = require("curvature/base/Router");
var _Bgm = require("../audio/Bgm");
var _Card = require("../intro/Card");
var _Cylinder = require("../effects/Cylinder");
var _Pinch = require("../effects/Pinch");
var _Twist = require("../effects/Twist");
var _Menu2 = require("./Menu");
var _SavestateMenu = require("./SavestateMenu");
var _SettingsMenu = require("./SettingsMenu");
var _TileMap = require("../tileMap/TileMap");
var _CharacterString = require("../ui/CharacterString");
var _CharacterPreview = require("./CharacterPreview");
var _ZoneSuffix = require("./ZoneSuffix");
var _Lobby = require("../network/Lobby");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let MainMenu = /*#__PURE__*/function (_Menu) {
  _inherits(MainMenu, _Menu);
  var _super = _createSuper(MainMenu);
  function MainMenu(args, parent) {
    var _this;
    _classCallCheck(this, MainMenu);
    _this = _super.call(this, args, parent);
    _defineProperty(_assertThisInitialized(_this), "template", require('./main-menu.html'));
    if (!_this.args.initialPath.length && _Router.Router.query.menuPath) {
      _this.args.initialPath = JSON.parse(_Router.Router.query.menuPath);
    }
    _this.loggingIn = null;
    _this.args.cardName = 'main-menu';
    _this.args.haveToken = false;
    _this.args.listening = false;
    _this.args.joinGame = false;
    _this.args.hostGame = false;
    _this.args.copy = 'copy';
    _this.font = 'small-menu-font';
    // this.font = 'font';

    _this.args.title = new _CharacterString.CharacterString({
      font: _this.font,
      value: 'Sonic 3000'
    });
    _this.args.ok = new _CharacterString.CharacterString({
      font: _this.font,
      value: '⓿ ok'
    });
    _this.args.back = new _CharacterString.CharacterString({
      font: _this.font,
      value: '❶ back'
    });
    _this.args.revert = new _CharacterString.CharacterString({
      font: _this.font,
      value: '❸ default (hold)'
    });
    _this.args.select = new _CharacterString.CharacterString({
      font: _this.font,
      value: '✚ select'
    });
    _this.actsCleared = {};
    const Character = {
      input: 'select',
      options: ['Sonic', 'Tails', 'Knuckles', 'Robotnik', 'EggRobo', 'Mecha-Sonic', 'Seymour', 'Chalmers', 'Sean'],
      locked: ['Robotnik', 'EggRobo', 'Mecha-Sonic', 'Seymour', 'Chalmers', 'Sean'],
      default: 'Sonic',
      set: value => _this.parent.args.selectedChar = value,
      get: () => {
        var _this$parent$args$sel;
        return (_this$parent$args$sel = _this.parent.args.selectedChar) !== null && _this$parent$args$sel !== void 0 ? _this$parent$args$sel : 'Sonic';
      }
    };
    const Follower = {
      input: 'select',
      options: ['Sonic', 'Tails', 'Knuckles'
      // , 'Robotnik'
      // , 'EggRobo'
      // , 'Mecha-Sonic'
      // , 'Seymour'
      // , 'Chalmers'
      // , 'Sean'
      ],

      locked: ['Robotnik', 'EggRobo', 'Mecha-Sonic', 'Seymour', 'Chalmers', 'Sean'],
      set: value => _this.parent.args.followerChar = value,
      get: () => {
        var _this$parent$args$fol;
        return (_this$parent$args$fol = _this.parent.args.followerChar) !== null && _this$parent$args$fol !== void 0 ? _this$parent$args$fol : 'Tails';
      }
    };
    const Pallet = _Bindable.Bindable.make({
      input: 'select',
      tags: 'inline',
      options: [],
      set: value => _this.parent.args.mainPallet = value,
      get: () => {
        var _this$parent$args$mai;
        return (_this$parent$args$mai = _this.parent.args.mainPallet) !== null && _this$parent$args$mai !== void 0 ? _this$parent$args$mai : null;
      }
    });
    Pallet.set(_this.parent.args.mainPallet || 'Normal');
    const CustomColor = _Bindable.Bindable.make({
      Hue: {
        input: 'number',
        tags: 'inline',
        min: -180,
        max: +180,
        subtext: 'Rotate the color wheel.',
        revert: () => parent.customColor.h = 0,
        set: value => parent.customColor.h = Number(value).toFixed(2),
        get: () => parent.customColor.h
      },
      Saturation: {
        input: 'number',
        tags: 'inline',
        min: 0,
        max: 2,
        step: 0.01,
        subtext: 'Change the amount of color.',
        revert: () => parent.customColor.s = 1,
        set: value => parent.customColor.s = Number(value).toFixed(2),
        get: () => parent.customColor.s
      },
      Value: {
        input: 'number',
        tags: 'inline',
        min: 0,
        max: 2,
        step: 0.01,
        subtext: 'change the brightness.',
        revert: () => parent.customColor.v = 1,
        set: value => parent.customColor.v = Number(value).toFixed(2),
        get: () => parent.customColor.v
      }
    });
    _this.onRemove(parent.args.bindTo('selectedChar', v => {
      parent.loadSaves().then(() => {
        switch (v) {
          case 'Sonic':
            Pallet.options = ['Normal', 'Santiago', 'Sequel', 'RedHot', 'White', 'Custom'];
            break;
          case 'Tails':
            Pallet.options = ['SkyCamo', 'Copper', 'Patina', 'Arctic', 'Custom'];
            break;
          case 'Knuckles':
            Pallet.options = ['Tails', 'Enerjak', 'Pink', 'Wechnia', 'Custom'];
            break;
          default:
            Pallet.options = [];
            break;
        }
        if (v) {
          const charState = parent.getCharacterState(v);
          Pallet.options.length = Pallet.options.length ? 1 + Math.min(Pallet.options.length, Object.keys(charState.cleared).length) : 0;
        } else {
          Pallet.options = [];
        }
        if (Pallet.options.length) {
          Pallet.available = 'available';
        } else {
          Pallet.available = 'hidden';
        }
      });
    }));
    _this.onRemove(parent.args.bindTo('mainPallet', v => {
      if (v === 'Custom') {
        CustomColor.Hue.available = CustomColor.Saturation.available = CustomColor.Value.available = 'available';
        return;
      }
      CustomColor.Hue.available = CustomColor.Saturation.available = CustomColor.Value.available = 'hidden';
    }));

    // this.parent.args.selectedChar = this.parent.args.selectedChar || 'Sonic';

    Character.prefix = new _CharacterPreview.CharacterPreview(Character, _this.parent);
    // Follower.prefix = new CharacterPreview(Follower);

    _this.onRemove(() => Character.prefix.remove());
    _this.items = _this.args.items = {
      'Single Player': {
        available: 'available',
        children: {
          Character: Character

          // , Follower
          // , Pallet
          // , ...CustomColor
          ,

          'Brooklyn Breakout Zone Act 1': {
            characters: ['Sonic', 'Tails', 'Knuckles', 'Robotnik'],
            suffix: new _ZoneSuffix.ZoneSuffix({
              map: '/map/brooklyn-zone.json'
            }, _this.parent),
            callback: () => {
              _this.parent.loadMap({
                mapUrl: '/map/brooklyn-zone.json'
              });
              _this.accept();
            }
          },
          'Brooklyn Breakout Zone Act 2': {
            characters: ['Sonic', 'Tails', 'Knuckles', 'Robotnik'],
            suffix: new _ZoneSuffix.ZoneSuffix({
              map: '/map/brooklyn-zone-2.json'
            }, _this.parent),
            callback: () => {
              _this.parent.loadMap({
                mapUrl: '/map/brooklyn-zone-2.json'
              });
              _this.accept();
            }
          },
          'Manic Harbor Zone Act 1': {
            characters: ['Sonic', 'Tails', 'Knuckles', 'Robotnik'],
            suffix: new _ZoneSuffix.ZoneSuffix({
              map: '/map/manic-harbor-zone.json'
            }, _this.parent),
            callback: () => {
              _this.parent.loadMap({
                mapUrl: '/map/manic-harbor-zone.json'
              });
              _this.accept();
            }
          },
          'Manic Harbor Zone Act 2': {
            characters: ['Sonic', 'Tails', 'Knuckles', 'Robotnik'],
            suffix: new _ZoneSuffix.ZoneSuffix({
              map: '/map/manic-harbor-zone-2.json'
            }, _this.parent),
            callback: () => {
              _this.parent.loadMap({
                mapUrl: '/map/manic-harbor-zone-2.json'
              });
              _this.accept();
            }
          },
          'Agorapolis Zone Act 1 Preview': {
            characters: ['Sonic', 'Tails', 'Knuckles', 'Robotnik'],
            tags: 'new',
            suffix: new _ZoneSuffix.ZoneSuffix({
              map: '/map/emerald-isle.json'
            }, _this.parent),
            callback: () => {
              _this.parent.loadMap({
                mapUrl: '/map/emerald-isle.json'
              });
              _this.accept();
            }
          },
          'Agorapolis Zone Act 2 Preview': {
            characters: ['Sonic', 'Tails', 'Knuckles', 'Robotnik'],
            tags: 'new',
            suffix: new _ZoneSuffix.ZoneSuffix({
              map: '/map/emerald-isle-2.json'
            }, _this.parent),
            callback: () => {
              _this.parent.loadMap({
                mapUrl: '/map/emerald-isle-2.json'
              });
              _this.accept();
            }
          },
          'Radical City Zone Act 1': {
            characters: ['Sonic', 'Tails', 'Knuckles', 'Robotnik'],
            suffix: new _ZoneSuffix.ZoneSuffix({
              map: '/map/empty-zone.json'
            }, _this.parent),
            callback: () => {
              _this.parent.loadMap({
                mapUrl: '/map/empty-zone.json'
              });
              _this.accept();
            }
          },
          'Radical City Zone Act 2': {
            characters: ['Sonic', 'Tails', 'Knuckles', 'Robotnik'],
            suffix: new _ZoneSuffix.ZoneSuffix({
              map: '/map/empty-zone-2.json'
            }, _this.parent),
            callback: () => {
              _this.parent.loadMap({
                mapUrl: '/map/empty-zone-2.json'
              });
              _this.accept();
            }
          },
          'Seaview Park Zone Act 1': {
            characters: ['Sonic', 'Tails', 'Knuckles', 'Robotnik'],
            suffix: new _ZoneSuffix.ZoneSuffix({
              map: '/map/west-side-zone.json'
            }, _this.parent),
            callback: () => {
              _this.parent.loadMap({
                mapUrl: '/map/west-side-zone.json'
              });
              _this.accept();
            }
          },
          'Seaview Park Zone Act 2': {
            characters: ['Sonic', 'Tails', 'Knuckles', 'Robotnik'],
            suffix: new _ZoneSuffix.ZoneSuffix({
              map: '/map/west-side-zone-2.json'
            }, _this.parent),
            callback: () => {
              _this.parent.loadMap({
                mapUrl: '/map/west-side-zone-2.json'
              });
              _this.accept();
            }
          },
          'Misty Ruins Zone Preview': {
            characters: ['Sonic', 'Tails', 'Knuckles', 'Robotnik'],
            subtext: 'Testing art, layout and physics for Misty Ruins Zone',
            callback: () => {
              _this.parent.loadMap({
                mapUrl: '/map/ruins-test.json'
              });
              _this.accept();
            }
          },
          'StratoRail Zone Preview': {
            characters: ['Sonic', 'Tails', 'Knuckles', 'Robotnik'],
            subtext: 'Testing art for Moon Zone',
            callback: () => {
              _this.parent.loadMap({
                mapUrl: '/map/pumpkin-test.json'
              });
              _this.accept();
            }
          },
          'Toxin Refinery Zone Preview': {
            characters: ['Sonic', 'Tails', 'Knuckles', 'Robotnik'],
            tags: 'new',
            subtext: 'Testing art for Moon Zone',
            callback: () => {
              _this.parent.loadMap({
                mapUrl: '/map/chemical-test.json'
              });
              _this.accept();
            }
          },
          'Underground Zone Preview': {
            characters: ['Sonic', 'Tails', 'Knuckles', 'Robotnik'],
            subtext: 'Testing art, layout and physics for Underground Zone',
            callback: () => {
              _this.parent.loadMap({
                mapUrl: '/map/underground-test.json'
              });
              _this.accept();
            }
          }

          // , 'Peak Vape Test Zone': {
          // 	characters: ['Sonic', 'Tails', 'Knuckles', 'Robotnik']
          // 	, subtext: 'Testing art for Peak Vape Zone'
          // 	, callback: () => {
          // 		this.parent.loadMap({mapUrl: '/map/quartz-test.json'});
          // 		this.accept();
          // 	}
          // }
          ,

          'Phazon Crater Preview': {
            characters: ['Sonic', 'Tails', 'Knuckles', 'Robotnik'],
            tags: 'new',
            subtext: 'Testing art for Phazon Crater Zone',
            callback: () => {
              _this.parent.loadMap({
                mapUrl: '/map/phazon-test.json'
              });
              _this.accept();
            }
          },
          'Moon Zone Preview': {
            characters: ['Sonic', 'Tails', 'Knuckles', 'Robotnik'],
            subtext: 'Testing art for Moon Zone',
            callback: () => {
              _this.parent.loadMap({
                mapUrl: '/map/moon-test.json'
              });
              _this.accept();
            }
          }

          // , 'Flickie Test': {
          // 	characters: ['Sonic', 'Tails', 'Knuckles', 'Robotnik']
          // 	, subtext: 'Flickie stress test'
          // 	, callback: () => {
          // 		this.parent.loadMap({mapUrl: '/map/flickie-test.json'});
          // 		this.accept();
          // 	}
          // }
        }
      },

      'Multiplayer': {
        tags: '',
        children: {
          'Matrix Lobby': {
            tags: 'new',
            callback: () => {
              _this.refreshConnection();
              if (!_this.loggingIn) {
                _this.loggingIn = _this.parent.matrixConnect(true);
                _this.loggingIn.finally(() => _this.loggingIn = null);
                _this.loggingIn.then(matrix => {
                  const lobby = new _Lobby.Lobby({
                    roomId: _this.parent.settings.matrixRoom
                  }, _this.parent);
                  _this.args.override = lobby;
                  _this.args.override.onRemove(() => {
                    _this.args.override = null;
                    _this.onNextFrame(() => _this.focusFirst());
                  });
                  _this.onRemove(() => lobby.remove());
                });
              } else {
                _this.parent.matrixConnect();
              }
            }
          },
          'Peer to Peer': {
            children: {
              'Host a game': {
                callback: () => {
                  _this.refreshConnection();
                  _this.args.hostOutput = '';
                  _this.args.hostGame = true;
                  _this.args.copy = 'copy';
                }
              },
              'Join a game': {
                callback: () => {
                  _this.refreshConnection();
                  _this.args.joinOutput = '';
                  _this.args.joinGame = true;
                  _this.args.copy = 'copy';
                  _this.client.fullOffer().then(token => {
                    const tokenString = JSON.stringify(token);
                    const encodedToken = `s3ktp://request/${btoa(tokenString)}`;
                    _this.args.joinOutput = encodedToken;
                    _this.args.haveToken = true;
                  });
                }
              }
            }
          }
        }
      },
      Settings: (0, _SettingsMenu.SettingsMenu)(parent),
      Graphics: {
        input: 'select',
        tags: 'inline',
        options: ['High', 'Medium', 'Low', 'Very Low'],
        set: value => parent.settings.graphicsLevel = value,
        get: () => parent.settings.graphicsLevel
      },
      About: {
        callback: () => {
          window.open('/about.html');
        }
      }
    };
    return _this;
  }
  _createClass(MainMenu, [{
    key: "clear",
    value: function clear() {
      this.args.input = '';
      this.args.joinOutput = '';
      this.args.hostOutput = '';
    }
  }, {
    key: "input",
    value: function input(controller) {
      _get(_getPrototypeOf(MainMenu.prototype), "input", this).call(this, controller);
      let xEffect = 2;
      let yEffect = 3;

      // if(controller.axes[7])
      // {
      // 	xEffect = 3;
      // 	yEffect = 4;
      // }

      // if(this.args.twist)
      // {
      // 	const xAxis = (controller.axes[xEffect] ? controller.axes[xEffect].magnitude : 0);
      // 	const yAxis = (controller.axes[yEffect] ? controller.axes[yEffect].magnitude : 0);

      // 	let pressure = 0;

      // 	if(controller.buttons[6])
      // 	{
      // 		pressure = controller.buttons[6].pressure - controller.buttons[7].pressure;
      // 	}

      // 	this.args.twist.args.scale = pressure * -256;

      // 	this.args.twist.args.dx = 64*1.618 * xAxis;
      // 	this.args.twist.args.dy = 64*1.000 * yAxis;
      // }

      // if(this.args.pinch)
      // {
      // 	const xAxis = (controller.axes[xEffect] ? controller.axes[xEffect].magnitude : 0) + (controller.axes[0] ? controller.axes[0].magnitude : 0) * 0.1;
      // 	const yAxis = (controller.axes[yEffect] ? controller.axes[yEffect].magnitude : 0) + (controller.axes[1] ? controller.axes[1].magnitude : 0) * 0.1;

      // 	this.args.pinch.args.dx = 64*1.618 * xAxis;
      // 	this.args.pinch.args.dy = 64*1.000 * yAxis;
      // }
    }
  }, {
    key: "disconnect",
    value: function disconnect() {
      this.server && this.server.close();
      this.client && this.client.close();
      this.server = null;
      this.client = null;
      this.parent.args.networked = false;
      this.parent.args.chatBox = null;
      this.args.connected = false;
      this.args.hostGame = false;
      this.args.joinGame = false;
      this.clear();
    }

    // onRendered(event)
    // {
    // 	super.onRendered(event);

    // 	this.args.twist = new Twist({
    // 		id:'menu-twist', scale:  64, width: Math.floor(64 * 1.618), height: 64
    // 	});

    // 	this.args.pinch = new Pinch({
    // 		id:'menu-pinch', scale:  64, width: Math.floor(64 * 1.618), height: 64
    // 	});
    // }
  }, {
    key: "back",
    value: function back() {
      let levels = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      _get(_getPrototypeOf(MainMenu.prototype), "back", this).call(this, levels);
      this.disconnect();
    }
  }, {
    key: "answer",
    value: function answer() {
      let offerString = this.args.input;
      const isEncoded = /^s3ktp:\/\/request\/(.+)/.exec(offerString);
      if (isEncoded) {
        offerString = atob(isEncoded[1]);
      }
      const offer = JSON.parse(offerString);
      const answer = this.server.fullAnswer(offer);
      answer.then(token => {
        const tokenString = JSON.stringify(token);
        const encodedToken = `s3ktp://accept/${btoa(tokenString)}`;
        this.args.hostOutput = encodedToken;
        this.args.haveToken = true;
      });
      return answer;
    }
  }, {
    key: "acceptRtp",
    value: function acceptRtp() {
      let answerString = this.args.input;
      const isEncoded = /^s3ktp:\/\/accept\/(.+)/.exec(answerString);
      if (isEncoded) {
        answerString = atob(isEncoded[1]);
      }
      const answer = JSON.parse(answerString);
      this.client.fullAccept(answer);
    }
  }, {
    key: "select",
    value: function select() {
      if (this.args.hostGame) {
        this.tags.hostOutput.select();
      } else if (this.args.joinGame) {
        this.tags.joinOutput.select();
      }
    }
  }, {
    key: "copy",
    value: function copy() {
      if (this.args.hostGame) {
        if (!this.args.input) {
          return;
        }
        this.tags.hostOutput.select();
      } else if (this.args.joinGame) {
        if (!this.args.joinOutput) {
          return;
        }
        this.tags.joinOutput.select();
      }
      document.execCommand("copy");
      this.args.copy = 'copied!';
    }
  }, {
    key: "paste",
    value: function paste(event) {
      navigator.clipboard.readText().then(copied => {
        if (this.args.hostGame && copied.match(/^s3ktp:\/\/request\//)) {
          this.args.input = copied;
          this.answer().then(token => {
            this.copy();
          });
        }
        if (this.args.joinGame && copied.match(/^s3ktp:\/\/accept\//)) {
          this.args.input = copied;
          this.acceptRtp();
        }
      });
    }
  }, {
    key: "refreshConnection",
    value: function refreshConnection() {
      this.server = this.parent.getServer(true);
      this.client = this.parent.getClient(true);
      const server = this.server;
      const client = this.client;
      const onOpen = event => {
        console.log('Peer connection opened!');
        this.parent.loadMap({
          mapUrl: '/map/emerald-isle.json',
          networked: true
        }).then(() => console.log('Level started!'));
      };
      const onClose = event => {
        this.disconnect(event);
        if (this.server && this.server.peerServer && this.server.peerServer.connectionState === 'closed') {
          console.log({
            server: this.server
          });
          this.server = null;
        }
        if (this.client && this.client.peerClient && this.client.peerClient.connectionState === 'closed') {
          console.log({
            client: this.client
          });
          this.client = null;
        }
      };
      this.listen(server, 'open', onOpen, {
        once: true
      });
      this.listen(client, 'open', onOpen, {
        once: true
      });
      this.listen(server, 'close', onClose, {
        once: true
      });
      this.listen(client, 'close', onClose, {
        once: true
      });
    }
  }, {
    key: "play",
    value: function play() {
      _get(_getPrototypeOf(MainMenu.prototype), "play", this).call(this);
      _Bgm.Bgm.play('MENU_THEME', {
        loop: true,
        interlude: true
      });
      const done = this.done;
      done.then(() => this.onTimeout(250, () => this.remove()));
      return done;
    }
  }]);
  return MainMenu;
}(_Menu2.Menu);
exports.MainMenu = MainMenu;
});

;require.register("Menu/Menu.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Menu = void 0;
var _Bindable = require("curvature/base/Bindable");
var _Card2 = require("../intro/Card");
var _Cylinder = require("../effects/Cylinder");
var _Pinch = require("../effects/Pinch");
var _CharacterString = require("../ui/CharacterString");
var _Sfx = require("../audio/Sfx");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
const Bindings = Symbol('bindings');
let Menu = /*#__PURE__*/function (_Card) {
  _inherits(Menu, _Card);
  var _super = _createSuper(Menu);
  function Menu(args, parent) {
    var _this;
    _classCallCheck(this, Menu);
    args[_Bindable.Bindable.NoGetters] = true;
    _this = _super.call(this, args, parent);
    _defineProperty(_assertThisInitialized(_this), "template", require('./main-menu.html'));
    _this[_Bindable.Bindable.NoGetters] = true;
    _this.font = 'small-menu-font';
    // this.font = 'font';

    _this.args.initialPath = [];
    _this.args.cardName = 'menu';
    _this.args.items = {};
    _this.args.pageLoop = false;
    _this.args.pageJump = 7;
    _this.currentItem = null;
    _this.include = 'a, button, input, textarea, select, details, [tabindex]';
    _this.exclude = '[tabindex="-1"], .hidden';
    _this.elements = new Map();
    _this.onRemove(() => parent.focus());
    return _this;
  }
  _createClass(Menu, [{
    key: "onRendered",
    value: function onRendered(event) {
      this.listen(window, 'focus', event => this.refocus(event));
      this.args.bindTo('items', v => {
        for (const i in this.args.items) {
          const item = this.args.items[i];
          if (item[Bindings]) {
            [...item[Bindings]].forEach(b => b());
          }
        }
        let index = 0;
        for (const i in v) {
          const item = v[i];
          item.color = item.color || 'var(--default-color)';
          item._index = index++;
          item._key = i;
          item._title = new _CharacterString.CharacterString({
            value: i,
            font: this.font
          });
          item._value = new _CharacterString.CharacterString({
            value: '',
            font: this.font
          });
          if (item.get) {
            item.setting = item.get();
          }
          if (item.input === 'boolean') {
            item._value.args.value = item.setting ? 'ON' : 'OFF';
            item._boolValue = item._value;
          } else if (item.input === 'string') {
            var _item$Bindings;
            const bindable = _Bindable.Bindable.make(item);
            item[Bindings] = (_item$Bindings = item[Bindings]) !== null && _item$Bindings !== void 0 ? _item$Bindings : new Set();
            item[Bindings].add(bindable.bindTo('setting', v => item.set && item.set(v)));
          } else if (item.input === 'select') {
            item._value.args.value = item.setting;
            item._selectValue = item._value;
          } else if (item.input === 'output') {
            var _item$Bindings2;
            const bindable = _Bindable.Bindable.make(item);
            item[Bindings] = (_item$Bindings2 = item[Bindings]) !== null && _item$Bindings2 !== void 0 ? _item$Bindings2 : new Set();
            item[Bindings].add(bindable.bindTo('setting', v => item._value.args.value = v));
            if (item.bind) {
              item[Bindings].add(item.bind(_Bindable.Bindable.make(item)));
            }
          }
        }
      });
      this.args.bindTo('items', v => {
        if (!v || !Object.keys(v).length) {
          return;
        }
        if (this.args.items) {
          this.currentItem = null;
        }
        if (this.tags.bound) {
          const next = this.findNext(this.currentItem, this.tags.bound.node);
          if (next) {
            this.focus(next);
          }
        }
      }, {
        wait: 0
      });
    }
  }, {
    key: "onAttached",
    value: function onAttached(event) {
      const autoNav = () => {
        if (this.args.initialPath.length) {
          const item = this.args.initialPath.shift();
          if (item in this.args.items) {
            this.onTimeout(0, () => this.run(this.args.items[item]));
            if (this.args.initialPath.length) {
              this.onTimeout(0, () => autoNav());
            }
          }
        } else {
          this.onNextFrame(() => this.focusFirst());
        }
      };
      this.onTimeout(0, () => autoNav());
    }
  }, {
    key: "focusFirst",
    value: function focusFirst() {
      if (!this.tags.bound) {
        return;
      }
      const element = this.findNext(null, this.tags.bound);
      element && this.focus(element);
    }
  }, {
    key: "refocus",
    value: function refocus(event) {
      this.onNextFrame(() => {
        if (!this.currentItem) {
          this.focusFirst();
        }
        this.focus(this.currentItem, true);
      });
    }
  }, {
    key: "findNext",
    value: function findNext(current, bounds) {
      let jump = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
      const elements = bounds.querySelectorAll(this.include);
      if (!elements.length) {
        return;
      }
      const items = [];
      let c = 0,
        i = 0;
      for (const element of elements) {
        if (element.matches(this.exclude)) {
          continue;
        }
        items.push(element);
        if (element === current) {
          c = i;
        }
        i++;
      }
      if (!current) {
        return items[0];
      }
      if (Math.abs(jump) > 1 && !this.args.pageLoop) {
        if (jump + c < 0) {
          return items[0];
        } else if (jump + c >= items.length) {
          return items[items.length + -1];
        }
      }
      if (jump === -Infinity) {
        return items[0];
      } else if (jump === Infinity) {
        return items[items.length + -1];
      }
      let s = (c + jump) % items.length;
      while (s < 0) {
        s += items.length;
      }
      return items[s];
    }
  }, {
    key: "handleFocus",
    value: function handleFocus(event) {
      this.focus(event.target, true);
    }
  }, {
    key: "focus",
    value: function focus(element) {
      let quick = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      if (document.activeElement === element && this.currentItem === element) {
        return;
      }
      if (this.currentItem) {
        this.blur(this.currentItem);
      }
      if (element) {
        this.currentItem = element;
        element.focus({
          preventScroll: true
        });
        element.scrollIntoView({
          behavior: quick ? 'instant' : 'smooth',
          block: 'center'
        });
        element.classList.add('focused');
        element.addEventListener('blur', () => this.blur(element), {
          once: true
        });
      }
    }
  }, {
    key: "blur",
    value: function blur(element) {
      element.classList.remove('focused');
      element.blur();
    }
  }, {
    key: "input",
    value: function input(controller) {
      this.zeroMe = controller;
      if (!this.tags.bound) {
        return;
      }
      if (this.args.override) {
        this.args.override.input(controller);
        return;
      }
      let next,
        quick = false;
      if (controller.buttons[0] && controller.buttons[0].time === 1) {
        this.currentItem && this.currentItem.click();
        this.args.last = 'A';
        if (this.currentItem && !this.currentItem.contains(document.activeElement)) {
          next = this.currentItem;
        }
        this.beep();
      } else if (controller.buttons[1] && controller.buttons[1].time === 1) {
        this.back();
        this.args.last = 'B';
        this.beep();
      } else if (controller.buttons[3] && controller.buttons[3].time === 30) {
        this.currentItem && this.currentItem.dispatchEvent(new MouseEvent('auxclick', {
          button: 1
        }));
        this.args.last = 'Y';
        this.beep();
      }
      const repeatCheck = button => controller.buttons[button] && (controller.buttons[button].time === 1 || controller.buttons[button].time >= 140 && controller.buttons[button].time % 5 === 1 || controller.buttons[button].time > 30 && controller.buttons[button].time < 140 && controller.buttons[button].time % 15 === 1);
      if (repeatCheck(12) || controller.axes[7] && controller.axes[7].magnitude < 0 && controller.axes[7].delta) {
        if (this.currentItem && this.currentItem.previousElementSibling) {
          quick = true;
        }
        next = this.findNext(this.currentItem, this.tags.bound.node, -1);
        this.beep();
      } else if (repeatCheck(13) || controller.axes[7] && controller.axes[7].magnitude > 0 && controller.axes[7].delta) {
        if (this.currentItem && this.currentItem.nextElementSibling) {
          quick = true;
        }
        next = this.findNext(this.currentItem, this.tags.bound.node, 1);
        this.beep();
      }
      if (repeatCheck(1022)) {
        next = this.findNext(this.currentItem, this.tags.bound.node, -this.args.pageJump);
        this.beep();
      } else if (repeatCheck(1023)) {
        next = this.findNext(this.currentItem, this.tags.bound.node, this.args.pageJump);
        this.beep();
      }
      if (repeatCheck(1024)) {
        next = this.findNext(this.currentItem, this.tags.bound.node, -Infinity);
        this.beep();
      } else if (repeatCheck(1025)) {
        next = this.findNext(this.currentItem, this.tags.bound.node, Infinity);
        this.beep();
      } else if (repeatCheck(14) || controller.axes[6] && controller.axes[6].magnitude < 0 && controller.axes[6].delta) {
        this.currentItem && this.contract(this.currentItem);
        this.beep();
      } else if (repeatCheck(15) || controller.axes[6] && controller.axes[6].magnitude > 0 && controller.axes[6].delta) {
        this.currentItem && this.expand(this.currentItem);
        this.beep();
      }
      next && this.focus(next, quick);
    }
  }, {
    key: "beep",
    value: function beep() {
      if (!this.parent.args.audio) {
        return;
      }
      _Sfx.Sfx.play('SWITCH_HIT');
    }
  }, {
    key: "run",
    value: function run(item, event) {
      let element;
      if (event && event.target) {
        element = event.target;
        while (element && element.matches) {
          if (element.matches('[data-click-barrier]')) {
            return;
          }
          element = element.parentNode;
        }
      }
      if (this.zeroMe) {
        this.zeroMe.zero();
      }
      if (item.available === 'unavailable' || item.available === 'hidden') {
        return;
      }
      if (item.input === 'string') {
        const input = element.querySelector('input');
        input.focus();
        return;
      }
      if (event && item.input) {
        this.onNextFrame(() => this.focus(event.target.closest('li')));
      }
      if (item.callback) {
        item.callback(item, this);
      }
      if (item.children) {
        let getChildren = item.children;
        if (typeof item.children === 'function') {
          getChildren = item.children(this.parent, this);
        }
        if (!(getChildren instanceof Promise)) {
          getChildren = Promise.resolve(getChildren);
        }
        const lastSelected = item._key;
        const prev = this.args.items;
        const back = {
          _title: new _CharacterString.CharacterString({
            value: 'back',
            font: 'small-menu-font'
          }),
          callback: () => {
            this.args.items = prev;
            this.args.currentKey = prev._title ? prev._title.args.value : '';
            // this.onNextFrame(()=>this.focusFirst());
            const lastIndex = Object.keys(prev).indexOf(lastSelected);
            this.onNextFrame(() => {
              this.focusFirst();
              this.onNextFrame(() => {
                if (this.tags.bound) {
                  const next = this.findNext(this.currentItem, this.tags.bound.node, lastIndex > 0 ? lastIndex : 0);
                  this.focus(next);
                }
              });
            });
          },
          _prev: prev['back'],
          color: 'var(--back-color, var(--default-color))'
        };
        this.args.items = {};
        getChildren.catch(error => {
          this.args.items['back'] = this.args.items['back'] || back;
        });
        getChildren.then(children => {
          this.args.items = children;
          this.args.currentKey = item._title.args.value;
          this.args.items['back'] = this.args.items['back'] || back;
          this.onNextFrame(() => this.focusFirst());
        });
      }
    }
  }, {
    key: "altRun",
    value: function altRun(item, event) {
      if (!event || event.button !== 1) {
        return;
      }
      if (item.revert) {
        item.revert(item, this);
        if (item.get) {
          item.setting = item.get();
        }
        if (item.input === 'boolean') {
          item._value.args.value = item.setting ? 'ON' : 'OFF';
        }
        item.set && item.set(item.setting);
      }
    }
  }, {
    key: "back",
    value: function back() {
      let levels = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      let target = this.args.items['back'];
      for (let i = 1; i < levels; i++) {
        console.log(target);
        if (target._prev) {
          target = target._prev;
        } else {
          break;
        }
      }
      target && target.callback && target.callback();
    }
  }, {
    key: "expand",
    value: function expand(element) {
      const input = element.querySelector('input');
      const title = element.getAttribute('data-title');
      const item = this.args.items[title];
      if (!item) {
        return;
      }
      if (item.input === 'number') {
        item.setting = Number(item.setting) + (item.step || 1);
        if (item.setting > item.max) {
          item.setting = item.max;
        }
        item.set && item.set(item.setting);
      } else if (item.input === 'boolean') {
        item.setting = !item.setting;
        item._value.args.value = item.setting ? 'ON' : 'OFF';
        item.set && item.set(item.setting);
      } else if (item && item.input === 'select') {
        this.cycleSelect(item, title, 1);
      } else if (input) {
        input.focus();
      }
    }
  }, {
    key: "contract",
    value: function contract(element) {
      const title = element.getAttribute('data-title');
      const item = this.args.items[title];
      if (!item) {
        return;
      }
      if (item.input === 'number') {
        item.setting = Number(item.setting) - (item.step || 1);
        if (item.setting < item.min) {
          item.setting = item.min;
        }
        item.set && item.set(item.setting);
      } else if (item.input === 'boolean') {
        item.setting = !item.setting;
        item._value.args.value = item.setting ? 'ON' : 'OFF';
        item.set && item.set(item.setting);
      } else if (item && item.input === 'select') {
        this.cycleSelect(item, title, -1);
      } else {
        this.focus(element);
      }
    }
  }, {
    key: "keyup",
    value: function keyup(event, item) {
      console.log(event.key);
      if (['ArrowUp', 'ArrowDown'].includes(event.key)) {
        event.preventDefault();
        event.stopPropagation();
        event.stopImmediatePropagation();
        const jump = {
          ArrowUp: -1,
          ArrowDown: 1
        }[event.key];
        if (event.currentTarget.tagName === 'INPUT') {
          const next = this.findNext(this.currentItem, this.tags.bound.node, jump);
          if (next) {
            this.focus(next);
            return;
          }
        }
      }
    }
  }, {
    key: "change",
    value: function change(event, title) {
      const item = this.args.items[title];
      if (!item) {
        return;
      }
      item.setting = event.target.value;
      this.selectListChanged(item, title);
      item.set(item.setting);
    }
  }, {
    key: "toggle",
    value: function toggle(event, item) {
      event && event.preventDefault();
      item.setting = !item.setting;
      item._value.args.value = item.setting ? 'ON' : 'OFF';
      item.set && item.set(item.setting);
    }
  }, {
    key: "cancel",
    value: function cancel(event) {
      event.preventDefault();
    }
  }, {
    key: "cycleSelect",
    value: function cycleSelect(item, title) {
      let direction = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
      let found = false;
      let first = undefined;
      let last = undefined;
      const options = [];
      Object.assign(options, item.options);
      if (direction === -1) {
        options.reverse();
      } else if (direction !== 1) {
        return;
      }
      for (const option of options) {
        var _first;
        first = (_first = first) !== null && _first !== void 0 ? _first : option;
        if (option === item.setting) {
          found = true;
          continue;
        }
        if (found) {
          item.setting = option;
          last = undefined;
          break;
        }
        last = option;
      }
      if (last !== undefined) {
        item.setting = first;
      }
      this.selectListChanged(item, title);
      item.set(item.setting);
    }
  }, {
    key: "selectListRendered",
    value: function selectListRendered(event, item, title, $view, $subview, $parent) {
      if (item.input === 'select') {
        var _ref;
        item.setting = (_ref = item.get ? item.get() : item.default) !== null && _ref !== void 0 ? _ref : undefined;
        let selectedIndex = 0;
        for (const i in item.options) {
          if (item.options[i] === item.setting) {
            selectedIndex = i;
          }
        }
        if (item.setting === undefined && item.options.length) {
          selectedIndex = 0;
          item.setting = item.options[0];
        }
        const selectTag = $subview.findTag('select');
        const optionTag = $subview.findTag('option');
        selectTag.selectedIndex = selectedIndex;
        item._value.args.value = item.setting;
        this.selectListChanged(item, title, true);
      } else if (item.input === 'boolean') {
        if (item.element) {
          item.element.selectedIndex = item.setting ? 0 : 1;
          item._value.args.value = item.setting ? 'ON' : 'OFF';
        }
      }
    }
  }, {
    key: "selectListChanged",
    value: function selectListChanged(item, title) {
      let silent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      if (item.input === 'boolean') {
        item._value.args.value = item.setting ? 'ON' : 'OFF';
        this.selectListChanged(item, title, true);
      } else if (item.input === 'select') {
        if (item._value) {
          if (item.locked && item.locked.includes(item.setting)) {
            item._value.args.value = 'Locked';
          } else {
            item._value.args.value = item.setting;
          }
        }
      }
      if (title === 'Character') {
        for (const _item of Object.values(this.args.items)) {
          var _ref2, _item$_available;
          _item._available = (_ref2 = (_item$_available = _item._available) !== null && _item$_available !== void 0 ? _item$_available : _item.available) !== null && _ref2 !== void 0 ? _ref2 : 'available';
          if (_item.characters && !_item.characters.includes(item.setting)) {
            _item.available = 'unavailable';
          } else {
            _item.available = _item._available;
          }
        }
      }
      if (this.parent.args.audio && !silent) {
        this.beep();
      }
    }
  }]);
  return Menu;
}(_Card2.Card);
exports.Menu = Menu;
});

;require.register("Menu/PauseMenu.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PauseMenu = void 0;
var _Card = require("../intro/Card");
var _Cylinder = require("../effects/Cylinder");
var _Pinch = require("../effects/Pinch");
var _Menu2 = require("./Menu");
var _SettingsMenu = require("./SettingsMenu");
var _CharacterString = require("../ui/CharacterString");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let PauseMenu = /*#__PURE__*/function (_Menu) {
  _inherits(PauseMenu, _Menu);
  var _super = _createSuper(PauseMenu);
  function PauseMenu(args, parent) {
    var _this;
    _classCallCheck(this, PauseMenu);
    _this = _super.call(this, args, parent);
    _defineProperty(_assertThisInitialized(_this), "template", require('./pause-menu.html'));
    _this.args.cardName = 'pause-menu';
    _this.args.animation = '';
    _this.args.title = new _CharacterString.CharacterString({
      value: 'Sonic 3000',
      font: 'small-menu-font'
    });
    _this.items = _this.args.items = {
      Continue: {
        subtext: 'Return to gameplay.',
        callback: () => parent.unpauseGame()
      },
      Mute: {
        input: 'boolean',
        subtext: 'Mute all audio',
        revert: () => parent.args.audio = true,
        set: value => parent.args.audio = !value,
        get: () => !parent.args.audio
      },
      Settings: (0, _SettingsMenu.SettingsMenu)(parent),
      Graphics: {
        input: 'select',
        options: ['High', 'Medium', 'Low', 'Very Low'],
        set: value => parent.settings.graphicsLevel = value,
        get: () => parent.settings.graphicsLevel
      }
      // , Save: SaveMenu(parent)
      ,
      Reset: {
        subtext: 'Reset the run.',
        children: {
          'Last Checkpoint': {
            subtext: 'Restart from the last checkpoint.',
            children: {
              'No': {
                callback: () => _this.args.items.back.callback()
              },
              'Yes': {
                callback: () => {
                  parent.unpauseGame();
                  parent.reset();
                  parent.startLevel();
                }
              }
            }
          },
          'Level Start': {
            subtext: 'Restart from the beginning of the act.',
            children: {
              'No': {
                callback: () => _this.args.items.back.callback()
              },
              'Yes': {
                callback: () => {
                  parent.clearCheckpoints();
                  parent.unpauseGame();
                  parent.reset();
                  parent.startLevel();
                }
              }
            }
          }
        }
      },
      Quit: {
        subtext: 'Quit to the title screen.',
        children: {
          'No': {
            callback: () => _this.args.items.back.callback()
          },
          'Yes': {
            callback: () => {
              _this.args.items.back.callback();
              parent.clearCheckpoints();
              parent.unpauseGame();
              parent.quit();
              // parent.playCards();
            }
          }
        }
      }
    };
    return _this;
  }
  _createClass(PauseMenu, [{
    key: "run",
    value: function run(item, event) {
      event.stopPropagation();
      event.stopImmediatePropagation();
      _get(_getPrototypeOf(PauseMenu.prototype), "run", this).call(this, item, event);
    }
  }, {
    key: "input",
    value: function input(controller) {
      if (controller.buttons[1011] && controller.buttons[1011].active) {
        const time = controller.buttons[1011].time;
        if (time === 1 || time > 30 && time % 15 === 1) {
          this.parent.focus();
          this.parent.args.paused = 1;
          this.args.hideMenu = 'pause-menu-hide';
        }
      }
      const pauseButton = 9;
      if (!this.args.hideMenu) {
        _get(_getPrototypeOf(PauseMenu.prototype), "input", this).call(this, controller);
      } else if (controller.buttons[pauseButton] && controller.buttons[pauseButton].active) {
        this.args.hideMenu = '';
      }
      if (controller.buttons[1012] && controller.buttons[1012].time > 0) {
        this.parent.focus();
        this.args.hideMenu = 'pause-menu-hide';
      } else if (controller.buttons[1020] && controller.buttons[1020].time > 0) {
        this.args.hideMenu = '';
      }
    }
  }, {
    key: "reset",
    value: function reset() {
      // this.args.items = {};
      // Object.assign(this.args.items, this.items);
      this.args.items = this.items;
    }
  }]);
  return PauseMenu;
}(_Menu2.Menu);
exports.PauseMenu = PauseMenu;
});

;require.register("Menu/SaveMenu.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SaveMenu = void 0;
var _SaveDatabase = require("../save/SaveDatabase");
const SaveMenu = parent => {
  return {
    children: {
      Save: {
        callback: () => {
          if (!parent.controlActor) {
            return;
          }
          const controlActor = parent.controlActor;
          const currentMap = parent.currentMap;
          const character = controlActor.args.canonical;
          const checkpoint = parent.getCheckpoint(controlActor.args.id);
          const savestate = {
            currentMap: currentMap,
            character: character,
            checkpoint: checkpoint
          };
          console.log(savestate);
          SavestateDatabase.open('savestates', 1).then(database => {
            const store = 'savestates';
            database.insert(store, savestate).then(result => {
              console.log(result);
              const index = 'id';
              const query = {
                store: store,
                index: index
              };
              database.select(query).each(savestate => console.log(savestate)).then(results => console.log(results));
            });
          });
        }
      }
    }
  };
};
exports.SaveMenu = SaveMenu;
});

require.register("Menu/SavestateMenu.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SavestateMenu = void 0;
var _SaveDatabase = require("../save/SaveDatabase");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
const SavestateMenu = parent => {
  const children = {};
  _SaveDatabase.SaveDatabase.open('saves', 1).then(database => {
    const store = 'saves';
    const index = 'created';
    const query = {
      store: store,
      index: index
    };
    database.select(query).each(savestate => {
      const id = savestate.id;
      const character = savestate.character;
      children[`${id} ${character}`] = {
        callback: () => {
          console.log(savestate);
          parent.setCheckpoint(savestate.currentMap, _defineProperty({}, character, savestate.checkpoint));
          parent.loadMap({
            mapUrl: savestate.currentMap
          });
        }
      };
    }).then(results => console.log(results));
  });
  return {
    children: children
  };
};
exports.SavestateMenu = SavestateMenu;
});

require.register("Menu/SettingsMenu.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SettingsMenu = void 0;
var _TraceMenu = require("./TraceMenu");
var _GamepadConfig = require("../controller/GamepadConfig");
var _Series = require("../intro/Series");
var _ButtonSelect = require("./ButtonSelect");
var _DemoMenu = require("./DemoMenu");
const videoMenu = parent => ({
  subtext: 'Video settings.',
  children: {
    // 'Tile Scale': {
    // 	input: 'number'
    // 	, subtext: 'Scale.'
    // 	, revert: () => parent.args.tileScale = 1
    // 	, set: value => parent.args.tileScale = value
    // 	, get: () => parent.args.tileScale
    // 	, min: 0.1
    // 	, step: 0.1
    // }

    'Motion Blur Effects': {
      input: 'boolean',
      subtext: 'Enable/Disable Motion Blur Effects',
      revert: () => parent.settings.blur = true,
      set: value => parent.settings.blur = value,
      get: () => parent.settings.blur
    },
    'Displacement Effects': {
      input: 'boolean',
      subtext: 'Enable/Disable Displacement Effects',
      revert: () => parent.settings.displace = true,
      set: value => parent.settings.displace = value,
      get: () => parent.settings.displace
    },
    'Scaling': {
      input: 'boolean',
      subtext: 'Enable/Disable Scaling',
      revert: value => parent.settings.scaling = true,
      set: value => parent.settings.scaling = value,
      get: () => parent.settings.scaling
    },
    'Smoothing': {
      input: 'boolean',
      subtext: 'Enable/Disable Smoothing',
      revert: value => parent.settings.smoothing = false,
      set: value => parent.settings.smoothing = value,
      get: () => parent.settings.smoothing
    },
    'Outline Thickness': {
      input: 'number',
      subtext: 'Change the Outline Thickness',
      revert: value => parent.settings.outline = 1,
      set: value => parent.settings.outline = value,
      get: () => parent.settings.outline,
      step: 0.5,
      max: 15,
      min: 0
    }

    // , 'Frameskip': {
    // 	input: 'number'
    // 	, subtext: 'Change the frameskip'
    // 	, set: value => parent.settings.frameSkip = value
    // 	, get: () => parent.settings.frameSkip
    // 	, max: 8
    // 	, min: 0
    // }
    ,

    'Display HUD': {
      input: 'boolean',
      subtext: 'Enable/Disable the HUD',
      revert: value => parent.settings.showHud = true,
      set: value => parent.settings.showHud = value,
      get: () => parent.settings.showHud
    }

    // , 'Debug OSD': {
    // 	input: 'boolean'
    // 	, subtext: 'Enable/Disable Debug OSD'
    // 	, set: value => parent.settings.debugOsd = value
    // 	, get: () => parent.settings.debugOsd
    // }
    ,

    'FPS Meter': {
      input: 'boolean',
      subtext: 'Enable/Disable the FPS Meter',
      revert: value => parent.settings.showFps = true,
      set: value => parent.settings.showFps = value,
      get: () => parent.settings.showFps
    },
    'Mute/Fullscreen': {
      input: 'boolean',
      subtext: 'Show the mute & fullscreen controls in the bottom right.',
      revert: value => parent.settings.shortcuts = true,
      set: value => parent.settings.shortcuts = value,
      get: () => parent.settings.shortcuts
    }
  }
});
const audioMenu = parent => ({
  subtext: 'Audio settings.',
  children: {
    'Mute': {
      input: 'boolean',
      subtext: 'Mute all audio',
      revert: () => parent.args.audio = true,
      set: value => parent.args.audio = !value,
      get: () => !parent.args.audio
    },
    'Music Volume': {
      input: 'number',
      subtext: 'Background music volume - 0% - 100%'
      // , available: 'unavailable'
      ,
      revert: () => parent.settings.musicVol = parent.defaults.musicVol,
      set: value => parent.settings.musicVol = value,
      get: () => parent.settings.musicVol,
      max: 100,
      min: 0
    },
    'SFX': {
      input: 'number',
      subtext: 'Sound effect music volume - 0% - 100%'
      // , available: 'unavailable'
      ,
      revert: () => parent.settings.sfxVol = parent.defaults.sfxVol,
      set: value => parent.settings.sfxVol = value,
      get: () => parent.settings.sfxVol,
      max: 100,
      min: 0
    }
    // , 'Mono / Stereo': {
    // 	available: 'unavailable'
    // }
  }
});

const inputMenu = parent => ({
  subtext: 'Input settings.',
  children: {
    // 'Gamepad Test': {
    // 	callback: (item,menu) => {
    // 		menu.args.override = new GamepadConfig({}, parent);
    // 		menu.args.override.onRemove(() => {
    // 			menu.args.override = null;
    // 			menu.onNextFrame(()=>menu.focusFirst());
    // 		});
    // 		// const cards = [
    // 		// 	new GamepadConfig({timeout: -1}, parent)
    // 		// 	, ...parent.homeCards()
    // 		// ];

    // 		// parent.args.titlecard = new Series({cards}, parent);

    // 		// parent.args.titlecard.play();
    // 	}
    // }

    // 'Select A Button': {
    // 	callback: (item,menu) => {
    // 		console.log('Select a button!');
    // 		menu.args.override = new ButtonSelect({},menu);
    // 		menu.args.override.onRemove(() => {
    // 			menu.args.override = null;
    // 			menu.onNextFrame(()=>menu.focusFirst());
    // 		});
    // 	}
    // }

    // , 'Output test': {
    // 	input: 'output'
    // 	, bind: i => {
    // 		return parent.settings.bindTo('buttonTest', v => {
    // 			i.setting = v
    // 		})
    // 	}
    // 	, set: value => parent.settings.buttonTest = value
    // 	, get: () => parent.settings.buttonTest
    // }

    'Button Font Test': {
      input: 'select',
      options: ['', '⓿', '❶', '❷', '❸', '❹', '❺', '❻', '❼', '❽', '❾', '❿', '⓫', '✚', '←', '→', '↑', '↓'
      // , '▦', '🡠', '🡢', '🡡', '🡣'
      , '⬲', '🡨', '🡪', '🡩', '🡫', '⟴', '🡰', '🡲', '🡱', '🡳'],
      set: value => parent.settings.buttonTest = value,
      get: () => parent.settings.buttonTest
    },
    'Rumble': {
      input: 'boolean',
      subtext: 'Enable/Disable controller vibration',
      set: value => parent.settings.rumble = value,
      get: () => parent.settings.rumble
    }
  }
});
const networkMenu = parent => ({
  subtext: 'Network settings.',
  children: {
    // 'Username': {
    // 	input: 'string'
    // 	, subtext: 'Name to display in online games'
    // 	, revert: () => parent.settings.username = parent.defaults.username
    // 	, set: value => parent.settings.username = value
    // 	, get: () => parent.settings.username
    // }
    'Matrix Settings': {
      children: {
        'Matrix URL': {
          input: 'string',
          subtext: 'Matrix Server URL for lobby.',
          revert: () => parent.settings.matrixUrl = parent.defaults.matrixUrl,
          set: value => parent.settings.matrixUrl = value,
          get: () => parent.settings.matrixUrl
        },
        'Lobby': {
          input: 'string',
          subtext: 'Matrix Room for lobby.',
          revert: () => parent.settings.matrixRoom = parent.defaults.matrixRoom,
          set: value => parent.settings.matrixRoom = value,
          get: () => parent.settings.matrixRoom
        }
      }
    }

    // , 'Subspace Hub Servers': {}
    ,

    'ICE Servers': {
      children: {
        'ICE Server #1': {
          input: 'string',
          subtext: 'ICE candidate server.',
          revert: () => parent.settings.iceServer1 = parent.defaults.iceServer1,
          set: value => parent.settings.iceServer1 = value,
          get: () => parent.settings.iceServer1
        },
        'ICE Server #2': {
          input: 'string',
          subtext: 'ICE candidate server.',
          revert: () => parent.settings.iceServer2 = parent.defaults.iceServer2,
          set: value => parent.settings.iceServer2 = value,
          get: () => parent.settings.iceServer2
        }
      }
    }
  }
});
const SettingsMenu = parent => {
  return {
    subtext: 'Edit your configuration.',
    children: () => {
      const children = {
        Video: videoMenu(parent),
        Audio: audioMenu(parent),
        Input: inputMenu(parent),
        Network: networkMenu(parent),
        Traces: _TraceMenu.TraceMenu
      };
      if (parent.args.debugEnabled) {
        children['Demos'] = _DemoMenu.DemoMenu;
        children['Costume'] = {
          children: {
            'Hue': {
              input: 'number',
              min: -180,
              max: +180,
              subtext: 'Rotate the color wheel.',
              revert: () => parent.customColor.h = 0,
              set: value => parent.customColor.h = Number(value).toFixed(2),
              get: () => parent.customColor.h
            },
            'Saturation': {
              input: 'number',
              min: 0,
              max: 2,
              step: 0.01,
              subtext: 'Rotate the color wheel.',
              revert: () => parent.customColor.s = 1,
              set: value => parent.customColor.s = Number(value).toFixed(2),
              get: () => parent.customColor.s
            },
            'Value': {
              input: 'number',
              min: 0,
              max: 2,
              step: 0.01,
              subtext: 'Rotate the color wheel.',
              revert: () => parent.customColor.v = 1,
              set: value => parent.customColor.v = Number(value).toFixed(2),
              get: () => parent.customColor.v
            }
          }
        };
      }
      return children;
    }
  };
};
exports.SettingsMenu = SettingsMenu;
});

;require.register("Menu/TraceMenu.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TraceMenu = void 0;
var _TraceDatabase = require("../trace/TraceDatabase");
var _ReplayDatabase = require("../replay/ReplayDatabase");
var _Replay = require("../replay/Replay");
const loadChildren = function loadChildren(parent, menu) {
  let offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  return _TraceDatabase.TraceDatabase.open('traces', 1).then(database => {
    const store = 'traces';
    const index = 'id';
    const limit = 10;
    const direction = 'prev';
    const query = {
      store: store,
      index: index,
      direction: direction,
      limit: limit,
      offset: offset
    };
    const children = {};
    return database.select(query).each(trace => {
      const subchildren = {
        'Export Trace': {
          callback: () => {
            // const shiftedDate = new Date(trace.created);
            const traceWin = window.open();
            traceWin.document.write(`${trace.uuid}\n` + `${trace.message}\n${trace.local}\n` + `${trace.buildTime}\n` + `${trace.created}\n\n` + `${trace.stack}\n`);
            traceWin.document.body.style.whiteSpace = 'pre';
            traceWin.document.body.style.fontFamily = 'monospace';
          }
        },
        'Export Replay': {
          callback: () => {
            _ReplayDatabase.ReplayDatabase.open('replays', 3).then(database => {
              const store = 'replays';
              const index = 'uuid';
              const type = _Replay.Replay;
              const range = trace.replay;
              const query = {
                store: store,
                index: index,
                offset: offset,
                type: type,
                range: range
              };
              const children = {};
              database.select(query).one(replay => {
                const fileContents = new Blob([JSON.stringify(replay)], {
                  type: 'text/json'
                });
                const fileUrl = URL.createObjectURL(fileContents);
                const fileLink = document.createElement('a');
                fileLink.href = fileUrl;
                fileLink.download = `${replay.name || replay.uuid}.json`;
                fileLink.click();
              });
            });
          }
        }
      };
      if (parent.args.debugEnabled) {
        subchildren['View Replay'] = {
          callback: () => {
            _ReplayDatabase.ReplayDatabase.open('replays', 3).then(database => {
              const store = 'replays';
              const index = 'uuid';
              const type = _Replay.Replay;
              const range = trace.replay;
              const query = {
                store: store,
                index: index,
                offset: offset,
                type: type,
                range: range
              };
              const children = {};
              console.log(trace.replay);
              parent.replayStart = parent.replayFrames.get(replay.firstFrame);
              database.select(query).one(replay => {
                parent.loadMap({
                  mapUrl: replay.map
                }).then(() => {
                  parent.replay = replay;
                  parent.replayFrames = replay.getIndexedFrames();
                  parent.maxReplayFrame = replay.lastFrame;
                  parent.args.paused = -1;
                  parent.args.frameId = -1;
                  parent.args.started = false;
                  parent.args.running = false;
                  parent.playback();
                  parent.replayOffset = -1 + replay.firstFrame;
                  if (loaded) {
                    menu.back();
                  }
                });
              });
            });
          }
        };
      }
      children[`${trace.id})${new Date(trace.created).toLocaleString('en-US')}`] = {
        subtext: trace.message,
        children: subchildren
      };
    }).then(results => {
      if (results.mapped) {
        children['Next ' + limit] = {
          children: () => loadChildren(parent, menu, offset + limit)
        };
      }
      return children;
    });
  });
};
const TraceMenu = {
  subtext: 'View error log.',
  children: loadChildren
};
exports.TraceMenu = TraceMenu;
});

require.register("Menu/ZoneSuffix.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ZoneSuffix = void 0;
var _View2 = require("curvature/base/View");
var _CharacterString = require("../ui/CharacterString");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let ZoneSuffix = /*#__PURE__*/function (_View) {
  _inherits(ZoneSuffix, _View);
  var _super = _createSuper(ZoneSuffix);
  function ZoneSuffix(args, parent) {
    var _this;
    _classCallCheck(this, ZoneSuffix);
    _this = _super.call(this, args, parent);
    _defineProperty(_assertThisInitialized(_this), "preserve", true);
    _defineProperty(_assertThisInitialized(_this), "template", `<div class = "zone-suffix">
	<div class = "row">
		<!-- <div class = "checkpoint"></div> -->
		<div class = "rings">[[rings]]</div>
		<div class = "time">[[time]]</div>
		<div class = "air">[[air]]</div>
		<div class = "score">[[score]]</div>
	</div>
	<div class = "row">
		<div class = "emblems" cv-each = "emblems:emblem">
			<img src = "/custom/hud-emblem.png" />
		</div>
	</div>
</div>`);
    _defineProperty(_assertThisInitialized(_this), "font", 'small-menu-font');
    parent.loadSaves().then(saves => {
      const state = parent.getZoneState(_this.args.map);
      const totalSeconds = Math.floor(state.time / 60);
      const ticks = String(Math.ceil(state.time % 60 * 1.67)).padEnd(2, '0');
      const seconds = String(state.time ? totalSeconds % 60 : 0).padStart(2, '0');
      const minutes = state.time ? Math.floor(totalSeconds / 60) : 0;
      _this.args.emblems = state.emblems;
      _this.args.rings = new _CharacterString.CharacterString({
        value: state.rings || 0,
        font: _this.font
      });
      _this.args.time = new _CharacterString.CharacterString({
        value: `${minutes}:${seconds}.${ticks}` || '--',
        font: _this.font
      });
      _this.args.air = new _CharacterString.CharacterString({
        value: (Number(state.air || 0) * 100).toFixed(2) + '%',
        font: _this.font
      });
      _this.args.score = new _CharacterString.CharacterString({
        value: state.score || 0,
        font: _this.font
      });
      console.log();
    });
    return _this;
  }
  return _createClass(ZoneSuffix);
}(_View2.View);
exports.ZoneSuffix = ZoneSuffix;
});

;require.register("Menu/main-menu.html", function(exports, require, module) {
module.exports = "<div class = \"screen-card screen-card-[[cardName]] [[animation]]\">\n\n\t<div class = \"menu-scroller\"></div>\n\n\t[[pinch]]\n\t[[twist]]\n\n\t<section class = \"buttons\">\n\t\t<span>[[select]]</span>\n\t\t<span>[[ok]]</span>\n\t\t<span>[[back]]</span>\n\t\t<span>[[revert]]</span>\n\t</section>\n\n\t<section class = \"contents\" cv-if = \"!connected\">\n\t\t<div class = \"menu-container\" data-current-menu = \"[[currentKey]]\">\n\t\t\t<div>[[title]]</div>\n\t\t\t<div>\n\t\t\t\t<ul cv-ref = \"bound\" cv-each = \"items:item:title\">\n\n\t\t\t\t\t<li data-title = \"[[title]]\" class = \"[[item.available]]\" cv-on = \"click:run(item, event); auxclick:altRun(item, event); keyup(event, item):c\" tabindex=\"0\" data-tags = \"[[item.tags]]\">\n\t\t\t\t\t\t[[item.prefix]]\n\t\t\t\t\t\t<span class = \"title\">[[item._title]]</span>\n\t\t\t\t\t\t<span class = \"subtext\">[[item.subtext]]</span>\n\t\t\t\t\t\t<span cv-if = \"item.input\" cv-is = \"output\">\n\t\t\t\t\t\t\t:\n\t\t\t\t\t\t\t<span data-wraps = \"output\">\n\t\t\t\t\t\t\t\t[[item._value]]\n\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t</span>\n\t\t\t\t\t\t<span cv-if = \"item.input\" cv-is = \"string\" class = \"field\">\n\t\t\t\t\t\t\t<span data-wraps = \"string\" data-click-barrier><input cv-ref = \"string\" cv-bind = \"item.setting\" cv-on = \"keyup(event);input:change(event, title)\" tabindex=\"-1\" /></span>\n\t\t\t\t\t\t</span>\n\t\t\t\t\t\t<span cv-if = \"item.input\" cv-is = \"number\" class = \"field\">\n\t\t\t\t\t\t\t<span data-wraps = \"number\"><input cv-ref = \"number\" cv-bind = \"item.setting\" type = \"number\" cv-on = \"keyup(event);change(event, title)\" tabindex=\"-1\" max = \"[[item.max]]\" min = \"[[item.min]]\" step = \"[[item.step]]\" /></span>\n\t\t\t\t\t\t</span>\n\t\t\t\t\t\t<span cv-if = \"item.input\" cv-is = \"boolean\" class = \"field\">\n\t\t\t\t\t\t\t<span data-wraps = \"select\">\n\t\t\t\t\t\t\t\t[[item._boolValue]]\n\t\t\t\t\t\t\t\t<select\n\t\t\t\t\t\t\t\t\tcv-on    = \"cvDomAttached:selectListRendered(event, item, title, $view, $subview, $parent);click:toggle(event,item);mousedown:cancel(event);input:change(event, title)\" cv-ref = \"boolean\"\n\t\t\t\t\t\t\t\t\tcv-bind = \"item.setting\"\n\t\t\t\t\t\t\t\t\ttabindex=\"-1\">\n\t\t\t\t\t\t\t\t<option value = \"1\">on</option>\n\t\t\t\t\t\t\t\t<option value = \"0\">off</option>\n\t\t\t\t\t\t\t</select></span>\n\t\t\t\t\t\t</span>\n\t\t\t\t\t\t<span cv-if = \"item.input\" cv-is = \"select\" class = \"field\">\n\t\t\t\t\t\t\t<span data-wraps = \"select\">\n\t\t\t\t\t\t\t\t[[item._selectValue]]\n\t\t\t\t\t\t\t\t<select\n\t\t\t\t\t\t\t\t\tcv-on    = \"input:change(event, title); listRendered:selectListRendered(event, item, title, $view, $subview, $parent);\"\n\t\t\t\t\t\t\t\t\tcv-ref   = \"options\"\n\t\t\t\t\t\t\t\t\tcv-bind  = \"item.setting\"\n\t\t\t\t\t\t\t\t\ttabindex = \"-1\"\n\t\t\t\t\t\t\t\t\tcv-each  = \"item.options:option\">\n\t\t\t\t\t\t\t\t\t<option value = \"[[option]]\">[[option]]</option>\n\t\t\t\t\t\t\t\t</select>\n\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t</span>\n\t\t\t\t\t\t[[item.suffix]]\n\t\t\t\t\t</li>\n\t\t\t\t</ul>\n\t\t\t</div>\n\t\t</div>\n\t</section>\n\n\t<section class = \"contents\" cv-if = \"!connected\">\n\t\t<section class = \"contents\" cv-if = \"lobby\">[[lobby]]</section>\n\t\t<section class = \"contents\" cv-if = \"hostGame\">\n\t\t\t<div class = \"token-exchange\" data-have-token = \"[[haveToken]]\">\n\t\t\t\t<label>\n\t\t\t\t\t<p>Input the token from your friend here.</p>\n\t\t\t\t\t<textarea cv-bind = \"input\" cv-on = \"click:paste(event)\"></textarea>\n\t\t\t\t\t<button cv-on = \"click:answer\">go!</button>\n\t\t\t\t</label>\n\n\t\t\t\t<label>\n\t\t\t\t\t<p>Send this token to your friend to get started.</p>\n\t\t\t\t\t<textarea cv-on = \"click:copy\" cv-ref = \"hostOutput\" cv-bind = \"hostOutput\" readonly = \"true\"></textarea>\n\t\t\t\t\t<button cv-on = \"click:copy\">[[copy]]</button>\n\t\t\t\t\t<div class = \"close\" cv-on = \"click:disconnect\"></div>\n\t\t\t\t</label>\n\t\t\t</div>\n\t\t</section>\n\n\t\t<section class = \"contents\" cv-if = \"joinGame\">\n\t\t\t<div class = \"token-exchange\">\n\t\t\t\t<label cv-if = \"haveToken\">\n\t\t\t\t\t<p>Send this token to your friend to get started.</p>\n\t\t\t\t\t<textarea cv-on = \"click:copy\" cv-ref = \"joinOutput\" cv-bind = \"joinOutput\" readonly = \"true\"></textarea>\n\t\t\t\t\t<button cv-on = \"click:copy\">[[copy]]</button>\n\t\t\t\t</label>\n\n\t\t\t\t<label cv-if = \"haveToken\">\n\t\t\t\t\t<p>Input the token they send back here.</p>\n\t\t\t\t\t<textarea cv-bind = \"input\" cv-on = \"click:paste(event)\"></textarea>\n\t\t\t\t\t<button cv-on = \"click:acceptRtp\">go!</button>\n\t\t\t\t\t<div class = \"close\" cv-on = \"click:disconnect\"></div>\n\t\t\t\t</label>\n\t\t\t</div>\n\t\t</section>\n\t</section>\n\t<section class = \"override\">[[override]]</section>\n</div>\n"
});

;require.register("Menu/menu.html", function(exports, require, module) {
module.exports = "<div class = \"screen-card screen-card-[[cardName]] [[animation]]\">\n\t<div class = \"menu-scroller\"></div>\n\t[[warp]]\n\t<div class = \"menu-container\" data-current-menu = \"[[currentKey]]\">\n\t\t<ul cv-ref = \"bound\" cv-each = \"items:item:title\">\n\t\t\t<li data-title = \"[[title]]\" class = \"[[item.available]]\" cv-on = \"click:run(item, event);cvDomDetached:removeItem(item);focus:handleFocus(event)\" tabindex=\"0\">\n\t\t\t\t<span class = \"title\">[[item._title]]</span>\n\t\t\t\t<span class = \"subtext\">[[item.subtext]]</span>\n\t\t\t\t<span cv-if = \"item.input\" cv-is = \"output\">\n\t\t\t\t\t: <span data-wraps = \"output\"><span cv-ref = \"output\" cv-bind = \"item.setting\"></span></span>\n\t\t\t\t</span>\n\t\t\t\t<span cv-if = \"item.input\" cv-is = \"string\">\n\t\t\t\t\t: <span data-wraps = \"string\"><input cv-ref = \"string\" cv-bind = \"item.setting\" cv-on = \"keyup(event);input:change(event)\" tabindex=\"-1\" /></span>\n\t\t\t\t</span>\n\t\t\t\t<span cv-if = \"item.input\" cv-is = \"number\">\n\t\t\t\t\t: <span data-wraps = \"number\"><input cv-ref = \"number\" cv-bind = \"item.setting\" type = \"number\" cv-on = \"keyup(event);change(event)\" tabindex=\"-1\" max = \"[[item.max]]\" min = \"[[item.min]]\" step = \"[[item.step]]\" /></span>\n\t\t\t\t</span>\n\t\t\t\t<span cv-if = \"item.input\" cv-is = \"range\">\n\t\t\t\t\t: <span data-wraps = \"range\"><input cv-ref = \"range\" cv-bind = \"item.setting\" type = \"range\" cv-on = \"keyup(event);change(event)\" tabindex=\"-1\" max = \"[[item.max]]\" min = \"[[item.min]]\" step = \"[[item.step]]\" /></span>\n\t\t\t\t</span>\n\t\t\t\t<span cv-if = \"item.input\" cv-is = \"boolean\">\n\t\t\t\t\t: <span data-wraps = \"select\"><select cv-on = \"click:toggle(event,item);mousedown:cancel(event);change(event)\" cv-ref = \"boolean\" cv-bind = \"item.setting\" tabindex=\"-1\">\n\t\t\t\t\t\t<option value = \"1\">on</option>\n\t\t\t\t\t\t<option value = \"0\">off</option>\n\t\t\t\t\t</select></span>\n\t\t\t\t</span>\n\t\t\t\t<span cv-if = \"item.input\" cv-is = \"select\">\n\t\t\t\t\t: <span data-wraps = \"select\"><select cv-on = \"change(event)\" cv-ref = \"select\" cv-bind = \"item.setting\" tabindex=\"-1\" cv-each = \"options:option:o\">\n\t\t\t\t\t\t<option value = \"[[o]]\">[[o]]</option>\n\t\t\t\t\t</select></span>\n\t\t\t\t</span>\n\t\t\t</li>\n\t\t</ul>\n\t</div>\n</div>\n"
});

;require.register("Menu/pause-menu.html", function(exports, require, module) {
module.exports = "<div class = \"screen-card screen-card-[[cardName]] [[animation]] [[hideMenu]]\">\n\n\t<div class = \"menu-scroller\"></div>\n\n\t[[warp]]\n\n\t<section class = \"contents\" cv-if = \"!connected\">\n\n\t\t<div class = \"menu-container\" data-current-menu = \"[[currentKey]]\">\n\n\t\t\t<div>[[title]]</div>\n\n\t\t\t<ul cv-ref = \"bound\" cv-each = \"items:item:title\">\n\n\t\t\t\t<li data-title = \"[[title]]\" class = \"[[item.available]]\" style = \"--color:[[item.color]];\" cv-on = \"click:run(item, event):c; auxclick:altRun(item, event); keyup(event, item):c; focus:handleFocus(event);\" tabindex=\"0\">\n\t\t\t\t\t[[item.prefix]]\n\t\t\t\t\t<span class = \"title\">[[item._title]]</span>\n\t\t\t\t\t<span class = \"subtext\">[[item.subtext]]</span>\n\t\t\t\t\t<span cv-if = \"item.input\" cv-is = \"string\">\n\t\t\t\t\t\t: <input cv-ref = \"string\" cv-bind = \"item.setting\" cv-on = \"keyup(event);input:change(event)\" tabindex=\"-1\" />\n\t\t\t\t\t</span>\n\t\t\t\t\t<span cv-if = \"item.input\" cv-is = \"number\">\n\t\t\t\t\t\t: <input cv-ref = \"number\" cv-bind = \"item.setting\" type = \"number\" cv-on = \"keyup(event);change(event)\" tabindex=\"-1\" max = \"[[item.max]]\" min = \"[[item.min]]\" step = \"[[item.step]]\" />\n\t\t\t\t\t</span>\n\t\t\t\t\t<span cv-if = \"item.input\" cv-is = \"boolean\">\n\t\t\t\t\t\t:\n\t\t\t\t\t\t<span data-wraps = \"select\">\n\t\t\t\t\t\t\t[[item._boolValue]]\n\t\t\t\t\t\t\t<select cv-on = \"click:toggle(event,item);mousedown:cancel(event);change(event)\" cv-ref = \"boolean\" cv-bind = \"item.setting\" tabindex=\"-1\">\n\t\t\t\t\t\t\t\t<option value = \"1\">on</option>\n\t\t\t\t\t\t\t\t<option value = \"0\">off</option>\n\t\t\t\t\t\t\t</select>\n\t\t\t\t\t\t</span>\n\t\t\t\t\t</span>\n\t\t\t\t\t<span cv-if = \"item.input\" cv-is = \"select\" class = \"field\">\n\t\t\t\t\t\t:\n\t\t\t\t\t\t<span data-wraps = \"select\">\n\t\t\t\t\t\t\t[[item._selectValue]]\n\t\t\t\t\t\t\t<select\n\t\t\t\t\t\t\t\tcv-on    = \"input:change(event, title); listRendered:selectListRendered(event, item, title, $view, $subview, $parent);\"\n\t\t\t\t\t\t\t\tcv-ref   = \"options\"\n\t\t\t\t\t\t\t\tcv-bind  = \"item.setting\"\n\t\t\t\t\t\t\t\ttabindex = \"-1\"\n\t\t\t\t\t\t\t\tcv-each  = \"item.options:option\">\n\t\t\t\t\t\t\t\t<option value = \"[[option]]\">[[option]]</option>\n\t\t\t\t\t\t\t</select>\n\t\t\t\t\t\t</span>\n\t\t\t\t\t</span>\n\t\t\t\t\t[[item.suffix]]\n\t\t\t\t</li>\n\t\t</ul>\n\n\t\t</div>\n\n\t</section>\n\n\t<section class = \"override\">[[override]]</section>\n\n</div>\n"
});

;require.register("ObjectPalette.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ObjectPalette = void 0;
var _PointActor = require("./actor/PointActor");
var _LayerSwitch = require("./actor/LayerSwitch");
var _Region = require("./region/Region");
var _ShadeRegion = require("./region/ShadeRegion");
var _BgShadeRegion = require("./region/BgShadeRegion");
var _FgShadeRegion = require("./region/FgShadeRegion");
var _WaterRegion = require("./region/WaterRegion");
var _DarkRegion = require("./region/DarkRegion");
var _LavaRegion = require("./region/LavaRegion");
var _ToxicRegion = require("./region/ToxicRegion");
var _PhazonRegion = require("./region/PhazonRegion");
var _RollingRegion = require("./region/RollingRegion");
var _SlidingRegion = require("./region/SlidingRegion");
var _GrindingRegion = require("./region/GrindingRegion");
var _ForceRegion = require("./region/ForceRegion");
var _FrictionRegion = require("./region/FrictionRegion");
var _CorkscrewRegion = require("./region/CorkscrewRegion");
var _BossRegion = require("./region/BossRegion");
var _ExitRegion = require("./region/ExitRegion");
var _LoadingRegion = require("./region/LoadingRegion");
var _ExplodingRegion = require("./region/ExplodingRegion");
var _SwitchRegion = require("./region/SwitchRegion");
var _RainRegion = require("./region/RainRegion");
var _DebrisRegion = require("./region/DebrisRegion");
var _WaterfallRegion = require("./region/WaterfallRegion");
var _KillRegion = require("./region/KillRegion");
var _VerticalRegion = require("./region/VerticalRegion");
var _VehicleRegion = require("./region/VehicleRegion");
var _DropVehicleRegion = require("./region/DropVehicleRegion");
var _PerspectiveRegion = require("./region/PerspectiveRegion");
var _CompanionBlock = require("./actor/CompanionBlock");
var _QuestionBlock = require("./actor/QuestionBlock");
var _MarbleBlock = require("./actor/MarbleBlock");
var _BreakableBlock = require("./actor/BreakableBlock");
var _Stopper = require("./actor/Stopper");
var _Zipline = require("./actor/Zipline");
var _Block3d = require("./actor/Block3d");
var _Block = require("./actor/Block");
var _Tree = require("./actor/Tree");
var _Coconut = require("./actor/Coconut");
var _Mushroom = require("./actor/Mushroom");
var _Door = require("./actor/Door");
var _PlatformFlare = require("./actor/PlatformFlare");
var _GravityPad = require("./actor/GravityPad");
var _Monitor = require("./actor/Monitor");
var _WebMonitor = require("./actor/monitor/WebMonitor");
var _RingMonitor = require("./actor/monitor/RingMonitor");
var _TripleRingMonitor = require("./actor/monitor/TripleRingMonitor");
var _InfoMonitor = require("./actor/monitor/InfoMonitor");
var _SheildStarMonitor = require("./actor/monitor/SheildStarMonitor");
var _SheildNormalMonitor = require("./actor/monitor/SheildNormalMonitor");
var _SheildFireMonitor = require("./actor/monitor/SheildFireMonitor");
var _SheildWaterMonitor = require("./actor/monitor/SheildWaterMonitor");
var _SheildElectricMonitor = require("./actor/monitor/SheildElectricMonitor");
var _Bumper = require("./actor/Bumper");
var _Flipper = require("./actor/Flipper");
var _SeeSaw = require("./actor/SeeSaw");
var _Cinematic = require("./actor/Cinematic");
var _Tumbler = require("./actor/Tumbler");
var _Flickie = require("./actor/Flickie");
var _Bubbles = require("./actor/Bubbles");
var _Redz = require("./actor/Redz");
var _GuardBot = require("./actor/GuardBot");
var _Sping = require("./actor/Sping");
var _CrabMeat = require("./actor/CrabMeat");
var _BuzzBomber = require("./actor/BuzzBomber");
var _MechaFroggy = require("./actor/MechaFroggy");
var _DrainFly = require("./actor/DrainFly");
var _GohlaBall = require("./actor/GohlaBall");
var _Voltorb = require("./actor/Voltorb");
var _Balkiry = require("./actor/Balkiry");
var _Jawz = require("./actor/Jawz");
var _SnailBot = require("./actor/SnailBot");
var _Motobug = require("./actor/Motobug");
var _BFish = require("./actor/BFish");
var _Grounder = require("./actor/Grounder");
var _Scratch = require("./actor/Scratch");
var _TechnoSqueak = require("./actor/TechnoSqueak");
var _Blastoid = require("./actor/Blastoid");
var _Meanie = require("./actor/Meanie");
var _SpringTurtle = require("./actor/SpringTurtle");
var _Sparkle = require("./actor/Sparkle");
var _Splats = require("./actor/Splats");
var _Relief = require("./actor/Relief");
var _Barnacle = require("./actor/Barnacle");
var _Skorp = require("./actor/Skorp");
var _RhinoBot = require("./actor/RhinoBot");
var _Gator = require("./actor/Gator");
var _ButterDroid = require("./actor/ButterDroid");
var _Catakiller = require("./actor/Catakiller");
var _CatakillerSegment = require("./actor/CatakillerSegment");
var _EggTroid = require("./actor/EggTroid");
var _SpitFire = require("./actor/SpitFire");
var _SpitSteam = require("./actor/SpitSteam");
var _Explosion = require("./actor/Explosion");
var _StarPost = require("./actor/StarPost");
var _ArrowSign = require("./actor/ArrowSign");
var _Emerald = require("./actor/Emerald");
var _FakeEmerald = require("./actor/FakeEmerald");
var _Window = require("./actor/Window");
var _Spring = require("./actor/Spring");
var _NotchSpring = require("./actor/NotchSpring");
var _BrokenMonitor = require("./actor/BrokenMonitor");
var _BoostRing = require("./actor/BoostRing");
var _Ring = require("./actor/Ring");
var _Coin = require("./actor/Coin");
var _Emblem = require("./actor/Emblem");
var _Apple = require("./actor/Apple");
var _AntiRing = require("./actor/AntiRing");
var _DropCage = require("./actor/DropCage");
var _SlotMachine = require("./actor/SlotMachine");
var _WaterFall = require("./actor/WaterFall");
var _WaterJet = require("./actor/WaterJet");
var _WaterSpout = require("./actor/WaterSpout");
var _PowerupGlow = require("./actor/PowerupGlow");
var _Projectile = require("./actor/Projectile");
var _TextActor = require("./actor/TextActor");
var _EggMobile = require("./actor/EggMobile");
var _SnowBoard = require("./actor/SnowBoard");
var _SkateBoard = require("./actor/SkateBoard");
var _DrillCar = require("./actor/DrillCar");
var _Tornado = require("./actor/Tornado");
var _RailCar = require("./actor/RailCar");
var _EggWalker = require("./actor/EggWalker");
var _EggShuttle = require("./actor/EggShuttle");
var _PogoSpring = require("./actor/PogoSpring");
var _NuclearSuperball = require("./actor/NuclearSuperball");
var _Platformer = require("./actor/Platformer");
var _MechaSonic = require("./actor/MechaSonic");
var _Eggrobo = require("./actor/Eggrobo");
var _Eggman = require("./actor/Eggman");
var _Sonic = require("./actor/Sonic");
var _Tails = require("./actor/Tails");
var _Knuckles = require("./actor/Knuckles");
var _Seymour = require("./actor/Seymour");
var _Chalmers = require("./actor/Chalmers");
var _Sean = require("./actor/Sean");
var _Big = require("./actor/Big");
var _Rocks = require("./actor/Rocks");
var _Switch = require("./actor/Switch");
var _HeavyDutySwitch = require("./actor/HeavyDutySwitch");
var _Balloon = require("./actor/Balloon");
var _StarBalloon = require("./actor/StarBalloon");
var _Spinner = require("./actor/Spinner");
var _HallBooster = require("./actor/HallBooster");
var _Springboard = require("./actor/Springboard");
var _GrapplePoint = require("./actor/GrapplePoint");
var _WoodenCrate = require("./actor/WoodenCrate");
var _SteelCrate = require("./actor/SteelCrate");
var _ChaoCrate = require("./actor/ChaoCrate");
var _UnbreakableCrate = require("./actor/UnbreakableCrate");
var _Rocket = require("./actor/Rocket");
var _Booster = require("./actor/Booster");
var _WindStone = require("./actor/WindStone");
var _Skull = require("./actor/Skull");
var _Pumpkin = require("./actor/Pumpkin");
var _RoadBarrier = require("./actor/RoadBarrier");
var _CautionPanel = require("./actor/CautionPanel");
var _Spikes = require("./actor/Spikes");
var _SpikesSmall = require("./actor/SpikesSmall");
var _Cone = require("./actor/Cone");
var _Fountain = require("./actor/Fountain");
var _CautionSign = require("./actor/CautionSign");
var _RollingSign = require("./actor/RollingSign");
var _Bell = require("./actor/Bell");
var _Torch = require("./actor/Torch");
var _LightSource = require("./actor/LightSource");
var _Signpost = require("./actor/Signpost");
var _Umbrella = require("./actor/Umbrella");
var _Dish = require("./actor/Dish");
var _RedEyeJet = require("./actor/RedEyeJet");
var _MiniMace = require("./actor/MiniMace");
var _MegaMace = require("./actor/MegaMace");
var _Beelzebub = require("./actor/Beelzebub");
var _MiniBoss = require("./actor/MiniBoss");
var _PogoEgg = require("./actor/PogoEgg");
var _Magnet = require("./actor/Magnet");
var _Pulley = require("./actor/Pulley");
var _PulleySmall = require("./actor/PulleySmall");
var _Orb = require("./actor/Orb");
var _OrbSmall = require("./actor/OrbSmall");
var _Egg = require("./actor/Egg");
var _Chao = require("./actor/Chao");
var _EggShellTop = require("./actor/EggShellTop");
var _EggShellBottom = require("./actor/EggShellBottom");
var _BackdropSwapper = require("./actor/BackdropSwapper");
var _LayerController = require("./actor/LayerController");
var _WaterController = require("./actor/WaterController");
var _TilesetSwapper = require("./actor/TilesetSwapper");
var _CutScene = require("./actor/CutScene");
var _HtmlFrame = require("./actor/HtmlFrame");
var _Panel = require("./actor/Panel");
var _Tester = require("./actor/Tester");
var _Cursor = require("./actor/Cursor");
var _MouseIndicator = require("./actor/MouseIndicator");
var _Spawner = require("./actor/Spawner");
var _NeverBetter = require("./actor/NeverBetter");
var _AsteroidLarge = require("./actor/AsteroidLarge");
var _AsteroidMedium = require("./actor/AsteroidMedium");
var _AsteroidSmall = require("./actor/AsteroidSmall");
var _Asteroid = require("./actor/Asteroid");
var _RocketPlatform = require("./actor/RocketPlatform");
var _PropellerPlatform = require("./actor/PropellerPlatform");
var _HexNut = require("./actor/HexNut");
var _SpinningFloat = require("./actor/SpinningFloat");
var _Turtloid = require("./actor/Turtloid");
var _CrossCannon = require("./actor/CrossCannon");
var _ChaoDetailer = require("./actor/ChaoDetailer");
var _Angel = require("./actor/Angel");
var _Flag = require("./actor/Flag");
var _GiantTire = require("./actor/GiantTire");
var _TruckBody = require("./actor/TruckBody");
var _TruckCab = require("./actor/TruckCab");
var _Dolphin = require("./actor/Dolphin");
var _Herculad = require("./actor/Herculad");
var _Chopper = require("./actor/Chopper");
var _TrickRamp = require("./actor/TrickRamp");
var _TwistRamp = require("./actor/TwistRamp");
var _AirBomb = require("./actor/AirBomb");
var _EggCapsule = require("./actor/EggCapsule");
var _SpikeRing = require("./actor/SpikeRing");
var _ToxicBarrel = require("./actor/ToxicBarrel");
var _SpinBridge = require("./actor/SpinBridge");
var _StoneAltar = require("./actor/StoneAltar");
var _BouncyMushroom = require("./actor/BouncyMushroom");
var _NitroBooster = require("./actor/NitroBooster");
var _LavaBall = require("./actor/LavaBall");
// Newtron
// Bomb

// import { SuperRing }   from './actor/SuperRing';

const ObjectPalette = {
  player: _NuclearSuperball.NuclearSuperball,
  cinematic: _Cinematic.Cinematic,
  spring: _Spring.Spring,
  'layer-switch': _LayerSwitch.LayerSwitch,
  'layer-controller': _LayerController.LayerController,
  'water-controller': _WaterController.WaterController,
  'backdrop-swapper': _BackdropSwapper.BackdropSwapper,
  'tileset-swapper': _TilesetSwapper.TilesetSwapper,
  'star-post': _StarPost.StarPost,
  'arrow-sign': _ArrowSign.ArrowSign,
  'projectile': _Projectile.Projectile,
  'block3d': _Block3d.Block3d,
  'block': _Block.Block,
  'tree': _Tree.Tree,
  'coconut': _Coconut.Coconut,
  'mushroom': _Mushroom.Mushroom,
  'door': _Door.Door,
  'platform-flare': _PlatformFlare.PlatformFlare,
  'gravity-pad': _GravityPad.GravityPad,
  'q-block': _QuestionBlock.QuestionBlock,
  'marble-block': _MarbleBlock.MarbleBlock,
  'companion-block': _CompanionBlock.CompanionBlock,
  'breakable-block': _BreakableBlock.BreakableBlock,
  'stopper': _Stopper.Stopper,
  'zipline': _Zipline.Zipline,
  'bumper': _Bumper.Bumper,
  'flipper': _Flipper.Flipper,
  'see-saw': _SeeSaw.SeeSaw,
  'drill-car': _DrillCar.DrillCar,
  'rail-car': _RailCar.RailCar,
  'tornado': _Tornado.Tornado,
  'egg-walker': _EggWalker.EggWalker,
  'snow-board': _SnowBoard.SnowBoard,
  'skate-board': _SkateBoard.SkateBoard,
  'egg-mobile': _EggMobile.EggMobile,
  'egg-shuttle': _EggShuttle.EggShuttle,
  'pogo-spring': _PogoSpring.PogoSpring,
  'rocks-tall': _Rocks.Rocks,
  'rocks-med': _Rocks.Rocks,
  'rocks-short': _Rocks.Rocks,
  'mecha-sonic': _MechaSonic.MechaSonic,
  'platformer': _Platformer.Platformer,
  'sonic': _Sonic.Sonic,
  'tails': _Tails.Tails,
  'knuckles': _Knuckles.Knuckles,
  'eggman': _Eggman.Eggman,
  'robotnik': _Eggman.Eggman,
  'eggrobo': _Eggrobo.Eggrobo,
  'seymour': _Seymour.Seymour,
  'chalmers': _Chalmers.Chalmers,
  'sean': _Sean.Sean,
  'big': _Big.Big,
  'switch': _Switch.Switch,
  'heavy-duty-switch': _HeavyDutySwitch.HeavyDutySwitch,
  'window': _Window.Window,
  'emerald': _Emerald.Emerald,
  'fake-emerald': _FakeEmerald.FakeEmerald,
  'base-region': _Region.Region,
  'region': _WaterRegion.WaterRegion,
  'lava-region': _LavaRegion.LavaRegion,
  'toxic-region': _ToxicRegion.ToxicRegion,
  'phazon-region': _PhazonRegion.PhazonRegion,
  'dark-region': _DarkRegion.DarkRegion,
  'shade-region': _ShadeRegion.ShadeRegion,
  'force-region': _ForceRegion.ForceRegion,
  'friction-region': _FrictionRegion.FrictionRegion,
  'corkscrew-region': _CorkscrewRegion.CorkscrewRegion,
  'rolling-region': _RollingRegion.RollingRegion,
  'sliding-region': _SlidingRegion.SlidingRegion,
  'grinding-region': _GrindingRegion.GrindingRegion,
  'exploding-region': _ExplodingRegion.ExplodingRegion,
  'boss-region': _BossRegion.BossRegion,
  'exit-region': _ExitRegion.ExitRegion,
  'loading-region': _LoadingRegion.LoadingRegion,
  'switch-region': _SwitchRegion.SwitchRegion,
  'rain-region': _RainRegion.RainRegion,
  'debris-region': _DebrisRegion.DebrisRegion,
  'waterfall-region': _WaterfallRegion.WaterfallRegion,
  'kill-region': _KillRegion.KillRegion,
  'vertical-region': _VerticalRegion.VerticalRegion,
  'vehicle-region': _VehicleRegion.VehicleRegion,
  'drop-vehicle-region': _DropVehicleRegion.DropVehicleRegion,
  'perspective-region': _PerspectiveRegion.PerspectiveRegion,
  'boost-ring': _BoostRing.BoostRing,
  'ring': _Ring.Ring,
  'antiring': _AntiRing.AntiRing
  // , 'super-ring':   SuperRing
  ,
  'coin': _Coin.Coin,
  'emblem': _Emblem.Emblem,
  'notch-spring': _NotchSpring.NotchSpring,
  'apple': _Apple.Apple,
  'drop-cage': _DropCage.DropCage,
  'slot-machine': _SlotMachine.SlotMachine,
  'powerup-glow': _PowerupGlow.PowerupGlow,
  'explosion': _Explosion.Explosion,
  'text-actor': _TextActor.TextActor,
  'water-jet': _WaterJet.WaterJet,
  'water-fall': _WaterFall.WaterFall,
  'water-spout': _WaterSpout.WaterSpout,
  'balloon': _Balloon.Balloon,
  'star-balloon': _StarBalloon.StarBalloon,
  'web-monitor': _WebMonitor.WebMonitor,
  'ring-monitor': _RingMonitor.RingMonitor,
  'triple-ring-monitor': _TripleRingMonitor.TripleRingMonitor,
  'info-monitor': _InfoMonitor.InfoMonitor,
  'sheild-fire-monitor': _SheildFireMonitor.SheildFireMonitor,
  'sheild-normal-monitor': _SheildNormalMonitor.SheildNormalMonitor,
  'sheild-star-monitor': _SheildStarMonitor.SheildStarMonitor,
  'sheild-water-monitor': _SheildWaterMonitor.SheildWaterMonitor,
  'sheild-electric-monitor': _SheildElectricMonitor.SheildElectricMonitor,
  'flickie': _Flickie.Flickie,
  'crabmeat': _CrabMeat.CrabMeat,
  'redz': _Redz.Redz,
  'guard-bot': _GuardBot.GuardBot,
  'sping': _Sping.Sping,
  'mecha-froggy': _MechaFroggy.MechaFroggy,
  'buzz-bomber': _BuzzBomber.BuzzBomber,
  'bubbles': _Bubbles.Bubbles,
  'drainfly': _DrainFly.DrainFly,
  'gohla-ball': _GohlaBall.GohlaBall,
  'voltorb': _Voltorb.Voltorb,
  'balkiry': _Balkiry.Balkiry,
  'jawz': _Jawz.Jawz,
  'snailbot': _SnailBot.SnailBot,
  'motobug': _Motobug.Motobug,
  'b-fish': _BFish.BFish,
  'grounder': _Grounder.Grounder,
  'scratch': _Scratch.Scratch,
  'techno-squeak': _TechnoSqueak.TechnoSqueak,
  'blastoid': _Blastoid.Blastoid,
  'meanie': _Meanie.Meanie,
  'spring-turtle': _SpringTurtle.SpringTurtle,
  'sparkle': _Sparkle.Sparkle,
  'splats': _Splats.Splats,
  'relief': _Relief.Relief,
  'barnacle': _Barnacle.Barnacle,
  'skorp': _Skorp.Skorp,
  'rhino-bot': _RhinoBot.RhinoBot,
  'gator': _Gator.Gator,
  'butter-droid': _ButterDroid.ButterDroid,
  'catakiller': _Catakiller.Catakiller,
  'catakiller-segment': _CatakillerSegment.CatakillerSegment,
  'eggtroid': _EggTroid.EggTroid,
  'spitfire': _SpitFire.SpitFire,
  'spitsteam': _SpitSteam.SpitSteam,
  'grapple-point': _GrapplePoint.GrapplePoint,
  'rocket': _Rocket.Rocket,
  'booster': _Booster.Booster,
  'spinner': _Spinner.Spinner,
  'hall-booster': _HallBooster.HallBooster,
  'springboard': _Springboard.Springboard,
  'wooden-crate': _WoodenCrate.WoodenCrate,
  'steel-crate': _SteelCrate.SteelCrate,
  'chao-crate': _ChaoCrate.ChaoCrate,
  'unbreakable-crate': _UnbreakableCrate.UnbreakableCrate,
  'road-barrier': _RoadBarrier.RoadBarrier,
  'caution-panel': _CautionPanel.CautionPanel,
  'signpost': _Signpost.Signpost,
  'umbrella': _Umbrella.Umbrella,
  'dish': _Dish.Dish,
  'red-eye-jet': _RedEyeJet.RedEyeJet,
  'beelzebub': _Beelzebub.Beelzebub,
  'pogo-egg': _PogoEgg.PogoEgg,
  'mini-boss': _MiniBoss.MiniBoss,
  'mini-mace': _MiniMace.MiniMace,
  'mega-mace': _MegaMace.MegaMace,
  'magnet': _Magnet.Magnet,
  'pulley': _Pulley.Pulley,
  'pulley-small': _PulleySmall.PulleySmall,
  'spikes': _Spikes.Spikes,
  'spikes-small': _SpikesSmall.SpikesSmall,
  'cone': _Cone.Cone,
  'wind-stone': _WindStone.WindStone,
  'skull': _Skull.Skull,
  'pumpkin': _Pumpkin.Pumpkin,
  'fountain': _Fountain.Fountain,
  'caution-sign': _CautionSign.CautionSign,
  'rolling-sign': _RollingSign.RollingSign,
  'bell': _Bell.Bell,
  'torch': _Torch.Torch,
  'light-source': _LightSource.LightSource,
  'orb': _Orb.Orb,
  'orb-small': _OrbSmall.OrbSmall,
  'chao': _Chao.Chao,
  'egg': _Egg.Egg,
  'egg-shell-top': _EggShellTop.EggShellTop,
  'egg-shell-bottom': _EggShellBottom.EggShellBottom,
  'cut-scene': _CutScene.CutScene
  // , 'html-frame': HtmlFrame
  ,
  'panel': _Panel.Panel,
  'tester': _Tester.Tester,
  'cursor': _Cursor.Cursor,
  'mouse-indicator': _MouseIndicator.MouseIndicator,
  'spawner': _Spawner.Spawner,
  'never-better': _NeverBetter.NeverBetter,
  'asteroid-large': _AsteroidLarge.AsteroidLarge,
  'asteroid-medium': _AsteroidMedium.AsteroidMedium,
  'asteroid-small': _AsteroidSmall.AsteroidSmall,
  'asteroid': _Asteroid.Asteroid,
  'rocket-platform': _RocketPlatform.RocketPlatform,
  'propeller-platform': _PropellerPlatform.PropellerPlatform,
  'hex-nut': _HexNut.HexNut,
  'spinning-float': _SpinningFloat.SpinningFloat,
  'turtloid': _Turtloid.Turtloid,
  'angel': _Angel.Angel,
  'chao-detailer': _ChaoDetailer.ChaoDetailer,
  'cross-cannon': _CrossCannon.CrossCannon,
  'tumbler': _Tumbler.Tumbler,
  'flag': _Flag.Flag,
  'giant-tire': _GiantTire.GiantTire,
  'truck-body': _TruckBody.TruckBody,
  'truck-cab': _TruckCab.TruckCab,
  'dolphin': _Dolphin.Dolphin,
  'herculad': _Herculad.Herculad,
  'chopper': _Chopper.Chopper,
  'trick-ramp': _TrickRamp.TrickRamp,
  'twist-ramp': _TwistRamp.TwistRamp,
  'air-bomb': _AirBomb.AirBomb,
  'egg-capsule': _EggCapsule.EggCapsule,
  'spike-ring': _SpikeRing.SpikeRing,
  'toxic-barrel': _ToxicBarrel.ToxicBarrel,
  'spin-bridge': _SpinBridge.SpinBridge,
  'stone-altar': _StoneAltar.StoneAltar,
  'bouncy-mushroom': _BouncyMushroom.BouncyMushroom,
  'nitro-booster': _NitroBooster.NitroBooster,
  'lava-ball': _LavaBall.LavaBall
};
exports.ObjectPalette = ObjectPalette;
});

require.register("QuadCell.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.QuadCell = void 0;
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
const CellRef = Symbol('CellRef');
let QuadCell = /*#__PURE__*/function () {
  function QuadCell(minSize) {
    let position = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
      x: 0,
      y: 0
    };
    let size = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
      x: 0,
      y: 0
    };
    let parent = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    _classCallCheck(this, QuadCell);
    _defineProperty(this, "position", {});
    _defineProperty(this, "size", {});
    _defineProperty(this, "divided", false);
    _defineProperty(this, "parent", null);
    _defineProperty(this, "leafPoint", {
      x: null,
      y: null
    });
    _defineProperty(this, "leafRefs", null);
    _defineProperty(this, "ld", null);
    _defineProperty(this, "rd", null);
    _defineProperty(this, "lu", null);
    _defineProperty(this, "ru", null);
    _defineProperty(this, "cells", []);
    _defineProperty(this, "minSize", 0);
    this.parent = parent;
    this.position.x = position.x;
    this.position.y = position.y;
    this.size.x = size.x;
    this.size.y = size.y;
    this.minSize = minSize;
    Object.seal(this);
  }
  _createClass(QuadCell, [{
    key: "empty",
    value: function empty() {
      let depth = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      if (!this.divided) {
        if (!this.leafRefs) {
          return true;
        }
        return !this.leafRefs.size;
      }
      for (const c in this.cells) {
        if (!this.cells[c].empty(depth + 1)) {
          return false;
        }
      }
      return true;
    }
  }, {
    key: "insert",
    value: function insert(object) {
      let point = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
        x: 0,
        y: 0
      };
      if (!this.contains(point)) {
        return false;
      }
      if (!this.leafRefs && !this.divided) {
        this.leafRefs = new Set();
        this.leafPoint.x = point.x;
        this.leafPoint.y = point.y;
        this.leafRefs.add(object);
        object[CellRef] = this;
        return true;
      } else if (this.size.x <= this.minSize) {
        this.leafRefs.add(object);
        object[CellRef] = this;
        return true;
      } else if (this.leafRefs && point.x === this.leafPoint.x && point.y === this.leafPoint.y) {
        this.leafRefs.add(object);
        object[CellRef] = this;
        return true;
      } else if (!this.divided) {
        this.divide();
      }
      for (const cell of this.cells) {
        if (cell.insert(object, point)) {
          return true;
        }
      }
      return false;
    }
  }, {
    key: "move",
    value: function move(object, point) {
      const cell = object[CellRef];
      if (cell) {
        if (cell.leafPoint.x === point.x && cell.leafPoint.y === point.y) {
          return;
        }
        object[CellRef] = null;
        cell.leafRefs.delete(object);
        if (cell.parent) {
          cell.parent.join();
        }
      }
      this.insert(object, point);
    }
  }, {
    key: "remove",
    value: function remove(object) {
      const cell = object[CellRef];
      if (!cell) {
        return;
      }
      object[CellRef] = null;
      cell.leafRefs.delete(object);
      if (cell.parent) {
        cell.parent.join();
      }
    }
  }, {
    key: "join",
    value: function join() {
      if (!this.empty()) {
        return false;
      }
      let nonEmpty = null;
      for (const cell of this.cells) {
        if (!cell.empty()) {
          if (nonEmpty) {
            return false;
          }
          nonEmpty = cell;
        }
      }
      this.ld = null;
      this.rd = null;
      this.lu = null;
      this.ru = null;
      this.cells = [];
      this.divided = false;
      if (nonEmpty) {
        nonEmpty.leafRefs.forEach(l => this.insert(l));
      }
      if (this.parent) {
        this.parent.join();
      }
    }
  }, {
    key: "divide",
    value: function divide() {
      if (this.divided) {
        return false;
      }
      const p = this.position;
      const s = this.size;
      const m = this.minSize;
      this.ld = new this.constructor(m, {
        x: p.x - s.x / 4,
        y: p.y - s.y / 4
      }, {
        x: s.x / 2,
        y: s.y / 2
      }, this);
      this.rd = new this.constructor(m, {
        x: p.x + s.x / 4,
        y: p.y - s.y / 4
      }, {
        x: s.x / 2,
        y: s.y / 2
      }, this);
      this.lu = new this.constructor(m, {
        x: p.x - s.x / 4,
        y: p.y + s.y / 4
      }, {
        x: s.x / 2,
        y: s.y / 2
      }, this);
      this.ru = new this.constructor(m, {
        x: p.x + s.x / 4,
        y: p.y + s.y / 4
      }, {
        x: s.x / 2,
        y: s.y / 2
      }, this);
      this.cells.push(this.ld, this.rd, this.lu, this.ru);
      this.divided = true;
      if (!this.leafRefs.size) {
        return true;
      }
      refs: for (const ref of this.leafRefs) {
        cells: for (const cell of this.cells) {
          const inserted = cell.insert(ref, this.leafPoint);
          if (inserted) {
            this.leafRefs.delete(ref);
            continue refs;
          }
        }
      }
    }
  }, {
    key: "contains",
    value: function contains() {
      let point = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
        x: 0,
        y: 0
      };
      const xMin = this.position.x - this.size.x / 2;
      const xMax = this.position.x + this.size.x / 2;
      if (point.x < xMin || point.x > xMax) {
        return false;
      }
      const yMin = this.position.y - this.size.y / 2;
      const yMax = this.position.y + this.size.y / 2;
      if (point.y < yMin || point.y > yMax) {
        return false;
      }
      return true;
    }
  }, {
    key: "select",
    value: function select(xPos, yPos, xSize, ySize) {
      let depth = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
      if (this.empty()) {
        return [];
      }
      const xMax = xSize / 2 + this.size.x / 2;
      if (xMax < Math.abs(xPos - this.position.x)) {
        return [];
      }
      const yMax = ySize / 2 + this.size.y / 2;
      if (yMax < Math.abs(yPos - this.position.y)) {
        return [];
      }
      if (this.divided) {
        const results = new Set();
        for (const cell of this.cells) {
          for (const result of cell.select(xPos, yPos, xSize, ySize, depth + 1)) {
            results.add(result);
          }
        }
        return results;
      }
      return this.leafRefs ? this.leafRefs : [];
    }
  }]);
  return QuadCell;
}();
exports.QuadCell = QuadCell;
});

;require.register("ScriptPalette.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ScriptPalette = void 0;
const ScriptPalette = {
  'infinite-ruin': require('./zoneScripts/InfiniteRuin').InfiniteRuin,
  'chao-garden': require('./zoneScripts/ChaoGarden').ChaoGarden
};
exports.ScriptPalette = ScriptPalette;
});

;require.register("World.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.World = void 0;
var _Bag = require("curvature/base/Bag");
var _Bindable = require("curvature/base/Bindable");
var _TileMap = require("tileMap/TileMap");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let World = /*#__PURE__*/function () {
  function World() {
    _classCallCheck(this, World);
    _defineProperty(this, "tileMap", new _TileMap.TileMap());
    this.viewports = new _Bag.Bag((i, s, a) => {
      switch (a) {
        case BAG.ITEM_ADDED:
          i.world = this;
          break;
        case BAG.ITEM_REMOVED:
          i.world = null;
          break;
      }
    });
    this.actors = new _Bag.Bag((i, s, a) => {
      switch (a) {
        case BAG.ITEM_ADDED:
          i.world = this;
          break;
        case BAG.ITEM_REMOVED:
          i.world = null;
          break;
      }
    });
  }
  _createClass(World, [{
    key: "getOnScreenObjects",
    value: function getOnScreenObjects(tolerance) {}
  }, {
    key: "update",
    value: function update() {}
  }]);
  return World;
}();
exports.World = World;
_defineProperty(World, "globals", _Bindable.Bindable.make({}));
});

;require.register("abilities/LightDash.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LightDash = void 0;
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
let LightDash = /*#__PURE__*/_createClass(function LightDash() {
  _classCallCheck(this, LightDash);
});
exports.LightDash = LightDash;
});

;require.register("actor/AirBomb.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AirBomb = void 0;
var _PointActor2 = require("./PointActor");
var _Sfx = require("../audio/Sfx");
var _Tag = require("curvature/base/Tag");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let AirBomb = /*#__PURE__*/function (_PointActor) {
  _inherits(AirBomb, _PointActor);
  var _super = _createSuper(AirBomb);
  function AirBomb() {
    var _this;
    _classCallCheck(this, AirBomb);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.width = 22;
    _this.args.height = 32;
    _this.args.type = 'actor-item actor-air-bomb';
    _this.args.decel = 0;
    _this.explosions = new Set();
    return _this;
  }
  _createClass(AirBomb, [{
    key: "update",
    value: function update() {
      if (!this.args.falling && !this.explosions.size) {
        this.explode();
      }
      _get(_getPrototypeOf(AirBomb.prototype), "update", this).call(this);
      for (const explosion of this.explosions) {
        explosion.style({
          '--x': this.args.x,
          '--y': this.args.y + -16
        });
      }
    }
  }, {
    key: "collideA",
    value: function collideA(other) {
      if (!other.controllable) {
        return;
      }
      other.damage(this);
      this.explode();
      this.args.float = -1;
      this.args.xSpeed = 0;
      this.args.ySpeed = 0;
    }
  }, {
    key: "explode",
    value: function explode() {
      if (this.exploded) {
        return;
      }
      this.exploded = true;
      this.args.type = 'actor-item actor-air-bomb hide';
      const explosionTag = document.createElement('div');
      explosionTag.classList.add('particle-huge-explosion');
      const explosion = new _Tag.Tag(explosionTag);
      this.explosions.add(explosion);
      const viewport = this.viewport;
      this.viewport.particles.add(explosion);
      this.viewport.onFrameOut(30, () => {
        viewport.particles.remove(explosion);
        viewport.actors.remove(this);
        this.explosions.delete(explosion);
      });
      _Sfx.Sfx.play('OBJECT_DESTROYED');
    }
  }]);
  return AirBomb;
}(_PointActor2.PointActor);
exports.AirBomb = AirBomb;
});

;require.register("actor/Angel.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Angel = void 0;
var _PointActor2 = require("./PointActor");
var _Liftable = require("../behavior/Liftable");
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let Angel = /*#__PURE__*/function (_PointActor) {
  _inherits(Angel, _PointActor);
  var _super = _createSuper(Angel);
  function Angel() {
    var _this;
    _classCallCheck(this, Angel);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.type = 'actor-item actor-angel';
    _this.args.width = 45;
    _this.args.height = 80;
    return _this;
  }
  return _createClass(Angel);
}(_PointActor2.PointActor);
exports.Angel = Angel;
});

;require.register("actor/AntiRing.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AntiRing = void 0;
var _PointActor2 = require("./PointActor");
var _Sfx = require("../audio/Sfx");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let AntiRing = /*#__PURE__*/function (_PointActor) {
  _inherits(AntiRing, _PointActor);
  var _super = _createSuper(AntiRing);
  function AntiRing() {
    var _this$args$static, _this$args$dropped, _this$args$delay;
    var _this;
    _classCallCheck(this, AntiRing);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _defineProperty(_assertThisInitialized(_this), "template", `<div class  = "point-actor [[type]]">
		<div class = "sprite" cv-ref = "sprite"></div>
	</div>`);
    _defineProperty(_assertThisInitialized(_this), "float", -1);
    _this.args.type = 'actor-item actor-anti-ring';
    _this.args.width = 15;
    _this.args.height = 15;
    _this.args.static = (_this$args$static = _this.args.static) !== null && _this$args$static !== void 0 ? _this$args$static : true;
    _this.args.dropped = (_this$args$dropped = _this.args.dropped) !== null && _this$args$dropped !== void 0 ? _this$args$dropped : true;
    _this.args.gone = false;
    _this.args.gravity = 0.40;
    _this.args.delay = (_this$args$delay = _this.args.delay) !== null && _this$args$delay !== void 0 ? _this$args$delay : 48;
    return _this;
  }
  _createClass(AntiRing, [{
    key: "update",
    value: function update() {
      if (!this.viewport) {
        return;
      }
      const currentFrame = this.viewport.args.frameId;
      const startFrame = this.startFrame;
      const age = currentFrame - startFrame;
      if (this.args.noClip) {
        this.noClip = true;
      } else if (!this.args.decoration) {
        if (this.args.ySpeed < 0) {
          this.noClip = true;
        } else if (!this.attract) {
          this.noClip = false;
        }
      } else {
        this.noClip = true;
      }
      if (this.args.decoration) {
        this.args.type = 'actor-item actor-anti-ring decoration';
        this.args.gravity = 0.36;
      }
      if (this.dropped) {
        this.args.type = 'actor-item actor-anti-ring dropped';
        this.args.height = 14;
      }
      const viewport = this.viewport;
      if (this.dropped && this.viewport && !this.viewport.actorIsOnScreen(this, 256)) {
        viewport.onFrameOut(15, () => {
          viewport.actors.remove(this);
        });
      }
      if (this.args.reward && this.args.gone) {
        viewport.onFrameOut(15, () => {
          viewport.actors.remove(this);
        });
      }
      _get(_getPrototypeOf(AntiRing.prototype), "update", this).call(this);
      if (this.args.reward) {
        return;
      }
      if (this.getMapSolidAt(this.x + this.args.xSpeed * this.args.direction, this.y + -8)) {
        this.args.xSpeed *= -1;
      }
      if ((this.dropped || this.scattered) && (!this.args.falling || !this.args.ySpeed)) {
        this.args.xSpeed = this.args.xSpeed || this.xSpeedLast || Math.random() - 0.5;
        this.args.ySpeed = Math.min(-Math.abs(this.args.ySpeed || this.ySpeedLast || 0) * 0.75, -5);
        this.args.gSpeed = 0;
        this.args.x += this.args.xSpeed;
        this.args.y += this.args.ySpeed;
        this.args.falling = true;
        this.args.groundAngle = 0;
      }
    }
  }, {
    key: "callCollideHandler",
    value: function callCollideHandler(other) {
      if (other instanceof AntiRing) {
        return false;
      }
      return _get(_getPrototypeOf(AntiRing.prototype), "callCollideHandler", this).call(this, other);
    }
  }, {
    key: "collideA",
    value: function collideA(other) {
      if (other instanceof this.constructor) {
        return;
      }
      if (!this.viewport || this.args.gone || this.args.ignore) {
        return false;
      }
      if (!other.controllable && !other.occupant && !other.args.owner) {
        return false;
      }
      const age = this.viewport.args.frameId - this.startFrame;
      if (this.dropped && age < this.args.delay) {
        return false;
      }
      _get(_getPrototypeOf(AntiRing.prototype), "collideA", this).call(this, other);
      if (other.args.owner) {
        other = other.args.owner;
      }
      if (other.occupant) {
        other = other.occupant;
      }
      if (other.controllable) {
        other.args.rings -= 1;
      }
      this.args.gone = true;
      this.viewport.auras.delete(this);

      // this.args.xSpeed = 0;
      // this.args.ySpeed = 0;
      this.args.static = true;
      this.args.float = -1;
      this.args.type = 'actor-item actor-anti-ring collected';
      this.args.xSpeed = 0;
      this.args.ySpeed = 0;
      if (this.viewport.args.audio) {
        _Sfx.Sfx.play('SPIKE_DAMAGE');
      }
      this.viewport.onFrameOut(5, () => {
        this.args.type = 'actor-item actor-anti-ring collected gone';
      });
      const x = this.x;
      const y = this.y;
      const viewport = this.viewport;
      this.viewport.onFrameOut(1200, () => {
        this.restore = true;
      });
      if (other.collect) {
        this.onNextFrame(() => {
          other.collect(this);
        });
      }

      // this.args.xSpeed = 0;
      // this.args.ySpeed = 0;
    }
  }, {
    key: "wakeUp",
    value: function wakeUp() {
      if (this.def && this.restore) {
        this.args.x = this.def.get('x');
        this.args.y = this.def.get('y');
        // this.args.float = -1;

        this.args.gone = this.restore = false;
        this.args.type = 'actor-item actor-anti-ring';
      }
    }
  }, {
    key: "solid",
    get: function get() {
      return false;
    }
  }, {
    key: "rotateLock",
    get: function get() {
      return true;
    }
  }]);
  return AntiRing;
}(_PointActor2.PointActor);
exports.AntiRing = AntiRing;
});

;require.register("actor/Apple.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Apple = void 0;
var _PointActor2 = require("./PointActor");
var _Sfx = require("../audio/Sfx");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let Apple = /*#__PURE__*/function (_PointActor) {
  _inherits(Apple, _PointActor);
  var _super = _createSuper(Apple);
  function Apple() {
    var _this;
    _classCallCheck(this, Apple);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.width = 11;
    _this.args.height = 11;
    _this.args.type = 'actor-item actor-apple';
    _this.args.float = -1;
    _this.collected = false;
    return _this;
  }
  _createClass(Apple, [{
    key: "onRendered",
    value: function onRendered(event) {
      // const zoneState = this.viewport.getZoneState();
      // if(zoneState.apples.includes(this.args.id))
      // {
      // 	this.args.type = 'actor-item actor-apple actor-apple-collected';
      // 	this.collected = true;
      // }

      return _get(_getPrototypeOf(Apple.prototype), "onRendered", this).call(this, event);
    }
  }, {
    key: "collideA",
    value: function collideA(other) {
      if (!other.controllable || this.gone) {
        return;
      }
      const viewport = this.viewport;
      const zoneState = viewport.getZoneState();
      if (!this.collected) {
        // other.args.apples.push(this);
        // zoneState.apples.push(this.args.id);
        this.args.type = 'actor-item actor-apple actor-apple-gone';
      } else {
        this.args.type = 'actor-item actor-apple actor-apple-gone actor-apple-collected';
      }
      this.gone = true;
      viewport.onFrameOut(20, () => {
        viewport.actors.remove(this);
      });
      viewport.currentSave.save();
      if (this.viewport.args.audio) {
        _Sfx.Sfx.play('apple_COLLECTED');
      }
    }
  }]);
  return Apple;
}(_PointActor2.PointActor);
exports.Apple = Apple;
});

;require.register("actor/ArrowSign.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ArrowSign = void 0;
var _PointActor2 = require("./PointActor");
var _Tag = require("curvature/base/Tag");
var _Projectile = require("../actor/Projectile");
var _Monitor = require("./Monitor");
var _RingMonitor = require("./monitor/RingMonitor");
var _SheildFireMonitor = require("./monitor/SheildFireMonitor");
var _SheildWaterMonitor = require("./monitor/SheildWaterMonitor");
var _SheildElectricMonitor = require("./monitor/SheildElectricMonitor");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let ArrowSign = /*#__PURE__*/function (_PointActor) {
  _inherits(ArrowSign, _PointActor);
  var _super = _createSuper(ArrowSign);
  function ArrowSign() {
    var _this$args$float, _this$args$static;
    var _this;
    let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let parent = arguments.length > 1 ? arguments[1] : undefined;
    _classCallCheck(this, ArrowSign);
    _this = _super.call(this, args, parent);
    _this.args.type = 'actor-item actor-arrow-sign';
    _this.args.float = (_this$args$float = _this.args.float) !== null && _this$args$float !== void 0 ? _this$args$float : -1;
    _this.args.static = (_this$args$static = _this.args.static) !== null && _this$args$static !== void 0 ? _this$args$static : true;
    _this.args.width = args.width || 32;
    _this.args.height = args.height || 64;
    return _this;
  }
  _createClass(ArrowSign, [{
    key: "onRendered",
    value: function onRendered(event) {
      _get(_getPrototypeOf(ArrowSign.prototype), "onRendered", this).call(this, event);
      if (this.headBox) {
        return;
      }
      this.sprite = this.findTag('div.sprite');
      this.box = this.findTag('div');
      this.headBox = new _Tag.Tag('<div class = "arrow-sign-head-box">');
      this.post = new _Tag.Tag('<div class = "arrow-sign-post">');
      this.head = new _Tag.Tag('<div class = "arrow-sign-head">');
      this.sprite.appendChild(this.post.node);
      this.headBox.appendChild(this.head.node);
      this.sprite.appendChild(this.headBox.node);
      this.args.bindTo(['point', 'height'], (v, k) => {
        this.headBox.style(_defineProperty({}, '--' + k, v));
      });
    }
  }, {
    key: "solid",
    get: function get() {
      return false;
    }
  }], [{
    key: "fromDef",
    value: function fromDef(objDef) {
      const obj = _get(_getPrototypeOf(ArrowSign), "fromDef", this).call(this, objDef);
      obj.args.rotation = objDef.rotation;
      obj.args.height = objDef.height;
      return obj;
    }
  }]);
  return ArrowSign;
}(_PointActor2.PointActor);
exports.ArrowSign = ArrowSign;
});

;require.register("actor/Asteroid.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Asteroid = void 0;
var _PointActor2 = require("./PointActor");
var _Block = require("./Block");
var _Sfx = require("../audio/Sfx");
var _AsteroidLarge = require("./AsteroidLarge");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let Asteroid = /*#__PURE__*/function (_PointActor) {
  _inherits(Asteroid, _PointActor);
  var _super = _createSuper(Asteroid);
  function Asteroid() {
    var _this;
    _classCallCheck(this, Asteroid);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.width = 80;
    _this.args.height = 80;
    _this.args.type = 'actor-item actor-asteroid';
    _this.args.float = -1;
    _this.args.static = 1;
    _this.args.spawned = false;
    _this.args.firedAt = 0;
    return _this;
  }
  _createClass(Asteroid, [{
    key: "sleep",
    value: function sleep() {
      this.args.spawned = false;
    }
  }, {
    key: "update",
    value: function update() {
      if (!this.viewport) {
        return;
      }
      const viewport = this.viewport;
      if (viewport.controlActor) {
        if (viewport.controlActor.args.respawning) {
          return;
        }
        if (viewport.controlActor.args.y < this.args.y) {
          return;
        }
        if (Math.abs(viewport.controlActor.args.y - this.args.y) < 128) {
          return;
        }
      }
      if (viewport.args.frameId - this.args.firedAt < 90) {
        _get(_getPrototypeOf(Asteroid.prototype), "update", this).call(this);
        return;
      }
      if (this.args.spawned) {
        this.args.spawned = Math.random() >= 0.01;
        _get(_getPrototypeOf(Asteroid.prototype), "update", this).call(this);
        return;
      }
      if (viewport.actorIsOnScreen(this, 128)) {
        viewport.spawn.add({
          object: new _AsteroidLarge.AsteroidLarge({
            xSpeed: this.args.xSpeed,
            ySpeed: this.args.ySpeed,
            x: this.args.x,
            y: this.args.y
          })
        });
        this.args.spawned = true;
        this.args.firedAt = viewport.args.frameId;
      } else {
        this.args.spawned = false;
      }
      _get(_getPrototypeOf(Asteroid.prototype), "update", this).call(this);
    }

    // get solid() { return true };
  }]);
  return Asteroid;
}(_PointActor2.PointActor);
exports.Asteroid = Asteroid;
});

;require.register("actor/AsteroidBase.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AsteroidBase = void 0;
var _PointActor2 = require("./PointActor");
var _Block = require("./Block");
var _Sfx = require("../audio/Sfx");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let AsteroidBase = /*#__PURE__*/function (_PointActor) {
  _inherits(AsteroidBase, _PointActor);
  var _super = _createSuper(AsteroidBase);
  function AsteroidBase() {
    var _this;
    _classCallCheck(this, AsteroidBase);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.width = 80;
    _this.args.height = 80;
    _this.args.type = 'actor-item actor-asteroid';
    _this.args.broken = false;
    _this.args.decel = 0;
    return _this;
  }
  _createClass(AsteroidBase, [{
    key: "sleep",
    value: function sleep() {
      this.viewport && this.viewport.actors.remove(this);
    }
  }, {
    key: "update",
    value: function update() {
      if (!this.viewport || this.args.broken) {
        _get(_getPrototypeOf(AsteroidBase.prototype), "update", this).call(this);
        this.args.groundAngle = 0;
        return;
      }
      const viewport = this.viewport;
      if (!this.args.falling) {
        this.break();
      }
      _get(_getPrototypeOf(AsteroidBase.prototype), "update", this).call(this);
      this.args.groundAngle = 0;
      if (!this.viewport.actorIsOnScreen(this, 128)) {
        this.viewport && this.viewport.actors.remove(this);
      }
    }
  }, {
    key: "rotateLock",
    get: function get() {
      return true;
    }
  }]);
  return AsteroidBase;
}(_PointActor2.PointActor);
exports.AsteroidBase = AsteroidBase;
});

;require.register("actor/AsteroidLarge.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AsteroidLarge = void 0;
var _Tag = require("curvature/base/Tag");
var _PointActor = require("./PointActor");
var _Block = require("./Block");
var _Sfx = require("../audio/Sfx");
var _AsteroidMedium5 = require("./AsteroidMedium");
var _AsteroidBase2 = require("./AsteroidBase");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let AsteroidLarge = /*#__PURE__*/function (_AsteroidBase) {
  _inherits(AsteroidLarge, _AsteroidBase);
  var _super = _createSuper(AsteroidLarge);
  function AsteroidLarge() {
    var _this;
    _classCallCheck(this, AsteroidLarge);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.type = `${_this.args.type} actor-asteroid-large`;
    _this.args.gravity = 0.45;
    _this.args.width = 64;
    _this.args.height = 80;
    return _this;
  }
  _createClass(AsteroidLarge, [{
    key: "update",
    value: function update() {
      _get(_getPrototypeOf(AsteroidLarge.prototype), "update", this).call(this);
      if (!this.viewport || this.viewport.args.frameId % 3) {
        return;
      }
      const dustParticle = new _Tag.Tag(document.createElement('div'));
      dustParticle.classList.add('particle-dust');
      dustParticle.style({
        '--x': this.args.x,
        '--y': this.args.y + -this.args.height - 0.75,
        'z-index': 0,
        opacity: Math.random() * 0.25 + 0.5
      });
      viewport.particles.add(dustParticle);
      viewport.onFrameOut(30, () => {
        viewport.particles.remove(dustParticle);
      });
    }
  }, {
    key: "collideA",
    value: function collideA(other) {
      if (!other.controllable || this.args.broken || other.args.mercy) {
        return;
      }
      if (other.args.y < this.args.y + -this.args.height * 0.75) {
        return;
      }
      this.args.xSpeed = 0;
      other.damage(this, 'rock');
      _Sfx.Sfx.play('ROCK_BREAK_1');
      this.break();
    }
  }, {
    key: "break",
    value: function _break() {
      const xSpeed = this.xSpeedLast || this.gSpeedLast || 0;
      const ySpeed = this.ySpeedLast || 0;
      const pieces = [new _AsteroidMedium5.AsteroidMedium(_defineProperty({
        falling: true,
        x: this.args.x - 20,
        y: this.args.y - 20,
        xSpeed: xSpeed,
        ySpeed: -ySpeed * 0.25 + -1.5
      }, "xSpeed", xSpeed * 0.333 - 0.5)), new _AsteroidMedium5.AsteroidMedium(_defineProperty({
        falling: true,
        x: this.args.x + 20,
        y: this.args.y - 20,
        xSpeed: xSpeed,
        ySpeed: -ySpeed * 0.25 + -1.5
      }, "xSpeed", xSpeed * 0.333 + 0.5)), new _AsteroidMedium5.AsteroidMedium(_defineProperty({
        falling: true,
        x: this.args.x + 0,
        y: this.args.y - 4,
        xSpeed: xSpeed,
        ySpeed: -ySpeed * 0.25 + -1.0
      }, "xSpeed", xSpeed * 0.333 + 0.0)), new _AsteroidMedium5.AsteroidMedium(_defineProperty({
        falling: true,
        x: this.args.x + 0,
        y: this.args.y - 40,
        xSpeed: xSpeed,
        ySpeed: -ySpeed * 0.25 + -2.0
      }, "xSpeed", xSpeed * 0.333 + 0.0))];
      pieces.forEach(object => viewport.spawn.add({
        object: object
      }));
      viewport.onFrameOut(1, () => viewport.actors.remove(this));
      this.args.broken = true;
      _Sfx.Sfx.play('ROCK_BREAK_1');
    }
  }]);
  return AsteroidLarge;
}(_AsteroidBase2.AsteroidBase);
exports.AsteroidLarge = AsteroidLarge;
});

;require.register("actor/AsteroidMedium.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AsteroidMedium = void 0;
var _PointActor = require("./PointActor");
var _Block = require("./Block");
var _Sfx = require("../audio/Sfx");
var _AsteroidSmall = require("./AsteroidSmall");
var _AsteroidBase2 = require("./AsteroidBase");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let AsteroidMedium = /*#__PURE__*/function (_AsteroidBase) {
  _inherits(AsteroidMedium, _AsteroidBase);
  var _super = _createSuper(AsteroidMedium);
  function AsteroidMedium() {
    var _this;
    _classCallCheck(this, AsteroidMedium);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.type = `${_this.args.type} actor-asteroid-medium`;
    _this.args.gravity = 0.50;
    _this.args.width = 48;
    _this.args.height = 48;
    return _this;
  }
  _createClass(AsteroidMedium, [{
    key: "collideA",
    value: function collideA(other) {
      if (!other.controllable || this.args.broken || other.args.mercy) {
        return;
      }
      if (other.args.y < this.args.y + -this.args.height * 0.75) {
        return;
      }

      // this.args.xSpeed = 0;

      other.damage(this, 'rock');
      _Sfx.Sfx.play('ROCK_BREAK_2');
    }
  }, {
    key: "break",
    value: function _break() {
      const xSpeed = this.xSpeedLast || this.gSpeedLast || 0;
      const ySpeed = this.ySpeedLast || 0;
      const pieces = [new _AsteroidSmall.AsteroidSmall({
        falling: true,
        x: this.args.x + 0,
        y: this.args.y - 24,
        ySpeed: ySpeed * -0.5 - 1,
        xSpeed: xSpeed + 0.00
      }), new _AsteroidSmall.AsteroidSmall({
        falling: true,
        x: this.args.x + 0,
        y: this.args.y + 0,
        ySpeed: ySpeed * -0.5 - 1,
        xSpeed: xSpeed + 0.00
      }), new _AsteroidSmall.AsteroidSmall({
        falling: true,
        x: this.args.x - 14,
        y: this.args.y - 12,
        ySpeed: ySpeed * -0.5 - 1,
        xSpeed: xSpeed - 0.15
      }), new _AsteroidSmall.AsteroidSmall({
        falling: true,
        x: this.args.x + 14,
        y: this.args.y - 12,
        ySpeed: ySpeed * -0.5 - 1,
        xSpeed: xSpeed + 0.15
      })];
      pieces.forEach(object => viewport.spawn.add({
        object: object
      }));
      viewport.onFrameOut(1, () => viewport.actors.remove(this));
      this.args.broken = true;
      _Sfx.Sfx.play('ROCK_BREAK_2');
    }
  }]);
  return AsteroidMedium;
}(_AsteroidBase2.AsteroidBase);
exports.AsteroidMedium = AsteroidMedium;
});

;require.register("actor/AsteroidSmall.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AsteroidSmall = void 0;
var _PointActor2 = require("./PointActor");
var _Block = require("./Block");
var _Sfx = require("../audio/Sfx");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let AsteroidSmall = /*#__PURE__*/function (_PointActor) {
  _inherits(AsteroidSmall, _PointActor);
  var _super = _createSuper(AsteroidSmall);
  function AsteroidSmall() {
    var _this;
    _classCallCheck(this, AsteroidSmall);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.width = 32;
    _this.args.height = 32;
    // this.args.gravity = 0.85;
    _this.args.type = 'actor-item actor-asteroid-small';
    _this.noClip = true;
    // this.args.float = -1;
    return _this;
  }
  _createClass(AsteroidSmall, [{
    key: "sleep",
    value: function sleep() {
      this.viewport && this.viewport.actors.remove(this);
    }
  }, {
    key: "collideA",
    value: function collideA(other) {
      if (!other.controllable || other.args.mercy) {
        return;
      }
      this.args.xSpeed = 0;
      other.damage(this, 'rock');
      _Sfx.Sfx.play('ROCK_BREAK_2');
    }
  }, {
    key: "damage",
    value: function damage() {}
  }, {
    key: "rotateLock",
    get: function get() {
      return true;
    }
  }]);
  return AsteroidSmall;
}(_PointActor2.PointActor);
exports.AsteroidSmall = AsteroidSmall;
});

;require.register("actor/BFish.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BFish = void 0;
var _Flickie = require("./Flickie");
var _Mixin = require("curvature/base/Mixin");
var _Tag = require("curvature/base/Tag");
var _PointActor = require("./PointActor");
var _SkidDust = require("../behavior/SkidDust");
var _Patrol = require("../behavior/Patrol");
var _CanPop = require("../mixin/CanPop");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let BFish = /*#__PURE__*/function (_Mixin$from) {
  _inherits(BFish, _Mixin$from);
  var _super = _createSuper(BFish);
  function BFish() {
    var _this;
    let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let parent = arguments.length > 1 ? arguments[1] : undefined;
    _classCallCheck(this, BFish);
    const jumpForce = args.jumpForce || 14;
    _this = _super.call(this, args, parent);
    _this.behaviors.add(new _SkidDust.SkidDust());
    _this.behaviors.add(new _Patrol.Patrol());
    _this.args.type = 'actor-item actor-b-fish';
    _this.args.animation = 'standing';

    // this.args.accel     = 0.1;
    // this.args.decel     = 0.5;

    _this.noClip = true;
    _this.args.gSpeedMax = 5;
    _this.args.jumpForce = jumpForce || 14;
    _this.args.jumpDelay = _this.args.jumpDelay || 0;
    _this.args.gravity = 0.5;
    _this.args.width = 24;
    _this.args.height = 32;
    _this.willStick = false;
    _this.stayStuck = false;
    return _this;
  }
  _createClass(BFish, [{
    key: "update",
    value: function update() {
      const yStart = this.def.get('y');
      if (this.age <= this.args.jumpDelay) {
        this.args.float = -1;
      } else {
        this.args.float = false;
      }
      if (this.age > this.args.jumpDelay && this.args.y > yStart) {
        this.viewport.onNextFrame(() => this.args.ySpeed = -this.args.jumpForce);
      }
      _get(_getPrototypeOf(BFish.prototype), "update", this).call(this);
    }
  }, {
    key: "solid",
    get: function get() {
      return false;
    }
  }, {
    key: "isEffect",
    get: function get() {
      return false;
    }
    // get controllable() { return true; }
  }]);
  return BFish;
}(_Mixin.Mixin.from(_PointActor.PointActor, _CanPop.CanPop));
exports.BFish = BFish;
});

;require.register("actor/BackdropController.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BackdropController = void 0;
var _PointActor2 = require("./PointActor");
var _BackdropPalette = require("../BackdropPalette");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let BackdropController = /*#__PURE__*/function (_PointActor) {
  _inherits(BackdropController, _PointActor);
  var _super = _createSuper(BackdropController);
  function BackdropController(args, parent) {
    var _this;
    _classCallCheck(this, BackdropController);
    _this = _super.call(this, args, parent);
    _this.args.hidden = true;
    return _this;
  }
  _createClass(BackdropController, [{
    key: "activate",
    value: function activate(other, button) {
      // this.viewport.tilemap.replacements.set(
      // 	this.args.original//'../Sonic/tiles/azure-lake/azure-lake.png'
      // 	, this.args.replacement//'../Sonic/tiles/azure-lake/azure-lake-burnt.png'
      // );
    }
  }]);
  return BackdropController;
}(_PointActor2.PointActor);
exports.BackdropController = BackdropController;
});

;require.register("actor/BackdropSwapper.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BackdropSwapper = void 0;
var _PointActor2 = require("./PointActor");
var _BackdropPalette = require("../BackdropPalette");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let BackdropSwapper = /*#__PURE__*/function (_PointActor) {
  _inherits(BackdropSwapper, _PointActor);
  var _super = _createSuper(BackdropSwapper);
  function BackdropSwapper(args, parent) {
    var _this;
    _classCallCheck(this, BackdropSwapper);
    _this = _super.call(this, args, parent);
    _this.args.hidden = true;
    return _this;
  }
  _createClass(BackdropSwapper, [{
    key: "activate",
    value: function activate(other, button) {
      // this.viewport.tilemap.replacements.set(
      // 	this.args.original//'../Sonic/tiles/azure-lake/azure-lake.png'
      // 	, this.args.replacement//'../Sonic/tiles/azure-lake/azure-lake-burnt.png'
      // );
    }
  }]);
  return BackdropSwapper;
}(_PointActor2.PointActor);
exports.BackdropSwapper = BackdropSwapper;
});

;require.register("actor/Balkiry.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Balkiry = void 0;
var _Flickie = require("./Flickie");
var _Spring = require("./Spring");
var _Mixin = require("curvature/base/Mixin");
var _Tag = require("curvature/base/Tag");
var _PointActor = require("./PointActor");
var _SkidDust = require("../behavior/SkidDust");
var _CanPop = require("../mixin/CanPop");
var _Explosion = require("../actor/Explosion");
var _Projectile = require("../actor/Projectile");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let Balkiry = /*#__PURE__*/function (_Mixin$from) {
  _inherits(Balkiry, _Mixin$from);
  var _super = _createSuper(Balkiry);
  function Balkiry() {
    var _this;
    _classCallCheck(this, Balkiry);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.type = 'actor-item actor-balkiry';
    _this[_Spring.Spring.WontSpring] = true;
    _this.args.animation = 'standing';
    _this.args.accel = 0.1;
    _this.args.decel = 0.5;
    _this.args.gSpeedMax = 5;
    _this.args.jumpForce = 5;
    _this.args.gravity = 0.5;
    _this.args.width = 32;
    _this.args.height = 16;
    _this.willStick = false;
    _this.stayStuck = false;
    _this.args.float = -1;
    _this.noClip = true;
    return _this;
  }
  _createClass(Balkiry, [{
    key: "onRendered",
    value: function onRendered() {
      _get(_getPrototypeOf(Balkiry.prototype), "onRendered", this).call(this);
      this.flame = new _Tag.Tag('<div class = "balkiry-flame">');
      this.sprite.appendChild(this.flame.node);
      this.box.setAttribute('data-animation', 'standing');
    }
  }, {
    key: "update",
    value: function update() {
      // this.args.facing  = 'right';
      this.args.facing = 'left';
      if (this.args.xSpeed > -12) {
        this.args.xSpeed -= 0.1;
      }
      this.args.ySpeed = 0;
      this.args.falling = true;
      this.args.flying = true;
      _get(_getPrototypeOf(Balkiry.prototype), "update", this).call(this);
    }
  }, {
    key: "effect",
    value: function effect(other) {
      _get(_getPrototypeOf(Balkiry.prototype), "effect", this).call(this, other);

      // this.viewport.spawn.add({object:new Flickie({
      // 	x: this.args.x,
      // 	y: this.args.y,
      // })});
    }
  }, {
    key: "wakeUp",
    value: function wakeUp() {}
  }, {
    key: "sleep",
    value: function sleep() {
      // this.args.x = this.def.get('x');
      // this.args.y = this.def.get('y');
    }
  }, {
    key: "solid",
    get: function get() {
      return false;
    }
    // get controllable() { return true; }
  }, {
    key: "isEffect",
    get: function get() {
      return false;
    }
  }]);
  return Balkiry;
}(_Mixin.Mixin.from(_PointActor.PointActor, _CanPop.CanPop));
exports.Balkiry = Balkiry;
});

;require.register("actor/Balloon.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Balloon = void 0;
var _PointActor2 = require("./PointActor");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let Balloon = /*#__PURE__*/function (_PointActor) {
  _inherits(Balloon, _PointActor);
  var _super = _createSuper(Balloon);
  function Balloon() {
    var _this;
    _classCallCheck(this, Balloon);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.type = 'actor-item actor-balloon';
    _this.args.width = 32;
    _this.args.height = 33;
    _this.args.float = -1;
    _this.args.airAngle = -Math.PI;
    return _this;
  }
  _createClass(Balloon, [{
    key: "collideA",
    value: function collideA(other) {
      if (!other.controllable) {
        return;
      }
    }
  }]);
  return Balloon;
}(_PointActor2.PointActor);
exports.Balloon = Balloon;
});

;require.register("actor/Barnacle.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Barnacle = void 0;
var _Mixin = require("curvature/base/Mixin");
var _PointActor = require("./PointActor");
var _Patrol = require("../behavior/Patrol");
var _CanPop = require("../mixin/CanPop");
var _BarnacleTrap = require("./BarnacleTrap");
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let Barnacle = /*#__PURE__*/function (_Mixin$from) {
  _inherits(Barnacle, _Mixin$from);
  var _super = _createSuper(Barnacle);
  function Barnacle() {
    var _this$args$patrolPaus, _this$args$patrolBeat, _this$args$patrolSpee, _this$args$showOff;
    var _this;
    _classCallCheck(this, Barnacle);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);

    // this.behaviors.add(new Patrol);

    _this.args.type = 'actor-item actor-barnacle';
    _this.args.animation = 'standing';
    _this.args.accel = 0.1;
    _this.args.decel = 0.5;
    _this.args.gSpeedMax = 5;
    _this.args.gravity = 0.75;
    _this.args.width = 34;
    _this.args.height = 32;
    _this.args.float = -1;
    _this.willStick = false;
    _this.stayStuck = false;
    _this.args.patrolPause = (_this$args$patrolPaus = _this.args.patrolPause) !== null && _this$args$patrolPaus !== void 0 ? _this$args$patrolPaus : 10;
    _this.args.patrolBeat = (_this$args$patrolBeat = _this.args.patrolBeat) !== null && _this$args$patrolBeat !== void 0 ? _this$args$patrolBeat : 200;
    _this.args.patrolSpeed = (_this$args$patrolSpee = _this.args.patrolSpeed) !== null && _this$args$patrolSpee !== void 0 ? _this$args$patrolSpee : 1;
    _this.args.showOff = (_this$args$showOff = _this.args.showOff) !== null && _this$args$showOff !== void 0 ? _this$args$showOff : false;
    _this.args.state = 'waiting';
    if (_this.args.showOff) {
      _this.args.state = 'intro';
    }
    _this.args.bindTo('state', () => _this.args.stateAge = 0);
    return _this;
  }
  _createClass(Barnacle, [{
    key: "update",
    value: function update() {
      _get(_getPrototypeOf(Barnacle.prototype), "update", this).call(this);
      if (!this.trap) {
        this.mountPoint = new _PointActor.PointActor();
        this.trap = new _BarnacleTrap.BarnacleTrap();
        this.trap.owner = this;
        this.mountPoint.args.x = this.trap.args.x = this.args.x;
        this.mountPoint.args.y = this.trap.args.y = this.args.y;
        this.mountPoint.args.y -= 24;
        this.mountPoint.noClip = true;
        this.mountPoint.args.float = -1;
        this.mountPoint.args.hidden = true;
        this.trap.others.tiedTo = this.mountPoint;
        if (!this.args.showOff) {
          this.trap.args.y += this.findRopeLength();
          this.trap.args.ropeLength = this.findRopeLength();
          this.trap.args.xSpeed += 2 * Math.sign(Math.random() + -0.5);
        }

        // this.trap.render();
        // this.trap.initialize();

        this.viewport.spawn.add({
          object: this.trap
        });
        // this.viewport.spawn.add({object:this.mountPoint});
      }

      if (this.trap.stuck.size && this.trap.args.ySpeed <= 0) {
        this.trap.args.xSpeed *= 0.85;
      }
      const state = this.args.state;
      if (_typeof(this['state_' + state])) {
        this['state_' + state]();
      }
    }
  }, {
    key: "pop",
    value: function pop(other) {
      this.viewport.actors.remove(this.trap);
      this.viewport.actors.remove(this.mountPoint);
      _get(_getPrototypeOf(Barnacle.prototype), "pop", this).call(this, other);
    }
  }, {
    key: "updateEnd",
    value: function updateEnd() {
      _get(_getPrototypeOf(Barnacle.prototype), "updateEnd", this).call(this);
      this.args.stateAge++;
    }
  }, {
    key: "state_intro",
    value: function state_intro() {
      this.trap.args.ropeLength = 2;
      if (this.args.stateAge > 45) {
        this.args.state = 'spitting';
      }
    }
  }, {
    key: "state_waiting",
    value: function state_waiting() {
      this.args.animation = 'idle';
      if (this.args.stateAge > 40 && this.trap.stuck.size) {
        this.args.state = 'feeding';
      }
      if (this.trap.args.ropeLength <= 0) {
        this.args.state = 'spitting';
      }
    }
  }, {
    key: "state_carriage",
    value: function state_carriage() {
      this.args.animation = 'idle';
      if (typeof this.trap.args.ropeLength === 'undefined') {
        this.trap.args.ropeLength = 0;
      }
      if (this.args.stateAge > 40) {
        this.args.state = 'feeding';
      }
    }
  }, {
    key: "state_feeding",
    value: function state_feeding() {
      this.args.animation = 'feeding';
      if (this.args.stateAge > 15) {
        if (this.trap.args.ropeLength > 48) {
          this.trap.args.ropeLength -= 5;
        } else {
          this.trap.args.ropeLength -= 3;
        }
        this.trap.args.falling = true;
      }
      if (this.args.stateAge > 25) {
        this.args.state = 'carriage';
      }
      if (this.trap.args.ropeLength <= 0) {
        this.trap.args.ropeLength = 0;
        this.trap.args.float = -1;
        this.args.state = 'spitting';
        this.trap.args.xSpeed = 0;
        this.trap.args.ySpeed = 0;
        for (const _ref of this.trap.stuck) {
          var _ref2 = _slicedToArray(_ref, 1);
          const other = _ref2[0];
          if (typeof other.pop === 'function') {
            this.viewport.onFrameOut(10, () => {
              this.trap.stuck.delete(other);
              this.trap.ignores.set(other, 60);
              other.pop();
            });
          }
        }
      }
    }
  }, {
    key: "state_spitting",
    value: function state_spitting() {
      if (this.args.stateAge === 60) {
        this.trap.args.xSpeed += 2 * Math.sign(Math.random() + -0.5);
        // this.trap.args.xSpeed = 3;
      }

      if (this.args.stateAge > 40) {
        const length = this.findRopeLength();
        this.trap.args.ropeLength = length + -16;
        this.args.animation = 'spit';
        this.trap.args.float = 0;
        this.trap.args.ySpeed = Math.max(2, this.trap.args.ySpeed);
      } else {
        // this.trap.args.xSpeed = 0;
        // this.trap.args.ySpeed = 0;
      }
      if (this.args.stateAge > 70) {
        this.args.state = 'waiting';
      }
    }
  }, {
    key: "findRopeLength",
    value: function findRopeLength() {
      const endPoint = this.viewport.tileMap.castRay(this.args.x, this.args.y, Math.PI / 2, 2048);
      return Math.hypot(this.args.x - endPoint[0], this.args.y - endPoint[1]) || 128;
    }
  }, {
    key: "solid",
    get: function get() {
      return false;
    }
  }, {
    key: "isEffect",
    get: function get() {
      return false;
    }
  }]);
  return Barnacle;
}(_Mixin.Mixin.from(_PointActor.PointActor, _CanPop.CanPop));
exports.Barnacle = Barnacle;
});

;require.register("actor/BarnacleTrap.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BarnacleTrap = void 0;
var _PointActor = require("./PointActor");
var _Mixin = require("curvature/base/Mixin");
var _Constrainable = require("../mixin/Constrainable");
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let BarnacleTrap = /*#__PURE__*/function (_Mixin$from) {
  _inherits(BarnacleTrap, _Mixin$from);
  var _super = _createSuper(BarnacleTrap);
  function BarnacleTrap() {
    var _this;
    _classCallCheck(this, BarnacleTrap);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.type = 'actor-item actor-barnacle-trap';
    _this.args.width = 8;
    _this.args.height = 8;
    _this.args.ropeLength = 0;
    // this.args.float  = -1;

    // this.args.airAngle = -Math.PI;

    _this.stuck = new Map();
    _this.noClip = true;
    _this.onRemove(() => {
      for (const _ref of _this.stuck) {
        var _ref2 = _slicedToArray(_ref, 2);
        const other = _ref2[0];
        const entry = _ref2[1];
        other.args.float = 0;
        other.args.stuck = false;
      }
    });
    return _this;
  }
  _createClass(BarnacleTrap, [{
    key: "update",
    value: function update() {
      if (!this.others.tiedTo) {
        _get(_getPrototypeOf(BarnacleTrap.prototype), "update", this).call(this);
      }
    }
  }, {
    key: "updateEnd",
    value: function updateEnd() {
      _get(_getPrototypeOf(BarnacleTrap.prototype), "update", this).call(this);
      if (!this.viewport) {
        return;
      }
      for (const _ref3 of this.stuck) {
        var _ref4 = _slicedToArray(_ref3, 2);
        const other = _ref4[0];
        const entry = _ref4[1];
        if (this.viewport.args.frameId % 25 === 0) {
          entry.wiggles = Math.min(8, 1 + entry.wiggles);
        }
      }
      const tiedTo = this.others.tiedTo;
      if (tiedTo) {
        this.setPos();
      }
      for (const _ref5 of this.stuck) {
        var _ref6 = _slicedToArray(_ref5, 2);
        const other = _ref6[0];
        const entry = _ref6[1];
        other.args.xSpeed = other.xAxis;
        other.args.ySpeed = 0;
        if (other.args.mercy || other.args.dead || entry.wiggles <= 0) {
          this.stuck.delete(other);
          this.ignores.set(other, 15);
          other.args.stuck = false;
          if (!other.args.dead) {
            other.args.float = 0;
          }
        } else {
          this.args.xSpeed += other.xAxis * 0.1;
          if (Math.abs(this.args.xSpeed) > 3) {
            this.args.xSpeed = 3 * Math.sign(this.args.xSpeed);
          }
          other.args.x = this.args.x;
          other.args.y = this.args.y + other.args.height + -this.args.height;
          other.args.float = -1;
          other.args.falling = true;
          other.dashed = false;
          other.args.stuck = true;
          other.args.jumping = false;
          other.args.spinning = false;
          other.args.cameraBias = 0.2;
          if (other.controllable) {
            other.args.animation = 'walking';
          }
        }
        if (other.xAxis) {
          if (Math.sign(entry.xAxisLast) !== Math.sign(other.xAxis)) {
            entry.wiggles--;
          }
          entry.xAxisLast = other.xAxis;
        }
      }
      if (Math.abs(this.args.xSpeed) < 2 && this.args.ySpeed > 0 && this.args.ySpeed < 2 && this.args.rope > 32) {
        this.args.xSpeed = 2 * Math.sign(this.args.xSpeed);
      }
      _get(_getPrototypeOf(BarnacleTrap.prototype), "updateEnd", this).call(this);
    }
  }, {
    key: "collideA",
    value: function collideA(other) {
      if (other === this.owner) {
        return;
      }
      if (!other.controllable && typeof other.pop !== 'function') {
        return;
      }
      if (other.args.mercy || other.args.dead || this.stuck.size) {
        return;
      }
      if (!this.stuck.has(other)) {
        this.stuck.set(other, {
          xAxisLast: 0,
          wiggles: 8,
          yDiff: other.args.y - this.args.y
        });
        this.args.falling = true;
        this.args.xSpeed = other.args.xSpeed || other.args.gSpeed;
        this.args.x = other.args.x;
      }
    }
  }, {
    key: "solid",
    get: function get() {
      return false;
    }
  }]);
  return BarnacleTrap;
}(_Mixin.Mixin.from(_PointActor.PointActor, _Constrainable.Constrainable));
exports.BarnacleTrap = BarnacleTrap;
});

;require.register("actor/Beelzebub.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Beelzebub = void 0;
var _Tag = require("curvature/base/Tag");
var _PointActor = require("./PointActor");
var _Platformer = require("../behavior/Platformer");
var _Mixin = require("curvature/base/Mixin");
var _CanPop = require("../mixin/CanPop");
var _CutScene = require("./CutScene");
var _EggCapsule = require("./EggCapsule");
var _Sfx = require("../audio/Sfx");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let Beelzebub = /*#__PURE__*/function (_Mixin$from) {
  _inherits(Beelzebub, _Mixin$from);
  var _super = _createSuper(Beelzebub);
  function Beelzebub(args, parent) {
    var _this;
    _classCallCheck(this, Beelzebub);
    _this = _super.call(this, args, parent);
    _this.args.type = 'actor-item actor-beelzebub';
    _this.args.width = 64;
    _this.args.height = 32;
    _this.args.float = -1;
    _this.args.damagers = new Map();
    _this.args.phase = 'idle';
    _this.args.hitPoints = 8;
    _this.args.noseAngle = Math.PI / 2 * 3;
    _this.args.drillPush = 0;
    _this.args.phaseFrameId = 0;
    _this.args.frameId = 0;
    _this.args.direction = -1;
    _this.args.facing = 'left';
    _this.args.bindTo('phase', v => _this.args.phaseFrameId = 0);

    // this.clearScene = new CutScene({src: '/cutscenes/clear-seaview.json'});
    return _this;
  }
  _createClass(Beelzebub, [{
    key: "onRendered",
    value: function onRendered(event) {
      _get(_getPrototypeOf(Beelzebub.prototype), "onRendered", this).call(this, event);
      this.autoStyle.get(this.box)['--nose-angle'] = 'noseAngle';
      this.autoStyle.get(this.box)['--drill-push'] = 'drillPush';
      this.autoAttr.get(this.box)['data-phase'] = 'phase';
      this.drill = new _Tag.Tag(`<div class = "drill">`);
      this.body = new _Tag.Tag(`<div class = "body">`);
      this.nose = new _Tag.Tag(`<div class = "nose">`);
      this.eyeBack = new _Tag.Tag(`<div class = "eye-back">`);
      this.eyeFore = new _Tag.Tag(`<div class = "eye-fore">`);
      this.body.appendChild(this.eyeBack.node);
      this.body.appendChild(this.eyeFore.node);
      this.body.appendChild(this.nose.node);
      this.sprite.appendChild(this.body.node);
      this.nose.appendChild(this.drill.node);
      this.attractor = null;

      // this.clearScene.viewport = this.viewport;
    }
  }, {
    key: "update",
    value: function update() {
      this.args.phaseFrameId++;
      this.args.frameId++;
      if (!this.viewport) {
        return;
      }
      const viewport = this.viewport;
      viewport.auras.add(this);
      const mainChar = this.viewport.controlActor;
      if (!mainChar || mainChar.args.respawning) {
        return;
      }
      if (!this.attractor) {
        this.attractor = {};
        this.attractor.x = this.x;
        this.attractor.y = this.y;
      }
      const xDiff = Math.abs(this.x - this.attractor.x);
      const yDiff = Math.abs(this.y - this.attractor.y);
      const xSign = Math.sign(this.x - this.attractor.x);
      const ySign = Math.sign(this.y - this.attractor.y);
      switch (this.args.phase) {
        case 'idle':
          this.args.xSpeed = 0;
          this.args.ySpeed = 0;
          break;
        case 'intro':
          if (this.args.phaseFrameId > 30) {
            this.args.phase = 'stalking';
          }
          break;
        case 'alert':
          if (this.args.phaseFrameId > 4) {
            this.args.drillPush = 1;
            this.args.falling = true;
            this.args.float = -1;
            if (this.y > this.args.alertTo) {
              this.args.ySpeed--;
            } else {
              this.args.y = this.args.alertTo;
              this.args.ySpeed = 0;
            }
          }
          if (this.args.phaseFrameId > 0) {
            this.args.phase = 'stalking';
          }
          break;
        case 'damaged':
          if (this.args.hitPoints > 0) {
            if (this.args.phaseFrameId > 20) {
              this.args.phase = 'stalking';
            }
          } else {
            if (this.args.phaseFrameId > 6) {
              this.args.phase = 'dead';
            }
          }
          break;
        case 'knocked':
          this.args.xSpeed = 0;
          if (this.args.phaseFrameId > 30) {
            this.args.phase = 'stalking';
          }
          break;
        case 'dead':
          this.args.float = 0;
          break;
        case 'stalking':
          {
            this.args.xSpeed = -xSign * Math.max(1, xDiff / 25);
            this.args.ySpeed = -ySign * Math.max(1, yDiff / 25);
            this.args.ySpeed += Math.sin(this.args.frameId / 3) * 3;
            if (this.pointIsSafe(mainChar.x, mainChar.y - 128)) {
              this.attractor.x = mainChar.x;
              this.attractor.y = mainChar.y - 128;
            }
            this.args.noseAngle = Math.PI / 2 * 3;
            this.args.drillPush = 0;
            if (this.args.phaseFrameId > 10) {
              this.args.noseAngle = this.angleTo({
                x: mainChar.x,
                y: Math.max(this.y, mainChar.y)
              });
            }
            if (this.args.phaseFrameId > 20) {
              this.args.drillPush = 0.5;
            }
            if (this.args.phaseFrameId > 25) {
              this.args.phase = 'ready';
            }
            break;
          }
        case 'buzzing':
          {
            if (this.pointIsSafe(mainChar.x, mainChar.y + -mainChar.args.height + -34)) {
              this.attractor.x = mainChar.x;
              this.attractor.y = mainChar.y + -mainChar.args.height + -34;
            }
            this.args.xSpeed = -xSign * Math.max(1, xDiff / 15);
            this.args.ySpeed = -ySign * Math.max(1, yDiff / 15);
            this.args.noseAngle = Math.PI / 2 * 3;
            this.args.drillPush = 1;
            if (this.args.phaseFrameId > 10) {
              this.args.drillPush = 0.5;
            }
            if (this.args.phaseFrameId > 20) {
              this.args.noseAngle = this.angleTo({
                x: mainChar.x,
                y: Math.max(this.y, mainChar.y)
              });
            }
            if (this.args.phaseFrameId > 30) {
              this.args.phase = 'ready';
            }
            break;
          }
        case 'ready':
          {
            if (this.args.phaseFrameId < 10) {
              this.readySide = Math.sign(mainChar.xSpeedLast || mainChar.gSpeedLast);
            }
            if (this.pointIsSafe(mainChar.x + 128 * this.readySide, mainChar.y + -mainChar.args.height + -128)) {
              this.attractor.x = mainChar.x + 128 * this.readySide;
              this.attractor.y = mainChar.y + -mainChar.args.height + -128;
            }
            this.args.xSpeed = -xSign * Math.max(1, xDiff / 15);
            this.args.ySpeed = -ySign * Math.max(1, yDiff / 15);
            this.args.ySpeed += Math.sin(this.args.frameId / 3) * 3;
            this.args.drillPush = 0.75;
            if (this.args.phaseFrameId > 30) {
              const dieRoll = Math.random();
              if (!mainChar.args.falling) {
                if (dieRoll > 0.5) {
                  this.args.phase = 'swooping';
                } else {
                  this.args.phase = 'attacking';
                }
              } else {
                if (dieRoll > 0.5) {
                  this.args.phase = 'buzzing';
                } else {
                  this.args.phase = 'stalking';
                }
              }
            }
            break;
          }
        case 'attacking':
          {
            this.args.float = -1;
            this.args.falling = true;
            if (this.args.phaseFrameId > 100) {
              this.args.phase = 'stalking';
            }
            if (this.args.phaseFrameId < 50) {
              if (this.pointIsSafe(mainChar.x + 256 * (this.readySide || 1), mainChar.y - 32)) {
                this.attractor.x = mainChar.x + 256 * (this.readySide || 1);
                this.attractor.y = mainChar.y - 32;
              }
              this.args.noseAngle = 0;
            } else {
              if (this.pointIsSafe(mainChar.x + 256 * (-this.readySide || -1), mainChar.y - 16)) {
                this.attractor.x = mainChar.x + 256 * (-this.readySide || -1);
                this.attractor.y = mainChar.y - 16;
              }
              this.args.noseAngle = this.angleTo({
                x: mainChar.x,
                y: Math.max(this.y, mainChar.y)
              });
            }
            this.args.drillPush = 1;
            this.args.float = -1;
            const mainSpeed = mainChar.args.xSpeed || mainChar.args.gSpeed;
            this.args.xSpeed = -xSign * Math.max(1, xDiff / 10) + mainSpeed * 1.1;
            this.args.ySpeed = -ySign * Math.max(1, yDiff / 10);
            break;
          }
        case 'swooping':
          {
            if (this.pointIsSafe(mainChar.x, mainChar.y - 32)) {
              this.attractor.x = mainChar.x;
              this.attractor.y = mainChar.y - 32;
            }
            this.args.xSpeed += -xSign * Math.max(1, xDiff / 10000);
            this.args.ySpeed += -ySign * Math.max(1, yDiff / 10000);
            this.args.noseAngle = this.angleTo({
              x: mainChar.x,
              y: Math.max(this.y, mainChar.y)
            });
            this.args.drillPush = 1;
            this.args.float = -1;
            if (this.args.phaseFrameId > 180) {
              this.args.phase = 'stalking';
            }
            const mainSpeed = mainChar.args.xSpeed || mainChar.args.gSpeed;
            break;
          }
        case 'exploding':
          if (this.args.phaseFrameId === 90) {
            this.args.falling = true;
            this.args.ySpeed = -14;
            this.args.xSpeed = 0;
            this.args.gSpeed = 0;
            this.noClip = true;
            this.viewport.auras.delete(this);
            this.args.phase = 'exploded';

            // this.clearScene.activate(mainChar, this, true);

            _Sfx.Sfx.play('OBJECT_DESTROYED');
            if (viewport && viewport.controlActor) {
              const other = viewport.controlActor;
              viewport.onFrameOut(60, () => {
                const capsule = new _EggCapsule.EggCapsule({
                  x: other.args.x,
                  y: other.args.y - 384,
                  xSpeed: other.args.gSpeed || other.args.xSpeed
                });
                viewport.spawn.add({
                  object: capsule
                });
              });
            }
          }
          if (this.args.phaseFrameId > 90) {
            return;
          }
          if (viewport && viewport.args.frameId % 3 === 0) {
            const explosion = new _Tag.Tag('<div class = "particle-explosion">');
            _Sfx.Sfx.play('BOSS_DAMAGED');
            const xOff = this.args.width * Math.random() - this.args.width / 2;
            const yOff = this.args.height * Math.random() - this.args.height / 2;
            explosion.style({
              '--x': this.x + xOff,
              '--y': this.y + yOff + -16
            });
            viewport.particles.add(explosion);
            setTimeout(() => viewport.particles.remove(explosion), 512);
          }
          break;
      }
      if (this.args.phase !== 'knocked') {
        if (this.args.ySpeed < 0 && !this.pointIsSafe(this.x, this.y + -this.args.height + this.args.ySpeed + -1)) {
          this.args.ySpeed = 0;
        }
      }
      _get(_getPrototypeOf(Beelzebub.prototype), "update", this).call(this);
    }
  }, {
    key: "updateEnd",
    value: function updateEnd() {
      _get(_getPrototypeOf(Beelzebub.prototype), "updateEnd", this).call(this);
      if (!this.viewport) {
        return;
      }
      const mainChar = this.viewport.controlActor;
      if (!mainChar) {
        return;
      }
      if (this.args.hitPoints <= 0) {
        mainChar.cofocused = null;
      }
      const xDiff = Math.abs(this.args.x - mainChar.x);
      const yDiff = Math.abs(this.args.y - mainChar.y);
      const xSign = Math.sign(this.args.x - mainChar.x);
      const ySign = Math.sign(this.args.y - mainChar.y);
      switch (this.args.phase) {
        case 'attacking':
        case 'swooping':
        case 'stalking':
        case 'knocked':
        case 'damaged':
        case 'ready':
          {
            if (xDiff > 384) {
              this.args.x = mainChar.x + 384 * xSign;
            }
            if (yDiff > 192) {
              this.args.y = mainChar.y + 192 * ySign;
            }
            if (this.args.hitPoints <= 0) {
              this.viewport.auras.delete(this);
              this.args.phase = 'dead';
              this.noClip = false;
              this.args.float = 0;
              if (typeof ga === 'function') {
                ga('send', 'event', {
                  eventCategory: 'boss',
                  eventAction: 'defeated',
                  eventLabel: `${this.viewport.args.actName}::${this.args.id}`
                });
              }
            }
            break;
          }
      }
      if (this.args.xSpeed < 0) {
        this.args.facing = 'left';
      } else if (this.args.xSpeed > 0) {
        this.args.facing = 'right';
      }
      this.args.groundAngle = 0;
      switch (this.args.phase) {
        case 'attacking':
        case 'swooping':
        case 'stalking':
        case 'ready':
          {
            if (this.bMap('checkBelow', this.x, this.y).get(_Platformer.Platformer)) {
              this.args.falling = true;
              this.args.ySpeed = -4;
              this.args.y--;
            }
          }
          break;
      }
    }
  }, {
    key: "collideA",
    value: function collideA(other, type) {
      if (this.args.phase === 'exploded' || other.args.mercy) {
        return false;
      }
      if (!other.controllable && !other.hazard) {
        return true;
      }
      if (type === -1) {
        return;
      }
      const xSign = Math.sign(this.x - other.x);
      const ySign = Math.sign(this.y - other.y);
      const impactSpeed = Math.max(Math.abs(other.args.xSpeed), 5);
      const impactSign = Math.sign(other.args.xSpeed);
      if (this.args.hitPoints > 0 && other.controllable) {
        if (!(other.args.jumping || other.args.rolling || other.dashed)) {
          other.damage();
          this.args.phase = 'ready';
          if (typeof ga === 'function') {
            ga('send', 'event', {
              eventCategory: 'boss',
              eventAction: 'damaged-player',
              eventLabel: `${this.viewport.args.actName}::${this.args.id}::${other.args.id}`
            });
          }
          return true;
        }
      }
      if (this.args.phase === 'dead') {
        if (!(other.args.jumping || other.args.rolling || other.dashed)) {
          return true;
        }
        this.args.explodeFrame = this.viewport.args.frameId;
        this.args.phase = 'exploding';
      }
      if (type === 1 || type === 3)
        // Side collisions
        {
          if (other.args.falling) {
            this.ignores.set(other, 15);
          } else {
            other.args.gSpeed = 4 * -Math.sign(this.x - other.x);
            if (other.args.rolling) {
              this.onNextFrame(() => {
                other.args.gSpeed = -Math.sign(this.x - other.x);
                other.args.rolling = true;
                other.args.direction = Math.sign(other.args.gSpeed);
              });
            }
          }
          this.args.ySpeed = 0;
          if (this.args.hitPoints > 0) {
            this.damage(other);
          }
          if (this.args.hitPoints > 0) {
            other.args.xSpeed = -xSign * impactSpeed;
            this.args.xSpeed = xSign * impactSpeed;
          } else {
            other.args.xSpeed = -xSign * impactSpeed * 0.5;
            this.args.xSpeed = xSign * impactSpeed * 0.5;
          }
        }
      if (type === 2)
        // Collide from bottom
        {
          if (this.viewport.args.audio) {
            _Sfx.Sfx.play('BOSS_DUDHIT');
          }
          if (other.args.falling) {
            this.args.ySpeed = other.args.ySpeed * 2.5;
            if (other.args.controllable) {
              other.args.ySpeed = Math.max(7, Math.abs(other.args.ySpeed));
            }
          }
          this.args.xSpeed = 0;
          if (this.args.hitPoints > 0) {
            this.args.phase = 'knocked';
          }
          this.ignores.set(other, 15);
        }
      if (type === 0)
        // Collide from top
        {
          if (other.args.falling) {
            this.ignores.set(other, 15);
          }
          if (other.controllable) {
            other.args.y = this.y - this.args.height;
            const animation = other.args.animation;
            const ySpeed = other.args.ySpeed;
            this.onNextFrame(() => {
              other.args.ySpeed = -Math.floor(Math.abs(ySpeed)) || -4;
            });
          }
          this.args.xSpeed = 0;
          this.damage(other);
        }
      other.args.ignore = 1;
      if (!this.args.hitPoints) {
        other.args.ignore = -2;
      } else {
        // this.viewport.controlActor.cofocused = this;
      }
      return true;
    }
  }, {
    key: "damage",
    value: function damage(other) {
      let type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'normal';
      if (this.args.hitPoints <= 0) {
        return;
      }
      const lastHit = this.args.damagers.get(other);
      if (this.args.frameId - lastHit < 5) {
        return;
      }
      this.args.hitPoints--;
      this.args.damagers.set(other, this.args.frameId);
      this.args.phase = 'damaged';
      _Sfx.Sfx.play('BOSS_DAMAGED');
    }
  }, {
    key: "pointIsSafe",
    value: function pointIsSafe(x, y) {
      const hazards = this.viewport.actorsAtPoint(x, y).filter(a => a.hazard);
      if (hazards.length) {
        return false;
      }
      return true;
    }

    // get solid() { return this.args.hitPoints > 0; }
  }, {
    key: "solid",
    get: function get() {
      return false;
    }
  }, {
    key: "rotateLock",
    get: function get() {
      return true;
    }
  }]);
  return Beelzebub;
}(_Mixin.Mixin.from(_PointActor.PointActor));
exports.Beelzebub = Beelzebub;
});

;require.register("actor/Bell.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Bell = void 0;
var _Mixin = require("curvature/base/Mixin");
var _PointActor = require("./PointActor");
var _Constrainable = require("../mixin/Constrainable");
var _Ring = require("./Ring");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let Bell = /*#__PURE__*/function (_Mixin$from) {
  _inherits(Bell, _Mixin$from);
  var _super = _createSuper(Bell);
  function Bell() {
    var _this;
    _classCallCheck(this, Bell);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.z = 100;
    _this.args.width = 64;
    _this.args.height = 64;
    _this.args.type = 'actor-item actor-bell';

    // this.args.ropeLength = this.args._tiedTo ? this.args.ropeLength : 0;

    _this.cooldown = 0;
    _this.noClip = true;
    _this.args.gravity = 0.40;
    return _this;
  }
  _createClass(Bell, [{
    key: "update",
    value: function update() {
      this.xLast = this.x;
      this.yLast = this.y;
      _get(_getPrototypeOf(Bell.prototype), "update", this).call(this);
      if (this.cooldown > 0) {
        this.cooldown--;
      }
      if (this.cooldown < 1) {
        this.cooldown = 0;
      }
      const tiedTo = this.args.tiedTo;
      this.setPos();
      this.args.falling = true;
      const moved = this.x - this.xLast;
      if (Math.abs(moved) > 1) {
        this.args.animation = ['ring-left', '', 'ring-right'][1 + Math.sign(this.x - this.xLast)];
      } else {
        this.args.animation = '';
      }
      if (!this.cooldown && (Math.abs(this.args.xSpeed) > 2 || Math.abs(this.args.ySpeed) > 6)) {
        const ring = new _Ring.Ring({
          x: this.x,
          y: this.y
        });
        ring.dropped = true;
        ring.delay = 5;
        ring.args.static = false;
        ring.args.ignore = 10;
        ring.args.xSpeed = this.args.xSpeed * 0.75;
        ring.args.ySpeed = this.args.ySpeed;
        const spawnOffset = this.rotatePoint(0, 32);
        ring.args.x += spawnOffset[0];
        ring.args.y += spawnOffset[1];
        this.viewport.spawn.add({
          object: ring
        });
        this.cooldown = 45 * Math.random() + 15;
        this.viewport.onFrameOut(120, () => {
          this.viewport.actors.remove(ring);
        });
      }
    }
  }, {
    key: "updateEnd",
    value: function updateEnd() {
      if (Math.abs(this.args.xSpeed) < 3 && Math.abs(this.args.ySpeed) < 3) {
        if (this.viewport && !this.viewport.auras.has(this)) {
          this.viewport.auras.add(this);
        }
      } else {
        this.viewport.auras.delete(this);
      }

      // if(this.args.tiedTo)
      // {
      // 	super.update();

      // 	if(this.args.tiedTo && this.args._tiedTo.args.hitPoints)
      // 	{
      // 		this.setPos();
      // 	}
      // 	else
      // 	{
      // 		this.noClip = true;
      // 	}
      // }

      _get(_getPrototypeOf(Bell.prototype), "updateEnd", this).call(this);
    }
  }, {
    key: "collideB",
    value: function collideB(other) {
      if (!other.controllable) {
        return;
      }
      this.args.xSpeed = other.args.xSpeed;
      this.args.ySpeed = other.args.ySpeed;
      other.args.xSpeed *= 0.99;
      this.viewport.args.backdrop.args.sunrise = 1;
    }
  }]);
  return Bell;
}(_Mixin.Mixin.from(_PointActor.PointActor, _Constrainable.Constrainable));
exports.Bell = Bell;
});

;require.register("actor/Big.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Big = void 0;
var _PointActor2 = require("./PointActor");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let Big = /*#__PURE__*/function (_PointActor) {
  _inherits(Big, _PointActor);
  var _super = _createSuper(Big);
  function Big() {
    var _this;
    _classCallCheck(this, Big);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.type = 'actor-item actor-big';
    _this.args.width = 42;
    _this.args.height = 46;
    return _this;
  }
  _createClass(Big, [{
    key: "solid",
    get: function get() {
      return false;
    }
  }]);
  return Big;
}(_PointActor2.PointActor);
exports.Big = Big;
});

;require.register("actor/Blastoid.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Blastoid = void 0;
var _Flickie = require("./Flickie");
var _Mixin = require("curvature/base/Mixin");
var _PointActor = require("./PointActor");
var _Patrol = require("../behavior/Patrol");
var _CanPop = require("../mixin/CanPop");
var _Projectile = require("../actor/Projectile");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let Blastoid = /*#__PURE__*/function (_Mixin$from) {
  _inherits(Blastoid, _Mixin$from);
  var _super = _createSuper(Blastoid);
  function Blastoid() {
    var _this$args$color, _this$args$patrolBeat;
    var _this;
    _classCallCheck(this, Blastoid);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);

    // this.behaviors.add(new Patrol);

    _this.args.type = 'actor-item actor-blastoid';
    _this.args.animation = 'standing';

    // this.args.accel     = 0.75;
    // this.args.decel     = 0.5;

    // this.args.gSpeedMax = 15;
    // this.args.jumpForce = 5;
    // this.args.gravity   = 0.5;

    _this.args.width = 35;
    _this.args.height = 21;
    _this.args.flipped = false;
    _this.args.careening = false;
    _this.args.color = (_this$args$color = _this.args.color) !== null && _this$args$color !== void 0 ? _this$args$color : 'blue';
    _this.willStick = true;
    _this.stayStuck = true;

    // this.args.patrolPause   = this.args.patrolPause   ?? 20;
    _this.args.patrolBeat = (_this$args$patrolBeat = _this.args.patrolBeat) !== null && _this$args$patrolBeat !== void 0 ? _this$args$patrolBeat : 120;
    // this.args.patrolSpeed   = this.args.patrolSpeed   ?? 4;
    return _this;
  }
  _createClass(Blastoid, [{
    key: "onRendered",
    value: function onRendered(event) {
      _get(_getPrototypeOf(Blastoid.prototype), "onRendered", this).call(this, event);
      this.autoAttr.get(this.box)['data-color'] = 'color';
      this.autoAttr.get(this.box)['data-flipped'] = 'flipped';
    }
  }, {
    key: "update",
    value: function update() {
      if (this.args.flipped) {
        _get(_getPrototypeOf(Blastoid.prototype), "update", this).call(this);
        const xMoved = this.args.x - this.xLast;
        const yMoved = this.args.y - this.yLast;
        if (this.args.careening && !xMoved && !yMoved && !this.args.falling) {
          _get(_getPrototypeOf(Blastoid.prototype), "pop", this).call(this);
          return;
        }
        return;
      }

      // const direction = this.args.direction;
      const telegraph = this.args.shotTelegraph;
      const beat = this.args.patrolBeat;
      if (this.viewport.args.frameId % beat === 0) {
        const xSpeed = +2.5;
        const ySpeed = -3;
        const owner = this;
        const ball = new _Projectile.Projectile({
          x: this.x + 13 * this.args.direction,
          y: this.y + -8,
          xSpeed: xSpeed * this.args.direction,
          ySpeed: ySpeed,
          owner: owner
        });
        this.viewport.spawn.add({
          object: ball
        });
      }
      _get(_getPrototypeOf(Blastoid.prototype), "update", this).call(this);

      // this.args.direction = Math.sign(this.args.gSpeed);
    }
  }, {
    key: "effect",
    value: function effect(other) {
      _get(_getPrototypeOf(Blastoid.prototype), "effect", this).call(this, other);

      // this.viewport.spawn.add({object:new Flickie({
      // 	x: this.args.x,
      // 	y: this.args.y,
      // })});
    }

    // collideA(other, type)
    // {
    // 	if(typeof other.pop === 'function')
    // 	{
    // 		other.pop(other, type);
    // 	}

    // 	if(this.args.careening && other.controllable)
    // 	{
    // 		super.pop(other);
    // 		return;
    // 	}

    // 	if(this.args.flipped)
    // 	{
    // 		other.args.ySpeed *= -1;
    // 		this.args.gSpeed = 12 * Math.sign(this.args.x - other.args.x);
    // 		this.args.careening = true;
    // 		this.args.decel = 0;
    // 		return;
    // 	}

    // 	return super.collideA(other, type);
    // }

    // pop(other)
    // {
    // 	if(!this.args.flipped)
    // 	{
    // 		this.args.flipped = true;
    // 		this.args.falling = true;
    // 		this.args.ySpeed = -6;
    // 		this.args.y--;

    // 		if(other)
    // 		{
    // 			this.ignores.set(other, 10);
    // 			other.args.ySpeed *= -1;
    // 		}

    // 		return;
    // 	}

    // 	// return super.pop(other);
    // }
  }, {
    key: "solid",
    get: function get() {
      return false;
    }
  }, {
    key: "isEffect",
    get: function get() {
      return false;
    }
    // get controllable() { return true; }
  }]);
  return Blastoid;
}(_Mixin.Mixin.from(_PointActor.PointActor, _CanPop.CanPop));
exports.Blastoid = Blastoid;
});

;require.register("actor/Block.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Block = void 0;
var _PointActor2 = require("./PointActor");
var _Tag = require("curvature/base/Tag");
var _Ring = require("./Ring");
var _LayerSwitch = require("./LayerSwitch");
var _GrapplePoint = require("./GrapplePoint");
var _QuintInOut = require("curvature/animate/ease/QuintInOut");
var _CubicInOut = require("curvature/animate/ease/CubicInOut");
var _Platformer = require("../behavior/Platformer");
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let Block = /*#__PURE__*/function (_PointActor) {
  _inherits(Block, _PointActor);
  var _super = _createSuper(Block);
  function Block() {
    var _this$args$z, _args$convey, _this$args$solid, _args$collapse, _args$drop;
    var _this;
    let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let parent = arguments.length > 1 ? arguments[1] : undefined;
    _classCallCheck(this, Block);
    _this = _super.call(this, args, parent);
    _this.hitBlocks = false;
    _this.args.yForce = 0;
    _this.args.yLean = 0;
    _this.args.z = (_this$args$z = _this.args.z) !== null && _this$args$z !== void 0 ? _this$args$z : 100;
    _this.args.type = 'actor-item actor-block';
    _this.args.width = args.width || 32;
    _this.args.height = args.height || 32;
    _this.args.convey = (_args$convey = args.convey) !== null && _args$convey !== void 0 ? _args$convey : 0;
    _this.args.conveyed = 0;
    _this.args.ySpeedMax = 32;
    _this.originalX = _this.args.x;
    _this.originalY = _this.args.y;
    _this.args.solid = (_this$args$solid = _this.args.solid) !== null && _this$args$solid !== void 0 ? _this$args$solid : true;
    _this.args.gravity = 0.4;
    _this.args.collapse = (_args$collapse = args.collapse) !== null && _args$collapse !== void 0 ? _args$collapse : false;
    _this.args.drop = (_args$drop = args.drop) !== null && _args$drop !== void 0 ? _args$drop : false;
    _this.args.active = -1;
    _this.weighted = false;
    _this.activatedAt = null;
    _this.originalModes = new Map();
    _this.watching = new Set();
    if (_this.args.master) {
      _this.childBlocks = new Set();
    }

    // this.args.bindTo('spriteSheet', v => console.trace(v));
    return _this;
  }
  _createClass(Block, [{
    key: "onRendered",
    value: function onRendered(event) {
      _get(_getPrototypeOf(Block.prototype), "onRendered", this).call(this, event);
      if (!this.viewport) {
        return;
      }
      if (this.args.match) {
        this.match = this.viewport.actorsById[this.args.match];
      }

      // if(this.screen)
      // {
      // 	return;
      // }

      // this.screen = new Tag(`<input type = "text" placeholder = "this effect is dynamic">`);
      // this.screen2 = new Tag(`<input tabindex = "0" type = "button" value = "submit">`);

      // this.sprite.appendChild(this.screen.node);
      // this.sprite.appendChild(this.screen2.node);

      // this.screen.style({'pointer-events':'initial', 'z-index': 1000});

      // if(!this.viewport)
      // {
      // 	event.preventDefault();
      // 	return false;
      // }

      this.args.spriteSheet = this.args.spriteSheet || '/Sonic/marble-zone-block.png';
      if (this.args.droop) {
        this.droop(0);
      }
      this.args.collapse && this.tags.sprite.classList.add('collapse');
      this.args.platform && this.tags.sprite.classList.add('platform');
      this.args.drop && this.tags.sprite.classList.add('drop');
      if (this.args.hidden) {
        event && event.preventDefault();
        return false;
      }
      this.setTile();
    }
  }, {
    key: "initialize",
    value: function initialize() {
      if (!this.otherDefs.path && !this.otherDefs.ridePath) {
        return;
      }
      this.pathReset();
    }
  }, {
    key: "pathReset",
    value: function pathReset() {
      if (this.args.master) {
        const path = this.otherDefs.path || this.otherDefs.ridePath;
        if (path) {
          this.pathNext = path;
          this.args.x = path.x;
          this.args.y = path.y;
          this.viewport.setColCell(this);
          for (const child of this.childBlocks) {
            const path = child.otherDefs.path || child.otherDefs.ridePath;
            child.pathNext = path;
            child.args.x = path.x;
            child.args.y = path.y;
            this.viewport.setColCell(child);
          }
        }
      } else if (this.others.childOf) {
        this.others.childOf.pathReset();
      }
    }
  }, {
    key: "wakeUp",
    value: function wakeUp() {
      this.sleeping = false;
      if (this.otherDefs.path) {
        if (this.others.childOf) {
          this.others.childOf.childBlocks.add(this);
        }
      }
      this.pathReset();
      this.setTile();
      this.noClip = false;
      if (!this.args.tiedTo) {
        return;
      }
      if (!this.args._tiedTo) {
        this.args._tiedTo = this.viewport.actorsById[this.args.tiedTo];
      }
      const _tiedTo = this.args._tiedTo;
      if (_tiedTo && !_tiedTo.hanging.has(this.constructor)) {
        _tiedTo.hanging.set(this.constructor, new Set());
        const hangList = _tiedTo.hanging.get(this.constructor);
        hangList.add(this);
        this.chain = new _Tag.Tag('<div class = "chain">');
        this.sprite.appendChild(this.chain.node);
        this.onRemove(() => hangList.delete(this));
      }
    }
  }, {
    key: "collideA",
    value: function collideA(other, type) {
      if (other instanceof _LayerSwitch.LayerSwitch) {
        return;
      }
      if (other instanceof _GrapplePoint.GrapplePoint && this.args.platform) {
        return;
      }
      if (other instanceof this.constructor && !other.args.falling && !other.hitBlocks) {
        return false;
      }
      if (other.isRegion || other.noClip || other.args.static) {
        return false;
      }
      if (other.args.standingOn === this) {
        this.weighted = true;
      }
      if (this.objDef && this.args.platform && this.objDef.type === 'hex-nut' && other.objDef && other.objDef.type === 'hex-nut') {
        return false;
      }
      let xDist = 0.5 + (other.x - this.x) / this.args.width;
      if (other.args.gSpeed < 0) {
        xDist = -xDist + 1;
      }
      if (other.args.mode) {
        xDist = -xDist + 1;
      }
      if (this.args.hSwap && other.groundTime > 2 && Math.abs(other.args.gSpeed) > 8 && xDist < 0.2) {
        this.watching.add(other);
        if (!this.originalModes.has(other)) {
          this.originalModes.set(other, {
            mode: other.args.mode,
            rolling: other.args.rolling,
            gSpeed: other.args.gSpeed
          });
        }
        if (this.originalModes.has(other)) {
          other.args.gSpeed = this.originalModes.get(other).gSpeed;
        }
      }
      if ((!other.args.falling && !other.args.climbing || other.args.climbing && other.y < this.y - this.args.height) && this.args.droop && other.args.ySpeed >= 0 && other.args.standingOn !== this) {
        return true;
      }
      if (!other.args.climbing && this.args.droop && other.controllable && (type === 0 || type === 2) && other.args.ySpeed >= 0) {
        const blockTop = this.originalY + -this.args.height;
        const half = Math.floor(this.args.width / 2);
        const speed = other.args.gSpeed;
        const absSpeed = Math.abs(speed);
        if (absSpeed > half) {
          this.args.y = this.originalY;
          other.args.y = blockTop + -1;
          this.args.yForce = 0;
          this.args.yLean = 0;
          return true;
        }
        const pos = (this.x + -other.x + -(speed * 2)) / half;
        const droop = Number(this.args.droop) * 0.9;
        const absPos = Math.abs(pos);

        // this.screen.placeholder = `drooping at ${pos.toFixed(2)}`;

        if (absPos >= 0.9) {
          this.args.yForce = 0;
          this.args.yLean = this.args.yLean / 100;
          return true;
        }
        const yForceMax = Math.round(droop * (1 - Math.abs(pos)) / 2);
        this.args.yForce += Math.max(other.ySpeedLast, 0);
        this.args.yForce = Math.min(yForceMax, this.args.yForce);
        this.args.yForce = Math.max(this.args.yForce, -yForceMax);
        this.droopPos = this.x - other.x;

        // if(this.args.output)
        // {
        // 	const output = this.viewport.actorsById[ this.args.output ];

        // 	if(output)
        // 	{
        // 		output.args.content = this.screen.value;
        // 	}
        // }
      }

      // if(!other.args.bouncing && (type === 0 || type === -1) && !this.args.platform && other.controllable && other.args.ySpeed)
      // {
      // 	// other.args.y = other.yLast;
      // 	if(other.args.y < this.args.y)
      // 	{
      // 		other.args.y = this.y + -this.args.height;
      // 		other.args.falling = false;
      // 		other.args.ySpeed = this.args.ySpeed;
      // 	}

      // 	return;
      // }

      if (this.args.platform && !other.args.dead && !(other instanceof _Ring.Ring)) {
        const otherTop = other.args.y - other.args.height;
        const blockTop = this.args.y - this.args.height;
        const halfWidth = this.args.width / 2;
        if (other.args.falling && Math.abs(other.args.y - blockTop) < 4 && other.args.ySpeed >= 0 && !other.args.float && (!other.args.dashed || other.args.ySpeed > other.args.xSpeed)) {
          if (other.controllable || other.args.npc) {
            other.args.y = -1 + blockTop;
          } else {
            other.args.y = blockTop;
          }
        }
        if (other.args.y <= blockTop && (other.args.falling === false || other.args.ySpeed > 0)) {
          return true;
        }
        if (other.args.falling === false && other.args.mode === 2) {
          return true;
        }
        if (other.args.npc && !other.args.falling && this.args.falling && !this.args.float) {
          other.startle();
          other.noClip = true;
        }
        return false;
      }
      if (!other.controllable && !other.isVehicle) {
        return true;
      }
      if (!this.switch && this.args.drop && (type === 0 || type === 2) && this.args.float <= 0) {
        this.args.float = 1;
        this.args.goBack = false;
      }
      if (!this.switch && this.args.collapse && (type === 0 || type === 2) && this.args.float <= 0) {
        if (other.args.ySpeed > 15) {
          this.args.float = 1;
          this.args.goBack = false;
          const ySpeed = other.args.ySpeed;
          this.onNextFrame(() => {
            if (this.args.falling || this.args.float) {
              this.args.ySpeed = ySpeed;
              this.args.float = 1;
            } else {
              this.args.ySpeed = -1;
              this.args.float = 1;
            }
            this.args.falling = true;
          });
        } else if (other.args.ySpeed > 0 || other.args.gSpeed) {
          this.args.float = this.args.float >= 0 ? this.args.float : this.args.delay || 0;
        }
        this.viewport.onFrameOut(1, () => this.args.falling = true);
      }
      return true;
    }
  }, {
    key: "activate",
    value: function activate() {
      this.args.active = true;
    }
  }, {
    key: "deactivate",
    value: function deactivate() {
      this.args.active = false;
    }
  }, {
    key: "update",
    value: function update() {
      if (this.others.childOf) {
        return;
      } else if (this.args.master) {
        for (const child of this.childBlocks) {
          child._update();
        }
      }
      return this._update();
    }
  }, {
    key: "_update",
    value: function _update() {
      if (!this.viewport) {
        return;
      }
      const frameId = this.viewport.args.frameId - this.viewport.args.startFrameId;
      if (this.args.active > 0) {
        if (!this.activatedAt) {
          this.activatedAt = frameId;
        }
      }
      if (this.args.switch && !this.switch) {
        this.switch = this.viewport.actorsById[this.args.switch];
      }
      if (this.args.static) {
        _get(_getPrototypeOf(Block.prototype), "update", this).call(this);
        return;
      }
      if (this.args.collapse) {
        this.args.gSpeed = 0;
        if (!this.switch && this.activatedAt && frameId - this.activatedAt > 25 || this.switch && this.switch.args.active) {
          this.args.float = this.args.float >= 0 ? this.args.float : this.args.delay || 0;
          if (!this.args.float) {
            this.args.ySpeed = this.args.ySpeed || 12;
          }
        }
      }
      if (this.args.drop) {
        this.args.gSpeed = 0;
        if (!this.switch && this.activatedAt && frameId - this.activatedAt > 25 || this.switch && this.switch.args.active) {
          this.args.float = this.args.float >= 0 ? this.args.float : this.args.delay || 0;
          this.noClip = true;
          this.args.active = false;
          this.args.falling = true;
        }
      }
      if (this.match) {
        this.args.convey = -this.match.args.convey;
      }
      this.xLast = this.args.x;
      this.yLast = this.args.y;
      if (this.otherDefs.path) {
        let next = this.pathNext || this.otherDefs.path;
        if (next) {
          var _this$args$pathSpeed;
          for (const prop of next.properties) {
            if (prop.name === 'next') {
              next = this.viewport.objDefs.get(prop.value);
            }
          }
          const speed = (_this$args$pathSpeed = this.args.pathSpeed) !== null && _this$args$pathSpeed !== void 0 ? _this$args$pathSpeed : 8;
          const xDiff = this.args.x - next.x;
          const yDiff = this.args.y - next.y;
          const angle = Math.atan2(yDiff, xDiff);
          if (Math.abs(xDiff) < speed && Math.abs(yDiff) < speed) {
            this.pathNext = next;
          }
          if (Math.abs(xDiff) < speed) {
            this.args.x = next.x;
          } else {
            this.args.x -= speed * Math.cos(angle);
          }
          if (Math.abs(yDiff) < speed) {
            this.args.y = next.y;
          } else {
            this.args.y -= speed * Math.sin(angle);
          }
        }
      }
      if (this.args.float && this.args.oscillateX && this.args.oscillateY) {
        var _this$args$offset;
        const timeFrame = frameId + ((_this$args$offset = this.args.offset) !== null && _this$args$offset !== void 0 ? _this$args$offset : 0) * Math.PI;
        {
          const current = Math.sin(timeFrame / this.args.timeX);
          const moveX = current * this.args.oscillateX;
          this.args.x = this.originalX - moveX;
        }
        {
          const current = Math.cos(timeFrame / this.args.timeY);
          const moveY = -(current * this.args.oscillateY);
          this.args.y = this.originalY - moveY;
        }
      } else if (this.args.float && (this.args.oscillateX || this.args.oscillateY)) {
        const current = Math.pow(Math.cos(Math.pow(Math.sin(frameId / 90), 5)), 5 * 3.333);
        if (this.args.oscillateX) {
          const moveX = Math.round(current * this.args.oscillateX);
          this.args.x = this.originalX - moveX;
        }
        if (this.args.oscillateY) {
          const moveY = Math.round(current * this.args.oscillateY);
          this.args.y = this.originalY - moveY;
        }
      }
      if (!this.switch && this.args.collapse) {
        // if(!this.reset && !this.args.once)
        // {
        // 	this.reset = true;

        // 	this.viewport.onFrameOut(300, () => {
        // 		this.args.groundAngle = 0;
        // 		this.args.falling = true;
        // 		this.args.goBack = true;
        // 		this.args.float = -1;
        // 		this.reset = false;
        // 	});
        // }

        // if(!this.args.worm && this.args.goBack)
        // {
        // 	this.args.float = -1;

        // 	this.noClip = true;

        // 	const distX = this.originalX - this.args.x;
        // 	const distY = this.originalY - this.args.y;

        // 	this.args.xSpeed = 0;
        // 	this.args.ySpeed = 0;
        // 	this.args.gSpeed = 0;

        // 	if(Math.abs(distX) > 3)
        // 	{
        // 		this.args.x += Math.sign(distX) * 3;
        // 	}
        // 	else
        // 	{
        // 		this.args.x	= this.originalX;
        // 	}

        // 	if(Math.abs(distY) > 3)
        // 	{
        // 		this.args.y += Math.sign(distY) * 3;
        // 	}
        // 	else
        // 	{
        // 		this.args.y	= this.originalY;
        // 	}

        // 	if(this.args.x === this.originalX && this.args.y === this.originalY)
        // 	{
        // 		this.args.goBack = false;
        // 		this.noClip = false;
        // 	}

        // 	this.args.groundAngle = 0;
        // 	this.args.airAngle = 0;
        // }
      } else if (this.args.droop) {
        this.snapBack = this.snapBack || false;
        if (!this.args.colliding && this.args.yForce && this.viewport) {
          this.viewport.onFrameOut(4, () => {
            if (!this.viewport) {
              return;
            }
            const colliding = this.viewport.collisions.has(this);
            const collisions = colliding ? [...this.viewport.collisions.get(this).keys()] : [];
            if (!colliding || !collisions.filter(a => a.controllable).length) {
              this.snapBack = true;
            }
          });
        }
        if (!this.args.colliding && this.args.yForce && this.snapBack) {
          this.args.yForce *= 0.15;
        }
        if (Math.abs(this.args.yForce) <= 1) {
          // this.screen.placeholder = `flat.`;
          this.snapBack = false;
        }
        if (this.args.yForce !== this.args.yLean) {
          const diff = this.args.yLean - this.args.yForce;
          const step = this.args.yForce > this.args.yLean ? Math.abs(diff) * 0.666 : Math.abs(diff) * 0.333;
          this.args.yLean -= Math.sign(diff) * step;
          if (Math.abs(diff) < step) {
            this.args.yLean = this.args.yForce;
          }
        }
        if (!this.args.yLean) {
          this.args.y = this.originalY;
        } else {
          this.args.y = Math.ceil(this.originalY + this.args.yLean) || this.originalY;
          this.droop(-1 * this.args.yLean, this.droopPos || 0);
          // this.onNextFrame(() => {
          // 	this.args.y = Math.ceil(this.originalY + this.args.yLean) || this.originalY;
          // 	this.droop(-1 * this.args.yLean, this.droopPos || 0);
          // });
        }
      }

      this.box && this.box.style({
        '--convey': Math.abs(this.args.convey)
      });
      this.box && this.box.style({
        '--conveyDir': Math.sign(this.args.conveyed)
      });
      this.args.conveyed += this.args.convey;
      this.box && this.box.style({
        '--conveyed': this.args.conveyed * 0.8
      });
      this.box && this.box.setAttribute('data-design', this.args.design);
      const _tiedTo = this.args._tiedTo;
      if (_tiedTo && this.chain) {
        const point = {
          x: this.args.x,
          y: this.args.y - this.args.height
        };
        this.chain.style({
          '--distance': _tiedTo.distanceFrom(point) + this.args.height,
          '--angle': _tiedTo.angleTo(point) + Math.PI / 2
        });
      }
      _get(_getPrototypeOf(Block.prototype), "update", this).call(this);
    }
  }, {
    key: "updateStart",
    value: function updateStart() {
      if (this.args.float && this.args.settle) {
        if (this.weighted && this.args.y < this.def.get('y') + this.args.settle) {
          this.args.y += Math.min(Math.abs(this.args.settle), 64) / 8 * Math.sign(this.args.settle);
        }
        if (!this.weighted && this.y > this.def.get('y')) {
          this.args.y -= Math.min(Math.abs(this.args.settle), 32) / 8 * Math.sign(this.args.settle);
        }
      }
      this.weighted = false;
      for (const other of this.watching) {
        const _this$originalModes$g = this.originalModes.get(other),
          mode = _this$originalModes$g.mode,
          rolling = _this$originalModes$g.rolling,
          gSpeed = _this$originalModes$g.gSpeed;
        let xDist = 0.5 + (other.x - this.x) / this.args.width;
        const direction = Math.sign(gSpeed);
        if (direction < 0) {
          xDist = -xDist + 1;
        }
        if (mode) {
          xDist = -xDist + 1;
        }
        const xMoved = other.args.x - other.xLast;
        if (xDist >= 1) {
          this.originalModes.delete(other);
          this.watching.delete(other);
          other.noClip = false;
        }
        if (xDist >= 0.75) {
          other.args.xSpeed = xMoved;
          other.args.float = 0;
          other.args.falling = false;
          other.args.rolling = rolling;
          other.args.ignore = 9;
          // other.xAxis = Math.sign(other.args.gSpeed);

          if (mode === 0) {
            other.args.gSpeed = -gSpeed;
            other.args.y = this.args.y + 1;
            other.args.mode = 2;
            other.args.facing = Math.sign(gSpeed) < 0 ? 'right' : 'left';
          }
          if (mode === 2) {
            other.args.gSpeed = -gSpeed;
            other.args.y = this.args.y + -this.args.height;
            other.args.mode = 0;
            other.args.facing = Math.sign(gSpeed) < 0 ? 'right' : 'left';
          }
        } else {
          const speed = xMoved;
          other.args.gSpeed = mode ? -speed : speed;
          other.args.xSpeed = speed;
          other.args.float = -1;
          other.noClip = true;
          other.args.antiSkid = 35;
          // other.xAxis = Math.sign(other.args.gSpeed);

          other.args.direction = -Math.sign(gSpeed);
          const shiftFactor = Math.min(Math.max(xDist * 1.333, 0), 1);
          if (!rolling) {
            other.args.corkscrew = Math.min(shiftFactor * 0.5, 0.375);
            other.args.animation = 'barrel-roll';
          } else {
            other.args.rolling = true;
          }
          if (mode === 0) {
            other.args.y = this.y + -this.args.height + this.args.height * shiftFactor * 2;
          }
          if (mode === 2) {
            other.args.y = this.y + -this.args.height * shiftFactor * 2;
          }
        }
      }
    }
  }, {
    key: "updateEnd",
    value: function updateEnd() {
      _get(_getPrototypeOf(Block.prototype), "updateEnd", this).call(this);
      if (!this.viewport || !this.viewport.collisions.has(this)) {
        return;
      }
      const collidees = this.viewport.collisions.get(this);
      if (this.args.treadmill) {
        this.args.convey = 0;
        let speedCount = 0;
        let speedSum = 0;
        for (const _ref of collidees) {
          var _ref2 = _slicedToArray(_ref, 2);
          const collidee = _ref2[0];
          const type = _ref2[1];
          if (collidee.args.standingOn !== this) {
            continue;
          }
          if (collidee.args.gSpeed) {
            speedCount++;
            speedSum += collidee.args.gSpeed;
          }
        }
        if (speedCount) {
          this.args.convey = -speedSum / speedCount;
        }
      }
      if (this.args.convey) {
        for (const _ref3 of collidees) {
          var _ref4 = _slicedToArray(_ref3, 2);
          const collidee = _ref4[0];
          const type = _ref4[1];
          if (!collidee.controllable || collidee.args.falling) {
            continue;
          }
          const conveyTo = collidee.bMap('findNextStep', this.args.convey).get(_Platformer.Platformer);
          if (conveyTo[3]) {
            continue;
          }
          if (conveyTo[2]) {
            collidee.args.xSpeed = this.args.convey;
            collidee.args.ySpeed = 0;
            collidee.args.falling = true;
            collidee.args.y = -1 + this.y - this.args.height;
          }
          collidee.args.x += conveyTo[0];
          collidee.args.y += conveyTo[1];
        }
      }
      if (!this.args.platform) {
        return;
      }
      const moveUp = Math.min(this.args.ySpeed, this.args.y - this.yLast, 0);
      if (moveUp < 0) {
        for (let x = -this.args.width * 0.5 + 4; x < this.args.width * 0.5; x += 4) {
          const xx = this.args.x + x;
          const actors = this.viewport.actorsAtLine(xx, this.args.y + -this.args.height, xx, this.args.y + -moveUp + -this.args.height);
          for (const _ref5 of actors) {
            var _ref6 = _slicedToArray(_ref5, 2);
            const actor = _ref6[0];
            const point = _ref6[1];
            if (!actor.controllable || !actor.args.falling || actor.args.y < this.args.y) {
              continue;
            }
            actor.args.y = this.args.y + moveUp + -this.args.height;
            actor.args.ySpeed = this.args.ySpeed;
            actor.args.falling = false;
          }
        }
      }
    }
  }, {
    key: "sleep",
    value: function sleep() {
      this.sleeping = true;

      // if(this.others.childOf)
      // {
      // 	this.others.childOf.sleep();
      // }

      if (this.args.drop && this.args.once && !this.args.float) {
        this.viewport.actors.remove(this);
      }
      if (this.args.drop && this.args.float >= 0) {
        this.args.ySpeed = 0;
        this.args.float = -1;
        this.args.active = false;
        this.args.falling = false;
        this.viewport.onFrameOut(120, () => {
          this.args.y = this.originalY;
          this.activatedAt = null;
          this.args.goBack = false;
          this.noClip = false;
          this.args.ySpeed = 0;
          this.args.float = -1;
          this.args.active = false;
          this.args.falling = false;
          this.viewport.setColCell(this);
        });
      }
    }
  }, {
    key: "rotateLock",
    get: function get() {
      return true;
    }
  }, {
    key: "canStick",
    get: function get() {
      return !this.args.platform;
    }
  }, {
    key: "solid",
    get: function get() {
      return this.args.solid && (!this.args.collapse || this.args.float !== 0 || !this.args.goBack);
    }
  }], [{
    key: "fromDef",
    value: function fromDef(objDef) {
      const obj = _get(_getPrototypeOf(Block), "fromDef", this).call(this, objDef);
      obj.args.width = objDef.width;
      obj.args.height = objDef.height;

      // obj.args.x = obj.originalX = objDef.x + Math.floor(objDef.width / 2);
      obj.args.y = obj.originalY = objDef.y;
      return obj;
    }
  }]);
  return Block;
}(_PointActor2.PointActor);
exports.Block = Block;
});

;require.register("actor/Block3d.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Block3d = void 0;
var _Block2 = require("./Block");
var _Tag = require("curvature/base/Tag");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
// import { LavaRegion } from '../region/LavaRegion';
let Block3d = /*#__PURE__*/function (_Block) {
  _inherits(Block3d, _Block);
  var _super = _createSuper(Block3d);
  function Block3d() {
    var _this;
    let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    _classCallCheck(this, Block3d);
    _this = _super.call(this, args);
    _this.args.type = 'actor-item actor-block actor-block-3d';
    return _this;
  }
  _createClass(Block3d, [{
    key: "onRendered",
    value: function onRendered(event) {
      _get(_getPrototypeOf(Block3d.prototype), "onRendered", this).call(this, event);
      const front = new _Tag.Tag('<div class = "panel-3d front-3d">');
      const back = new _Tag.Tag('<div class = "panel-3d back-3d">');
      const left = new _Tag.Tag('<div class = "panel-3d right-3d">');
      const right = new _Tag.Tag('<div class = "panel-3d left-3d">');
      const top = new _Tag.Tag('<div class = "panel-3d top-3d">');
      const bottom = new _Tag.Tag('<div class = "panel-3d bottom-3d">');
      this.box.append(back.node);
      this.box.append(left.node);
      this.box.append(right.node);
      this.box.append(front.node);
      this.box.append(top.node);
      this.box.append(bottom.node);
    }
  }]);
  return Block3d;
}(_Block2.Block);
exports.Block3d = Block3d;
});

;require.register("actor/BoostRing.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BoostRing = void 0;
var _PointActor2 = require("./PointActor");
var _Sfx = require("../audio/Sfx");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let BoostRing = /*#__PURE__*/function (_PointActor) {
  _inherits(BoostRing, _PointActor);
  var _super = _createSuper(BoostRing);
  function BoostRing() {
    var _this$args$pointing, _this$args$power;
    var _this;
    _classCallCheck(this, BoostRing);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.type = 'actor-item actor-boost-ring';
    _this.args.width = 16;
    _this.args.height = 16;
    _this.args.float = -1;
    _this.args.pointing = (_this$args$pointing = _this.args.pointing) !== null && _this$args$pointing !== void 0 ? _this$args$pointing : 0;
    _this.args.power = (_this$args$power = _this.args.power) !== null && _this$args$power !== void 0 ? _this$args$power : 15;
    _this.shooting = new Set();
    return _this;
  }
  _createClass(BoostRing, [{
    key: "onRendered",
    value: function onRendered(event) {
      _get(_getPrototypeOf(BoostRing.prototype), "onRendered", this).call(this, event);
      this.autoStyle.get(this.box)['--pointing'] = 'pointing';
    }
  }, {
    key: "collideA",
    value: function collideA(other) {
      if (!other.controllable || this.shooting.has(other) || other.args.mercy > 120) {
        return;
      }
      other.args.rolling = true;
      other.args.jumping = true;
      other.dashed = false;
      other.args.x = this.args.x;
      other.args.y = this.args.y;
      other.args.xSpeed = 0;
      other.args.ySpeed = 0;
      other.args.float = 15;
      other.args.ignore = 15;
      other.args.cameraIgnore = 30;
      other.args.groundAngle = 0;
      other.args.cameraMode = 'boost-ring';
      other.args.angle = this.args.pointing;
      other.args.flying = false;
      this.shooting.add(other);
      this.viewport.onFrameOut(4, () => other.impulse(this.args.power, this.args.pointing, true));
      this.viewport.onFrameOut(2, () => _Sfx.Sfx.play('BOOST_RING'));
      this.viewport.onFrameOut(10, () => this.shooting.delete(other));
    }
  }, {
    key: "solid",
    get: function get() {
      return false;
    }
  }]);
  return BoostRing;
}(_PointActor2.PointActor);
exports.BoostRing = BoostRing;
});

;require.register("actor/Booster.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Booster = void 0;
var _PointActor2 = require("./PointActor");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let Booster = /*#__PURE__*/function (_PointActor) {
  _inherits(Booster, _PointActor);
  var _super = _createSuper(Booster);
  function Booster() {
    var _this$args$xMax, _this$args$yMax;
    var _this;
    _classCallCheck(this, Booster);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.type = 'actor-item actor-booster';
    _this.args.xMax = (_this$args$xMax = _this.args.xMax) !== null && _this$args$xMax !== void 0 ? _this$args$xMax : 24;
    _this.args.yMax = (_this$args$yMax = _this.args.yMax) !== null && _this$args$yMax !== void 0 ? _this$args$yMax : 24;
    _this.args.width = 64;
    _this.args.height = 345;
    _this.args.float = -1;
    return _this;
  }
  _createClass(Booster, [{
    key: "update",
    value: function update() {
      if (!this.viewport) {
        return;
      }
      _get(_getPrototypeOf(Booster.prototype), "update", this).call(this);
      if (this.args.launched && Math.abs(this.args.xSpeed) < Math.abs(this.args.xMax)) {
        this.args.xSpeed += 0.5 * Math.sign(this.args.xMax);
      }
      if (this.args.launched && Math.abs(this.args.ySpeed) < Math.abs(this.args.yMax)) {
        this.args.ySpeed -= 5 * Math.sign(this.args.yMax);
      }
      if (this.args.launched) {
        this.args.falling = true;
      }
      if (this.args.launched && this.args.xSpeed === 0 && this.args.ySpeed === 0) {
        // this.explode();
      }
    }
  }, {
    key: "activate",
    value: function activate() {
      this.args.active = true;
      this.viewport.auras.add(this);
      this.args.launched = true;
      if (this.args.xMax) {
        this.args.xSpeed += 0.5;
      }
      if (this.args.yMax) {
        this.args.ySpeed -= 0.5;
      }
    }
  }, {
    key: "explode",
    value: function explode() {
      this.viewport.onFrameOut(60, () => {
        this.args.launched = false;
        this.args.active = false;
        this.viewport.auras.delete(this);
        this.args.x = this.def.get('x');
        this.args.y = this.def.get('y');
        this.args.xSpeed = 0;
        this.args.ySpeed = 0;
        this.args.gSpeed = 0;
        this.viewport.setColCell(this);
        const exploded = new CustomEvent('exploded', {
          detail: {
            actor: this
          }
        });
        this.dispatchEvent(exploded);
      });
    }
  }, {
    key: "sleep",
    value: function sleep() {
      if (this.args.launched) {
        this.explode();
      }
    }
  }]);
  return Booster;
}(_PointActor2.PointActor);
exports.Booster = Booster;
});

;require.register("actor/BouncyMushroom.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BouncyMushroom = void 0;
var _Block2 = require("./Block");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let BouncyMushroom = /*#__PURE__*/function (_Block) {
  _inherits(BouncyMushroom, _Block);
  var _super = _createSuper(BouncyMushroom);
  function BouncyMushroom() {
    var _this$args$stemLength;
    var _this;
    _classCallCheck(this, BouncyMushroom);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.width = 64;
    _this.args.height = 32;
    _this.args.platform = true;
    _this.args.float = -1;
    _this.args.type = 'actor-item actor-bouncy-mushroom';
    _this.args.stemLength = (_this$args$stemLength = _this.args.stemLength) !== null && _this$args$stemLength !== void 0 ? _this$args$stemLength : 64;
    _this.args.pressed = 0;
    return _this;
  }
  _createClass(BouncyMushroom, [{
    key: "onRendered",
    value: function onRendered() {
      _get(_getPrototypeOf(BouncyMushroom.prototype), "onRendered", this).call(this);
      this.autoStyle.get(this.box)['--stem-length'] = 'stemLength';
    }
  }, {
    key: "update",
    value: function update() {
      _get(_getPrototypeOf(BouncyMushroom.prototype), "update", this).call(this);
      if (!this.def.get('stemLength')) {
        const stemLengthL = this.castRayQuick(1024, Math.PI / 2, [-16, 0], true) || 32;
        const stemLengthR = this.castRayQuick(1024, Math.PI / 2, [+16, 0], true) || 32;
        this.args.stemLength = Math.min(stemLengthL, stemLengthR);
      }
      this.args.active = this.args.pressed > 0;
      if (this.args.pressed > 0) {
        this.args.pressed--;
      }
    }
  }, {
    key: "collideA",
    value: function collideA(other, type) {
      if (type === 0 && other.args.ySpeed >= 0) {
        other.args.ySpeed = other.args.flying && other.flyTime > 2 ? -2 : -8;
        _get(_getPrototypeOf(BouncyMushroom.prototype), "collideA", this).call(this, other, type);
        this.args.pressed = 6;
        return;
      }
      return _get(_getPrototypeOf(BouncyMushroom.prototype), "collideA", this).call(this, other, type);
    }

    // get solid() {return this.groundTime > 15};
  }]);
  return BouncyMushroom;
}(_Block2.Block);
exports.BouncyMushroom = BouncyMushroom;
});

;require.register("actor/BreakableBlock.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BreakableBlock = void 0;
var _Block2 = require("./Block");
var _Orb = require("./Orb");
var _OrbSmall = require("./OrbSmall");
var _Tag = require("curvature/base/Tag");
var _Sfx = require("../audio/Sfx");
var _Platformer = require("../behavior/Platformer");
var _ObjectPalette = require("../ObjectPalette");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let lastPlay = 0;
let BreakableBlock = /*#__PURE__*/function (_Block) {
  _inherits(BreakableBlock, _Block);
  var _super = _createSuper(BreakableBlock);
  function BreakableBlock() {
    var _this$args$static;
    var _this;
    let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let parent = arguments.length > 1 ? arguments[1] : undefined;
    _classCallCheck(this, BreakableBlock);
    _this = _super.call(this, args, parent);

    // this.behaviors.clear();

    _this.args.type = 'actor-item actor-breakable-block';
    if (_this.args.collapse) {
      _this.args.type = 'actor-item actor-breakable-block collapsible-block';
    }
    _this.args.static = (_this$args$static = _this.args.static) !== null && _this$args$static !== void 0 ? _this$args$static : true;
    _this.args.strength = 0 || Number(_this.args.strength);
    _this.fragmentsX = document.createElement('div');
    _this.fragmentsY = document.createElement('div');
    _this.fragmentsX.classList.add('fragmentsX');
    _this.fragmentsY.classList.add('fragmentsY');
    _this.fragmentTopLeft = document.createElement('div');
    _this.fragmentTopRight = document.createElement('div');
    _this.fragmentBottomLeft = document.createElement('div');
    _this.fragmentBottomRight = document.createElement('div');
    _this.fragmentTopLeft.classList.add('fragment');
    _this.fragmentTopLeft.classList.add('fragment-top-left');
    _this.fragmentTopRight.classList.add('fragment');
    _this.fragmentTopRight.classList.add('fragment-top-right');
    _this.fragmentBottomLeft.classList.add('fragment');
    _this.fragmentBottomLeft.classList.add('fragment-bottom-left');
    _this.fragmentBottomRight.classList.add('fragment');
    _this.fragmentBottomRight.classList.add('fragment-bottom-right');
    _this.fragmentsY.append(_this.fragmentTopLeft);
    _this.fragmentsY.append(_this.fragmentTopRight);
    _this.fragmentsY.append(_this.fragmentBottomLeft);
    _this.fragmentsY.append(_this.fragmentBottomRight);
    _this.fragmentsX.append(_this.fragmentsY);
    _this.broken = false;
    return _this;
  }
  _createClass(BreakableBlock, [{
    key: "onRendered",
    value: function onRendered(event) {
      this.box = this.findTag('div');
      this.sprite = this.findTag('div.sprite');
      _get(_getPrototypeOf(BreakableBlock.prototype), "onRendered", this).call(this, event);
    }
  }, {
    key: "updateStart",
    value: function updateStart() {
      _get(_getPrototypeOf(BreakableBlock.prototype), "updateStart", this).call(this);
      if (this.switch) {
        if (this.switch.args.active && !this.broken) {
          this.break();
        }
      }
    }
  }, {
    key: "update",
    value: function update() {
      const regions = this.viewport.regionsAtPoint(this.args.x, this.args.y);
      for (const region of regions) {
        region.updateActor(this);
      }
      if (this.args.worm && !this.broken && !this.delay2 && this.viewport && this.viewport.controlActor) {
        if (this.viewport.controlActor.args.dead && this.args.x < this.viewport.controlActor.args.x + 32) {
          this.box.classList.add('will-break');
          this.box.classList.add('breaking');
          this.box.classList.add('worm');
          this.delayedBreak(1);
          if (!this.delay2) {
            this.delay2 = this.viewport.onFrameOut(1, () => {
              this.box.classList.add('broken');
              this.delay2 = false;
            });
          }
        }
        let offset = 0;
        if (this.viewport.controlActor.args.falling) {
          offset = -32;
        }
        if (this.viewport.controlActor.args.startled) {
          offset = 16;
        }
        if (this.args.x < this.viewport.controlActor.args.x + offset) {
          this.box.classList.add('will-break');
          this.box.classList.add('breaking');
          this.box.classList.add('worm');
          this.delayedBreak(1);
          if (!this.delay2) {
            this.delay2 = this.viewport.onFrameOut(1, () => {
              this.box.classList.add('broken');
              this.delay2 = false;
            });
          }
        }
      }
      _get(_getPrototypeOf(BreakableBlock.prototype), "update", this).call(this);
    }
  }, {
    key: "callCollideHandler",
    value: function callCollideHandler() {
      if (this.broken) {
        return false;
      }
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return _get(_getPrototypeOf(BreakableBlock.prototype), "callCollideHandler", this).call(this, ...args);
    }
  }, {
    key: "collideA",
    value: function collideA(other, type) {
      if (this.broken) {
        return false;
      }
      if (other instanceof _Block2.Block && (other.args.float || this.args.float)) {
        return false;
      }
      if (!(other instanceof _Orb.Orb) && !other.isVehicle && !other.controllable && !other.args.rolling) {
        return !this.broken;
      }
      if (this.args.collapse) {
        if (!this.broken && other.y <= this.y - this.args.height) {
          const up = this.viewport.actorsAtPoint(this.x, this.y + -this.args.height + -1, 0, 0, true);
          if (Array.isArray(up)) {
            for (const actor of up) {
              if (!(actor instanceof BreakableBlock)) {
                continue;
              }
              if (!actor.args.collapse) {
                continue;
              }
              if (actor.broken) {
                continue;
              }
              return false;
            }
          }
          this.fragmentsX.style.setProperty('--xSpeed', 0);
          if (!other.args.falling) {
            if (this.args.worm) {
              // this.box.classList.add('will-break');
              // this.box.classList.add('breaking');
              // this.box.classList.add('worm');
              // if(!this.delay2)
              // {
              // 	this.delay2 = this.viewport.onFrameOut(1, () => {
              // 		this.box.classList.add('broken');
              // 		this.delay2 = false;
              // 	});
              // }

              // this.delayedBreak(5);
            } else {
              this.delayedBreak(25);
            }
          }
          return true;
        }
        if (!this.broken) {
          if (!other.args.falling && !other.args.climbing || other.args.climbing && other.y < this.y - this.args.height || other.args.ySpeed > 0 && other.y < this.y - this.args.height) {
            return true;
          }
        }
        return false;
      }
      if (this.args.strength === -2) {
        if (other.args.falling || Math.abs(other.args.gSpeed) > 4) {
          this.broken || this.break(other);
          return false;
        }
      }
      if (this.args.strength === -1) {
        return true;
      }
      if (this.args.strength === 1 && other.args.name === 'knuckles') {
        if (other.args.falling || Math.abs(other.args.gSpeed) > 4) {
          this.broken || this.break(other);
          return false;
        }
      }
      if (this.args.strength === 1) {
        if (other.args.name !== 'knuckles' && !other.isVehicle) {
          return true;
        } else if (other.args.name !== 'knuckles' || other.args.falling || Math.abs(other.args.gSpeed) > 4) {
          this.broken || this.break(other);
          return false;
        }
      }
      if (this.args.strength === 2) {
        if (other.isVehicle || other.args.standingOn && other.args.standingOn.isVehicle) {
          if (type === 0) {
            this.viewport.onFrameOut(1, () => this.broken || this.break(other));
            return true;
          }
          this.broken || this.break(other);
          return false;
        } else {
          return true;
        }
      }
      if (!(other.args.rolling && !other.dropDashCharge && other.args.mode) && !other.isVehicle && !other.args.spinning) {
        if (other.args.falling && !(other.dashed || other.args.jumping) || !other.args.falling && type === 0) {
          return !this.broken;
        }
      }
      if (!(other instanceof _Orb.Orb) && !other.falling && !other.isVehicle && !other.args.gSpeed && !other.args.falling) {
        return !this.broken;
      }
      if (other instanceof _Orb.Orb || other.isVehicle || other.args.spinning && !other.spinDashCharge || other.args.dashed || other.punching || other.dropDashCharge && other.args.ySpeed >= 0) {
        const top = this.y - this.args.height;
        if (this.args.bounceBack && other.args.jumping && other.y < top) {
          other.args.ySpeed *= -bounceBack;
          other.args.y = top;
        }
        this.break(other);
        return false;
      }
      return !this.broken;
    }
  }, {
    key: "sleep",
    value: function sleep() {
      if (!this.viewport) {
        return;
      }
      if (this.args.dontRestore) {
        return;
      }
      if (this.args.collapse) {
        this.args.static = true;
        this.args.falling = false;
        this.args.float = -1;
        this.noClip = false;
        this.args.ySpeed = 0;
        this.box.classList.remove('broken');
        this.box.classList.remove('breaking');
        this.box.classList.remove('will-break');
        this.fragmentsX.remove();
        this.broken = false;
      }
      if (this.args.worm) {
        this.args.x += this.args.worm;
      } else if (this.def) {
        this.args.x = this.def.get('x');
      }
      if (this.def) {
        this.args.y = this.def.get('y') + 1;
      } else {
        this.viewport.actors.remove(this);
        return;
      }
      if (this.broken) {
        this.box.classList.remove('broken');
        this.box.classList.remove('breaking');
        this.box.classList.remove('will-break');
        this.fragmentsX.remove();
      }

      // this.args.y = this.def.get('y') + 1;

      this.args.active = 0;
      this.broken = false;
      this.viewport.setColCell(this);
    }
  }, {
    key: "delayedBreak",
    value: function delayedBreak() {
      let delay = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 30;
      let other = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      let silent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      if (this.delay || other && other.args.falling) {
        return;
      }
      this.box.append(this.fragmentsX);
      this.delay = this.viewport.onFrameOut(delay, () => {
        this.break(other, silent, true);
        this.delay = false;
      });
    }
  }, {
    key: "break",
    value: function _break(other) {
      let silent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      let appended = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      const wasBroken = this.broken;
      if (!this.broken) {
        if (!appended) {
          this.box.append(this.fragmentsX);
        }
        this.broken = true;
        if (this.box) {
          const viewport = this.viewport;
          if (!this.args.worm || other && other.noClip) {
            this.box.classList.add('will-break');
            this.box.classList.add('breaking');
            if (!this.delay3) {
              this.delay3 = viewport.onFrameOut(3, () => {
                this.box.classList.add('broken');
                this.delay3 = false;
              });
            }
          }
        }
        if (!silent && Date.now() - lastPlay > 100) {
          if (this.args.worm) {
            this.viewport.onFrameOut(Math.trunc(Math.random() * 3), () => _Sfx.Sfx.play('WORM_BLOCK_DESTROYED'));
            lastPlay = Date.now();
          } else {
            this.viewport.onFrameOut(Math.trunc(Math.random() * 3), () => _Sfx.Sfx.play(this.breakSound || 'BLOCK_DESTROYED'));
          }
        }
        const o = other && other.occupant || other;
        if (o && o.controllable) {
          if (o.args.popChain.length) {
            const reward = {
              label: this.args.name,
              points: 10,
              multiplier: 1
            };
            o.args.popCombo += 1;
            o.args.popChain.push(reward);
          }
          const scoreNode = document.createElement('div');
          scoreNode.classList.add('particle-score');
          scoreNode.classList.add('score-10');
          const scoreTag = new _Tag.Tag(scoreNode);
          scoreTag.style({
            '--x': this.args.x,
            '--y': this.args.y - this.args.height
          });
          this.viewport.particles.add(scoreTag);
          setTimeout(() => this.viewport && this.viewport.particles.remove(scoreTag), 768);
          o.args.score += 10;
        }
        if (this.args.contains && _ObjectPalette.ObjectPalette[this.args.contains]) {
          const object = new _ObjectPalette.ObjectPalette[this.args.contains]();
          object.args.x = this.args.x;
          object.args.y = this.args.y - this.args.height * 0.5;
          object.args.falling = true;
          object.args.xSpeed = this.xSpeedLast || this.gSpeedLast;
          object.args.ySpeed = this.args.ySpeed;
          object.args.ySpeed = -6;
          this.viewport.spawn.add({
            object: object
          });
        }
      }
      if (!this.delay4) {
        this.delay4 = this.viewport.onFrameOut(20, () => {
          this.box && this.box.classList.remove('breaking');
          this.fragmentsX.remove();
          this.delay4 = false;
        });
      }
      if (!this.args.collapse && other && other.args.mode % 2 === 0) {
        const speed = other.args.xSpeed || other.args.gSpeed;
        const dir = Math.sign(speed);
        const mag = Math.abs(speed);
        const x = Math.min(512, mag) * dir;
        if (other.isVehicle) {
          this.fragmentsX.style.setProperty('--xSpeed', Math.round(x * 1.1));
        } else if (other.controllable) {
          this.fragmentsX.style.setProperty('--xSpeed', Math.round(x * 1.5));
        } else {
          this.fragmentsX.style.setProperty('--xSpeed', Math.round(x) * 2);
        }
      }
      if (!this.refresher) {
        this.refresher = true;
      }
      this.args.active = 1;
      if (this.args.collapse && !wasBroken) {
        const left = this.viewport.actorsAtPoint(this.x - this.args.width, this.y, 0, 0, true);
        const right = this.viewport.actorsAtPoint(this.x + this.args.width, this.y, 0, 0, true);
        const down = this.viewport.actorsAtPoint(this.x, this.y + 1, 0, 0, true);
        if (Array.isArray(left) && !Math.sign(this.args.worm)) {
          for (const actor of left) {
            if (!(actor instanceof BreakableBlock)) {
              continue;
            }
            if (!actor.args.collapse) {
              continue;
            }
            if (actor.broken) {
              continue;
            }
            actor.delayedBreak(8, null, silent);
          }
        }
        if (Array.isArray(right) && !Math.sign(this.args.worm)) {
          for (const actor of right) {
            if (!(actor instanceof BreakableBlock)) {
              continue;
            }
            if (!actor.args.collapse) {
              continue;
            }
            if (actor.broken) {
              continue;
            }
            actor.delayedBreak(8, null, silent);
          }
        }
        if (Array.isArray(down) && !Math.sign(this.args.worm)) {
          for (const actor of down) {
            if (!(actor instanceof BreakableBlock)) {
              continue;
            }
            if (!actor.args.collapse) {
              continue;
            }
            if (actor.broken) {
              continue;
            }
            actor.delayedBreak(8, null, true);
          }
        }
      } else if (!wasBroken) {
        const up = this.viewport.actorsAtPoint(this.x, this.y + -this.args.height, 0, 0, true);
        if (Array.isArray(up) && !Math.sign(this.args.worm)) {
          for (const actor of up) {
            if (!(actor instanceof BreakableBlock)) {
              continue;
            }
            if (!actor.args.collapse) {
              continue;
            }
            if (actor.broken) {
              continue;
            }
            actor.delayedBreak(8, null, silent);
          }
        }
      }
      if (this.viewport && this.viewport.settings.rumble && !this.broken && other && other.controller && other.controller.rumble) {
        other.controller && other.controller.rumble && other.controller.rumble({
          duration: 140,
          strongMagnitude: 1.0,
          weakMagnitude: 1.0
        });
        this.onTimeout(140, () => {
          other.controller.rumble({
            duration: 100,
            strongMagnitude: 0.0,
            weakMagnitude: 0.25
          });
        });
      }
      this.broken = true;
    }
  }, {
    key: "damage",
    value: function damage(other) {
      let type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'normal';
      this.break(other);
    }
  }, {
    key: "solid",
    get: function get() {
      return this.args.solid && !this.broken && this.args.strength !== -2;
    }
  }]);
  return BreakableBlock;
}(_Block2.Block);
exports.BreakableBlock = BreakableBlock;
});

;require.register("actor/BrokenMonitor.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BrokenMonitor = void 0;
var _PointActor2 = require("./PointActor");
var _Explosion = require("../actor/Explosion");
var _Monitor = require("../actor/Monitor");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let BrokenMonitor = /*#__PURE__*/function (_PointActor) {
  _inherits(BrokenMonitor, _PointActor);
  var _super = _createSuper(BrokenMonitor);
  function BrokenMonitor() {
    var _this;
    _classCallCheck(this, BrokenMonitor);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.type = 'actor-item actor-monitor actor-monitor-broken';
    _this.args.width = 28;
    _this.args.height = 32;
    return _this;
  }
  _createClass(BrokenMonitor, [{
    key: "collideA",
    value: function collideA(other) {
      // if(other instanceof Monitor)
      // {
      // 	this.viewport && this.viewport.actors.remove(this);
      // 	return false;
      // }

      _get(_getPrototypeOf(BrokenMonitor.prototype), "collideA", this).call(this, other);
      return true;
    }
  }, {
    key: "canStick",
    get: function get() {
      return false;
    }
  }, {
    key: "solid",
    get: function get() {
      return false;
    }
  }]);
  return BrokenMonitor;
}(_PointActor2.PointActor);
exports.BrokenMonitor = BrokenMonitor;
});

;require.register("actor/Bubbles.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Bubbles = void 0;
var _Mixin = require("curvature/base/Mixin");
var _Tag = require("curvature/base/Tag");
var _Flickie = require("./Flickie");
var _PointActor = require("./PointActor");
var _SkidDust = require("../behavior/SkidDust");
var _CanPop = require("../mixin/CanPop");
var _Explosion = require("../actor/Explosion");
var _Projectile = require("../actor/Projectile");
var _ElectricSheild = require("../powerups/ElectricSheild");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let Bubbles = /*#__PURE__*/function (_Mixin$from) {
  _inherits(Bubbles, _Mixin$from);
  var _super = _createSuper(Bubbles);
  function Bubbles() {
    var _this;
    _classCallCheck(this, Bubbles);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.behaviors.add(new _SkidDust.SkidDust());
    _this.args.type = 'actor-item actor-bubbles';
    _this.args.animation = 'standing';
    _this.args.accel = 0.1;
    _this.args.decel = 0.5;
    _this.args.gSpeedMax = 5;
    _this.args.jumpForce = 5;
    _this.args.gravity = 0.5;
    _this.args.width = 32;
    _this.args.height = 32;
    _this.willStick = false;
    _this.stayStuck = false;
    _this.args.float = -1;
    _this.args.static = true;
    _this.aiming = false;
    return _this;
  }
  _createClass(Bubbles, [{
    key: "onRendered",
    value: function onRendered(event) {
      _get(_getPrototypeOf(Bubbles.prototype), "onRendered", this).call(this, event);
      this.shield = new _ElectricSheild.ElectricSheild();
      if (this.args.electric) {
        this.inventory.add(this.shield);
        this.args.currentSheild = this.shield;
      }
      this.autoAttr.get(this.box)['data-gold'] = 'gold';
      this.autoAttr.get(this.box)['data-fade'] = 'fade';
      this.chain = new _Tag.Tag('<div class = "bubbles-flame">');
      this.sprite.appendChild(this.chain.node);
    }
  }, {
    key: "update",
    value: function update() {
      if (!this.viewport || !this.viewport.controlActor) {
        return;
      }
      if (this.args.gold && !this.args.fading) {
        if (Math.abs(this.viewport.controlActor.x - this.x) < 256 && Math.abs(this.viewport.controlActor.y - this.y) < 128) {
          this.args.fading = true;
          const viewport = this.viewport;
          viewport.onFrameOut(25, () => this.args.fade = true);
          viewport.onFrameOut(55, () => viewport.actors.remove(this));
        }
      }
      const frameId = this.viewport.args.frameId - this.viewport.args.startFrameId;
      if (this.viewport && this.args.electric && frameId % 100 === 0) {
        this.args.currentSheild = this.args.currentSheild ? null : this.shield;
      }

      // this.args.ySpeed = this.yAxis;

      if (this.box) {
        this.box.setAttribute('data-animation', 'standing');
      }
      this.args.falling = true;
      this.args.flying = true;
      _get(_getPrototypeOf(Bubbles.prototype), "update", this).call(this);
    }
  }, {
    key: "hold_1",
    value: function hold_1() {
      this.aiming = true;
    }
  }, {
    key: "release_1",
    value: function release_1() {
      this.aiming = false;
    }
  }, {
    key: "effect",
    value: function effect(other) {
      _get(_getPrototypeOf(Bubbles.prototype), "effect", this).call(this, other);

      // this.viewport.spawn.add({object:new Flickie({
      // 	x: this.args.x,
      // 	y: this.args.y,
      // })});
    }
  }, {
    key: "solid",
    get: function get() {
      return false;
    }
  }, {
    key: "isEffect",
    get: function get() {
      return false;
    }
    // get controllable() { return true; }
  }]);
  return Bubbles;
}(_Mixin.Mixin.from(_PointActor.PointActor, _CanPop.CanPop));
exports.Bubbles = Bubbles;
});

;require.register("actor/Bumper.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Bumper = void 0;
var _PointActor2 = require("./PointActor");
var _Sfx = require("../audio/Sfx");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let Bumper = /*#__PURE__*/function (_PointActor) {
  _inherits(Bumper, _PointActor);
  var _super = _createSuper(Bumper);
  function Bumper() {
    var _this;
    _classCallCheck(this, Bumper);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _defineProperty(_assertThisInitialized(_this), "float", -1);
    _this.args.type = 'actor-item actor-bumper';
    _this.args.width = 16;
    _this.args.height = 16;
    _this.ignores = new Map();
    return _this;
  }
  _createClass(Bumper, [{
    key: "collideA",
    value: function collideA(other) {
      if (other.args.static || other.isRegion || this.ignores.has(other) || other.noClip) {
        return;
      }
      this.args.type = 'actor-item actor-bumper actor-bumper-active';
      this.viewport.onFrameOut(3, () => this.args.type = 'actor-item actor-bumper');
      if (other.args.falling) {
        _Sfx.Sfx.play('BUMPER_BOUNCE');
        const xDiff = this.x - other.x;
        const yDiff = this.y - other.y;
        const speed = Math.max(12, Math.hypot(other.args.xSpeed, other.args.ySpeed));
        const angle = Math.atan2(yDiff, xDiff);
        const otherRadius = other.args.width / 2;
        other.args.x = this.x; // + Math.cos(angle) * 10;
        other.args.y = this.y; // + Math.sin(angle) * 10;

        other.args.xSpeed = -speed * Math.cos(angle);
        other.args.ySpeed = -speed * Math.sin(angle);
      } else {
        other.args.gSpeed *= -1;
        if (Math.abs(other.args.gSpeed) < 7) {
          other.args.gSpeed = 7 * Math.sign(other.args.gSpeed);
        }
      }
      this.ignores.set(other, 8);
      if (this.viewport.settings.rumble && other && other.controller && other.controller.rumble) {
        other.controller.rumble({
          duration: 120,
          strongMagnitude: 1.0,
          weakMagnitude: 1.0
        });
        this.onTimeout(120, () => {
          other.controller.rumble({
            duration: 120,
            strongMagnitude: 0.0,
            weakMagnitude: 1.0
          });
        });
      }
    }
  }, {
    key: "canStick",
    get: function get() {
      return false;
    }
  }, {
    key: "rotateLock",
    get: function get() {
      return true;
    }
  }, {
    key: "solid",
    get: function get() {
      return true;
    }
  }]);
  return Bumper;
}(_PointActor2.PointActor);
exports.Bumper = Bumper;
});

;require.register("actor/ButterDroid.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ButterDroid = void 0;
var _PointActor = require("./PointActor");
var _Mixin = require("curvature/base/Mixin");
var _CanPop = require("../mixin/CanPop");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let ButterDroid = /*#__PURE__*/function (_Mixin$from) {
  _inherits(ButterDroid, _Mixin$from);
  var _super = _createSuper(ButterDroid);
  function ButterDroid(args, parent) {
    var _this;
    _classCallCheck(this, ButterDroid);
    _this = _super.call(this, args, parent);
    _this.args.type = 'actor-item actor-butter-droid';
    _this.args.width = 24;
    _this.args.height = 24;
    _this.args.float = -1;
    _this.args.gravity = 0;
    _this.args.phase = 'idle';
    return _this;
  }
  _createClass(ButterDroid, [{
    key: "update",
    value: function update() {
      if (!this.viewport || !this.viewport.actorIsOnScreen(this)) {
        return;
      }
      const viewport = this.viewport;
      this.args.xSpeed = 0.8 * Math.sign(Math.sin(this.age / 60));
      _get(_getPrototypeOf(ButterDroid.prototype), "update", this).call(this);
      const mainChar = viewport.controlActor;
      if (!mainChar) {
        this.args.phase = 'idle';
        return;
      }
      this.args.facing = this.args.xSpeed > 0 ? 'left' : 'right';
      this.args.float = -1;
    }
  }, {
    key: "solid",
    get: function get() {
      return false;
    }
  }, {
    key: "rotateLock",
    get: function get() {
      return true;
    }
  }]);
  return ButterDroid;
}(_Mixin.Mixin.from(_PointActor.PointActor, _CanPop.CanPop));
exports.ButterDroid = ButterDroid;
});

;require.register("actor/BuzzBomber.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BuzzBomber = void 0;
var _Flickie = require("./Flickie");
var _Mixin = require("curvature/base/Mixin");
var _Tag = require("curvature/base/Tag");
var _PointActor = require("./PointActor");
var _SkidDust = require("../behavior/SkidDust");
var _CanPop = require("../mixin/CanPop");
var _Explosion = require("../actor/Explosion");
var _Projectile = require("../actor/Projectile");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let BuzzBomber = /*#__PURE__*/function (_Mixin$from) {
  _inherits(BuzzBomber, _Mixin$from);
  var _super = _createSuper(BuzzBomber);
  function BuzzBomber() {
    var _this;
    _classCallCheck(this, BuzzBomber);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.behaviors.add(new _SkidDust.SkidDust());
    _this.args.type = 'actor-item actor-buzz-bomber';
    _this.args.animation = 'standing';
    _this.args.accel = 0.1;
    _this.args.decel = 0.5;
    _this.args.gSpeedMax = 2;
    _this.args.jumpForce = 5;
    _this.args.gravity = 0.5;
    _this.args.width = 32;
    _this.args.height = 16;
    _this.willStick = false;
    _this.stayStuck = false;
    _this.args.float = -1;
    _this.aiming = false;
    return _this;
  }
  _createClass(BuzzBomber, [{
    key: "onRendered",
    value: function onRendered() {
      _get(_getPrototypeOf(BuzzBomber.prototype), "onRendered", this).call(this);
      this.flame = new _Tag.Tag('<div class = "buzz-bomber-flame">');
      this.wings = new _Tag.Tag('<div class = "buzz-bomber-wings">');
      this.sprite.appendChild(this.flame.node);
      this.sprite.appendChild(this.wings.node);
      if (this.aiming) {
        this.box.setAttribute('data-animation', 'aiming');
      } else {
        const direction = this.args.direction;
        if (Math.sign(this.args.gSpeed) !== direction && Math.abs(this.args.gSpeed - direction) > 5) {
          this.box.setAttribute('data-animation', 'skidding');
        } else if (this.args.moving && this.args.gSpeed) {
          this.box.setAttribute('data-animation', 'walking');
        } else {
          this.box.setAttribute('data-animation', 'standing');
        }
      }
    }
  }, {
    key: "update",
    value: function update() {
      this.args.ySpeed = this.yAxis;
      if (!this.flame) {}
      if (this.args.xSpeed === 0 && this.viewport) {
        this.viewport.onFrameOut(10, () => {
          this.attack();
        });
      }
      this.args.falling = true;
      this.args.flying = true;
      _get(_getPrototypeOf(BuzzBomber.prototype), "update", this).call(this);
    }
  }, {
    key: "command_1",
    value: function command_1() {
      this.aiming = !this.aiming;

      // if(this.aiming)
      // {
      // 	this.args.xSpeed = 0;
      // 	this.args.ySpeed = 0;
      // }
    }
  }, {
    key: "command_2",
    value: function command_2() {
      if (!this.aiming || !this.viewport) {
        return;
      }
      const offset = [0, -24];
      const projectile = new _Projectile.Projectile({
        direction: this.args.direction,
        x: this.args.x + offset[0] + (this.args.xSpeed || this.args.gSpeed),
        y: this.args.y + offset[1],
        owner: this,
        xSpeed: this.args.xSpeed || this.args.gSpeed,
        YSpeed: this.args.YSpeed
      });
      projectile.impulse(6, 1.57 + Math.PI / 4 * 1);
      this.viewport.auras.add(projectile);
      this.viewport.spawn.add({
        object: projectile
      });
    }
  }, {
    key: "effect",
    value: function effect(other) {
      _get(_getPrototypeOf(BuzzBomber.prototype), "effect", this).call(this, other);

      // this.viewport.spawn.add({object:new Flickie({
      // 	x: this.args.x,
      // 	y: this.args.y,
      // })});
    }
  }, {
    key: "wakeUp",
    value: function wakeUp() {
      if (!this.viewport) {
        return;
      }
      const viewport = this.viewport;
      this.sleeping = false;
      this.attack();
    }
  }, {
    key: "attack",
    value: function attack() {
      if (this.sleeping || this.attacking) {
        return;
      }
      if (!this.viewport) {
        return;
      }
      const viewport = this.viewport;
      this.args.direction = -1;
      this.args.facing = 'left';
      this.args.xSpeed = -10;
      this.aiming = false;
      this.attacking = true;
      viewport.onFrameOut(5, () => {
        this.aiming = true;
        viewport.onFrameOut(5, () => {
          let shots = 2;
          const cancelInterval = viewport.onFrameInterval(5, () => {
            this.command_2();
            shots-- || cancelInterval();
          });
        });
      });
      viewport.onFrameOut(50, () => {
        const xSpeed = this.args.xSpeed;
        this.args.xSpeed = 0.5 * -xSpeed;
        viewport.onFrameOut(100, () => {
          this.aiming = false;
          this.attacking = false;
          this.args.xSpeed = 0;
          this.args.ySpeed = 0;
        });
      });
    }
  }, {
    key: "sleep",
    value: function sleep() {
      this.args.x = this.def.get('x');
      this.args.y = this.def.get('y');
      this.onNextFrame(() => {
        if (!this.viewport) {
          return;
        }
        this.args.x = this.def.get('x');
        this.args.y = this.def.get('y');
        this.viewport.setColCell(this);
        this.args.xSpeed = 0;
        this.args.ySpeed = 0;
        this.args.pushed = 0;
        this.args.float = 0;
        this.attacking = false;
        this.sleeping = true;
      });
    }
  }, {
    key: "solid",
    get: function get() {
      return false;
    }
    // get controllable() { return true; }
  }, {
    key: "isEffect",
    get: function get() {
      return false;
    }
  }]);
  return BuzzBomber;
}(_Mixin.Mixin.from(_PointActor.PointActor, _CanPop.CanPop));
exports.BuzzBomber = BuzzBomber;
});

;require.register("actor/Catakiller.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Catakiller = void 0;
var _PointActor = require("./PointActor");
var _Mixin = require("curvature/base/Mixin");
var _CanPop = require("../mixin/CanPop");
var _CatakillerSegment = require("./CatakillerSegment");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let Catakiller = /*#__PURE__*/function (_Mixin$from) {
  _inherits(Catakiller, _Mixin$from);
  var _super = _createSuper(Catakiller);
  function Catakiller(args, parent) {
    var _this;
    _classCallCheck(this, Catakiller);
    _this = _super.call(this, args, parent);
    _this.args.type = 'actor-item actor-catakiller';
    _this.args.width = 16;
    _this.args.height = 24;
    _this.args.phase = 'idle';
    _this.args.scootSpeed = _this.args.scootSpeed || 2;
    _this.args.segments = _this.args.segments || 6;
    _this.args.pauseTime = _this.args.pauseTime || 45;
    _this.args.phaseTime = _this.args.phaseTime || 600;
    _this.segments = [];
    return _this;
  }
  _createClass(Catakiller, [{
    key: "update",
    value: function update() {
      if (this.segments.length < this.args.segments) {
        const segment = new _CatakillerSegment.CatakillerSegment({
          leader: this.segments.length ? this.segments[this.segments.length - 1] : this,
          position: this.segments.length,
          following: true,
          head: this,
          x: this.args.x + 10 * (this.segments.length + 1),
          y: this.args.y,
          z: this.args.z - (this.segments.length + 1)
        });
        this.segments.push(segment);
        this.viewport.spawn.add({
          object: segment
        });
      }
      if (!this.viewport || !this.viewport.actorIsOnScreen(this)) {
        _get(_getPrototypeOf(Catakiller.prototype), "update", this).call(this);
        return;
      }
      const viewport = this.viewport;
      const interval = this.args.phaseTime;
      const half = interval * 0.5;
      const scootInterval = 30;
      const scoot = this.age % scootInterval;
      const direction = this.age % interval < half ? 1 : -1;
      const phase = this.age % half;
      const moveTime = half - this.args.pauseTime;
      if (phase < moveTime) {
        if (scoot > scootInterval * 0.5) {
          this.args.gSpeed = this.args.scootSpeed * direction;
          this.args.animation = 'mouth-open';
          if (Math.round(this.args.gSpeed) !== 0) {
            this.args.facing = this.args.gSpeed > 0 ? 'left' : 'right';
          }
        } else {
          this.args.animation = 'mouth-closed';
          this.args.gSpeed = 0;
        }
      } else {
        this.args.animation = 'mouth-closed';
        this.args.gSpeed = 0;
      }
      _get(_getPrototypeOf(Catakiller.prototype), "update", this).call(this);
    }
  }, {
    key: "pop",
    value: function pop() {
      if (this.segments) {
        this.segments.forEach(s => {
          s.args.popped = true;
          s.args.falling = true;
          s.args.xSpeed = 2 * -Math.sign(this.gSpeedLast) * (s.args.position - this.segments.length / 2);
          s.args.ySpeed = -14;
          if (!s.viewport) {
            return;
          }
          s.viewport.onFrameOut(160, () => s.noClip = true);
        });
      }
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _get(_getPrototypeOf(Catakiller.prototype), "pop", this).call(this, ...args);
    }
  }, {
    key: "solid",
    get: function get() {
      return false;
    }
  }, {
    key: "rotateLock",
    get: function get() {
      return true;
    }
  }]);
  return Catakiller;
}(_Mixin.Mixin.from(_PointActor.PointActor, _CanPop.CanPop));
exports.Catakiller = Catakiller;
});

;require.register("actor/CatakillerSegment.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CatakillerSegment = void 0;
var _PointActor = require("./PointActor");
var _Mixin = require("curvature/base/Mixin");
var _CanPop = require("../mixin/CanPop");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let CatakillerSegment = /*#__PURE__*/function (_Mixin$from) {
  _inherits(CatakillerSegment, _Mixin$from);
  var _super = _createSuper(CatakillerSegment);
  function CatakillerSegment(args, parent) {
    var _this;
    _classCallCheck(this, CatakillerSegment);
    _this = _super.call(this, args, parent);
    _this.args.type = 'actor-item actor-catakiller-segment';
    _this.args.width = 16;
    _this.args.height = 16;
    _this.args.following = _this.args.following || false;
    _this.args.willMove = true;
    _this.args.popped = false;
    _this.args.bounces = 1;
    return _this;
  }
  _createClass(CatakillerSegment, [{
    key: "collideA",
    value: function collideA(other, type) {
      // if(!other.controllable || (this.args.popped && this.args.ySpeed < 0))
      if (!other.controllable || this.args.popped) {
        return;
      }
      if (this.args.position === 0 && this.args.head) {
        this.args.head.collideA(other, type);
      } else {
        other.damage(this);
      }
    }
  }, {
    key: "onRendered",
    value: function onRendered() {
      _get(_getPrototypeOf(CatakillerSegment.prototype), "onRendered", this).call(this);
      if (this.box && this.args.position % 2 === 0) {
        this.autoStyle.get(this.box)['--space'] = 'space';
      }
    }
  }, {
    key: "update",
    value: function update() {
      if (this.args.leader && this.args.head && !this.args.popped) {
        const leaderX = this.args.leader.args.x;
        const space = Math.abs(this.args.x - leaderX);
        let speed = Math.abs(this.args.head.gSpeedLast || 0);
        this.args.space = space;
        if (space < 9.5) {
          this.args.willMove = false;
        } else if (space > 13) {
          this.args.willMove = true;
          // speed *= 1.5;
        }

        if (this.args.willMove) {
          this.args.gSpeed = speed * -Math.sign(this.args.x - leaderX);
        } else {
          this.args.gSpeed = 0;
        }
        if (this.args.gSpeed !== 0) {
          this.args.facing = this.args.gSpeed > 0 ? 'left' : 'right';
        }
        this.args.groundAngle = 0;
      }
      const yLast = this.args.y;
      _get(_getPrototypeOf(CatakillerSegment.prototype), "update", this).call(this);
      if (this.args.popped && this.args.y === yLast) {
        if (this.args.bounces > 0) {
          this.args.ySpeed = -Math.max(this.ySpeedLast || 5);
          this.args.xSpeed = (this.gSpeedLast || this.xSpeedLast || 0) + Math.sign(this.xSpeedLast || 0);
          this.args.falling = true;
          this.args.bounces--;
        } else {
          this.noClip = true;
          this.args.ySpeed = Math.max(this.ySpeedLast || 5);
          this.args.falling = true;
        }
      }
    }
  }, {
    key: "solid",
    get: function get() {
      return false;
    }
  }, {
    key: "rotateLock",
    get: function get() {
      return true;
    }
  }]);
  return CatakillerSegment;
}(_Mixin.Mixin.from(_PointActor.PointActor));
exports.CatakillerSegment = CatakillerSegment;
});

;require.register("actor/CautionPanel.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CautionPanel = void 0;
var _PointActor2 = require("./PointActor");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let CautionPanel = /*#__PURE__*/function (_PointActor) {
  _inherits(CautionPanel, _PointActor);
  var _super = _createSuper(CautionPanel);
  function CautionPanel() {
    var _this;
    _classCallCheck(this, CautionPanel);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.width = 80;
    _this.args.height = 48;
    _this.args.type = 'actor-item actor-caution-panel';
    _this.args.z = 0;
    return _this;
  }
  _createClass(CautionPanel, [{
    key: "solid",
    get: function get() {
      return false;
    }
  }]);
  return CautionPanel;
}(_PointActor2.PointActor);
exports.CautionPanel = CautionPanel;
});

;require.register("actor/CautionSign.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CautionSign = void 0;
var _PointActor2 = require("./PointActor");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let CautionSign = /*#__PURE__*/function (_PointActor) {
  _inherits(CautionSign, _PointActor);
  var _super = _createSuper(CautionSign);
  function CautionSign() {
    var _this;
    _classCallCheck(this, CautionSign);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.width = 20;
    _this.args.height = 60;
    _this.args.type = 'actor-item actor-caution-sign';
    return _this;
  }
  _createClass(CautionSign, [{
    key: "solid",
    get: function get() {
      return false;
    }
  }]);
  return CautionSign;
}(_PointActor2.PointActor);
exports.CautionSign = CautionSign;
});

;require.register("actor/ChainShot.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ChainShot = void 0;
var _PointActor2 = require("./PointActor");
var _Sfx = require("../audio/Sfx");
var _Tag = require("curvature/base/Tag");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let ChainShot = /*#__PURE__*/function (_PointActor) {
  _inherits(ChainShot, _PointActor);
  var _super = _createSuper(ChainShot);
  function ChainShot() {
    var _this;
    _classCallCheck(this, ChainShot);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.width = 16;
    _this.args.height = 128;
    _this.args.type = 'actor-item actor-chain-shot';
    _this.args.float = -1;
    _this.args.shooting = false;
    _this.args.animation = 'idle';
    return _this;
  }
  _createClass(ChainShot, [{
    key: "update",
    value: function update() {
      _get(_getPrototypeOf(ChainShot.prototype), "update", this).call(this);
      if (this.args.animation === 'shooting' && this.viewport.args.frameId % 5 === 0) {
        _Sfx.Sfx.play('CHOPPER_GUN', {});
      }
    }
  }, {
    key: "collideA",
    value: function collideA(other) {
      if (!this.args.shooting || !other.controllable) {
        return;
      }
      other.damage(this);
    }
  }]);
  return ChainShot;
}(_PointActor2.PointActor);
exports.ChainShot = ChainShot;
});

;require.register("actor/Chalmers.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Chalmers = void 0;
var _PointActor2 = require("./PointActor");
var _Tag = require("curvature/base/Tag");
var _SkidDust = require("../behavior/SkidDust");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let Chalmers = /*#__PURE__*/function (_PointActor) {
  _inherits(Chalmers, _PointActor);
  var _super = _createSuper(Chalmers);
  function Chalmers() {
    var _this;
    _classCallCheck(this, Chalmers);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.behaviors.add(new _SkidDust.SkidDust());
    _this.args.type = 'actor-item actor-chalmers';
    _this.args.normalHeight = 45;
    _this.args.rollingHeight = 23;
    _this.args.accel = 0.25;
    _this.args.decel = 0.4;
    _this.args.gSpeedMax = 18;
    _this.args.jumpForce = 11;
    _this.args.gravity = 0.5;
    _this.args.width = 18;
    _this.args.height = 32;
    return _this;
  }
  _createClass(Chalmers, [{
    key: "onRendered",
    value: function onRendered(event) {
      _get(_getPrototypeOf(Chalmers.prototype), "onRendered", this).call(this, event);
      this.box = this.findTag('div');
    }
  }, {
    key: "update",
    value: function update() {
      const falling = this.args.falling;
      if (!this.box) {
        _get(_getPrototypeOf(Chalmers.prototype), "update", this).call(this);
        return;
      }
      if (!falling) {
        if (this.yAxis > 0) {
          this.args.crouching = true;
        } else {
          this.args.crouching = false;
        }
        const direction = this.args.direction;
        const gSpeed = this.args.gSpeed;
        const speed = Math.abs(gSpeed);
        const maxSpeed = this.args.gSpeedMax;
        if (this.args.rolling) {
          this.box.setAttribute('data-animation', 'rolling');
        } else if (Math.sign(this.args.gSpeed) !== direction && Math.abs(this.args.gSpeed - direction) > 5) {
          this.box.setAttribute('data-animation', 'standing');
        } else if (speed > maxSpeed * 0.25) {
          this.box.setAttribute('data-animation', 'running');
        } else if (this.args.moving && gSpeed) {
          this.box.setAttribute('data-animation', 'walking');
        }
        // else if(this.args.crouching || (this.args.standingOn && this.args.standingOn.isVehicle))
        // {
        // 	this.box.setAttribute('data-animation', 'crouching');
        // }
        else {
          this.box.setAttribute('data-animation', 'standing');
        }
      } else if (this.args.standingOn && this.args.standingOn.isVehicle) {
        this.box.setAttribute('data-animation', 'standing');
      } else if (this.args.jumping) {
        this.box.setAttribute('data-animation', 'jumping');
      }
      _get(_getPrototypeOf(Chalmers.prototype), "update", this).call(this);
    }
  }, {
    key: "solid",
    get: function get() {
      return false;
    }
  }, {
    key: "canRoll",
    get: function get() {
      return true;
    }
  }, {
    key: "isEffect",
    get: function get() {
      return false;
    }
  }, {
    key: "controllable",
    get: function get() {
      return true;
    }
  }]);
  return Chalmers;
}(_PointActor2.PointActor);
exports.Chalmers = Chalmers;
});

;require.register("actor/Chao.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Chao = void 0;
var _Png = require("../sprite/Png");
var _PointActor2 = require("./PointActor");
var _Mushroom = require("./Mushroom");
var _Coconut = require("./Coconut");
var _Tree = require("./Tree");
var _Uuid = require("curvature/base/Uuid");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let Chao = /*#__PURE__*/function (_PointActor) {
  _inherits(Chao, _PointActor);
  var _super = _createSuper(Chao);
  function Chao() {
    var _this;
    _classCallCheck(this, Chao);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _defineProperty(_assertThisInitialized(_this), "png", new _Png.Png('/DBurraki/chao-normal.png'));
    _this.args.type = 'actor-item actor-chao';
    _this.args.particleScale = 0.75;
    _this.args.spriteSheet = _this.spriteSheet = '/DBurraki/chao-normal.png';
    _this.args.width = 14;
    _this.args.height = 18;
    _this.args.uuid = args.uuid || String(new _Uuid.Uuid());
    _this.xHold = 8;
    _this.yHold = 0;
    _this.maxFlight = 270;
    _this.emotes = ['normal', 'alert', 'inquire', 'like', 'love', 'angry'];
    _this.emoteIndex = 0;

    // this.animations = ['standing', 'thinking', 'walking', 'flying', 'sitting', 'searching', 'swimming', 'flying'];
    // this.animationIndex = 0;

    _this.args.animation = 'standing';
    _this.args.inWater = false;
    _this.bindTo('carriedBy', carrier => {
      if (_this.cX) {
        _this.cX();
        _this.cX = null;
      }
      if (_this.cY) {
        _this.cY();
        _this.cY = null;
      }
      if (carrier) {
        _this.cX = carrier.args.bindTo('x', v => _this.args.x = v + carrier.args.direction * 8);
        _this.cY = carrier.args.bindTo('y', v => _this.args.y = v + -16);
        carrier.carrying.add(_assertThisInitialized(_this));
        _this.args.float = -1;
        _this.args.groundAngle = 0;
      } else if (_this.carriedBy) {
        const carrier = _this.carriedBy;
        _this.carriedBy = null;
        _this.args.xSpeed = carrier.args.xSpeed;
        _this.args.ySpeed = carrier.args.ySpeed;
        _this.args.xSpeed += Math.sign(carrier.args.gSpeed || carrier.args.xSpeed) * 4;
        _this.args.ySpeed -= 4;
        carrier.carrying.delete(_assertThisInitialized(_this));
        _this.args.falling = true;
        _this.args.float = 0;
      }
    });
    _this.args.direction = 1;
    _this.args.currentState = _this.args.currentState || 'sitting';
    _this.args.bindTo('currentState', () => {
      _this.args.stateTime = 0;
    });
    _this.args.alignment = 'neutral';
    _this.stats = {
      intelligence: 0,
      stamina: 0,
      luck: 0,
      run: 0,
      swim: 0,
      fly: 0,
      power: 0
    };
    _this.traits = {
      appetite: 0,
      sociable: 0,
      restless: 0
    };
    _this.mood = {
      attitude: 0,
      happy: 1,
      hunger: 0,
      health: 1,
      social: 0
    };
    _this.defaultColors = ['addef8', '2ebee9', '0e6d89', 'ecde2f', 'dcb936', '985000', 'f8b0c0', 'f85080', 'e4e0e4', 'e0e0e0', 'f8f820', '606080'];
    _this.customColors = [null, null, null, null, null, null, null, null, null, null, null, null];
    _this.customColors.bindTo(() => {
      const colorMap = {};
      for (const i in _this.defaultColors) {
        var _this$customColors$i;
        colorMap[_this.defaultColors[i]] = (_this$customColors$i = _this.customColors[i]) !== null && _this$customColors$i !== void 0 ? _this$customColors$i : _this.defaultColors[i];
      }
      _this.png.ready.then(() => {
        const customSheet = _this.png.recolor(colorMap).toUrl();
        _this.args.spriteSheet = customSheet;
      });
    }, {
      wait: 0
    });
    _this.chaoAge = 0;
    return _this;
  }
  _createClass(Chao, [{
    key: "onAttached",
    value: function onAttached(event) {
      // super.onRendered(event);

      if (!this.listening) {
        this.box.addEventListener('click', event => this.onClick(event));
        this.box.addEventListener('contextmenu', event => this.onRightClick(event));
        this.listening = true;
      }
      this.setAutoAttr('currentState', 'data-current-state');
      this.setAutoAttr('alignment', 'data-alignment');
      this.setAutoAttr('direction', 'data-direction');
      this.setAutoAttr('emote', 'data-emote');
      const viewport = this.viewport;
      this.onRemove(() => clearInterval(viewport.onInterval(1500, () => {
        if (this.emoteIndex >= this.emotes.length) {
          this.emoteIndex = 0;
        }
        this.args.emote = this.emotes[this.emoteIndex];
        this.emoteIndex++;
        this.onRemove(() => viewport.onTimeout(500, () => {
          this.args.emote = 'normal';
        }));
      })));

      // this.viewport.onInterval(3000, () => {
      // 	if(this.animationIndex >= this.animations.length)
      // 	{
      // 		this.animationIndex = 0;
      // 	}

      // 	this.args.animation = this.animations[this.animationIndex];

      // 	console.log(this.animations[this.animationIndex]);

      // 	this.animationIndex++;
      // });

      const heroColors = {
        'addef8': 'e4e0e4',
        '2ebee9': 'c0bde4',
        '0e6d89': '9c99c0',
        'ecde2f': 'addef8',
        'dcb936': '2ebee9',
        '985000': '0e6d89',
        'ffa3b1': 'ffa3b1',
        'fa6379': 'fa6379',
        'e4e0e4': 'cdeef8',
        'f8f820': '9c99c0'

        // '606080': '606080',
      };

      const darkColors = {
        'addef8': '485070',
        '2ebee9': '303058',
        '0e6d89': '202020',
        'ecde2f': 'b70000',
        'dcb936': '770000',
        '985000': '420000',
        'ffa3b1': 'ffa3b1',
        'fa6379': 'fa6379',
        'e4e0e4': 'e4e0e4',
        'f8f820': 'bf999c',
        '606080': '202020'
      };
      const rubyColors = {
        'addef8': 'ff7575',
        '2ebee9': 'e00000',
        '0e6d89': '800000',
        'ecde2f': 'b70000',
        'dcb936': '770000',
        '985000': '420000',
        'ffa3b1': 'ffa3b1',
        'fa6379': 'fa6379',
        'e4e0e4': 'e4e0e4',
        '606080': '202020'
      };
      const tangyColors = {
        'addef8': 'e08000',
        '2ebee9': 'b76900',
        '0e6d89': '7d4800',
        'ecde2f': 'b44800',
        'dcb936': '844221',
        '985000': '630000',
        'ffa3b1': 'ffa3b1',
        'fa6379': 'fa6379',
        'e4e0e4': 'e4e0e4',
        '606080': '202020'
      };
      const limeColors = {
        'addef8': '80e000',
        '2ebee9': '69b700',
        '0e6d89': '487d00',
        'ecde2f': '48b400',
        'dcb936': '428421',
        '985000': '006300',
        'ffa3b1': 'ffa3b1',
        'fa6379': 'fa6379',
        'e4e0e4': 'e4e0e4',
        '606080': '202020'
      };
      const coalColors = {
        'addef8': '485070',
        '2ebee9': '303058',
        '0e6d89': '202020',
        'ecde2f': 'c0bde4',
        'dcb936': '9c99c0',
        '985000': '606080',
        'ffa3b1': 'ffa3b1',
        'fa6379': 'fa6379',
        'e4e0e4': 'e4e0e4',
        'f8f820': '9c99c0',
        '606080': '202020'
      };
      const mimeColors = {
        'addef8': 'c0bde4',
        '2ebee9': '9c99c0',
        '0e6d89': '606080',
        'ecde2f': '485070',
        'dcb936': '303058',
        '985000': '202020',
        'ffa3b1': 'ffa3b1',
        'fa6379': 'fa6379',
        'e4e0e4': 'e4e0e4',
        'f8f820': '9c99c0',
        '606080': '202020'
      };
      const whiteColors = {
        'addef8': 'c0bde4',
        '2ebee9': '9c99c0',
        '0e6d89': '606080',
        'ecde2f': 'e4e0e4',
        'dcb936': 'c0bde4',
        '985000': '9c99c0',
        'ffa3b1': 'ffa3b1',
        'fa6379': 'fa6379',
        'e4e0e4': 'e4e0e4',
        'f8f820': '9c99c0',
        '606080': '202020'
      };
      const limeRubyColors = {
        'addef8': '80e000',
        '2ebee9': '69b700',
        '0e6d89': '487d00',
        'ecde2f': 'b70000',
        'dcb936': '770000',
        '985000': '420000',
        'ffa3b1': 'ffa3b1',
        'fa6379': 'fa6379',
        'e4e0e4': 'e4e0e4',
        '606080': '202020'
      };
      this.png.ready.then(() => {
        this.heroSheet = this.png.recolor(heroColors).toUrl();
        this.darkSheet = this.png.recolor(darkColors).toUrl();
        this.rubySheet = this.png.recolor(rubyColors).toUrl();
        this.tangySheet = this.png.recolor(tangyColors).toUrl();
        this.limeSheet = this.png.recolor(limeColors).toUrl();
        this.coalSheet = this.png.recolor(coalColors).toUrl();
        this.mimeSheet = this.png.recolor(mimeColors).toUrl();
        this.whiteSheet = this.png.recolor(whiteColors).toUrl();
        this.limeRubySheet = this.png.recolor(limeRubyColors).toUrl();
      });
    }
  }, {
    key: "generate",
    value: function generate() {
      Object.assign(this.stats, {
        intelligence: 0,
        stamina: 0,
        luck: 0,
        run: 0,
        swim: 0,
        fly: 0,
        power: 0
      });
      Object.assign(this.traits, {
        appetite: 0,
        sociable: 0,
        restless: 0
      });
      Object.assign(this.mood, {
        attitude: 0,
        happy: 1,
        hunger: 0,
        health: 1,
        social: 0
      });
    }
  }, {
    key: "lift",
    value: function lift(actor) {
      if (this.carriedBy === actor) {
        this.carriedBy = null;
        this.args.currentState = 'standing';
        return;
      }
      this.carriedBy = actor;
      this.args.currentState = 'held';
    }
  }, {
    key: "solid",
    get: function get() {
      return false;
    }
  }, {
    key: "update",
    value: function update() {
      if (viewport.meta.fieldType === 'garden' && this.chaoAge % 120 === 0) {
        const zoneState = viewport.getZoneState();
        const stored = zoneState.chao.find(c => c.uuid === this.args.uuid);
        if (!stored) {
          zoneState.chao.push(this.store());
        } else {
          Object.assign(stored, this.store());
        }
        viewport.currentSave.save();
      }
      for (const carried of this.carrying) {
        carried.args.x = this.args.x + this.args.direction * this.xHold;
        carried.args.y = this.args.y + this.yHold;
      }
      this.args.inWater = false;
      const floatRegions = [...this.regions].filter(r => r.args.density >= 1);
      if (floatRegions.length) {
        if (this.args.currentState !== 'flying' && this.args.ySpeed >= 0) {
          const floatTarget = floatRegions[0].args.y - floatRegions[0].args.height + 6;
          const snapSpace = 3;
          if (this.args.currentState !== 'walking') {
            this.args.xSpeed = this.args.xSpeed * 0.95;
          }
          if (this.args.y > floatTarget) {
            this.args.falling = true;
            this.args.ySpeed += -0.25;
            this.args.float = -1;
            if (this.args.ySpeed > snapSpace) {
              this.args.ySpeed = snapSpace;
            }
            if (this.args.ySpeed < -snapSpace) {
              this.args.ySpeed = -snapSpace;
            }
          } else {
            if (this.args.ySpeed > 0 && Math.abs(this.args.y - floatTarget) < snapSpace) {
              this.args.y = floatTarget;
            }
            this.args.ySpeed = 0;
            this.args.float = 1;
          }
          this.args.groundAngle = 0;
        }
        this.args.inWater = true;
      } else {
        if (this.args.currentState !== 'flying') {
          this.args.float = 0;
        }
      }
      if (this.mood.hunger < 1) {
        if (this.traits.appetite < 0.333) {
          this.mood.hunger += 0.00002;
        } else if (this.traits.appetite < 0.666) {
          this.mood.hunger += 0.00004;
        } else {
          this.mood.hunger += 0.00006;
        }
      }
      if (this.mood.social < 1) {
        if (this.traits.sociable < 0.333) {
          this.mood.social += 0.0002;
        } else if (this.traits.sociable < 0.666) {
          this.mood.social += 0.0004;
        } else {
          this.mood.social += 0.0006;
        }
      }
      if (!['eating', 'holding'].includes(this.args.currentState)) {
        if (this.carrying.size) {
          this.args.currentState = 'holding';
        }
      }
      const state = String(this.args.currentState).charAt(0).toUpperCase() + String(this.args.currentState).slice(1);
      if (typeof this['state' + state] === 'function') {
        this['state' + state]();
      }
      if (this.mood.hunger < 0.3) {
        this.selectedFood = null;
        this.selectedTree = null;
      }
      if (this.selectedFood && this.selectedFood.carriedBy) {
        this.selectedThing = null;
        this.selectedFood = null;
      }
      if (this.selectedTree && this.selectedTree.args.shaking && this.args.currentState !== 'shakingTree') {
        this.selectedThing = null;
        this.selectedTree = null;
      }
      if (!this.selectedTree || !this.selectedTree.args.shaking) {
        this.args.z = 2;
      }
      _get(_getPrototypeOf(Chao.prototype), "update", this).call(this);
      this.args.stateTime++;
      this.chaoAge++;
    }
  }, {
    key: "collideA",
    value: function collideA(other, type) {
      _get(_getPrototypeOf(Chao.prototype), "collideA", this).call(this, other, type);
      if (this.selectedFriend === other && !this.carriedBy && this.args.currentState !== 'flying') {
        this.args.currentState = 'fun';
      }
      if (other.carriedBy || this.carrying.size) {
        return;
      }
      if (other instanceof _Coconut.Coconut || other instanceof _Mushroom.Mushroom) {
        if (other.args.size && other.args.falling === this.args.falling) {
          other.lift(this);
        }
      }
      if (this.selectedFood === other) {
        this.selectedThing = null;
        this.selectedFood = null;
      }
      if (this.selectedTree === other && Math.abs(this.args.x - other.args.x) < 8 && this.args.y <= other.args.y + 3) {
        this.args.currentState = 'shakingTree';
      }
    }
  }, {
    key: "stateStanding",
    value: function stateStanding() {
      this.args.animation = 'standing';
      if (!this.args.falling) {
        this.args.xSpeed = 0;
        this.args.ySpeed = 0;
      }
      if (this.args.stateTime > 120) {
        this.args.currentState = 'thinking';
      }
    }
  }, {
    key: "stateThinking",
    value: function stateThinking() {
      if (!this.args.falling) {
        this.args.xSpeed = 0;
        this.args.ySpeed = 0;
      }
      this.args.animation = 'thinking';
      if (this.args.stateTime > 60) {
        this.args.currentState = 'searching';
      } else if (this.args.stateTime == 0) {
        this.args.emote = 'inquire';
      }
    }
  }, {
    key: "stateSearching",
    value: function stateSearching() {
      this.args.animation = 'searching';
      this.args.emote = 'inquire';
      if (this.args.stateTime > 90) {
        this.args.emote = 'alert';
      } else {
        this.args.emote = 'inquire';
      }
      if (this.args.stateTime > 120) {
        this.args.direction = Math.sign(Math.random() - 0.5);
        if (this.getMapSolidAt(this.args.x + this.args.direction * 8, this.args.y)) {
          this.args.direction *= -1;
        }
        if (this.mood.hunger > 0.5) {
          this.args.currentState = 'seekingFood';
        } else if (this.mood.social > 0.75) {
          this.args.currentState = 'seekingFriend';
        } else if (Math.random() > 0.15 * this.traits.restless) {
          if (this.args.groundAngle || this.args.inWater) {
            this.args.currentState = 'walking';
          } else {
            this.args.currentState = 'sitting';
          }
        } else {
          this.args.currentState = 'walking';
        }
      }
    }
  }, {
    key: "stateWalking",
    value: function stateWalking() {
      if (this.args.inWater) {
        this.args.animation = 'flying';
      } else {
        this.args.animation = 'walking';
      }
      if (this.args.stateTime < 15) {
        this.args.emote = 'alert';
      } else if (this.args.stateTime === 16) {
        this.args.emote = 'normal';
      }
      if (this.args.inWater) {
        this.args.xSpeed = 1 * this.args.direction;
      } else {
        this.args.gSpeed = 0.01 * this.args.direction;
      }
      if (this.args.stateTime > 40) {
        if (!this.args.inWater && Math.random() > 0.9) {
          this.args.currentState = 'tripping';
        }
        if (!this.selectedThing && Math.random() > 0.95) {
          this.args.currentState = 'flying';
        } else if (this.selectedThing && this.selectedThing.args.y < this.args.y) {
          this.args.currentState = 'flying';
        } else if (!this.selectedThing && Math.random() > 0.98) {
          this.args.currentState = 'searching';
        }
      }
    }
  }, {
    key: "stateTripping",
    value: function stateTripping() {
      this.args.animation = 'tripping';
      if (this.args.stateTime > 10) {
        this.args.gSpeed = 0;
      } else {
        this.args.gSpeed = 1 * this.args.direction;
      }
      if (this.args.stateTime > 20) {
        if (this.args.stateTime < 30 && Math.random() > 0.6) {
          this.args.emote = 'angry';
        }
      } else {
        this.args.emote = 'alert';
      }
      if (this.args.stateTime > 120) {
        this.args.currentState = 'sitting';
      }
    }
  }, {
    key: "stateFlying",
    value: function stateFlying() {
      this.args.animation = 'flying';
      if (this.args.inWater) {
        this.args.y--;
      }
      if (this.args.stateTime === 1) {
        this.flightTime = this.maxFlight / 2 + Math.round(this.maxFlight / 2 * Math.random());
      }
      if (this.args.xSpeed && this.getMapSolidAt(this.args.x + Math.sign(this.args.xSpeed) * 8, this.args.y)) {
        this.args.direction *= -1;
        this.args.xSpeed *= -1;
      }
      if (this.getMapSolidAt(this.args.x, this.args.y + 2)) {
        this.args.falling = true;
        this.args.float = -1;
      }
      if (!this.selectedThing && this.args.stateTime > 120 && this.args.ySpeed < 0) {
        this.args.ySpeed *= 0.4;
      } else if (this.selectedThing && this.args.y < this.selectedThing.args.y - 96) {
        this.args.ySpeed *= 0.4;
      }
      if (this.selectedThing && this.selectedThing.args.y - 32 < this.args.y) {
        if (this.selectedThing && Math.abs(this.selectedThing.args.x - this.args.x) > 32) {
          this.args.direction = Math.sign(this.selectedThing.args.x - this.args.x);
        }
        this.args.xSpeed = 1.25 * this.args.direction;
        if (this.args.ySpeed > -1.5) {
          this.args.ySpeed -= 0.1;
        }
      } else if (this.selectedThing && Math.abs(this.selectedThing.args.x - this.args.x) < 32) {
        this.args.direction = Math.sign(this.selectedThing.args.x - this.args.x);
        this.args.currentState = 'walking';
      }
      if (this.args.stateTime < this.flightTime) {
        this.args.groundAngle = 0;
        if (!this.args.ySpeed || !this.args.falling) {
          if (!this.args.xSpeed && !this.args.gSpeed && !this.selectedThing) {
            this.args.direction = Math.sign(Math.random() - 0.5);
          }
          this.args.falling = true;
          this.args.ySpeed = -1;
          this.args.xSpeed = 1.25 * this.args.direction;
          this.args.float = -1;
        } else if (this.args.ySpeed >= 0) {
          this.args.currentState = 'flying';
        }
      } else if (!this.selectedThing) {
        this.args.currentState = 'thinking';
      }
    }
  }, {
    key: "stateHatching",
    value: function stateHatching() {
      this.stateSitting();
    }
  }, {
    key: "stateSitting",
    value: function stateSitting() {
      this.args.xSpeed = 0;
      if (this.args.inWater) {
        this.args.animation = 'standing';
      } else {
        this.args.animation = 'sitting';
      }
      if (this.args.stateTime > 120) {
        if (this.mood.hunger > 0.5) {
          this.args.currentState = 'seekingFood';
        } else if (this.mood.social > 0.75) {
          this.args.currentState = 'seekingFriend';
        } else if (Math.random() > 0.35 * this.traits.restless) {
          this.args.currentState = 'walking';
        } else {
          this.args.currentState = 'thinking';
        }
      }
    }
  }, {
    key: "stateWaiting",
    value: function stateWaiting() {
      this.args.xSpeed = 0;
      if (Math.trunc(this.args.stateTime / 15) % 2) {
        if (Math.random() < 0.2) {
          this.args.emote = 'inquire';
        } else {
          this.args.emote = 'normal';
        }
      }
      if (this.args.inWater) {
        this.args.animation = 'standing';
      } else {
        this.args.animation = 'sitting';
      }
    }
  }, {
    key: "stateSwimming",
    value: function stateSwimming() {}
  }, {
    key: "stateFlyingLooking",
    value: function stateFlyingLooking() {}
  }, {
    key: "stateHolding",
    value: function stateHolding() {
      if (this.args.stateTime < 60) {
        this.args.animation = 'thinking';
        this.args.emote = 'inquire';
        return;
      }
      for (const carrying of this.carrying) {
        carrying.args.gSpeed = 0;
        carrying.args.xSpeed = 0;
        carrying.args.ySpeed = 0;
        if (carrying instanceof _Coconut.Coconut || carrying instanceof _Mushroom.Mushroom) {
          if (this.mood.hunger > 0.5 || this.mood.hunger > 0.25 && Math.random() < 0.5) {
            this.args.emote = 'love';
            this.args.currentState = 'eating';
            carrying.carriedBy = this;
            carrying.noClip = true;
          } else {
            this.args.currentState = 'walking';
            carrying.noClip = false;
            carrying.carriedBy = null;
            this.carrying.delete(carrying);
            carrying.args.falling = true;
            carrying.args.x = this.args.x;
            carrying.args.y = this.args.y;
            carrying.args.xSpeed = this.args.direction * -3 + Math.random();
            carrying.args.ySpeed = -3 + Math.random();
            carrying.args.float = 0;
            this.ignores.set(carrying, 60);
          }
        }
      }
    }
  }, {
    key: "stateEating",
    value: function stateEating() {
      const eating = new Set();
      for (const carrying of this.carrying) {
        if (carrying instanceof _Coconut.Coconut || carrying instanceof _Mushroom.Mushroom) {
          eating.add(carrying);
        }
      }
      if (!this.args.falling) {
        this.args.ySpeed = 0;
      }
      if (!this.carriedBy) {
        this.args.float = 0;
      } else {
        this.args.float = -1;
      }
      this.args.xSpeed = 0;
      this.args.animation = 'eating';
      this.args.emote = 'love';
      if (this.selectedThing !== this.selectedFriend) {
        this.selectedThing = null;
      }
      this.selectedFood = null;
      this.selectedTree = null;
      if (this.args.stateTime && this.args.stateTime % 75 === 0) {
        for (const e of eating) {
          e.args.size--;
          this.mood.hunger -= e.args.nourishment;
          if (!e.args.size) {
            if (!this.carriedBy) {
              this.args.currentState = 'thinking';
            } else {
              this.args.currentState = 'held';
            }
            e.lift(this);
            this.viewport.actors.remove(e);
          }
        }
      }
    }
  }, {
    key: "stateHeld",
    value: function stateHeld() {
      this.args.falling = false;
      if (this.args.stateTime < 15) {
        this.args.emote = 'like';
      } else if (this.args.stateTime < 60) {
        this.args.emote = 'love';
        this.args.animation = 'walking';
      } else if (this.args.stateTime === 61) {
        this.args.emote = 'normal';
        this.args.animation = 'searching';
      }
    }
  }, {
    key: "stateFun",
    value: function stateFun() {
      const _this$nearestFriend = this.nearestFriend(),
        _this$nearestFriend2 = _slicedToArray(_this$nearestFriend, 2),
        closest = _this$nearestFriend2[0],
        minDist = _this$nearestFriend2[1];
      if (!closest) {
        this.args.currentState = 'searching';
        return;
      }
      const dir = Math.sign(this.args.x - closest.args.x);
      this.args.direction = -dir;
      if (Math.abs(this.args.x - closest.args.x) < 16) {
        this.args.x -= (this.args.x - (closest.args.x + 16 * dir)) * 0.1;
      }
      if (minDist > 25) {
        this.args.currentState = 'searching';
        return;
      }
      if (this.mood.social < 0.5) {
        this.args.direction *= -1;
        this.args.currentState = 'walking';
        this.selectedFriend = null;
        this.selectedThing = null;
        return;
      }
      if (this.args.stateTime < 45) {
        this.args.emote = 'alert';
      } else {
        this.args.emote = 'love';
      }
      this.args.animation = 'walking';
      let factor = 1;
      if (this.selectedThing && this.selectedThing.args.currentState === 'fun') {
        factor = 0.4;
      }
      if (this.traits.sociable < 0.333) {
        this.mood.social -= 0.004 * factor;
      } else if (this.traits.sociable < 0.666) {
        this.mood.social -= 0.003 * factor;
      } else {
        this.mood.social -= 0.002 * factor;
      }
    }
  }, {
    key: "stateSeekingFriend",
    value: function stateSeekingFriend() {
      if (this.viewport.args.frameId % 60 === 0) {
        const _this$nearestFriend3 = this.nearestFriend(),
          _this$nearestFriend4 = _slicedToArray(_this$nearestFriend3, 2),
          closest = _this$nearestFriend4[0],
          minDist = _this$nearestFriend4[1];
        this.selectedThing = closest;
        this.selectedFriend = closest;
        if (!closest) {
          this.args.currentState = 'thinking';
          return;
        }
        this.args.direction = Math.sign(closest.args.x - this.args.x);
        if (closest.args.y < this.args.y) {
          this.args.currentState = 'flying';
        } else {
          this.args.currentState = 'walking';
        }
      }
    }
  }, {
    key: "stateSeekingFood",
    value: function stateSeekingFood() {
      this.selectedFriend = null;
      if (this.viewport.args.frameId % 60 === 0) {
        const _this$nearestFood = this.nearestFood(),
          _this$nearestFood2 = _slicedToArray(_this$nearestFood, 2),
          closest = _this$nearestFood2[0],
          minDist = _this$nearestFood2[1];
        this.selectedThing = closest;
        this.selectedFood = closest;
        if (closest) {
          this.args.direction = Math.sign(closest.args.x - this.args.x);
          if (closest.args.y < this.args.y) {
            this.args.currentState = 'flying';
          } else {
            this.args.currentState = 'walking';
          }
        } else {
          this.selectedThing = null;
          this.selectedFood = null;
          this.args.currentState = 'thinking';
          const _this$nearestTree = this.nearestTree(),
            _this$nearestTree2 = _slicedToArray(_this$nearestTree, 2),
            closest = _this$nearestTree2[0],
            minDist = _this$nearestTree2[1];
          this.selectedThing = closest;
          this.selectedTree = closest;
          if (!closest) {
            this.selectedThing = null;
            this.selectedTree = null;
            this.args.currentState = 'thinking';
            return;
          }
          this.args.direction = Math.sign(closest.args.x - this.args.x);
          if (closest.args.y < this.args.y) {
            this.args.currentState = 'flying';
          } else {
            this.args.currentState = 'walking';
          }
        }
      }
    }
  }, {
    key: "stateShakingTree",
    value: function stateShakingTree() {
      if (!this.selectedTree) {
        this.args.currentState = 'thinking';
        return;
      }
      if (!this.selectedTree.args.coconutCount) {
        this.args.currentState = 'thinking';
        return;
      }
      if (this.args.stateTime % 45 === 0 && Math.random() > 0.75) {
        this.args.selectedThing = null;
        this.args.selectedTree = null;
        this.args.currentState = 'seekingFood';
        this.args.animation = 'standing';
        return;
      }
      const dir = Math.sign(this.args.x - this.selectedTree.args.x);
      this.args.direction = -dir;
      this.args.x = this.selectedTree.args.x + 8 * dir;
      this.args.z = this.selectedTree.args.z - 1;
      this.args.gSpeed = 0;
      this.args.animation = 'shaking';
    }
  }, {
    key: "store",
    value: function store() {
      const frozen = {
        stateTime: this.args.stateTime,
        state: this.args.currentState,
        name: this.args.name,
        colors: this.customColors,
        align: this.args.alignment,
        position: [this.args.x, this.args.y],
        traits: this.traits,
        uuid: this.args.uuid,
        stats: this.stats,
        mood: this.mood,
        age: this.chaoAge
      };
      return frozen;
    }
  }, {
    key: "load",
    value: function load(frozen) {
      var _frozen$name;
      if (typeof frozen === 'string') {
        frozen = JSON.parse(frozen);
      }
      this.args.name = (_frozen$name = frozen.name) !== null && _frozen$name !== void 0 ? _frozen$name : '';
      if (frozen.align) {
        this.args.alignment = frozen.align;
      }
      if (frozen.position) {
        this.args.x = frozen.position[0];
        this.args.y = frozen.position[1];
      }
      if (frozen.state) {
        var _frozen$stateTime;
        this.args.currentState = frozen.state;
        this.args.stateTime = (_frozen$stateTime = frozen.stateTime) !== null && _frozen$stateTime !== void 0 ? _frozen$stateTime : 0;
      }
      if (frozen.uuid) {
        this.args.uuid = frozen.uuid;
      }
      if (frozen.age) {
        this.chaoAge = frozen.age;
      }
      frozen.colors && Object.assign(this.customColors, frozen.colors);
      frozen.traits && Object.assign(this.stats, frozen.traits);
      frozen.stats && Object.assign(this.stats, frozen.stats);
      frozen.mood && Object.assign(this.mood, frozen.mood);
    }
  }, {
    key: "nearestFriend",
    value: function nearestFriend() {
      const actors = this.viewport.nearbyActors(this.args.x, this.args.y);
      let closest = null;
      let minDist = Infinity;
      for (const actor of actors) {
        if (actor === this) {
          continue;
        }

        // if(!(actor instanceof this.constructor) && !actor.controllable)
        if (!(actor instanceof this.constructor)) {
          continue;
        }
        if (actor.args.gSpeed || actor.args.currentState === 'eating') {
          continue;
        }
        const dist = this.distanceTo(actor);
        if (this.canSee(actor) && dist < minDist) {
          closest = actor;
          minDist = dist;
        }
      }
      return [closest, minDist];
    }
  }, {
    key: "nearestFood",
    value: function nearestFood() {
      const actors = this.viewport.nearbyActors(this.args.x, this.args.y);
      let closest = null;
      let minDist = Infinity;
      for (const actor of actors) {
        if (actor === this) {
          continue;
        }
        if (!(actor instanceof _Coconut.Coconut)) {
          continue;
        }
        if (actor.carriedBy) {
          continue;
        }
        const dist = this.distanceTo(actor);
        if (this.canSee(actor) && dist < minDist) {
          closest = actor;
          minDist = dist;
        }
      }
      return [closest, minDist];
    }
  }, {
    key: "nearestTree",
    value: function nearestTree() {
      const actors = this.viewport.nearbyActors(this.args.x, this.args.y);
      let closest = null;
      let minDist = Infinity;
      for (const actor of actors) {
        if (actor === this) {
          continue;
        }
        if (!(actor instanceof _Tree.Tree)) {
          continue;
        }
        if (!actor.args.coconutCount) {
          continue;
        }
        if (actor.args.shaking) {
          continue;
        }
        const dist = this.distanceTo(actor);
        if (this.canSee(actor) && dist < minDist) {
          closest = actor;
          minDist = dist;
        }
      }
      return [closest, minDist];
    }
  }]);
  return Chao;
}(_PointActor2.PointActor);
exports.Chao = Chao;
});

;require.register("actor/ChaoCrate.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ChaoCrate = void 0;
var _BreakableBlock2 = require("./BreakableBlock");
var _Egg = require("./Egg");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let ChaoCrate = /*#__PURE__*/function (_BreakableBlock) {
  _inherits(ChaoCrate, _BreakableBlock);
  var _super = _createSuper(ChaoCrate);
  function ChaoCrate() {
    var _this;
    _classCallCheck(this, ChaoCrate);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.type = 'actor-item actor-breakable-block actor-chao-crate';
    _this.args.width = 60;
    _this.args.height = 60;
    _this.args.static = false;
    _this.args.spriteSheet = '/Sonic/chao-crate.png';

    // this.args.bindTo('spriteSheet', v => console.trace(v));
    return _this;
  }
  _createClass(ChaoCrate, [{
    key: "setTile",
    value: function setTile() {}
  }, {
    key: "sleep",
    value: function sleep() {}
  }, {
    key: "wakeUp",
    value: function wakeUp() {}
  }, {
    key: "collideA",
    value: function collideA(other, type) {
      if (type === 0 && other.controllable) {
        return true;
        // return super.collideA(other, type);
      }

      // if(other.spindashCharge)
      // {
      // 	this.break();
      // 	return true;
      // }

      if (type === -1 && !other.args.gSpeed && !other.args.falling && other.controllable) {
        this.break();
        return false;
      }
      if (type !== 1 && type !== 3 || other.y <= this.y - this.args.height) {
        return true;
      }
      if (other.args.rolling || type === 2) {
        this.break();
        return false;
      }
      if (!this.viewport) {
        return false;
      }
      if (type === -1 || other.args.rolling) {
        return _get(_getPrototypeOf(ChaoCrate.prototype), "collideA", this).call(this, other, type);
      }
      return true;
    }
  }, {
    key: "break",
    value: function _break() {
      if (this.broken) {
        return;
      }
      if (this.viewport.meta.fieldType !== 'garden') {
        // this.viewport.args.inventory.push('/DBurraki/chao-icon.png');
        this.viewport.args.inventory.push({
          points: 10000,
          tallyIcon: '/DBurraki/chao-icon.png',
          icon: '/DBurraki/chao-icon.png',
          id: this.oid
        });
        _get(_getPrototypeOf(ChaoCrate.prototype), "break", this).call(this);
        return;
      }
      for (let i = 0; i < 5; i++) {
        const egg = new _Egg.Egg({
          x: this.x,
          y: this.y - 3
        });
        this.viewport.spawn.add({
          object: egg
        });
        egg.args.falling = true;
        egg.args.xSpeed = (-0.5 + Math.random()) * 6;
        egg.args.ySpeed = -7;
      }
      _get(_getPrototypeOf(ChaoCrate.prototype), "break", this).call(this);
      this.viewport.onTimeout(1000, () => {
        this.viewport && this.viewport.actors.remove(this);
      });
    }
  }]);
  return ChaoCrate;
}(_BreakableBlock2.BreakableBlock);
exports.ChaoCrate = ChaoCrate;
});

;require.register("actor/ChaoDetailer.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ChaoDetailer = void 0;
var _Block2 = require("./Block");
var _Chao = require("./Chao");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let ChaoDetailer = /*#__PURE__*/function (_Block) {
  _inherits(ChaoDetailer, _Block);
  var _super = _createSuper(ChaoDetailer);
  function ChaoDetailer() {
    var _this;
    _classCallCheck(this, ChaoDetailer);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _defineProperty(_assertThisInitialized(_this), "chaoStats", new WeakMap());
    return _this;
  }
  _createClass(ChaoDetailer, [{
    key: "updateEnd",
    value: function updateEnd() {
      let found = false;
      if (this.viewport.collisions.has(this)) for (const _ref of this.viewport.collisions.get(this)) {
        var _ref2 = _slicedToArray(_ref, 2);
        const other = _ref2[0];
        const type = _ref2[1];
        if (type !== 0) {
          continue;
        }
        if (other.args.falling) {
          continue;
        }
        if (!(other instanceof _Chao.Chao)) {
          continue;
        }
        this.viewport.args.quickForm = JSON.stringify({
          name: other.args.name,
          alignment: other.args.alignment
        }, null, 4) + "\n" + JSON.stringify(other.mood, null, 4) + "\n" + JSON.stringify(other.traits, null, 4) + "\n" + JSON.stringify(other.stats, null, 4);
        other.args.currentState = 'waiting';
        found = true;
      }
      if (!found) {
        this.viewport.args.quickForm = null;
      }
      _get(_getPrototypeOf(ChaoDetailer.prototype), "update", this).call(this);
    }
  }]);
  return ChaoDetailer;
}(_Block2.Block);
exports.ChaoDetailer = ChaoDetailer;
});

;require.register("actor/Chopper.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Chopper = void 0;
var _PointActor = require("./PointActor");
var _Tag = require("curvature/base/Tag");
var _Mixin = require("curvature/base/Mixin");
var _Sfx = require("../audio/Sfx");
var _AirBomb = require("./AirBomb");
var _ChainShot = require("./ChainShot");
var _EggCapsule = require("./EggCapsule");
var _SkateBoard = require("./SkateBoard");
var _TitleScreenCard = require("../intro/TitleScreenCard");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let Chopper = /*#__PURE__*/function (_Mixin$from) {
  _inherits(Chopper, _Mixin$from);
  var _super = _createSuper(Chopper);
  function Chopper() {
    var _this;
    _classCallCheck(this, Chopper);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.type = 'actor-item actor-chopper';
    _this.args.width = 80;
    _this.args.height = 48;
    _this.args.gravity = 0.25;
    _this.args.float = -1;
    _this.args.direction = 1;
    _this.exploded = false;
    _this.explosions = new Set();
    _this.contains = new Set();
    _this.args.xSpeed = 8;
    _this.args.ySpeed = 6;
    _this.args.attacker = _this.args.attacker || false;
    _this.args.color = 3; //Math.trunc(8 * Math.random());

    _this.playingSound = false;
    _this.activated = false;
    _this.targetPoint = [0, 0];
    _this.damageTimer = 0;
    if (_this.args.attacker) {
      _this.args.hitPoints = 8;
    }
    _this.bombs = new Set();
    _this.bombCount = 0;
    return _this;
  }
  _createClass(Chopper, [{
    key: "collideA",
    value: function collideA(other, type) {
      if (this.damageTimer || !this.args.attacker) {
        return;
      }
      if (other.args.jumping || other.args.rolling) {
        const avgSpeed = (other.args.xSpeed + this.args.xSpeed) * 0.5;
        _Sfx.Sfx.play('BOSS_DAMAGED');
        this.damageTimer = 30;
        this.args.hitPoints--;
        other.args.xSpeed = avgSpeed;
        other.args.ySpeed *= -1;
        if (other.args.ySpeed > 0) {
          other.args.ySpeed = -3;
        }
        if (this.args.hitPoints <= 0) {
          this.destroy();
          this.noClip = true;
          viewport.onFrameOut(60, () => {
            viewport.actors.remove(this);
            viewport.onFrameOut(60, () => {
              const capsule = new _EggCapsule.EggCapsule({
                x: other.args.x,
                y: other.args.y - 384,
                xSpeed: other.args.gSpeed || other.args.xSpeed
              });
              viewport.spawn.add({
                object: capsule
              });
            });
          });
        } else {
          this.args.xSpeed = 0;
          // this.args.ySpeed = 4;
        }
      }
    }
  }, {
    key: "onRendered",
    value: function onRendered(event) {
      _get(_getPrototypeOf(Chopper.prototype), "onRendered", this).call(this, event);
      this.autoStyle.get(this.box)['--color'] = 'color';
    }
  }, {
    key: "update",
    value: function update() {
      if (this.damageTimer) {
        this.args.type = 'actor-item actor-chopper actor-chopper-damaged';
      } else {
        this.args.type = 'actor-item actor-chopper';
      }
      if (this.args.attacker) {
        if (this.damageTimer > 0) {
          this.damageTimer--;
        }

        // this.attackUpdate();
      } else {
        this.introUpdate();
      }
    }
  }, {
    key: "updateEnd",
    value: function updateEnd() {
      if (this.args.attacker) {
        this.attackUpdate();
      } else {
        _get(_getPrototypeOf(Chopper.prototype), "updateEnd", this).call(this);
        // this.introUpdate();
      }

      for (const bomb of this.bombs) {
        bomb.args.x = this.args.x + bomb.xOffset;
      }
    }
  }, {
    key: "introUpdate",
    value: function introUpdate() {
      if (this.viewport.currentMap !== this.mapUrl) {
        return;
      }
      if (this.viewport.controlActor) {
        this.contains.add(this.viewport.controlActor);
      }
      if (this.viewport.controlActor) {
        const actor = this.viewport.controlActor;

        // this.args.xSpeed += 0.1 * actor.xAxis;
        // this.args.ySpeed += 0.1 * actor.yAxis;
      }

      if (this.args.ySpeed > -4) {
        this.args.ySpeed -= 0.025;
      }
      for (const explosion of this.explosions) {
        explosion.style({
          '--x': this.args.x + explosion.x * this.args.direction,
          '--y': this.args.y
        });
      }
      if (!this.exploded) {
        if (!this.playingSound && this.viewport.args.audio, this.viewport.args.frameId - this.playingSound > 10) {
          this.playingSound = this.viewport.args.frameId;
          _Sfx.Sfx.play('COPTER_SPIN', {});
        }
        for (const actor of this.contains) {
          actor.args.float = -1;
          actor.args.x = this.args.x; // + 24 * this.args.direction;
          actor.args.y = this.args.y;
          actor.args.hidden = true;
          actor.args.xSpeed = this.args.xSpeed;
          actor.args.ySpeed = this.args.ySpeed;
        }
      } else {
        if (this.args.float) {
          _Sfx.Sfx.stop('COPTER_SPIN', false);
          this.viewport.onFrameOut(120, () => _Sfx.Sfx.play('RADIO_CHATTER_1'));
          this.args.float = 0;
        }
        _get(_getPrototypeOf(Chopper.prototype), "update", this).call(this);
        return;
      }
      _get(_getPrototypeOf(Chopper.prototype), "update", this).call(this);
      if (this.viewport && this.age && this.age % 300 === 0) {
        const explosionTag = document.createElement('div');
        explosionTag.classList.add('particle-huge-explosion');
        const explosion = new _Tag.Tag(explosionTag);
        explosion.style({
          '--x': this.args.x + 18 * this.args.direction,
          '--y': this.args.y - 16
        });
        _Sfx.Sfx.play('OBJECT_DESTROYED');
        const viewport = this.viewport;
        this.viewport.onFrameOut(200, () => {
          viewport.actors.remove(this);
        });
        this.viewport.onFrameOut(10, () => {
          this.noClip = true;
          this.args.xSpeed *= 0.50;
          this.args.ySpeed = 2;
          this.args.gravity = 0.35;

          // viewport.actors.remove(this)
          for (const actor of this.contains) {
            actor.args.ySpeed = -12;
            actor.args.xSpeed = 0;
            actor.args.hidden = false;
            actor.args.float = 0;
          }
        });
        this.args.animation = 'exploded';
        explosion.x = +18;
        this.explosions.add(explosion);
        this.exploded = true;
        this.viewport.particles.add(explosion);
        this.viewport.onFrameOut(30, () => {
          viewport.particles.remove(explosion);
          this.explosions.delete(explosion);
        });
        const board = new _SkateBoard.SkateBoard({
          x: this.args.x,
          y: this.args.y,
          ySpeed: -10,
          xSpeed: 4 * Math.sign(this.args.xSpeed),
          groundAngle: Math.PI / 4,
          ignore: -2
        });
        this.viewport.controlActor.args.standingOn = board;
        this.viewport.spawn.add({
          object: board
        });
      }
      if (this.viewport && this.age && this.age % 290 === 0) {
        const explosionTag = document.createElement('div');
        explosionTag.classList.add('particle-huge-explosion');
        const explosion = new _Tag.Tag(explosionTag);
        this.explosions.add(explosion);
        explosion.style({
          '--x': this.args.x + 36 * this.args.direction,
          '--y': this.args.y - 32
        });
        explosion.x = 36;
        _Sfx.Sfx.play('OBJECT_DESTROYED');
        this.viewport.particles.add(explosion);
        this.viewport.onFrameOut(30, () => viewport.particles.remove(explosion));
      }
      if (this.viewport && this.age && this.age % 295 === 0) {
        const explosionTag = document.createElement('div');
        explosionTag.classList.add('particle-huge-explosion');
        const explosion = new _Tag.Tag(explosionTag);
        this.explosions.add(explosion);
        explosion.style({
          '--x': this.args.x + 0 * this.args.direction,
          '--y': this.args.y - 24
        });
        explosion.x = 0;
        _Sfx.Sfx.play('OBJECT_DESTROYED');
        this.viewport.particles.add(explosion);
        this.viewport.onFrameOut(30, () => viewport.particles.remove(explosion));
      }
      this.args.falling = true;
    }
  }, {
    key: "attackUpdate",
    value: function attackUpdate() {
      if (this.args.hitPoints <= 0) {
        this.args.falling = true;
        this.args.float = 0;
        _get(_getPrototypeOf(Chopper.prototype), "update", this).call(this);
        _get(_getPrototypeOf(Chopper.prototype), "updateEnd", this).call(this);
        return;
      }
      this.args.groundAngle = 0;
      const other = this.viewport.controlActor;
      if (!this.playingSound && this.viewport.args.audio, this.viewport.args.frameId - this.playingSound > 10) {
        this.playingSound = this.viewport.args.frameId;
        _Sfx.Sfx.play('COPTER_SPIN', {});
      }
      if (other.args.mode !== 0) {
        _get(_getPrototypeOf(Chopper.prototype), "update", this).call(this);
        _get(_getPrototypeOf(Chopper.prototype), "updateEnd", this).call(this);
        return;
      }
      if (!this.activated) {
        if (other.args.x > this.args.x + 64) {
          const other = this.viewport.controlActor;
          this.args.xSpeed = other.args.gSpeed || other.args.xSpeed;

          // other.cofocused = this;

          this.viewport.auras.add(this);
          this.activated = this.viewport.args.frameId;
        }
        _get(_getPrototypeOf(Chopper.prototype), "update", this).call(this);
        _get(_getPrototypeOf(Chopper.prototype), "updateEnd", this).call(this);
        return;
      }
      if (!this.chainShot) {
        this.chainShot = new _ChainShot.ChainShot();
        this.viewport.spawn.add({
          object: this.chainShot
        });
        this.chainShot.args.x = this.args.x;
        this.chainShot.args.y = this.args.y;
      }
      if (other.dashed) {
        _get(_getPrototypeOf(Chopper.prototype), "update", this).call(this);
        _get(_getPrototypeOf(Chopper.prototype), "updateEnd", this).call(this);
        this.chainShot.args.animation = 'idle';
        return;
      }
      const activeTime = this.viewport.args.frameId - this.activated;
      if (activeTime > 120) {
        if (Math.floor(activeTime / 240) % 2 === 0) {
          this.bombModeUpdate();
        } else {
          this.gunModeUpdate();
        }
      } else {
        this.initModeUpdate();
      }
    }
  }, {
    key: "initModeUpdate",
    value: function initModeUpdate() {
      const other = this.viewport.controlActor;
      if (this.chainShot) {
        this.chainShot.args.animation = 'idle';
      }
      if (!this.viewport || !this.viewport.controlActor || this.damageTimer) {
        if (this.damageTimer) {
          this.args.xSpeed = 0;
          this.args.ySpeed = 0;
        }
        _get(_getPrototypeOf(Chopper.prototype), "update", this).call(this);
        _get(_getPrototypeOf(Chopper.prototype), "updateEnd", this).call(this);
        this.lockPosition();
        return;
      }
      if (Math.abs(other.args.gSpeed) > 4 || other.args.falling) {
        this.targetPoint[0] = other.args.x + (-0 + -Math.min(64, Math.abs(other.args.gSpeed * 4))) * Math.sign(other.args.gSpeed);
        this.targetPoint[1] = other.args.y + -128;
      }
      let factor = 1;
      if (other.args.x < this.args.x) {
        this.args.facing = 'left';
      } else {
        this.args.facing = 'right';
      }
      this.args.xSpeed = factor * Math.min(25, Math.abs(0.35 * (this.args.x - this.targetPoint[0]))) * -Math.sign(this.args.x - this.targetPoint[0]);
      this.args.ySpeed = factor * Math.min(25, Math.abs(0.10 * (this.args.y - this.targetPoint[1]))) * -Math.sign(this.args.y - this.targetPoint[1]);
      this.args.falling = true;
      this.args.direction = this.args.facing === 'left' ? -1 : 1;
      _get(_getPrototypeOf(Chopper.prototype), "update", this).call(this);
      _get(_getPrototypeOf(Chopper.prototype), "updateEnd", this).call(this);
      this.lockPosition();
    }
  }, {
    key: "gunModeUpdate",
    value: function gunModeUpdate() {
      const other = this.viewport.controlActor;
      if (other.args.dead) {
        this.args.xSpeed = 0;
        this.args.ySpeed = 0;
        _get(_getPrototypeOf(Chopper.prototype), "update", this).call(this);
        _get(_getPrototypeOf(Chopper.prototype), "updateEnd", this).call(this);
        this.fireChaingun();
        this.chainShot.args.animation = 'shooting';
        return;
      }
      if (!this.viewport || !this.viewport.controlActor || this.damageTimer) {
        if (this.damageTimer) {
          this.args.xSpeed = 0;
          this.args.ySpeed = 0;
          this.chainShot.args.animation = 'idle';
        }
        _get(_getPrototypeOf(Chopper.prototype), "update", this).call(this);
        _get(_getPrototypeOf(Chopper.prototype), "updateEnd", this).call(this);
        this.lockPosition();
        // this.fireChaingun();
        this.chainShot.args.animation = 'idle';
        return;
      }
      if (Math.abs(other.args.gSpeed) > 4 || other.args.falling) {
        this.targetPoint[0] = other.args.x + (-96 + -Math.min(64, Math.abs(other.args.gSpeed * 4))) * Math.sign(other.args.gSpeed);
        this.targetPoint[1] = other.args.y + (-40 + -Math.min(0, Math.abs(other.args.gSpeed)));
      }
      let factor = 1;
      if (other.args.jumping && Math.abs(other.args.xSpeed) < 15 && Math.sign(other.args.xSpeed) === Math.sign(this.args.x - other.args.x)) {
        console.log(Math.sign(other.args.xSpeed), Math.sign(this.args.x - other.args.x));
        factor = 0.25;
      }
      if (other.args.x < this.args.x) {
        this.args.facing = 'left';
      } else {
        this.args.facing = 'right';
      }
      this.args.xSpeed = factor * Math.min(25, Math.abs(0.35 * (this.args.x - this.targetPoint[0]))) * -Math.sign(this.args.x - this.targetPoint[0]);
      this.args.ySpeed = factor * Math.min(25, Math.abs(0.20 * (this.args.y - this.targetPoint[1]))) * -Math.sign(this.args.y - this.targetPoint[1]);
      this.args.falling = true;
      this.args.direction = this.args.facing === 'left' ? -1 : 1;
      _get(_getPrototypeOf(Chopper.prototype), "update", this).call(this);
      _get(_getPrototypeOf(Chopper.prototype), "updateEnd", this).call(this);
      this.lockPosition();
      if (Math.abs(other.args.y - this.args.y) < 48 && !other.args.falling) {
        this.fireChaingun();
        this.chainShot.args.animation = 'shooting';
      } else {
        this.chainShot.args.animation = 'idle';
      }
    }
  }, {
    key: "bombModeUpdate",
    value: function bombModeUpdate() {
      const other = this.viewport.controlActor;
      if (this.chainShot) {
        this.chainShot.args.animation = 'idle';
      }
      if (!this.viewport || !this.viewport.controlActor || this.damageTimer) {
        if (this.damageTimer) {
          this.args.xSpeed = 0;
          this.args.ySpeed = 0;
        }
        _get(_getPrototypeOf(Chopper.prototype), "update", this).call(this);
        _get(_getPrototypeOf(Chopper.prototype), "updateEnd", this).call(this);
        this.lockPosition();
        return;
      }
      if (Math.abs(other.args.gSpeed) > 4 || other.args.falling) {
        this.targetPoint[0] = other.args.x + (-0 + -Math.min(64, Math.abs(other.args.gSpeed * 4))) * Math.sign(other.args.gSpeed);
        this.targetPoint[1] = other.args.y + -128;
      }
      let factor = 1;
      if (other.args.x < this.args.x) {
        this.args.facing = 'left';
      } else {
        this.args.facing = 'right';
      }
      this.args.xSpeed = factor * Math.min(25, Math.abs(0.35 * (this.args.x - this.targetPoint[0]))) * -Math.sign(this.args.x - this.targetPoint[0]);
      this.args.ySpeed = factor * Math.min(25, Math.abs(0.10 * (this.args.y - this.targetPoint[1]))) * -Math.sign(this.args.y - this.targetPoint[1]);
      this.args.falling = true;
      if (this.viewport.args.frameId % 30 === 0) {
        const offset = 16 * Math.sign(this.args.direction) + (-0.5 + this.bombCount % 2) * 16;
        const bomb = new _AirBomb.AirBomb({
          x: this.args.x + offset,
          y: this.args.y,
          xSpeed: this.args.xSpeed,
          ySpeed: this.args.ySpeed
        });
        this.bombCount++;
        bomb.xOffset = offset;
        this.bombs.add(bomb);
        this.viewport.spawn.add({
          object: bomb
        });
      }
      this.args.direction = this.args.facing === 'left' ? -1 : 1;
      _get(_getPrototypeOf(Chopper.prototype), "update", this).call(this);
      _get(_getPrototypeOf(Chopper.prototype), "updateEnd", this).call(this);
      this.lockPosition();
    }
  }, {
    key: "fireChaingun",
    value: function fireChaingun() {
      this.args.direction = this.args.direction || Math.sign(this.xSpeedLast);
      const shotX = 56 * Math.sign(this.args.direction);
      const shotY = 0;
      this.chainShot.args.x = this.args.x + shotX;
      this.chainShot.args.y = this.args.y + shotY;
      this.chainShot.args.xSpeed = this.args.xSpeed;
      this.chainShot.args.ySpeed = this.args.ySpeed;
      this.viewport.setColCell(this.chainShot);
      if (this.args.direction > 0) {
        this.chainShot.args.groundAngle = Math.PI * -0.65;
      } else {
        this.chainShot.args.groundAngle = Math.PI * 0.65;
      }
      this.chainShot.args.shooting = true;
      const length = this.chainShot.castRayQuick(786, -Math.PI * 0.5 - this.chainShot.args.groundAngle);
      this.chainShot.args.shooting = false;
      this.chainShot.args.height = length || 786;
    }
  }, {
    key: "lockPosition",
    value: function lockPosition() {
      {
        const diff = this.args.x - this.targetPoint[0];
        const dist = Math.abs(diff);
        const sign = Math.sign(diff);
        if (dist > 386) {
          this.args.x = this.targetPoint[0] + 386 * sign;
        }
      }
      {
        const diff = this.args.y - this.targetPoint[1];
        const dist = Math.abs(diff);
        const sign = Math.sign(diff);
        if (dist > 386) {
          this.args.y = this.targetPoint[1] + 386 * sign;
        }
      }
    }
  }, {
    key: "destroy",
    value: function destroy() {
      const viewport = this.viewport;
      _Sfx.Sfx.stop('COPTER_SPIN', false);
      viewport.onFrameOut(20, () => {
        const explosionTag = document.createElement('div');
        explosionTag.classList.add('particle-huge-explosion');
        const explosion = new _Tag.Tag(explosionTag);
        explosion.style({
          '--x': this.args.x + 18 * this.args.direction,
          '--y': this.args.y - 16
        });
        _Sfx.Sfx.play('OBJECT_DESTROYED');

        // this.noClip = true;

        this.args.animation = 'exploded';
        explosion.x = +18;
        this.explosions.add(explosion);
        this.exploded = true;
        viewport.particles.add(explosion);
        viewport.onFrameOut(30, () => {
          viewport.particles.remove(explosion);
          this.explosions.delete(explosion);
        });
        const other = viewport.controlActor;
        other.cofocused = null;
      });
      viewport.onFrameOut(0, () => {
        const explosionTag = document.createElement('div');
        explosionTag.classList.add('particle-huge-explosion');
        const explosion = new _Tag.Tag(explosionTag);
        this.explosions.add(explosion);
        explosion.style({
          '--x': this.args.x + 36 * this.args.direction,
          '--y': this.args.y - 32
        });
        explosion.x = 36;
        _Sfx.Sfx.play('OBJECT_DESTROYED');
        viewport.particles.add(explosion);
        viewport.onFrameOut(30, () => viewport.particles.remove(explosion));
      });
      viewport.onFrameOut(10, () => {
        const explosionTag = document.createElement('div');
        explosionTag.classList.add('particle-huge-explosion');
        const explosion = new _Tag.Tag(explosionTag);
        this.explosions.add(explosion);
        explosion.style({
          '--x': this.args.x + 0 * this.args.direction,
          '--y': this.args.y - 24
        });
        explosion.x = 0;
        _Sfx.Sfx.play('OBJECT_DESTROYED');
        viewport.particles.add(explosion);
        viewport.onFrameOut(30, () => viewport.particles.remove(explosion));
      });
    }
  }]);
  return Chopper;
}(_Mixin.Mixin.from(_PointActor.PointActor));
exports.Chopper = Chopper;
});

;require.register("actor/Cinematic.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Cinematic = void 0;
var _PointActor2 = require("./PointActor");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let Cinematic = /*#__PURE__*/function (_PointActor) {
  _inherits(Cinematic, _PointActor);
  var _super = _createSuper(Cinematic);
  function Cinematic(args, parent) {
    var _this;
    _classCallCheck(this, Cinematic);
    _this = _super.call(this, args, parent);
    _defineProperty(_assertThisInitialized(_this), "noClip", true);
    _defineProperty(_assertThisInitialized(_this), "panSpeed", 9);
    _this.args.isGhost = true;
    _this.args.float = -1;
    _this.target = null;
    _this.targets = [[250, 6500], [5900, 6600], [250, 6500], [7700, 7800], [6800, 4200], [6800, 4200], [8000, 4300], [1450, 1800]];
    return _this;
  }
  _createClass(Cinematic, [{
    key: "setCameraMode",
    value: function setCameraMode() {
      this.args.cameraMode = 'cinematic';
    }
  }, {
    key: "update",
    value: function update() {
      _get(_getPrototypeOf(Cinematic.prototype), "update", this).call(this);
      if (!this.args.selected) {
        return;
      }
      if (!this.target || this.x === this.target[0] && this.y === this.target[1]) {
        if (!this.targets.length) {
          this.remove();
        }
        this.target = this.targets.shift();
        return;
      }
      const target = this.target;
      if (this.x !== target[0]) {
        const space = target[0] - this.x;
        this.args.x += Math.sign(space) * this.panSpeed;
        if (Math.abs(space) < this.panSpeed) {
          this.args.x = target[0];
        }
      }
      if (this.y !== target[1]) {
        const space = target[1] - this.y;
        this.args.y += Math.sign(space) * this.panSpeed;
        if (Math.abs(space) < this.panSpeed) {
          this.args.y = target[1];
        }
      }
    }
  }, {
    key: "controllable",
    get: function get() {
      return true;
    }
  }]);
  return Cinematic;
}(_PointActor2.PointActor);
exports.Cinematic = Cinematic;
});

;require.register("actor/Coconut.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Coconut = void 0;
var _PointActor2 = require("./PointActor");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let Coconut = /*#__PURE__*/function (_PointActor) {
  _inherits(Coconut, _PointActor);
  var _super = _createSuper(Coconut);
  function Coconut() {
    var _this;
    _classCallCheck(this, Coconut);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.type = 'actor-item actor-coconut';
    _this.args.width = 12;
    _this.args.height = 13;
    _this.args.size = 4;
    _this.args.nourishment = 0.05;
    _this.bindTo('carriedBy', carrier => {
      if (_this.cX) {
        _this.cX();
        _this.cX = null;
      }
      if (_this.cY) {
        _this.cY();
        _this.cY = null;
      }
      if (_this.carriedBy) {
        const carrier = _this.carriedBy;
        _this.carriedBy = null;
        _this.args.xSpeed = carrier.args.xSpeed;
        _this.args.ySpeed = carrier.args.falling ? carrier.args.ySpeed : 0;
        _this.args.xSpeed += Math.sign(carrier.args.gSpeed || carrier.args.xSpeed) * 4;
        _this.args.ySpeed -= 4;
        carrier.carrying.delete(_assertThisInitialized(_this));
        _this.args.falling = true;
        _this.args.float = 0;
      }
      if (carrier) {
        _this.cX = carrier.args.bindTo('x', v => _this.args.x = v + carrier.args.direction * carrier.xHold);
        _this.cY = carrier.args.bindTo('y', v => _this.args.y = v + -carrier.yHold);
        _this.args.xSpeed = 0;
        _this.args.ySpeed = 0;
        carrier.carrying.add(_assertThisInitialized(_this));
        _this.args.float = -1;
      }
    });
    return _this;
  }
  _createClass(Coconut, [{
    key: "onRendered",
    value: function onRendered(event) {
      _get(_getPrototypeOf(Coconut.prototype), "onRendered", this).call(this, event);
      this.autoStyle.get(this.box)['--size'] = 'size';
    }
  }, {
    key: "lift",
    value: function lift(actor) {
      if (this.carriedBy === actor) {
        this.carriedBy = null;
        return;
      }
      this.carriedBy = actor;
    }
  }, {
    key: "solid",
    get: function get() {
      return false;
    }
  }, {
    key: "rotateLock",
    get: function get() {
      return true;
    }
  }, {
    key: "sleep",
    value: function sleep() {
      if (this.carriedBy) {
        return;
      }
      if (!this.viewport) {
        return;
      }
      this.viewport.actors.remove(this);
    }
  }]);
  return Coconut;
}(_PointActor2.PointActor);
exports.Coconut = Coconut;
});

;require.register("actor/Coin.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Coin = void 0;
var _PointActor2 = require("./PointActor");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let Coin = /*#__PURE__*/function (_PointActor) {
  _inherits(Coin, _PointActor);
  var _super = _createSuper(Coin);
  function Coin() {
    var _this;
    _classCallCheck(this, Coin);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _defineProperty(_assertThisInitialized(_this), "float", -1);
    _this.args.type = 'actor-item actor-coin';
    _this.args.width = 32;
    _this.args.height = 32;
    _this.args.gone = false;
    return _this;
  }
  _createClass(Coin, [{
    key: "update",
    value: function update() {
      _get(_getPrototypeOf(Coin.prototype), "update", this).call(this);
      if (this.viewport.args.audio && !this.sample) {
        this.sample = new Audio('/mario/smw_coin.wav');
        this.sample.volume = 1;
      }
    }
  }, {
    key: "collideA",
    value: function collideA(other) {
      _get(_getPrototypeOf(Coin.prototype), "collideA", this).call(this, other);
      if (this.args.gone) {
        return;
      }
      this.args.type = 'actor-item actor-coin collected';
      if (!this.args.gone) {
        if (this.viewport.args.audio && this.sample) {
          this.sample.play();
        }
        this.viewport.onFrameOut(40, () => {
          this.args.type = 'actor-item actor-coin collected gone';
        });
        this.viewport.onFrameOut(80, () => {
          this.viewport.actors.remove(this);
          this.remove();
        });
        const x = this.x;
        const y = this.y;

        // const viewport = this.viewport;

        // viewport.spawn.add({
        // 	time: Date.now() + 7500
        // 	, frame:  this.viewport.args.frameId + 450
        // 	, object: new Coin({x,y})
        // });

        if (other.args.owner) {
          other.args.owner.args.coins += 1;
        } else if (other.occupant) {
          other.occupant.args.coins += 1;
        } else {
          other.args.coins += 1;
        }
      }
      this.args.gone = true;
    }
  }, {
    key: "solid",
    get: function get() {
      return false;
    }
  }, {
    key: "isEffect",
    get: function get() {
      return true;
    }
  }]);
  return Coin;
}(_PointActor2.PointActor);
exports.Coin = Coin;
});

;require.register("actor/CompanionBlock.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CompanionBlock = void 0;
var _MarbleBlock2 = require("./MarbleBlock");
var _LavaRegion = require("../region/LavaRegion");
var _Sfx = require("../audio/Sfx");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let CompanionBlock = /*#__PURE__*/function (_MarbleBlock) {
  _inherits(CompanionBlock, _MarbleBlock);
  var _super = _createSuper(CompanionBlock);
  function CompanionBlock() {
    var _this;
    let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    _classCallCheck(this, CompanionBlock);
    _this = _super.call(this, args);
    _this.args.type = 'actor-item actor-marble-companion-block';
    _this.played = false;
    _this.args.density = _this.args.density || 10;
    return _this;
  }
  _createClass(CompanionBlock, [{
    key: "collideA",
    value: function collideA(other, type) {
      if (this.args.falling && other.y > 8 + this.y + -this.args.height) {
        // return false;
      } else if (this.args.falling && other.y > this.y - this.args.height) {
        // other.args.y = this.y - this.args.height
      } else if (this.args.falling && other.args.modeTime < 3) {
        other.args.gSpeed = 0;
      }
      return _get(_getPrototypeOf(CompanionBlock.prototype), "collideA", this).call(this, other, type);
    }
  }, {
    key: "update",
    value: function update() {
      const preX = this.args.x;
      let isInLava = false;
      const regions = this.viewport.regionsAtPoint(this.args.x, this.args.y);
      let localDensity = 0,
        denseRegion = null;
      for (const region of regions) {
        if (region.args.density > localDensity) {
          localDensity = region.args.density;
          denseRegion = region;
        }
        this.args.y = Math.round(this.args.y);
        if (region instanceof _LavaRegion.LavaRegion) {
          isInLava = true;

          // if(this.args.height > 18)
          // {
          // 	this.args.height = 18;
          // }

          if (!this.played) {
            this.args.type = 'actor-item actor-marble-companion-block actor-marble-companion-block-dying';
            this.viewport.onFrameOut(80, () => {
              this.args.type = 'actor-item actor-marble-companion-block actor-marble-companion-block-dead';
              _Sfx.Sfx.play('PLAYER_DAMAGED');
            });
            if (typeof ga === 'function') {
              ga('send', 'event', {
                eventCategory: 'companion-block',
                eventAction: 'pushed',
                eventLabel: `${this.viewport.args.actName}::${this.args.id}`
              });
            }
            this.played = true;
          }
        }
      }
      if (denseRegion && localDensity && this.args.density) {
        const thisBottom = this.args.y;
        const regionTop = denseRegion.args.y + -denseRegion.args.height;
        const yDiff = Math.min(this.args.height, thisBottom - regionTop);
        const pressure = this.args.gravity * (localDensity / this.args.density) * (yDiff / this.args.height);
        this.args.ySpeed -= pressure;
        if (!this.args.falling) {
          this.args.y--;
          this.args.falling = true;
        }
      }
      _get(_getPrototypeOf(CompanionBlock.prototype), "update", this).call(this);
      if (isInLava) {
        if (this.fallTime < 100) {
          this.args.xSpeed = 0;
        } else {
          this.args.xSpeed = Math.sign(this.gSpeedLast || this.xSpeedLast);
        }
      }
    }
  }, {
    key: "sleep",
    value: function sleep() {
      this.args.x = this.def.get('x');
      this.args.y = this.def.get('y');
      this.onNextFrame(() => {
        this.args.x = this.def.get('x');
        this.args.y = this.def.get('y');
        this.viewport.setColCell(this);
        this.args.xSpeed = 0;
        this.args.ySpeed = 0;
        this.args.pushed = 0;
        this.args.float = 0;
      });
    }
  }]);
  return CompanionBlock;
}(_MarbleBlock2.MarbleBlock);
exports.CompanionBlock = CompanionBlock;
});

;require.register("actor/Cone.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Cone = void 0;
var _PointActor2 = require("./PointActor");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let Cone = /*#__PURE__*/function (_PointActor) {
  _inherits(Cone, _PointActor);
  var _super = _createSuper(Cone);
  function Cone() {
    var _this;
    _classCallCheck(this, Cone);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.width = 16;
    _this.args.height = 32;
    _this.args.type = 'actor-item actor-cone';
    return _this;
  }
  _createClass(Cone, [{
    key: "solid",
    get: function get() {
      return false;
    }
  }]);
  return Cone;
}(_PointActor2.PointActor);
exports.Cone = Cone;
});

;require.register("actor/CrabMeat.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CrabMeat = void 0;
var _Flickie = require("./Flickie");
var _Mixin = require("curvature/base/Mixin");
var _Tag = require("curvature/base/Tag");
var _PointActor = require("./PointActor");
var _SkidDust = require("../behavior/SkidDust");
var _Patrol = require("../behavior/Patrol");
var _CanPop = require("../mixin/CanPop");
var _Explosion = require("../actor/Explosion");
var _Projectile = require("../actor/Projectile");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let CrabMeat = /*#__PURE__*/function (_Mixin$from) {
  _inherits(CrabMeat, _Mixin$from);
  var _super = _createSuper(CrabMeat);
  function CrabMeat() {
    var _this;
    _classCallCheck(this, CrabMeat);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.behaviors.add(new _SkidDust.SkidDust());
    _this.behaviors.add(new _Patrol.Patrol());
    _this.args.type = 'actor-item actor-crabmeat';
    _this.args.animation = 'standing';
    _this.args.accel = 0.1;
    _this.args.decel = 0.5;
    _this.args.gSpeedMax = 5;
    _this.args.jumpForce = 5;
    _this.args.gravity = 0.5;
    _this.args.width = 32;
    _this.args.height = 32;
    _this.willStick = false;
    _this.stayStuck = false;
    _this.args.patrolBeat = _this.args.patrolBeat || 90;
    _this.args.patrolPause = _this.args.patrolPause || 25;
    _this.args.patrolSpeed = _this.args.patrolSpeed || 0.25;
    _this.args.shotTelegraph = _this.args.shotTelegraph || 65;
    return _this;
  }
  _createClass(CrabMeat, [{
    key: "update",
    value: function update() {
      const direction = this.args.direction;
      _get(_getPrototypeOf(CrabMeat.prototype), "update", this).call(this);
      const telegraph = this.args.shotTelegraph;
      const beat = this.args.patrolBeat;
      if (this.box) {
        if (Math.sign(this.args.gSpeed) !== direction && Math.abs(this.args.gSpeed - direction) > 5) {
          this.box.setAttribute('data-animation', 'skidding');
        } else if (this.args.moving && this.args.gSpeed) {
          this.box.setAttribute('data-animation', 'walking');
        } else if (this.age % beat < telegraph || this.age % beat > beat - 15) {
          this.box.setAttribute('data-animation', 'shooting');
        } else {
          this.box.setAttribute('data-animation', 'standing');
        }
      }
      if (this.age % beat === beat - 3) {
        const xA = this.x + 19;
        const xB = this.x + -19;
        const y = this.y + -19;
        const z = -1;
        const xSpeed = -1.5;
        const ySpeed = -3;
        const owner = this;
        const ballA = new _Projectile.Projectile({
          x: xA,
          y: y,
          z: z,
          owner: owner
        });
        const ballB = new _Projectile.Projectile({
          x: xB,
          y: y,
          z: z,
          owner: owner
        });
        this.viewport.onFrameOut(3, () => {
          Object.assign(ballA.args, {
            xSpeed: -xSpeed,
            ySpeed: ySpeed
          });
          Object.assign(ballB.args, {
            xSpeed: xSpeed,
            ySpeed: ySpeed
          });
        });
        this.viewport.spawn.add({
          object: ballA
        });
        this.viewport.spawn.add({
          object: ballB
        });
      }
    }
  }, {
    key: "effect",
    value: function effect(other) {
      _get(_getPrototypeOf(CrabMeat.prototype), "effect", this).call(this, other);

      // this.viewport.spawn.add({object:new Flickie({
      // 	x: this.args.x,
      // 	y: this.args.y,
      // })});
    }
  }, {
    key: "solid",
    get: function get() {
      return false;
    }
  }, {
    key: "isEffect",
    get: function get() {
      return false;
    }
    // get controllable() { return true; }
  }]);
  return CrabMeat;
}(_Mixin.Mixin.from(_PointActor.PointActor, _CanPop.CanPop));
exports.CrabMeat = CrabMeat;
});

;require.register("actor/CrossCannon.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CrossCannon = void 0;
var _PointActor2 = require("./PointActor");
var _Tag = require("curvature/base/Tag");
var _Sfx = require("../audio/Sfx");
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let CrossCannon = /*#__PURE__*/function (_PointActor) {
  _inherits(CrossCannon, _PointActor);
  var _super = _createSuper(CrossCannon);
  function CrossCannon() {
    var _this;
    _classCallCheck(this, CrossCannon);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.width = 48;
    _this.args.height = 40;
    _this.args.type = 'actor-item actor-cross-cannon';
    _this.args.float = -1;
    _this.args.power = _this.args.power || 20;
    _this.holding = new Map();
    _this.args.spinTime = 0;
    _this.args.minHold = 9;
    _this.args.grabbing = null;
    return _this;
  }
  _createClass(CrossCannon, [{
    key: "onRendered",
    value: function onRendered(event) {
      _get(_getPrototypeOf(CrossCannon.prototype), "onRendered", this).call(this, event);
      this.autoAttr.get(this.box)['data-firing'] = 'firing';
      this.autoAttr.get(this.box)['data-aiming'] = 'aiming';
      this.autoAttr.get(this.box)['data-grabbing'] = 'grabbing';
      if (!this.barrelUp) {
        this.barrelUp = new _Tag.Tag(`<div class = "barrel barrel-up">`);
        this.box.appendChild(this.barrelUp.node);
      }
      if (!this.barrelDown) {
        this.barrelDown = new _Tag.Tag(`<div class = "barrel barrel-down">`);
        this.box.appendChild(this.barrelDown.node);
      }
      if (!this.barrelLeft) {
        this.barrelLeft = new _Tag.Tag(`<div class = "barrel barrel-left">`);
        this.box.appendChild(this.barrelLeft.node);
      }
      if (!this.barrelRight) {
        this.barrelRight = new _Tag.Tag(`<div class = "barrel barrel-right">`);
        this.box.appendChild(this.barrelRight.node);
      }
    }
  }, {
    key: "collideA",
    value: function collideA(other, type) {
      if (!other.controllable) {
        return;
      }
      if (other.isVehicle) {
        other = other.occupant;
      }
      if (this.holding.has(other)) {
        return false;
      }
      const x = other.args.x;
      const y = other.args.y;
      if (!other.args.falling) {
        other.args.falling = true;
        other.args.float = 1;
        other.args.y -= 1;
      }
      if (other.args.standingOn) {
        other.args.standingOn = null;
      }
      _Sfx.Sfx.play('SS_BWIP');
      if (type === -1 || type % 2 === 0) {
        const xDiff = Math.abs(other.args.x - this.args.x);
        this.holding.set(other, this.viewport.args.frameId);
        other.args.xSpeed = 0;
        other.args.ySpeed = 0;
        other.args.float = -1;
        other.args.ignore = -1;
        return false;
      }
      return true;
    }
  }, {
    key: "dropDelay",
    value: function dropDelay(other) {
      let waitFor = false;
      if (this.args.waitFor) {
        waitFor = this.viewport.actorsById[this.args.waitFor];
      }
      if (!waitFor) {
        return new Promise(accept => this.viewport.onFrameOut(240, () => accept()));
      }
      return waitFor.dropDelay(other);
    }
  }, {
    key: "update",
    value: function update() {
      _get(_getPrototypeOf(CrossCannon.prototype), "update", this).call(this);
      if (!this.holding.size) {
        this.args.spinTime = 0;
      }
      for (const _ref of this.holding) {
        var _ref2 = _slicedToArray(_ref, 2);
        const other = _ref2[0];
        const caughtAt = _ref2[1];
        const toX = this.args.x + -4;
        const toY = -6 + this.args.y;
        const stepX = (toX + -other.args.x) / 6;
        const stepY = (toY + -other.args.y) / 6;
        const holdTime = this.viewport.args.frameId - caughtAt;
        other.args.animation = 'jumping';
        if (Math.abs(other.args.y - toY) < stepY) {
          other.args.y = toY;
        } else {
          other.args.y += stepY;
        }
        if (Math.abs(other.args.x - toX) < stepX) {
          other.args.x = toX;
        } else {
          other.args.x += stepX;
        }
        other.args.groundAngle += -other.args.groundAngle * 0.05;
        if (holdTime < 5) {
          this.args.grabbing = 'grabbing';
        } else if (holdTime < 10) {
          this.args.grabbing = 'grabbed';
        } else {
          this.args.grabbing = null;
        }
        if (holdTime > 100) {
          // other.args.float  = 0;
          // other.args.ignore = 1;
          // this.ignores.set(other, 16);
          // this.holding.delete(other);
          // return;
        }
        other.canJump = true;
        other.args.jumping = false;
        if (other.willJump && this.args.spinTime < this.args.minHold) {
          this.args.spinTime = 0;
          this.args.aiming = '';
          return;
        } else if (other.willJump && this.args.aiming && this.args.spinTime >= this.args.minHold) {
          this.args.firing = 'firing';
          this.viewport.onFrameOut(6, () => {
            this.args.firing = 'fired';
          });
          this.viewport.onFrameOut(16, () => {
            this.args.firing = '';
          });
          this.viewport.onFrameOut(24, () => {
            this.args.aiming = '';
          });
          this.viewport.onFrameOut(6, () => {
            if (!this.args.aiming) {
              return;
            }
            _Sfx.Sfx.play('SPRING_SHOT');
            this.holding.delete(other);
            other.args.jumping = true;
            this.ignores.set(other, 2);
            other.args.ignore = 1;
            other.args.float = 0;
            if (other.yAxis > 0) {
              other.args.ySpeed = this.args.power;
            } else if (other.yAxis < 0) {
              other.args.ySpeed = -this.args.power;
            } else if (other.xAxis > 0) {
              other.args.xSpeed = this.args.power;
              other.args.ySpeed = 0;
              other.args.float = 8;
            } else if (other.xAxis < 0) {
              other.args.xSpeed = -this.args.power;
              other.args.ySpeed = 0;
              other.args.float = 8;
            }
          });
        }
        if (this.args.spinTime > 5) {
          other.args.cameraMode = 'cross-cannon-quick';
        } else {
          other.args.cameraMode = 'cross-cannon';
        }
        if (other.yAxis > 0) {
          this.args.aiming = 'down';
        } else if (other.yAxis < 0) {
          this.args.aiming = 'up';
        } else if (other.xAxis > 0) {
          this.args.aiming = 'right';
        } else if (other.xAxis < 0) {
          this.args.aiming = 'left';
        }
        if (!other.yAxis && !other.xAxis) {
          this.args.spinTime = 0;
          this.args.aiming = '';
        } else if (this.args.aiming) {
          if (this.args.spinTime === 0) {
            _Sfx.Sfx.play('QUICK_SLIDE');
          }
          this.args.spinTime++;
        }
        if (this.args.spinTime === this.args.minHold && this.args.aiming) {
          _Sfx.Sfx.play('PAD_BOUNCE');
        }

        // if(this.viewport.args.frameId % (60 * 3) === 0)
        // {
        // 	this.args.aiming = '';
        // }
      }
    }
  }, {
    key: "wakeUp",
    value: function wakeUp() {
      this.args.aiming = '';
    }

    // get solid() { return !this.holding; }
  }]);
  return CrossCannon;
}(_PointActor2.PointActor);
exports.CrossCannon = CrossCannon;
});

;require.register("actor/Cursor.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Cursor = void 0;
var _PointActor2 = require("./PointActor");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let Cursor = /*#__PURE__*/function (_PointActor) {
  _inherits(Cursor, _PointActor);
  var _super = _createSuper(Cursor);
  function Cursor() {
    _classCallCheck(this, Cursor);
    return _super.apply(this, arguments);
  }
  _createClass(Cursor, [{
    key: "update",
    value: function update() {}
  }]);
  return Cursor;
}(_PointActor2.PointActor);
exports.Cursor = Cursor;
});

;require.register("actor/CutScene.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CutScene = void 0;
var _PointActor2 = require("./PointActor");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let CutScene = /*#__PURE__*/function (_PointActor) {
  _inherits(CutScene, _PointActor);
  var _super = _createSuper(CutScene);
  function CutScene() {
    var _this;
    let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let parent = arguments.length > 1 ? arguments[1] : undefined;
    _classCallCheck(this, CutScene);
    _this = _super.call(this, args, parent);
    if (args.src) {
      _this.fetcher = fetch(args.src).then(r => r.json());
    } else if (args.frames) {
      _this.fetcher = Promise.resolve(args.frames);
    }
    _this.args.hidden = true;
    return _this;
  }
  _createClass(CutScene, [{
    key: "playSample",
    value: function playSample(event) {
      const viewport = this.viewport;
      if (!viewport.args.audio) {
        return;
      }
      const tag = new Audio(event.source);
      tag.play();
    }
  }, {
    key: "activate",
    value: function activate(other, button) {
      let force = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      if (!other.controllable || other.args.falling && !force) {
        return;
      }
      if (other.args.canonical !== 'Sonic') {
        return;
      }
      const viewport = this.viewport;
      if (!viewport || this.args.running) {
        return;
      }
      this.args.running = true;
      other.args.gSpeed = 0;
      viewport.args.cutScene = true;
      other.controller.zero();
      this.fetcher.then(scene => {
        let timer = 0;
        for (const frame of scene) {
          const frameCallback = () => {
            switch (frame.event) {
              case 'dialog':
                viewport.showDialog(frame.lines, frame.classes);
                break;
              case 'audio':
                this.playSample(frame);
                break;
              case 'face':
                other.args.direction = frame.direction;
                other.args.facing = frame.direction > 0 ? 'right' : 'left';
                break;
              case 'input':
                if (frame.axes) {
                  other.controller.replay({
                    axes: frame.axes
                  });
                }
                if (frame.buttons) {
                  other.controller.replay({
                    buttons: frame.buttons
                  });
                }
                other.readInput();
                break;
              case 'superdrop':
                other.dropDashCharge = 30;
                break;
              case 'clearAct':
                viewport.clearAct(frame.message);
                break;
              case 'clear':
                viewport.clearDialog();
                break;
              case 'message':
                viewport.showCenterMessage(frame.message);
                break;
              case 'hide':
                viewport.hideCenterMessage();
                viewport.hideDialog();
                break;
              case 'wait':
                viewport.args.cutScene = false;
                viewport.hideCenterMessage();
                viewport.hideDialog();
                break;
            }
          };
          if (timer) {
            viewport.onFrameOut(timer, frameCallback);
          } else {
            frameCallback();
          }
          timer += frame.time || 0;
        }
      });
    }
  }]);
  return CutScene;
}(_PointActor2.PointActor);
exports.CutScene = CutScene;
});

;require.register("actor/Dish.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Dish = void 0;
var _PointActor = require("./PointActor");
var _Mixin = require("curvature/base/Mixin");
var _CanPop = require("../mixin/CanPop");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let Dish = /*#__PURE__*/function (_Mixin$from) {
  _inherits(Dish, _Mixin$from);
  var _super = _createSuper(Dish);
  function Dish() {
    var _this;
    _classCallCheck(this, Dish);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.width = 46;
    _this.args.height = 50;
    _this.args.type = 'actor-item actor-dish';
    return _this;
  }
  _createClass(Dish, [{
    key: "solid",
    get: function get() {
      return false;
    }
  }], [{
    key: "fromDef",
    value: function fromDef(objDef) {
      const obj = _get(_getPrototypeOf(Dish), "fromDef", this).call(this, objDef);
      obj.args.width = objDef.width;
      obj.args.height = objDef.height;
      return obj;
    }
  }]);
  return Dish;
}(_Mixin.Mixin.from(_PointActor.PointActor, _CanPop.CanPop));
exports.Dish = Dish;
});

;require.register("actor/Dolphin.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Dolphin = void 0;
var _PointActor = require("./PointActor");
var _Mixin = require("curvature/base/Mixin");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
// import { Sfx } from '../audio/Sfx';
let Dolphin = /*#__PURE__*/function (_Mixin$from) {
  _inherits(Dolphin, _Mixin$from);
  var _super = _createSuper(Dolphin);
  function Dolphin() {
    var _this;
    _classCallCheck(this, Dolphin);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.type = 'actor-item actor-dolphin';
    _this.args.width = 64;
    _this.args.height = 64;
    _this.args.gravity = 0.4;
    _this.noClip = true;
    _this.args.float = -1;
    return _this;
  }
  _createClass(Dolphin, [{
    key: "update",
    value: function update() {
      if (!this.viewport || !this.viewport.controlActor) {
        return;
      }
      const controlActor = this.viewport.controlActor;
      if (this.args.ySpeed < -4) {
        this.args.type = 'actor-item actor-dolphin';
      } else {
        this.args.type = 'actor-item actor-dolphin actor-dolphin-downward';
      }
      if (!this.args.ySpeed && this.args.x < -128 + controlActor.args.x) {
        this.args.falling = true;
        this.args.xSpeed = 6 + (controlActor.args.xSpeed || controlActor.args.gSpeed);
        this.args.ySpeed = -16;
        this.args.float = 0;
      }
      _get(_getPrototypeOf(Dolphin.prototype), "update", this).call(this);
    }
  }]);
  return Dolphin;
}(_Mixin.Mixin.from(_PointActor.PointActor));
exports.Dolphin = Dolphin;
});

;require.register("actor/Door.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Door = void 0;
var _PointActor2 = require("./PointActor");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let Door = /*#__PURE__*/function (_PointActor) {
  _inherits(Door, _PointActor);
  var _super = _createSuper(Door);
  function Door() {
    var _this;
    _classCallCheck(this, Door);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.behaviors.clear();
    _this.args.type = 'actor-item actor-door';
    _this.args.width = 32;
    _this.args.height = 64;
    _this.args.opened = false;
    _this.args.opening = false;
    return _this;
  }
  _createClass(Door, [{
    key: "onRendered",
    value: function onRendered() {
      _get(_getPrototypeOf(Door.prototype), "onRendered", this).call(this, event);
      this.setAutoAttr('opening', 'data-opening');
      this.setAutoAttr('opened', 'data-opened');
    }
  }, {
    key: "open",
    value: function open(other) {
      if (!other.controllable) {
        return;
      }
      if (this.others.waitFor && this.others.waitFor.args.opened) {
        this.args.opening = this.args.opened = false;
        return;
      }
      this.args.opening = true;
      this.viewport.onFrameOut(10, () => this.args.opened = true);
      this.viewport.onFrameOut(50, () => this.args.opening = false);
      this.viewport.onFrameOut(55, () => this.args.opened = false);
    }
  }, {
    key: "collideA",
    value: function collideA(other, type) {
      if (this.args.opening) {
        return !this.args.opened;
      }
      if (!this.args.opened) {
        this.viewport.onFrameOut(20, () => this.open(other));
      }
      return !this.args.opened;
    }
  }, {
    key: "sleep",
    value: function sleep() {
      if (!this.viewport) {
        return;
      }
      this.args.opening = this.args.opened = false;
    }
  }, {
    key: "solid",
    get: function get() {
      return !this.args.opened;
    }
  }, {
    key: "rotateLock",
    get: function get() {
      return true;
    }
  }]);
  return Door;
}(_PointActor2.PointActor);
exports.Door = Door;
});

;require.register("actor/DrainFly.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DrainFly = void 0;
var _PointActor = require("./PointActor");
var _Platformer = require("../behavior/Platformer");
var _Mixin = require("curvature/base/Mixin");
var _CanPop = require("../mixin/CanPop");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let DrainFly = /*#__PURE__*/function (_Mixin$from) {
  _inherits(DrainFly, _Mixin$from);
  var _super = _createSuper(DrainFly);
  function DrainFly(args, parent) {
    var _this;
    _classCallCheck(this, DrainFly);
    _this = _super.call(this, args, parent);
    _this.args.type = 'actor-item actor-drainfly';
    _this.args.width = 16;
    _this.args.height = 16;
    _this.args.float = -1;
    _this.args.gravity = 0;
    _this.args.phase = 'idle';
    return _this;
  }
  _createClass(DrainFly, [{
    key: "update",
    value: function update() {
      if (!this.viewport || !this.viewport.actorIsOnScreen(this)) {
        return;
      }
      const viewport = this.viewport;
      _get(_getPrototypeOf(DrainFly.prototype), "update", this).call(this);
      const mainChar = viewport.controlActor;
      if (!mainChar) {
        this.args.phase = 'idle';
        return;
      }
      switch (this.args.phase) {
        case 'idle':
          this.args.alertTo = this.y - 64;
          if (mainChar.x + -this.x > -128) {
            this.args.phase = 'alert';
          }
          break;
        case 'alert':
          if (this.y > this.args.alertTo) {
            this.args.ySpeed--;
          } else {
            this.args.phase = 'attacking';
            this.args.y = this.args.alertTo;
            this.args.ySpeed = 0;
          }
          break;
        case 'attacking':
          {
            const drawX = Math.sign(mainChar.args.x + -this.args.x) || 0;
            const drawY = Math.sign(mainChar.args.y + -this.args.y + -24) || 0;
            this.args.xSpeed += drawX * 0.2 - Math.random() / 10 || 0;
            this.args.ySpeed += drawY * 0.5 - Math.random() / 10 || 0;
            if (Math.abs(this.args.xSpeed) > 6) {
              this.args.xSpeed = 4 * drawX;
            }
            if (Math.abs(this.args.ySpeed) > 8) {
              this.args.ySpeed = 4 * drawY;
            }
            if (this.bMap('checkBelow', this.x, this.y).get(_Platformer.Platformer)) {
              this.args.falling = true;
              this.args.ySpeed = -1;
              this.args.y -= 1;
            }
            break;
          }
      }

      // if(!this.args.ySpeed)
      // {
      // 	this.args.y -= 2;
      // }

      this.args.facing = this.args.xSpeed > 0 ? 'left' : 'right';
      this.args.float = -1;
    }
  }, {
    key: "solid",
    get: function get() {
      return false;
    }
  }, {
    key: "rotateLock",
    get: function get() {
      return true;
    }
  }]);
  return DrainFly;
}(_Mixin.Mixin.from(_PointActor.PointActor, _CanPop.CanPop));
exports.DrainFly = DrainFly;
});

;require.register("actor/DrillCar.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DrillCar = void 0;
var _Vehicle2 = require("./Vehicle");
var _Tag = require("curvature/base/Tag");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let DrillCar = /*#__PURE__*/function (_Vehicle) {
  _inherits(DrillCar, _Vehicle);
  var _super = _createSuper(DrillCar);
  function DrillCar() {
    var _this;
    _classCallCheck(this, DrillCar);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _defineProperty(_assertThisInitialized(_this), "instructions", ['Jump ⓿', 'Fly ⓿+⓿']);
    _this.args.type = 'actor-item actor-drill-car';
    _this.args.width = 38;
    _this.args.height = 48;
    _this.removeTimer = null;
    _this.args.gSpeedMax = 26;
    _this.args.decel = 0.30;
    _this.args.accel = 0.75;
    _this.args.seatHeight = 34;
    _this.args.skidTraction = 0.95;
    _this.dustCount = 0;
    _this.args.particleScale = 2;
    return _this;
  }
  _createClass(DrillCar, [{
    key: "onRendered",
    value: function onRendered(event) {
      _get(_getPrototypeOf(DrillCar.prototype), "onRendered", this).call(this, event);
      this.box = this.findTag('div');
      this.sprite = this.findTag('div.sprite');
      this.backSprite = new _Tag.Tag('<div class = "sprite-back sprite">');
      this.drill = new _Tag.Tag('<div class = "drill-car-drill">');
      this.seat = new _Tag.Tag('<div class = "drill-car-seat">');
      this.windsheild = new _Tag.Tag('<div class = "drill-car-windsheild">');
      this.copterCap = new _Tag.Tag('<div class = "drill-car-copter-cap">');
      this.copterBladeA = new _Tag.Tag('<div class = "drill-car-copter-blade-a">');
      this.copterBladeB = new _Tag.Tag('<div class = "drill-car-copter-blade-b">');
      this.frontWheelA = new _Tag.Tag('<div class = "drill-car-tire drill-car-tire-front-a">');
      this.frontWheelB = new _Tag.Tag('<div class = "drill-car-tire drill-car-tire-front-b">');
      this.backWheelA = new _Tag.Tag('<div class = "drill-car-tire drill-car-tire-back-a">');
      this.backWheelB = new _Tag.Tag('<div class = "drill-car-tire drill-car-tire-back-b">');
      this.sprite.appendChild(this.drill.node);
      this.backSprite.appendChild(this.copterCap.node);
      this.backSprite.appendChild(this.copterBladeA.node);
      this.backSprite.appendChild(this.copterBladeB.node);
      this.sprite.appendChild(this.windsheild.node);
      this.backSprite.appendChild(this.seat.node);
      this.sprite.appendChild(this.frontWheelA.node);
      this.backSprite.appendChild(this.frontWheelB.node);
      this.sprite.appendChild(this.backWheelA.node);
      this.backSprite.appendChild(this.backWheelB.node);
      this.box.appendChild(this.backSprite.node);
    }
  }, {
    key: "update",
    value: function update() {
      const falling = this.args.falling;
      if (this.viewport.args.audio && !this.flyingSound) {
        this.flyingSound = new Audio('/Sonic/drill-car-copter.wav');
        this.flyingSound.volume = 0.35 + Math.random() * -0.2;
        this.flyingSound.loop = true;
      }
      if (this.flyingSound) {
        if (!this.flyingSound.paused) {
          this.flyingSound.volume = 0.25 + Math.random() * -0.2;
        }
        if (this.flyingSound.currentTime > 0.2) {
          this.flyingSound.currentTime = 0.0;
        }
      }
      if (!this.box) {
        _get(_getPrototypeOf(DrillCar.prototype), "update", this).call(this);
        return;
      }
      if (!falling) {
        this.flyingSound && this.flyingSound.pause();
        const direction = this.args.direction;
        const gSpeed = this.args.gSpeed;
        const speed = Math.abs(gSpeed);
        const maxSpeed = this.args.gSpeedMax;
        if (this.dustCount > 0) {
          this.dustCount--;
        }
        if (Math.sign(this.args.gSpeed) !== direction && Math.abs(this.args.gSpeed - direction) > 5) {
          this.box.setAttribute('data-animation', 'skidding');
          const viewport = this.viewport;
          const particleA = new _Tag.Tag('<div class = "particle-dust">');
          const pointA = this.rotatePoint(this.args.gSpeed, 0);
          particleA.style({
            '--x': pointA[0] + this.x,
            '--y': pointA[1] + this.y,
            'z-index': 0,
            opacity: Math.random() * 2
          });
          const particleB = new _Tag.Tag('<div class = "particle-dust">');
          const pointB = this.rotatePoint(this.args.gSpeed + 40 * this.args.direction, 0);
          particleB.style({
            '--x': pointB[0] + this.x,
            '--y': pointB[1] + this.y,
            'z-index': 0,
            opacity: Math.random() * 2
          });
          viewport.particles.add(particleA);
          viewport.particles.add(particleB);
          setTimeout(() => {
            viewport.particles.remove(particleA);
            viewport.particles.remove(particleB);
          }, 350);
        } else if (this.args.moving && speed > maxSpeed * 0.75) {
          this.box.setAttribute('data-animation', 'running');
        } else if (this.args.moving && speed) {
          this.box.setAttribute('data-animation', 'walking');
        } else {
          this.box.setAttribute('data-animation', 'standing');
        }
      } else if (this.args.flying) {
        this.box.setAttribute('data-animation', 'flying');
      } else if (this.args.falling) {
        this.flyingSound && this.flyingSound.pause();
        this.box.setAttribute('data-animation', 'jumping');
      }
      if (this.args.copterCoolDown == 0) {
        if (this.args.ySpeed > 5) {
          this.flyingSound && this.flyingSound.pause();
          this.args.flying = false;
        }
      } else if (this.args.copterCoolDown > 0) {
        this.args.copterCoolDown--;
      }
      _get(_getPrototypeOf(DrillCar.prototype), "update", this).call(this);
    }
  }, {
    key: "command_0",
    value: function command_0() {
      if (!this.args.falling) {
        this.args.copterCoolDown = 15;
        _get(_getPrototypeOf(DrillCar.prototype), "command_0", this).call(this);
        return;
      }
      if (this.args.copterCoolDown > 0) {
        return;
      }
      if (this.args.ySpeed > -16) {
        if (!this.args.flying) {
          this.flyingSound && this.flyingSound.play();
        }
        this.args.flying = true;
        if (this.args.copterCoolDown == 0) {
          this.args.copterCoolDown = 7;
        }
        this.args.ySpeed = -1;
        this.args.ySpeed = -4;
        this.args.float = 8;
      }
    }
  }, {
    key: "sleep",
    value: function sleep() {
      this.flyingSound && this.flyingSound.pause();
    }
  }, {
    key: "solid",
    get: function get() {
      return !this.occupant;
    }
  }]);
  return DrillCar;
}(_Vehicle2.Vehicle);
exports.DrillCar = DrillCar;
});

;require.register("actor/DropCage.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DropCage = void 0;
var _PointActor2 = require("./PointActor");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let DropCage = /*#__PURE__*/function (_PointActor) {
  _inherits(DropCage, _PointActor);
  var _super = _createSuper(DropCage);
  function DropCage() {
    var _this;
    _classCallCheck(this, DropCage);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.width = 48;
    _this.args.height = 40;
    _this.args.type = 'actor-item actor-drop-cage';
    _this.args.float = -1;
    _this.holding = false;
    return _this;
  }
  _createClass(DropCage, [{
    key: "collideA",
    value: function collideA(other, type) {
      if (this.holding || !other.controllable) {
        return false;
      }
      if (this.ignores.has(other)) {
        this.ignores.set(other, 60);
        return false;
      }
      if (type === -1 || type % 2 === 0) {
        const xDiff = Math.abs(other.args.x - this.args.x);
        other.args.xSpeed = 0;
        this.holding = other;
        other.args.ySpeed = 0;
        other.args.float = -1;
        other.args.ignore = -1;
        this.dropDelay(other).then(() => {
          other.args.float = 0;
          other.args.ignore = 5;
          this.ignores.set(other, 60);
          this.holding = false;
        });
        return false;
      }
      return true;
    }
  }, {
    key: "dropDelay",
    value: function dropDelay(other) {
      let waitFor = false;
      if (this.args.waitFor) {
        waitFor = this.viewport.actorsById[this.args.waitFor];
      }
      if (!waitFor) {
        return new Promise(accept => this.viewport.onFrameOut(30, () => accept()));
      }
      return waitFor.dropDelay(other);
    }
  }, {
    key: "update",
    value: function update() {
      _get(_getPrototypeOf(DropCage.prototype), "update", this).call(this);
      if (this.holding) {
        const other = this.holding;
        const toX = this.x;
        const toY = -6 + this.y;
        const stepX = (toX + -other.args.x) / 3;
        const stepY = (toY + -other.args.y) / 3;
        if (Math.abs(other.args.x - toX) < 0.1) {
          other.args.x = toX;
          if (Math.abs(other.args.y - toY) < 0.1) {
            other.args.y = toY;
          } else {
            other.args.y += stepY;
          }
        } else {
          other.args.x += stepX;
        }
      }
    }
  }, {
    key: "solid",
    get: function get() {
      return !this.holding && !this.ignores.size;
    }
  }]);
  return DropCage;
}(_PointActor2.PointActor);
exports.DropCage = DropCage;
});

;require.register("actor/Egg.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Egg = void 0;
var _Png = require("../sprite/Png");
var _PointActor2 = require("./PointActor");
var _Platformer = require("../behavior/Platformer");
var _EggShellTop = require("./EggShellTop");
var _Chao = require("./Chao");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let Egg = /*#__PURE__*/function (_PointActor) {
  _inherits(Egg, _PointActor);
  var _super = _createSuper(Egg);
  function Egg() {
    var _this;
    _classCallCheck(this, Egg);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.type = 'actor-item actor-egg';
    _this.args.shell = 'normal';
    _this.args.bindTo('shell', v => {
      switch (v) {
        case 'flat':
        case 'normal':
          _this.args.spriteSheet = `/DBurraki/chao-egg-${v}.png`;
          break;
        default:
          _this.args.spriteSheet = `/DBurraki/chao-egg-normal.png`;
          break;
      }
      _this.png = new _Png.Png(_this.args.spriteSheet);
    });
    _this.args.width = 15;
    _this.args.height = 20;
    _this.broken = false;

    // this.defaultChaoColors = ['addef8', '2ebee9', '0e6d89', 'ecde2f', 'dcb936', '985000', 'f8b0c0', 'f85080', 'e4e0e4', 'e0e0e0', 'f8f820', '606080', 'e2e0e2'];

    _this.customChaoColors = [null, null, null, null, null, null, null, null, null, null, null, null, null];
    const colorMap = [12, 0, 1, 2];
    _this.defaultColors = ['e2e0e2', 'addef8', '2ebee9', '0e6d89'];
    _this.customColors = [null, null, null, null];
    _this.customColors.bindTo(() => {
      const colorMap = {};
      for (const i in _this.defaultColors) {
        var _this$customColors$i;
        colorMap[_this.defaultColors[i]] = (_this$customColors$i = _this.customColors[i]) !== null && _this$customColors$i !== void 0 ? _this$customColors$i : _this.defaultColors[i];
      }
      _this.png.ready.then(() => {
        const customSheet = _this.png.recolor(colorMap).toUrl();
        _this.args.spriteSheet = customSheet;
      });
    }, {
      wait: 0
    });
    _this.customChaoColors.bindTo((v, k) => {
      k = Number(k);
      if (!colorMap.includes(k)) {
        return;
      }
      const shellColorKey = colorMap.indexOf(k);
      _this.customColors[shellColorKey] = v;
      if (v !== null) {
        _this.args.shell = 'flat';
      }
    });
    const colorSelection = [[null, null, null, null, null, null, null, null, null, null, null, null, null]
    // blue + yellow (normal)
    , [null, null, null, "80e000", "69b700", "487d00", null, null, null, null, null, null, null]
    // blue + green
    , ["485070", "303058", "202020", null, null, null, null, null, null, null, null, "202020", "5f6994"]
    // black + yellow
    , ["e4e0e4", "c0bde4", "9c99c0", null, null, null, null, null, null, null, null, null, "e4e0e4"]
    // white + yellow
    , ["e4e0e4", "c0bde4", "9c99c0", "addef8", "2ebee9", "0e6d89", null, null, null, null, null, null, "e4e0e4"]
    // white + blue
    , ["485070", "303058", "202020", "b70000", "770000", "420000", null, null, null, null, "bf999c", "202020", "5f6994"]
    // black + red
    , ["ff7575", "e00000", "800000", "b70000", "770000", "420000", null, null, null, null, null, "202020", "ffaeae"]
    // ruby
    , ["ffc20e", "dd8604", "ad4d05", "b44800", "844221", "630000", null, null, null, null, null, "202020", "fae3af"]
    // tangy
    , ["80e000", "69b700", "487d00", "48b400", "428421", "006300", null, null, null, null, null, "202020", "cef00f"]
    // lime
    , ["485070", "303058", "202020", "c0bde4", "9c99c0", "606080", null, null, null, null, "9c99c0", "202020", "5f6994"]
    // black + white
    , ["c0bde4", "9c99c0", "606080", "485070", "303058", "202020", null, null, null, null, "9c99c0", "202020", "e4e0e4"]
    // white + black
    , ["c0bde4", "9c99c0", "606080", "e4e0e4", "c0bde4", "9c99c0", null, null, null, null, "9c99c0", "202020", "e4e0e4"]
    // white + white
    ];

    Object.assign(_this.customChaoColors, colorSelection[Math.trunc(Math.random() * (-1 + colorSelection.length))]);
    _this.args.bindTo('falling', falling => {
      const impact = _this.ySpeedLast;
      if (falling || _this.broken || impact < 12) {
        return;
      }
      ;
      _this.hatch();
    });
    _this.bindTo('carriedBy', carrier => {
      if (_this.cX) {
        _this.cX();
        _this.cX = null;
      }
      if (_this.cY) {
        _this.cY();
        _this.cY = null;
      }
      if (carrier) {
        _this.cX = carrier.args.bindTo('x', v => _this.args.x = v + carrier.args.direction * 12);
        _this.cY = carrier.args.bindTo('y', v => _this.args.y = v + -12);
        carrier.carrying.add(_assertThisInitialized(_this));
        _this.args.standingOn = null;
        _this.args.falling = true;
        _this.args.float = -1;
        _this.args.groundAngle = 0;
      } else if (_this.carriedBy) {
        const carrier = _this.carriedBy;
        _this.carriedBy = null;
        _this.args.xSpeed = carrier.args.xSpeed;
        _this.args.ySpeed = carrier.args.ySpeed;
        _this.args.xSpeed += Math.sign(carrier.args.gSpeed || carrier.args.xSpeed) * 4;
        _this.args.ySpeed -= 4;
        _this.args.xSpeed += carrier.xAxis * 2;
        carrier.carrying.delete(_assertThisInitialized(_this));
        _this.args.falling = true;
        _this.args.float = 0;
        _this.args.groundAngle = 0;
      }
    });
    return _this;
  }
  _createClass(Egg, [{
    key: "onRendered",
    value: function onRendered(event) {
      _get(_getPrototypeOf(Egg.prototype), "onRendered", this).call(this, event);
      this.setAutoAttr('shell', 'data-shell');
    }
  }, {
    key: "lift",
    value: function lift(actor) {
      if (this.carriedBy === actor) {
        this.carriedBy = null;
        return;
      }
      this.carriedBy = actor;
    }
  }, {
    key: "sleep",
    value: function sleep() {
      if (!this.broken) {
        return;
      }
      this.viewport.actors.remove(this);
    }
  }, {
    key: "hatch",
    value: function hatch() {
      const impact = this.ySpeedLast;
      this.args.type = 'actor-item actor-egg actor-egg-shell-bottom';
      const shellTop = new _EggShellTop.EggShellTop({
        spriteSheet: this.args.spriteSheet,
        xSpeed: this.xSpeedLast * 0.6,
        ySpeed: -impact * 0.4,
        x: this.x,
        y: this.y - 10
      });
      const chao = new _Chao.Chao({
        currentState: 'hatching',
        xSpeed: this.xSpeedLast * 0.4,
        ySpeed: -impact * 0.4,
        x: this.x,
        y: this.y - 10
      });
      this.args.gSpeed = this.xSpeedLast * 0.2;
      this.viewport.spawn.add({
        object: shellTop
      });
      this.viewport.spawn.add({
        object: chao
      });
      Object.assign(chao.customColors, this.customChaoColors);
      Object.assign(chao.traits, {
        appetite: Math.random(),
        sociable: Math.random(),
        restless: Math.random()
      });
      chao.mood.hunger = 0.8;
      this.broken = true;
    }
  }, {
    key: "updateStart",
    value: function updateStart() {
      // if(this.args.static)
      // {
      // 	this.args.static = !!this.bMap('checkBelow', this.x, this.y + 1).get(Platformer);
      // }
      // else
      // {
      // 	this.args.static = !this.args.falling;
      // }

      // if(this.args.gSpeed || this.args.xSpeed)
      // {
      // 	this.args.static = false;
      // }

      _get(_getPrototypeOf(Egg.prototype), "updateStart", this).call(this);
    }
  }, {
    key: "update",
    value: function update() {
      if (this.broken && !this.carriedBy) {
        this.args.startFrame = this.args.startFrame || this.viewport.args.frameId;
        if (this.viewport.args.frameId - this.args.startFrame > 120) {
          this.viewport.actors.remove(this);
          return;
        }
      }
      _get(_getPrototypeOf(Egg.prototype), "update", this).call(this);
    }
  }, {
    key: "rotateLock",
    get: function get() {
      return true;
    }
  }, {
    key: "solid",
    get: function get() {
      return false;
    }
  }]);
  return Egg;
}(_PointActor2.PointActor);
exports.Egg = Egg;
});

;require.register("actor/EggCapsule.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EggCapsule = void 0;
var _PointActor2 = require("./PointActor");
var _Sfx = require("../audio/Sfx");
var _Bgm = require("../audio/Bgm");
var _Tag = require("curvature/base/Tag");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let EggCapsule = /*#__PURE__*/function (_PointActor) {
  _inherits(EggCapsule, _PointActor);
  var _super = _createSuper(EggCapsule);
  function EggCapsule() {
    var _this;
    _classCallCheck(this, EggCapsule);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.width = 64;
    _this.args.height = 69;
    _this.args.type = 'actor-item actor-egg-capsule';
    _this.args.gravity = 0.4;
    _this.args.bindTo('falling', v => {
      if (!v) _this.viewport.args.shakeY = 7;
    });
    _this.triggered = false;
    return _this;
  }
  _createClass(EggCapsule, [{
    key: "collideA",
    value: function collideA(other, type) {
      if (this.args.falling) {
        other.startle(this);
        return true;
      }
      if (!other.controllable || type !== 0) {
        return true;
      }
      if (this.triggered) {
        other.args.x += 0.1 * Math.sign(this.args.x - other.args.x);
        other.args.gSpeed = 0;
        this.args.active = true;
        return true;
      } else if (this.groundTime > 15 && type === 0 && !this.triggered) {
        other.args.ignore = 200;
        _Sfx.Sfx.play('WTF_BOOM');
        _Bgm.Bgm.fadeOut(1500);
        this.viewport.onFrameOut(107, () => {
          const explosionTag = document.createElement('div');
          explosionTag.classList.add('particle-huge-explosion');
          const explosion = new _Tag.Tag(explosionTag);
          this.viewport.controlActor.screenLock = null;
          explosion.style({
            '--x': this.args.x,
            '--y': this.args.y
          });
          this.viewport.particles.add(explosion);
          this.viewport.onFrameOut(15, () => this.viewport.particles.remove(explosion));
        });
        this.viewport.onFrameOut(240, () => this.triggered = false);
        this.viewport.onFrameOut(117, () => other.args.ySpeed = -65);
        this.viewport.onFrameOut(115, () => other.startle(this));
        this.triggered = true;
        return true;
      }
      return true;
    }
  }, {
    key: "solid",
    get: function get() {
      return this.groundTime > 15;
    }
  }]);
  return EggCapsule;
}(_PointActor2.PointActor);
exports.EggCapsule = EggCapsule;
});

;require.register("actor/EggMobile.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EggMobile = void 0;
var _Vehicle2 = require("./Vehicle");
var _Platformer = require("../behavior/Platformer");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let EggMobile = /*#__PURE__*/function (_Vehicle) {
  _inherits(EggMobile, _Vehicle);
  var _super = _createSuper(EggMobile);
  function EggMobile() {
    var _this;
    _classCallCheck(this, EggMobile);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.type = 'actor-item actor-vehicle actor-eggmobile';
    _this.args.accel = 0.15;
    _this.args.decel = 0.8;
    _this.args.gSpeedMax = 15;
    _this.args.xSpeedMax = 45;
    _this.args.ySpeedMax = 45;
    _this.args.jumpForce = 12;
    _this.args.gravity = 0.6;
    _this.args.width = 28;
    _this.args.height = 20;
    _this.args.yMargin = 42;
    _this.args.falling = true;
    _this.args.flying = true;
    _this.args.float = -1;
    return _this;
  }
  _createClass(EggMobile, [{
    key: "update",
    value: function update() {
      if (this.bMap('checkBelow', this.x, this.y).get(_Platformer.Platformer)) {
        this.args.y--;
      }
      if (Math.abs(this.yAxis) > 0.5) {
        if (Math.abs(this.args.ySpeed) < this.args.ySpeedMax) {
          let ySpeed = this.args.ySpeed;
          if (Math.sign(this.yAxis) === Math.sign(this.args.ySpeed)) {
            ySpeed += this.yAxis * this.args.accel * 3;
          } else {
            ySpeed += this.yAxis * this.args.accel * 6;
          }
          if (ySpeed > 0) {
            ySpeed = Math.floor(ySpeed * 1000) / 1000;
          } else {
            ySpeed = Math.ceil(ySpeed * 1000) / 1000;
          }
          this.args.ySpeed = ySpeed;
        }
      } else {
        this.args.ySpeed = this.args.ySpeed * this.args.decel;
      }
      if (!this.xAxis) {
        if (Math.abs(this.args.xSpeed) <= 1) {
          this.args.xSpeed = 0;
        }
        if (this.args.xSpeed > 0) {
          this.args.xSpeed = Math.floor(this.args.xSpeed * this.args.decel);
        } else {
          this.args.xSpeed = Math.ceil(this.args.xSpeed * this.args.decel);
        }
      }
      // else
      // {
      // 	this.args.xSpeed = Math.ceil(this.args.xSpeed * this.args.decel);
      // }

      if (!this.occupant) {
        this.args.xSpeed = 0;
        this.args.ySpeed = 0;
      }
      this.args.falling = true;
      this.args.flying = true;
      this.args.mode = 0;
      this.args.cameraMode = 'aerial';
      _get(_getPrototypeOf(EggMobile.prototype), "update", this).call(this);
    }
  }, {
    key: "solid",
    get: function get() {
      return !this.occupant;
    }
  }]);
  return EggMobile;
}(_Vehicle2.Vehicle);
exports.EggMobile = EggMobile;
});

;require.register("actor/EggShellBottom.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EggShellBottom = void 0;
var _PointActor2 = require("./PointActor");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let EggShellBottom = /*#__PURE__*/function (_PointActor) {
  _inherits(EggShellBottom, _PointActor);
  var _super = _createSuper(EggShellBottom);
  function EggShellBottom() {
    var _this;
    _classCallCheck(this, EggShellBottom);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.type = 'actor-item actor-egg-shell-bottom';
    _this.args.width = 15;
    _this.args.height = 20;

    // this.bindTo('carriedBy', carrier => {
    // 	if(this.cX) { this.cX(); this.cX = null; }
    // 	if(this.cY) { this.cY(); this.cY = null; }
    // 	if(carrier)
    // 	{
    // 		this.cX = carrier.args.bindTo('x', v => this.args.x = v + carrier.args.direction * 12);
    // 		this.cY = carrier.args.bindTo('y', v => this.args.y = v + -12);

    // 		carrier.carrying.add(this);

    // 		this.args.float = -1;
    // 	}
    // 	else if(this.carriedBy)
    // 	{
    // 		const carrier = this.carriedBy;

    // 		this.carriedBy = null;

    // 		this.args.xSpeed = carrier.args.xSpeed;
    // 		this.args.ySpeed = carrier.args.ySpeed;

    // 		this.args.xSpeed += Math.sign(carrier.args.gSpeed || carrier.args.xSpeed) * 4;
    // 		this.args.ySpeed -= 4;

    // 		carrier.carrying.delete(this);

    // 		this.args.falling = true;
    // 		this.args.float = 0;
    // 	}
    // });
    return _this;
  }
  _createClass(EggShellBottom, [{
    key: "update",
    value: function update() {
      this.args.startFrame = this.args.startFrame || this.viewport.args.frameId;
      if (this.viewport.args.frameId - this.args.startFrame > 45) {
        this.viewport.actors.remove(this);
        return;
      }
      _get(_getPrototypeOf(EggShellBottom.prototype), "update", this).call(this);
    }

    // lift(actor)
    // {
    // 	if(this.carriedBy === actor)
    // 	{
    // 		this.carriedBy = null;

    // 		return;
    // 	}

    // 	this.carriedBy = actor;
    // }
  }, {
    key: "solid",
    get: function get() {
      return false;
    }
  }, {
    key: "sleep",
    value: function sleep() {
      this.viewport.actors.remove(this);
      console.log(this);
    }
  }]);
  return EggShellBottom;
}(_PointActor2.PointActor);
exports.EggShellBottom = EggShellBottom;
});

;require.register("actor/EggShellTop.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EggShellTop = void 0;
var _PointActor2 = require("./PointActor");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let EggShellTop = /*#__PURE__*/function (_PointActor) {
  _inherits(EggShellTop, _PointActor);
  var _super = _createSuper(EggShellTop);
  function EggShellTop() {
    var _this;
    _classCallCheck(this, EggShellTop);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.type = 'actor-item actor-egg-shell-top';
    _this.args.width = 15;
    _this.args.height = 20;

    // this.bindTo('carriedBy', carrier => {
    // 	if(this.cX) { this.cX(); this.cX = null; }
    // 	if(this.cY) { this.cY(); this.cY = null; }
    // 	if(carrier)
    // 	{
    // 		this.cX = carrier.args.bindTo('x', v => this.args.x = v + carrier.args.direction * 12);
    // 		this.cY = carrier.args.bindTo('y', v => this.args.y = v + -12);

    // 		carrier.carrying.add(this);

    // 		this.args.float = -1;
    // 	}
    // 	else if(this.carriedBy)
    // 	{
    // 		const carrier = this.carriedBy;

    // 		this.carriedBy = null;

    // 		this.args.xSpeed = carrier.args.xSpeed;
    // 		this.args.ySpeed = carrier.args.ySpeed;

    // 		this.args.xSpeed += Math.sign(carrier.args.gSpeed || carrier.args.xSpeed) * 4;
    // 		this.args.ySpeed -= 4;

    // 		carrier.carrying.delete(this);

    // 		this.args.falling = true;
    // 		this.args.float = 0;
    // 	}
    // });
    return _this;
  }
  _createClass(EggShellTop, [{
    key: "update",
    value: function update() {
      this.args.startFrame = this.args.startFrame || this.viewport.args.frameId;
      if (this.viewport.args.frameId - this.args.startFrame > 90) {
        this.viewport.actors.remove(this);
        return;
      }
      _get(_getPrototypeOf(EggShellTop.prototype), "update", this).call(this);
    }

    // lift(actor)
    // {
    // 	if(this.carriedBy === actor)
    // 	{
    // 		this.carriedBy = null;

    // 		return;
    // 	}

    // 	this.carriedBy = actor;
    // }
  }, {
    key: "solid",
    get: function get() {
      return false;
    }
  }, {
    key: "sleep",
    value: function sleep() {
      this.viewport.actors.remove(this);
    }
  }]);
  return EggShellTop;
}(_PointActor2.PointActor);
exports.EggShellTop = EggShellTop;
});

;require.register("actor/EggShuttle.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EggShuttle = void 0;
var _Tag = require("curvature/base/Tag");
var _Vehicle2 = require("./Vehicle");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let EggShuttle = /*#__PURE__*/function (_Vehicle) {
  _inherits(EggShuttle, _Vehicle);
  var _super = _createSuper(EggShuttle);
  function EggShuttle() {
    var _this;
    _classCallCheck(this, EggShuttle);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.type = 'actor-item actor-vehicle actor-egg-shuttle';
    _this.args.accel = 0.15;
    _this.args.decel = 0.8;
    _this.args.gSpeedMax = 15;
    _this.args.xSpeedMax = 15;
    _this.args.ySpeedMax = 15;
    _this.args.jumpForce = 3;
    _this.args.gravity = 0.6;
    _this.args.width = 96;
    _this.args.height = 308;
    _this.args.yMargin = 42;
    _this.args.falling = true;
    _this.args.flying = true;
    _this.args.float = -1;
    _this.args.seatHeight = _this.args.height - 40;
    _this.args.seatForward = -16;
    _this.args.seatAngle = Math.PI / 2;
    _this.args.thrustAngle = -Math.PI / 2;
    _this.args.bindTo('boosting', v => {
      if (!_this.boost) {
        return;
      }
      ;
      _this.boost.setAttribute('data-active', !!v);
    });
    _this.args.crashAngle = 0;
    _this.args.bindTo('falling', v => {
      if (Math.abs(_this.args.groundAngle) < Math.PI / 4) {
        return;
      }
      _this.args.crashAngle = _this.args.groundAngle;
    });
    return _this;
  }
  _createClass(EggShuttle, [{
    key: "onRendered",
    value: function onRendered(event) {
      _get(_getPrototypeOf(EggShuttle.prototype), "onRendered", this).call(this, event);
      this.autoStyle.get(this.box)['--crash-angle'] = 'crashAngle';
    }
  }, {
    key: "updateStart",
    value: function updateStart() {
      _get(_getPrototypeOf(EggShuttle.prototype), "updateStart", this).call(this);
      if (this.args.falling) {
        this.args.groundAngle = -(this.args.thrustAngle + Math.PI / 2);
      }
    }
  }, {
    key: "updateEnd",
    value: function updateEnd() {
      _get(_getPrototypeOf(EggShuttle.prototype), "updateEnd", this).call(this);
      if (!this.args.falling) {
        this.args.groundAngle = 0;
      }
      if (this.args.crashAngle) {
        this.args.groundAngle = this.args.crashAngle;
        if (this.occupant) {
          const occupant = this.occupant;
          occupant.args.standingOn = false;
          occupant.args.falling = true;
          occupant.args.xSpeed = Math.sign(this.xSpeedLast) * 2;
          occupant.args.ySpeed = -12;
          occupant.args.y += -12;
        }
      }
    }
  }, {
    key: "update",
    value: function update() {
      if (this.sprite && !this.windshield) {
        this.windshield = new _Tag.Tag('<div class = "shuttle-windshield">');
        this.boost = new _Tag.Tag('<div class = "shuttle-boost">');
        this.sprite.appendChild(this.windshield.node);
        this.sprite.appendChild(this.boost.node);
      }
      if (this.occupant) {
        this.args.type = 'actor-item actor-vehicle actor-egg-shuttle actor-egg-shuttle-occupied';
        this.args.float = 1;
      } else {
        this.args.type = 'actor-item actor-vehicle actor-egg-shuttle';
        this.args.float = 0;
      }
      this.args.gSpeed = 0;
      this.args.facing = 'right';
      _get(_getPrototypeOf(EggShuttle.prototype), "update", this).call(this);
      if (this.args.falling) {
        this.args.cameraMode = 'rocket';

        // const maxBias = 0.06125;
        // this.args.cameraBias = Math.max(-maxBias, Math.min(maxBias, (this.args.ySpeed / this.args.ySpeedMax) * -maxBias));
        // console.log(this.args.cameraBias);

        this.args.thrustAngle += 0.02 * this.xAxis;
        if (this.args.thrustAngle < -Math.PI * 7 / 8) {
          this.args.thrustAngle = -Math.PI * 7 / 8;
        }
        if (this.args.thrustAngle > -Math.PI * 1 / 8) {
          this.args.thrustAngle = -Math.PI * 1 / 8;
        }
      } else {
        this.args.cameraMode = 'normal';
        this.args.cameraBias = 0;
        this.args.boosting = false;
        this.args.thrustAngle = -Math.PI / 2;
      }
    }
  }, {
    key: "processInputDirect",
    value: function processInputDirect() {}
  }, {
    key: "command_0",
    value: function command_0(button) {}
  }, {
    key: "release_0",
    value: function release_0(button) {
      this.args.boosting = false;
    }
  }, {
    key: "hold_0",
    value: function hold_0(button) {
      this.args.x += this.viewport.args.frameId % 2 ? -1 : 1;
      if (!this.args.falling && button.time < 60) {
        return;
      }
      this.args.falling = true;
      const impulse = this.args.gravity * (1 + 0.002 * Math.min(-60 + button.time, 150));
      this.args.xSpeed += impulse * Math.cos(this.args.thrustAngle);
      this.args.ySpeed += impulse * Math.sin(this.args.thrustAngle);
      if (Math.abs(this.args.xSpeed) > this.args.xSpeedMax) {
        this.args.xSpeed = this.args.xSpeedMax * Math.sign(this.args.xSpeed);
      }
      if (Math.abs(this.args.ySpeed) > this.args.ySpeedMax) {
        this.args.ySpeed = this.args.ySpeedMax * Math.sign(this.args.ySpeed);
      }
      this.args.boosting = true;
    }
  }, {
    key: "collideA",
    value: function collideA(other, type) {
      if (this.args.crashAngle) {
        return false;
      }
      _get(_getPrototypeOf(EggShuttle.prototype), "collideA", this).call(this, other, type);
    }
  }, {
    key: "solid",
    get: function get() {
      return !this.args.crashAngle && !this.occupant;
    }
  }]);
  return EggShuttle;
}(_Vehicle2.Vehicle);
exports.EggShuttle = EggShuttle;
});

;require.register("actor/EggTroid.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EggTroid = void 0;
var _PointActor = require("./PointActor");
var _Mixin = require("curvature/base/Mixin");
var _CanPop = require("../mixin/CanPop");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let EggTroid = /*#__PURE__*/function (_Mixin$from) {
  _inherits(EggTroid, _Mixin$from);
  var _super = _createSuper(EggTroid);
  function EggTroid(args, parent) {
    var _this;
    _classCallCheck(this, EggTroid);
    _this = _super.call(this, args, parent);
    _this.args.type = 'actor-item actor-eggtroid';
    _this.args.width = 40;
    _this.args.height = 25;
    _this.args.float = -1;
    _this.args.gravity = 0.5;
    _this.args.phase = 'idle';
    return _this;
  }
  _createClass(EggTroid, [{
    key: "update",
    value: function update() {
      if (!this.viewport || !this.viewport.actorIsOnScreen(this)) {
        return;
      }
      const viewport = this.viewport;
      if (this.args.animation !== 'diving') {
        this.args.xSpeed = 0.8 * Math.sign(Math.sin(this.age / 60));
      }
      _get(_getPrototypeOf(EggTroid.prototype), "update", this).call(this);
      if (!this.viewport) {
        return;
      }
      const mainChar = viewport.controlActor;
      if (!mainChar) {
        this.args.phase = 'idle';
        return;
      }
      this.args.facing = this.args.xSpeed > 0 ? 'left' : 'right';
      this.args.float = -1;
      const downPoint = this.castRayQuick(128, Math.PI / 2, [0, 0], false) || 128;
      if (downPoint) {
        const actors = this.viewport.actorsAtLine(this.args.x, this.args.y, this.args.x, this.args.y + downPoint);
        const actorList = [...actors.keys()];
        if (actors.size && actorList.filter(a => a !== this && a.controllable && !a.args.dead).length) {
          console.log(actorList.filter(a => a !== this && a.controllable));
          this.args.animation = 'diving';
          this.args.xSpeed = 0;
          this.args.ySpeed = 6;
          this.args.float = 0;
        } else {
          // this.args.animation = 'idle';
        }
      }
      if (!this.args.falling) {
        this.pop();
      }
    }
  }, {
    key: "solid",
    get: function get() {
      return false;
    }
  }, {
    key: "rotateLock",
    get: function get() {
      return true;
    }
  }]);
  return EggTroid;
}(_Mixin.Mixin.from(_PointActor.PointActor, _CanPop.CanPop));
exports.EggTroid = EggTroid;
});

;require.register("actor/EggWalker.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EggWalker = void 0;
var _Vehicle2 = require("./Vehicle");
var _Platformer = require("../behavior/Platformer");
var _Projectile = require("./Projectile");
var _Tag = require("curvature/base/Tag");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let EggWalker = /*#__PURE__*/function (_Vehicle) {
  _inherits(EggWalker, _Vehicle);
  var _super = _createSuper(EggWalker);
  function EggWalker() {
    var _this;
    _classCallCheck(this, EggWalker);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _defineProperty(_assertThisInitialized(_this), "instructions", []);
    _this.args.type = 'actor-item actor-egg-walker';
    _this.args.width = 32;
    _this.args.height = 64;
    _this.args.weight = 1500;
    _this.removeTimer = null;
    _this.args.gSpeedMax = 2.5;
    _this.args.decel = 0.05;
    _this.args.accel = 0.10;
    _this.args.seatHeight = 48;
    _this.args.jumpForce = 12;
    _this.args.skidTraction = 0.9;
    _this.dustCount = 0;
    _this.args.particleScale = 2;
    _this.args.bindTo('falling', v => {
      if (v || !_this.crouching || _this.ySpeedLast < 8) {
        return;
      }
      _this.viewport.args.shakeY = 7;
    });
    return _this;
  }
  _createClass(EggWalker, [{
    key: "onRendered",
    value: function onRendered(event) {
      _get(_getPrototypeOf(EggWalker.prototype), "onRendered", this).call(this, event);
      this.box = this.findTag('div');
      this.sprite = this.findTag('div.sprite');
      this.backSprite = new _Tag.Tag('<div class = "sprite-back sprite">');
      this.body = new _Tag.Tag('<div class = "egg-walker-body">');
      this.sprite.appendChild(this.body.node);
      this.punch = new _Tag.Tag('<div class = "egg-walker-punch">');
      this.sprite.appendChild(this.punch.node);
      this.legFront = new _Tag.Tag('<div class = "egg-walker-leg">');
      this.sprite.appendChild(this.legFront.node);
      this.boostFront = new _Tag.Tag('<div class = "egg-boost">');
      this.legFront.appendChild(this.boostFront.node);
      this.legBack = new _Tag.Tag('<div class = "egg-walker-leg egg-walker-leg-back">');
      this.backSprite.appendChild(this.legBack.node);
      this.boostBack = new _Tag.Tag('<div class = "egg-boost">');
      this.legBack.appendChild(this.boostBack.node);
      this.chair = new _Tag.Tag('<div class = "egg-walker-chair">');
      this.backSprite.appendChild(this.chair.node);
      this.gun = new _Tag.Tag('<div class = "egg-walker-gun">');
      this.backSprite.appendChild(this.gun.node);
      this.box.appendChild(this.backSprite.node);
    }
  }, {
    key: "update",
    value: function update() {
      _get(_getPrototypeOf(EggWalker.prototype), "update", this).call(this);
      if (this.boosting) {
        this.args.type = 'actor-item actor-egg-walker egg-walker-boosting';
        if (this.args.ySpeed > 0) {
          this.args.ySpeed -= 1.25 * ((Math.sin(this.viewport.args.frameId / 10) + 0.9) / 2) + 0.5;
        }
      } else {
        this.args.type = 'actor-item actor-egg-walker';
      }
      this.boosting = false;
      if (this.yAxis > 0.55 && (!this.xAxis || this.falling && this.args.ySpeed > 0)) {
        if (this.crouching) {
          this.args.y += 0.001;
          this.args.y -= 0.001;
        }
        if (this.args.falling && !this.crouching) {
          this.args.ySpeed += 4;
        }
        this.args.gSpeed = 0;
        this.args.animation = 'crouching';
        this.crouching = true;
        this.args.seatHeight = 30;
        this.args.height = 48;
      } else {
        if (!this.crouching) {
          this.args.y += 0.001;
          this.args.y -= 0.001;
        }
        this.crouching = false;
        this.args.seatHeight = 48;
        this.args.height = 64;
        if (this.args.falling) {
          this.args.animation = 'falling';
        } else if (Math.sign(this.args.gSpeed) === this.args.direction) {
          this.args.animation = 'walking';
        } else {
          this.args.animation = 'standing';
        }
      }
    }
  }, {
    key: "hold_0",
    value: function hold_0() {
      const below = this.bMap('checkBelow', this.x, this.y + 1).get(_Platformer.Platformer);
      if (!this.args.falling && this.args.ySpeed < 0 || below) {
        return;
      }
      if (this.yAxis > 0.55) {
        return;
      }
      this.boosting = true;
    }
  }, {
    key: "hold_2",
    value: function hold_2() {
      if (this.shooting) {
        return;
      }
      let offset, trajectory, spotAngle;
      const direction = Math.sign(this.args.direction);
      const groundAngle = this.args.groundAngle;
      switch (this.args.mode) {
        case 0:
          spotAngle = -groundAngle - Math.PI / 2 + Math.PI / 4 * direction;
          trajectory = -groundAngle;
          break;
        case 1:
          spotAngle = -groundAngle + Math.PI / 4 * direction;
          trajectory = -groundAngle + Math.PI / 2;
          break;
        case 2:
          spotAngle = -groundAngle + Math.PI / 2 + Math.PI / 4 * direction;
          trajectory = -groundAngle - Math.PI;
          break;
        case 3:
          spotAngle = -groundAngle - Math.PI + Math.PI / 4 * direction;
          trajectory = -groundAngle - Math.PI / 2;
          break;
      }
      offset = [32 * Math.cos(spotAngle), 120 * Math.sin(spotAngle)];

      // if(this.args.falling || this.args.crouching)
      // {
      // 	trajectory = 0;
      // 	offset = [-16 * direction, -96];
      // }

      const projectile = new _Projectile.Projectile({
        direction: this.args.direction,
        x: this.args.x + offset[0] + (this.args.xSpeed || this.args.gSpeed),
        y: this.args.y + offset[1] - (this.crouching ? -20 : 0),
        owner: this,
        xSpeed: this.args.xSpeed || this.args.gSpeed || this.args.direction
        // , ySpeed: this.args.ySpeed
        ,
        float: 10,
        strength: 2
      });
      projectile.impulse(8, trajectory + (direction < 0 ? Math.PI : 0), true);
      this.viewport.spawn.add({
        object: projectile
      });
      this.viewport.auras.add(projectile);
      projectile.update();
      this.box.setAttribute('data-shoot', 'true');
      this.shooting = true;
      this.viewport.onFrameOut(1, () => {
        this.box.setAttribute('data-shoot', 'false');
      });
      this.viewport.onFrameOut(6, () => {
        this.shooting = false;
      });
    }
  }, {
    key: "command_0",
    value: function command_0() {
      if (!this.crouching) {
        _get(_getPrototypeOf(EggWalker.prototype), "command_0", this).call(this);
      }
    }
  }, {
    key: "command_1",
    value: function command_1() {
      if (this.punching) {
        return;
      }
      this.box.setAttribute('data-punch', 'true');
      this.punching = true;
      this.viewport.onFrameOut(12, () => {
        this.box.setAttribute('data-punch', 'false');
      });
      this.viewport.onFrameOut(25, () => {
        this.punching = false;
      });
    }
  }, {
    key: "solid",
    get: function get() {
      return !this.occupant;
    }
  }]);
  return EggWalker;
}(_Vehicle2.Vehicle);
exports.EggWalker = EggWalker;
});

;require.register("actor/Eggman.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Eggman = void 0;
var _PointActor2 = require("./PointActor");
var _Tag = require("curvature/base/Tag");
var _SkidDust = require("../behavior/SkidDust");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let Eggman = /*#__PURE__*/function (_PointActor) {
  _inherits(Eggman, _PointActor);
  var _super = _createSuper(Eggman);
  function Eggman() {
    var _this;
    _classCallCheck(this, Eggman);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.behaviors.add(new _SkidDust.SkidDust());
    _this.args.type = 'actor-item actor-eggman';
    _this.accelNormal = 0.15;
    _this.accelSuper = 0.30;
    _this.args.weight = 200;
    _this.args.accel = 0.15;
    _this.args.decel = 0.3;
    _this.args.normalHeight = 40;
    _this.args.rollingHeight = 28;
    _this.gSpeedMaxNormal = 18;
    _this.gSpeedMaxSuper = 28;
    _this.args.gSpeedMax = _this.gSpeedMaxNormal;
    _this.args.normalHeight = 57;
    _this.args.rollingHeight = 29;
    _this.jumpForceNormal = 11;
    _this.jumpForceSuper = 18;
    _this.args.jumpForce = _this.jumpForceNormal;
    _this.args.gravity = 0.5;
    _this.args.width = 18;
    _this.args.height = 57;
    _this.args.lookingUp = false;
    _this.args.spriteSheet = _this.spriteSheet = '/Sonic/eggman.png';
    _this.superSpriteSheet = '/Sonic/eggman-super.png';
    return _this;
  }
  _createClass(Eggman, [{
    key: "onRendered",
    value: function onRendered(event) {
      _get(_getPrototypeOf(Eggman.prototype), "onRendered", this).call(this, event);
      this.box = this.findTag('div');
    }
  }, {
    key: "updateStart",
    value: function updateStart() {
      if (this.args.grinding && this.args.falling && this.args.ySpeed > 0) {
        this.args.animation = 'airdash';
        this.args.grinding = false;
      }
      _get(_getPrototypeOf(Eggman.prototype), "updateStart", this).call(this);
      if (this.args.dead) {
        this.args.animation = 'dead';
        return;
      }
    }
  }, {
    key: "update",
    value: function update() {
      const falling = this.args.falling;
      if (!this.box) {
        _get(_getPrototypeOf(Eggman.prototype), "update", this).call(this);
        return;
      } else if (this.yAxis > 0.5 && !this.args.ignore) {
        this.args.crouching = true;
        this.args.lookTime--;
        if (this.args.lookTime < -45) {
          this.args.cameraBias = -0.5;
        }
      } else if (this.yAxis < -0.5 && !this.args.ignore) {
        this.args.lookingUp = true;
        this.args.lookTime++;
        if (this.args.lookTime > 45) {
          this.args.cameraBias = 0.25;
        }
      } else {
        this.args.lookingUp = this.args.crouching = false;
      }
      const direction = this.args.direction;
      const gSpeed = this.args.gSpeed;
      const speed = Math.abs(gSpeed);
      const maxSpeed = this.args.gSpeedMax;
      if (falling) {
        if (this.args.jumping) {
          this.args.animation = 'jumping';
        }
        this.args.height = this.args.rollingHeight;
      } else if (this.args.rolling) {
        this.args.height = this.args.rollingHeight;
        if (this.args.direction !== Math.sign(this.args.gSpeed)) {
          this.args.direction = Math.sign(this.args.gSpeed);
          if (this.args.direction < 0) {
            this.args.facing = 'left';
          } else {
            this.args.facing = 'right';
          }
        }
        this.args.animation = 'rolling';
      } else {
        this.args.height = this.args.normalHeight;
        if (Math.sign(this.args.gSpeed) !== direction && Math.abs(this.args.gSpeed - direction) > 5) {
          this.args.animation = 'skidding';
        } else if (speed > maxSpeed / 2) {
          this.args.animation = 'running';
        } else if (this.args.moving && gSpeed) {
          this.args.animation = 'walking';
        } else if (this.args.lookingUp) {
          this.args.animation = 'lookingUp';
        } else if (this.args.crouching || this.args.standingOn && this.args.standingOn.isVehicle) {
          this.args.animation = 'crouching';
        } else {
          this.args.animation = 'standing';
        }
      }
      if (this.args.hangingFrom) {
        this.args.animation = 'hanging';
      }
      if (this.args.grinding) {
        this.args.rolling = false;
        if (this.yAxis > 0.5) {
          this.args.animation = 'grinding-crouching';
        } else {
          this.args.animation = 'grinding';
        }
      }
      _get(_getPrototypeOf(Eggman.prototype), "update", this).call(this);
    }
  }, {
    key: "command_3",
    value: function command_3() {
      this.isSuper = !this.isSuper;
      this.onTimeout(150, () => {
        if (this.args.rings === 0) {
          // this.isSuper = false;
          this.setProfile();
        }
        ;
      });
      this.setProfile();
    }
  }, {
    key: "setProfile",
    value: function setProfile() {
      if (this.isSuper) {
        this.args.spriteSheet = this.superSpriteSheet;
        this.args.gSpeedMax = this.gSpeedMaxSuper;
        this.args.jumpForce = this.jumpForceSuper;
        this.args.accel = this.accelSuper;
      } else {
        this.args.spriteSheet = this.spriteSheet;
        this.args.gSpeedMax = this.gSpeedMaxNormal;
        this.args.jumpForce = this.jumpForceNormal;
        this.args.accel = this.accelNormal;
      }
    }
  }, {
    key: "solid",
    get: function get() {
      return false;
    }
  }, {
    key: "canRoll",
    get: function get() {
      return true;
    }
  }, {
    key: "isEffect",
    get: function get() {
      return false;
    }
  }, {
    key: "controllable",
    get: function get() {
      return true;
    }
  }], [{
    key: "fromDef",
    value: function fromDef(objDef) {
      const instance = _get(_getPrototypeOf(Eggman), "fromDef", this).call(this, objDef);
      instance.args.name = 'Robotnik';
      return instance;
    }
  }]);
  return Eggman;
}(_PointActor2.PointActor);
exports.Eggman = Eggman;
});

;require.register("actor/Eggrobo.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Eggrobo = void 0;
var _PointActor2 = require("./PointActor");
var _Projectile = require("./Projectile");
var _Tag = require("curvature/base/Tag");
var _SkidDust = require("../behavior/SkidDust");
var _Sfx = require("../audio/Sfx");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let Eggrobo = /*#__PURE__*/function (_PointActor) {
  _inherits(Eggrobo, _PointActor);
  var _super = _createSuper(Eggrobo);
  function Eggrobo() {
    var _this;
    _classCallCheck(this, Eggrobo);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.behaviors.add(new _SkidDust.SkidDust());
    _this.args.type = 'actor-item actor-eggrobo';
    _this.args.accel = 0.125;
    _this.args.decel = 0.3;
    _this.args.gSpeedMax = 14;
    _this.args.jumpForce = 11;
    _this.args.gravity = 0.5;
    _this.args.width = 18;
    _this.args.height = 57;
    return _this;
  }
  _createClass(Eggrobo, [{
    key: "onRendered",
    value: function onRendered(event) {
      _get(_getPrototypeOf(Eggrobo.prototype), "onRendered", this).call(this, event);
      this.box = this.findTag('div');
      this.sprite = this.findTag('div.sprite');
      this.flame = new _Tag.Tag('<div class = "eggrobo-flame">');
      this.muzzleFlash = new _Tag.Tag('<div class = "eggrobo-muzzle-flash">');
      this.sprite.appendChild(this.flame.node);
      this.sprite.appendChild(this.muzzleFlash.node);
    }
  }, {
    key: "update",
    value: function update() {
      const falling = this.args.falling;
      if (this.viewport.args.audio && !this.thrusterSound) {
        this.thrusterSound = new Audio('/Sonic/mecha-sonic-thruster.wav');
        this.thrusterSound.loop = true;
      }
      if (this.thrusterSound) {
        if (this.thrusterSound.currentTime > 0.4 + Math.random() / 10) {
          this.thrusterSound.currentTime = 0.05;
        }
        this.thrusterSound.volume = 0.2 + Math.random() * -0.05;
      }
      if (!this.box) {
        _get(_getPrototypeOf(Eggrobo.prototype), "update", this).call(this);
        return;
      }
      if (!falling) {
        if (this.yAxis > 0) {
          this.args.crouching = true;
        } else {
          this.args.crouching = false;
        }
        const direction = this.args.direction;
        const gSpeed = this.args.gSpeed;
        const speed = Math.abs(gSpeed);
        const maxSpeed = this.args.gSpeedMax;
        if (Math.sign(this.args.gSpeed) !== direction && Math.abs(this.args.gSpeed - direction) > 5) {
          this.thrusterSound && this.thrusterSound.pause();
          this.box.setAttribute('data-animation', 'skidding');
        } else if (speed > maxSpeed / 2) {
          this.thrusterSound && this.thrusterSound.pause();
          this.box.setAttribute('data-animation', 'running');
        } else if (this.args.moving && gSpeed) {
          this.box.setAttribute('data-animation', 'walking');
        } else if (this.args.crouching || this.standingOn && this.standingOn.isVehicle) {
          this.box.setAttribute('data-animation', 'crouching');
        } else {
          this.box.setAttribute('data-animation', 'standing');
        }
      } else {
        this.args.crouching = false;
        if (this.args.jumping) {
          this.box.setAttribute('data-animation', 'jumping');
        }
      }
      if (!this.args.falling) {
        this.args.flying = false;
      }
      if (this.args.flying) {
        this.box.setAttribute('data-animation', 'flying');
      } else if (this.args.falling) {
        this.box.setAttribute('data-animation', 'jumping');
      }
      if (this.args.shotCoolDown > 0) {
        this.args.shotCoolDown--;
      }
      if (this.args.rocketCoolDown == 0) {
        this.thrusterSound && this.thrusterSound.pause();
      }
      if (this.args.rocketCoolDown > 0) {
        this.args.rocketCoolDown--;
      }
      if (this.args.rocketCoolDown == 0) {
        this.args.flying = false;
      }
      _get(_getPrototypeOf(Eggrobo.prototype), "update", this).call(this);
    }
  }, {
    key: "solid",
    get: function get() {
      return false;
    }
  }, {
    key: "isEffect",
    get: function get() {
      return false;
    }
  }, {
    key: "hold_0",
    value: function hold_0() {
      if (!this.args.falling) {
        this.args.rocketCoolDown = 5;
        return;
      }
      if (this.args.ySpeed > 1 || this.args.flying) {
        this.args.flying = true;
        if (this.args.rocketCoolDown <= 1) {
          this.thrusterSound && this.thrusterSound.play();
          this.args.rocketCoolDown = 3;
        }
        this.args.ySpeed = this.args.ySpeed * 0.999;
        this.args.float = 3;
      }
    }
  }, {
    key: "hold_2",
    value: function hold_2() {
      if (this.args.shotCoolDown > 0) {
        return;
      }
      const direction = Math.sign(this.args.direction);
      const groundAngle = this.args.groundAngle;
      let offset, trajectory, spotAngle;
      switch (this.args.mode) {
        case 0:
          spotAngle = -groundAngle - Math.PI / 2 + Math.PI / 4 * direction;
          trajectory = -groundAngle;
          break;
        case 1:
          spotAngle = -groundAngle + Math.PI / 4 * direction;
          trajectory = -groundAngle + Math.PI / 2;
          break;
        case 2:
          spotAngle = -groundAngle + Math.PI / 2 + Math.PI / 4 * direction;
          trajectory = -groundAngle - Math.PI;
          break;
        case 3:
          spotAngle = -groundAngle - Math.PI + Math.PI / 4 * direction;
          trajectory = -groundAngle - Math.PI / 2;
          break;
      }
      offset = [50 * Math.cos(spotAngle), 50 * Math.sin(spotAngle)];
      if (this.args.falling || this.args.crouching) {
        trajectory = 0;
        offset = [26 * direction, -26];
      }
      const projectile = new _Projectile.Projectile({
        direction: this.args.direction,
        x: this.args.x + offset[0] + (this.args.xSpeed || this.args.gSpeed),
        y: this.args.y + offset[1],
        owner: this,
        xSpeed: this.args.xSpeed || this.args.gSpeed,
        YSpeed: this.args.YSpeed
      });
      projectile.impulse(20, trajectory + (direction < 0 ? Math.PI : 0), true);
      projectile.update();
      this.viewport.auras.add(projectile);
      this.viewport.spawn.add({
        object: projectile
      });
      this.box.setAttribute('data-shooting', 'true');
      this.onTimeout(140, () => {
        this.box.setAttribute('data-shooting', 'false');
      });
      _Sfx.Sfx.play('SHOT_FIRED');
      this.args.shotCoolDown = 4;
    }
  }, {
    key: "canFly",
    get: function get() {
      return true;
    }
  }, {
    key: "controllable",
    get: function get() {
      return true;
    }
  }]);
  return Eggrobo;
}(_PointActor2.PointActor);
exports.Eggrobo = Eggrobo;
});

;require.register("actor/Emblem.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Emblem = void 0;
var _PointActor2 = require("./PointActor");
var _Tag = require("curvature/base/Tag");
var _Sfx = require("../audio/Sfx");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let Emblem = /*#__PURE__*/function (_PointActor) {
  _inherits(Emblem, _PointActor);
  var _super = _createSuper(Emblem);
  function Emblem() {
    var _this$args$character;
    var _this;
    _classCallCheck(this, Emblem);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.width = 32;
    _this.args.height = 32;
    _this.args.type = 'actor-item actor-emblem';
    _this.args.float = -1;
    _this.args.static = true;
    _this.collected = false;
    _this.args.character = (_this$args$character = _this.args.character) !== null && _this$args$character !== void 0 ? _this$args$character : 'sonic';
    return _this;
  }
  _createClass(Emblem, [{
    key: "onRendered",
    value: function onRendered(event) {
      if (!this.viewport) {
        return _get(_getPrototypeOf(Emblem.prototype), "onRendered", this).call(this, event);
      }
      const zoneState = this.viewport.getZoneState();
      if (zoneState && zoneState.emblems && zoneState.emblems.includes(this.oid)) {
        if (!this.viewport.replay) {
          this.args.type = 'actor-item actor-emblem actor-emblem-collected';
          this.collected = true;
        }
      }
      _get(_getPrototypeOf(Emblem.prototype), "onRendered", this).call(this, event);
      this.autoAttr.get(this.box)['data-character'] = 'character';
    }
  }, {
    key: "collideA",
    value: function collideA(other) {
      if (!other.controllable || this.gone) {
        return;
      }
      const viewport = this.viewport;
      const zoneState = viewport.getZoneState();
      other.args.emblemsCurrent.push(this);
      if (!this.collected) {
        other.args.emblems.push(this);
        zoneState.emblems.push(this.oid);
        this.args.type = 'actor-item actor-emblem actor-emblem-gone';
      } else {
        this.args.type = 'actor-item actor-emblem actor-emblem-gone actor-emblem-collected';
      }
      const scoreNode = document.createElement('div');
      scoreNode.classList.add('particle-score');
      const scoreTag = new _Tag.Tag(scoreNode);
      scoreTag.style({
        '--x': this.args.x,
        '--y': this.args.y - 16
      });
      let points;
      switch (other.args.emblemsCurrent && other.args.emblemsCurrent.length) {
        case 1:
          scoreNode.classList.add('score-100');
          points = 100;
          break;
        case 2:
          scoreNode.classList.add('score-200');
          points = 200;
          break;
        case 3:
          scoreNode.classList.add('score-500');
          points = 500;
          break;
        case 4:
          scoreNode.classList.add('score-1000');
          points = 1000;
          break;
        case 5:
          scoreNode.classList.add('score-10000');
          points = 10000;
          break;
      }
      viewport.particles.add(scoreTag);
      setTimeout(() => viewport.particles.remove(scoreTag), 768);
      other.args.score += points;
      this.gone = true;
      viewport.onFrameOut(20, () => viewport.actors.remove(this));
      this.viewport.args.inventory.push({
        tallyIcon: '/custom/hud-emblem.png',
        points: 1000,
        id: this.oid
      });
      viewport.currentSave.save();
      if (this.viewport.args.audio) {
        _Sfx.Sfx.play('EMBLEM_COLLECTED');
      }
      if (typeof ga === 'function') {
        ga('send', 'event', {
          eventCategory: 'emblem',
          eventAction: 'collected',
          eventLabel: `${this.viewport.args.actName}::${this.oid}`
        });
      }
    }
  }]);
  return Emblem;
}(_PointActor2.PointActor);
exports.Emblem = Emblem;
});

;require.register("actor/Emerald.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Emerald = void 0;
var _PointActor2 = require("./PointActor");
var _Sfx = require("../audio/Sfx");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let Emerald = /*#__PURE__*/function (_PointActor) {
  _inherits(Emerald, _PointActor);
  var _super = _createSuper(Emerald);
  function Emerald() {
    var _this;
    _classCallCheck(this, Emerald);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.type = 'actor-item actor-emerald emerald-' + (_this.args.color || 'white');
    _this.args.width = 12;
    _this.args.height = 12;
    return _this;
  }

  // update()
  // {
  // 	super.update();

  // 	const viewport = this.viewport;

  // 	if(!viewport)
  // 	{
  // 		return;
  // 	}
  // }
  _createClass(Emerald, [{
    key: "collideA",
    value: function collideA(other) {
      _get(_getPrototypeOf(Emerald.prototype), "collideA", this).call(this, other);
      if (this.args.gone || !other.controllable) {
        return;
      }
      this.args.type = 'actor-item actor-emerald collected emerald-' + (this.args.color || 'white');
      if (!this.args.gone) {
        _Sfx.Sfx.play('EMERALD_COLLECTED');
        this.args.type = 'actor-item actor-emerald collected gone emerald-' + (this.args.color || 'white');
        if (other.args.owner) {
          other.args.owner.args.emeralds += 1;
        } else if (other.occupant) {
          other.occupant.args.emeralds += 1;
        } else {
          other.args.emeralds += 1;
        }
        if (!this.viewport.args.emeralds.includes(this.args.color)) {
          this.viewport.args.emeralds.push(this.args.color);
        }
        const save = viewport.currentSave;
        if (!save.emeralds.includes(this.args.color)) {
          save.emeralds.push(this.args.color);
        }
        this.viewport.args.inventory.push({
          points: 10000,
          tallyIcon: `/Sonic/emerald-${this.args.color}-mini.png`,
          id: this.oid
        });
        save.save();
        ga('send', 'event', {
          eventCategory: 'chaos-emerald',
          eventAction: 'collected',
          eventLabel: `${this.viewport.args.actName}::${this.args.color}::${this.args.id}`
        });
        this.viewport.actors.remove(this);
        this.remove();
      }
      this.args.gone = true;
    }
  }, {
    key: "solid",
    get: function get() {
      return false;
    }
  }, {
    key: "effect",
    get: function get() {
      return true;
    }
  }]);
  return Emerald;
}(_PointActor2.PointActor);
exports.Emerald = Emerald;
});

;require.register("actor/Explosion.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Explosion = void 0;
var _PointActor2 = require("./PointActor");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let Explosion = /*#__PURE__*/function (_PointActor) {
  _inherits(Explosion, _PointActor);
  var _super = _createSuper(Explosion);
  function Explosion() {
    var _this;
    _classCallCheck(this, Explosion);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _defineProperty(_assertThisInitialized(_this), "float", -1);
    _this.args.type = 'actor-item actor-explosion';
    _this.args.width = 48;
    _this.args.height = 48;
    _this.removeTimer = null;
    return _this;
  }
  _createClass(Explosion, [{
    key: "update",
    value: function update() {
      _get(_getPrototypeOf(Explosion.prototype), "update", this).call(this);
      if (!this.removeTimer) {
        const viewport = this.viewport;
        this.removeTimer = this.onTimeout(360, () => {
          // viewport.actors.remove( this );
        });
      }
    }
  }, {
    key: "solid",
    get: function get() {
      return false;
    }
  }, {
    key: "isEffect",
    get: function get() {
      return false;
    }
  }]);
  return Explosion;
}(_PointActor2.PointActor);
exports.Explosion = Explosion;
});

;require.register("actor/FakeEmerald.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FakeEmerald = void 0;
var _BreakableBlock2 = require("./BreakableBlock");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let FakeEmerald = /*#__PURE__*/function (_BreakableBlock) {
  _inherits(FakeEmerald, _BreakableBlock);
  var _super = _createSuper(FakeEmerald);
  function FakeEmerald() {
    var _this;
    _classCallCheck(this, FakeEmerald);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.width = 64;
    _this.args.height = 34;
    _this.args.type = 'actor-item actor-breakable-block actor-fake-emerald';
    _this.args.z = 128;
    _this.args.float = -1;
    _this.breakable = false;
    return _this;
  }
  _createClass(FakeEmerald, [{
    key: "updateStart",
    value: function updateStart() {}
  }, {
    key: "update",
    value: function update() {
      _get(_getPrototypeOf(FakeEmerald.prototype), "update", this).call(this);
      if (this.switch && this.switch.args.active) {
        this.breakable = true;
      }
    }
  }, {
    key: "collideA",
    value: function collideA(other, type) {
      if (!this.breakable) {
        return false;
      }
      return _get(_getPrototypeOf(FakeEmerald.prototype), "collideA", this).call(this, other, type);
    }
  }, {
    key: "solid",
    get: function get() {
      return this.breakable;
    }
  }]);
  return FakeEmerald;
}(_BreakableBlock2.BreakableBlock);
exports.FakeEmerald = FakeEmerald;
});

;require.register("actor/Flag.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Flag = void 0;
var _PointActor2 = require("./PointActor");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let Flag = /*#__PURE__*/function (_PointActor) {
  _inherits(Flag, _PointActor);
  var _super = _createSuper(Flag);
  function Flag() {
    var _this;
    _classCallCheck(this, Flag);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.width = 45;
    _this.args.height = 53;
    _this.args.type = 'actor-item actor-flag';
    _this.args.z = 0;
    return _this;
  }
  _createClass(Flag, [{
    key: "solid",
    get: function get() {
      return false;
    }
  }]);
  return Flag;
}(_PointActor2.PointActor);
exports.Flag = Flag;
});

;require.register("actor/Flickie.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Flickie = void 0;
var _Follower2 = require("./Follower");
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let Flickie = /*#__PURE__*/function (_Follower) {
  _inherits(Flickie, _Follower);
  var _super = _createSuper(Flickie);
  function Flickie(args, parent) {
    var _this;
    _classCallCheck(this, Flickie);
    _this = _super.call(this, args, parent);
    _this.args.type = 'actor-item actor-flickie';
    _this.args.palletShift = Math.floor(Math.random() * 8);
    return _this;
  }
  return _createClass(Flickie);
}(_Follower2.Follower);
exports.Flickie = Flickie;
});

;require.register("actor/Flipper.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Flipper = void 0;
var _PointActor2 = require("./PointActor");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let Flipper = /*#__PURE__*/function (_PointActor) {
  _inherits(Flipper, _PointActor);
  var _super = _createSuper(Flipper);
  function Flipper(args, parent) {
    var _this$args$power;
    var _this;
    _classCallCheck(this, Flipper);
    _this = _super.call(this, args, parent);
    _this.args.width = 64;
    _this.args.height = 48;
    _this.noClip = true;
    _this.args.float = -1;
    _this.args.direction = _this.args.direction || 1;
    _this.args.power = (_this$args$power = _this.args.power) !== null && _this$args$power !== void 0 ? _this$args$power : 12;
    _this.args.type = 'actor-item actor-flipper';
    _this.args.bindTo('direction', v => _this.args.type = v < 0 ? 'actor-item actor-flipper actor-flipper-right' : 'actor-item actor-flipper actor-flipper-left');
    _this.flipped = new WeakSet();
    return _this;
  }
  _createClass(Flipper, [{
    key: "collideA",
    value: function collideA(other, type) {
      if (other.y <= this.y - this.args.height) {
        return;
      }
      if (this.flipped.has(other)) {
        return;
      }
      const leftBound = this.x - this.args.direction * this.args.width;
      other.args.rolling = true;
      other.willJump = false;

      // if(other.x < leftBound + (this.args.width / 3))
      // {
      // 	other.args.gSpeed = 2;
      // }

      if (other.buttons[0] && other.buttons[0].time === 1) {
        // const rounded = this.roundAngle(-other.args.groundAngle + -Math.PI/2, 16, true);
        const rounded = -other.args.groundAngle + -Math.PI / 2;
        this.args.animation = 'flipping';
        other.args.xSpeed = 0;
        other.args.ySpeed = 0;
        other.args.gSpeed = 0;
        const flipFactor = (other.x - leftBound) / this.args.width * 0.5;
        const flipMagnitude = flipFactor * this.args.direction;
        other.impulse(this.args.power * flipMagnitude, rounded, true);
        const xImpulse = Number(Number(Math.cos(rounded) * 1).toFixed(3));
        const yImpulse = Number(Number(Math.sin(rounded) * 1).toFixed(3));
        other.args.y += -4;
        other.args.xSpeed = xImpulse;
        other.args.ySpeed = yImpulse;
        other.args.falling = true;
        this.viewport.onFrameOut(3, () => this.args.animation = 'unflipping');
        other.args.jumping = false;
        other.args.falling = true;
        this.flipped.add(other);
        this.viewport.onFrameOut(1, () => other.willJump = false);
        this.viewport.onFrameOut(3, () => other.args.jumping = false);
        this.viewport.onFrameOut(5, () => this.flipped.delete(other));
        return;
      }
      if (Math.abs(other.args.gSpeed) < 3) {
        other.args.gSpeed = Math.min(2, Math.abs(other.args.gSpeed) || 1) * Math.sign(other.args.gSpeed || this.args.direction);
      } else {
        other.args.gSpeed *= 0.5;
      }
    }
  }]);
  return Flipper;
}(_PointActor2.PointActor);
exports.Flipper = Flipper;
});

;require.register("actor/Follower.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Follower = void 0;
var _PointActor2 = require("./PointActor");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let Follower = /*#__PURE__*/function (_PointActor) {
  _inherits(Follower, _PointActor);
  var _super = _createSuper(Follower);
  function Follower(args, parent) {
    var _this;
    _classCallCheck(this, Follower);
    _this = _super.call(this, args, parent);
    _defineProperty(_assertThisInitialized(_this), "noClip", 1);
    _this.args.isGhost = true;
    _this.args.type = 'actor-item actor-follower';
    _this.args.float = -1;
    _this.args.width = 16;
    _this.args.height = 16;
    _this.stopSwapZ = 0;
    _this.args.z = -1;
    return _this;
  }
  _createClass(Follower, [{
    key: "update",
    value: function update() {
      _get(_getPrototypeOf(Follower.prototype), "update", this).call(this);
      if (this.stopSwapZ > 0) {
        this.stopSwapZ--;
      }
      this.args.standingOn = false;
      const host = this.viewport.controlActor;
      if (!host) {
        return;
      }
      this.args.falling = true;
      this.args.float = -1;
      const force = Math.random();
      let fudge = Math.random();
      const xDiff = host.x + -this.x;
      const yDiff = host.y + -this.y;
      const angle = Math.atan2(yDiff, xDiff);
      const distance = Math.hypot(yDiff, xDiff);
      const maxDistance = 256;
      const minDistance = 64;
      let minSpeed = 1;
      const airSpeed = Math.max(Math.abs(host.args.gSpeed), Math.abs(host.args.xSpeed), Math.abs(host.args.ySpeed), minSpeed) * 1.1;
      const xSpeedRelativeOriginal = this.args.xSpeed - (host.args.xSpeed || host.args.gSpeed);
      let maxSpeed = airSpeed + 3;
      let facing = null;
      if (distance < minDistance) {
        if (Math.abs(this.args.xSpeed) < minSpeed) {
          this.args.xSpeed = minSpeed * Math.sign(-0.5 + Math.random());
        }
        if (Math.abs(this.args.ySpeed) < minSpeed) {
          this.args.ySpeed = minSpeed * Math.sign(-0.5 + Math.random());
        }
      } else if (distance >= maxDistance) {
        this.args.x = Math.floor(host.x - Math.cos(angle) * maxDistance);
        this.args.y = Math.floor(host.y - Math.sin(angle) * maxDistance);
        this.args.xSpeed = xDiff / 60 + (host.args.xSpeed || host.args.gSpeed);
        this.args.ySpeed = 0;
        this.viewport.setColCell(this);
        if (this.x > host.x) {
          facing = 'left';
        } else {
          facing = 'right';
        }
        maxSpeed *= 4;
      } else {}
      const xDir = Math.sign(xDiff);
      const yDir = Math.sign(yDiff);
      const xSame = Math.sign(this.args.xSpeed) === xDir;
      const ySame = this.args.ySpeed && Math.sign(this.args.ySpeed) === yDir;
      const xMag = Math.max(force) * 0.35 * (xSame ? 0.85 : 0.55);
      const yMag = Math.max(force) * 0.10 * (xSame ? 0.75 : 1.50);
      if (!xSame || Math.abs(this.args.xSpeed) < maxSpeed) {
        const step = xMag * xDir * fudge;

        // if(!this.swapZ && this.args.xSpeed && Math.sign(this.args.xSpeed) !== Math.sign(step))
        // {
        // 	this.swapZ = this.viewport.onFrameOut(1, () => {

        // 		this.swapZ = false;
        // 	})
        // }

        let xSpeed = this.args.xSpeed + step;
        if (Math.abs(this.args.xSpeed) > maxSpeed) {
          xSpeed = maxSpeed * Math.sign(this.args.xSpeed);
        }
        this.args.xSpeed = xSpeed;
        if (distance >= maxDistance) {
          const xSpeed = host.args.xSpeed || host.args.gSpeed;
          const ySpeed = host.args.ySpeed;
          if (facing) {
            this.args.xSpeed = xDiff / 90 + xSpeed;
            this.args.ySpeed = yDiff / 90 + ySpeed;
          }
        }
      }
      if (!facing && this.args.xSpeed < 0) {
        facing = 'left';
      } else if (!facing) {
        facing = 'right';
      }
      if (!ySame || Math.abs(this.args.ySpeed) < maxSpeed) {
        let ySpeed = this.args.ySpeed + yMag * yDir;
        if (Math.abs(this.args.ySpeed) > maxSpeed) {
          ySpeed = maxSpeed * Math.sign(this.args.ySpeed);
        }
        this.args.ySpeed = ySpeed;
      }
      if (Math.sign(xSpeedRelativeOriginal) && Math.sign(host.args.xSpeed || host.args.gSpeed) !== Math.sign(xSpeedRelativeOriginal) && this.stopSwapZ === 0) {
        if (Math.abs(this.x - host.x) > minDistance || Math.abs(this.y - host.y) > minDistance) {
          this.args.z = this.args.z > -1000 ? -100000 : 100000;
          this.stopSwapZ = 30;
        }
      }
      if (facing) {
        this.args.facing = facing;
      }
      if (this.args.ySpeed > 0) {
        if (this.args.ySpeed <= 0 || airSpeed < 1.5) {
          return;
        }
        if (this.box) {
          this.box.classList.add('decending');
          this.box.classList.remove('ascending');
        }
      } else if (this.box) {
        this.box.classList.remove('decending');
        this.box.classList.add('ascending');
      }
    }
  }, {
    key: "solid",
    get: function get() {
      return false;
    }
    // get isGhost() { return true; }
  }]);
  return Follower;
}(_PointActor2.PointActor);
exports.Follower = Follower;
});

;require.register("actor/Fountain.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Fountain = void 0;
var _PointActor2 = require("./PointActor");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let Fountain = /*#__PURE__*/function (_PointActor) {
  _inherits(Fountain, _PointActor);
  var _super = _createSuper(Fountain);
  function Fountain() {
    var _this;
    _classCallCheck(this, Fountain);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.width = 72;
    _this.args.height = 120;
    _this.args.float = -1;
    _this.args.type = 'actor-item actor-fountain';
    return _this;
  }
  _createClass(Fountain, [{
    key: "collideA",
    value: function collideA(other) {
      if (!other.controllable || !other.args.falling) {
        return;
      }
      if (other.y > this.y + -this.args.height * 0.5) {
        other.args.x = this.x;
      }
      if (other.args.ySpeed > 0) {
        other.args.ySpeed *= 0.75;
      }
      if (other.args.ySpeed > -20 && Math.abs(this.x - other.x) < 8) {
        other.args.ySpeed -= 0.4;
      }
    }
  }, {
    key: "solid",
    get: function get() {
      return false;
    }
  }]);
  return Fountain;
}(_PointActor2.PointActor);
exports.Fountain = Fountain;
});

;require.register("actor/Gator.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Gator = void 0;
var _Flickie = require("./Flickie");
var _Mixin = require("curvature/base/Mixin");
var _PointActor = require("./PointActor");
var _Patrol = require("../behavior/Patrol");
var _CanPop = require("../mixin/CanPop");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let Gator = /*#__PURE__*/function (_Mixin$from) {
  _inherits(Gator, _Mixin$from);
  var _super = _createSuper(Gator);
  function Gator() {
    var _this$args$patrolPaus, _this$args$patrolBeat, _this$args$patrolSpee;
    var _this;
    _classCallCheck(this, Gator);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.behaviors.add(new _Patrol.Patrol());
    _this.args.type = 'actor-item actor-gator-bot';
    _this.args.animation = 'standing';
    _this.args.accel = 0.75;
    _this.args.decel = 0.5;
    _this.args.gSpeedMax = 15;
    _this.args.jumpForce = 5;
    _this.args.gravity = 0.5;
    _this.args.width = 44;
    _this.args.height = 32;
    _this.args.patrolPause = (_this$args$patrolPaus = _this.args.patrolPause) !== null && _this$args$patrolPaus !== void 0 ? _this$args$patrolPaus : 20;
    _this.args.patrolBeat = (_this$args$patrolBeat = _this.args.patrolBeat) !== null && _this$args$patrolBeat !== void 0 ? _this$args$patrolBeat : 110;
    _this.args.patrolSpeed = (_this$args$patrolSpee = _this.args.patrolSpeed) !== null && _this$args$patrolSpee !== void 0 ? _this$args$patrolSpee : 1;
    _this.chasing = false;
    return _this;
  }
  _createClass(Gator, [{
    key: "onRendered",
    value: function onRendered(event) {
      _get(_getPrototypeOf(Gator.prototype), "onRendered", this).call(this, event);
    }
  }, {
    key: "update",
    value: function update() {
      if (this.viewport && this.viewport.controlActor) {
        const space = Math.abs(this.viewport.controlActor.args.x - this.args.x);
        if (space < 64) {
          this.box.setAttribute('data-animation', 'chomping');
        } else {
          this.box.setAttribute('data-animation', 'standing');
        }
      }
      _get(_getPrototypeOf(Gator.prototype), "update", this).call(this);
      this.args.direction = Math.sign(this.args.gSpeed);
      this.args.facing = this.args.direction > 0 ? 'right' : 'left';
    }
  }, {
    key: "effect",
    value: function effect(other) {
      _get(_getPrototypeOf(Gator.prototype), "effect", this).call(this, other);

      // this.viewport.spawn.add({object:new Flickie({
      // 	x: this.args.x,
      // 	y: this.args.y,
      // })});
    }
  }, {
    key: "solid",
    get: function get() {
      return false;
    }
  }, {
    key: "isEffect",
    get: function get() {
      return false;
    }
    // get controllable() { return true; }
  }]);
  return Gator;
}(_Mixin.Mixin.from(_PointActor.PointActor, _CanPop.CanPop));
exports.Gator = Gator;
});

;require.register("actor/GiantTire.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GiantTire = void 0;
var _PointActor = require("./PointActor");
var _Mixin = require("curvature/base/Mixin");
var _TruckBody = require("./TruckBody");
var _TruckCab = require("./TruckCab");
var _Platformer = require("../behavior/Platformer");
var _Sfx = require("../audio/Sfx");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let GiantTire = /*#__PURE__*/function (_Mixin$from) {
  _inherits(GiantTire, _Mixin$from);
  var _super = _createSuper(GiantTire);
  function GiantTire() {
    var _this;
    _classCallCheck(this, GiantTire);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.type = 'actor-item actor-giant-tire';
    if (_this.args.rear) {
      _this.args.type += ' actor-giant-tire-back';
    }
    _this.args.width = 64;
    _this.args.height = 64;
    _this.args.rolled = 0;
    _this.gSpeedLast = 0;
    _this.args.accel = 0.0;
    _this.args.decel = 0.0;
    _this.args.gravity = 0.6;
    _this.args.driver = _this.args.driver || null;
    _this.args.partner = _this.args.partner || null;
    _this.args.idler = null;
    _this.args.body = _this.args.body || null;
    return _this;
  }
  _createClass(GiantTire, [{
    key: "spawnParts",
    value: function spawnParts() {
      if (this.args.driver || this.args.idler) {
        return;
      }
      const idler = this.args.idler = new GiantTire({
        driver: this,
        x: this.args.x - 96,
        y: this.args.y
      });
      const partner = this.args.partner = new GiantTire({
        driver: this,
        rear: true,
        x: this.args.x + 32,
        y: this.args.y
      });
      const idlerPartner = this.args.idlerPartner = new GiantTire({
        driver: this,
        rear: true,
        x: this.args.x - 64,
        y: this.args.y
      });
      const body = this.args.body = new _TruckBody.TruckBody({
        driver: this,
        x: this.args.x - 32,
        y: this.args.y - 32
      });
      const cab = this.args.cab = new _TruckCab.TruckCab({
        driver: this,
        x: this.args.x + 48,
        y: this.args.y - 28
      });
      this.viewport.spawn.add({
        object: idler
      });
      this.viewport.spawn.add({
        object: partner
      });
      this.viewport.spawn.add({
        object: idlerPartner
      });
      this.viewport.spawn.add({
        object: body
      });
      this.viewport.spawn.add({
        object: cab
      });
      this.viewport.auras.add(this);
      this.viewport.auras.add(idler);
      this.viewport.auras.add(partner);
      this.viewport.auras.add(idlerPartner);
      this.viewport.auras.add(body);
      this.viewport.auras.add(cab);
    }
  }, {
    key: "onRendered",
    value: function onRendered(event) {
      _get(_getPrototypeOf(GiantTire.prototype), "onRendered", this).call(this, event);
      this.autoStyle.get(this.box)['--rolled'] = 'rolled';
    }
  }, {
    key: "updateStart",
    value: function updateStart() {
      if (!this.args.driver && !this.args.idler) {
        this.spawnParts();
      }
      if (this.args.destroyed && !this.args.falling) {
        this.args.type += ' actor-giant-tire-destroyed';
        this.args.idler.args.type += ' actor-giant-tire-destroyed';
        this.args.partner.args.type += ' actor-giant-tire-destroyed';
        this.args.idlerPartner.args.type += ' actor-giant-tire-destroyed';
        this.args.cab.args.type += ' actor-truck-cab-destroyed';
        this.args.body.args.type += ' actor-truck-body-destroyed';
        _Sfx.Sfx.play('ROCK_BREAK_1');
        _Sfx.Sfx.play('OBJECT_DESTROYED');
        if (!this.args.driver) {
          let other = this.viewport.controlActor;
          this.viewport.onFrameOut(15, () => other.cofocused = null);
          this.args.body.noClip = true;
          this.args.cab.noClip = true;
          this.args.body.args.destroyed = true;
          this.args.cab.args.destroyed = true;
          this.args.body.args.xSpeed = this.gSpeedLast * 1.2;
          this.args.cab.args.xSpeed = this.gSpeedLast * 1.3;
          this.args.body.args.ySpeed = -6;
          this.args.cab.args.ySpeed = -14;
          this.args.body.args.falling = true;
          this.args.cab.args.falling = true;
          this.args.body.args.float = 0;
          this.args.cab.args.float = 0;
        }
        this.args.ySpeed = -11;
        this.args.xSpeed = this.gSpeedLast * 1.4;
        this.args.falling = true;
      }
      if (this.args.destroyed) {
        if (this.args.idler && !this.args.idler.args.destroyed) {
          this.args.idler.args.destroyed = true;
          this.args.partner.args.destroyed = true;
          this.args.idlerPartner.args.destroyed = true;
          this.args.idler.args.falling = true;
          this.args.partner.args.falling = true;
          this.args.idlerPartner.args.falling = true;
          this.args.idler.args.xSpeed = this.gSpeedLast * 1.7;
          this.args.partner.args.xSpeed = this.gSpeedLast * 1.5;
          this.args.idlerPartner.args.xSpeed = this.gSpeedLast * 1.8;
          this.args.idler.args.ySpeed = -11;
          this.args.partner.args.ySpeed = -11;
          this.args.idlerPartner.args.ySpeed = -11;
          this.args.idler.args.float = 0;
          this.args.partner.args.float = 0;
          this.args.idlerPartner.args.float = 0;
          this.args.idler.noClip = true;
          this.args.partner.noClip = true;
          this.args.idlerPartner.noClip = true;
        }
        this.args.float = 0;
        this.noClip = true;
        return;
      }
      while (this.getMapSolidAt(this.args.x, this.args.y - 1)) {
        this.args.y--;
      }
      if (!this.args.idler || !this.viewport.controlActor || this.viewport.controlActor.args.dead) {
        _get(_getPrototypeOf(GiantTire.prototype), "updateStart", this).call(this);
        return;
      }
      let other = this.viewport.controlActor;
      if (this.age < 36 && this.args.x > -160 + other.args.x) {
        _get(_getPrototypeOf(GiantTire.prototype), "updateStart", this).call(this);
        return;
      }
      if (other.args.standingOn && other.args.standingOn.isVehicle) {
        other = other.args.standingOn;
      }
      if (!this.args.falling) {
        if (other.args.gSpeed && this.args.x > -160 + other.args.x) {
          this.args.gSpeed *= 0.99;
        } else {
          this.args.gSpeed = Math.max(this.args.gSpeed, other.args.gSpeed || other.args.xSpeed);
        }
      } else {
        if (this.args.x > -160 + other.args.x) {
          this.args.xSpeed *= 0.99;
        } else {
          this.args.xSpeed = Math.max(this.args.xSpeed, other.args.xSpeed || other.args.xSpeed);
        }
      }
      if (other.args.x < this.args.x || other.args.falling && other.args.xSpeed < 0) {
        this.args.gSpeed = Math.min(-8, 0.75 * other.args.xSpeed);
      } else if (other.args.gSpeed && other.args.gSpeed < 5) {
        this.args.gSpeed++;
      }
      const distance = this.args.body.distanceTo(other);
      if (distance < 768 && other.args.jumping && other.fallTime < 120) {
        this.args.gSpeed *= 0.9;
      }
      if (distance < 512) {
        other.cofocused = this.args.idler;
      } else {
        other.cofocused = null;
      }
    }
  }, {
    key: "updateEnd",
    value: function updateEnd() {
      if (!this.args.idler || this.args.destroyed) {
        _get(_getPrototypeOf(GiantTire.prototype), "updateEnd", this).call(this);
        return;
      }
      for (const region of this.viewport.regionsAtPoint(this.args.x + 80, this.args.y)) {
        if (region.args.destroyTruck) {
          this.args.destroyed = true;
        }
      }
      const idler = this.args.idler;
      const partner = this.args.partner;
      const idlerPartner = this.args.idlerPartner;
      const bodyX = 0.5 * (this.args.x + idler.args.x);
      const bodyY = -32 + 0.5 * (this.args.y + idler.args.y);
      const bodyA = this.angleTo(idler);
      const bodyD = this.distanceTo(idler);
      this.ensureSpace(idler, 96);
      this.ensureSpace(partner, -16);
      this.ensureSpace(idlerPartner, 80);
      this.args.body.args.x = bodyX;
      this.args.body.args.y = bodyY;
      this.args.body.args.groundAngle = -bodyA;
      this.args.body.args.falling = true;
      this.args.body.args.mode = 0;
      this.args.body.args.xSpeed = this.args.xSpeed || this.args.gSpeed * Math.cos(bodyA);
      this.args.body.args.ySpeed = this.args.ySpeed || this.args.gSpeed * Math.sin(bodyA);
      this.args.cab.args.xSpeed = this.args.xSpeed || this.args.gSpeed * Math.cos(bodyA);
      this.args.cab.args.ySpeed = this.args.ySpeed || this.args.gSpeed * Math.sin(bodyA);
      this.args.cab.args.x = 0 + bodyX + 80 * Math.cos(bodyA);
      this.args.cab.args.y = 3 + bodyY + 80 * Math.sin(bodyA);
      this.args.cab.args.groundAngle = -bodyA * 1.1;
      this.args.cab.args.falling = true;
      this.args.cab.args.mode = 0;
      if (this.args.gSpeed) {
        this.args.animation = 'rolling';
        this.args.idler.args.animation = 'rolling';
        this.args.partner.args.animation = 'rolling';
        this.args.idlerPartner.args.animation = 'rolling';
      } else {
        this.args.animation = 'idle';
        this.args.idler.args.animation = 'idle';
        this.args.partner.args.animation = 'idle';
        this.args.idlerPartner.args.animation = 'idle';
      }
      _get(_getPrototypeOf(GiantTire.prototype), "updateEnd", this).call(this);
    }
  }, {
    key: "ensureSpace",
    value: function ensureSpace(other, spacing) {
      let idlerDist = this.distanceFrom(other);
      let absSpace = Math.abs(spacing);
      let offset = Math.abs(absSpace - idlerDist);
      let angle = this.angleTo(other);
      if (spacing > 0 && other.args.x > this.args.x) {
        other.args.x = this.args.x - 4;
        other.args.y = this.args.y;
      } else if (spacing < 0 && other.args.x < this.args.x) {
        other.args.x = this.args.x + 4;
        other.args.y = this.args.y;
      }
      if (this.args.falling) {
        other.args.gSpeed = this.args.xSpeed;
        other.args.xSpeed = this.args.xSpeed;
      } else if (idlerDist > absSpace) {
        other.args.gSpeed = this.args.gSpeed + offset * Math.cos(angle);
        other.args.xSpeed = this.args.xSpeed || other.args.gSpeed;
      } else if (idlerDist < absSpace) {
        other.args.gSpeed = this.args.gSpeed + -offset * Math.cos(angle);
        other.args.xSpeed = other.args.gSpeed;
      } else {
        other.args.gSpeed = this.args.gSpeed;
        other.args.xSpeed = other.args.gSpeed;
      }
      if (this.args.falling && other.args.falling) {
        other.args.xSpeed = this.args.xSpeed;
        other.args.ySpeed = this.args.ySpeed;
        const bodyD = this.distanceTo(other);
        const bodyA = this.angleTo(other);
        if (bodyD !== 96) {
          other.args.x = this.args.x - absSpace * Math.cos(bodyA);
          other.args.y = this.args.y - absSpace * Math.sin(bodyA);
        }
      }
    }
  }, {
    key: "collideA",
    value: function collideA(other, type) {
      if (this.args.destroyed) {
        return;
      }
      if (other.break) {
        other.break(this);
        return;
      }
      if (other.pop) {
        other.pop(this);
        return;
      }
      if (!other.controllable) {
        return;
      }
      other.damage(this);
    }
  }]);
  return GiantTire;
}(_Mixin.Mixin.from(_PointActor.PointActor));
exports.GiantTire = GiantTire;
});

;require.register("actor/GohlaBall.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GohlaBall = void 0;
var _Flickie = require("./Flickie");
var _Mixin = require("curvature/base/Mixin");
var _Tag = require("curvature/base/Tag");
var _PointActor = require("./PointActor");
var _SkidDust = require("../behavior/SkidDust");
var _CanPop = require("../mixin/CanPop");
var _Explosion = require("../actor/Explosion");
var _Projectile = require("../actor/Projectile");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let GohlaBall = /*#__PURE__*/function (_Mixin$from) {
  _inherits(GohlaBall, _Mixin$from);
  var _super = _createSuper(GohlaBall);
  function GohlaBall() {
    var _this;
    _classCallCheck(this, GohlaBall);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.behaviors.add(new _SkidDust.SkidDust());
    _this.args.type = 'actor-item actor-gohla-ball';
    _this.args.animation = 'standing';
    _this.args.accel = 0.1;
    _this.args.decel = 0.5;
    _this.args.gSpeedMax = 5;
    _this.args.jumpForce = 5;
    _this.args.gravity = 0.5;
    _this.args.width = 16;
    _this.args.height = 16;
    _this.willStick = false;
    _this.stayStuck = false;
    return _this;
  }
  _createClass(GohlaBall, [{
    key: "solid",
    get: function get() {
      return false;
    }
  }, {
    key: "isEffect",
    get: function get() {
      return false;
    }
  }]);
  return GohlaBall;
}(_Mixin.Mixin.from(_PointActor.PointActor, _CanPop.CanPop));
exports.GohlaBall = GohlaBall;
});

;require.register("actor/GrapplePoint.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GrapplePoint = void 0;
var _PointActor = require("./PointActor");
var _Tag = require("curvature/base/Tag");
var _Spring = require("./Spring");
var _Mixin = require("curvature/base/Mixin");
var _Constrainable = require("../mixin/Constrainable");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let GrapplePoint = /*#__PURE__*/function (_Mixin$from) {
  _inherits(GrapplePoint, _Mixin$from);
  var _super = _createSuper(GrapplePoint);
  function GrapplePoint() {
    var _this;
    _classCallCheck(this, GrapplePoint);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);

    // this.args.width  = this.args.width  || 32;
    // this.args.height = this.args.height || 32;

    _this.args.width = 28;
    _this.args.height = 16;
    _this.args.type = 'actor-item actor-grapple-point';
    _this.ignoreOthers = new Set();
    _this.args.gravity = 0.6;

    // this.noClip = true;
    _this[_Spring.Spring.WontSpring] = true;
    _this.hooked = new Set();
    return _this;
  }
  _createClass(GrapplePoint, [{
    key: "updateEnd",
    value: function updateEnd() {
      _get(_getPrototypeOf(GrapplePoint.prototype), "update", this).call(this);
      const tiedTo = this.others.tiedTo;
      if (tiedTo) {
        this.setPos();
      } else {
        this.noClip = true;
      }
      if (!tiedTo) {
        this.unhookAll();
      }

      // if(!tiedTo || !tiedTo.args.falling)
      // {
      // 	return false;
      // }

      this.args.falling = true;
      if (this.hooked.size) {
        if (this.viewport.args.theme === 'phazon') {
          if (!this.lightning) {
            this.lightning = new _Tag.Tag(`<div class = "particle-sparkle-lightning">`);
            viewport.particles.add(this.lightning);
            console.log(this.lightning);
          }
          this.lightning.style({
            '--x': tiedTo.args.x,
            '--y': tiedTo.args.y,
            'height': this.args.ropeLength * 2 + 'px',
            '--angle': -this.args.groundAngle
          });
        }
        const hooked = [...this.hooked];
        const first = hooked[0];
        if (first.xAxis) {
          if (Math.sign(this.args.xSpeed) || Math.sign(this.args.xSpeed) === Math.sign(this.hooked.xAxis)) {
            if (this.y > tiedTo.y) {
              this.args.xSpeed += first.xAxis * 0.25;
            } else {
              this.args.xSpeed -= first.xAxis * 0.25;
            }
          }
        }
        for (const h of this.hooked) {
          h.args.x = this.x;
          h.args.y = this.y + first.args.height + -5;
          h.args.xSpeed = 0;
          h.args.ySpeed = 0;
          h.args.groundAngle = 0;
          if (h.xAxis > 0) {
            h.args.facing = 'right';
            h.args.direction = +1;
          } else if (h.xAxis < 0) {
            h.args.facing = 'left';
            h.args.direction = -1;
          }
          h.args.cameraMode = 'hooked';
        }
      } else {
        if (this.lightning) {
          this.viewport.particles.remove(this.lightning);
          this.lightning = null;
        }
      }
      _get(_getPrototypeOf(GrapplePoint.prototype), "updateEnd", this).call(this);
    }
  }, {
    key: "update",
    value: function update() {}
  }, {
    key: "collideA",
    value: function collideA(other) {
      if (!other.controllable) {
        return false;
      }
      const tiedTo = this.others.tiedTo;
      if (!tiedTo || tiedTo.noClip) {
        return false;
      }
      if (other.args.hangingFrom || this.ignoreOthers.has(other)) {
        return;
        false;
      }
      if (this.args.ignore) {
        return false;
      }

      // if((
      // 	(other.args.falling && Math.abs(other.args.y + -this.args.y + other.args.height) > 8)
      // 	&& (other.args.falling && Math.abs(other.args.y + -this.args.y) > 8)
      // )
      // || !other.controllable
      // || this.hooked)
      // {
      // 	return;
      // }

      other.args.falling = true;
      other.swing = true;
      this.hooked.add(other);
      this.viewport.auras.add(this);
      this.args.xSpeed = other.args.xSpeed || other.args.gSpeed;
      if (other.args.mode === 2) {
        this.args.xSpeed = other.args.xSpeed || -other.args.gSpeed;
      }
      this.args.ySpeed = other.args.ySpeed;
      other.args.xSpeed = 0;
      other.args.ySpeed = 0;
      other.args.gSpeed = 0;
      other.args.ignore = -4;
      other.args.float = -1;
      other.xLast = other.args.x;
      other.yLast = other.args.y;
      other.args.x = this.args.x;
      other.args.y = this.args.y + other.args.height;
      other.args.hangingFrom = this;
      other.args.jumping = false;
      if (this.others.tiedTo) {
        const tiedTo = this.others.tiedTo;
        tiedTo.dispatchEvent(new CustomEvent('hooked'), {
          detail: {
            hook: this,
            subject: other
          }
        });
        tiedTo.activate && tiedTo.activate(other);
        const drop = () => {
          if (!this.viewport) {
            return;
          }
          if (!this.hooked.size) {
            this.args.x = this.def.get('x');
            this.args.y = this.def.get('y');
            this.viewport.setColCell(this);
            return;
          }
          this.unhookAll();
          if (tiedTo.explode) {
            for (const h of this.hooked) {
              h.args.gSpeed = 0;
            }
            tiedTo.explode();
            this.args.x = this.def.get('x');
            this.args.y = this.def.get('y');
            this.viewport.setColCell(this);
          }
        };
        if (tiedTo.args.flightTime) {
          this.viewport.onFrameOut(tiedTo.args.flightTime, drop);
        }
        tiedTo.onRemove(drop);
        tiedTo.addEventListener('exploded', drop);
      }
    }
  }, {
    key: "unhook",
    value: function unhook(hooked) {
      // const hooked = this.hooked;

      // this.hooked = null;

      // if(!hooked)
      // {
      // 	return;
      // }

      if (!this.hooked.has(hooked)) {
        return;
      }
      this.hooked.delete(hooked);
      const tiedTo = this.others.tiedTo;
      hooked.args.ignore = hooked.args.float = 0;
      hooked.args.y++;
      hooked.args.xSpeed += tiedTo.xSpeedLast || this.xSpeedLast || 0;
      hooked.args.ySpeed += tiedTo.ySpeedLast || this.ySpeedLast || 0;
      hooked.args.groundAngle = 0;
      hooked.args.hangingFrom = null;
      this.ignoreOthers.add(hooked);
      hooked.args.falling = true;
      hooked.args.jumping = true;
      const viewport = this.viewport;
      viewport.onFrameOut(15, () => {
        this.ignoreOthers.delete(hooked);
        viewport.auras.delete(this);
      });
    }
  }, {
    key: "unhookAll",
    value: function unhookAll() {
      for (const hooked of this.hooked) {
        this.unhook(hooked);
      }
    }
  }]);
  return GrapplePoint;
}(_Mixin.Mixin.from(_PointActor.PointActor, _Constrainable.Constrainable));
exports.GrapplePoint = GrapplePoint;
});

;require.register("actor/GravityPad.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GravityPad = void 0;
var _PointActor2 = require("./PointActor");
var _Block = require("./Block");
var _Sfx = require("../audio/Sfx");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let GravityPad = /*#__PURE__*/function (_PointActor) {
  _inherits(GravityPad, _PointActor);
  var _super = _createSuper(GravityPad);
  function GravityPad() {
    var _this;
    _classCallCheck(this, GravityPad);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.width = _this.args.width || 24;
    _this.args.height = 32;
    _this.args.type = 'actor-item actor-gravity-pad';
    _this.args.float = -1;
    return _this;
  }
  _createClass(GravityPad, [{
    key: "collideA",
    value: function collideA(other) {
      if (other.args.mode || other.args.float || other.args.static) {
        return;
      }
      other.args.float = 1;
      other.args.xSpeed = other.args.xSpeed || other.args.gSpeed;
      if (Math.abs(other.xLast - other.args.x) > 5) {
        other.args.ignore = 1;
      }
      other.args.ySpeed = Math.min(0, other.args.ySpeed);
      other.args.falling = true;
      if (other.args.y > this.args.y + -this.args.height) {
        other.args.y -= 1;
        other.args.ySpeed -= 0.50;
      } else {
        other.args.ySpeed *= 0.25;
      }
      if (other.args.y >= this.args.y + -(this.args.height * 0.5)) {
        other.args.ySpeed -= 1;
      }
      other.args.animation = 'flip';
      other.args.jumping = false;
      other.dashed = false;
    }
  }], [{
    key: "fromDef",
    value: function fromDef(objDef) {
      const obj = _get(_getPrototypeOf(GravityPad), "fromDef", this).call(this, objDef);
      obj.args.width = objDef.width;
      return obj;
    }
  }]);
  return GravityPad;
}(_PointActor2.PointActor);
exports.GravityPad = GravityPad;
});

;require.register("actor/Grounder.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Grounder = void 0;
var _Flickie = require("./Flickie");
var _Mixin = require("curvature/base/Mixin");
var _PointActor = require("./PointActor");
var _Patrol = require("../behavior/Patrol");
var _CanPop = require("../mixin/CanPop");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let Grounder = /*#__PURE__*/function (_Mixin$from) {
  _inherits(Grounder, _Mixin$from);
  var _super = _createSuper(Grounder);
  function Grounder() {
    var _this$args$color, _this$args$patrolPaus, _this$args$patrolBeat, _this$args$patrolSpee;
    var _this;
    _classCallCheck(this, Grounder);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.behaviors.add(new _Patrol.Patrol());
    _this.args.type = 'actor-item actor-grounder';
    _this.args.animation = 'standing';
    _this.args.accel = 0.1;
    _this.args.decel = 0.5;
    _this.args.gSpeedMax = 5;
    _this.args.jumpForce = 5;
    _this.args.gravity = 0.5;
    _this.args.width = 24;
    _this.args.height = 32;
    _this.args.color = (_this$args$color = _this.args.color) !== null && _this$args$color !== void 0 ? _this$args$color : 'green';
    _this.willStick = false;
    _this.stayStuck = false;
    _this.args.patrolPause = (_this$args$patrolPaus = _this.args.patrolPause) !== null && _this$args$patrolPaus !== void 0 ? _this$args$patrolPaus : 20;
    _this.args.patrolBeat = (_this$args$patrolBeat = _this.args.patrolBeat) !== null && _this$args$patrolBeat !== void 0 ? _this$args$patrolBeat : 120;
    _this.args.patrolSpeed = (_this$args$patrolSpee = _this.args.patrolSpeed) !== null && _this$args$patrolSpee !== void 0 ? _this$args$patrolSpee : 1;
    return _this;
  }
  _createClass(Grounder, [{
    key: "onRendered",
    value: function onRendered() {
      _get(_getPrototypeOf(Grounder.prototype), "onRendered", this).call(this);
      this.autoAttr.get(this.box)['data-color'] = 'color';
    }
  }, {
    key: "update",
    value: function update() {
      const direction = this.args.direction;
      const telegraph = this.args.shotTelegraph;
      const beat = this.args.patrolBeat;
      if (this.box) {
        if (this.args.moving && this.args.gSpeed) {
          this.box.setAttribute('data-animation', 'walking');
        } else {
          this.box.setAttribute('data-animation', 'standing');
        }
      }
      _get(_getPrototypeOf(Grounder.prototype), "update", this).call(this);
      this.args.direction = Math.sign(this.args.gSpeed);
    }
  }, {
    key: "effect",
    value: function effect(other) {
      _get(_getPrototypeOf(Grounder.prototype), "effect", this).call(this, other);

      // this.viewport.spawn.add({object:new Flickie({
      // 	x: this.args.x,
      // 	y: this.args.y,
      // })});
    }
  }, {
    key: "solid",
    get: function get() {
      return false;
    }
  }, {
    key: "isEffect",
    get: function get() {
      return false;
    }
    // get controllable() { return true; }
  }]);
  return Grounder;
}(_Mixin.Mixin.from(_PointActor.PointActor, _CanPop.CanPop));
exports.Grounder = Grounder;
});

;require.register("actor/GuardBot.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GuardBot = void 0;
var _Flickie = require("./Flickie");
var _Mixin = require("curvature/base/Mixin");
var _Tag = require("curvature/base/Tag");
var _PointActor = require("./PointActor");
var _SkidDust = require("../behavior/SkidDust");
var _CanPop = require("../mixin/CanPop");
var _Explosion = require("../actor/Explosion");
var _Projectile = require("../actor/Projectile");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let GuardBot = /*#__PURE__*/function (_Mixin$from) {
  _inherits(GuardBot, _Mixin$from);
  var _super = _createSuper(GuardBot);
  function GuardBot() {
    var _this;
    _classCallCheck(this, GuardBot);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.behaviors.add(new _SkidDust.SkidDust());
    _this.args.type = 'actor-item actor-guard-bot';
    _this.args.animation = 'standing';
    _this.args.accel = 0.1;
    _this.args.decel = 0.5;
    _this.args.gSpeedMax = 5;
    _this.args.jumpForce = 5;
    _this.args.gravity = 0.5;
    _this.args.width = 24;
    _this.args.height = 24;
    _this.args.static = true;
    _this.willStick = false;
    _this.stayStuck = false;
    return _this;
  }
  _createClass(GuardBot, [{
    key: "solid",
    get: function get() {
      return false;
    }
  }, {
    key: "isEffect",
    get: function get() {
      return false;
    }
  }]);
  return GuardBot;
}(_Mixin.Mixin.from(_PointActor.PointActor, _CanPop.CanPop));
exports.GuardBot = GuardBot;
});

;require.register("actor/HallBooster.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.HallBooster = void 0;
var _PointActor2 = require("./PointActor");
var _Sfx = require("../audio/Sfx");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
const Boosted = Symbol('Boosted');
let HallBooster = /*#__PURE__*/function (_PointActor) {
  _inherits(HallBooster, _PointActor);
  var _super = _createSuper(HallBooster);
  function HallBooster() {
    var _this;
    _classCallCheck(this, HallBooster);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.type = 'actor-item actor-hall-booster';
    _this.args.width = 64;
    _this.args.height = 24;
    _this.args.direction = _this.args.direction || 1;
    _this.args.static = true;
    return _this;
  }
  _createClass(HallBooster, [{
    key: "update",
    value: function update() {
      _get(_getPrototypeOf(HallBooster.prototype), "update", this).call(this);
    }
  }, {
    key: "collideA",
    value: function collideA(other) {
      if (other.isRegion || other.args.static) {
        return;
      }
      if (other instanceof HallBooster) {
        return;
      }
      if (other.args.gSpeed === 0) {
        // return;
      }
      if (other.args.falling || other[Boosted]) {
        return;
      }
      this.viewport.onFrameOut(10, () => delete other[Boosted]);
      other[Boosted] = this;
      const toSpeed = this.args.toSpeed || 24;
      other.args.ignore = 2;
      other.args.direction = this.args.direction;
      other.args.facing = this.args.direction > 0 ? 'right' : 'left';
      other.args.gSpeed = toSpeed * this.args.direction;
      _Sfx.Sfx.play('HALLBOOSTER_HIT');
    }
  }]);
  return HallBooster;
}(_PointActor2.PointActor);
exports.HallBooster = HallBooster;
});

;require.register("actor/HeavyDutySwitch.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.HeavyDutySwitch = void 0;
var _Switch2 = require("./Switch");
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let HeavyDutySwitch = /*#__PURE__*/function (_Switch) {
  _inherits(HeavyDutySwitch, _Switch);
  var _super = _createSuper(HeavyDutySwitch);
  function HeavyDutySwitch() {
    var _this;
    _classCallCheck(this, HeavyDutySwitch);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.type = 'actor-item actor-switch actor-heavy-duty-switch';
    _this.args.height = _this.height = 19;
    return _this;
  }
  return _createClass(HeavyDutySwitch);
}(_Switch2.Switch);
exports.HeavyDutySwitch = HeavyDutySwitch;
});

;require.register("actor/Herculad.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Herculad = void 0;
var _PointActor = require("./PointActor");
var _Mixin = require("curvature/base/Mixin");
var _Sfx = require("../audio/Sfx");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let Herculad = /*#__PURE__*/function (_Mixin$from) {
  _inherits(Herculad, _Mixin$from);
  var _super = _createSuper(Herculad);
  function Herculad() {
    var _this;
    _classCallCheck(this, Herculad);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.type = 'actor-item actor-herculad';
    _this.args.width = 32;
    _this.args.height = 32;
    _this.args.gravity = 0.4;
    _this.args.collected = false;
    return _this;
  }
  _createClass(Herculad, [{
    key: "onRendered",
    value: function onRendered(event) {
      _get(_getPrototypeOf(Herculad.prototype), "onRendered", this).call(this, event);
      this.autoAttr.get(this.box)['data-collected'] = 'collected';
    }
  }, {
    key: "collideA",
    value: function collideA(other, type) {
      if (other.controllable) {
        if (!this.args.collected) {
          _Sfx.Sfx.play('DOOT_DOOT');
          this.viewport.args.inventory.push({
            tallyIcon: '/secret/herculad-icon.png',
            icon: '/secret/herculad-icon.png',
            points: 10000,
            id: this.oid
          });
        }
        this.args.collected = 'collected';
      }
      _get(_getPrototypeOf(Herculad.prototype), "collideA", this).call(this, other, type);
    }
  }]);
  return Herculad;
}(_Mixin.Mixin.from(_PointActor.PointActor));
exports.Herculad = Herculad;
});

;require.register("actor/HexNut.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.HexNut = void 0;
var _Block2 = require("./Block");
var _Sfx = require("../audio/Sfx");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let HexNut = /*#__PURE__*/function (_Block) {
  _inherits(HexNut, _Block);
  var _super = _createSuper(HexNut);
  function HexNut() {
    var _this$args$maxClimb;
    var _this;
    _classCallCheck(this, HexNut);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.maxClimb = (_this$args$maxClimb = _this.args.maxClimb) !== null && _this$args$maxClimb !== void 0 ? _this$args$maxClimb : 262;
    _this.args.width = 64;
    _this.args.height = 24;
    _this.args.platform = 1;
    _this.args.float = -1;
    _this.args.type = 'actor-item actor-hex-nut';
    _this.args.static = 0;
    // this.args.gravity  = 0.20;
    _this.args.spinning = 0;
    _this.args.bouncing = 0;
    _this.args.treadmill = true;
    return _this;
  }
  _createClass(HexNut, [{
    key: "collideA",
    value: function collideA(other, type) {
      if (other.args.platform) {
        return false;
      }
      return _get(_getPrototypeOf(HexNut.prototype), "collideA", this).call(this, other, type);
    }
  }, {
    key: "update",
    value: function update() {
      this.args.treadmill = true;
      this.standingUnder.forEach(a => {
        if (Math.abs(a.args.gSpeed) > 16) {
          a.args.gSpeed = 16 * Math.sign(a.args.gSpeed);
        }
      });
      const maxClimb = this.originalY + -this.args.maxClimb;
      if (this.args.convey > 0) {
        if (this.getMapSolidAt(this.args.x, this.args.y + 1)) {
          this.args.ySpeed = 0;
          this.args.treadmill = false;
          this.args.convey = 0;
        } else {
          this.args.y += 0.1 * this.args.convey;
        }
      } else if (this.args.convey < 0) {
        if (this.args.y <= maxClimb) {
          this.args.y = maxClimb;
          this.args.ySpeed = 0;
          this.args.treadmill = false;
          this.args.convey = 0;
        } else {
          this.args.y += 0.1 * this.args.convey;
        }
      }
      if (Math.abs(this.args.convey) > 8) {
        this.standingUnder.forEach(a => a.args.x = this.args.x);
      } else {
        this.standingUnder.forEach(a => {
          if (Math.abs(this.args.x - a.args.x) < 1) {
            a.args.x = this.args.x;
          }
          a.args.x += Math.sign(this.args.x - a.args.x);
        });
      }
      _get(_getPrototypeOf(HexNut.prototype), "update", this).call(this);
    }
  }, {
    key: "sleep",
    value: function sleep() {
      this.args.y = this.originalY;
    }
  }]);
  return HexNut;
}(_Block2.Block);
exports.HexNut = HexNut;
});

;require.register("actor/HtmlFrame.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.HtmlFrame = void 0;
var _PointActor2 = require("./PointActor");
var _Tag = require("curvature/base/Tag");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let HtmlFrame = /*#__PURE__*/function (_PointActor) {
  _inherits(HtmlFrame, _PointActor);
  var _super = _createSuper(HtmlFrame);
  function HtmlFrame() {
    var _args$collapse;
    var _this;
    let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let parent = arguments.length > 1 ? arguments[1] : undefined;
    _classCallCheck(this, HtmlFrame);
    _this = _super.call(this, args, parent);
    _this.args.yForce = 0;
    _this.args.yLean = 0;
    _this.args.type = 'actor-item actor-html-frame';
    _this.args.width = args.width || 32;
    _this.args.height = args.height || 32;
    _this.originalX = _this.args.x;
    _this.originalY = _this.args.y;
    _this.args.z = -1000;
    _this.args.static = true;
    _this.args.gravity = 0.5;
    _this.args.collapse = (_args$collapse = args.collapse) !== null && _args$collapse !== void 0 ? _args$collapse : false;
    const urls = ['pxIofYrt0kE', 'aRsOBFhNjVM', 'obtGE_8NAp8', 'uRjoPlWWljk'];
    const ytUrt = v => `https://www.youtube.com/embed/${v}?controls=0&autoplay=1`;
    const random = Math.random();
    console.log(random);
    _this.args.url = ytUrt(urls[Math.trunc(random * urls.length)]);
    return _this;
  }
  _createClass(HtmlFrame, [{
    key: "onRendered",
    value: function onRendered(event) {
      _get(_getPrototypeOf(HtmlFrame.prototype), "onRendered", this).call(this, event);

      // this.droop(0);

      if (this.screen) {
        return;
      }
      this.screen = new _Tag.Tag(`<iframe width="560" height="315" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>`);
      this.sprite.appendChild(this.screen.node);

      // this.screen.style({'pointer-events':'initial'});

      this.args.spriteSheet = this.args.spriteSheet || '/Sonic/marble-zone-block.png';
      this.args.bindTo('url', v => this.screen.src = v);
      this.args.bindTo('html', v => this.screen.srcDoc = v);
    }
  }], [{
    key: "fromDef",
    value: function fromDef(objDef) {
      const obj = _get(_getPrototypeOf(HtmlFrame), "fromDef", this).call(this, objDef);
      obj.args.width = objDef.width;
      obj.args.height = objDef.height;
      obj.args.tileId = objDef.gid;

      // obj.args.x = obj.originalX = objDef.x + Math.floor(objDef.width / 2);
      obj.args.y = obj.originalY = objDef.y;
      return obj;
    }
  }]);
  return HtmlFrame;
}(_PointActor2.PointActor); // <iframe width="560" height="315" src="https://www.youtube.com/embed/lTsIO_bo2P8" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
exports.HtmlFrame = HtmlFrame;
});

;require.register("actor/Jawz.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Jawz = void 0;
var _Flickie = require("./Flickie");
var _Spring = require("./Spring");
var _Mixin = require("curvature/base/Mixin");
var _Tag = require("curvature/base/Tag");
var _PointActor = require("./PointActor");
var _CanPop = require("../mixin/CanPop");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let Jawz = /*#__PURE__*/function (_Mixin$from) {
  _inherits(Jawz, _Mixin$from);
  var _super = _createSuper(Jawz);
  function Jawz() {
    var _this;
    _classCallCheck(this, Jawz);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.type = 'actor-item actor-jawz';
    _this[_Spring.Spring.WontSpring] = true;
    _this.args.animation = 'standing';
    _this.args.accel = 0.1;
    _this.args.decel = 0.5;
    _this.args.gSpeedMax = 5;
    _this.args.jumpForce = 5;
    _this.args.gravity = 0.5;
    _this.args.width = 56;
    _this.args.height = 16;
    _this.willStick = false;
    _this.stayStuck = false;
    _this.args.float = -1;
    _this.noClip = true;
    return _this;
  }
  _createClass(Jawz, [{
    key: "onRendered",
    value: function onRendered() {
      _get(_getPrototypeOf(Jawz.prototype), "onRendered", this).call(this);
      this.box.setAttribute('data-animation', 'standing');
    }
  }, {
    key: "update",
    value: function update() {
      // this.args.facing  = 'right';
      this.args.facing = 'left';
      if (this.args.xSpeed > -4) {
        this.args.xSpeed -= 0.2;
      }
      this.args.ySpeed = 0;
      this.args.falling = true;
      this.args.flying = true;
      _get(_getPrototypeOf(Jawz.prototype), "update", this).call(this);
    }
  }, {
    key: "effect",
    value: function effect(other) {
      _get(_getPrototypeOf(Jawz.prototype), "effect", this).call(this, other);

      // this.viewport.spawn.add({object:new Flickie({
      // 	x: this.args.x,
      // 	y: this.args.y,
      // })});
    }
  }, {
    key: "solid",
    get: function get() {
      return false;
    }
  }, {
    key: "isEffect",
    get: function get() {
      return false;
    }
  }]);
  return Jawz;
}(_Mixin.Mixin.from(_PointActor.PointActor, _CanPop.CanPop));
exports.Jawz = Jawz;
});

;require.register("actor/Knuckles.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Knuckles = void 0;
var _PointActor2 = require("./PointActor");
var _Platformer = require("../behavior/Platformer");
var _Tag = require("curvature/base/Tag");
var _KnuxBomb = require("./KnuxBomb");
var _Spindash = require("../behavior/Spindash");
var _Spring = require("./Spring");
var _SkidDust = require("../behavior/SkidDust");
var _Crouch = require("../behavior/Crouch");
var _LookUp = require("../behavior/LookUp");
var _EmeraldHalo = require("../behavior/EmeraldHalo");
var _SuperForm = require("../behavior/SuperForm");
var _Color = require("../lib/Color");
var _Png = require("../sprite/Png");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let Knuckles = /*#__PURE__*/function (_PointActor) {
  _inherits(Knuckles, _PointActor);
  var _super = _createSuper(Knuckles);
  function Knuckles(args, parent) {
    var _this;
    _classCallCheck(this, Knuckles);
    _this = _super.call(this, args, parent);
    _defineProperty(_assertThisInitialized(_this), "png", new _Png.Png('/Sonic/knuckles.png'));
    _this.args.canonical = 'Knuckles';
    window.knuckles = _assertThisInitialized(_this);
    _this.behaviors.add(new _SkidDust.SkidDust());
    _this.behaviors.add(new _Spindash.Spindash());
    _this.behaviors.add(new _Crouch.Crouch());
    _this.behaviors.add(new _LookUp.LookUp());
    _this.behaviors.add(new _SuperForm.SuperForm());
    _this.behaviors.add(new _EmeraldHalo.EmeraldHalo());
    _this.args.isHyper = _this.args.isSuper = false;
    _this.args.type = 'actor-item actor-knuckles';
    _this.args.spriteSheet = _this.spriteSheet = `url('/Sonic/knuckles.png')`;
    _this.gSpeedMaxNormal = 18;
    _this.gSpeedMaxSuper = 20;
    _this.gSpeedMaxHyper = 23;
    _this.climbSpeedMaxNormal = 4;
    _this.climbSpeedMaxSuper = 6;
    _this.climbSpeedMax = _this.climbSpeedMaxNormal;
    _this.jumpForceNormal = 9.5;
    _this.jumpForceSuper = 10;
    _this.jumpForceHyper = 11;
    _this.accelNormal = 0.15;
    _this.accelSuper = 0.24;
    _this.args.accel = _this.accelNormal;
    _this.args.decel = 0.4;
    _this.args.gSpeedMax = _this.gSpeedMaxNormal;
    _this.args.jumpForce = _this.jumpForceNormal;
    _this.args.gravity = 0.5;
    _this.args.normalGravity = 0.5;
    _this.args.slowGravity = 0.125;
    _this.args.punchMomentum = 0;
    _this.args.width = 15;
    _this.args.height = 41;
    _this.args.weight = 150;
    _this.args.normalHeight = 41;
    _this.args.rollingHeight = 28;
    _this.punchTime = 0;
    _this.punched = 0;
    _this.beforePunch = 'standing';
    _this.bombsDropped = 0;
    _this.args.bellySliding = false;
    _this.slideTime = 0;
    _this.sparks = new Set();
    _this.flyTime = 0;
    _this.transformTime = 0;
    _this.args.minRingsSuper = 50;
    _this.args.minRingsHyper = 75;
    _this.args.bindTo('punchMomentum', v => _this.args.punchSpeed = Math.abs(v * 0.5));
    _this.args.bindTo('falling', v => {
      if (v || !_this.args.flying) {
        return;
      }
      if (_this.args.mode === 1 || _this.args.mode === 2 || _this.args.mode === 3) {
        _this.args.climbing = true;
        if (_this.isHyper && Math.abs(_this.args.xSpeed) > 5) {
          _this.viewport.args.shakeX = 16;
          if (_this.viewport && _this.viewport.settings.rumble && _this.controller && _this.controller.rumble) {
            _this.controller.rumble({
              duration: 800,
              strongMagnitude: 1.0,
              weakMagnitude: 1.0
            });

            // this.onTimeout(240, () => {
            // 	this.controller.rumble({
            // 		duration: 100,
            // 		strongMagnitude: 0.0,
            // 		weakMagnitude: 0.25
            // 	});
            // });
          }
        }

        _this.args.gSpeed = 0;
        _this.args.xSpeed = 0;
        _this.args.ySpeed = 0;
      }
    });
    _this.costumes = {
      Tails: {
        h: -125,
        s: 1.0,
        v: 1.00
      },
      Enerjak: {
        h: 120,
        s: 1.0,
        v: 0.55
      },
      Pink: {
        h: 0,
        s: 1.5,
        v: 1.50
      },
      Wechnia: {
        h: 0,
        s: 0.0,
        v: 0.85
      }
    };
    return _this;
  }
  _createClass(Knuckles, [{
    key: "onRendered",
    value: function onRendered(event) {
      if (this.box) {
        return;
      }
      _get(_getPrototypeOf(Knuckles.prototype), "onRendered", this).call(this, event);
      this.autoStyle.get(this.box)['--punchSpeed'] = 'punchSpeed';
      this.autoStyle.get(this.box)['--sprite-sheet'] = 'spriteSheet';
      this.punchAura = new _Tag.Tag('<div class = "punch-aura">');
      this.punchAura.style({
        display: 'none'
      });
      this.sprite.appendChild(this.punchAura.node);
      this.args.bindTo('animation', v => this.box.setAttribute('data-animation', v));
      this.addEventListener('jump', event => {
        if (this.willPunch) {
          this.punchTime = this.viewport.args.frameId;
          this.punched++;
        }
      });
      this.rotatedSpriteSheet = this.spriteSheet;
      const updateSprite = () => {
        var _this$viewport$custom, _this$viewport$custom2, _this$viewport$custom3;
        let h = Number((_this$viewport$custom = this.viewport.customColor.h) !== null && _this$viewport$custom !== void 0 ? _this$viewport$custom : 0);
        let s = Number((_this$viewport$custom2 = this.viewport.customColor.s) !== null && _this$viewport$custom2 !== void 0 ? _this$viewport$custom2 : 1);
        let v = Number((_this$viewport$custom3 = this.viewport.customColor.v) !== null && _this$viewport$custom3 !== void 0 ? _this$viewport$custom3 : 1);
        this.rotateMainColor(h, s, v);

        // this.args.spriteSheet = this.args.rotatedSpriteSheet;

        this.box.node.style.setProperty('--sprite-sheet', `url(${this.args.rotatedSpriteSheet})`);
      };
      const debindH = this.viewport.customColor.bindTo('h', updateSprite, {
        wait: 0
      });
      const debindS = this.viewport.customColor.bindTo('s', updateSprite, {
        wait: 0
      });
      const debindV = this.viewport.customColor.bindTo('v', updateSprite, {
        wait: 0
      });
      this.onRemove(debindH);
      this.onRemove(debindS);
      this.onRemove(debindV);
      if (this.viewport.args.mainPallet && this.costumes[this.viewport.args.mainPallet]) {
        Object.assign(this.viewport.customColor, this.costumes[this.viewport.args.mainPallet]);
      }
      this.superSheet = 0;
      const superColorsA = {
        'f1958e': 'cacaca',
        'd3565c': 'cacaca',
        'c00020': 'b0b0b0',
        '600020': '989898'
        // '900000': '464646',
      };

      const superColorsB = {
        'f1958e': 'faf1f1',
        'd3565c': 'faf1f1',
        'c00020': 'f5dfdf',
        '600020': 'eecaca'
        // '900000': 'f1d5d5',
      };

      if (!this.superSpriteSheetLoaders) {
        this.superSpriteSheetLoaders = this.png.ready.then(() => this.superSpriteSheets = [this.png.recolor(superColorsA).toUrl(), this.png.recolor(superColorsB).toUrl()]);
      }
      this.hyperSheet = 0;
      const hyperColorsRed = {
        'f1958e': 'fcfcfc',
        'd3565c': 'fcfcfc',
        'c00020': 'fcfcfc',
        '600020': 'fcd8d8'
        // '900000': 'fcb4b4',
      };

      const hyperColorsPurple = {
        'f1958e': 'fcfcfc',
        'd3565c': 'fcfcfc',
        'c00020': 'fcfcfc',
        '600020': 'fcd8fc'
        // '900000': 'd8b4d8',
      };

      const hyperColorsCyan = {
        'f1958e': 'd8fcfc',
        'd3565c': 'd8fcfc',
        'c00020': 'fcfcfc',
        '600020': 'b4d8fc'
        // '900000': '90b4fc',
      };

      const hyperColorsBlue = {
        'f1958e': 'd8d8ff',
        'd3565c': 'd8d8ff',
        'c00020': 'b4b4d8',
        '600020': 'a4a4d8'
        // '900000': '6c6cb4',
      };

      const hyperColorsGreen = {
        'f1958e': 'd8fcfc',
        'd3565c': 'd8fcfc',
        'c00020': 'd8fcd8',
        '600020': 'b4fcb4'
        // '900000': '00fc24',
      };

      const hyperColorsYellow = {
        'f1958e': 'd8fcfc',
        'd3565c': 'd8fcfc',
        'c00020': 'd8fcb4',
        '600020': 'd8fc48'
        // '900000': 'd8d800',
      };

      const hyperColorsWhite = {
        'f1958e': 'ffffff',
        'd3565c': 'ffffff',
        'c00020': 'fcfcfc',
        '600020': 'd8d8d8'
        // '900000': 'b4b4b4',
      };

      if (!this.hyperSpriteSheetLoader) {
        this.hyperSpriteSheetLoader = this.png.ready.then(() => this.hyperSpriteSheets = [this.png.recolor(hyperColorsRed).toUrl(), this.png.recolor(hyperColorsCyan).toUrl(), this.png.recolor(hyperColorsPurple).toUrl(), this.png.recolor(hyperColorsWhite).toUrl(), this.png.recolor(hyperColorsGreen).toUrl(), this.png.recolor(hyperColorsBlue).toUrl(), this.png.recolor(hyperColorsYellow).toUrl()]);
      }
    }
  }, {
    key: "update",
    value: function update() {
      if (this.isSuper) {
        if (this.isHyper) {
          if (this.viewport.args.frameId % 15 === 0) {
            this.hyperSheet++;
            if (this.hyperSheet >= this.hyperSpriteSheets.length) {
              this.hyperSheet = 0;
            }
          }
          this.hyperSpriteSheet = this.hyperSpriteSheets[this.hyperSheet];
          this.args.spriteSheet = `url(${this.hyperSpriteSheet})`;
        } else {
          if (this.viewport.args.frameId % 15 === 0) {
            this.superSheet++;
            if (this.superSheet >= this.superSpriteSheets.length) {
              this.superSheet = 0;
            }
          }
          this.superSpriteSheet = this.superSpriteSheets[this.superSheet];
          this.args.spriteSheet = `url(${this.superSpriteSheet})`;
        }
        const tick = this.isHyper ? 30 : 60;
        if (this.viewport.args.frameId % tick === 0) {
          if (this.args.rings < 2) {
            this.isHyper = false;
            this.setProfile();
          }
          if (this.args.rings > 0) {
            this.args.rings--;
          } else {
            this.isSuper = false;
            this.isHyper = false;
            this.setProfile();
          }
        }
      }
      this.args.isSuper = this.isSuper;
      this.args.isHyper = this.isHyper;
      if (!this.args.falling && this.groundTime > 3 || this.args.falling && this.fallTime > 90) {
        this.args.twistRamp = false;
      }
      if (this.args.bellySliding) {
        this.xAxis = 0;
      }
      if (this.args.wasHanging) {
        this.args.flying = false;
      }
      if (this.args.flying) {
        const frontUpSolid = this.getMapSolidAt(this.args.x + this.args.xSpeed, this.args.y + -18);
        const frontSolid = this.getMapSolidAt(this.args.x + this.args.xSpeed, this.args.y);
        const downSolid = this.getMapSolidAt(this.args.x, this.args.y + 1);
        if (frontSolid && !frontUpSolid && !downSolid) while (this.getMapSolidAt(this.args.x + this.args.xSpeed, this.args.y)) {
          this.args.y--;
        }
        if (this.isHyper && this.yAxis < -0.55) {
          this.args.ySpeed -= this.args.slowGravity * 1.1;
        }
        this.args.gravity = this.args.slowGravity;
        this.flyTime++;
      } else {
        this.args.didBoost = false;
        this.args.gravity = this.args.normalGravity;
        this.flyTime = 0;
      }
      if (this.args.dead) {
        this.punching = false;
      }
      if (this.groundTime === 1 && this.punching) {
        this.punching = false;
        this.readyStart(0, 1);
      }
      const falling = this.args.falling;
      const wasMoving = this.args.gSpeed;
      if (!this.box) {
        _get(_getPrototypeOf(Knuckles.prototype), "update", this).call(this);
        return;
      }
      if (!this.args.falling && this.readyTime && this.viewport.args.frameId - this.readyTime > 36) {
        this.punched = false;
        this.readying = false;
        this.willPunch = false;
        this.punchTime = false;
        this.readyTime = false;
        this.punching = false;
        if (Math.sign(this.args.punchMomentum) === Math.sign(this.xAxis)) {
          this.args.gSpeed = this.args.punchMomentum;
        }
        this.args.punchMomentum = 0;
      } else if (this.readyTime && this.xAxis && Math.abs(this.args.punchMomentum) < 20) {
        this.args.punchMomentum += this.xAxis * 0.05;
      }
      if (this.throwing && this.viewport.args.frameId - this.throwing > 20) {
        this.throwing = false;
        this.holdBomb = false;
        const bomb = new _KnuxBomb.KnuxBomb({
          x: this.args.x,
          y: this.args.y - 16,
          owner: this,
          xSpeed: this.args.direction * 10 + (-1 + Math.random() * 2),
          ySpeed: Math.random() * -2
        });
        this.viewport.spawn.add({
          object: bomb
        });
      }
      this.readying = false;
      if (this.punchTime && this.viewport.args.frameId - this.punchTime > 15) {
        this.readying = true;
      }
      if (this.punchTime && this.viewport.args.frameId - this.punchTime > 10) {
        this.punching = true;
      }
      if (this.punching) {
        this.args.rolling = false;
      }
      if (this.punching && Math.abs(this.args.gSpeed) > 10) {
        this.auraVisible = true;
        this.viewport.onFrameOut(6, () => {
          this.punchAura.style({
            display: 'none'
          });
          this.auraVisible = false;
        });
        this.punchAura.style({
          display: 'initial'
        });
      } else {
        this.auraVisible = false;
        this.punchAura.style({
          display: 'none'
        });
      }
      this.stayStuck = false;
      this.willStick = false;
      if (this.args.mercy) {
        this.args.flying = false;
      }
      if (this.yAxis === 0) {
        this.args.lookTime = 0;
        this.args.cameraBias = 0;
      }
      if (!falling) {
        this.bombsDropped = 0;
        this.springing = false;
        const direction = this.args.direction;
        const gSpeed = this.args.gSpeed;
        const speed = Math.abs(gSpeed);
        const maxSpeed = this.args.gSpeedMax;
        this.args.knucklesFlyCoolDown = 15;
        this.args.flying = false;
        if (this.args.bellySliding) {
          this.args.animation = 'flying';
        } else if (!this.args.rolling) {
          if (this.args.climbing) {
            const climbDir = this.args.mode === 3 ? -1 : 1;
            if (!this.getMapSolidAt(this.args.x + -climbDir, this.args.y + 1)) {
              this.args.direction = -climbDir;
              this.args.climbing = false;
              this.args.facing = climbDir > 0 ? 'left' : 'rigjt';
              this.args.animation = 'dropping';
              this.args.x += this.args.width * 0.5 * climbDir;
              this.args.groundAngle = 0;
              this.args.falling = true;
              this.args.ySpeed = this.gSpeedLast * (this.args.mode === 3 ? -1 : 1);
              this.args.gSpeed = 0;
              this.args.mode = 0;
              return;
            }
            const ledgeDir = this.args.mode === 1 ? -1 : 1;
            const ledgeDist = 16;
            if (this.args.modeTime < 2 || this.yAxis === 0) {
              if (!this.climbOverCancel) {
                this.args.animation = 'climbing';
                this.args.gSpeed = 0;
              }
            } else if (this.yAxis < -0.55) {
              if (!this.getMapSolidAt(this.args.x + 18 * ledgeDir, this.args.y - ledgeDist)) {
                this.args.animation = 'climbing-over';
                if (!this.climbOverCancel) {
                  this.args.ignore = 12;
                  this.args.gSpeed = 0;
                  this.climbOverCancel = this.viewport.onFrameOut(12, () => {
                    if (this.args.falling) {
                      this.climbOverCancel = false;
                      return;
                    }
                    this.args.x += this.args.width * 0.5 * ledgeDir;
                    this.args.y -= ledgeDist;
                    this.args.direction = ledgeDir;
                    this.args.facing = ledgeDir > 0 ? 'right' : 'left';
                    this.args.climbing = false;
                    this.climbOverCancel = false;
                  });
                }
              } else {
                this.args.animation = 'climbing-up';
                if (Math.abs(this.args.gSpeed) < this.climbSpeedMax) {
                  const dir = [0, 1, 0, -1][this.args.mode];
                  this.args.direction = dir;
                  this.args.gSpeed += -dir;
                }
              }
            } else if (this.yAxis > 0.55) {
              this.args.animation = 'climbing-down';
              if (Math.abs(this.args.gSpeed) < this.climbSpeedMax) {
                this.args.direction = this.args.mode === 1 ? 1 : -1;
                this.args.gSpeed += this.args.direction;
              }
            }
          } else if (Math.sign(this.args.gSpeed) !== direction && Math.abs(this.args.gSpeed - direction) > 5) {
            this.args.animation = 'skidding';
          } else if (this.holdBomb) {
            this.args.animation = 'hold-bomb';
          } else if (this.throwing) {
            this.args.animation = 'throw-bomb';
          } else if (this.readying || this.willPunch) {
            this.args.animation = 'readying';
          } else if (!this.readying && this.punched) {
            if (this.punched % 2) {
              this.args.animation = 'jabbing';
            } else {
              this.args.animation = 'punching';
            }
          } else if (speed > maxSpeed * 0.75) {
            this.args.animation = 'running';
          } else if (this.args.moving && this.args.gSpeed) {
            this.args.animation = 'walking';
          } else if (this.args.teeter) {
            this.args.animation = 'teeter';
            if (this.idleTime > 56) {
              this.args.animation = 'teeter-2';
            }
          } else {
            this.args.animation = 'standing';
          }
        } else {
          this.args.animation = 'rolling';
        }
        if (this.args.grinding) {
          this.args.rolling = false;
          this.args.animation = 'grinding';
        }
      } else {
        this.args.climbing = false;
        if (this.springing) {
          this.args.groundAngle = 0;
        }
        if (this.args.flying) {
          let inWater = false,
            topWater = false;
          const topRegions = this.viewport.regionsAtPoint(this.args.x, this.args.y - 36);
          for (const region of this.regions) {
            if (region.isWater) {
              inWater = true;
            }
          }
          if (Math.abs(this.args.xSpeed) > 6 || Math.abs(this.xAxis) < 0.55 || Math.sign(this.xAxis) === Math.sign(this.args.xSpeed)) {
            if (inWater) {
              this.args.animation = 'swimming';
            } else {
              this.args.animation = 'flying';
            }
          } else if (Math.sign(this.xAxis) !== Math.sign(this.args.xSpeed)) {
            if (Math.abs(this.args.xSpeed) > 3) {
              this.args.animation = 'flying-turning';
            } else {
              this.args.animation = 'flying-stalled';
            }
          }
          if (this.bMap('checkBelow', this.x, this.y).get(_Platformer.Platformer) && !this.args.climbing) {
            this.args.flying = false;
            this.args.bellySliding = true;
            this.args.float = 1;
          }
          if (this.yAxis > 0.55) {
            this.args.flying = false;
            this.args.ySpeed = 8;
            return;
          }
          if (this.xAxis) {
            this.args.flyDirection = Math.sign(this.xAxis);
          }
          this.args.direction = Math.sign(this.args.xSpeed);
          if (this.args.direction < 0) {
            this.args.facing = 'left';
          } else {
            this.args.facing = 'right';
          }
          const maxFlySpeed = (16 + 8 * Math.abs(this.xAxis)) * (inWater ? 0.5 : 1);
          if (this.args.flyDirection) {
            if (Math.abs(this.args.xSpeed) < maxFlySpeed) {
              if (this.args.flyDirection !== Math.sign(this.args.xSpeed)) {
                this.args.xSpeed += 0.15625 * Math.sign(this.args.flyDirection) * 4;
              } else {
                this.args.xSpeed += 0.15625 * Math.sign(this.args.flyDirection);
              }
            }
          }
          if (!this.args.didBoost && Math.abs(this.args.xSpeed) > maxFlySpeed) {
            this.args.xSpeed -= 0.1 * (this.args.xSpeed - maxFlySpeed * Math.sign(this.args.xSpeed));
          }
          if (this.args.ySpeed > 2 && Math.abs(this.args.xSpeed) < 4) {
            this.args.xSpeed += 0.1 * Math.sign(this.args.xSpeed);
          }
          if (inWater && this.args.ySpeed > 1) {
            this.args.ySpeed = 1;
          }
          if (!inWater && this.args.ySpeed > 0.5) {
            this.args.ySpeed = 0.5;
          }
          this.willStick = true;
          this.stayStuck = true;
          this.args.groundAngle = 0;
        } else if (this.args.jumping) {
          // if(!this.willPunch && this.punched && this.args.ySpeed > 0)
          // {
          // 	this.args.animation = 'kick';
          // }
          // else

          if ((Math.abs(this.args.punchMomentum) > 8 || this.readyTime) && (this.willPunch || this.punching)) {
            this.args.animation = 'uppercut';
            this.punched++;
            this.punchAura.style({
              display: 'initial'
            });
            this.auraVisible = true;
            this.viewport.onFrameOut(15, () => {
              this.punchAura.style({
                display: 'none'
              });
              this.auraVisible = false;
            });
          } else {
            this.punched = false;
            this.punching = false;
            if (!this.args.bellySliding) {
              this.args.animation = 'jumping';
            }
          }
        }
      }
      if (this.args.flying) {} else if (this.args.mode % 2 === 0 || this.args.groundAngle) {
        this.args.flyDirection = 0;
      }
      if (this.args.knucklesFlyCoolDown > 0) {
        this.args.knucklesFlyCoolDown--;
      }
      _get(_getPrototypeOf(Knuckles.prototype), "update", this).call(this);
      if (this.willPunch && !wasMoving) {
        this.args.gSpeed = 0;
      }
      if (this.args.mode === 0 || this.args.mode === 2) {
        if (this.args.climbing && this.args.mode === 2) {
          this.args.groundAngle = 0;
          this.args.falling = true;
          this.args.y += this.args.height;
        }
        this.args.climbing = false;
      }
      if (this.args.grinding && !this.args.falling && this.args.gSpeed) {
        const sparkParticle = new _Tag.Tag(`<div class = "particle-sparks">`);
        const sparkEnvelope = new _Tag.Tag(`<div class = "envelope-sparks">`);
        sparkEnvelope.appendChild(sparkParticle.node);
        const sparkPoint = this.rotatePoint(-this.args.gSpeed * 1.75 * this.args.direction, 8);
        const flip = Math.sign(this.args.gSpeed);
        sparkEnvelope.style({
          '--x': sparkPoint[0] + this.x,
          '--y': sparkPoint[1] + this.y + Math.random * -3,
          'z-index': 0,
          'animation-delay': -Math.random() * 0.25 + 's',
          '--xMomentum': Math.max(Math.abs(this.args.gSpeed), 4) * flip,
          '--flip': flip,
          '--angle': this.realAngle,
          opacity: Math.random() * 2
        });
        sparkEnvelope.particle = sparkParticle;
        this.viewport.particles.add(sparkEnvelope);
        this.sparks.add(sparkEnvelope);
        this.viewport.onFrameOut(30, () => {
          this.viewport.particles.remove(sparkEnvelope);
          this.sparks.delete(sparkEnvelope);
        });
      }
      if (this.args.grinding) {
        this.args.rolling = false;
        this.args.animation = 'grinding';
      }
      if (this.args.falling && this.springing && this.args.ySpeed >= 0) {
        this.args.animation = 'dropping';
      } else if (this.args.falling && this.springing) {
        this.args.animation = 'springdash';
      }
      if (this.args.hangingFrom) {
        this.args.animation = 'hanging';
      }
      if (this.args.standingOn && this.args.standingOn.isVehicle) {
        this.args.animation = this.args.standingOn.ridingAnimation || 'standing';
      }
      if (this.sparks.size) {
        for (const spark of this.sparks) {
          const sparkPoint = this.rotatePoint(1.75 * this.args.direction, 8);
          spark.style({
            opacity: Math.random() * 2,
            '--x': sparkPoint[0] + this.x,
            '--y': sparkPoint[1] + this.y
          });
        }
      }
      if (this.args.dead) {
        this.args.animation = 'dead';
      }
      if (this.args.twistRamp) {
        this.args.animation = 'side-flip';
      }
    }
  }, {
    key: "updateEnd",
    value: function updateEnd() {
      if (!this.args.falling && this.punchTime && this.viewport.args.frameId - this.punchTime > (this.willPunch ? 90 : 30)) {
        this.args.punchMomentum = 0;
        this.punchTime = false;
        this.willPunch = false;
        this.punching = false;
        this.punched = 0;
      }
      if (!this.args.falling) {
        if (this.args.bellySliding) {
          this.args.rolling = false;
          this.args.animation = 'sliding';
          this.alwaysSkidding = true;
          this.slideTime++;
        } else {
          this.alwaysSkidding = false;
          this.slideTime = 0;
        }
        if (Math.abs(this.args.gSpeed) < 1) {
          this.args.bellySliding = false;
        }
      }
      _get(_getPrototypeOf(Knuckles.prototype), "updateEnd", this).call(this);
      if (!this.args.falling) {
        this.dashed = false;
      }
    }
  }, {
    key: "startle",
    value: function startle() {
      _get(_getPrototypeOf(Knuckles.prototype), "startle", this).call(this);
      this.onNextFrame(() => this.args.animation = 'startle');
    }
  }, {
    key: "dropBomb",
    value: function dropBomb() {
      if (this.args.falling) {
        this.args.ySpeed = -8;
      }
      const bomb = new _KnuxBomb.KnuxBomb({
        x: this.args.x,
        y: this.args.y - 16,
        owner: this,
        xSpeed: this.args.xSpeed,
        ySpeed: -3
      });
      ;
      this.viewport.spawn.add({
        object: bomb
      });
    }
  }, {
    key: "release_0",
    value: function release_0() {
      if (this.args.flying) {
        this.args.flying = false;
        this.args.ySpeed *= 0.25;
      }

      // super.release_0();
    }
  }, {
    key: "command_0",
    value: function command_0() {
      this.args.bellySliding = false;
      _get(_getPrototypeOf(Knuckles.prototype), "command_0", this).call(this);
      if (this.args.hangingFrom || !this.args.jumping || this.willPunch || !this.args.falling) {
        return;
      }
      if (this.args.wasHanging) {
        return;
      }
      if (this.args.falling) {
        this.args.punchMomentum = 0;
        this.punching = false;
      }
      if (!this.args.jumpArced) {
        if (this.getMapSolidAt(this.args.x + Math.sign(this.args.direction) * this.args.width * 0.5, this.args.height * 0.5)) {
          this.args.xSpeed = Math.sign(this.args.direction) * this.args.width * 0.5;
          this.willStick = true;
          this.args.climbing = true;
          return;
        }
      }
      this.args.direction = Math.sign(this.args.xSpeed) || (this.args.facing === 'left' ? -1 : 1);
      this.args.willJump = false;
      this.args.flying = true;
      this.args.xSpeed = Math.max(4, Math.abs(this.args.xSpeed)) * this.args.direction;
      this.args.ySpeed = Math.max(0, this.args.ySpeed);
    }
  }, {
    key: "readyStart",
    value: function readyStart() {
      let inputDirection = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      let button = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      if (this.readyTime && this.viewport.args.frameId - this.readyTime > 20) {
        return;
      }
      this.readyTime = this.viewport.args.frameId;
      if (this.args.flying || this.args.climbing || this.args.falling) {
        return;
      }
      this.readyButton = button;
      if (this.punchTime && this.viewport.args.frameId - this.punchTime < 9) {
        this.args.punchMomentum = 0;
        // this.args.ignore = 16;
        this.willPunch = false;
        this.punchTime = false;
        this.punched = 0;
        return;
      }
      this.willPunch = true;
      const direction = Math.sign(this.xAxis || inputDirection || this.args.direction);
      this.args.direction = Math.sign(direction || this.args.punchMomentum);
      if (direction < 0) {
        this.args.facing = 'left';
      } else {
        this.args.facing = 'right';
      }
      if (this.punchTime) {
        this.args.gSpeed = 0;
        this.punchTime = false;
        return;
      }
      this.args.punchMomentum = Math.abs(this.args.punchMomentum || this.args.gSpeed || 4) * Math.sign(direction || this.xAxis);
      this.args.gSpeed = 0;
    }
  }, {
    key: "damage",
    value: function damage(other, type) {
      if (this.readyTime) {
        return false;
      }
      _get(_getPrototypeOf(Knuckles.prototype), "damage", this).call(this, other, type);
    }
  }, {
    key: "readyStop",
    value: function readyStop(inputDirection, button) {
      this.readyTime = false;
      if (this.readyButton !== button) {
        return;
      }
      this.readyButton = false;
      if (this.args.flying || this.args.climbing || this.args.falling) {
        return;
      }
      if (this.punchTime && this.viewport.args.frameId - this.punchTime < 64) {
        this.willPunch = false;
        // this.args.punchMomentum = 0;
        this.punched = 0;
        return;
      }
      this.args.direction = this.args.facing === 'left' ? -1 : 1;
      const direction = this.args.direction;
      if (!direction || Math.sign(direction) === Math.sign(this.args.punchMomentum)) {
        this.args.gSpeed = direction ? Math.abs(this.args.punchMomentum) * direction : this.args.punchMomentum;
      } else if (direction) {
        this.args.punchMomentum = Math.abs(this.args.punchMomentum) * direction;
        this.args.gSpeed = 1 * (direction ? Math.abs(this.args.punchMomentum) * direction : this.args.punchMomentum);
      }
      this.args.direction = Math.sign(direction || this.args.punchMomentum);
      if (direction < 0) {
        this.args.facing = 'left';
      } else {
        this.args.facing = 'right';
      }
      this.punchTime = this.viewport.args.frameId;
      this.willPunch = false;
      if (!this.args.falling && this.args.gSpeed) {
        const dustParticle = new _Tag.Tag(`<div class = "particle-dust">`);
        const dustDist = Math.sign(this.args.gSpeed) * this.dustDist || 0;
        const dustPoint = this.rotatePoint(this.args.gSpeed, 0);
        dustParticle.style({
          '--x': dustPoint[0] + dustDist + this.x,
          '--y': dustPoint[1] + this.y,
          'z-index': 0,
          opacity: Math.pow(Math.random(), 2) * 0.5 + 0.5
        });
        viewport.particles.add(dustParticle);
        viewport.onFrameOut(20, () => {
          viewport.particles.remove(dustParticle);
        });
      }
      if (this.throwing || this.args.climbing) {
        return;
      }
      this.punched++;
    }
  }, {
    key: "command_1",
    value: function command_1() {
      if (this.args.climbing) {
        this.args.x += this.args.width / 2 * (this.args.mode === 1 ? 1 : -1);
        this.bMap('doJump', 0);
        return;
      }
      if (this.args.falling) {
        this.readyStart(0, 1);
        return;
      }
      if (this.cancelReady) {
        this.cancelReady();
        this.cancelReady = false;
      }
      this.args.direction = this.args.facing === 'left' ? -1 : 1;
      this.args.punchMomentum = this.args.punchMomentum || this.args.gSpeed || 3 * (this.args.direction || 1);
      if (!this.args.gSpeed || !this.punched) {
        this.readyButton = 1;
        this.punching = true;
        this.readyStop(Math.sign(this.args.punchMomentum), 1);
        this.cancelReady = this.viewport.onFrameOut(20, () => this.readyStart(this.args.direction, 1));
        return;
      }
      if (this.args.gSpeed > 10) {
        this.punchAura.style({
          display: 'initial'
        });
        this.auraVisible = true;
      }
      this.punched = this.punched || 1;
      this.args.gSpeed = 0;
      this.readyStart(0, 1);
    }
  }, {
    key: "release_1",
    value: function release_1() {
      if (this.args.falling) {
        return;
      }
      if (this.willPunch) {
        this.readyStop(0, 1);
        return;
      }
      if (this.punchTime && this.viewport.args.frameId - this.punchTime < 220) {
        return;
      }
      if (this.punchTime && this.viewport.args.frameId - this.punchTime > 320) {
        return;
      }
      if (this.args.gSpeed) {
        return;
      }

      // this.args.gSpeed = 0;

      if (!this.cancelReady) {
        this.cancelReady = this.viewport.onFrameOut(40, () => this.readyStart(this.args.direction, 1));
      }
    }
  }, {
    key: "command_4",
    value: function command_4() {
      this.readyStart(-1, 4);
    }
  }, {
    key: "release_4",
    value: function release_4() {
      this.readyStop(-1, 4);
    }
  }, {
    key: "command_5",
    value: function command_5() {
      this.readyStart(1, 5);
    }
  }, {
    key: "release_5",
    value: function release_5() {
      this.readyStop(1, 5);
    }
  }, {
    key: "command_2",
    value: function command_2() {
      // if(!this.args.ignore && this.args.falling && !this.args.flying && this.bombsDropped < 3)
      // {
      // 	this.dropBomb();

      // 	this.bombsDropped++;

      // 	return;
      // }

      // if(this.args.falling || this.args.climbing)
      // {
      // 	return;
      // }

      // if(Math.abs(this.args.gSpeed) > 3)
      // {
      // 	return;
      // }

      // if(this.punchTime || this.throwing)
      // {
      // 	return;
      // }

      // this.holdBomb = this.viewport.args.frameId;
      // this.args.ignore = -1;
      // this.args.gSpeed = 0;
    }
  }, {
    key: "release_2",
    value: function release_2() {
      if (this.args.falling || this.args.climbing) {
        return;
      }
      if (Math.abs(this.args.gSpeed) > 3) {
        return;
      }
      if (!this.holdBomb) {
        return;
      }
      this.args.ignore = 4;
      this.holdBomb = false;
      this.throwing = this.viewport.args.frameId;
    }
  }, {
    key: "setCameraMode",
    value: function setCameraMode() {
      if (this.args.climbing) {
        this.args.cameraMode = 'climbing';
      } else {
        _get(_getPrototypeOf(Knuckles.prototype), "setCameraMode", this).call(this);
      }
    }
  }, {
    key: "collideA",
    value: function collideA(other) {
      if (other instanceof _Spring.Spring) {
        this.onNextFrame(() => {
          if (!this.args.falling || this.args.hangingFrom) {
            return;
          }
          this.springing = true;
          this.args.animation = 'springdash';
        });
      }
      if (other.pop && this.isHyper) {
        other.pop(this);
      }
    }
  }, {
    key: "rotateMainColor",
    value: function rotateMainColor() {
      let rH = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      let rS = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      let rV = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
      const rotatedColors = {
        'f1958e': new _Color.Color('f1958e').rotate(rH, rS, rV).toString(),
        'd3565c': new _Color.Color('d3565c').rotate(rH, rS, rV).toString(),
        'c00020': new _Color.Color('c00020').rotate(rH, rS, rV).toString(),
        // // '900000': new Color('900000').rotate(rH, rS, rV).toString(),
        '600020': new _Color.Color('600020').rotate(rH, rS, rV).toString()
      };
      this.png.ready.then(() => {
        const newPng = this.png.recolor(rotatedColors);
        this.args.rotatedSpriteSheet = this.rotatedSpriteSheet = this.spriteSheet = newPng.toUrl();
        this.args.spriteSheet = `url('${this.args.rotatedSpriteSheet}')`;
      });
    }
  }, {
    key: "setProfile",
    value: function setProfile() {
      if (this.isHyper) {
        this.args.spriteSheet = `url('${this.hyperSpriteSheet}')`;
        this.args.gSpeedMax = this.gSpeedMaxHyper;
        this.args.jumpForce = this.jumpForceHyper;
        this.climbSpeedMax = this.climbSpeedMaxSuper;
        this.args.accel = this.accelSuper;
      } else if (this.isSuper) {
        this.args.spriteSheet = `url('${this.superSpriteSheet}')`;
        this.args.gSpeedMax = this.gSpeedMaxSuper;
        this.args.jumpForce = this.jumpForceSuper;
        this.climbSpeedMax = this.climbSpeedMaxSuper;
        this.args.accel = this.accelSuper;
      } else {
        this.args.spriteSheet = `url('${this.rotatedSpriteSheet}')`;
        this.args.gSpeedMax = this.gSpeedMaxNormal;
        this.args.jumpForce = this.jumpForceNormal;
        this.climbSpeedMax = this.climbSpeedMaxNormal;
        this.args.accel = this.accelNormal;
      }
    }
  }, {
    key: "command_3",
    value: function command_3() {}
  }, {
    key: "solid",
    get: function get() {
      return false;
    }
  }, {
    key: "canRoll",
    get: function get() {
      return !this.args.climbing;
    }
  }, {
    key: "canFly",
    get: function get() {
      return true;
    }
  }, {
    key: "isEffect",
    get: function get() {
      return false;
    }
  }, {
    key: "controllable",
    get: function get() {
      return !this.args.npc;
    }
  }]);
  return Knuckles;
}(_PointActor2.PointActor);
exports.Knuckles = Knuckles;
});

;require.register("actor/KnuxBomb.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KnuxBomb = void 0;
var _PointActor2 = require("./PointActor");
var _Explosion = require("../actor/Explosion");
var _Tag = require("curvature/base/Tag");
var _Region = require("../region/Region");
var _Spring = require("./Spring");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let KnuxBomb = /*#__PURE__*/function (_PointActor) {
  _inherits(KnuxBomb, _PointActor);
  var _super = _createSuper(KnuxBomb);
  function KnuxBomb() {
    var _this;
    _classCallCheck(this, KnuxBomb);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.type = 'actor-item actor-knux-bomb';
    _this.args.width = 16;
    _this.args.height = 16;
    _this.removeTimer = null;
    return _this;
  }
  _createClass(KnuxBomb, [{
    key: "update",
    value: function update() {
      if (this.removed) {
        return;
      }
      _get(_getPrototypeOf(KnuxBomb.prototype), "update", this).call(this);
      if (!this.args.xSpeed && !this.args.ySpeed && !this.args.gSpeed) {
        this.removeTimer = this.onTimeout(250, () => this.explode());
      }
      if (!this.removeTimer) {
        this.removeTimer = this.onTimeout(1500, () => this.explode());
      }
    }

    // collideA(other)
    // {
    // 	if(other === this.args.owner || other instanceof KnuxBomb || other instanceof Region || other instanceof Spring)
    // 	{
    // 		return false;
    // 	}

    // 	this.args.x += Math.cos(this.args.angle) * other.args.width / 2 * Math.sign(this.args.xSpeed);
    // 	this.args.y += Math.sin(this.args.angle) * other.args.width / 2 * Math.sign(this.args.xSpeed);

    // 	this.explode();

    // 	return false;
    // }
  }, {
    key: "explode",
    value: function explode() {
      const viewport = this.viewport;
      if (!viewport) {
        return;
      }
      const particle = new _Tag.Tag('<div class = "particle-explosion">');
      particle.style({
        '--x': this.x,
        '--y': this.y
      });
      viewport.particles.add(particle);
      setTimeout(() => viewport.particles.remove(particle), 350);
      this.viewport.actors.remove(this);
      this.remove();
    }
  }, {
    key: "canStick",
    get: function get() {
      return false;
    }
  }, {
    key: "solid",
    get: function get() {
      return false;
    }
  }]);
  return KnuxBomb;
}(_PointActor2.PointActor);
exports.KnuxBomb = KnuxBomb;
});

;require.register("actor/LavaBall.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LavaBall = void 0;
var _PointActor2 = require("./PointActor");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let LavaBall = /*#__PURE__*/function (_PointActor) {
  _inherits(LavaBall, _PointActor);
  var _super = _createSuper(LavaBall);
  function LavaBall() {
    var _this;
    _classCallCheck(this, LavaBall);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.width = 16;
    _this.args.height = 16;
    _this.args.float = 0;
    _this.args.type = 'actor-item actor-lava-ball';
    _this.args.jumpForce = 7.25;
    _this.args.gravity = 0.2;
    _this.args.density = 25;
    return _this;
  }
  _createClass(LavaBall, [{
    key: "onRendered",
    value: function onRendered() {
      _get(_getPrototypeOf(LavaBall.prototype), "onRendered", this).call(this);
      this.autoAttr.get(this.box)['data-color'] = 'color';
    }
  }, {
    key: "update",
    value: function update() {
      _get(_getPrototypeOf(LavaBall.prototype), "update", this).call(this);
      const age = this.viewport.args.frameId + (this.args.offset || 0);
      if (age % 45 === 0) {
        this.willJump = true;
      }
      this.args.hidden = !this.willJump && !this.args.falling;
    }
  }, {
    key: "collideA",
    value: function collideA(other, type) {
      if (other.controllable && this.args.falling) {
        other.damage(this);
      }
      return _get(_getPrototypeOf(LavaBall.prototype), "collideA", this).call(this, other, type);
    }
  }]);
  return LavaBall;
}(_PointActor2.PointActor);
exports.LavaBall = LavaBall;
});

;require.register("actor/LayerController.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LayerController = void 0;
var _PointActor2 = require("./PointActor");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let LayerController = /*#__PURE__*/function (_PointActor) {
  _inherits(LayerController, _PointActor);
  var _super = _createSuper(LayerController);
  function LayerController(args, parent) {
    var _this$args$fall, _this$args$yQuake;
    var _this;
    _classCallCheck(this, LayerController);
    _this = _super.call(this, args, parent);
    _this.args.activated = false;
    _this.args.xLayer = 0;
    _this.args.yLayer = 0;
    _this.args.xLayerSpeed = 0;
    _this.args.yLayerSpeed = 0;
    _this.args.yLayerSpeedMax = _this.args.yLayerSpeedMax || 9;
    _this.args.fall = (_this$args$fall = _this.args.fall) !== null && _this$args$fall !== void 0 ? _this$args$fall : true;
    _this.args.xLayerLimit = _this.args.xLayerLimit || null;
    _this.args.yLayerLimit = _this.args.yLayerLimit || null;
    _this.args.yQuake = (_this$args$yQuake = _this.args.yQuake) !== null && _this$args$yQuake !== void 0 ? _this$args$yQuake : 5;
    _this.args.static = true;
    _this.args.hidden = true;
    return _this;
  }
  _createClass(LayerController, [{
    key: "updateStart",
    value: function updateStart() {
      if (!this.viewport) {
        return;
      }
      if (this.args.activated && this.args.fall) {
        this.args.yLayerSpeed += 0.25;
      }
      if (this.args.activated && this.args.swim) {
        this.args.xLayerSpeed += 1;
      }
      if (this.args.yLayerSpeed > this.args.yLayerSpeedMax && this.args.yLayerSpeedMax > 0) {
        this.args.yLayerSpeed = this.args.yLayerSpeedMax;
      }
      if (this.args.xLayerSpeed > this.args.xLayerSpeedMax && this.args.xLayerSpeedMax > 0) {
        this.args.xLayerSpeed = this.args.xLayerSpeedMax;
      }
      if (this.args.yLayerSpeed) {
        this.args.yLayer = Math.round(this.args.yLayer + this.args.yLayerSpeed || 0);
      }
      if (this.args.xLayerSpeed) {
        this.args.xLayer = Math.round(this.args.xLayer + this.args.xLayerSpeed || 0);
      }
      const tileSize = this.viewport.tileMap.mapData.tileheight;
      const xMapTiles = this.viewport.tileMap.mapData.width;
      const yMapTiles = this.viewport.tileMap.mapData.height;
      const mapWidth = this.viewport.tileMap.meta.wrapX ? Infinity : xMapTiles * tileSize;
      const mapHeight = this.viewport.tileMap.meta.wrapY ? Infinity : yMapTiles * tileSize;
      if (this.args.yLayerLimit > 0 && this.args.yLayer > mapHeight && this.args.yLayer > this.args.yLayerLimit) {
        this.args.yLayerSpeed = 0;
        this.args.yLayer = this.args.yLayerLimit;
        if (this.args.target) {
          const target = this.viewport.actorsById[this.args.target];
          this.viewport.auras.delete(target);
        }
        this.viewport.auras.delete(this);
      }
      if (this.args.xLayerLimit > 0 && (this.args.xLayer > mapWidth || this.args.xLayer > this.args.xLayerLimit)) {
        this.args.xLayerSpeed = 0;
        this.args.xLayer = this.args.xLayerLimit;
        if (this.args.target) {
          const target = this.viewport.actorsById[this.args.target];
          this.viewport.auras.delete(target);
        }
        this.viewport.auras.delete(this);
      }
    }
  }, {
    key: "activate",
    value: function activate(other, button) {
      var _this$args$yLayerLimi;
      if (this.args.activated) {
        return;
      }
      if (other) {
        this.args.x = other.x;
        this.args.y = other.y;
      }
      this.viewport.auras.add(this);
      this.viewport.args.shakeY = this.args.yQuake;
      this.viewport.onFrameOut(90, () => {
        this.args.activated = true;
      });
      this.args.yLayerLimit = (_this$args$yLayerLimi = this.args.yLayerLimit) !== null && _this$args$yLayerLimi !== void 0 ? _this$args$yLayerLimi : 4096;
      if (this.args.target && this.viewport.actorsById[this.args.target]) {
        const target = this.viewport.actorsById[this.args.target];
        this.viewport.auras.add(target);
        target.activate(other, this);
      }
    }
  }]);
  return LayerController;
}(_PointActor2.PointActor);
exports.LayerController = LayerController;
});

;require.register("actor/LayerSwitch.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LayerSwitch = void 0;
var _PointActor2 = require("./PointActor");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let LayerSwitch = /*#__PURE__*/function (_PointActor) {
  _inherits(LayerSwitch, _PointActor);
  var _super = _createSuper(LayerSwitch);
  function LayerSwitch() {
    var _this$args$fromLayer, _this$args$toLayer;
    var _this;
    _classCallCheck(this, LayerSwitch);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _defineProperty(_assertThisInitialized(_this), "float", -1);
    _this.args.type = 'actor-item actor-layer-switch';
    _this.args.width = 32;
    _this.args.height = 32;
    _this.args.static = true;
    _this.args.fromLayer = (_this$args$fromLayer = _this.args.fromLayer) !== null && _this$args$fromLayer !== void 0 ? _this$args$fromLayer : 1;
    _this.args.toLayer = (_this$args$toLayer = _this.args.toLayer) !== null && _this$args$toLayer !== void 0 ? _this$args$toLayer : 2;
    return _this;
  }
  _createClass(LayerSwitch, [{
    key: "onAttach",
    value: function onAttach(event) {
      event && event.preventDefault();
      return false;
    }
  }, {
    key: "collideA",
    value: function collideA(other, type) {
      let speed = other.args.gSpeed || other.args.xSpeed || other.args.direction || other.xAxis;
      let back = !!Number(this.args.back);
      let roll = !!Number(this.args.roll);
      const invert = other.args.mode === 2 || other.args.mode === 3 ? -1 : 1;
      const radius = this.args.width / 2;
      const otherRadius = 0; //other.args.width / 2;

      const thisX = this.args.x;
      const thisY = this.args.y;
      const otherX = other.args.x;
      const otherY = other.args.y;
      if (otherX < thisX + -radius + otherRadius || otherX > thisX + radius + -otherRadius) {
        return;
      }
      if (otherY < thisY + -this.args.height || other.y > thisY) {
        return;
      }
      if (this.args.allow || this.args.disallow) {
        if (this.args.allow) {
          other.doorMap.set(Number(this.args.allow), false);
        }
        if (this.args.disallow) {
          other.doorMap.set(Number(this.args.disallow), true);
        }
        return;
      }
      if (roll && (!other.args.rolling || other.args.height > 28)) {
        other.args.layer = toLayer === this.args.fromLayer ? this.args.toLayer : this.args.fromLayer;
        return false;
      }
      if (back && other.args.falling) {
        speed = other.args.xSpeed || other.args.direction;
        back = !back;
      }
      let toLayer = other.args.layer;
      let fromLayer = this.args.fromLayer;
      if (speed > 0) {
        toLayer = back ? this.args.fromLayer : this.args.toLayer;
        fromLayer = back ? this.args.toLayer : this.args.fromLayer;
      }
      if (speed < 0) {
        toLayer = back ? this.args.toLayer : this.args.fromLayer;
        fromLayer = back ? this.args.fromLayer : this.args.toLayer;
      }
      if (!this.viewport.tileMap.getSolid(otherX, otherY, toLayer)) {
        if (!other.args.layer || other.args.layer === fromLayer) {
          other.args.layer = toLayer;
        }
      } else {
        this.viewport.onFrameOut(1, () => {
          if (!this.viewport.tileMap.getSolid(otherX, otherY, toLayer)) {
            other.args.layer = toLayer;
          }
        });
      }
    }
  }, {
    key: "solid",
    get: function get() {
      return false;
    }
  }, {
    key: "isEffect",
    get: function get() {
      return true;
    }
  }], [{
    key: "fromDef",
    value: function fromDef(objDef) {
      const obj = _get(_getPrototypeOf(LayerSwitch), "fromDef", this).call(this, objDef);
      obj.args.width = objDef.width;
      obj.args.height = objDef.height;
      return obj;
    }
  }]);
  return LayerSwitch;
}(_PointActor2.PointActor);
exports.LayerSwitch = LayerSwitch;
});

;require.register("actor/LightSource.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LightSource = void 0;
var _PointActor2 = require("./PointActor");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let LightSource = /*#__PURE__*/function (_PointActor) {
  _inherits(LightSource, _PointActor);
  var _super = _createSuper(LightSource);
  function LightSource() {
    var _this;
    _classCallCheck(this, LightSource);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.type = 'actor-item actor-light-source';
    _this.args.hidden = true;
    _this.args.static = true;
    _this.args.float = -1;
    return _this;
  }
  _createClass(LightSource, [{
    key: "solid",
    get: function get() {
      return false;
    }
  }], [{
    key: "fromDef",
    value: function fromDef(objDef) {
      const obj = _get(_getPrototypeOf(LightSource), "fromDef", this).call(this, objDef);
      if (objDef.polygon) {
        obj.args.polygon = objDef.polygon.map(p => Object.assign({}, p));
      }
      return obj;
    }
  }]);
  return LightSource;
}(_PointActor2.PointActor);
exports.LightSource = LightSource;
});

;require.register("actor/Magnet.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Magnet = void 0;
var _PointActor = require("./PointActor");
var _Mixin = require("curvature/base/Mixin");
var _Constrainable = require("../mixin/Constrainable");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let Magnet = /*#__PURE__*/function (_Mixin$from) {
  _inherits(Magnet, _Mixin$from);
  var _super = _createSuper(Magnet);
  function Magnet() {
    var _this;
    _classCallCheck(this, Magnet);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.gravity = 0.8;
    _this.args.width = 48;
    _this.args.height = 28;
    _this.args.type = 'actor-item actor-magnet';
    return _this;
  }
  _createClass(Magnet, [{
    key: "collideA",
    value: function collideA(other, type) {}
  }, {
    key: "collideB",
    value: function collideB(other) {
      if (other.controllable) {
        // other.startle();
      }
    }
  }, {
    key: "update",
    value: function update() {
      _get(_getPrototypeOf(Magnet.prototype), "update", this).call(this);
      this.setPos();
    }
  }]);
  return Magnet;
}(_Mixin.Mixin.from(_PointActor.PointActor, _Constrainable.Constrainable));
exports.Magnet = Magnet;
});

;require.register("actor/MarbleBlock.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MarbleBlock = void 0;
var _PointActor2 = require("./PointActor");
var _Platformer = require("../behavior/Platformer");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let MarbleBlock = /*#__PURE__*/function (_PointActor) {
  _inherits(MarbleBlock, _PointActor);
  var _super = _createSuper(MarbleBlock);
  function MarbleBlock() {
    var _this;
    _classCallCheck(this, MarbleBlock);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.type = 'actor-item actor-block-marble';
    _this.args.width = 32;
    _this.args.height = 32;
    _this.args.spriteSheet = _this.args.spriteSheet || '/Sonic/marble-zone-block.png';
    return _this;
  }
  _createClass(MarbleBlock, [{
    key: "collideA",
    value: function collideA(other, type) {
      _get(_getPrototypeOf(MarbleBlock.prototype), "collideA", this).call(this, other, type);
      if (other.isEffect) {
        return false;
      }
      if (!this.isPushable) {
        return true;
      }
      const otherMag = Math.ceil(Math.abs(other.args.gSpeed || other.args.xSpeed));
      const otherDir = Math.sign(other.args.gSpeed || other.args.xSpeed);
      let otherSpeed = otherMag * otherDir;
      if (!this.args.falling && type === 1 && otherSpeed <= 0) {
        return false;
      }
      if (!this.args.falling && type === 3 && otherSpeed >= 0) {
        return false;
      }
      const blockTop = this.y - this.args.height;
      if ((type === 1 || type === 3) && (other.y >= this.y || other.y > blockTop)) {
        if (!otherSpeed) {
          return true;
        }
        this.args.pushed = Math.sign(other.args.gSpeed) || this.args.pushed;
        if (this.args.pushed < 0 && this.getMapSolidAt(this.x - Math.ceil(this.args.width / 2) + -1, this.y + -4)) {
          return true;
        }
        if (this.args.pushed > 0 && this.getMapSolidAt(this.x + Math.ceil(this.args.width / 2) + 1, this.y + -4)) {
          return true;
        }
        const tileMap = this.viewport.tileMap;
        const moveBy = type === 1 && 1 || type === 3 && -1;
        const blockers = tileMap.getSolid(this.x + Math.ceil(this.args.width / 2) * moveBy, this.y + -4);
        if (blockers) {
          return true;
        }
        const radius = this.args.width / 2;
        if (!this.args.falling) {
          const nextCenter = this.bMap('findNextStep', moveBy).get(_Platformer.Platformer);
          // const nextWall   = this.bMap('findNextStep', moveBy + (radius * Math.sign(moveBy))).get(Platformer);

          if (nextCenter[2]) {
            // this.args.xSpeed = moveBy;

            const scan = this.scanBottomEdge(moveBy);
            if (scan && scan <= (this.args.width + this.args.width % 2) * 0.5) {
              this.args.xSpeed = Math.sign(moveBy);
              this.args.x += scan * Math.sign(moveBy);
            }

            // this.args.falling = true;
          } else if (!nextCenter[3]) {
            const otherRadius = other.args.width / 2;
            const myRadius = this.args.width / 2;
            if (Math.trunc(Math.abs(this.x - other.x)) <= 1 + otherRadius + myRadius) {
              // this.args.x = other.args.x + (moveBy * (Math.abs(other.args.gSpeed) + myRadius + otherRadius));
              this.args.x += nextCenter[0];
              this.args.y -= nextCenter[1];
              const direction = Math.sign(other.args.gSpeed);
              if (Math.sign(this.x - other.x) === direction) {
                other.args.pushing = direction;
                // other.args.rolling = false;
              }

              const weightRatio = this.args.weight / other.args.weight;
              other.args.gSpeed -= weightRatio * 0.005 * Math.sign(other.args.gSpeed);
            }
            return false;
          }
          return true;
        }
      }
      if (other.args.ySpeed < 0) {
        return false;
      }
      return true;
    }
  }, {
    key: "onAttach",
    value: function onAttach() {
      this.args.spriteSheet = this.args.spriteSheet || '/Sonic/marble-zone-block.png';
      if (this.viewport) {
        this.setTile();
      }
    }
  }, {
    key: "isPushable",
    get: function get() {
      return true;
    }
  }, {
    key: "canStick",
    get: function get() {
      return false;
    }
  }, {
    key: "solid",
    get: function get() {
      return true;
    }
  }, {
    key: "rotateLock",
    get: function get() {
      return true;
    }
  }]);
  return MarbleBlock;
}(_PointActor2.PointActor);
exports.MarbleBlock = MarbleBlock;
});

;require.register("actor/Marker.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Marker = void 0;
var _PointActor2 = require("./PointActor");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let Marker = /*#__PURE__*/function (_PointActor) {
  _inherits(Marker, _PointActor);
  var _super = _createSuper(Marker);
  function Marker() {
    var _this;
    _classCallCheck(this, Marker);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.type = 'actor-item actor-marker';
    _this.args.width = 64;
    _this.args.height = 64;
    _this.args.float = -1;
    return _this;
  }
  _createClass(Marker, [{
    key: "solid",
    get: function get() {
      return false;
    }
  }]);
  return Marker;
}(_PointActor2.PointActor);
exports.Marker = Marker;
});

;require.register("actor/Meanie.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Meanie = void 0;
var _Flickie = require("./Flickie");
var _Mixin = require("curvature/base/Mixin");
var _PointActor = require("./PointActor");
var _Patrol = require("../behavior/Patrol");
var _CanPop = require("../mixin/CanPop");
var _ObjectPalette = require("../ObjectPalette");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let Meanie = /*#__PURE__*/function (_Mixin$from) {
  _inherits(Meanie, _Mixin$from);
  var _super = _createSuper(Meanie);
  function Meanie() {
    var _this$args$patrolPaus, _this$args$patrolBeat, _this$args$patrolSpee, _this$args$hatType;
    var _this;
    _classCallCheck(this, Meanie);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.behaviors.add(new _Patrol.Patrol());
    _this.args.type = 'actor-item actor-meanie';
    _this.args.animation = 'standing';
    _this.args.accel = 0.1;
    _this.args.decel = 0.5;
    _this.args.gSpeedMax = 5;
    _this.args.jumpForce = 5;
    _this.args.gravity = 0.5;
    _this.args.width = 16;
    _this.args.height = 29;
    _this.willStick = false;
    _this.stayStuck = false;
    _this.args.patrolPause = (_this$args$patrolPaus = _this.args.patrolPause) !== null && _this$args$patrolPaus !== void 0 ? _this$args$patrolPaus : 40;
    _this.args.patrolBeat = (_this$args$patrolBeat = _this.args.patrolBeat) !== null && _this$args$patrolBeat !== void 0 ? _this$args$patrolBeat : 140;
    _this.args.patrolSpeed = (_this$args$patrolSpee = _this.args.patrolSpeed) !== null && _this$args$patrolSpee !== void 0 ? _this$args$patrolSpee : 1;

    // this.args.hatType = this.args.hatType ?? 'skull';
    _this.args.hatType = (_this$args$hatType = _this.args.hatType) !== null && _this$args$hatType !== void 0 ? _this$args$hatType : 'pumpkin';
    _this.args.maxBoost = 0;
    return _this;
  }
  _createClass(Meanie, [{
    key: "wakeUp",
    value: function wakeUp(event) {
      if (!this.viewport) {
        return;
      }
      if (!this.hat && _ObjectPalette.ObjectPalette[this.args.hatType]) {
        this.hat = new _ObjectPalette.ObjectPalette[this.args.hatType]();
        this.viewport.spawn.add({
          object: this.hat
        });
        this.hat.args.float = -1;
        this.hat.noClip = true;
        this.hat.args.x = this.args.x;
        this.hat.args.y = this.args.y + 14;
        this.viewport.setColCell(this.hat);
        if (this.args.hatType) {
          this.hat.args.face = true;
        }
      }
    }
  }, {
    key: "update",
    value: function update() {
      this.args.maxBoost = Math.max(this.args.ySpeed, this.args.maxBoost);
      const direction = this.args.direction;
      const telegraph = this.args.shotTelegraph;
      const beat = this.args.patrolBeat;
      if (this.box) {
        if (this.args.moving && this.args.gSpeed) {
          this.box.setAttribute('data-animation', 'walking');
        } else {
          this.box.setAttribute('data-animation', 'standing');
        }
      }
      _get(_getPrototypeOf(Meanie.prototype), "update", this).call(this);
      this.args.groundAngle = 0;
      this.args.mode = 0;
      this.args.direction = Math.sign(this.args.xSpeed || this.args.gSpeed);
      if (!this.args.falling && !this.jumpTimer) {
        this.jumpTimer = this.viewport.onFrameOut(2, () => {
          this.args.ySpeed = -Math.min(this.args.maxBoost, 9);
          this.args.xSpeed = this.args.gSpeed;
          this.args.falling = true;
          this.fallTime = 0;
          this.jumpTimer = false;
        });
      }
      if (this.hat) {
        this.hat.args.direction = this.args.direction;
        this.hat.args.x = this.args.x;
        this.hat.args.y = this.args.y;
        if (this.fallTime > 9 || this.fallTime < 5) {
          this.hat.args.y += -14;
        } else {
          this.hat.args.y += -10;
        }
        this.hat.args.z = this.args.z + 1;
        if (this.viewport) {
          this.viewport.setColCell(this.hat);
        }
      }
    }
  }, {
    key: "effect",
    value: function effect(other) {
      _get(_getPrototypeOf(Meanie.prototype), "effect", this).call(this, other);

      // this.viewport.spawn.add({object:new Flickie({
      // 	x: this.args.x,
      // 	y: this.args.y,
      // })});
    }
  }, {
    key: "pop",
    value: function pop(other) {
      if (other && !other.controllable) {
        return;
      }
      if (this.hat) {
        const hat = this.hat;
        this.viewport.onFrameOut(3, () => {
          if (other) {
            this.args.xSpeed += -2 * (Math.sign(other.args.xSpeed || other.args.gSpeed) || 1);
            hat.args.xSpeed = -4 * (Math.sign(other.args.xSpeed || other.args.gSpeed) || 1);
            hat.args.ySpeed = Math.min(-4, -Math.abs(other.args.ySpeed));
            hat.args.float = 1;
          } else {
            hat.args.float = 10;
          }
          hat.noClip = false;
          this.hat = null;
        });
        if (!other.args.rolling) {
          if (other) {
            this.ignores.set(other, 10);
            other.args.gSpeed *= -1;
            other.args.xSpeed *= -1;
            other.args.ySpeed = -4;
            other.args.xSpeed = Math.min(Math.abs(other.args.xSpeed), 6) * Math.sign(other.args.xSpeed);
          }
          return;
        }
      }
      return _get(_getPrototypeOf(Meanie.prototype), "pop", this).call(this, other);
    }
  }, {
    key: "solid",
    get: function get() {
      return false;
    }
  }, {
    key: "isEffect",
    get: function get() {
      return false;
    }
    // get controllable() { return true; }
  }]);
  return Meanie;
}(_Mixin.Mixin.from(_PointActor.PointActor, _CanPop.CanPop));
exports.Meanie = Meanie;
});

;require.register("actor/MechaFroggy.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MechaFroggy = void 0;
var _PointActor2 = require("./PointActor");
var _Tag = require("curvature/base/Tag");
var _SkidDust = require("../behavior/SkidDust");
var _Explosion = require("../actor/Explosion");
var _Projectile = require("../actor/Projectile");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let MechaFroggy = /*#__PURE__*/function (_PointActor) {
  _inherits(MechaFroggy, _PointActor);
  var _super = _createSuper(MechaFroggy);
  function MechaFroggy() {
    var _this;
    _classCallCheck(this, MechaFroggy);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.behaviors.add(new _SkidDust.SkidDust());
    _this.args.type = 'actor-item actor-mecha-froggy';
    _this.args.animation = 'standing';
    _this.args.accel = 0.7;
    _this.args.decel = 0.5;
    _this.args.gSpeedMax = 10;
    _this.args.jumpForce = 15;
    _this.args.gravity = 0.5;
    _this.args.width = 15;
    _this.args.height = 32;
    _this.willStick = false;
    _this.stayStuck = false;
    return _this;
  }
  _createClass(MechaFroggy, [{
    key: "update",
    value: function update() {
      const direction = this.args.direction;
      if (!this.flame) {
        this.flame = new _Tag.Tag('<div class = "mecha-froggy-flame">');
        this.sprite.appendChild(this.flame.node);
      }
      if (!this.args.jumping || this.args.falling) {
        if (Math.sign(this.args.gSpeed) !== direction && Math.abs(this.args.gSpeed - direction) > 5) {
          this.box.setAttribute('data-animation', 'skidding');
        } else if (this.args.moving && this.args.gSpeed && Math.abs(this.args.gSpeed) >= 10) {
          this.box.setAttribute('data-animation', 'running');
        } else if (this.args.moving && this.args.gSpeed && Math.abs(this.args.gSpeed)) {
          this.box.setAttribute('data-animation', 'walking');
        } else {
          this.box.setAttribute('data-animation', 'standing');
        }
      }
      if (this.args.jumping) {
        this.box.setAttribute('data-animation', 'jumping');
      }
      _get(_getPrototypeOf(MechaFroggy.prototype), "update", this).call(this);
    }
  }, {
    key: "solid",
    get: function get() {
      return false;
    }
  }, {
    key: "isEffect",
    get: function get() {
      return false;
    }
  }, {
    key: "controllable",
    get: function get() {
      return true;
    }
  }]);
  return MechaFroggy;
}(_PointActor2.PointActor);
exports.MechaFroggy = MechaFroggy;
});

;require.register("actor/MechaSonic.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MechaSonic = void 0;
var _PointActor2 = require("./PointActor");
var _Platformer = require("../behavior/Platformer");
var _Vehicle = require("./Vehicle");
var _Tag = require("curvature/base/Tag");
var _Sfx = require("../audio/Sfx");
var _SkidDust = require("../behavior/SkidDust");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let MechaSonic = /*#__PURE__*/function (_PointActor) {
  _inherits(MechaSonic, _PointActor);
  var _super = _createSuper(MechaSonic);
  function MechaSonic() {
    var _this;
    _classCallCheck(this, MechaSonic);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.behaviors.add(new _SkidDust.SkidDust('particle-sparks'));
    _this.args.type = 'actor-item actor-mecha-sonic';
    _this.args.accel = 0.1;
    _this.args.decel = 0.3;
    _this.args.skidTraction = 2;
    _this.args.gSpeedMax = 18;
    _this.args.jumpForce = 11;
    _this.args.gravity = 0.5;
    _this.args.takeoffPlayed = false;
    _this.args.rollingHeight = 28;
    _this.args.normalHeight = 44;
    _this.args.width = 18;
    _this.args.height = _this.args.normalHeight;
    _this.args.bindTo('falling', v => {
      if (!v) {
        _this.landSound();
      }
    });
    return _this;
  }
  _createClass(MechaSonic, [{
    key: "onRendered",
    value: function onRendered(event) {
      _get(_getPrototypeOf(MechaSonic.prototype), "onRendered", this).call(this, event);
      this.box = this.findTag('div');
      this.sprite = this.findTag('div.sprite');
    }
  }, {
    key: "update",
    value: function update() {
      if (!this.sprite) {
        return;
      }
      const falling = this.args.falling;
      this.args.accel = 0.1;
      const direction = this.args.direction;
      const gSpeed = this.args.gSpeed;
      const speed = Math.abs(gSpeed);
      const maxSpeed = 100;
      const minRun = 100 * 0.1;
      const minRun2 = 0.5 * this.args.gSpeedMax;
      if (!this.flame) {
        this.sparks = new _Tag.Tag('<div class = "mecha-sonic-sparks">');
        this.flame = new _Tag.Tag('<div class = "mecha-sonic-flame">');
        this.sprite.appendChild(this.sparks.node);
        this.sprite.appendChild(this.flame.node);
      }
      if (this.viewport.args.audio && !this.thrusterSound) {
        this.thrusterSound = new Audio('/Sonic/mecha-sonic-thruster.wav');
        this.scrapeSound = new Audio('/Sonic/mecha-sonic-scrape.wav');
        this.scrapeSound.volume = 0.1;
        this.thrusterSound.loop = true;
        this.scrapeSound.loop = true;
      }
      if (this.thrusterSound) {
        this.thrusterSound.volume = 0.15 + Math.random() * -0.05;
        if (this.thrusterSound.currentTime > 1.5) {
          this.thrusterSound.currentTime = 0.5;
        }
        if (this.scrapeSound.currentTime > 1.5) {
          this.scrapeSound.currentTime = 0.5;
        }
      }
      if (!falling) {
        this.dashed = false;
      }
      if (!this.args.rolling && !falling) {
        if (this.yAxis > 0) {
          this.args.crouching = true;
        } else {
          this.args.crouching = false;
        }
        if (Math.sign(this.args.gSpeed) !== direction && Math.abs(this.args.gSpeed - direction) > 5) {
          this.scrapeSound && this.scrapeSound.play();
          this.args.animation = 'skidding';
        } else if (speed >= minRun2) {
          this.scrapeSound && this.scrapeSound.pause();
          this.args.animation = 'running2';
          this.thrusterSound && this.thrusterSound.play();
          if (!this.args.takeoffPlayed) {
            this.args.takeoffPlayed = true;
            _Sfx.Sfx.play('MECHASONIC_TAKEOFF');
          }
          this.args.accel = 0.75;
          if (speed > maxSpeed * 0.75) {
            this.args.accel = 0.03;
          }
        } else if (speed >= minRun) {
          this.scrapeSound && this.scrapeSound.play();
          this.args.animation = 'running';
        } else if (this.args.moving && gSpeed) {
          this.scrapeSound && this.scrapeSound.play();
          if (this.args.animation === 'curling' || this.args.animation === 'jumping' || this.args.animation === 'rolling') {
            this.args.animation = 'uncurling';
            this.onTimeout(128, () => {
              this.args.animation = 'walking';
            });
          } else if (this.args.animation === 'standing' || this.args.animation === 'running' || this.args.animation === 'running2') {
            this.args.animation = 'walking';
          }
        } else if (this.args.crouching || this.standingOn && this.standingOn.isVehicle) {
          this.args.animation = 'crouching';
        } else {
          this.scrapeSound && this.scrapeSound.pause();
          if (this.args.animation === 'curling' || this.args.animation === 'jumping' || this.args.animation === 'rolling') {
            this.args.animation = 'uncurling';
            this.onTimeout(128, () => {
              this.args.animation = 'standing';
            });
          } else if (this.args.animation === 'walking' || this.args.animation === 'running' || this.args.animation === 'running2' || this.args.animation === 'skidding' || this.args.animation === 'crouching' || this.args.animation === 'rolling') {
            this.args.animation = 'standing';
          }
        }
        if (speed < minRun2) {
          this.closeThruster();
        }
      } else if (this.args.rolling) {
        this.scrapeSound && this.scrapeSound.pause();
        if (this.args.animation !== 'curling' && this.args.animation !== 'uncurling' && this.args.animation !== 'rolling' && this.args.animation !== 'jumping') {
          this.args.animation = 'crouching';
          this.onTimeout(200, () => {
            if (this.args.rolling) {
              this.args.animation = 'rolling';
              this.closeThruster();
            }
          });
        }
      } else {
        this.scrapeSound && this.scrapeSound.pause();
        if (this.dashed) {
          this.args.animation = 'running2';
        } else if (this.args.animation !== 'rolling' && this.args.animation !== 'jumping' && this.args.animation !== 'uncurling' && this.args.animation !== 'curling' && this.args.animation !== 'crouching') {
          this.args.animation = 'curling';
          this.onTimeout(200, () => {
            _Sfx.Sfx.play('MECHASONIC_SLAP');
            if (this.args.falling) {
              if (this.dashed) {
                this.args.animation = 'running2';
              } else if (this.args.jumping) {
                this.args.animation = 'jumping';
              }
              this.closeThruster();
            }
          });
        } else if (!this.args.jumping) {
          this.args.animation = 'crouching';
        }
      }
      _get(_getPrototypeOf(MechaSonic.prototype), "update", this).call(this);
    }
  }, {
    key: "closeThruster",
    value: function closeThruster() {
      if (this.args.takeoffPlayed) {
        this.landSound();
      }
      this.args.takeoffPlayed = false;
      this.thrusterSound && this.thrusterSound.pause();
    }
  }, {
    key: "landSound",
    value: function landSound() {
      _Sfx.Sfx.play('MECHASONIC_SLAP');
    }
  }, {
    key: "sleep",
    value: function sleep() {
      this.thrusterSound && this.thrusterSound.pause();
      this.scrapeSound && this.scrapeSound.pause();
    }
  }, {
    key: "command_5",
    value: function command_5() {
      if (this.args.falling) {
        this.airDash(1);
      }
    }
  }, {
    key: "command_4",
    value: function command_4() {
      if (this.args.falling) {
        this.airDash(-1);
      }
    }
  }, {
    key: "airDash",
    value: function airDash(direction) {
      if (this.dashed || this.args.ignore && this.args.ignore !== -2) {
        return;
      }
      if (direction < 0) {
        this.args.direction = -1;
        this.args.facing = 'left';
      } else {
        this.args.direction = 1;
        this.args.facing = 'right';
      }
      let dashSpeed = direction * 7;
      this.args.float = 3;
      this.args.mode = 0;
      this.args.float = 2;
      this.args.rolling = false;
      this.args.height = this.args.normalHeight;
      if (this.args.xSpeed && Math.sign(this.args.xSpeed) !== Math.sign(direction)) {
        dashSpeed = direction * 11;
        this.args.float = 6;
        this.args.xSpeed = 0;
      }
      this.args.falling = true;
      const finalSpeed = this.args.xSpeed + dashSpeed;
      const space = this.bMap('scanForward', dashSpeed, 0.5).get(_Platformer.Platformer);
      if (space && Math.abs(finalSpeed) > Math.abs(space)) {
        dashSpeed = space * Math.sign(finalSpeed);
      }
      this.args.xSpeed = finalSpeed;
      this.args.ySpeed = 0;
      this.dashTimer = 0;
      this.dashed = true;
      this.args.mode = 0;
      this.args.groundAngle = 0;
      this.args.takeoffPlayed = true;
      if (this.takeoffSound) {
        _Sfx.Sfx.play('MECHASONIC_TAKEOFF');
      }
    }

    // get solid() { return !this.occupant; }
    // get isVehicle() { return true; }
  }, {
    key: "canRoll",
    get: function get() {
      return true;
    }
  }, {
    key: "controllable",
    get: function get() {
      return true;
    }
  }]);
  return MechaSonic;
}(_PointActor2.PointActor);
exports.MechaSonic = MechaSonic;
});

;require.register("actor/MegaMace.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MegaMace = void 0;
var _PointActor = require("./PointActor");
var _Mixin = require("curvature/base/Mixin");
var _Constrainable = require("../mixin/Constrainable");
var _SkidDust = require("../behavior/SkidDust");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let MegaMace = /*#__PURE__*/function (_Mixin$from) {
  _inherits(MegaMace, _Mixin$from);
  var _super = _createSuper(MegaMace);
  function MegaMace() {
    var _this;
    _classCallCheck(this, MegaMace);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.decel = 0.0;
    _this.args.width = 64;
    _this.args.height = 64 - 12;
    _this.args.type = 'actor-item actor-mega-mace';

    // this.behaviors.add(new SkidDust('particle-dust'));

    _this.args.ropeLength = _this.args._tiedTo ? _this.args.ropeLength : 8;
    _this.args.gravity = 0.8;
    // this.alwaysSkidding  = true;

    _this.args.xSpeedMax = 256;
    _this.args.ySpeedMax = 256;
    return _this;
  }
  _createClass(MegaMace, [{
    key: "update",
    value: function update() {
      if (!this.args.tiedTo) {
        _get(_getPrototypeOf(MegaMace.prototype), "update", this).call(this);
      }
    }
  }, {
    key: "updateEnd",
    value: function updateEnd() {
      if (this.viewport && !this.viewport.auras.has(this)) {
        this.viewport.auras.add(this);
      }
      if (this.args.tiedTo) {
        _get(_getPrototypeOf(MegaMace.prototype), "update", this).call(this);
        if (!this.args._tiedTo) {
          this.args._tiedTo = this.viewport.actorsById[this.args.tiedTo];
        }
        if (this.args.tiedTo && this.args._tiedTo.args.hitPoints) {
          this.setPos();
        } else {
          this.noClip = true;
        }
      }
      _get(_getPrototypeOf(MegaMace.prototype), "updateEnd", this).call(this);
    }
  }, {
    key: "collideA",
    value: function collideA(other) {
      if (this.args._tiedTo && !this.args._tiedTo === other) {
        return false;
      }
    }
  }, {
    key: "collideB",
    value: function collideB(other) {
      const _tiedTo = this.others.tiedTo;
      if (_tiedTo && !_tiedTo === other) {
        return false;
      }
      if (_tiedTo && !_tiedTo.args.hitPoints) {
        return;
      }
      if (other.controllable || other.damage) {
        other.damage();
      }
    }
  }]);
  return MegaMace;
}(_Mixin.Mixin.from(_PointActor.PointActor, _Constrainable.Constrainable));
exports.MegaMace = MegaMace;
});

;require.register("actor/MiniBoss.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MiniBoss = void 0;
var _Tag = require("curvature/base/Tag");
var _Platformer = require("../behavior/Platformer");
var _PointActor = require("./PointActor");
var _Mixin = require("curvature/base/Mixin");
var _CanPop = require("../mixin/CanPop");
var _CutScene = require("./CutScene");
var _Sfx = require("../audio/Sfx");
var _EggCapsule = require("./EggCapsule");
var _SpikeBomb = require("./SpikeBomb");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let MiniBoss = /*#__PURE__*/function (_Mixin$from) {
  _inherits(MiniBoss, _Mixin$from);
  var _super = _createSuper(MiniBoss);
  function MiniBoss(args, parent) {
    var _this;
    _classCallCheck(this, MiniBoss);
    _this = _super.call(this, args, parent);
    _this.args.type = 'actor-item actor-mini-boss';
    _this.args.width = 48;
    _this.args.height = 48;
    _this.args.float = -1;
    _this.args.damagers = new Map();
    _this.args.phase = 'idle';
    _this.args.hitPoints = 8;
    _this.args.noseAngle = Math.PI / 2 * 3;
    _this.args.drillPush = 0;
    _this.args.phaseFrameId = 0;
    _this.args.frameId = 0;
    _this.args.direction = -1;
    _this.args.facing = 'left';
    _this.args.bindTo('phase', v => _this.args.phaseFrameId = 0);
    return _this;
  }
  _createClass(MiniBoss, [{
    key: "onRendered",
    value: function onRendered(event) {
      _get(_getPrototypeOf(MiniBoss.prototype), "onRendered", this).call(this, event);
      this.autoAttr.get(this.box)['data-phase'] = 'phase';
      this.attractor = null;
    }
  }, {
    key: "update",
    value: function update() {
      this.args.phaseFrameId++;
      this.args.frameId++;
      if (!this.viewport) {
        return;
      }
      const viewport = this.viewport;
      viewport.auras.add(this);
      const mainChar = this.viewport.controlActor;
      if (!mainChar) {
        return;
      }
      if (!this.attractor) {
        this.attractor = {};
        this.attractor.x = this.x;
        this.attractor.y = this.y;
      }
      const xDiff = Math.abs(this.x - this.attractor.x);
      const yDiff = Math.abs(this.y - this.attractor.y);
      const xSign = Math.sign(this.x - this.attractor.x);
      const ySign = Math.sign(this.y - this.attractor.y);
      switch (this.args.phase) {
        case 'stalking':
          const diff = this.viewport.controlActor.args.x - this.args.x;
          this.args.xSpeed = Math.sign(diff) * Math.min(4.5, Math.abs(diff));
        case 'idle':
          if (this.args.phaseFrameId % 60 === 0) {
            const bomb = new _SpikeBomb.SpikeBomb({
              x: this.args.x,
              y: this.args.y + 16,
              owner: this,
              xSpeed: this.args.xSpeed
            });
            this.viewport.spawn.add({
              object: bomb
            });
          }
          break;
        case 'damaged':
        case 'knocked':
          if (this.args.hitPoints > 0) {
            if (this.args.phaseFrameId > 20) {
              this.args.phase = 'stalking';
            }
          } else {
            if (this.args.phaseFrameId > 6) {
              this.args.phase = 'dead';
            }
          }
          break;
        case 'dead':
          this.args.float = 0;
          break;
        case 'exploding':
          if (this.args.phaseFrameId === 90) {
            this.args.falling = true;
            this.args.ySpeed = -14;
            this.args.xSpeed = 0;
            this.args.gSpeed = 0;
            this.noClip = true;
            this.viewport.auras.delete(this);
            this.args.phase = 'exploded';
            _Sfx.Sfx.play('OBJECT_DESTROYED');
            const viewport = this.viewport;
            const other = viewport.controlActor;
            viewport.onFrameOut(60, () => {
              const capsule = new _EggCapsule.EggCapsule({
                x: other.args.x,
                y: other.args.y - 384,
                xSpeed: other.args.gSpeed || other.args.xSpeed
              });
              viewport.spawn.add({
                object: capsule
              });
            });
          }
          if (this.args.phaseFrameId > 90) {
            return;
          }
          if (viewport && viewport.args.frameId % 3 === 0) {
            const explosion = new _Tag.Tag('<div class = "particle-explosion">');
            _Sfx.Sfx.play('BOSS_DAMAGED');
            const xOff = this.args.width * Math.random() - this.args.width / 2;
            const yOff = this.args.height * Math.random() - this.args.height / 2;
            explosion.style({
              '--x': this.x + xOff,
              '--y': this.y + yOff + -16
            });
            viewport.particles.add(explosion);
            setTimeout(() => viewport.particles.remove(explosion), 512);
          }
          break;
      }
      if (this.args.phase !== 'knocked') {
        if (this.args.ySpeed < 0 && !this.pointIsSafe(this.x, this.y + -this.args.height + this.args.ySpeed + -1)) {
          this.args.ySpeed = 0;
        }
      }
      _get(_getPrototypeOf(MiniBoss.prototype), "update", this).call(this);
    }
  }, {
    key: "updateEnd",
    value: function updateEnd() {
      _get(_getPrototypeOf(MiniBoss.prototype), "updateEnd", this).call(this);
      if (!this.viewport) {
        return;
      }
      const mainChar = this.viewport.controlActor;
      if (!mainChar) {
        return;
      }
      const xDiff = Math.abs(this.x - mainChar.x);
      const yDiff = Math.abs(this.y - mainChar.y);
      const xSign = Math.sign(this.x - mainChar.x);
      const ySign = Math.sign(this.y - mainChar.y);
      if (this.args.xSpeed < 0) {
        this.args.facing = 'left';
      } else if (this.args.xSpeed > 0) {
        this.args.facing = 'right';
      }
      this.args.groundAngle = 0;
      switch (this.args.phase) {
        case 'attacking':
        case 'swooping':
        case 'stalking':
        case 'ready':
          {
            if (this.bMap('checkBelow', this.x, this.y + 1).get(_Platformer.Platformer)) {
              this.args.falling = true;
              this.args.ySpeed = -4;
              this.args.y--;
            }
          }
          break;
      }
    }
  }, {
    key: "collideA",
    value: function collideA(other, type) {
      if (!other.controllable) {
        return;
      }
      const xSign = Math.sign(this.x - other.x);
      const ySign = Math.sign(this.y - other.y);
      const impactSpeed = Math.max(Math.abs(other.args.xSpeed), 5);
      const impactSign = Math.sign(other.args.xSpeed);
      if (this.args.phase === 'dead') {
        if (other.args.rolling) {
          other.args.gSpeed = -xSign * Math.abs(other.args.gSpeed);
        }
        if (!(other.args.jumping || other.args.rolling || other.dashed)) {
          return true;
        }
        this.args.explodeFrame = this.viewport.args.frameId;
        this.args.phase = 'exploding';
      }
      if (type === 1 || type === 3)
        // Side collisions
        {
          this.onNextFrame(() => {
            other.args.xSpeed = -xSign * Math.max(5, Math.abs(other.xSpeedLast));
          });
          if (other.args.falling) {
            this.ignores.set(other, 15);
          } else {
            other.args.gSpeed = 4 * -Math.sign(this.x - other.x);
            if (other.args.rolling) {
              this.onNextFrame(() => {
                other.args.gSpeed = -Math.sign(this.x - other.x);
                other.args.rolling = true;
                other.args.direction = Math.sign(other.args.gSpeed);
              });
            }
          }
          this.args.ySpeed = Math.min(0, this.args.ySpeed);
          this.damage(other);
        }
      if (type === 2)
        // Collide from bottom
        {
          if (this.viewport.args.audio) {
            _Sfx.Sfx.play('BOSS_DUDHIT');
          }
          if (other.args.falling) {
            if (this.hitPoints <= 0) {
              this.args.ySpeed = -Math.abs(other.args.ySpeed) * 2.5;
            }
            if (other.controllable) {
              other.args.ySpeed = Math.max(7, Math.abs(other.args.ySpeed));
            }
          }
          this.args.xSpeed = 0;
          if (this.args.hitPoints > 0) {
            this.args.phase = 'knocked';
          }
          this.ignores.set(other, 15);
        }
      if (type === 0)
        // Collide from top
        {
          if (other.args.falling) {
            this.ignores.set(other, 15);
          }
          if (other.controllable) {
            other.args.y = this.y - this.args.height;
            const animation = other.args.animation;
            const ySpeed = other.args.ySpeed;
            this.onNextFrame(() => {
              other.args.ySpeed = -Math.floor(Math.abs(ySpeed)) || -4;
            });
          }
          this.args.xSpeed = 0;
          this.damage(other);
        }
      other.args.ignore = 6;
      if (!this.args.hitPoints) {
        other.args.ignore = -2;
      }
      return true;
    }
  }, {
    key: "damage",
    value: function damage(other) {
      let type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'normal';
      if (this.args.hitPoints <= 0) {
        this.viewport.controlActor.screenLock = null;
        return;
      }
      const lastHit = this.args.damagers.get(other);
      if (this.args.frameId - lastHit < 45) {
        return;
      }
      this.args.hitPoints--;
      this.args.xSpeed = 0;
      if (this.args.hitPoints <= 0) {
        this.viewport.controlActor.screenLock = null;
      }
      this.args.damagers.set(other, this.args.frameId);
      this.onNextFrame(() => this.args.phase = 'damaged');
      _Sfx.Sfx.play('BOSS_DAMAGED');
    }
  }, {
    key: "pointIsSafe",
    value: function pointIsSafe(x, y) {
      const hazards = this.viewport.actorsAtPoint(x, y).filter(a => a.hazard);
      if (hazards.length) {
        return false;
      }
      return true;
    }
  }, {
    key: "wakeUp",
    value: function wakeUp() {
      this.viewport.controlActor.screenLock = {
        xMin: this.args.x - 768,
        xMax: this.args.x + 768
      };
      if (this.args.phase === 'idle') {
        this.args.phase = 'stalking';
      }
    }
  }, {
    key: "solid",
    get: function get() {
      return this.args.hitPoints > 0;
    }
  }, {
    key: "rotateLock",
    get: function get() {
      return true;
    }
  }]);
  return MiniBoss;
}(_Mixin.Mixin.from(_PointActor.PointActor));
exports.MiniBoss = MiniBoss;
});

;require.register("actor/MiniMace.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MiniMace = void 0;
var _PointActor = require("./PointActor");
var _Mixin = require("curvature/base/Mixin");
var _Constrainable = require("../mixin/Constrainable");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let MiniMace = /*#__PURE__*/function (_Mixin$from) {
  _inherits(MiniMace, _Mixin$from);
  var _super = _createSuper(MiniMace);
  function MiniMace() {
    var _this;
    _classCallCheck(this, MiniMace);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.width = 32;
    _this.args.height = 32;
    _this.args.type = 'actor-item actor-mini-mace';
    _this.args.ropeLength = _this.args._tiedTo ? _this.args.ropeLength : 8;
    _this.args.gravity = 0.6;
    return _this;
  }
  _createClass(MiniMace, [{
    key: "update",
    value: function update() {
      if (!this.args.tiedTo) {
        _get(_getPrototypeOf(MiniMace.prototype), "update", this).call(this);
      }
    }
  }, {
    key: "updateEnd",
    value: function updateEnd() {
      if (this.viewport && !this.viewport.auras.has(this)) {
        this.viewport.auras.add(this);
      }
      if (this.args.tiedTo) {
        _get(_getPrototypeOf(MiniMace.prototype), "update", this).call(this);
        if (!this.args._tiedTo) {
          this.args._tiedTo = this.viewport.actorsById[this.args.tiedTo];
        }
        if (this.args.tiedTo && this.args._tiedTo.args.hitPoints) {
          this.setPos();
        } else {
          this.noClip = true;
        }
      }
      _get(_getPrototypeOf(MiniMace.prototype), "updateEnd", this).call(this);
    }
  }, {
    key: "collideA",
    value: function collideA(other) {
      if (this.args._tiedTo && !this.args._tiedTo === other) {
        return false;
      }
    }
  }, {
    key: "collideB",
    value: function collideB(other) {
      if (this.args._tiedTo && !this.args._tiedTo === other) {
        return false;
      }
      if (this.args._tiedTo && !this.args._tiedTo.args.hitPoints) {
        return;
      }
      if (other.controllable) {
        other.damage();
      }
    }
  }]);
  return MiniMace;
}(_Mixin.Mixin.from(_PointActor.PointActor, _Constrainable.Constrainable));
exports.MiniMace = MiniMace;
});

;require.register("actor/Monitor.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Monitor = void 0;
var _PointActor2 = require("./PointActor");
var _Tag = require("curvature/base/Tag");
var _Explosion = require("../actor/Explosion");
var _Projectile = require("../actor/Projectile");
var _BrokenMonitor = require("../actor/BrokenMonitor");
var _Block = require("../actor/Block");
var _Marker = require("../actor/Marker");
var _Sfx = require("../audio/Sfx");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let Monitor = /*#__PURE__*/function (_PointActor) {
  _inherits(Monitor, _PointActor);
  var _super = _createSuper(Monitor);
  function Monitor() {
    var _this;
    _classCallCheck(this, Monitor);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.type = 'actor-item actor-monitor';
    _this.args.width = 30;
    _this.args.height = 32;
    _this.args.decel = 0.25;
    _this.args.canHide = true;
    _this.args.platform = true;
    _this.args.gone = false;
    return _this;
  }
  _createClass(Monitor, [{
    key: "onRendered",
    value: function onRendered(event) {
      _get(_getPrototypeOf(Monitor.prototype), "onRendered", this).call(this, event);
      if (!this.screen && this.sprite) {
        this.screen = new _Tag.Tag(`<div class = "monitor-screen">`);
        this.sprite.appendChild(this.screen.node);
      }
    }
  }, {
    key: "update",
    value: function update() {
      _get(_getPrototypeOf(Monitor.prototype), "update", this).call(this);
      if (!this.viewport) {
        return;
      }
    }
  }, {
    key: "collideA",
    value: function collideA(other, type) {
      if (other.knocked) {
        this.pop(other.knocked);
      }
      if (other.args.static) {
        return true;
      }
      if (other.punching) {
        this.pop(other);
        return false;
      }
      if (!other.args.moving && !other.args.falling) {
        return false;
      }
      if (other instanceof _Block.Block) {
        return false;
      }
      if (other instanceof _Marker.Marker) {
        other = other.owner;
      }
      _get(_getPrototypeOf(Monitor.prototype), "collideA", this).call(this, other, type);
      if (other.passPop && other.occupant && !other.args.dead) {
        other = other.occupant;
        this.pop(other);
        return;
      }

      // if(type === 1 && !other.args.spinning)
      // {
      // 	return true;
      // }

      if (type === 2 && this.args.float && other.controllable) {
        other.args.ySpeed *= -1;
        this.args.ySpeed = -4;
        this.args.float = 0;
        this.ignores.set(other, 15);
        return true;
      }
      if (type !== 2 && (other.args.ySpeed > 0 && other.y < this.y || (other.args.rolling || other.args.bellySliding) && !other.args.grinding) && (!this.args.falling || this.args.float === -1) && !this.args.gone && this.viewport && other.args.spinning) {
        this.pop(other);
        return;
      }
      if ((type === 1 || type === 3
      // && (Math.abs(other.args.xSpeed) > 15 || other instanceof Projectile)
      ) && ((other.args.rolling || other.args.bellySliding) && !other.args.grinding || other instanceof _Projectile.Projectile) && !this.args.gone && this.viewport) {
        this.pop(other);
        return false;
      }
    }
  }, {
    key: "pop",
    value: function pop(other) {
      const viewport = this.viewport;
      if (!viewport || this.args.gone) {
        return;
      }
      const explosion = new _Tag.Tag('<div class = "particle-explosion">');
      if (other) {
        const reward = {
          label: this.name || this.args.name,
          points: 10,
          multiplier: 1
        };
        if (!other.isVehicle && other.args.ySpeed > 5 && other.args.ySpeed < 25 && Math.abs(other.args.ySpeed) > Math.abs(other.args.xSpeed)) {
          other.args.cameraMode = 'popping';
        }
        other.args.popChain.push(reward);
        other.args.popCombo += 1;
        if (other.args.ySpeed > 25 && !other.args.bouncing) {
          const reward = {
            label: 'BIG AIR!!!',
            points: 1000,
            multiplier: 1.5
          };
          other.args.popChain.push(reward);
          other.args.popCombo += 1;
          if (!other.airReward && Math.abs(other.args.xSpeed) > 10) {
            other.args.x = this.args.x - (this.args.gSpeed || this.args.xSpeed);
            other.args.y = this.args.y + -8;
            this.viewport.onFrameOut(1, () => this.viewport.args.frozen = 25);
            this.viewport.args.invert = 'invert';
            this.viewport.onFrameOut(25, () => this.viewport.args.invert = '');
            _Sfx.Sfx.play('SICK_TRICK');
            _Sfx.Sfx.play('SICK_TRICK');
          }
          other.airReward = reward;
        }
        _Sfx.Sfx.play('OBJECT_DESTROYED');
      }
      explosion.style({
        '--x': this.x,
        '--y': this.y - 16
      });
      const scoreNode = document.createElement('div');
      scoreNode.classList.add('particle-score');
      scoreNode.classList.add('score-10');
      const scoreTag = new _Tag.Tag(scoreNode);
      scoreTag.style({
        '--x': this.args.x,
        '--y': this.args.y - 16
      });
      viewport.particles.add(scoreTag);
      viewport.particles.add(explosion);
      setTimeout(() => viewport.particles.remove(explosion), 512);
      setTimeout(() => viewport.particles.remove(scoreTag), 768);
      setTimeout(() => this.screen && this.screen.remove(), 1024);
      this.args.gone = true;
      this.box && this.box.setAttribute('data-animation', 'broken');
      if (other) {
        if (other.occupant) {
          other = other.occupant;
        }
        if (other.args.owner) {
          other = other.args.owner;
        }
        if (other.controllable) {
          this.effect(other);
        }
      }
      if (typeof ga === 'function') {
        ga('send', 'event', {
          eventCategory: 'monitor',
          eventAction: 'popped',
          eventLabel: `${this.viewport.args.actName}::${this.args.id}`
        });
      }
      if (other) {
        const ySpeed = Math.min(other.args.ySpeed, other.ySpeedLast);
        if (other.args.doubleSpin) {
          other.args.doubleSpin = 2;
        }
        other.dashed = false;
        if (other && other.dashed && Math.abs(other.args.xSpeed) > Math.abs(other.args.ySpeed)) {
          other.args.gSpeed = 0;
          other.args.xSpeed = -1.5 * Math.sign(other.args.xSpeed);
          other.args.ySpeed = -10;
        } else if (other && other.args.falling) {
          const spinning = other.args.spinning;
          const jumping = other.args.jumping;
          const flying = other.args.flying;
          const xSpeed = other.args.xSpeed || other.args.gSpeed;
          other.args.xSpeed = 0;
          other.args.ySpeed = 0;
          viewport.onFrameOut(1, () => {
            if (ySpeed >= 0) {
              if (other.flyTime < 5) {
                other.args.ySpeed = Math.min(-ySpeed, -7);
              } else {
                other.args.ySpeed = Math.min(-ySpeed, -2);
              }
            } else {
              other.args.ySpeed += 8;
            }
            other.args.spinning = other.args.spinning || spinning;
            other.args.jumping = other.args.jumping || jumping;
            other.args.flying = other.args.flying || flying;
            other.args.xSpeed = xSpeed;
            other.args.falling = true;
          });
        }
      }
      if (other && this.viewport.settings.rumble && other.controller && other.controller.rumble) {
        other.controller.rumble({
          duration: 40,
          strongMagnitude: 0.0,
          weakMagnitude: 1.0
        });
        this.viewport.onTimeout(40, () => {
          other.controller.rumble({
            duration: 110,
            strongMagnitude: 0.75,
            weakMagnitude: 1.0
          });
        });
      }
    }
  }, {
    key: "effect",
    value: function effect() {}
  }, {
    key: "canStick",
    get: function get() {
      return false;
    }
  }, {
    key: "solid",
    get: function get() {
      return false;
    }
  }]);
  return Monitor;
}(_PointActor2.PointActor);
exports.Monitor = Monitor;
});

;require.register("actor/Motobug.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Motobug = void 0;
var _Mixin = require("curvature/base/Mixin");
var _PointActor = require("./PointActor");
var _Patrol = require("../behavior/Patrol");
var _CanPop = require("../mixin/CanPop");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let Motobug = /*#__PURE__*/function (_Mixin$from) {
  _inherits(Motobug, _Mixin$from);
  var _super = _createSuper(Motobug);
  function Motobug() {
    var _this$args$patrolPaus, _this$args$patrolBeat, _this$args$patrolSpee;
    var _this;
    _classCallCheck(this, Motobug);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.behaviors.add(new _Patrol.Patrol());
    _this.args.type = 'actor-item actor-motobug';
    _this.args.animation = 'standing';
    _this.args.accel = 0.1;
    _this.args.decel = 0.5;
    _this.args.gSpeedMax = 3;
    _this.args.gravity = 0.5;
    _this.args.width = 24;
    _this.args.height = 32;
    _this.willStick = false;
    _this.stayStuck = false;
    _this.args.patrolPause = (_this$args$patrolPaus = _this.args.patrolPause) !== null && _this$args$patrolPaus !== void 0 ? _this$args$patrolPaus : 10;
    _this.args.patrolBeat = (_this$args$patrolBeat = _this.args.patrolBeat) !== null && _this$args$patrolBeat !== void 0 ? _this$args$patrolBeat : 120;
    _this.args.patrolSpeed = (_this$args$patrolSpee = _this.args.patrolSpeed) !== null && _this$args$patrolSpee !== void 0 ? _this$args$patrolSpee : 1;
    return _this;
  }
  _createClass(Motobug, [{
    key: "update",
    value: function update() {
      _get(_getPrototypeOf(Motobug.prototype), "update", this).call(this);
      if (this.args.moving && this.args.gSpeed) {
        this.args.animation = 'walking';
      } else {
        this.args.animation = 'standing';
      }
      this.args.direction = Math.sign(this.args.gSpeed);
    }
  }, {
    key: "solid",
    get: function get() {
      return false;
    }
  }, {
    key: "isEffect",
    get: function get() {
      return false;
    }
  }]);
  return Motobug;
}(_Mixin.Mixin.from(_PointActor.PointActor, _CanPop.CanPop));
exports.Motobug = Motobug;
});

;require.register("actor/MouseIndicator.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MouseIndicator = void 0;
var _Cursor2 = require("./Cursor");
var _CharacterString = require("../ui/CharacterString");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let MouseIndicator = /*#__PURE__*/function (_Cursor) {
  _inherits(MouseIndicator, _Cursor);
  var _super = _createSuper(MouseIndicator);
  function MouseIndicator() {
    var _this;
    _classCallCheck(this, MouseIndicator);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _defineProperty(_assertThisInitialized(_this), "endPoint", null);
    _defineProperty(_assertThisInitialized(_this), "lastMouseX", null);
    _defineProperty(_assertThisInitialized(_this), "lastMouseY", null);
    return _this;
  }
  _createClass(MouseIndicator, [{
    key: "onRendered",
    value: function onRendered(event) {
      _get(_getPrototypeOf(MouseIndicator.prototype), "onRendered", this).call(this, event);
      this.args.type = 'point-actor actor-generic actor-mouse-indicator';
      this.autoStyle.get(this.box)['--magnitude'] = 'magnitude';
      this.magnitudeLabel = new _CharacterString.CharacterString({
        value: 0
      });
      this.angleLabel = new _CharacterString.CharacterString({
        value: 0
      });
      this.colorLabel = new _CharacterString.CharacterString({
        value: 0
      });
      Object.assign(this.args.charStrings, [this.magnitudeLabel, this.angleLabel, this.colorLabel]);
    }
  }, {
    key: "update",
    value: function update() {
      if (this.viewport && !this.viewport.args.plot) {
        this.viewport.args.plot = new Plot();
      }
      const mouse = this.viewport.mouse;
      if (!mouse.buttons[0] && !this.endPoint) {
        this.args.x = mouse.position[0];
        this.args.y = mouse.position[1];
      } else if (mouse.buttons[0] === 1 && this.endPoint) {
        // this.viewport.actors.remove(this.endPoint);
        this.endPoint = null;
      } else if (mouse.buttons[0] === 1 && !this.endPoint) {
        this.endPoint = new _Cursor2.Cursor({
          x: this.args.x,
          y: this.args.y
        });
        // this.viewport.spawn.add({object:this.endPoint});
      } else {
        const length = Math.hypot(this.args.y - mouse.position[1], this.args.x - mouse.position[0]);
        const angle = Math.atan2(mouse.position[1] - this.args.y, mouse.position[0] - this.args.x);
        this.args.airAngle = angle;

        // this.args.falling = false;

        if (this.lastMouseX !== mouse.position[0] || this.lastMouseY !== mouse.position[1]) {
          // this.viewport.args.plot.clearPoints();
          window.logPoints = (x, y, label) => this.viewport.args.plot.addPoint(x, y, 'main-scan ' + label);
          const magnitude = this.castRayQuick(length, angle);
          // window.logPoints = false;

          this.args.falling = true;
          this.endPoint.args.x = this.args.x + Math.cos(angle) * magnitude;
          this.endPoint.args.y = this.args.y + Math.sin(angle) * magnitude;
          const color = this.viewport.tileMap.getColor(Math.trunc(this.endPoint.args.x), Math.trunc(this.endPoint.args.y), 0);
          this.magnitudeLabel.args.value = magnitude === false ? false : Number(magnitude).toFixed(2);
          this.angleLabel.args.value = Number(angle).toFixed(2);
          this.colorLabel.args.value = Number(color).toString(16).padStart(8, '0');
        }
        this.lastMouseX = mouse.position[0];
        this.lastMouseY = mouse.position[1];
      }
    }
  }]);
  return MouseIndicator;
}(_Cursor2.Cursor);
exports.MouseIndicator = MouseIndicator;
});

;require.register("actor/Mushroom.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Mushroom = void 0;
var _PointActor2 = require("./PointActor");
var _Liftable = require("../behavior/Liftable");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let Mushroom = /*#__PURE__*/function (_PointActor) {
  _inherits(Mushroom, _PointActor);
  var _super = _createSuper(Mushroom);
  function Mushroom() {
    var _this;
    _classCallCheck(this, Mushroom);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.type = 'actor-item actor-mushroom';
    _this.args.width = 24;
    _this.args.height = 24;
    _this.args.size = 4;
    _this.args.nourishment = 0.1;
    _this.behaviors.add(new _Liftable.Liftable());
    return _this;
  }
  _createClass(Mushroom, [{
    key: "onRendered",
    value: function onRendered(event) {
      _get(_getPrototypeOf(Mushroom.prototype), "onRendered", this).call(this, event);
      const viewport = this.viewport;
      this.onRemove(() => viewport.spawnFromDef(this.objDef));
      this.autoStyle.get(this.box)['--size'] = 'size';
    }
  }, {
    key: "lift",
    value: function lift(actor) {
      if (this.carriedBy === actor) {
        this.carriedBy = null;
        return;
      }
      this.carriedBy = actor;
    }
  }, {
    key: "solid",
    get: function get() {
      return false;
    }
  }, {
    key: "rotateLock",
    get: function get() {
      return true;
    }
  }, {
    key: "sleep",
    value: function sleep() {
      if (!this.viewport) {
        return;
      }
      this.viewport.actors.remove(this);
    }
  }]);
  return Mushroom;
}(_PointActor2.PointActor);
exports.Mushroom = Mushroom;
});

;require.register("actor/NeverBetter.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NeverBetter = void 0;
var _PointActor2 = require("./PointActor");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let NeverBetter = /*#__PURE__*/function (_PointActor) {
  _inherits(NeverBetter, _PointActor);
  var _super = _createSuper(NeverBetter);
  function NeverBetter(args, parent) {
    var _this;
    _classCallCheck(this, NeverBetter);
    _this = _super.call(this, args, parent);
    _this.args.type = 'actor-item actor-never-better-sign';
    _this.args.width = 84;
    _this.args.height = 78;
    return _this;
  }
  _createClass(NeverBetter, [{
    key: "solid",
    get: function get() {
      return false;
    }
  }]);
  return NeverBetter;
}(_PointActor2.PointActor);
exports.NeverBetter = NeverBetter;
});

;require.register("actor/NitroBooster.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NitroBooster = void 0;
var _PointActor2 = require("./PointActor");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
// import { Sfx } from '../audio/Sfx';
// import { Bgm } from '../audio/Bgm';
// import { Tag } from 'curvature/base/Tag';
// import { Block } from './Block';
let NitroBooster = /*#__PURE__*/function (_PointActor) {
  _inherits(NitroBooster, _PointActor);
  var _super = _createSuper(NitroBooster);
  function NitroBooster() {
    var _this;
    _classCallCheck(this, NitroBooster);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.width = 64;
    _this.args.height = 8;
    _this.args.float = -1;
    _this.args.type = 'actor-item actor-nitro-booster';
    return _this;
  }
  _createClass(NitroBooster, [{
    key: "onRendered",
    value: function onRendered() {
      _get(_getPrototypeOf(NitroBooster.prototype), "onRendered", this).call(this);
    }
  }, {
    key: "update",
    value: function update() {
      _get(_getPrototypeOf(NitroBooster.prototype), "update", this).call(this);
      if (Math.trunc(this.viewport.args.frameId / 6) % 6 < 2 && this.viewport.args.frameId % 3) {
        this.castRayQuick(60, -Math.PI / 2, [0, -16]);
        this.args.animation = 'boosting';
      } else {
        this.args.animation = 'idle';
      }
    }
  }, {
    key: "collideA",
    value: function collideA(other, type) {
      if (!other.controllable) {
        return;
      }
      if (this.args.animation === 'boosting') {
        other.args.y -= 16;
        other.args.ySpeed = -16;
        other.args.falling = true;
      }

      // if(type === 0 && other.args.ySpeed >= 0)
      // {
      // 	other.args.ySpeed = (other.args.flying && other.flyTime > 2) ? -2 : -8;
      // 	super.collideA(other, type);
      // 	this.args.pressed = 6;
      // 	return;
      // }

      return _get(_getPrototypeOf(NitroBooster.prototype), "collideA", this).call(this, other, type);
    }
  }, {
    key: "solid",
    get: function get() {
      return true;
    }
  }]);
  return NitroBooster;
}(_PointActor2.PointActor);
exports.NitroBooster = NitroBooster;
});

;require.register("actor/NotchSpring.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NotchSpring = void 0;
var _PointActor2 = require("./PointActor");
var _Block = require("./Block");
var _Sfx = require("../audio/Sfx");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let NotchSpring = /*#__PURE__*/function (_PointActor) {
  _inherits(NotchSpring, _PointActor);
  var _super = _createSuper(NotchSpring);
  function NotchSpring() {
    var _this;
    _classCallCheck(this, NotchSpring);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.width = 8;
    _this.args.height = 32;
    _this.args.type = 'actor-item actor-notch-spring';
    _this.noClip = true;
    _this.args.float = -1;
    _this.args.animation = 'idle';
    _this.launching = new Set();
    return _this;
  }
  _createClass(NotchSpring, [{
    key: "collideA",
    value: function collideA(other) {
      if (!other.controllable || !other.args.falling) {
        return;
      }
      this.launching.add(other);
      this.args.animation = 'springing';
      _Sfx.Sfx.play('NOTCH_SPRING_HIT');
      this.viewport.onFrameOut(1, () => this.args.animation = 'idle');
    }
  }, {
    key: "updateEnd",
    value: function updateEnd() {
      _get(_getPrototypeOf(NotchSpring.prototype), "updateEnd", this).call(this);
      this.launching.forEach(other => {
        other.args.animation = 'flip';
        other.args.jumping = false;
        other.dashed = false;
        other.args.x += this.args.direction;
        other.args.flying = false;
        other.impulse(12, -Math.PI / 2 + Math.PI / 4 * this.args.direction, true);
        other.args.xSpeed = 0;
        other.args.ySpeed = 0;
        other.args.ignore = 8;
        this.launching.delete(other);
      });
    }
  }, {
    key: "solid",
    get: function get() {
      return false;
    }
  }]);
  return NotchSpring;
}(_PointActor2.PointActor);
exports.NotchSpring = NotchSpring;
});

;require.register("actor/NuclearSuperball.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NuclearSuperball = void 0;
var _PointActor2 = require("./PointActor");
var _Tag = require("curvature/base/Tag");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let NuclearSuperball = /*#__PURE__*/function (_PointActor) {
  _inherits(NuclearSuperball, _PointActor);
  var _super = _createSuper(NuclearSuperball);
  function NuclearSuperball() {
    var _this;
    _classCallCheck(this, NuclearSuperball);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.gSpeedMax = 150;
    _this.args.accel = 2;
    _this.args.jumpForce = 20;
    _this.willStick = true;
    _this.stayStuck = true;
    return _this;
  }
  _createClass(NuclearSuperball, [{
    key: "solid",
    get: function get() {
      return false;
    }
  }, {
    key: "isEffect",
    get: function get() {
      return false;
    }
  }, {
    key: "controllable",
    get: function get() {
      return true;
    }
  }]);
  return NuclearSuperball;
}(_PointActor2.PointActor);
exports.NuclearSuperball = NuclearSuperball;
});

;require.register("actor/Orb.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Orb = void 0;
var _PointActor = require("./PointActor");
var _Mixin = require("curvature/base/Mixin");
var _Pushable = require("../mixin/Pushable");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let Orb = /*#__PURE__*/function (_Mixin$from) {
  _inherits(Orb, _Mixin$from);
  var _super = _createSuper(Orb);
  function Orb() {
    var _this;
    _classCallCheck(this, Orb);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.type = 'actor-item actor-orb';
    _this.args.width = 18;
    _this.args.height = 48;
    _this.args.rolled = 0;
    _this.args.accel = 0.0;
    _this.args.decel = 0;
    _this.args.bindTo('x', (v, k, t, d, p) => _this.args.rolled += 0.5 * Number(v - p || 0));
    _this.args.gravity = 1.35;
    _this.args.maxFollow = _this.args.maxFollow || null;
    return _this;
  }
  _createClass(Orb, [{
    key: "onRendered",
    value: function onRendered(event) {
      _get(_getPrototypeOf(Orb.prototype), "onRendered", this).call(this, event);
      this.autoStyle.get(this.box)['--rolled'] = 'rolled';
    }
  }, {
    key: "updateStart",
    value: function updateStart() {
      _get(_getPrototypeOf(Orb.prototype), "updateStart", this).call(this);
      const other = this.viewport.controlActor;
      this.otherSpacing = this.distanceFrom(other);
      this.otherSpeed = other.args.gSpeed || other.args.xSpeed || other.gSpeedLast || other.xSpeedLast;
    }
  }, {
    key: "update",
    value: function update() {}
  }, {
    key: "updateEnd",
    value: function updateEnd() {
      if (!this.viewport || !this.viewport.controlActor) {
        return;
      }
      const other = this.viewport.controlActor;
      if (this.args.falling && other.args.fallTime < 15 && this.args.ySpeed < 0) {
        this.args.xSpeed = 0.995;
      }
      const viewport = this.viewport;
      if (this.args.falling) {
        this.viewport.onFrameOut(10, () => {
          if (this.args.falling) {
            viewport.auras.delete(this);
          }
        });
      } else {
        this.viewport.auras.add(this);
      }
      const speedMag = Math.max(0, this.otherSpeed);
      const speedSign = Math.sign(this.args.gSpeed || this.gSpeedLast || other.args.gSpeed || other.args.xSpeed);
      const moving = this.args.gSpeed || this.args.xSpeed;
      if ((moving || this.args.x < other.args.x - 160) && (!this.args.maxFollow || this.x < this.args.maxFollow)) {
        const maxSpace = 64;
        const spacing = this.otherSpacing;
        let gSpeed = speedMag * speedSign;
        if (spacing < maxSpace || other.args.falling && other.args.ySpeed >= 0) {
          gSpeed *= 0.975;
        }
        if (gSpeed && this.args.groundAngle > 0) {
          gSpeed += 1.5 * Math.sign(gSpeed);
        }
        this.args.gSpeed = gSpeed;
      }
      _get(_getPrototypeOf(Orb.prototype), "update", this).call(this);
      _get(_getPrototypeOf(Orb.prototype), "updateEnd", this).call(this);
    }
  }, {
    key: "collideA",
    value: function collideA(other) {
      if (!other.isHyper && !other.isSuper) {
        other.controllable && other.loseRings();
      }
      other.controllable && other.die();
    }
  }, {
    key: "controllable",
    get: function get() {
      return false;
    }
  }, {
    key: "solid",
    get: function get() {
      return false;
    }
  }]);
  return Orb;
}(_Mixin.Mixin.from(_PointActor.PointActor));
exports.Orb = Orb;
});

;require.register("actor/OrbSmall.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.OrbSmall = void 0;
var _PointActor = require("./PointActor");
var _Mixin = require("curvature/base/Mixin");
var _Sfx = require("../audio/Sfx");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let OrbSmall = /*#__PURE__*/function (_Mixin$from) {
  _inherits(OrbSmall, _Mixin$from);
  var _super = _createSuper(OrbSmall);
  function OrbSmall() {
    var _this;
    _classCallCheck(this, OrbSmall);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.type = 'actor-item actor-orb-small';
    _this.args.width = 18;
    _this.args.height = 24;
    _this.args.rolled = 0;
    _this.gSpeedLast = 0;
    _this.args.accel = 0.2;
    _this.args.decel = _this.args.decel || 0.0;

    // this.args.bindTo('x', (v,k,t,d,p) => this.args.rolled += Math.PI * Number(v - p || 0));
    // this.args.bindTo('y', (v,k,t,d,p) => this.args.rolled += Math.abs(Number(v - p || 0)));

    _this.args.gravity = 0.4;
    _this.args.maxFollow = _this.args.maxFollow || null;
    _this.args.friction = _this.args.friction || 0.75;
    _this.args.bounce = _this.args.bounce || 0.5;
    _this.args.rollSpeed = 0;
    _this.args.rolled = 0;
    return _this;
  }
  _createClass(OrbSmall, [{
    key: "onRendered",
    value: function onRendered(event) {
      _get(_getPrototypeOf(OrbSmall.prototype), "onRendered", this).call(this, event);
      this.autoStyle.get(this.box)['--rolled'] = 'rolled';
    }
  }, {
    key: "update",
    value: function update() {
      if (!this.viewport || !this.viewport.controlActor) {
        return;
      }
      if (this.args.x < -16 + this.viewport.controlActor.args.x) {
        if (!this.args.falling) {
          this.args.xSpeed = this.args.gSpeed;
        }
        this.args.falling = true;
        this.noClip = true;
      }
      const ySpeed = this.ySpeedLast - this.args.gravity;
      _get(_getPrototypeOf(OrbSmall.prototype), "update", this).call(this);
      if (!this.args.falling) {
        this.args.rollSpeed = this.args.gSpeed * Math.PI;
      } else if (this.args.ySpeed > 0) {
        this.args.rollSpeed *= 0.975;
      }
      this.args.rolled += this.args.rollSpeed;
      if (!this.args.falling && ySpeed > 3) {
        const volume = Math.max(0.5, Math.min(ySpeed, 16) / 16);
        _Sfx.Sfx.play('HEAVY_THUD', {
          volume: volume
        });
        if (this.args.bounce) {
          this.args.xSpeed *= this.args.friction;
          this.args.x += this.args.xSpeed;
        }
        this.args.ySpeed = -ySpeed * this.args.bounce;
        this.args.falling = true;
        this.args.y -= 1;
      }
    }
  }, {
    key: "collideA",
    value: function collideA(other) {
      // if(other instanceof this.constructor)
      // {
      // 	this.args.gSpeed = (this.args.gSpeed + other.args.gSpeed) * 0.5
      // 	this.args.xSpeed = (this.args.xSpeed + other.args.xSpeed) * 0.5
      // 	this.args.ySpeed = (this.args.ySpeed + other.args.ySpeed) * 0.5

      // 	this.args.gSpeed += Math.sign(this.args.x - other.args.x);
      // 	this.args.xSpeed += Math.sign(this.args.x - other.args.x);
      // 	this.args.ySpeed += Math.sign(this.args.y - other.args.y);

      // 	Sfx.play('HEAVY_THUD');

      // 	return;
      // }

      if (other.controllable) {
        const volume = Math.max(0.5, Math.min(this.args.ySpeed, 16) / 16);
        if (!other.args.startled) {
          this.args.gSpeed = 0;
          this.noClip = true;
          this.args.falling = true;
          this.args.xSpeed = 0;
          this.args.ySpeed = -3;
          this.args.float = 10;
          this.args.rollSpeed *= 2;
          _Sfx.Sfx.play('HEAVY_THUD', {
            volume: volume
          });
        }
        if (other.args.rings) {
          other.damage();
        } else {
          other.startle();
        }
      }
      if (this.args.x < this.viewport.controlActor.args.x - 8) {
        this.noClip = true;
        return;
      }
      if (this.noClip && other.break && !other.broken) {
        this.args.ySpeed *= -1;
        _Sfx.Sfx.play('HEAVY_THUD');
        other.break(this);
      }
    }
  }, {
    key: "sleep",
    value: function sleep() {
      this.viewport.actors.remove(this);
    }
  }, {
    key: "controllable",
    get: function get() {
      return false;
    }
  }, {
    key: "solid",
    get: function get() {
      return false;
    }
  }]);
  return OrbSmall;
}(_Mixin.Mixin.from(_PointActor.PointActor));
exports.OrbSmall = OrbSmall;
});

;require.register("actor/Panel.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Panel = void 0;
var _PointActor2 = require("./PointActor");
var _Bindable = require("curvature/base/Bindable");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let Panel = /*#__PURE__*/function (_PointActor) {
  _inherits(Panel, _PointActor);
  var _super = _createSuper(Panel);
  function Panel(args, parent) {
    var _this;
    _classCallCheck(this, Panel);
    _this = _super.call(this, args, parent);
    _this.args.type = 'actor-item actor-panel';
    _this.args.width = 64;
    _this.args.height = 8;
    _this.args.static = 1;
    _this.args.float = -1;
    _this.leaving = new Set();
    _this.holding = new Set();
    _this.cancels = new Map();

    // this.args.bindTo('mode', (k,v) => console.trace(this.args.id,k,v));
    return _this;
  }
  _createClass(Panel, [{
    key: "collideA",
    value: function collideA(other, type) {
      if (other.canFly) {
        return false;
      }
      if (this.leaving.has(other)) {
        if (this.holding.has(other)) {
          other.stayStuck = false;
          other.willStick = false;
          other.willJump = false;
          other.args.gSpeed = 0;
          this.holding.delete(other);
        }
        if (this.cancels.has(other)) {
          this.cancels.get(other)();
          this.cancels.delete(other);
        }
        this.cancels.set(other, this.viewport.onFrameOut(25, () => {
          this.holding.delete(other);
          this.leaving.delete(other);
        }));
        return false;
      }
      if (!other.args.jumping && !this.holding.has(other)) {
        return false;
      }
      if (this.holding.has(other)) {
        other.args.mode = 0;
        other.args.groundAngle = this.args.groundAngle;
        other.lastAngles.length = 0;
        other.args.gSpeed = 0;
        other.args.xSpeed = 0;
        other.args.ySpeed = 0;
        other.args.falling = false;
        if ((this.args.next || this.args.mode) && this.holding.has(other) && other.willJump) {
          const nextPanel = this.viewport.actorsById[this.args.next];
          other.args.falling = true;
          if (nextPanel || this.args.mode) {
            other.stayStuck = true;
            other.willStick = true;
            // other.willJump = false;

            if (nextPanel) {
              const point = nextPanel.rotatePoint(0, 0);
              const angle = other.angleTo({
                x: point[0] + nextPanel.x,
                y: point[1] + nextPanel.y
              });
              other.args.x -= Math.cos(angle) * 16;
              other.args.y -= Math.sin(angle) * 16;
              other.args.xSpeed = -Math.cos(angle) * 34;
              other.args.ySpeed = -Math.sin(angle) * 34;
            }
            other.args.gSpeed = 0;
            other.args.falling = true;
            other.args.jumping = true;
            other.args.float = 45;
            this.leaving.add(other);
            this.holding.delete(other);
            other.args.ignore = 45;
          } else {
            this.leaving.add(other);
            this.holding.delete(other);
            other.stayStuck = false;
            other.willStick = false;
            // other.willJump  = false;
            other.args.gSpeed = 0;
            other.args.xSpeed = 0;
            other.args.ySpeed = 0;
            other.args.falling = true;
            other.args.ignore = 15;
          }
          return false;
        }
        const point = this.rotatePoint(0, 8);
        other.args.x = this.x + point[0];
        other.args.y = this.y + point[1];
        other.args.ignore = 0;
        return false;
      }
      const nextPanel = this.others.next;
      if (nextPanel || this.args.mode) {
        this.holding.add(other);
      } else {
        return true;
      }

      // other.args.gSpeed = 0;
      // other.args.xSpeed = 0;
      // other.args.ySpeed = 0;

      other.args.ignore = 10;
      if (this.cancels.has(other)) {
        this.cancels.get(other)();
        this.cancels.delete(other);
      }
      this.cancels.set(other, this.viewport.onFrameOut(20, () => {
        if (this.holding.has(other)) {
          this.holding.delete(other);
          this.leaving.add(other);
        }
      }));
      return false;
    }
  }, {
    key: "sleep",
    value: function sleep() {
      this.leaving.clear();
      this.holding.clear();
    }
  }, {
    key: "solid",
    get: function get() {
      return false;
    }
  }]);
  return Panel;
}(_PointActor2.PointActor);
exports.Panel = Panel;
});

;require.register("actor/PlatformFlare.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PlatformFlare = void 0;
var _PointActor2 = require("./PointActor");
var _Block = require("./Block");
var _Sfx = require("../audio/Sfx");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let PlatformFlare = /*#__PURE__*/function (_PointActor) {
  _inherits(PlatformFlare, _PointActor);
  var _super = _createSuper(PlatformFlare);
  function PlatformFlare() {
    var _this;
    _classCallCheck(this, PlatformFlare);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.width = 32;
    _this.args.height = 8;
    _this.args.power = _this.args.power || 18;
    _this.args.type = 'actor-item actor-platform-flare';
    _this.args.static = 1;
    return _this;
  }
  _createClass(PlatformFlare, [{
    key: "collideA",
    value: function collideA(other) {
      if (other.args.float || other.args.static) {
        return;
      }
      if (other.controllable && this.args.active) {
        other.damage(this, 'fire');
      }
      const frameId = this.viewport.args.frameId - this.viewport.args.startFrameId;
      if (frameId / 60 % 3) {
        return;
      }
      this.args.active = true;
      this.viewport.onFrameOut(30, () => this.args.active = false);
      if (other instanceof _Block.Block) {
        _Sfx.Sfx.play('LID_POP');
        other.args.ySpeed = -this.args.power;
        other.args.y += -1;
        other.args.falling = true;
      }
    }
  }]);
  return PlatformFlare;
}(_PointActor2.PointActor);
exports.PlatformFlare = PlatformFlare;
});

;require.register("actor/Platformer.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Platformer = void 0;
var _PointActor2 = require("./PointActor");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let Platformer = /*#__PURE__*/function (_PointActor) {
  _inherits(Platformer, _PointActor);
  var _super = _createSuper(Platformer);
  function Platformer() {
    _classCallCheck(this, Platformer);
    return _super.apply(this, arguments);
  }
  _createClass(Platformer, [{
    key: "controllable",
    get: function get() {
      return true;
    }
  }]);
  return Platformer;
}(_PointActor2.PointActor);
exports.Platformer = Platformer;
});

;require.register("actor/PogoEgg.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PogoEgg = void 0;
var _PointActor2 = require("./PointActor");
var _Sfx = require("../audio/Sfx");
var _Tag = require("curvature/base/Tag");
var _EggCapsule = require("./EggCapsule");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let PogoEgg = /*#__PURE__*/function (_PointActor) {
  _inherits(PogoEgg, _PointActor);
  var _super = _createSuper(PogoEgg);
  function PogoEgg() {
    var _this;
    _classCallCheck(this, PogoEgg);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.width = 65;
    _this.args.height = 63;
    _this.args.type = 'actor-item actor-pogo-egg';
    _this.args.gravity = 0.5;
    _this.args.jumpForce = 8.5;
    _this.args.decel = 0;
    _this.targetPoint = null;
    _this.xTarget = 19216;
    _this.yTarget = 1280;
    _this.args.expectedAirTime = 0;
    _this.args.hp = 8;
    _this.args.bounceCount = 0;
    return _this;
  }
  _createClass(PogoEgg, [{
    key: "onRendered",
    value: function onRendered() {
      _get(_getPrototypeOf(PogoEgg.prototype), "onRendered", this).call(this);
      this.autoStyle.get(this.box)['--stem-length'] = 'stemLength';
    }
  }, {
    key: "update",
    value: function update() {
      _get(_getPrototypeOf(PogoEgg.prototype), "update", this).call(this);
      this.screenLock = this.screenLock || {
        xMin: 20384,
        xMax: 21320
      };
      if (this.args.hp >= 0) {
        if (this.viewport.controlActor) {
          if (!this.viewport.controlActor.args.dead) {
            this.viewport.controlActor.screenLock = this.viewport.controlActor.screenLock || {
              xMin: 20384,
              xMax: 21320
            };
          }
        }
        this.args.animation = 'idle';
        if (this.args.damaged > 0) {
          this.args.damaged--;
          this.args.animation = 'damaged';
        }
      }
      if (this.args.hp > 0) {
        const stemLengthL = this.castRayQuick(32, Math.PI / 2, [-16, 0], false) || 32;
        const stemLengthR = this.castRayQuick(32, Math.PI / 2, [+16, 0], false) || 32;
        this.args.stemLength = Math.min(stemLengthL, stemLengthR);
      } else {
        this.args.stemLength = 0;
      }
      const cycle = 800;
      let target = this.otherDefs.pointA;
      let phase = this.age % cycle;
      if (phase > cycle * 0.75) {
        target = this.otherDefs.pointB;
      } else if (phase > cycle * 0.5) {
        target = this.otherDefs.pointC;
      } else if (phase > cycle * 0.25) {
        target = this.otherDefs.pointB;
      }
      if (this.targetPoint !== target) {
        this.args.bounceCount = 0;
      }
      this.xTarget = target.x;
      this.yTarget = target.y;
      this.targetPoint = target;
      if (this.args.bounceCount) {
        if (this.args.bounceCount % 2) {
          this.xTarget = this.targetPoint.x - 32;
        } else {
          this.xTarget = this.targetPoint.x + 32;
        }
      }
      if (this.args.hp > 0) {
        if (!this.args.falling) {
          this.args.bounceCount++;
          this.willJump = true;
        } else if (this.fallTime === 0) {
          const g = this.args.gravity;
          const v = this.args.jumpForce;
          const h = -(this.yTarget - this.args.y);
          const b = g + 2 * v;
          const a = (-b - Math.sqrt(Math.pow(b, 2) + 8 * g * -h)) / (-2 * g);
          const d = this.xTarget - this.args.x;
          this.args.xSpeed = d / a;
          this.args.expectedAirTime = a;
        }
      } else if (this.args.hp < 0 && this.args.animation !== 'exploding' && this.args.animation !== 'exploded') {
        this.args.xSpeed = 0;
        this.args.animation = 'exploding';
        viewport.onFrameOut(80, () => {
          this.args.animation = 'exploded';
          this.args.falling = true;
          this.args.ySpeed = -16;
          this.noClip = true;
          _Sfx.Sfx.play('OBJECT_DESTROYED');
        });
        viewport.onFrameOut(160, () => {
          const capsule = new _EggCapsule.EggCapsule({
            x: this.otherDefs.pointB.x,
            y: this.otherDefs.pointB.y - 384
          });
          viewport.spawn.add({
            object: capsule
          });
        });
      }
      if (this.args.animation === 'exploding') {
        viewport = this.viewport;
        if (viewport && viewport.args.frameId % 3 === 0) {
          const explosion = new _Tag.Tag('<div class = "particle-explosion">');
          _Sfx.Sfx.play('BOSS_DAMAGED');
          const xOff = this.args.width * Math.random() - this.args.width / 2;
          const yOff = this.args.height * Math.random() - this.args.height / 2;
          explosion.style({
            '--x': this.x + xOff,
            '--y': this.y + yOff + -32
          });
          viewport.particles.add(explosion);
          setTimeout(() => viewport.particles.remove(explosion), 512);
        }
      }
    }
  }, {
    key: "collideA",
    value: function collideA(other, type) {
      if (!other.controllable) {
        return;
      }
      if (!other.args.falling && other.groundTime > 1 && !this.args.damaged && !this.standingUnder.has(other)) {
        other.damage(this);
        return false;
      }
      if (type === 0 && other.ySpeedLast > 0) {
        this.args.ySpeed = Math.abs(other.ySpeedLast);
        other.args.ySpeed = -Math.abs(other.ySpeedLast);
        if (other.args.ySpeed > -6) {
          other.args.ySpeed = -6;
        }
        _Sfx.Sfx.play('BOSS_DAMAGED');
        if (!this.args.damaged) {
          this.ignores.set(other, 30);
          this.args.damaged = 30;
          this.args.hp--;
        }
      } else if (type === 2 && other.args.ySpeed < 0) {
        this.args.ySpeed = Math.abs(other.args.ySpeed);
        other.args.ySpeed = -Math.abs(other.args.ySpeed);
        _Sfx.Sfx.play('BOSS_DUDHIT');
      } else if (Math.abs(this.args.x - other.args.x) > this.args.width / 2) {
        other.args.xSpeed *= -1;
        this.args.xSpeed *= -1;
        if (Math.abs(other.args.xSpeed) < 2) {
          other.args.xSpeed = 2 * Math.sign(other.args.x - this.args.x);
        }
        if (Math.abs(this.args.xSpeed) < 2) {
          this.args.xSpeed = 2 * Math.sign(other.args.x - this.args.x);
        }
        _Sfx.Sfx.play('BOSS_DAMAGED');
        if (!this.args.damaged) {
          // this.ignores.set(other, 30);
          this.args.damaged = 30;
          this.args.hp--;
          this.args.ySpeed = -5 * Math.sign(other.args.y - this.args.y);
        }
      }
      return _get(_getPrototypeOf(PogoEgg.prototype), "collideA", this).call(this, other, type);
    }
  }, {
    key: "solid",
    get: function get() {
      return !this.noClip;
    }
  }]);
  return PogoEgg;
}(_PointActor2.PointActor);
exports.PogoEgg = PogoEgg;
});

;require.register("actor/PogoSpring.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PogoSpring = void 0;
var _Vehicle2 = require("./Vehicle");
var _Sfx = require("../audio/Sfx");
var _Tag = require("curvature/base/Tag");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let PogoSpring = /*#__PURE__*/function (_Vehicle) {
  _inherits(PogoSpring, _Vehicle);
  var _super = _createSuper(PogoSpring);
  function PogoSpring() {
    var _this;
    _classCallCheck(this, PogoSpring);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _defineProperty(_assertThisInitialized(_this), "quickDrop", true);
    _defineProperty(_assertThisInitialized(_this), "passPop", true);
    _this.args.type = 'actor-item actor-pogo-spring';
    _this.args.width = 32;
    _this.args.height = 32;
    _this.removeTimer = null;
    _this.args.gSpeedMax = 20;
    _this.args.decel = 0.45;
    _this.args.accel = 0.45;
    _this.args.gravity = 0.6;
    _this.args.seatHeight = 16;
    _this.args.seatForward = -2;
    _this.args.skidTraction = 0.05;
    _this.args.jumpForce = 8;
    _this.dustCount = 0;
    _this.args.particleScale = 2;
    _this.args.started = false;
    _this.args.cameraMode = 'locked';
    _this.args.bound = 0;
    _this.bindTo('occupant', (v, k, t, d, p) => {
      if (p && !v) {
        _this.args.dead = true;
        _this.args.gSpeed = 0;
        _this.args.xSpeed = 0;
        _this.args.ySpeed = 0;
      }
    });
    return _this;
  }
  _createClass(PogoSpring, [{
    key: "onRendered",
    value: function onRendered(event) {
      _get(_getPrototypeOf(PogoSpring.prototype), "onRendered", this).call(this, event);
      this.autoStyle.get(this.box)['--bound'] = 'bound';
    }
  }, {
    key: "update",
    value: function update() {
      this.args.active = !!this.occupant;
      if (!this.args.falling && !this.occupant) {
        this.args.dead = false;
      }
      if (this.occupant && !this.args.falling && this.args.ySpeed > 0) {
        this.args.bound = -Math.floor(this.args.ySpeed || 0);
      }
      if (this.occupant && !this.frameout && !this.args.falling) {
        this.args.height = 16 + this.occupant.args.height;
        this.frameout = this.viewport.onFrameOut(1, () => {
          this.args.falling = true;
          this.frameout = false;
          this.args.ySpeed = this.args.bound;
          if (this.args.ySpeed > -3) {
            this.args.ySpeed -= 3;
          }
          if (this.args.ySpeed > -13) {
            this.args.ySpeed -= 3;
          }
          if (this.args.ySpeed < -24) {
            this.args.ySpeed = -24;
          }
        });
        this.args.xSpeed *= 0.3;
        const xDir = this.xAxis || this.xSpeedLast || 0;
        this.args.direction = Math.sign(xDir);
        this.args.facing = Math.sign(xDir) < 0 ? 'left' : 'right';
        _Sfx.Sfx.play('POGO_BOUNCE');
      } else if (!this.occupant) {
        this.args.gSpeed = 0;
        this.args.xSpeed = 0;
      }
      if (!this.occupant) {
        this.args.height = 32;
        this.args.bound = -4;
      }
      this.noClip = this.args.dead;
      _get(_getPrototypeOf(PogoSpring.prototype), "update", this).call(this);
    }
  }, {
    key: "collideA",
    value: function collideA(other, type) {
      if (other instanceof PogoSpring) {
        return;
      }
      if (other.args.falling && other.args.ySpeed > 0) {
        this.args.bound = -other.args.ySpeed;
      }
      _get(_getPrototypeOf(PogoSpring.prototype), "collideA", this).call(this, other, type);
    }
  }, {
    key: "sleep",
    value: function sleep() {
      this.args.x = this.def.get('x');
      this.args.y = this.def.get('y');
      this.viewport.setColCell(this);
      this.args.dead = false;
      this.args.gSpeed = 0;
      this.args.xSpeed = 0;
      this.args.ySpeed = 0;
      this.args.bound = 0;
      _get(_getPrototypeOf(PogoSpring.prototype), "sleep", this).call(this);
      this.args.facing = 'right';
    }

    // wakeUp()
    // {
    // 	this.args.x = this.def.get('x');
    // 	this.args.y = this.def.get('y');

    // 	this.args.dead = false;

    // 	this.args.gSpeed = 0;
    // 	this.args.xSpeed = 0;
    // 	this.args.ySpeed = 0;

    // 	this.args.bound  = 0;

    // 	super.sleep();

    // 	this.args.facing = 'right';

    // 	if(!this.args.falling && !this.occupant)
    // 	{
    // 		this.args.dead = false;
    // 	}

    // 	super.wakeUp();
    // }
  }, {
    key: "solid",
    get: function get() {
      return !this.occupant;
    }
  }, {
    key: "rotateLock",
    get: function get() {
      return false;
    }
  }]);
  return PogoSpring;
}(_Vehicle2.Vehicle);
exports.PogoSpring = PogoSpring;
});

;require.register("actor/PointActor.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PointActor = void 0;
var _Bindable = require("curvature/base/Bindable");
var _View2 = require("curvature/base/View");
var _Tag = require("curvature/base/Tag");
var _Twist = require("../effects/Twist");
var _Droop = require("../effects/Droop");
var _Pinch = require("../effects/Pinch");
var _CharacterString = require("../ui/CharacterString");
var _Classifier = require("../Classifier");
var _Controller = require("../controller/Controller");
var _Sheild = require("../powerups/Sheild");
var _FireSheild = require("../powerups/FireSheild");
var _SuperSheild = require("../powerups/SuperSheild");
var _BubbleSheild = require("../powerups/BubbleSheild");
var _NormalSheild = require("../powerups/NormalSheild");
var _ElectricSheild = require("../powerups/ElectricSheild");
var _StarSheild = require("../powerups/StarSheild");
var _LayerSwitch = require("./LayerSwitch");
var _Layer = require("../viewport/Layer");
var _Platformer = require("../behavior/Platformer");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
const MODE_FLOOR = 0;
const MODE_LEFT = 1;
const MODE_CEILING = 2;
const MODE_RIGHT = 3;
const WALKING_SPEED = 100;
const RUNNING_SPEED = Infinity;
const CRAWLING_SPEED = 1;
const JUMP_FORCE = 15;
const DEFAULT_GRAVITY = MODE_FLOOR;
const BOUNDS = Symbol('BOUNDS');
let PointActor = /*#__PURE__*/function (_View) {
  _inherits(PointActor, _View);
  var _super = _createSuper(PointActor);
  function PointActor() {
    var _this$args$weight, _this$args$opacity, _this$args$layer, _this$args$active, _this$args$gravity, _this$args$name;
    var _this;
    let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let parent = arguments.length > 1 ? arguments[1] : undefined;
    _classCallCheck(this, PointActor);
    args[_Bindable.Bindable.NoGetters] = true;
    _this = _super.call(this, args, parent);
    _defineProperty(_assertThisInitialized(_this), "template", `<div class  = "point-actor [[type]]">
		<div class = "sprite" cv-ref = "sprite"></div>
	</div>`);
    _defineProperty(_assertThisInitialized(_this), "profiles", {
      normal: {
        height: 1,
        width: 1,
        decel: 0.85,
        accel: 0.2,
        gravity: 0.65,
        airAccel: 0.3,
        jumpForce: 14,
        gSpeedMax: 100
        // , rollSpeedMax = 37;
      }
    });

    _this[_Bindable.Bindable.NoGetters] = true;
    Object.defineProperty(_this.nodes, _Bindable.Bindable.NoGetters, {
      value: true
    });
    _this.defaultDisplay = 'initial';
    _this.others = {};
    _this.otherDefs = {};
    _this.args.knocked = false;
    _this.springing = false;
    _this.isGhost = false;
    _this.stepsTaken = 0;

    // this.stepCache = {};

    _this.fallTime = 0;
    _this.idleTime = 0;
    _this.groundTime = 0;
    _this.locked = 0;
    _this.xHold = 12;
    _this.yHold = 12;
    _this.args.weight = (_this$args$weight = _this.args.weight) !== null && _this$args$weight !== void 0 ? _this$args$weight : 100;
    _this.args.score = 0;
    _this.args.rings = 0;
    _this.args.mercy = false;
    _this.args.stuck = false;
    _this.args.R = 0;
    _this.args.popChain = [];
    _this.args.canHide = false;
    _this.collisionMap = null;
    _this.doorMap = new Map();
    _this.args.opacity = (_this$args$opacity = _this.args.opacity) !== null && _this$args$opacity !== void 0 ? _this$args$opacity : 1;
    _this.args.pushing = false;
    _this.autoStyle = new Map();
    _this.autoAttr = new Map();
    _this.hanging = new Map();
    _this.ignores = new Map();
    _this.regions = new Set();
    _this.powerups = new Set();
    _this.behaviors = new Set();
    _this.args.lookTime = 0;
    _this.behaviors.add(new _Platformer.Platformer());
    _this.lastPointA = [];
    _this.lastPointB = [];
    _this.carrying = new Set();
    _this.inventory = new _Classifier.Classifier([_Sheild.Sheild, _FireSheild.FireSheild, _BubbleSheild.BubbleSheild, _ElectricSheild.ElectricSheild, _NormalSheild.NormalSheild]);
    _this.splashes = new Set();
    _this.noClip = false;
    _this.sheild = null;
    _this.inventory.addEventListener('adding', event => {
      let item = event.detail.object;
      if (_this.inventory.has(item.constructor)) {
        if (!(_this.args.currentSheild instanceof _StarSheild.StarSheild)) {
          item = [..._this.inventory.get(item.constructor)][0];
          _this.args.currentSheild = item;
          item.equip && item.equip(_assertThisInitialized(_this));
        }
        event.preventDefault();
        return;
      }
      _this.powerups.add(item);
      if (_this.controllable) {
        const hasKey = `has${item.type[0].toUpperCase() + item.type.substr(1)}`;
        _this.viewport.args[hasKey] = hasKey;
      }
      item.acquire && item.acquire(_assertThisInitialized(_this));
      if (!(_this.args.currentSheild instanceof _StarSheild.StarSheild)) {
        _this.args.currentSheild = item;
        item.equip && item.equip(_assertThisInitialized(_this));
      }
    });
    _this.inventory.addEventListener('removing', event => {
      const item = event.detail.object;
      _this.powerups.delete(item);
      if (_this.controllable) {
        const hasKey = `has${item.type[0].toUpperCase() + item.type.substr(1)}`;
        _this.viewport.args[hasKey] = null;
      }
      if (_Bindable.Bindable.make(item) === _this.args.currentSheild) {
        _this.args.currentSheild = null;
      }
    });
    _this.args.bindTo('isGhost', (v, k, t, d, p) => _this.isGhost = v);
    _this.args.bindTo('currentSheild', (v, k, t, d, p) => {
      if (p) {
        p.unequip && p.unequip(_assertThisInitialized(_this));
      }
      for (const shield of _this.inventory.get(_Sheild.Sheild)) {
        if (shield instanceof _SuperSheild.SuperSheild) {
          continue;
        }
        shield.detach();
      }
      v && v.equip && v.equip(_assertThisInitialized(_this));
      v && v.render(_this.sprite);
    });

    // Object.defineProperty(this, 'public', {value: {}});

    // this.args.bindTo((v,k) => {
    // 	this.public[k] = v;
    // });

    _this.args.type = 'actor-generic';
    _this.args.modeTime = 0;
    _this.args.charStrings = [];
    _this.args.display = _this.args.display || 'initial';
    _this.args.rings = 0;
    _this.args.coins = 0;
    _this.args.emeralds = 0;
    _this.args.emblems = [];
    _this.args.emblemsCurrent = [];
    _this.args.dead = false;
    _this.args.respawning = false;
    _this.ringSet = new Set();
    _this.ringDoc = new DocumentFragment();
    _this.args.yMargin = 0;
    _this.args.cameraMode = 'normal';
    _this.args.cameraBias = 0;
    _this.args.layer = (_this$args$layer = _this.args.layer) !== null && _this$args$layer !== void 0 ? _this$args$layer : 1;
    _this.args.active = (_this$args$active = _this.args.active) !== null && _this$args$active !== void 0 ? _this$args$active : false;
    _this.args.moving = false;
    _this.args.flySpeedMax = 40;
    _this.args.x = _this.args.x || 1024 + 256;
    _this.args.y = _this.args.y || 32;
    _this.args.z = _this.args.z || 0;
    _this.args.xOff = 0;
    _this.args.yOff = 0;
    _this.args.jumpArced = false;
    _this.args.width = _this.args.width || 1;
    _this.args.height = _this.args.height || 1;
    _this.args.direction = Number(_this.args.direction) || 1;
    _this.args.heading = 0;
    _this.args.gSpeed = _this.args.gSpeed || 0;
    _this.args.hSpeed = 0;
    _this.args.xSpeed = _this.args.xSpeed || 0;
    _this.args.ySpeed = _this.args.ySpeed || 0;
    _this.args.angle = _this.args.angle || 0;
    _this.args.groundAngle = _this.args.groundAngle || 0;
    _this.args.displayAngle = 0;
    _this.args.seatAngle = 0;
    _this.args.airAngle = 0;
    const lastAngles = [];
    Object.defineProperty(lastAngles, _Bindable.Bindable.NoGetters, {
      value: true
    });
    _this.lastAngles = lastAngles;
    _this.angleAvg = 16;
    _this.args.xSpeedMax = 512;
    _this.args.ySpeedMax = 512;
    _this.args.gSpeedMax = WALKING_SPEED;
    _this.args.rollSpeedMax = 23;
    _this.args.gravity = (_this$args$gravity = _this.args.gravity) !== null && _this$args$gravity !== void 0 ? _this$args$gravity : 0.65;
    _this.args.decel = 0.85;
    _this.args.accel = 0.2;
    _this.args.airAccel = 0.3;
    _this.args.jumpForce = 14;
    _this.args.airTimeTotal = 0;
    _this.args.groundTimeTotal = 0;
    _this.args.jumping = false;
    _this.args.jumpedAt = null;
    _this.args.deepJump = false;
    _this.args.highJump = false;
    _this.maxStep = 11;
    _this.backStep = 0;
    _this.frontStep = 0;
    _this.args.rolling = false;
    _this.args.sliding = false;
    _this.args.skidTraction = 2.25;
    _this.args.skidTraction = 5;
    _this.args.fgFilter = 'none';
    _this.args.bgFilter = 'none';
    _this.args.falling = true;
    _this.args.running = false;
    _this.args.crawling = false;
    _this.args.climbing = false;
    _this.args.rotateFixed = false;
    _this.args.mode = _this.args.mode || MODE_FLOOR;
    _this.xAxis = 0;
    _this.yAxis = 0;
    _this.aAxis = 0;
    _this.bAxis = 0;
    _this.lAxis = 0;
    _this.rAxis = 0;
    _this.buttons = {};
    _this.stayStuck = false;
    _this.willStick = false;
    _this.args.startled = _this.args.startled || 0;
    _this.args.antiSkid = _this.args.antiSkid || 0;
    _this.args.halted = _this.args.halted || 0;
    _this.args.ignore = _this.args.ignore || 0;
    _this.args.float = _this.args.float || 0;
    _this.colliding = false;
    _this.args.flyAngle = 0;
    _this.standingUnder = new Set();
    _this[BOUNDS] = false;
    _this.args.bindTo(['mode', 'falling'], () => {
      _this.args.modeTime = 0;
      _this[BOUNDS] = false;
    });
    _this.moved = false;
    _this.args.bindTo(['x', 'y', 'direction'], (v, k, t) => {
      _this[BOUNDS] = false;
      isNaN(v) && console.trace(k, v);
      // this.stepCache = {};
      _this.idleTime = 0;
      _this.moved = true;
    });
    _this.args.bindTo(['width', 'height'], (v, k, t) => {
      _this[BOUNDS] = false;
      _this.moved = true;
    });
    _this.args.bindTo(['xSpeed', 'ySpeed'], (v, k, t) => {
      isNaN(v) && console.trace(k, v);
    });
    _this.args.bindTo('gSpeed', v => {
      _this.gSpeedLast = v || _this.gSpeedLast;
    });
    _this.args.bindTo('xSpeed', v => {
      _this.airAngle = _this.args.airAngle = Math.atan2(_this.args.ySpeed, v);
      _this.xSpeedLast = v || _this.xSpeedLast;
    });
    _this.args.bindTo('ySpeed', v => {
      _this.airAngle = _this.args.airAngle = Math.atan2(v, _this.args.xSpeed);
      _this.ySpeedLast = v || _this.ySpeedLast;
    });

    // this.controllable && this.args.bindTo('animation', v => console.trace(v));
    // this.controllable && this.args.bindTo('xSpeed', v => console.trace(v));
    // this.controllable && this.args.bindTo('ySpeed', v => console.trace(v));
    // this.controllable && this.args.bindTo('gSpeed', v => console.trace(v));
    // this.controllable && this.args.bindTo('falling', v => console.trace(v));

    _this.impulseMag = null;
    _this.impulseDir = null;
    _this.args.stopped = 0;
    _this.args.particleScale = 1;
    _this.dropDashCharge = 0;
    const bindable = _Bindable.Bindable.make(_assertThisInitialized(_this));
    _this.debindGroundX = null;
    _this.debindGroundY = null;
    _this.debindGroundA = null;
    _this.debindGroundL = null;
    _this.args.name = (_this$args$name = _this.args.name) !== null && _this$args$name !== void 0 ? _this$args$name : '';
    if (_this.controllable) {
      _this.controller = new _Controller.Controller({
        deadZone: 0.2
      });

      // this.args.charStrings = [
      // 	new CharacterString({value: this.args.name ?? ''})
      // ];

      _this.controller.zero();
    }
    _this.debindGroundX = new Set();
    _this.debindGroundY = new Set();
    _this.debindGroundA = new Set();
    _this.debindGroundL = new Set();
    _this.args.bindTo('standingOn', (groundObject, key, target, previous) => {
      if (_this.isGhost) {
        return;
      }
      if (_this.args.standingOn === groundObject) {
        return;
      }
      for (const debind of _this.debindGroundX) {
        _this.debindGroundX.delete(debind);
        debind();
      }
      for (const debind of _this.debindGroundY) {
        _this.debindGroundY.delete(debind);
        debind();
      }
      for (const debind of _this.debindGroundA) {
        _this.debindGroundA.delete(debind);
        debind();
      }
      for (const debind of _this.debindGroundL) {
        _this.debindGroundL.delete(debind);
        debind();
      }
      const prevGroundObject = target[key];
      if (prevGroundObject) {
        if (prevGroundObject.isVehicle) {
          prevGroundObject.occupant = null;
          prevGroundObject.stayStuck = false;
          prevGroundObject.willStick = false;
          prevGroundObject.xAxis = 0;
          prevGroundObject.yAxis = 0;

          // prevGroundObject.args.active = false;
        }

        prevGroundObject.standingUnder && prevGroundObject.standingUnder.delete(_assertThisInitialized(_this));
      }
      const Switch = _this.viewport.objectPalette['switch'];
      if (_this.controllable) {
        if (prevGroundObject && !(prevGroundObject instanceof Switch)) {
          // prevGroundObject.args.active = false;
          _this.viewport.auras.delete(prevGroundObject);
        }

        // if(groundObject && !(groundObject instanceof Switch))
        // {
        // 	groundObject.args.active = true;
        // }
      }

      if (!groundObject) {
        _this.viewport.auras.delete(_this.args.standingOn);
        return;
      }
      groundObject.standingUnder.add(_assertThisInitialized(_this));
      if (_this.controllable && groundObject.isVehicle && !groundObject.dead) {
        if (!_this.args.gSpeed) {
          _this.args.pushing = false;
        }

        // groundObject.args.active = true;

        const debindGroundX = groundObject.args.bindTo('x', (vv, kk) => {
          const x = groundObject.args.direction * groundObject.args.seatForward || 0;
          const y = groundObject.args.seatHeight || groundObject.args.height || 0;
          const _groundObject$rotateP = groundObject.rotatePoint(x, y),
            _groundObject$rotateP2 = _slicedToArray(_groundObject$rotateP, 2),
            xRot = _groundObject$rotateP2[0],
            yRot = _groundObject$rotateP2[1];
          _this.args.x = xRot + vv;
          _this.args.y = yRot + groundObject.y;
          _this.args.direction = groundObject.args.direction;
        });
        const debindGroundY = groundObject.args.bindTo('y', (vv, kk) => {
          if (_this.args.jumping) {
            return;
          }
          const x = groundObject.args.direction * groundObject.args.seatForward || 0;
          const y = groundObject.args.seatHeight || groundObject.args.height || 0;
          const _groundObject$rotateP3 = groundObject.rotatePoint(x, y),
            _groundObject$rotateP4 = _slicedToArray(_groundObject$rotateP3, 2),
            xRot = _groundObject$rotateP4[0],
            yRot = _groundObject$rotateP4[1];
          _this.args.x = xRot + groundObject.x;
          _this.args.y = yRot + vv;
        });

        // const debindGroundA = groundObject.args.bindTo('groundAngle', (vv,kk) => {

        // 	if(this.args.jumping)
        // 	{
        // 		return;
        // 	}

        // 	const x = groundObject.args.direction * groundObject.args.seatForward || 0;
        // 	const y = groundObject.args.seatHeight || groundObject.args.height || 0;

        // 	const [xRot, yRot] = groundObject.rotatePoint(x, y);

        // 	this.args.x = xRot + groundObject.x;
        // 	this.args.y = yRot + groundObject.y;
        // });

        const debindGroundL = groundObject.args.bindTo('layer', (vv, kk) => {
          _this.args.layer = vv;
        });
        _this.debindGroundX.add(debindGroundX);
        _this.debindGroundY.add(debindGroundY);
        // this.debindGroundA.add(debindGroundA);
        _this.debindGroundL.add(debindGroundL);
        const occupant = groundObject.occupant;
        groundObject.args.yMargin = _this.args.height;
        if (occupant && occupant !== _assertThisInitialized(_this)) {
          occupant.args.standingOn = null;
          occupant.args.y -= 32;
          occupant.args.gSpeed = 0;
          occupant.args.xSpeed = -5 * _this.args.direction;
          occupant.args.ySpeed = -8;
          occupant.args.falling = true;
        }
        _this.args.gSpeed = 0;
        _this.args.xSpeed = 0;
        _this.args.ySpeed = 0;
        _this.args.falling = false;
        groundObject.occupant = _assertThisInitialized(_this);
      } else if (!groundObject.isVehicle) {
        if (_this.args.y <= 1 + groundObject.args.y - groundObject.args.height)
          // if(this.args.y <= this.args.height + groundObject.args.y - groundObject.args.height)
          {
            const debindGroundX = groundObject.args.bindTo('x', (vv, kk) => {
              const solid = groundObject.getMapSolidAt(_this.args.x + vv + -groundObject.args.x, _this.args.y);
              if (solid) {
                return;
              }
              _this.args.x += vv + -groundObject.args.x;
            });
            const debindGroundY = groundObject.args.bindTo('y', (vv, kk) => {
              const newY = vv + -groundObject.args.height + (_this.controllable || _this.isPushable ? 0 : 0);
              const solid = groundObject.getMapSolidAt(_this.args.x, newY);
              if (solid) {
                return;
              }
              _this.args.y = newY;
            });
            const debindGroundL = groundObject.args.bindTo('layer', (vv, kk) => {
              _this.args.layer = vv;
            });
            _this.debindGroundX.add(debindGroundX);
            _this.debindGroundY.add(debindGroundY);
            _this.debindGroundL.add(debindGroundL);
            if (!groundObject.args.treadmill) {
              _this.args.gSpeed -= groundObject.args.gSpeed;
            }
          }
      }
      if (prevGroundObject && prevGroundObject.isVehicle) {
        if (prevGroundObject.occupant === _assertThisInitialized(_this)) {
          prevGroundObject.occupant = null;
          prevGroundObject.stayStuck = false;
          prevGroundObject.willStick = false;
        }
        prevGroundObject.xAxis = 0;
        prevGroundObject.yAxis = 0;
      }
      groundObject.standBelow(_assertThisInitialized(_this));
    });
    _this.age = 0;
    return _possibleConstructorReturn(_this, bindable);
  }
  _createClass(PointActor, [{
    key: "onRendered",
    value: function onRendered() {
      this.sprite = this.findTag('div.sprite');
      this.box = this.findTag('div');
      this.autoStyle.set(this.box, {
        display: 'display',
        '--animation-bias': 'animationBias',
        '--bg-filter': 'bgFilter',
        '--sprite-sheet': 'spriteSheetUrl',
        '--direction': 'direction',
        '--sprite-x': 'spriteX',
        '--sprite-y': 'spriteY',
        '--angle': 'angle',
        '--palletShift': 'palletShift',
        '--fly-angle': 'flyAngle',
        '--display-angle': 'groundAngle8',
        '--ground-angle': 'groundAngle8',
        '--seat-angle': 'seatAngle',
        '--ground-angle8': 'groundAngle8',
        '--air-angle': 'airAngle',
        '--corkscrew': 'corkscrew',
        '--opacity': 'opacity',
        '--height': 'height',
        '--width': 'width',
        '--x': 'x',
        '--y': 'y',
        '--z': 'z'
      });
      this.autoAttr.set(this.box, {
        'data-camera-mode': 'cameraMode',
        'data-colliding': 'colliding',
        'data-direction': 'direction',
        'data-respawning': 'respawning',
        'data-animation': ' animation',
        'data-heading': 'heading',
        'data-super': 'isSuper',
        'data-hyper': 'isHyper',
        'data-mercy': 'mercy',
        'data-selected': 'selected',
        'data-following': 'following',
        'data-carrying': 'carrying',
        'data-reversing': 'reversing',
        'data-falling': 'falling',
        'data-moving': 'moving',
        'data-pushing': 'pushing',
        'data-facing': 'facing',
        'data-filter': 'filter',
        'data-angle': 'angleDeg',
        'data-driving': 'driving',
        'data-active': 'active',
        'data-knocked': 'knocked',
        'data-layer': 'layer',
        'data-dead': 'dead',
        'data-mode': 'mode',
        'data-netplayer': 'netplayer',
        'data-id': 'id'
      });

      // data-camera-mode = "[[cameraMode]]"
      // data-colliding   = "[[colliding]]"
      // data-falling     = "[[falling]]"
      // data-facing      = "[[facing]]"
      // data-filter      = "[[filter]]"
      // data-angle       = "[[angle|rad2deg]]"
      // data-layer       = "[[layer]]"
      // data-mode        = "[[mode]]"
      // data-id          = "[[id]]"

      if (this.init || !this.viewport) {
        return;
      }

      // const regionClass = this.viewport.objectPalette['base-region']

      // this.isRegion = this instanceof regionClass;

      this.args.bindTo('spriteSheet', v => {
        if (v !== undefined) {
          this.args.spriteSheetUrl = this.urlWrap(v);
        } else {
          this.args.spriteSheetUrl = undefined;
        }
      });
      this.args.bindTo('angle', v => this.args.angleDeg = this.rad2deg(v));
      this.args.charStrings.bindTo(v => {
        if (!this.labels && this.args.charStrings.length) {
          this.labels = _View2.View.from('<div class = "labels" cv-ref = "labels" cv-each = "charStrings:charString:c">[[charString]]</div>', {
            charStrings: this.args.charStrings
          });
          this.labels.render(this.sprite);
        } else if (this.labels && !this.args.charStrings.length) {
          this.labels.remove();
          this.labels = null;
        }
      }, {
        wait: 0
      });
      this.init = true;
      this.args.bindTo('animation', (v, k, t, d, p) => {
        // const animations = this.box.getAnimations({subtree:true});
        // animations.forEach(animation => animation.cancel());
        this.box.setAttribute('data-animation', v);
      });
      if (this.controllable) {
        this.sprite.parentNode.classList.add('controllable');
      }
      for (const behavior of this.behaviors) {
        behavior.rendered && behavior.rendered(_Bindable.Bindable.make(this));
      }
    }
  }, {
    key: "updateStart",
    value: function updateStart() {
      if ((this.isSuper || this.isHyper) && !this.args.currentSheild instanceof _SuperSheild.SuperSheild) {
        const superSheild = new _SuperSheild.SuperSheild();
        superSheild.equip(this);
        this.inventory.add(superSheild);
      } else if (this.args.currentSheild && this.args.currentSheild instanceof _SuperSheild.SuperSheild) {
        const superSheild = this.args.currentSheild;
        superSheild && superSheild.unequip(this);
        this.args.currentSheild = null;
      }
      if (this.args.dead) {
        this.args.xSpeed = 0;
      }
      for (const behavior of this.behaviors) {
        behavior.updateStart && behavior.updateStart(this);
      }
    }
  }, {
    key: "updateEnd",
    value: function updateEnd() {
      const speedDir = Math.sign(this.args.gSpeed || this.args.xSpeed || this.args.direction);
      if (speedDir > 0 && this.args.facing === 'left' || speedDir < 0 && this.args.facing === 'right') {
        this.args.reversing = true;
      } else {
        this.args.reversing = false;
      }
      for (const behavior of this.behaviors) {
        behavior.updateEnd && behavior.updateEnd(this);
      }
      if (this.viewport && this.viewport.args.frameId % this.viewport.settings.frameSkip !== 0) {
        return;
      }
      const lastFocus = this.focused;
      if (!this.args.falling) {
        // this.focused = false;
      }
      for (const region of this.regions) {
        if (region.focus) {
          this.viewport.auras.add(region.focus);
          this.focused = region.focus;
        }
      }
      if (lastFocus !== this && lastFocus !== this.focused) {
        this.viewport && this.viewport.auras.delete(lastFocus);
      }
      if (this.focused && this.focused.broken) {
        this.focused = null;
      }
      this.args.groundAngle8 = this.args.groundAngle;
      if (!this.isVehicle && !this.args.falling && !this.args.grinding && this.args.mode === 0 && Math.abs(this.args.groundAngle8) <= Math.PI / 8 + 0.01) {
        this.args.groundAngle8 = 0;
      }
      for (const _ref of this.autoStyle) {
        var _ref2 = _slicedToArray(_ref, 2);
        const tag = _ref2[0];
        const cssArgs = _ref2[1];
        const styles = {};
        for (const _ref3 of Object.entries(cssArgs)) {
          var _ref4 = _slicedToArray(_ref3, 2);
          const prop = _ref4[0];
          const arg = _ref4[1];
          if (arg in this.args) {
            styles[prop] = this.args[arg];
          }
        }
        tag.style(styles);
      }
      for (const _ref5 of this.autoAttr) {
        var _ref6 = _slicedToArray(_ref5, 2);
        const tag = _ref6[0];
        const attrsArgs = _ref6[1];
        const attrs = {};
        for (const _ref7 of Object.entries(attrsArgs)) {
          var _ref8 = _slicedToArray(_ref7, 2);
          const attr = _ref8[0];
          const arg = _ref8[1];
          if (arg in this.args) {
            attrs[attr] = this.args[arg];
          }
        }
        tag.attr(attrs);
      }
      for (const splash of this.splashes) {
        splash.x += this.args.xSpeed * (1 - splash.age / 30);
        splash.style({
          '--x': splash.x
        });
        splash.age++;
      }
      if (this.viewport && this.startFrame !== undefined) {
        this.age++;
      } else {
        this.age = 0;
      }
      if (this.screenLock) {
        if (this.args.x < this.screenLock.xMin) {
          this.args.x = this.screenLock.xMin;
        }
        if (this.args.x > this.screenLock.xMax) {
          this.args.x = this.screenLock.xMax;
        }
      }
    }
  }, {
    key: "update",
    value: function update() {
      if (this.locked > 0) {
        this.locked--;
      }
      for (const _ref9 of this.ignores) {
        var _ref10 = _slicedToArray(_ref9, 2);
        const object = _ref10[0];
        const timeout = _ref10[1];
        if (timeout <= 0) {
          this.ignores.delete(object);
        } else {
          this.ignores.set(object, -1 + timeout);
        }
      }
      for (const behavior of this.behaviors) {
        behavior.update && behavior.update(this);
      }
    }
  }, {
    key: "getLocalDrag",
    value: function getLocalDrag() {
      if (this.args.dead) {
        return 1;
      }
      let drag = 1;
      for (const region of this.regions) {
        if (region.skimmers.has(this) || region.skimmers.has(_Bindable.Bindable.make(this))) {
          continue;
        }
        if (!region.args.drag && region.args.drag !== 0) {
          continue;
        }
        if (region.args.drag < drag) {
          drag = region.args.drag;
        }
      }
      return drag;
    }
  }, {
    key: "getLocalFriction",
    value: function getLocalFriction() {
      let friction = 1;
      for (const region of this.regions) {
        if (region.skimmers.has(this) || region.skimmers.has(_Bindable.Bindable.make(this))) {
          continue;
        }
        if (!region.args.friction && region.args.friction !== 0) {
          continue;
        }
        if (region.args.friction < friction) {
          friction = region.args.friction;
        }
      }
      return friction;
    }
  }, {
    key: "setCameraMode",
    value: function setCameraMode() {
      if (!this.viewport) {
        return;
      }
      if (this.args.cameraIgnore) {
        return;
      }
      if (this.args.cameraMode === 'popping' && Math.abs(this.args.xSpeed) > Math.abs(this.args.ySpeed)) {
        this.args.cameraMode = 'aerial';
      }
      if (this.focused) {
        this.args.cameraMode = 'panning';
        return;
      }
      if (this.viewport.args.cutScene) {
        this.args.cameraMode = 'cutScene';
        return;
      }
      if (this.args.bossMode) {
        this.args.cameraMode = 'boss';
        return;
      }
      if (this.args.standingOn && this.args.standingOn.isVehicle) {
        this.args.cameraMode = this.args.standingOn.args.cameraMode;
      } else if (this.args.localCameraMode) {
        this.args.cameraMode = this.args.localCameraMode;
      } else if (this.controllable) {
        if (this.args.mode && !this.args.falling && this.args.rolling && this.args.jumpBlocked) {
          this.args.cameraMode = 'tube';
        } else if (!this.args.falling || this.getMapSolidAt(this.args.x, this.args.y + 24)) {
          const forwardSolid = this.getMapSolidAt(this.args.x + 32 * this.args.direction, this.args.y + 24);
          const forwardDeepSolid = this.getMapSolidAt(this.args.x + 32 * this.args.direction, this.args.y + 96);
          const underSolid = this.getMapSolidAt(this.args.x + 0 * this.args.direction, this.args.y + 48);
          if (this.args.mode === MODE_FLOOR && this.args.groundAngle === 0) {
            if (Math.abs(this.args.groundAngle) < Math.PI / 4) {
              if (!underSolid && forwardSolid && !this.args.grinding && !this.args.skimming) {
                this.args.cameraMode = 'bridge';
              } else if (!forwardSolid && !forwardDeepSolid && !this.args.grinding && !this.args.skimming) {
                this.args.cameraMode = 'cliff';
              } else {
                this.args.cameraMode = 'normal';
              }
            } else {
              this.args.cameraMode = 'normal';
            }
          } else {
            this.args.cameraMode = 'normal';
          }
        } else {
          if (this.getMapSolidAt(this.args.x + 0 * this.args.direction, this.args.y + 64)) {
            if (!this.args.falling || this.args.cameraMode !== 'popping' || Math.abs(this.args.ySpeed) < Math.abs(this.args.xSpeed)) {
              this.args.cameraMode = 'normal';
            }
          } else if (this.fallTime > 15) {
            if (this.args.cameraMode !== 'panning' && (this.args.cameraMode !== 'popping' || this.args.ySpeed > 10)) {
              this.args.cameraMode = 'aerial';
            }
          }
          this.viewport.onFrameOut(45, () => {
            if (this.args.cameraMode === 'airplane') {
              return;
            }
            if (this.args.falling && this.isVehicle && Math.abs(this.args.xSpeed > 25) && !this.getMapSolidAt(this.args.x, this.args.y + 480)) {
              this.args.cameraMode = 'airplane';
            }
          });
        }
      }
    }
  }, {
    key: "callCollideHandler",
    value: function callCollideHandler(other) {
      if (this.ignores.has(other)) {
        return false;
      }
      if (other.ignores.has(this)) {
        return false;
      }
      if (this.args.dead || other.args.dead) {
        return;
      }
      if (other === this.args.hangingFrom) {
        return false;
      }
      if (this.isGhost || other.isGhost) {
        return;
      }
      if (!this.viewport) {
        return;
      }
      const viewport = this.viewport;
      let type;
      if (other.args.y <= this.args.y - this.args.height) {
        this.args.collType = 'collision-top';
        type = 0;
      } else if (other.args.x < this.args.x - Math.floor(this.args.width / 2)) {
        this.args.collType = 'collision-left';
        type = 1;
      } else if (other.args.x >= this.args.x + Math.floor(this.args.width / 2)) {
        this.args.collType = 'collision-right';
        type = 3;
      } else if (other.args.y >= this.args.y) {
        this.args.collType = 'collision-bottom';
        type = 2;
      } else {
        this.args.collType = 'collision-intersect';
        type = -1;

        // this.solid && !this.isVehicle && this.popOut(other);
      }

      if (!viewport.collisions.has(this)) {
        viewport.collisions.set(this, new Map());
      }
      if (!viewport.collisions.has(other)) {
        viewport.collisions.set(other, new Map());
      }

      // if(this.viewport.collisions.get(this).has(other))
      // {
      // 	return;
      // }

      const invertType = type > -1 ? (type + 2) % 4 : type;

      // other.pause(true);

      // this.viewport.collisions.set(other, collisionListB);

      this.collideB(other, type);
      other.collideB(this, invertType);
      const ab = this.collideA(other, type);
      const ba = other.collideA(this, invertType);
      const result = ab || ba;
      this.args.colliding = this.colliding = this.colliding || result || false;
      if (result !== false) {
        const collisionListA = viewport.collisions.get(this, type);
        const collisionListB = viewport.collisions.get(other, invertType);
        collisionListA.set(other, type);
        collisionListB.set(this, invertType);
      }
      return result;
    }
  }, {
    key: "processInput",
    value: function processInput() {
      if (this.controllable && this.args.standingOn && this.args.standingOn.isVehicle && this === _Bindable.Bindable.make(this.args.standingOn.occupant)) {
        if (this.args.modeTime < 5) {
          return;
        }
        this.viewport.auras.add(this.args.standingOn);
        const vehicle = this.args.standingOn;
        vehicle.xAxis = this.xAxis;
        vehicle.yAxis = this.yAxis;
        vehicle.stayStuck = this.stayStuck;
        vehicle.willStick = this.willStick;
        this.processInputVehicle();
        this.args.direction = vehicle.args.direction;
        this.args.facing = vehicle.args.facing;
        this.args.layer = vehicle.args.layer;
        this.args.mode = vehicle.args.mode;
        this.args.angle = vehicle.args.angle;

        // const seatX = (vehicle.args.seatX || 0) * this.args.direction;
        // const seatY = (vehicle.args.seatY || 0);

        // this.args.x = vehicle.args.x + seatX;
        // this.args.y = vehicle.args.y + vehicle.args.height + seatY;
      } else if (this.controllable) {
        this.processInputDirect();
      }
    }
  }, {
    key: "processInputDirect",
    value: function processInputDirect() {
      let xAxis = this.xAxis;
      let yAxis = this.yAxis;
      let gSpeedMax = this.args.gSpeedMax;
      if (this.running) {
        gSpeedMax = RUNNING_SPEED;
      } else if (this.crawling) {
        gSpeedMax = CRAWLING_SPEED;
      }
      const drag = this.getLocalDrag();
      if (this.noClip) {
        if (!this.args.ignore) {
          this.args.xSpeed += xAxis * this.args.airAccel * drag;
          this.args.ySpeed += yAxis * this.args.airAccel * drag;
          if (!xAxis) {
            this.args.xSpeed = 0;
          }
          if (!yAxis) {
            this.args.ySpeed = 0;
          }
        }
      } else if (!this.args.falling) {
        const grindInput = !this.args.grinding || Math.sign(this.args.gSpeed) === Math.sign(this.xAxis) || Math.abs(this.args.gSpeed) > 6 && Math.abs(this.args.gSpeed) < this.args.gSpeedMax * 2 || this.args.gSpeed === 0;
        if (!this.args.rolling && grindInput && !this.yAxis && !this.spindashCharge) {
          const axisSign = Math.sign(xAxis);
          let gSpeed = this.args.gSpeed;
          const sign = Math.sign(gSpeed);
          const friction = this.getLocalFriction();
          if (!this.args.ignore) {
            if (!this.args.rolling && !this.args.sliding && !this.args.climbing && !this.args.wallSticking) {
              if (axisSign === sign || !sign) {
                if (Math.abs(axisSign - sign) < 2) {
                  gSpeed += xAxis * friction * this.args.accel * drag;
                  // this.args.ignore = 10;
                }
              } else if (!this.args.ignore && !this.args.antiSkid && Math.abs(gSpeed) > 1) {
                gSpeed += xAxis * 0.5 * friction * this.args.accel * drag * this.args.skidTraction;
              }
            }
            if (!Math.sign(this.args.gSpeed) || Math.sign(this.args.gSpeed) === Math.sign(gSpeed)) {
              if (this.args.pushing && Math.sign(xAxis) !== Math.sign(this.args.pushing)) {
                this.args.gSpeed = 0;
              } else if (!xAxis || Math.abs(gSpeed) < gSpeedMax || Math.sign(gSpeed) !== Math.sign(xAxis)) {
                this.args.gSpeed = gSpeed;
              }
            } else {
              this.args.gSpeed = 0;
              return;
            }
          }
        }
      } else if (this.args.falling && xAxis && Math.abs(this.args.xSpeed) < this.args.xSpeedMax) {
        if (Math.abs(this.args.xSpeed) < this.args.gSpeedMax && !this.args.ignore) {
          this.args.xSpeed += xAxis * this.args.airAccel * drag;
        }

        // const tileMap = this.viewport.tileMap;

        // if(!this.noClip && this.getMapSolidAt(this.x + (this.args.width / 2) * Math.sign(this.args.xSpeed), this.y))
        // {
        // 	this.args.xSpeed = 0;
        // }
      }

      if (xAxis < 0 && (this.args.gSpeed || this.args.stuck) && !this.args.ignore) {
        if (!this.args.climbing) {
          this.args.facing = 'left';
        }
        if (!this.args.grinding || Math.abs(this.args.gSpeed) < 3) {
          this.args.direction = -1;
        }
      }
      if (xAxis > 0 && (this.args.gSpeed || this.args.stuck) && !this.args.ignore) {
        if (!this.args.climbing) {
          this.args.facing = 'right';
        }
        if (!this.args.grinding || Math.abs(this.args.gSpeed) < 3) {
          this.args.direction = 1;
        }
      }
      if (this.args.currentSheild instanceof _StarSheild.StarSheild) {
        return;
      }
      if (this.aAxis < -0.75) {
        if (this.inventory.has(_ElectricSheild.ElectricSheild)) {
          this.args.currentSheild = [...this.inventory.get(_ElectricSheild.ElectricSheild)][0];
        } else {
          this.args.currentSheild = '';
        }
      }
      if (this.aAxis > +0.75) {
        if (this.inventory.has(_FireSheild.FireSheild)) {
          this.args.currentSheild = [...this.inventory.get(_FireSheild.FireSheild)][0];
        } else {
          this.args.currentSheild = '';
        }
      }
      if (this.bAxis < -0.75) {
        if (this.inventory.has(_BubbleSheild.BubbleSheild)) {
          this.args.currentSheild = [...this.inventory.get(_BubbleSheild.BubbleSheild)][0];
        } else {
          this.args.currentSheild = '';
        }
      }
      if (this.bAxis > +0.75) {
        if (this.inventory.has(_NormalSheild.NormalSheild)) {
          this.args.currentSheild = [...this.inventory.get(_NormalSheild.NormalSheild)][0];
        } else {
          this.args.currentSheild = '';
        }
      }
    }
  }, {
    key: "processInputVehicle",
    value: function processInputVehicle() {
      this.args.standingOn.processInputDirect();
    }
  }, {
    key: "collideA",
    value: function collideA(other, type) {
      return this.solid;
    }
  }, {
    key: "collideB",
    value: function collideB(other) {}
  }, {
    key: "castRay",
    value: function castRay() {
      let length = 1;
      let callback = () => {};
      let angle = Math.PI / 2;
      let offset = [0, 0];
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      switch (args.length) {
        case 2:
          length = args[0];
          callback = args[1];
          break;
        case 3:
          length = args[0];
          angle = args[1];
          callback = args[2];
          break;
        case 4:
          length = args[0];
          angle = args[1];
          offset = args[2];
          callback = args[3];
          break;
      }
      let hit = false;
      for (let i = 0; i < Math.floor(length); i++) {
        const x = this.args.x + offset[0] + i * Math.cos(angle);
        const y = this.args.y + offset[1] + i * Math.sin(angle);

        // window.logPoints && window.logPoints(x, y, 'mode-' + this.args.mode);

        const bottom = [x, y];
        const retVal = callback(i, bottom, this);
        if (retVal !== undefined) {
          return retVal;
        }
      }
      return false;
    }
  }, {
    key: "castRayQuick",
    value: function castRayQuick(length, angle) {
      let offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [0, 0];
      let collides = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
      if (!this.viewport || !this.viewport.tileMap) {
        return;
      }
      const thisPointX = this.args.x + offset[0];
      const thisPointY = this.args.y + offset[1];
      const solidPoint = this.viewport.tileMap.castRay(thisPointX, thisPointY, angle, length, this.getCollisionMap());
      let magnitude = length;
      if (solidPoint) {
        magnitude = Math.hypot(thisPointX - solidPoint[0], thisPointY - solidPoint[1]);
      }
      const endPointX = thisPointX + Math.cos(angle) * magnitude;
      const endPointY = thisPointY + Math.sin(angle) * magnitude;
      const actorsAtLine = this.viewport.actorsAtLine(thisPointX, thisPointY, endPointX, endPointY);
      actorsAtLine.delete(_Bindable.Bindable.make(this));
      actorsAtLine.delete(this);
      const collisions = new Map();
      if (collides) {
        for (const _ref11 of actorsAtLine) {
          var _ref12 = _slicedToArray(_ref11, 2);
          const actor = _ref12[0];
          const collision = _ref12[1];
          if (actor.callCollideHandler(this) !== false) {
            collisions.set(actor, collision);
          }
        }
      }
      for (const _ref13 of collisions) {
        var _ref14 = _slicedToArray(_ref13, 2);
        const actor = _ref14[0];
        const collision = _ref14[1];
        if (collision.distance > magnitude) {
          continue;
        }
        if (this.checkSolidActors(actor)) {
          return collision.distance;
        }
      }
      if (solidPoint) {
        return magnitude;
      }
      return false;
    }
  }, {
    key: "impulse",
    value: function impulse(magnitude, direction) {
      let willFall = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      this.impulseMag = magnitude;
      this.impulseDir = direction;
      this.impulseFal = willFall;
    }
  }, {
    key: "rad2deg",
    value: function rad2deg(rad) {
      const deg = 180 / Math.PI * rad;
      if (deg > 0) {
        return Math.round(Math.floor(deg * 10) / 10);
      }
      return Math.round(Math.ceil(deg * 10) / 10);
    }
  }, {
    key: "roundAngle",
    value: function roundAngle(angle, segments) {
      segments /= 2;
      let rAngle = Math.round(angle / (Math.PI / segments)) * Math.PI / segments;
      return rAngle;
    }
  }, {
    key: "findNearestActor",
    value: function findNearestActor(selector, maxDistance) {
      let direction = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      const viewport = this.viewport;
      if (!viewport) {
        return;
      }
      const cells = viewport.getNearbyColCells(this.args.x, this.args.y);
      let closest = null;
      let minDist = Infinity;
      for (const cell of cells) {
        for (const actor of cell) {
          if (actor === this) {
            continue;
          }
          if (actor.args.gone) {
            continue;
          }
          if (!selector(actor)) {
            continue;
          }
          const distance = this.distanceFrom(actor);
          if (Math.abs(distance) > maxDistance) {
            continue;
          }
          if (distance < minDist) {
            closest = actor;
            minDist = distance;
          }
        }
      }
      return closest;

      // const actors = new Map;

      // cells.map(s => s.forEach(a =>{

      // 	if(a === this)
      // 	{
      // 		return;
      // 	}

      // 	if(a.args.gone)
      // 	{
      // 		return;
      // 	}

      // 	if(!selector(a))
      // 	{
      // 		return;
      // 	}

      // 	const distance = this.distanceFrom(a);
      // 	const angle    = Math.atan2(a.y - this.y, a.args.x - this.args.x);

      // 	if(Math.abs(distance) > maxDistance)
      // 	{
      // 		return;
      // 	}

      // 	actors.set(distance, a);
      // }));

      // const distances = [...actors.keys()];
      // const shortest  = Math.min(...distances);

      // const closest = actors.get(shortest);

      // return closest;
    }
  }, {
    key: "immune",
    value: function immune(other) {
      let type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'normal';
      // if(this.args.mercy)
      // {
      // 	return true;
      // }

      const shield = this.args.currentSheild;
      if (shield && shield.immune && shield.immune(this, other, type)) {
        return true;
      }
      return false;
    }
  }, {
    key: "totalCombo",
    value: function totalCombo() {
      let fail = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      if (!this.args.popChain.length) {
        return;
      }
      if (this.eraseCombo) {
        this.eraseCombo();
        this.eraseCombo = false;
      }
      this.args.popCombo = 0;
      let multiply = 0;
      let base = 0;
      for (const pop of this.args.popChain) {
        multiply += pop.multiplier;
        base += pop.points;
      }
      const total = Math.ceil(base * multiply);
      this.args.popChain.length = 0;
      if (!total) {
        this.viewport.args.comboResult = null;
        this.viewport.args.comboFail = null;
        return;
      }
      this.eraseCombo = this.viewport.onFrameOut(360, () => {
        this.viewport.args.comboResult = null;
        this.viewport.args.comboFail = null;
      });
      if (fail) {
        this.viewport.args.comboFail = new _CharacterString.CharacterString({
          value: total,
          color: 'red-light'
        });
        this.viewport.args.comboResult = null;
        return;
      }
      this.viewport.args.comboResult = new _CharacterString.CharacterString({
        value: '+' + total,
        color: 'green-light'
      });
      this.viewport.args.comboFail = null;
      this.args.score += total;
    }
  }, {
    key: "damage",
    value: function damage(other) {
      let type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'normal';
      if (this.args.mercy) {
        return;
      }
      this.dashed = this.args.jumping = this.args.spinning = false;
      const damageEvent = new CustomEvent('damage', {
        cancelable: true,
        detail: {
          other: other,
          type: type
        }
      });
      if (this.isHyper) {
        return;
      }
      if (this.isSuper) {
        this.onNextFrame(() => this.startle(other));
        this.args.mercy = 30;
        return;
      }
      if (!this.immune(other, type)) {
        if (!this.dispatchEvent(damageEvent)) {
          if (!damageEvent.detail.immune) {
            this.args.y -= 8;
            this.onNextFrame(() => this.startle(other));
            this.args.mercy = 180;
            if (this.viewport.settings.rumble) {
              this.controller.rumble({
                duration: 350,
                strongMagnitude: 1.0,
                weakMagnitude: 1.0
              });
            }
            this.totalCombo(true);
            this.lightDashReward = this.grindReward = this.airReward = null;
          }
          return;
        }
      } else {
        return;
      }
      if (this.args.rings) {
        this.loseRings();
        this.args.rings = 0;
        this.onNextFrame(() => this.startle(other));
        this.args.mercy = 180;
        this.totalCombo(true);
        if (this.viewport.settings.rumble) {
          this.controller.rumble({
            duration: 350,
            strongMagnitude: 1.0,
            weakMagnitude: 1.0
          });
          this.onTimeout(350, () => {
            this.controller.rumble({
              duration: 150,
              strongMagnitude: 0.5,
              weakMagnitude: 1.0
            });
          });
        }
      } else if (this.controllable) {
        this.die();
        this.totalCombo(true);
        if (this.viewport.settings.rumble) {
          this.controller.rumble({
            duration: 450,
            strongMagnitude: 1.0,
            weakMagnitude: 1.0
          });
        }
      }
    }
  }, {
    key: "startle",
    value: function startle(other) {
      if (this.noClip || this.args.startled > 30) {
        return;
      }
      const direction = Math.sign(other && (other.args.xSpeed || other.args.x - other.xLast || other.args.x - this.args.x) || this.x - this.xLast || this.args.xSpeed || this.args.gSpeed || this.args.direction);
      this.args.jumping = false;
      this.args.falling = true;
      this.args.startled = 180;
      this.args.ignore = 30;
      this.args.float = 1;
      this.args.xSpeed = -2.25 * direction;
      this.args.ySpeed = -8;
      this.args.x += this.args.xSpeed;
      this.args.flying = false;
      this.args.dashed = false;
      this.args.lightDashed = false;
      this.args.lightDashing = false;
      this.args.gSpeed = 0;
      this.args.standingOn = false;
      if (this.args.mode === MODE_CEILING) {
        this.args.mode = 0;
        this.args.y += this.args.height;
        this.args.ySpeed = 4;
      } else {
        this.args.y -= 4;
      }
    }
  }, {
    key: "checkSolidActors",
    value: function checkSolidActors(x) {
      if (x.args === this.args) {
        return false;
      }
      if (!x.solid) {
        return false;
      }
      if (x.args.platform || x.isVehicle) {
        if (this.args.y <= x.args.y + -x.args.height && this.args.ySpeed >= 0) {
          return true;
        }
        return false;
      }
      return true;
    }

    // findSolid(i, point, actor)
    // {
    // 	if(!actor.viewport)
    // 	{
    // 		return;
    // 	}

    // 	const viewport = actor.viewport;
    // 	const tileMap  = viewport.tileMap;

    // 	const actors = viewport.actorsAtPoint(point[0], point[1]);

    // 	for(const a of actors)
    // 	{
    // 		if(actor.checkSolidActors(a))
    // 		{
    // 			return i;
    // 		}
    // 	}

    // 	const solid = tileMap.getSolid(point[0], point[1], actor.args.layer, Math.sign(this.args.ySpeed));

    // 	if(actor.upScan)
    // 	{
    // 		actor.lastLayer = solid;
    // 	}

    // 	if(solid)
    // 	{
    // 		return i;
    // 	}
    // }

    // findSolidTile(i, point, actor)
    // {
    // 	if(!actor.viewport)
    // 	{
    // 		return;
    // 	}

    // 	const viewport = actor.viewport;
    // 	const tileMap  = viewport.tileMap;

    // 	const solid = tileMap.getSolid(point[0], point[1], actor.args.layer, Math.sign(this.args.ySpeed));

    // 	if(actor.upScan)
    // 	{
    // 		actor.lastLayer = solid;
    // 	}

    // 	if(solid)
    // 	{
    // 		return i;
    // 	}
    // }
  }, {
    key: "scanBottomEdge",
    value: function scanBottomEdge() {
      let direction = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      const tileMap = this.viewport.tileMap;
      const radius = this.args.width / 2;
      const leftCorner = tileMap.getSolid(this.x - radius, this.y + 1, this.args.layer);
      const rightCorner = tileMap.getSolid(this.x + radius, this.y + 1, this.args.layer);
      if (leftCorner && rightCorner) {
        return;
      }
      return this.castRay(this.args.width, -direction < 0 ? Math.PI : 0, [direction * radius, 0], (i, point) => {
        let solids = this.getMapSolidAt(point[0], point[1] + 1);
        if (Array.isArray(solids)) {
          solids = solids.filter(s => s.callCollideHandler(this)).length;
        }
        if (solids) {
          return this.args.width - i;
        }
        // const actors = this.viewport
        // 	.actorsAtPoint(point[0], point[1])
        // 	.filter(a => a.args !== this.args);

        // if(!actors.length && !tileMap.getSolid(point[0], point[1] + 1, this.args.layer))
        // {
        // 	return i;
        // }
      });
    }
  }, {
    key: "realAngle",
    get: function get() {
      const args = this.args;
      if (args.standingOn) {
        return args.standingOn.realAngle;
      }
      if (args.falling) {
        return -args.groundAngle - Math.PI;
      }
      switch (args.mode) {
        case 0:
          return -args.groundAngle - Math.PI;
        case 1:
          return -args.groundAngle - Math.PI / 2;
        case 2:
          return -args.groundAngle;
        case 3:
          return -args.groundAngle + Math.PI / 2;
      }
    }
  }, {
    key: "downAngle",
    get: function get() {
      switch (this.args.mode) {
        case MODE_FLOOR:
          return Math.PI / 2;
          break;
        case MODE_RIGHT:
          return 0;
          break;
        case MODE_CEILING:
          return -Math.PI / 2;
          break;
        case MODE_LEFT:
          return Math.PI;
          break;
      }
    }
  }, {
    key: "upAngle",
    get: function get() {
      switch (this.args.mode) {
        case MODE_FLOOR:
          return -Math.PI / 2;
          break;
        case MODE_RIGHT:
          return Math.PI;
          break;
        case MODE_CEILING:
          return Math.PI / 2;
          break;
        case MODE_LEFT:
          return 0;
          break;
      }
    }
  }, {
    key: "leftAngle",
    get: function get() {
      switch (this.args.mode) {
        case MODE_FLOOR:
          return Math.PI;
          break;
        case MODE_RIGHT:
          return -Math.PI / 2;
          break;
        case MODE_CEILING:
          return 0;
          break;
        case MODE_LEFT:
          return Math.PI / 2;
          break;
      }
    }
  }, {
    key: "rightAngle",
    get: function get() {
      switch (this.args.mode) {
        case MODE_FLOOR:
          return 0;
          break;
        case MODE_RIGHT:
          return Math.PI / 2;
          break;
        case MODE_CEILING:
          return Math.PI;
          break;
        case MODE_LEFT:
          return -Math.PI / 2;
          break;
      }
    }
  }, {
    key: "groundPoint",
    get: function get() {
      switch (this.args.mode) {
        case MODE_FLOOR:
          return [this.args.x + 0, this.args.y + 1];
          break;
        case MODE_RIGHT:
          return [this.args.x + 1, this.args.y + 0];
          break;
        case MODE_CEILING:
          return [this.args.x + 0, this.args.y - 1];
          break;
        case MODE_LEFT:
          return [this.args.x - 1, this.args.y + 0];
          break;
      }
    }
  }, {
    key: "rotatePoint",
    value: function rotatePoint(x, y) {
      const xRot = x * Math.cos(this.realAngle) - y * Math.sin(this.realAngle);
      const yRot = y * Math.cos(this.realAngle) + x * Math.sin(this.realAngle);
      return [xRot, yRot];
    }
  }, {
    key: "standBelow",
    value: function standBelow(other) {}
  }, {
    key: "filterSolidActors",
    value: function filterSolidActors(x) {
      if (x.args === this.args) {
        return false;
      }
      if (!x.solid) {
        return false;
      }
      if (x.args.platform || x.isVehicle) {
        if (this.args.y >= x.args.y && this.args.ySpeed >= 0 && this.args.mode === 2) {
          return true;
        }
        if (this.args.y <= x.args.y + -x.args.height + 1 && this.args.ySpeed >= 0) {
          return true;
        }
        return false;
      }
      return true;
    }
  }, {
    key: "getMapSolidAt",
    value: function getMapSolidAt(x, y) {
      let actors = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      if (!this.viewport) {
        return;
      }
      if (this.screenLock) {
        if (x < this.screenLock.xMin || x > this.screenLock.xMax) {
          return true;
        }
      }
      if (actors) {
        const actors = this.viewport.actorsAtPoint(x, y).filter(this.filterSolidActors.bind(this));
        if (actors.length > 0) {
          return actors;
        }
      }
      const tileMap = this.viewport.tileMap;
      return tileMap.getSolid(x, y, this.getCollisionMap());
    }
  }, {
    key: "canRoll",
    get: function get() {
      return false;
    }
  }, {
    key: "canFly",
    get: function get() {
      return false;
    }
  }, {
    key: "canStick",
    get: function get() {
      return false;
    }
  }, {
    key: "canSpindash",
    get: function get() {
      return false;
    }
  }, {
    key: "isEffect",
    get: function get() {
      return false;
    }
    // get isGhost() { return false; }
  }, {
    key: "isPushable",
    get: function get() {
      return false;
    }
  }, {
    key: "isVehicle",
    get: function get() {
      return false;
    }
  }, {
    key: "solid",
    get: function get() {
      return false;
    }
  }, {
    key: "x",
    get: function get() {
      return this.args.x;
    }
  }, {
    key: "y",
    get: function get() {
      return this.args.y;
    }
  }, {
    key: "point",
    get: function get() {
      return [this.args.x, this.args.y];
    }
  }, {
    key: "rotateLock",
    get: function get() {
      return false;
    }
  }, {
    key: "controllable",
    get: function get() {
      return false;
    }
  }, {
    key: "skidding",
    get: function get() {
      return Math.abs(this.args.gSpeed) && this.args.direction && !this.args.antiSkid && !this.args.grinding && Math.sign(this.args.gSpeed) !== this.args.direction;
    }
  }, {
    key: "effect",
    value: function effect(other) {}
  }, {
    key: "readInput",
    value: function readInput() {
      if (!this.controller) {
        return;
      }
      const controller = this.controller;
      this.xAxis = 0;
      this.yAxis = 0;
      if (!controller.axes) {
        return;
      }
      if (controller.axes[0]) {
        this.xAxis = controller.axes[0].magnitude;
      }
      if (controller.axes[1]) {
        this.yAxis = controller.axes[1].magnitude;
      }

      // if(controller.axes[6] && controller.axes[6].magnitude)
      // {
      // 	this.xAxis = controller.axes[6].magnitude;
      // }
      // else if(controller.axes[0] && controller.axes[0].magnitude)
      // {
      // 	this.xAxis = controller.axes[0].magnitude;
      // }

      // if(controller.axes[7] && controller.axes[7].magnitude)
      // {
      // 	this.yAxis = controller.axes[7].magnitude;
      // }
      // else if(controller.axes[1] && controller.axes[1].magnitude)
      // {
      // 	this.yAxis = controller.axes[1].magnitude;
      // }

      if (0 && controller.axes[7]) {
        if (controller.axes[3]) {
          this.aAxis = controller.axes[3].magnitude;
        }
        if (controller.axes[4]) {
          this.bAxis = controller.axes[4].magnitude;
        }
      } else {
        if (controller.axes[2]) {
          this.aAxis = controller.axes[2].magnitude;
        }
        if (controller.axes[3]) {
          this.bAxis = controller.axes[3].magnitude;
        }
      }
      const buttons = controller.buttons;
      this.buttons = buttons;

      // if(this.args.ignore > 0)
      // {
      // 	this.xAxis = 0;
      // 	this.yAxis = 0;
      // }

      for (const i in buttons) {
        const button = buttons[i];
        const release = `release_${i}`;
        const press = `command_${i}`;
        const hold = `hold_${i}`;
        if (i == 0 && button.delta === 1 && (this.yAxis && this.args.falling || this.args.standingOn && this.args.standingOn.quickDrop) || !this.args.standingOn || !this.args.standingOn.isVehicle) {
          if (button.delta === 1) {
            let cancel = false;
            if (this.args.currentSheild && press in this.args.currentSheild) {
              if (this.args.currentSheild[press](this, button) === false) {
                cancel = true;
              }
            }
            if (!cancel) {
              for (const behavior of [...this.behaviors].reverse()) {
                if (behavior[press]) {
                  if (behavior[press](this, button) === false) {
                    cancel = true;
                    break;
                  }
                }
              }
            }
            if (!cancel) {
              this[press] && this[press](button);
            }
          } else if (button.delta === -1) {
            let cancel = false;
            for (const behavior of this.behaviors) {
              if (behavior[release]) {
                if (behavior[release](this, button) === false) {
                  cancel = true;
                }
              }
            }
            if (!cancel) {
              if (this.args.currentSheild && release in this.args.currentSheild) {
                this.args.currentSheild[release](this, button);
              }
              this[release] && this[release](button);
            }
          } else if (button.active) {
            let cancel = false;
            for (const behavior of this.behaviors) {
              if (behavior[hold]) {
                if (behavior[hold](this, button) === false) {
                  cancel = true;
                }
              }
            }
            if (!cancel) {
              if (this.args.currentSheild && hold in this.args.currentSheild) {
                this.args.currentSheild[hold](this, button);
              }
              this[hold] && this[hold](button);
            }
          }
        } else if (this.args.standingOn && this.args.standingOn.isVehicle) {
          this.args.jumping = false;
          this.args.flying = false;
          const vehicle = this.args.standingOn;
          if (button.delta === 1) {
            vehicle[press] && vehicle[press](button);
            for (const behavior of vehicle.behaviors) {
              if (behavior[press]) {
                behavior[press](vehicle, button);
              }
            }
          } else if (button.delta === -1) {
            vehicle[release] && vehicle[release](button);
            for (const behavior of vehicle.behaviors) {
              if (behavior[release]) {
                behavior[release](vehicle, button);
              }
            }
          } else if (button.active) {
            vehicle[hold] && vehicle[hold](button);
            for (const behavior of vehicle.behaviors) {
              if (behavior[hold]) {
                behavior[hold](vehicle, button);
              }
            }
          }
        }
      }
    }
  }, {
    key: "distanceFrom",
    value: function distanceFrom(_ref15) {
      let x = _ref15.x,
        y = _ref15.y;
      return Math.hypot(this.x - x, this.y - y);
    }
  }, {
    key: "twist",
    value: function twist(warp) {
      if (!this.twister) {
        const filterContainer = this.viewport.tags.bgFilters;
        const html = `<div class = "point-actor-filter twist-filter">`;
        this.twistFilter = new _Tag.Tag(html);
        filterContainer.appendChild(this.twistFilter.node);
        this.twister = new _Twist.Twist({
          id: 'twist-' + this.args.id,
          scale: 60
        });
        this.twister.args.bindTo(['x', 'y', 'width', 'height', 'xOff', 'yOff'], (v, k) => {
          var _this$twistFilter$sty;
          this.twistFilter.style((_this$twistFilter$sty = {}, _defineProperty(_this$twistFilter$sty, `--${k}`, v), _defineProperty(_this$twistFilter$sty, "filter", `url(#twist-${this.args.id})`), _this$twistFilter$sty));
        });
        this.twister.args.yOff = 16;
        this.twister.render(this.twistFilter.node);
        this.onRemove(() => this.twistFilter.remove());
      }
      this.twister.args.scale = warp;
    }
  }, {
    key: "pinch",
    value: function pinch() {
      let warpBg = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      let warpFg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      if (!this.pincherBg) {
        const filterContainer = this.viewport.tags.bgFilters;
        const type = this.args.type.split(' ').shift();
        const html = `<div class = "point-actor-filter pinch-filter">`;
        this.pinchFilterBg = new _Tag.Tag(html);
        filterContainer.appendChild(this.pinchFilterBg.node);
        this.pincherBg = new _Pinch.Pinch({
          id: 'pinch-' + this.args.id,
          scale: 60
        });
        this.pincherBg.args.bindTo(['x', 'y', 'width', 'height', 'xOff', 'yOff'], (v, k) => {
          var _this$pinchFilterBg$s;
          this.pinchFilterBg.style((_this$pinchFilterBg$s = {}, _defineProperty(_this$pinchFilterBg$s, `--${k}`, v), _defineProperty(_this$pinchFilterBg$s, "filter", `url(#pinch-${this.args.id})`), _this$pinchFilterBg$s));
        });
        this.pincherBg.render(this.pinchFilterBg);
        this.onRemove(() => this.pinchFilterBg.remove());
      }
      this.pincherBg.args.scale = warpBg;
    }
  }, {
    key: "droop",
    value: function droop() {
      let warpFactor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      let xPosition = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      let xMax = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      if (xMax === null) {
        xMax = xPosition;
      }
      const half = this.args.width / 2;
      if (!this.drooperFg) {
        this.drooperFg = new _Droop.Droop({
          id: 'droop-' + this.args.id,
          width: this.args.width * 3,
          height: this.args.height * 3,
          scale: 64
        });
        this.args.bindTo(['x', 'y'], (v, k) => {
          this.drooperFg.args[k] = Number(v);
        });
        this.onNextFrame(() => {
          this.drooperFg.args.scale = Number(warpFactor * 2);
          this.sprite.style({
            transform: `translate(-50%, calc(${warpFactor}px + calc(-100% + 1px)))`,
            filter: `url(#droop-${this.args.id})`
          });
          this.drooperFg.args.dx = -xPosition;
        });
        this.drooperFg.render(this.sprite);
        return;
      }
      this.drooperFg.args.scale = Number(warpFactor * 2);
      this.sprite.style({
        transform: `translate(-50%, calc(${warpFactor}px + calc(-100% + 1px)))`,
        filter: `url(#droop-${this.args.id})`
      });
      const droopCenter = 1 - xPosition / half;
      const posFactor = xPosition / this.args.width;
      this.drooperFg.args.droopWidthLeft = `${51 * droopCenter + 1}%`;
      this.drooperFg.args.droopRightStart = `${51 * droopCenter}%`;
      this.drooperFg.args.droopWidthRight = `${102 + -51 * droopCenter}%`;
    }
  }, {
    key: "crossRegionBoundary",
    value: function crossRegionBoundary(region) {
      if (!region || this.args.static) {
        return;
      }

      // const drag = region.args.drag;

      // this.args.xSpeed *= drag;
      // this.args.ySpeed *= drag;
      // this.args.gSpeed *= drag;

      if (this.viewport) {
        const viewport = this.viewport;
        if (!this.args.gone && this.args.moving && Math.abs(this.args.y - (region.args.y + -region.args.height)) <= Math.abs(this.args.ySpeed || this.args.gSpeed) && region.entryParticle) {
          const splash = new _Tag.Tag(region.entryParticle);
          if (splash.node) {
            splash.age = 0;
            splash.x = this.args.x;
            splash.style({
              '--x': this.args.x,
              '--y': region.args.y + -region.args.height + -8,
              'z-index': 5,
              opacity: Math.random,
              '--particleScale': this.args.particleScale,
              '--time': 320
            });
            this.splashes.add(splash);
            viewport.particles.add(splash);
            viewport.onFrameOut(20, () => {
              splash.node && viewport.particles.remove(splash);
              this.splashes.delete(splash);
            });
          }
        }
      }
    }
  }, {
    key: "die",
    value: function die() {
      if (this.args.dead) {
        return;
      }
      this.viewport.args.inventory.splice(0);
      this.args.currentSheild = null;
      this.totalCombo(true);
      this.args.groundAngle = 0;
      this.args.ySpeed = 0;
      this.args.xSpeed = 0;
      this.args.jumping = false;
      this.args.falling = true;
      this.args.ignore = -1;
      this.args.mercy = 0;
      this.args.float = 0;
      this.args.rings = 0;
      this.args.standingLayer = null;
      this.args.standingOn = null;
      this.lastLayer = null;
      this.args.dead = true;
      this.noClip = true;
      this.args.ySpeed = -12;
      this.focused = this.cofocused = null;
      if (this.y > this.viewport.meta.deathLine) {
        this.args.ySpeed = -14;
      }
      this.args.xSpeed = 0;

      // this.onNextFrame(()=>{
      // 	this.args.ySpeed = -8;
      // 	this.args.xSpeed = 0;
      // });

      this.viewport.onFrameOut(120, () => {
        if (!this.args.dead) {
          return;
        }
        this.respawn();
      });
    }
  }, {
    key: "respawn",
    value: function respawn() {
      if (!this.viewport) {
        return;
      }
      this.screenLock = null;
      this.args.xSpeed = 0;
      this.args.ySpeed = 0;
      this.args.gSpeed = 0;
      this.args.respawning = true;
      this.args.display = 'none';
      this.args.x = -this.viewport.args.x;
      this.args.y = -this.viewport.args.y;
      this.args.standingLayer = null;
      this.args.standingOn = null;
      this.lastLayer = null;
    }
  }, {
    key: "sleep",
    value: function sleep() {}
  }, {
    key: "wakeUp",
    value: function wakeUp() {}
  }, {
    key: "urlWrap",
    value: function urlWrap(url) {
      return `url(${url})`;
    }
  }, {
    key: "facePoint",
    get: function get() {
      return this.rotatePoint(-5 * this.args.direction, -14 + this.args.height);
    }
  }, {
    key: "registerDebug",
    value: function registerDebug(name) {
      window[name] = this;
    }
  }, {
    key: "loseRings",
    value: function loseRings() {
      let count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      let age = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      const Ring = this.viewport.objectPalette['ring'];
      this.spawnRings = this.spawnRings || 0;
      const maxSpawn = count || Math.min(this.args.rings, 16);
      let current = 0;
      const toSpawn = maxSpawn - this.spawnRings;
      const circles = Math.floor(maxSpawn / 8);
      this.viewport.onFrameOut(4, () => {
        while (this.spawnRings < maxSpawn) {
          const ring = new Ring();
          const circle = Math.ceil(current / 8);
          const angle = current % 8 * (Math.PI / 4) + Math.PI / 4;
          const radius = 1 * circle;
          const cos = Math.cos(angle);
          const sin = Math.sin(angle);
          ring.args.x = this.x - cos * (circle * 8);
          ring.args.y = this.y - sin * (circle * 8) - this.args.height / 4;
          ring.args.xSpeed = 0;
          ring.args.ySpeed = 0;
          ring.noClip = true;
          ring.args.static = false;
          ring.args.float = 18;
          ring.args.ignore = 30;
          ring.args.width = 16;
          ring.args.height = 16;
          ring.dropped = true;
          this.viewport.onFrameOut((1 + circle) * 2, () => {
            this.viewport.spawn.add({
              object: ring
            });
          });
          this.spawnRings++;
          current++;

          // ring.args.xSpeed = this.args.xSpeed || this.args.gSpeed;
          // ring.args.ySpeed = this.args.ySpeed;

          this.viewport.onFrameOut(circle * 2 + 6, () => {
            ring.args.xSpeed += -cos * 3;
            ring.args.ySpeed += -sin * 3;
            ring.args.ySpeed += -(circle + 1) * 0.75;
          });
          if (current % 3 === 2) {
            ring.args.decoration = true;
            ring.noClip = true;
            this.viewport.onFrameOut(100, () => {
              this.viewport.actors.remove(ring);
              if (this.spawnRings > 0) {
                this.spawnRings--;
              }
            });
          } else {
            ring.args.decoration = false;
            ring.noClip = false;
            this.viewport.onFrameOut(age || 360 - current % 5 * 35, () => {
              this.viewport.actors.remove(ring);
              if (this.spawnRings > 0) {
                this.spawnRings--;
              }
            });
          }
        }
      });
    }
  }, {
    key: "collect",
    value: function collect(pickup) {
      if (pickup.dropped) {
        if (this.spawnRings) {
          this.spawnRings--;
        }
        pickup.dropped = false;
      }
    }
  }, {
    key: "angleTo",
    value: function angleTo(actor) {
      return Math.atan2(this.y - actor.y, this.x - actor.x);
    }
  }, {
    key: "distanceTo",
    value: function distanceTo(actor) {
      return Math.hypot(this.y - actor.y, this.x - actor.x);
      // return Math.sqrt((this.y - actor.y)**2 + (this.x - actor.x)**2);
    }
  }, {
    key: "canSee",
    value: function canSee(actor) {
      const cast = this.castRayQuick(this.distanceTo(actor), actor.angleTo({
        x: this.args.x,
        y: this.args.y - this.args.height
      }), [0, -this.args.height], false);
      if (cast === false) {
        return true;
      }
    }
  }, {
    key: "setTile",
    value: function setTile() {
      const tileMap = this.viewport.tileMap;
      tileMap.ready.then(event => {
        const tile = tileMap.getTile(this.args.tileId - 1);
        if (!tile) {
          return;
        }
        this.args.spriteX = tile[0];
        this.args.spriteY = tile[1];
        this.args.spriteSheet = tile[2] || this.args.spriteSheet;
      });
    }
  }, {
    key: "halt",
    value: function halt(frameOut) {
      const hSpeed = this.args.hSpeed = this.args.gSpeed;
      this.args.gSpeed = 0;
      this.viewport.onFrameOut(frameOut, () => {
        this.args.gSpeed = hSpeed;
        this.args.hSpeed = 0;
      });
    }
  }, {
    key: "setAutoAttr",
    value: function setAutoAttr(property, attribute) {
      const attrMap = this.autoAttr.get(this.box);
      attrMap[attribute] = property;
    }
  }, {
    key: "invoke",
    value: function invoke(methodName) {
      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }
      this.behaviors.forEach(b => {
        if (typeof b[methodName] !== 'function') {
          return;
        }
        b[methodName](this, ...args);
      });
    }
  }, {
    key: "bMap",
    value: function bMap(methodName) {
      const result = new Map();
      for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
        args[_key3 - 1] = arguments[_key3];
      }
      for (const b of this.behaviors) {
        if (typeof b[methodName] !== 'function') {
          continue;
        }
        result.set(b.constructor, b[methodName](this, ...args));
      }
      return result;
    }
  }, {
    key: "getBoundingLines",
    value: function getBoundingLines() {
      if (this[BOUNDS]) {
        return this[BOUNDS];
      }
      let bounds, left, right, top, bottom;
      switch (this.args.mode) {
        case MODE_FLOOR:
          left = this.args.x - (this.isRegion ? 0 : this.args.width / 2);
          right = this.args.x + (this.isRegion ? this.args.width : this.args.width / 2);
          top = this.args.y - this.args.height;
          bottom = this.args.y;
          bounds = [[right, top, right, bottom], [left, top, left, bottom], [right, top, left, top], [right, bottom, left, bottom]];
          break;
        case MODE_CEILING:
          left = this.args.x - this.args.width / 2;
          right = this.args.x + this.args.width / 2;
          top = this.args.y;
          bottom = this.args.y + this.args.height;
          bounds = [[right, top, right, bottom], [left, top, left, bottom], [right, top, left, top], [right, bottom, left, bottom]];
          break;
        case MODE_LEFT:
          left = this.args.x;
          right = this.args.x + this.args.height;
          top = this.args.y - this.args.width / 2;
          bottom = this.args.y + this.args.width / 2;
          bounds = [[right, top, right, bottom], [left, top, left, bottom], [right, top, left, top], [right, bottom, left, bottom]];
          break;
        case MODE_RIGHT:
          left = this.args.x - this.args.height;
          right = this.args.x;
          top = this.args.y - this.args.width / 2;
          bottom = this.args.y + this.args.width / 2;
          bounds = [[right, top, right, bottom], [left, top, left, bottom], [right, top, left, top], [right, bottom, left, bottom]];
          break;
      }
      Object.freeze(bounds);
      return this[BOUNDS] = bounds;
    }
  }, {
    key: "filterSolids",
    value: function filterSolids(a) {
      return a.args !== this.args && a.callCollideHandler(this) && a.solid;
    }
  }, {
    key: "onSpawned",
    value: function onSpawned(viewport) {
      for (const behavior of this.behaviors) {
        behavior.onSpawned && behavior.onSpawned(this, viewport);
      }
    }
  }, {
    key: "onDespawned",
    value: function onDespawned(viewport) {
      for (const behavior of this.behaviors) {
        behavior.onDespawned && behavior.onDespawned(this, viewport);
      }
    }
  }, {
    key: "getCollisionMap",
    value: function getCollisionMap() {
      if (!this.collisionMap) {
        this.collisionMap = this.viewport.tileMap.getCollisionMap();
      }
      for (const layer of this.collisionMap.keys()) {
        if (layer.name === 'Collision 0') {
          this.collisionMap.set(layer, true);
        } else if (layer.name === 'Collision ' + this.args.layer) {
          this.collisionMap.set(layer, true);
        } else if (layer.name.substr(0, 4) === 'Door') {
          if (this.doorMap.has(layer.index)) {
            this.collisionMap.set(layer, this.doorMap.get(layer.index));
          }
        } else if (layer.name.substr(0, 8) === 'Platform' || layer.name.substr(0, 8) === 'Grinding') {
          if (this.args.ySpeed >= 0) {
            this.collisionMap.set(layer, true);
            if (this.viewport.tileMap.getSolid(this.args.x + 16, this.args.y + -16, layer.index) && this.viewport.tileMap.getSolid(this.args.x - 16, this.args.y + -16, layer.index)) {
              this.collisionMap.set(layer, false);
            }
          } else {
            this.collisionMap.set(layer, false);
          }
          if (layer.layer && layer.layer.meta.vertical) {
            if (!this.args.xSpeed || Math.sign(layer.layer.meta.vertical) === Math.sign(this.args.xSpeed)) {
              this.collisionMap.set(layer, true);
            }
          }
        } else if (layer.name.substr(0, 8) === 'Grinding') {
          this.collisionMap.set(layer, true);
        } else if (layer.name.substr(0, 6) === 'Moving' && !layer.name.substr(0, 10) === 'Moving Art') {
          this.collisionMap.set(layer, true);
        } else {
          this.collisionMap.set(layer, false);
        }
      }
      return this.collisionMap;
    }
  }, {
    key: "command_0",
    value: function command_0() {}
  }, {
    key: "command_1",
    value: function command_1() {}
  }], [{
    key: "fromDef",
    value:
    // ringDoc = new DocumentFragment;

    function fromDef(objDef) {
      var _instance$float;
      const objArgs = {
        x: objDef.x + Math.floor(objDef.width / 2),
        y: objDef.y - 1
        // , z:       objDef.id
        ,
        visible: objDef.visible,
        name: objDef.name,
        id: objDef.id
      };
      const def = new Map();
      for (const i in objArgs) {
        if (_typeof(objArgs[i]) === 'object') {
          continue;
        }
        def.set(i, objArgs[i]);
      }
      const others = {};
      for (const i in objDef.properties) {
        const property = objDef.properties[i];
        if (objDef.properties[i].type === 'object') {
          others[property.name] = property.value;
          // continue;
        }

        objArgs[property.name] = property.value;
        def.set(property.name, property.value);
      }
      objArgs.tileId = objDef.gid;
      const instance = new this(Object.assign({}, objArgs));
      instance.others = others;
      instance.def = def;
      instance.objDef = objDef;
      instance.args.float = (_instance$float = instance.float) !== null && _instance$float !== void 0 ? _instance$float : instance.args.float;
      return instance;
    }
  }]);
  return PointActor;
}(_View2.View);
exports.PointActor = PointActor;
_defineProperty(PointActor, "lastClick", 0);
});

;require.register("actor/PowerupGlow.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PowerupGlow = void 0;
var _PointActor2 = require("./PointActor");
var _Tag = require("curvature/base/Tag");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let PowerupGlow = /*#__PURE__*/function (_PointActor) {
  _inherits(PowerupGlow, _PointActor);
  var _super = _createSuper(PowerupGlow);
  function PowerupGlow() {
    var _this;
    _classCallCheck(this, PowerupGlow);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.type = 'actor-item actor-powerup-glow';
    _this.args.width = 64;
    _this.args.height = 64;
    return _this;
  }
  _createClass(PowerupGlow, [{
    key: "onRendered",
    value: function onRendered(event) {
      _get(_getPrototypeOf(PowerupGlow.prototype), "onRendered", this).call(this, event);
      this.autoAttr.get(this.box)['data-closed'] = 'closed';
      this.icon = new _Tag.Tag('<div class = "powerup-icon">');
      this.halo = new _Tag.Tag('<div class = "powerup-halo">');
      this.tags.sprite.appendChild(this.icon.node);
      this.box.appendChild(this.halo.node);
    }
  }, {
    key: "collideA",
    value: function collideA(other) {
      _get(_getPrototypeOf(PowerupGlow.prototype), "collideA", this).call(this, other);
      if (!other.controllable) {
        return;
      }
      this.onTimeout(125, () => this.args.closed = 'closed');
      this.onTimeout(4500, () => this.args.closed = '');
    }
  }, {
    key: "canStick",
    get: function get() {
      return false;
    }
  }, {
    key: "solid",
    get: function get() {
      return false;
    }
  }, {
    key: "isEffect",
    get: function get() {
      return true;
    }
  }]);
  return PowerupGlow;
}(_PointActor2.PointActor);
exports.PowerupGlow = PowerupGlow;
});

;require.register("actor/Projectile.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Projectile = void 0;
var _PointActor2 = require("./PointActor");
var _Platformer = require("../behavior/Platformer");
var _Marker = require("../actor/Marker");
var _Explosion = require("../actor/Explosion");
var _Tag = require("curvature/base/Tag");
var _Region = require("../region/Region");
var _Spring = require("./Spring");
var _BreakableBlock = require("./BreakableBlock");
var _Block = require("./Block");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
// import { StarPost } from './StarPost';
let Projectile = /*#__PURE__*/function (_PointActor) {
  _inherits(Projectile, _PointActor);
  var _super = _createSuper(Projectile);
  function Projectile() {
    var _this$args$damageType;
    var _this;
    let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let parent = arguments.length > 1 ? arguments[1] : undefined;
    _classCallCheck(this, Projectile);
    const gravity = args.gravity;
    _this = _super.call(this, args, parent);
    _this.args.type = 'actor-item actor-projectile';
    if (_this.args.subType) {
      _this.args.type = _this.args.type + ' ' + _this.args.subType;
    }
    _this.args.damageType = (_this$args$damageType = _this.args.damageType) !== null && _this$args$damageType !== void 0 ? _this$args$damageType : 'normal';
    _this.behaviors.add(new _Platformer.Platformer());
    _this.args.width = 8;
    _this.args.height = 8;
    _this.args.strength = _this.args.strength || 1;
    _this.args.gravity = gravity !== null && gravity !== void 0 ? gravity : 0.15;
    _this.removeTimer = null;
    _this.noClip = true;
    _this.deflected = false;
    return _this;
  }
  _createClass(Projectile, [{
    key: "update",
    value: function update() {
      if (this.removed || !this.viewport) {
        return;
      }
      if (!this.args.falling) {
        this.args.gSpeed = 0;
        this.args.xSpeed = 0;
        this.args.ySpeed = 0;
      }
      _get(_getPrototypeOf(Projectile.prototype), "update", this).call(this);
      if (!this.args.xSpeed && !this.args.ySpeed && this.age > 1) {
        this.explode();
      }
      if (this.viewport && !this.removeTimer) {
        this.removeTimer = this.viewport.onFrameOut(200, () => this.explode());
      }
    }
  }, {
    key: "collideA",
    value: function collideA(other) {
      if (other instanceof Projectile) {
        return;
      }
      if (other === this.args.owner || other instanceof _Region.Region || other instanceof _Spring.Spring) {
        return false;
      }
      if (!(other instanceof _Marker.Marker) && !this.args.owner.controllable && !other.controllable) {
        return;
      }
      if (this.args.strength <= 1 && other instanceof _BreakableBlock.BreakableBlock) {
        return false;
      }
      if (other.args.gone || this.deflected) {
        return false;
      }
      if (other instanceof _Marker.Marker || other.args.currentSheild && other.args.currentSheild.immune(other, this, 'projectile')) {
        this.args.xSpeed *= -1;
        this.args.ySpeed *= -1;
        this.deflected = true;
        return;
      }
      if (!other.solid && !other.controllable) {
        return false;
      }
      this.args.xSpeed = 0;
      this.args.ySpeed = 0;
      this.args.float = -1;
      if (this.args.owner && !this.args.owner.args.gone) {
        (other.controllable || other instanceof _BreakableBlock.BreakableBlock) && other.damage(this, this.args.damageType);
      }

      // this.args.x += Math.cos(this.args.angle) * (other.args.width / 2) * Math.sign(this.args.xSpeed);
      // this.args.y += Math.sin(this.args.angle) * (other.args.width / 2) * Math.sign(this.args.xSpeed);

      this.explode();
      return false;
    }
  }, {
    key: "explode",
    value: function explode() {
      const viewport = this.viewport;
      if (!viewport) {
        return;
      }
      const particle = new _Tag.Tag('<div class = "particle-explosion">');
      particle.style({
        '--x': this.x,
        '--y': this.y
      });
      viewport.particles.add(particle);
      this.viewport.onFrameOut(20, () => viewport.particles.remove(particle));
      this.viewport.actors.remove(this);
      this.remove();
    }
  }, {
    key: "canStick",
    get: function get() {
      return false;
    }
  }, {
    key: "solid",
    get: function get() {
      return false;
    }
  }]);
  return Projectile;
}(_PointActor2.PointActor);
exports.Projectile = Projectile;
});

;require.register("actor/PropellerPlatform.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PropellerPlatform = void 0;
var _Block2 = require("./Block");
var _Sfx = require("../audio/Sfx");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let PropellerPlatform = /*#__PURE__*/function (_Block) {
  _inherits(PropellerPlatform, _Block);
  var _super = _createSuper(PropellerPlatform);
  function PropellerPlatform() {
    var _this$args$maxClimb;
    var _this;
    _classCallCheck(this, PropellerPlatform);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.maxClimb = (_this$args$maxClimb = _this.args.maxClimb) !== null && _this$args$maxClimb !== void 0 ? _this$args$maxClimb : 256;
    _this.args.width = 64;
    _this.args.height = 53;
    _this.args.platform = 1;
    _this.args.type = 'actor-item actor-propeller-platform';
    _this.args.static = 0;
    _this.args.gravity = 0.20;
    _this.args.spinning = 0;
    _this.args.bouncing = 0;
    return _this;
  }
  _createClass(PropellerPlatform, [{
    key: "onRendered",
    value: function onRendered() {
      _get(_getPrototypeOf(PropellerPlatform.prototype), "onRendered", this).call(this);
      this.autoAttr.get(this.box)['data-spinning'] = 'spinning';
      this.autoAttr.get(this.box)['data-bouncing'] = 'bouncing';
    }
  }, {
    key: "update",
    value: function update() {
      this.args.cameraBias = -0.2;
      if (this.args.spinning > 0) {
        this.args.spinning--;
      } else {
        this.args.spinning = 0;
      }
      if (this.args.bouncing > 0) {
        this.args.bouncing--;
      } else {
        this.args.bouncing = 0;
      }
      const maxClimb = this.originalY + -this.args.maxClimb;
      if (this.args.y > this.originalY) {
        this.args.y = this.originalY;
        this.args.ySpeed = 0;
        this.args.float = -1;
      }
      if (this.args.y < maxClimb) {
        this.args.float = 30;
        this.args.y = maxClimb;
        this.args.ySpeed = Math.max(0, this.args.ySpeed);
      }
      _get(_getPrototypeOf(PropellerPlatform.prototype), "update", this).call(this);
    }
  }, {
    key: "collideA",
    value: function collideA(other, type) {
      if (other.args.static) {
        return;
      }
      if (other.args.falling && other.args.y > this.args.y + -this.args.height && other.args.y < this.args.y + -(this.args.height * 0.75)) {
        other.args.y = this.args.y + -this.args.height + this.args.ySpeed + 3;
        return _get(_getPrototypeOf(PropellerPlatform.prototype), "collideA", this).call(this, other, type);
      }
      if (!other.args.falling || other.args.ySpeed < 0) {
        return _get(_getPrototypeOf(PropellerPlatform.prototype), "collideA", this).call(this, other, type);
      }

      // if(!other.controllable)
      // {
      // 	return super.collideA(other, type);
      // }

      this.args.ySpeed += Math.min(-4, -Math.abs(other.args.ySpeed) * 0.5);
      this.args.float = 10;
      this.args.spinning = 30;
      this.args.bouncing = 10;
      other.args.xSpeed *= 0.5;
      other.doubleSpin = false;
      if (other.dashed) {
        other.dashed = false;
        other.args.xSpeed = 0;
        other.args.ySpeed = -other.args.airSpeed;
        other.args.ySpeed *= 1.25;
        this.args.ySpeed *= 1.75;
      } else {
        if (other.args.ySpeed > 0) {
          other.args.ySpeed = Math.min(-4, Math.max(-6, -Math.abs(other.args.ySpeed)));
          other.args.ySpeed += this.args.ySpeed;
        }
        if (other.args.ySpeed > this.args.ySpeed) {
          other.args.ySpeed = this.args.ySpeed + -6;
        }
      }
      _Sfx.Sfx.play('PROP_PLAT');
      this.args.y--;
      this.args.falling = true;
      if (other.args.animation === 'airdash') {
        other.args.animation = 'flip';
      }
      return _get(_getPrototypeOf(PropellerPlatform.prototype), "collideA", this).call(this, other, type);
    }
  }]);
  return PropellerPlatform;
}(_Block2.Block);
exports.PropellerPlatform = PropellerPlatform;
});

;require.register("actor/Pulley.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Pulley = void 0;
var _PointActor2 = require("./PointActor");
var _Ring = require("./Ring");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let Pulley = /*#__PURE__*/function (_PointActor) {
  _inherits(Pulley, _PointActor);
  var _super = _createSuper(Pulley);
  function Pulley() {
    var _this;
    _classCallCheck(this, Pulley);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.width = 64;
    _this.args.height = 64;
    _this.args.type = 'actor-item actor-pulley';
    _this.args.convey = 0;
    _this.args.conveyed = 0;
    _this.args.float = -1;
    _this.noClip = true;
    return _this;
  }
  _createClass(Pulley, [{
    key: "update",
    value: function update() {
      if (this.match) {
        this.args.convey = -this.match.args.convey;
      } else {
        this.match = this.viewport.actorsById[this.args.match];
      }
      this.box && this.box.style({
        '--convey': Math.abs(this.args.convey)
      });
      this.box && this.box.style({
        '--conveyDir': Math.sign(this.args.convey)
      });
      this.args.conveyed += this.match.args.convey;
      this.box && this.box.style({
        '--conveyed': this.args.conveyed
      });

      // if(Math.abs(this.args.convey) > 10
      // 	&& Math.sign(this.args.convey) === this.args.reward
      // 	&& this.viewport.args.frameId % 60 === 0
      // ){
      // 	const ring = new Ring({
      // 		static:   false
      // 		, float:  10
      // 		, ySpeed: 1
      // 		, x:this.x
      // 		, y:this.y - 192,

      // 	});

      // 	ring.scattered = true;
      // 	ring.noClip = false;

      // 	this.viewport.spawn.add({object: ring});

      // 	this.viewport.onFrameOut(100, () => {
      // 		this.viewport.actors.remove(ring);
      // 	});
      // }

      // super.update();
    }
  }, {
    key: "isEffect",
    get: function get() {
      return true;
    }
  }]);
  return Pulley;
}(_PointActor2.PointActor);
exports.Pulley = Pulley;
});

;require.register("actor/PulleySmall.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PulleySmall = void 0;
var _Pulley2 = require("./Pulley");
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let PulleySmall = /*#__PURE__*/function (_Pulley) {
  _inherits(PulleySmall, _Pulley);
  var _super = _createSuper(PulleySmall);
  function PulleySmall() {
    var _this;
    _classCallCheck(this, PulleySmall);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.width = 32;
    _this.args.height = 32;
    _this.args.type = 'actor-item actor-pulley-small';
    _this.args.convey = 0;
    _this.args.float = -1;
    _this.noClip = true;
    return _this;
  }
  return _createClass(PulleySmall);
}(_Pulley2.Pulley);
exports.PulleySmall = PulleySmall;
});

;require.register("actor/Pumpkin.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Pumpkin = void 0;
var _PointActor2 = require("./PointActor");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let Pumpkin = /*#__PURE__*/function (_PointActor) {
  _inherits(Pumpkin, _PointActor);
  var _super = _createSuper(Pumpkin);
  function Pumpkin() {
    var _this$args$face;
    var _this;
    _classCallCheck(this, Pumpkin);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.face = (_this$args$face = _this.args.face) !== null && _this$args$face !== void 0 ? _this$args$face : false;
    _this.args.width = 17;
    _this.args.height = 15;
    _this.args.type = 'actor-item actor-pumpkin';
    _this.bindTo('carriedBy', carrier => {
      if (_this.cX) {
        _this.cX();
        _this.cX = null;
      }
      if (_this.cY) {
        _this.cY();
        _this.cY = null;
      }
      if (carrier) {
        _this.cX = carrier.args.bindTo('x', v => _this.args.x = v + carrier.args.direction * 8);
        _this.cY = carrier.args.bindTo('y', v => _this.args.y = v + -16);
        carrier.carrying.add(_assertThisInitialized(_this));
        _this.args.float = -1;
      } else if (_this.carriedBy) {
        const carrier = _this.carriedBy;
        _this.carriedBy = null;
        _this.args.xSpeed = carrier.args.xSpeed;
        _this.args.ySpeed = carrier.args.ySpeed;
        _this.args.xSpeed += Math.sign(carrier.args.gSpeed || carrier.args.xSpeed) * 4;
        _this.args.ySpeed -= 4;
        carrier.carrying.delete(_assertThisInitialized(_this));
        _this.args.falling = true;
        _this.args.float = 0;
      }
    });
    return _this;
  }
  _createClass(Pumpkin, [{
    key: "onRendered",
    value: function onRendered() {
      _get(_getPrototypeOf(Pumpkin.prototype), "onRendered", this).call(this);
      this.autoAttr.get(this.box)['data-face'] = 'face';
    }
  }, {
    key: "lift",
    value: function lift(actor) {
      if (this.carriedBy === actor) {
        this.carriedBy = null;
        return;
      }
      this.carriedBy = actor;
    }
  }, {
    key: "solid",
    get: function get() {
      return false;
    }
  }]);
  return Pumpkin;
}(_PointActor2.PointActor);
exports.Pumpkin = Pumpkin;
});

;require.register("actor/QuestionBlock.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.QuestionBlock = void 0;
var _PointActor2 = require("./PointActor");
var _RingMonitor = require("./monitor/RingMonitor");
var _SheildWaterMonitor = require("./monitor/SheildWaterMonitor");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let QuestionBlock = /*#__PURE__*/function (_PointActor) {
  _inherits(QuestionBlock, _PointActor);
  var _super = _createSuper(QuestionBlock);
  function QuestionBlock() {
    var _this;
    _classCallCheck(this, QuestionBlock);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _defineProperty(_assertThisInitialized(_this), "maxBounce", 4);
    _defineProperty(_assertThisInitialized(_this), "float", -1);
    _defineProperty(_assertThisInitialized(_this), "template", `<div
		class = "point-actor [[type]] [[collType]]"
		style = "
			display:[[display]];
			--angle:[[angle]];
			--airAngle:[[airAngle]];
			--display-angle:[[_angle]];
			--height:[[height]];
			--width:[[width]];
			--x:[[x]];
			--y:[[y]];
		"
		data-colliding = "[[colliding]]"
		data-falling   = "[[falling]]"
		data-facing    = "[[facing]]"
		data-angle     = "[[angle|rad2deg]]"
		data-mode      = "[[mode]]"
		data-empty     = "[[empty]]"
		cv-ref = "box"
	><div cv-ref = "sprite" class = "sprite"></div></div>`);
    _this.args.type = 'actor-question-block actor-item';
    _this.args.width = 32;
    _this.args.height = 32;
    _this.initY = null;
    _this.empty = false;
    return _this;
  }
  _createClass(QuestionBlock, [{
    key: "collideA",
    value: function collideA(other, type) {
      _get(_getPrototypeOf(QuestionBlock.prototype), "collideA", this).call(this, other);
      if (this.initY === null) {
        this.initY = this.y;
      }
      if (type === 2) {
        const impulse = Math.abs(other.args.ySpeed);
        other.args.falling = true;
        if (other.args.ySpeed > 0) {
          other.args.ySpeed += this.args.ySpeed;
        } else {
          this.args.y -= impulse;
          other.args.y += impulse;
        }
        if (this.args.ySpeed > 0 && this.args.ySpeed > other.args.ySpeed) {
          other.args.ySpeed = Math.abs(other.args.ySpeed);
          other.args.y += this.args.ySpeed;
        }
        if (this.args.ySpeed < 0) {
          this.args.ySpeed = -Math.abs(this.args.ySpeed);
        }
        if (this.args.ySpeed) {
          return true;
        }
        const ySpeedMax = this.maxBounce;
        let speed = type === 2 ? -Math.abs(other.args.ySpeed) : other.args.ySpeed;
        if (Math.abs(speed) > ySpeedMax) {
          speed = ySpeedMax * Math.sign(speed);
        }
        this.args.ySpeed = speed;
        other.args.ySpeed = -other.args.ySpeed;
      }
      if (type === 2 && !this.args.empty) {
        if (!this.args.empty) {
          const monitor = new _SheildWaterMonitor.SheildWaterMonitor({
            x: this.x,
            y: this.y - 96
          });
          this.viewport.spawn.add({
            object: monitor
          });
          monitor.onRemove(() => this.args.empty = false);
          this.args.empty = true;
        }
      }
      return true;
    }
  }, {
    key: "update",
    value: function update() {
      if (this.initY !== null) {
        if (this.initY > this.y) {
          this.args.ySpeed += 0.75;
        } else if (this.initY < this.y) {
          this.args.ySpeed -= 0.75;
        }
        if (Math.abs(this.args.y - this.initY) < 1 && Math.abs(this.args.ySpeed) < 1) {
          this.args.ySpeed = 0;
          this.args.y = this.initY;
        }
      }
      this.args.ySpeed *= 0.9;
      this.args.ySpeed = Math.floor(this.args.ySpeed * 100) / 100;
      this.args.y = Math.round(this.args.y);
      const ySpeedMax = this.maxBounce;
      if (Math.abs(this.args.ySpeed) > ySpeedMax) {
        this.args.ySpeed = ySpeedMax * Math.sign(this.args.ySpeed);
      }
      _get(_getPrototypeOf(QuestionBlock.prototype), "update", this).call(this);
    }
  }, {
    key: "canStick",
    get: function get() {
      return false;
    }
  }, {
    key: "solid",
    get: function get() {
      return true;
    }
  }], [{
    key: "fromDef",
    value: function fromDef(objDef) {
      const obj = _get(_getPrototypeOf(QuestionBlock), "fromDef", this).call(this, objDef);
      obj.args.x = obj.originalX = objDef.x + Math.floor(objDef.width / 2);
      obj.args.y = obj.originalY = objDef.y;
      return obj;
    }
  }]);
  return QuestionBlock;
}(_PointActor2.PointActor);
exports.QuestionBlock = QuestionBlock;
});

;require.register("actor/RailCar.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RailCar = void 0;
var _Vehicle2 = require("./Vehicle");
var _Tag = require("curvature/base/Tag");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let RailCar = /*#__PURE__*/function (_Vehicle) {
  _inherits(RailCar, _Vehicle);
  var _super = _createSuper(RailCar);
  function RailCar() {
    var _this;
    _classCallCheck(this, RailCar);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.type = 'actor-item actor-rail-car';
    _this.args.width = 32;
    _this.args.height = 48;
    _this.removeTimer = null;
    _this.args.cartSpeed = _this.args.cartSpeed || 15;
    _this.args.gSpeedMax = 20;
    _this.args.decel = 0.00;
    _this.args.accel = 0.75;
    _this.args.gravity = 1;
    // this.args.ignore    = -1;

    _this.args.seatHeight = 44;
    _this.args.skidTraction = 0.05;
    _this.args.jumpForce = 12;
    _this.dustCount = 0;
    _this.args.particleScale = 2;
    _this.args.started = false;
    return _this;
  }
  _createClass(RailCar, [{
    key: "onRendered",
    value: function onRendered(event) {
      _get(_getPrototypeOf(RailCar.prototype), "onRendered", this).call(this, event);
      this.box = this.findTag('div');
      this.sprite = this.findTag('div.sprite');
      this.frontWheel = new _Tag.Tag('<div class = "rail-car-wheel rail-car-wheel-front">');
      this.backWheel = new _Tag.Tag('<div class = "rail-car-wheel rail-car-wheel-back">');
      this.frontFrag = new _Tag.Tag('<div class = "rail-car-frag rail-car-frag-front">');
      this.backFrag = new _Tag.Tag('<div class = "rail-car-frag rail-car-frag-back">');
      this.sprite.appendChild(this.frontWheel.node);
      this.sprite.appendChild(this.backWheel.node);
      this.sprite.appendChild(this.frontFrag.node);
      this.sprite.appendChild(this.backFrag.node);
    }
  }, {
    key: "update",
    value: function update() {
      this.originalSpeed = this.args.gSpeed || this.args.xSpeed;
      const lastX = this.args.x;
      const lastY = this.args.y;
      _get(_getPrototypeOf(RailCar.prototype), "update", this).call(this);
      if (!this.sprite) {
        return;
      }
      const nowX = this.x;
      if (this.args.gSpeed !== 0 || this.args.hSpeed !== 0 || this.args.xSpeed !== 0) {
        this.sprite.classList.add('moving');
        this.args.started = true;
      }
      if (nowX === lastX && !this.args.broken && !this.args.hSpeed) {
        this.sprite.classList.remove('moving');
        if (this.args.started) {
          const viewport = this.viewport;
          if (this.args.falling && !this.args.xSpeed && !this.args.ySpeed) {
            this.breakApart();
          } else if (!this.args.falling && !this.args.hSpeed && this.args.x === lastX && this.args.y === lastY) {
            this.breakApart();
          }
        }
      }
      if (this.occupant && !this.args.falling) {
        const speed = this.args.hSpeed || this.args.gSpeed;
        if (Math.abs(speed) < Math.abs(this.args.cartSpeed) || Math.sign(speed) !== Math.sign(this.args.cartSpeed)) {
          if (this.args.hSpeed) {
            this.args.hSpeed += Math.sign(this.args.cartSpeed) * 0.125;
          } else {
            this.args.gSpeed += Math.sign(this.args.cartSpeed) * 0.125;
          }
          if (Math.abs(this.args.gSpeed) < 1) {
            this.args.gSpeed = Math.sign(this.args.gSpeed);
          }
        }
        this.args.direction = Math.sign(this.args.hSpeed || this.args.gSpeed);
      } else {
        if (this.args.hSpeed) {
          this.args.hSpeed = this.args.xSpeed;
        } else if (this.args.xSpeed) {
          this.args.gSpeed = this.args.xSpeed;
        }
      }
    }
  }, {
    key: "breakApart",
    value: function breakApart() {
      if (!this.args.broken) {
        const viewport = this.viewport;

        // viewport.onFrameOut(140, () => viewport && viewport.actors.remove(this));
        // viewport.onFrameOut(120, () => this.sprite.classList.add('broken'));

        if (this.occupant) {
          this.occupant.startle();
        }
        this.sprite.classList.add('breaking');
        this.args.broken = true;
        this.args.groundAngle = 0;
        this.args.mode = 0;
        this.args.dead = true;
      }
    }
  }, {
    key: "sleep",
    value: function sleep() {
      this.args.x = this.def.get('x');
      this.args.y = this.def.get('y');
      this.args.dead = false;
      this.args.groundAngle = 0;
      this.args.gSpeed = 0;
      this.args.xSpeed = 0;
      this.args.ySpeed = 0;
      this.sprite.classList.remove('breaking');
      this.sprite.classList.remove('broken');
      this.args.broken = false;
      this.args.started = false;
      _get(_getPrototypeOf(RailCar.prototype), "sleep", this).call(this);
    }
  }, {
    key: "processInputDirect",
    value: function processInputDirect() {
      // Don't process input at all.
    }

    // jump()
    // {
    // 	// Don't process input at all.
    // }
  }, {
    key: "solid",
    get: function get() {
      return !this.args.broken && !this.occupant;
    }
  }]);
  return RailCar;
}(_Vehicle2.Vehicle);
exports.RailCar = RailCar;
});

;require.register("actor/Red.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Red = void 0;
var _PointActor2 = require("./PointActor");
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let Red = /*#__PURE__*/function (_PointActor) {
  _inherits(Red, _PointActor);
  var _super = _createSuper(Red);
  function Red() {
    var _this;
    _classCallCheck(this, Red);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.behaviors.add(new SkidDust());
    _this.args.type = 'actor-item actor-red';
    _this.args.animation = 'standing';
    _this.args.accel = 0.1;
    _this.args.decel = 0.5;
    _this.args.width = 16;
    _this.args.height = 16;
    _this.args.float = -1;
    return _this;
  }
  return _createClass(Red);
}(_PointActor2.PointActor);
exports.Red = Red;
});

;require.register("actor/RedBomb.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RedBomb = void 0;
var _PointActor2 = require("./PointActor");
var _Sfx = require("../audio/Sfx");
var _Tag = require("curvature/base/Tag");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let RedBomb = /*#__PURE__*/function (_PointActor) {
  _inherits(RedBomb, _PointActor);
  var _super = _createSuper(RedBomb);
  function RedBomb() {
    var _this;
    _classCallCheck(this, RedBomb);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.width = 8;
    _this.args.height = 8;
    _this.args.type = 'actor-item actor-red-bomb';
    _this.args.decel = 0;
    _this.noClip = true;
    _this.explosions = new Set();
    return _this;
  }
  _createClass(RedBomb, [{
    key: "update",
    value: function update() {
      if (!this.args.falling && !this.explosions.size) {
        this.explode();
      }
      _get(_getPrototypeOf(RedBomb.prototype), "update", this).call(this);
      for (const explosion of this.explosions) {
        explosion.style({
          '--x': this.args.x,
          '--y': this.args.y + -16
        });
      }
    }
  }, {
    key: "collideA",
    value: function collideA(other) {
      if (!other.controllable) {
        return;
      }
      other.damage(this);
      this.explode();
      this.args.float = -1;
      this.args.xSpeed = 0;
      this.args.ySpeed = 0;
    }
  }, {
    key: "explode",
    value: function explode() {
      if (this.exploded) {
        return;
      }
      this.exploded = true;
      this.viewport.actors.remove(this);
      _Sfx.Sfx.play('OBJECT_DESTROYED');
    }
  }]);
  return RedBomb;
}(_PointActor2.PointActor);
exports.RedBomb = RedBomb;
});

;require.register("actor/RedEyeJet.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RedEyeJet = void 0;
var _Tag = require("curvature/base/Tag");
var _Bgm = require("../audio/Bgm");
var _Sfx = require("../audio/Sfx");
var _PointActor2 = require("./PointActor");
var _Projectile = require("./Projectile");
var _MiniMace = require("./MiniMace");
var _MegaMace = require("./MegaMace");
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let RedEyeJet = /*#__PURE__*/function (_PointActor) {
  _inherits(RedEyeJet, _PointActor);
  var _super = _createSuper(RedEyeJet);
  function RedEyeJet(args, parent) {
    var _this;
    _classCallCheck(this, RedEyeJet);
    _this = _super.call(this, args, parent);
    _this.args.gravity = 0.4;
    _this.args.width = 96;
    _this.args.height = 32;
    _this.args.type = 'actor-item actor-red-eye-jet';
    _this.args.float = -1;
    _this.args.phase = 'idle';
    _this.args.hitPoints = _this.args.hitPoints || 8;
    _this.args.maxSpeed = 9;
    _this.args.bindTo('phase', v => _this.args.phaseFrameId = 0);
    return _this;
  }
  _createClass(RedEyeJet, [{
    key: "wakeUp",
    value: function wakeUp() {
      for (const _ref of this.hanging) {
        var _ref2 = _slicedToArray(_ref, 2);
        const type = _ref2[0];
        const others = _ref2[1];
        for (const other of others) {
          other.setPos();
        }
      }
    }
  }, {
    key: "collideA",
    value: function collideA(other, type) {
      let name;
      if (this.hanging.has(other)) {
        return false;
      }
      if (this.hanging.has(_MiniMace.MiniMace)) {
        name = 'MINI-MACE';
      } else if (this.hanging.has(_MegaMace.MegaMace)) {
        name = 'MEGA-MACE';
      }
      if (!other.controllable && !(other instanceof _Projectile.Projectile)) {
        return;
      }
      if (other instanceof _Projectile.Projectile) {}
      if (this.args.hitPoints > 0) {
        if (!(other.args.jumping || other.args.rolling || other.dashed) && !(other instanceof _Projectile.Projectile)) {
          // other.args.xSpeed = -other.args.xSpeed * 1.5;

          other.damage();
          return true;
        }
      }
      if (!this.args.falling && this.args.phase !== 'exploding') {
        if (!(other.args.jumping || other.args.rolling || other.dashed)) {
          return true;
        }
        this.box.setAttribute('data-phase', 'exploding');
        this.args.phase = 'exploding';
        this.viewport.clearCheckpoints();
        const viewport = this.viewport;
        viewport.onFrameOut(80, () => {
          this.box.setAttribute('data-phase', 'exploded');
          this.args.falling = true;
          this.args.ySpeed = -12;
          this.noClip = true;
          _Sfx.Sfx.play('OBJECT_DESTROYED');
        });

        // viewport.onFrameOut(100, () => {
        // 	viewport.clearAct(`${other.args.name} BEAT THE ${name}`);
        // });

        viewport.onFrameOut(100, () => {
          this.viewport.args.cutScene = true;
        });
        viewport.onFrameOut(150, () => {
          this.viewport.controlActor.controller.replay({
            axes: [1, 0, 0, 1]
          });
          this.viewport.controlActor.readInput();
        });
        viewport.onFrameOut(210, () => {
          this.viewport.controlActor.controller.replay({
            buttons: [1]
          });
          this.viewport.controlActor.readInput();
        });
        viewport.onFrameOut(211, () => {
          this.viewport.controlActor.dropDashCharge = 30;
        });
        viewport.onFrameOut(285, () => {
          this.viewport.controlActor.controller.replay({
            buttons: [0, 0, 0, 0, 0, 0]
          });
          this.viewport.controlActor.readInput();
          this.args.phase = 'done';
        });
        viewport.onFrameOut(500, () => {
          this.args.xSpeed = 0;
          this.args.ySpeed = 0;
          this.args.y = -1024;
        });
      }
      this.ignores.set(other, 15);
      if (type === 2) {
        _Sfx.Sfx.play('BOSS_DUDHIT');
        other.args.ySpeed = Math.max(7, Math.abs(other.args.ySpeed));
      }
      const xBounce = Math.max(Math.abs(other.args.xSpeed), Math.abs(this.args.xSpeed));
      if (this.args.hitPoints > 1 && this.args.falling) {
        this.args.xSpeed = other.args.xSpeed;
      } else {
        this.args.xSpeed = 0;
      }
      let damaged = false;
      if (type === 1) {
        this.handleDamage(other);
        damaged = true;

        // other.args.x = this.x - (this.args.width / 2) * Math.sign(other.x - this.x);

        if (this.args.hitPoints > 0) {
          other.args.xSpeed = -xBounce * 1.25;
          other.args.xSpeed = Math.min(-7, -this.args.xSpeed);
          this.args.hitPoints--;
        } else {
          other.args.xSpeed = -2;
          other.args.ignore = -2;
        }
      }
      if (type === 3) {
        this.handleDamage(other);
        damaged = true;

        // other.args.x = this.x + (this.args.width / 2) * Math.sign(other.x - this.x);

        if (this.args.hitPoints > 0) {
          other.args.xSpeed = xBounce * 1.25;
          other.args.xSpeed = Math.max(7, -this.args.xSpeed);
          this.args.hitPoints--;
        } else {
          other.args.xSpeed = 2;
          other.args.ignore = -2;
        }
      }
      if (damaged && other && other.controller && other.controller.rumble) {
        if (this.viewport.settings.rumble) {
          other.controller.rumble({
            duration: 120,
            strongMagnitude: 1.0,
            weakMagnitude: 1.0
          });
          this.onTimeout(100, () => {
            other.controller.rumble({
              duration: 100,
              strongMagnitude: 0.0,
              weakMagnitude: 0.5
            });
          });
        }
      }
      if (other instanceof _Projectile.Projectile || type === 1 || type === 3 || type === 0) {
        if (!['dead', 'exploding', 'damaged', 'done'].includes(this.args.phase)) {
          this.args.phase = 'damaged';
          this.args.animation = '';
          this.args.animation = 'damaged';
          if (this.args.hitPoints === 0 && this.args.phase !== 'exploding') {
            this.box.setAttribute('data-phase', 'dead');
            this.args.animation = '';
            this.args.phase = 'dead';
            if (typeof ga === 'function') {
              ga('send', 'event', {
                eventCategory: 'boss',
                eventAction: 'defeated',
                eventLabel: `${this.viewport.args.actName}::${this.args.id}`
              });
            }
          }
          this.viewport.onFrameOut(20, () => {
            if (this.args.phase === 'intro') {
              return;
            }
            if (this.args.hitPoints > 0) {
              this.args.animation = 'attacking';
              this.args.phase = 'attacking';
            } else if (!['dead', 'exploding', 'done'].includes(this.args.phase)) {
              this.box.setAttribute('data-phase', 'dead');
              this.args.animation = 'dead';
              this.args.phase = 'dead';
              this.args.xSpeed = 0;
              other.args.score += 20000;
            }
          });
        }
        if (type === 0) {
          other.args.y = this.y - this.args.height;
          const animation = other.args.animation;
          const ySpeed = other.args.ySpeed;
          this.onNextFrame(() => {
            other.args.animation = animation;
            other.args.falling = true;
            other.args.xSpeed = -4 * Math.sign(this.x - other.x);
            other.args.ySpeed = -Math.floor(Math.abs(ySpeed)) || -4;
          });
          _Sfx.Sfx.play('BOSS_DAMAGED');
        }
        const gSpeed = other.args.gSpeed;
        other.args.gSpeed = -gSpeed;
        if (other.args.rolling) {
          this.onNextFrame(() => {
            other.args.gSpeed = -gSpeed;
            other.args.rolling = true;
            other.args.direction - Math.sign(gSpeed);
          });
        }
      }
      other.args.ignore = 1;
      if (!this.args.hitPoints) {
        _Bgm.Bgm.stop('ZONE-BOSS');
        _Bgm.Bgm.stop('ACT-BOSS');
        other.args.ignore = -2;
      }
      return true;
    }
  }, {
    key: "handleDamage",
    value: function handleDamage(other) {
      _Sfx.Sfx.play('BOSS_DAMAGED');
      if (other) {
        const label = ['LUCKY SHOT', 'IM GOING EASY', 'OKAY', 'NICE', 'WOW', 'JEEZ', 'DAMN!', 'STOP!'][other.args.popChain.length];
        const reward = {
          label: label,
          points: 1000 * other.args.popChain.length,
          multiplier: 1
        };
        other.args.popChain.push(reward);
        other.args.popCombo += 1;
      }
    }
  }, {
    key: "update",
    value: function update() {
      this.args.phaseFrameId++;
      this.args.frameId++;
      if (this.args.phase === 'idle') {
        if (this.args.phaseFrameId > 120) {
          this.args.phase = 'intro';
        }
        return;
      }
      if (!this.viewport) {
        return;
      }
      if (this.args.phase === 'intro') {
        if (this.hanging.has(_MiniMace.MiniMace)) {
          for (const mace of this.hanging.get(_MiniMace.MiniMace)) {
            mace.args.ropeLength = 80;
          }
          _Bgm.Bgm.play('ACT-BOSS', {
            loop: true,
            interlude: true
          });
        }
        if (this.hanging.has(_MegaMace.MegaMace)) {
          for (const mace of this.hanging.get(_MegaMace.MegaMace)) {
            mace.args.ropeLength = 96;
          }
          _Bgm.Bgm.play('ZONE-BOSS', {
            loop: true,
            interlude: true
          });
        }
        this.args.maxSpeed = 12;
        if (this.args.phaseFrameId > 240) {
          this.args.phase = 'attacking';
        }
      } else if (this.hanging.has(_MiniMace.MiniMace)) {
        this.viewport.onFrameOut(45, () => {
          for (const mace of this.hanging.get(_MiniMace.MiniMace)) {
            mace.args.ropeLength = 128;
          }
        });
      } else if (this.hanging.has(_MegaMace.MegaMace)) {
        this.viewport.onFrameOut(45, () => {
          for (const mace of this.hanging.get(_MegaMace.MegaMace)) {
            mace.args.ropeLength = 176;
          }
        });
      }
      if (this.args.phase === 'attacking') {
        this.args.maxSpeed = 9;
        if (this.hanging.has(_MiniMace.MiniMace)) {
          for (const mace of this.hanging.get(_MiniMace.MiniMace)) {
            mace.args.float = 0;
          }
        }
        if (this.hanging.has(_MegaMace.MegaMace)) {
          for (const mace of this.hanging.get(_MegaMace.MegaMace)) {
            mace.args.float = 0;
          }
        }
        if (Math.abs(this.viewport.controlActor.x - this.x) > 255) {
          this.args.phase = 'chasing';
        }
      }
      if (this.args.phase === 'chasing') {
        if (Math.abs(this.viewport.controlActor.x - this.x) < 8 && this.y < this.viewport.controlActor.y) {
          this.args.phase = 'attacking';
        }
      }
      if (this.args.phase === 'exploding') {
        const viewport = this.viewport;
        if (viewport && viewport.args.frameId % 3 === 0) {
          const explosion = new _Tag.Tag('<div class = "particle-explosion">');
          _Sfx.Sfx.play('BOSS_DAMAGED');
          const xOff = this.args.width * Math.random() - this.args.width / 2;
          const yOff = this.args.height * Math.random() - this.args.height / 2;
          explosion.style({
            '--x': this.x + xOff,
            '--y': this.y + yOff + -16
          });
          viewport.particles.add(explosion);
          setTimeout(() => viewport.particles.remove(explosion), 512);
        }
        _get(_getPrototypeOf(RedEyeJet.prototype), "update", this).call(this);
        return;
      }
      if (this.args.phase === 'damaged') {
        this.args.xSpeed *= 0.999;
      }
      if (this.box) {
        if (this.x - this.viewport.controlActor.x > 0) {
          if (Math.abs(this.x - this.viewport.controlActor.x) > 128) {
            this.box.setAttribute('data-looking', 'far-left');
          } else if (this.viewport.controlActor.args.direction === -1) {
            this.box.setAttribute('data-looking', 'far-left');
          } else {
            this.box.setAttribute('data-looking', 'left');
          }
        } else if (this.x - this.viewport.controlActor.x < 0) {
          this.box.setAttribute('data-looking', 'far-right');
          if (Math.abs(this.x - this.viewport.controlActor.x) > 128) {
            this.box.setAttribute('data-looking', 'far-right');
          } else if (this.viewport.controlActor.args.direction === 1) {
            this.box.setAttribute('data-looking', 'far-right');
          } else {
            this.box.setAttribute('data-looking', 'right');
          }
        }
        if (32 > this.y - this.viewport.controlActor.y) {
          this.box.setAttribute('data-ducking', 'true');
        } else {
          this.box.setAttribute('data-ducking', 'false');
        }
      }
      if (this.args.hitPoints) {
        if (['attacking', 'intro', 'chasing'].includes(this.args.phase)) {
          if (Math.abs(this.x - this.viewport.controlActor.x) > 384) {
            this.args.x = this.viewport.controlActor.x + Math.sign(this.x - this.viewport.controlActor.x) * 384;
          }
          this.args.xSpeed += -Math.sign(this.x - this.viewport.controlActor.x) * 0.35;
        }
      }
      if (this.args.hitPoints) {
        this.args.falling = true;
        this.args.float = -1;
      } else {
        this.args.float = 0;
      }
      if (this.args.phase === 'intro' || this.args.phase === 'attacking') {
        this.args.maxSpeed = 11;
      }
      if (this.args.phase === 'chasing') {
        if (Math.abs(this.x - this.viewport.controlActor.x) < 128) {
          this.args.maxSpeed = Math.max(this.args.maxSpeed, this.viewport.controlActor.args.xSpeed);
        }
      } else if (Math.abs(this.args.xSpeed) > this.args.maxSpeed) {
        this.args.xSpeed = Math.sign(this.args.xSpeed) * this.args.maxSpeed;
      }
      _get(_getPrototypeOf(RedEyeJet.prototype), "update", this).call(this);
    }
  }, {
    key: "onRendered",
    value: function onRendered(event) {
      _get(_getPrototypeOf(RedEyeJet.prototype), "onRendered", this).call(this, event);
      this.box = this.findTag('div');
      this.sprite = this.findTag('div.sprite');
      this.body = new _Tag.Tag(`<div class = "body-center">`);
      this.bodyL = new _Tag.Tag(`<div class = "body-left">`);
      this.bodyR = new _Tag.Tag(`<div class = "body-right">`);
      this.fireA = new _Tag.Tag(`<div class = "boost-fire boost-fire-left">`);
      this.fireB = new _Tag.Tag(`<div class = "boost-fire boost-fire-right">`);
      this.eye = new _Tag.Tag(`<div class = "orange-eye">`);
      this.box.appendChild(this.body.node);
      this.box.appendChild(this.bodyL.node);
      this.box.appendChild(this.bodyR.node);
      this.box.appendChild(this.fireA.node);
      this.box.appendChild(this.fireB.node);
      this.box.appendChild(this.eye.node);
    }
  }, {
    key: "solid",
    get: function get() {
      return false;
    }
  }]);
  return RedEyeJet;
}(_PointActor2.PointActor);
exports.RedEyeJet = RedEyeJet;
});

;require.register("actor/Redz.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Redz = void 0;
var _Flickie = require("./Flickie");
var _Mixin = require("curvature/base/Mixin");
var _Tag = require("curvature/base/Tag");
var _PointActor = require("./PointActor");
var _SkidDust = require("../behavior/SkidDust");
var _Patrol = require("../behavior/Patrol");
var _CanPop = require("../mixin/CanPop");
var _Explosion = require("../actor/Explosion");
var _SpitFire = require("../actor/SpitFire");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let Redz = /*#__PURE__*/function (_Mixin$from) {
  _inherits(Redz, _Mixin$from);
  var _super = _createSuper(Redz);
  function Redz() {
    var _this;
    _classCallCheck(this, Redz);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.behaviors.add(new _SkidDust.SkidDust());
    _this.behaviors.add(new _Patrol.Patrol());
    _this.args.type = 'actor-item actor-redz';
    _this.args.animation = 'standing';

    // this.args.accel     = 0.1;
    // this.args.decel     = 0.5;

    _this.args.gSpeedMax = 5;
    _this.args.jumpForce = 5;
    _this.args.gravity = 0.5;
    _this.args.width = 18;
    _this.args.height = 32;
    _this.willStick = false;
    _this.stayStuck = false;
    _this.args.patrolBeat = _this.args.patrolBeat || 160;
    _this.args.patrolPause = _this.args.patrolPause || 60;
    _this.args.patrolSpeed = _this.args.patrolSpeed || 0.25;
    return _this;
  }
  _createClass(Redz, [{
    key: "update",
    value: function update() {
      _get(_getPrototypeOf(Redz.prototype), "update", this).call(this);
      const direction = this.args.direction = Math.sign(this.args.gSpeed) || this.args.direction;
      if (this.box) {
        if (Math.sign(this.args.gSpeed) !== direction && Math.abs(this.args.gSpeed - direction) > 5) {
          this.box.setAttribute('data-animation', 'skidding');
        } else if (this.args.moving && this.args.gSpeed) {
          this.box.setAttribute('data-animation', 'walking');
        } else {
          this.box.setAttribute('data-animation', 'shooting');
        }
      }
      if (this.age % this.args.patrolBeat === this.args.patrolBeat - this.args.patrolPause) {
        const spitFire = new _SpitFire.SpitFire({
          owner: this,
          direction: direction,
          x: this.x + 59 * direction,
          y: this.y - 3,
          z: this.z + 1
        });
        const viewport = this.viewport;
        viewport.spawn.add({
          object: spitFire
        });
        this._onRemove.add(() => viewport.actors.remove(spitFire));
      }
    }
  }, {
    key: "effect",
    value: function effect(other) {
      _get(_getPrototypeOf(Redz.prototype), "effect", this).call(this, other);

      // this.viewport.spawn.add({object:new Flickie({
      // 	x: this.args.x,
      // 	y: this.args.y,
      // })});
    }
  }, {
    key: "solid",
    get: function get() {
      return false;
    }
  }, {
    key: "isEffect",
    get: function get() {
      return false;
    }
    // get controllable() { return true; }
  }]);
  return Redz;
}(_Mixin.Mixin.from(_PointActor.PointActor, _CanPop.CanPop));
exports.Redz = Redz;
});

;require.register("actor/Relief.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Relief = void 0;
var _PointActor2 = require("./PointActor");
var _Block = require("./Block");
var _Sfx = require("../audio/Sfx");
var _ObjectPalette = require("../ObjectPalette");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let Relief = /*#__PURE__*/function (_PointActor) {
  _inherits(Relief, _PointActor);
  var _super = _createSuper(Relief);
  function Relief() {
    var _this$args$offset, _this$args$shoots;
    var _this;
    _classCallCheck(this, Relief);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.width = 24;
    _this.args.height = 80;
    _this.args.type = 'actor-item actor-relief';
    _this.noClip = true;
    _this.args.float = -1;
    _this.args.offset = (_this$args$offset = _this.args.offset) !== null && _this$args$offset !== void 0 ? _this$args$offset : 45;
    _this.args.animation = 'idle';
    _this.args.shoots = (_this$args$shoots = _this.args.shoots) !== null && _this$args$shoots !== void 0 ? _this$args$shoots : 'spitsteam';
    _this.launching = new Set();
    return _this;
  }
  _createClass(Relief, [{
    key: "update",
    value: function update() {
      _get(_getPrototypeOf(Relief.prototype), "update", this).call(this);
      const frame = this.viewport.args.frameId + -this.args.offset;
      if (frame % 60) {
        return;
      }
      if (!this.shoots && _ObjectPalette.ObjectPalette[this.args.shoots]) {
        var _this$args$direction;
        const type = _ObjectPalette.ObjectPalette[this.args.shoots];
        const direction = (_this$args$direction = this.args.direction) !== null && _this$args$direction !== void 0 ? _this$args$direction : 1;
        this.shoots = new type({
          owner: this,
          direction: direction,
          x: this.x,
          y: this.y + -24,
          z: this.z + 1
        });
        this.shoots.args.x += this.shoots.args.width * 0.5 * direction + this.args.width * 0.3 * direction;
        this.shoots.args.y += this.shoots.args.height * 0.5;
        this.viewport.spawn.add({
          object: this.shoots
        });
      }
      if (this.shoots.args.gone) {
        this.shoots = null;
      }
    }
  }, {
    key: "collideA",
    value: function collideA(other) {
      return true;
    }
  }, {
    key: "solid",
    get: function get() {
      return true;
    }
  }]);
  return Relief;
}(_PointActor2.PointActor);
exports.Relief = Relief;
});

;require.register("actor/RhinoBot.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RhinoBot = void 0;
var _Flickie = require("./Flickie");
var _Mixin = require("curvature/base/Mixin");
var _PointActor = require("./PointActor");
var _Patrol = require("../behavior/Patrol");
var _CanPop = require("../mixin/CanPop");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let RhinoBot = /*#__PURE__*/function (_Mixin$from) {
  _inherits(RhinoBot, _Mixin$from);
  var _super = _createSuper(RhinoBot);
  function RhinoBot() {
    var _this;
    _classCallCheck(this, RhinoBot);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);

    // this.behaviors.add(new Patrol);

    _this.args.type = 'actor-item actor-rhino-bot';
    _this.args.animation = 'standing';
    _this.args.accel = 0.75;
    _this.args.decel = 0.5;
    _this.args.gSpeedMax = 15;
    _this.args.jumpForce = 5;
    _this.args.gravity = 0.5;
    _this.args.width = 44;
    _this.args.height = 32;

    // this.args.patrolPause   = this.args.patrolPause   ?? 20;
    // this.args.patrolBeat    = this.args.patrolBeat    ?? 120;
    // this.args.patrolSpeed   = this.args.patrolSpeed   ?? 4;

    // this.args.tailOffset = 0;

    _this.chasing = false;
    return _this;
  }
  _createClass(RhinoBot, [{
    key: "onRendered",
    value: function onRendered(event) {
      _get(_getPrototypeOf(RhinoBot.prototype), "onRendered", this).call(this, event);
    }
  }, {
    key: "update",
    value: function update() {
      // const direction = this.args.direction;
      const telegraph = this.args.shotTelegraph;
      const beat = this.args.patrolBeat;
      const moved = this.args.x - this.xLast;
      this.args.tailOffset += isNaN(moved) ? 0 : moved;
      if (this.box) {
        if (this.args.moving && this.args.gSpeed) {
          this.box.setAttribute('data-animation', 'walking');
        } else {
          this.box.setAttribute('data-animation', 'standing');
        }
      }
      if (this.viewport && this.viewport.controlActor) {
        if (Math.abs(this.viewport.controlActor.args.x - this.args.x) < 768) {
          this.chasing = this.viewport.controlActor;
        }
      }
      if (this.chasing) {
        this.args.gSpeed += (this.chasing.args.x - this.args.x) * 0.1;
        const diff = Math.abs(this.chasing.args.x - this.chasing.args.x);
        const maxSpeed = Math.max(6, Math.abs(this.chasing.args.gSpeed || this.chasing.args.xSpeed) * (diff > 256 ? 1.2 : 1));
        if (Math.abs(this.args.gSpeed) > maxSpeed) {
          this.args.gSpeed = Math.sign(this.args.gSpeed) * maxSpeed;
        }
      }
      _get(_getPrototypeOf(RhinoBot.prototype), "update", this).call(this);
      this.args.direction = Math.sign(this.args.gSpeed);
      this.args.facing = this.args.direction > 0 ? 'right' : 'left';
    }
  }, {
    key: "effect",
    value: function effect(other) {
      _get(_getPrototypeOf(RhinoBot.prototype), "effect", this).call(this, other);

      // this.viewport.spawn.add({object:new Flickie({
      // 	x: this.args.x,
      // 	y: this.args.y,
      // })});
    }
  }, {
    key: "solid",
    get: function get() {
      return false;
    }
  }, {
    key: "isEffect",
    get: function get() {
      return false;
    }
    // get controllable() { return true; }
  }]);
  return RhinoBot;
}(_Mixin.Mixin.from(_PointActor.PointActor, _CanPop.CanPop));
exports.RhinoBot = RhinoBot;
});

;require.register("actor/Ring.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Ring = void 0;
var _PointActor2 = require("./PointActor");
var _Spring = require("./Spring");
var _Sfx = require("../audio/Sfx");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let Ring = /*#__PURE__*/function (_PointActor) {
  _inherits(Ring, _PointActor);
  var _super = _createSuper(Ring);
  function Ring() {
    var _this$args$static, _this$args$dropped, _this$args$delay;
    var _this;
    _classCallCheck(this, Ring);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _defineProperty(_assertThisInitialized(_this), "template", `<div class  = "point-actor [[type]]">
		<div class = "sprite" cv-ref = "sprite"></div>
	</div>`);
    _defineProperty(_assertThisInitialized(_this), "float", -1);
    _this[_Spring.Spring.WontSpring] = true;
    _this.args.type = 'actor-item actor-ring';
    _this.args.width = 32;
    _this.args.height = 32;
    _this.args.static = (_this$args$static = _this.args.static) !== null && _this$args$static !== void 0 ? _this$args$static : true;
    _this.args.dropped = (_this$args$dropped = _this.args.dropped) !== null && _this$args$dropped !== void 0 ? _this$args$dropped : true;
    _this.args.gone = false;
    _this.args.gravity = 0.40;
    _this.args.delay = (_this$args$delay = _this.args.delay) !== null && _this$args$delay !== void 0 ? _this$args$delay : 48;
    return _this;
  }
  _createClass(Ring, [{
    key: "update",
    value: function update() {
      if (!this.viewport) {
        return;
      }
      const currentFrame = this.viewport.args.frameId;
      const startFrame = this.startFrame;
      const age = currentFrame - startFrame;
      if (this.args.noClip) {
        this.noClip = true;
      } else if (!this.args.decoration) {
        if (this.args.ySpeed < 0) {
          this.noClip = true;
        } else if (!this.attract) {
          this.noClip = false;
        }
      } else {
        this.noClip = true;
      }
      if (this.args.decoration) {
        this.args.type = 'actor-item actor-ring decoration';
        this.args.gravity = 0.36;
      }
      if (this.dropped) {
        this.args.type = 'actor-item actor-ring dropped';
        this.args.height = 14;
      }
      const viewport = this.viewport;
      if (this.dropped && this.viewport && !this.viewport.actorIsOnScreen(this, 256)) {
        viewport.onFrameOut(15, () => {
          viewport.actors.remove(this);
        });
      }
      if (this.args.reward && this.args.gone) {
        viewport.onFrameOut(15, () => {
          viewport.actors.remove(this);
        });
      }
      if (this.args.reward || this.dropped || this.attract) {
        _get(_getPrototypeOf(Ring.prototype), "update", this).call(this);
      }
      if (this.args.reward) {
        return;
      }
      if (this.dropped && !this.attract && this.getMapSolidAt(this.args.x, this.args.y + -this.args.height) && !this.getMapSolidAt(this.args.x, this.args.y)) {
        this.args.y += this.args.height + 1;
        this.args.ySpeed = Math.abs(this.args.ySpeed) || 8;
      } else if (this.dropped && !this.attract && this.getMapSolidAt(this.args.x + this.args.xSpeed * this.args.direction, this.args.y + -8, false)) {
        this.args.xSpeed *= -1;
      }
      if ((this.dropped || this.scattered) && (!this.args.falling || !this.args.ySpeed)) {
        // this.args.xSpeed = this.args.xSpeed || this.xSpeedLast || (Math.random() - 0.5);
        this.args.ySpeed = Math.min(-Math.abs(this.args.ySpeed || this.ySpeedLast || 0) * 0.75, age > 6 ? -2 : 0);
        this.args.gSpeed = 0;
        this.args.x += this.args.xSpeed;
        this.args.y += this.args.ySpeed;
        this.args.falling = true;
        this.args.groundAngle = 0;
      }
    }
  }, {
    key: "callCollideHandler",
    value: function callCollideHandler(other) {
      if (other instanceof Ring) {
        return false;
      }
      return _get(_getPrototypeOf(Ring.prototype), "callCollideHandler", this).call(this, other);
    }
  }, {
    key: "collideA",
    value: function collideA(other) {
      if (other instanceof this.constructor) {
        return;
      }
      if (!this.viewport || this.args.gone || this.args.ignore) {
        return false;
      }
      const age = this.viewport.args.frameId - this.startFrame;
      if (this.dropped && age < this.args.delay) {
        return false;
      }
      if (other.args.owner) {
        other = other.args.owner;
      }
      if (other.occupant) {
        other = other.occupant;
      }
      if (!other.controllable && !other.occupant && !other.args.owner) {
        return false;
      }
      _get(_getPrototypeOf(Ring.prototype), "collideA", this).call(this, other);
      if (other.controllable) {
        other.args.rings += 1;
      }
      this.args.gone = true;
      this.viewport.auras.delete(this);

      // this.args.xSpeed = 0;
      // this.args.ySpeed = 0;
      this.args.static = true;
      this.args.float = -1;
      this.args.type = 'actor-item actor-ring collected';
      this.args.xSpeed = 0;
      this.args.ySpeed = 0;
      if (this.viewport.args.audio) {
        _Sfx.Sfx.play('RING_COLLECTED');
      }
      this.viewport.onFrameOut(5, () => {
        this.args.type = 'actor-item actor-ring collected gone';
      });
      const x = this.args.x;
      const y = this.args.y;
      const viewport = this.viewport;
      this.viewport.onFrameOut(4200, () => {
        this.restore = true;
      });
      if (other.collect) {
        if (typeof ga === 'function') {
          ga('send', 'event', {
            eventCategory: 'ring',
            eventAction: 'collected',
            eventLabel: `${this.viewport.args.actName}::${this.args.id}`
          });
        }
        this.viewport.onFrameOut(1, () => {
          other.collect(this);
        });
      }

      // this.args.xSpeed = 0;
      // this.args.ySpeed = 0;
    }
  }, {
    key: "wakeUp",
    value: function wakeUp() {
      if (this.def && this.restore) {
        this.args.x = this.def.get('x');
        this.args.y = this.def.get('y');
        // this.args.float = -1;

        this.args.gone = this.restore = false;
        this.args.type = 'actor-item actor-ring';
      }
    }
  }, {
    key: "solid",
    get: function get() {
      return false;
    }
  }, {
    key: "rotateLock",
    get: function get() {
      return true;
    }
  }]);
  return Ring;
}(_PointActor2.PointActor);
exports.Ring = Ring;
});

;require.register("actor/RoadBarrier.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RoadBarrier = void 0;
var _PointActor2 = require("./PointActor");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let RoadBarrier = /*#__PURE__*/function (_PointActor) {
  _inherits(RoadBarrier, _PointActor);
  var _super = _createSuper(RoadBarrier);
  function RoadBarrier() {
    var _this;
    _classCallCheck(this, RoadBarrier);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.width = _this.args.width || 64;
    _this.args.height = _this.args.height || 32;
    _this.args.type = 'actor-item actor-road-barrier';
    _this.args.z = 0;
    return _this;
  }
  _createClass(RoadBarrier, [{
    key: "solid",
    get: function get() {
      return false;
    }
  }]);
  return RoadBarrier;
}(_PointActor2.PointActor);
exports.RoadBarrier = RoadBarrier;
});

;require.register("actor/Rocket.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Rocket = void 0;
var _PointActor2 = require("./PointActor");
var _Tag = require("curvature/base/Tag");
var _Sfx = require("../audio/Sfx");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let Rocket = /*#__PURE__*/function (_PointActor) {
  _inherits(Rocket, _PointActor);
  var _super = _createSuper(Rocket);
  function Rocket() {
    var _this$args$xMax, _this$args$yMax;
    var _this;
    _classCallCheck(this, Rocket);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);

    // this.args.width  = this.args.width  || 32;
    // this.args.height = this.args.height || 32;

    _this.args.width = 64;
    _this.args.height = 16;
    _this.args.xMax = (_this$args$xMax = _this.args.xMax) !== null && _this$args$xMax !== void 0 ? _this$args$xMax : 24;
    _this.args.yMax = (_this$args$yMax = _this.args.yMax) !== null && _this$args$yMax !== void 0 ? _this$args$yMax : 24;
    _this.args.type = 'actor-item actor-rocket';
    _this.args.launched = false;
    _this.args.bindTo(['xSpeed', 'ySpeed'], v => {
      if (v || !_this.args.launched) {
        return;
      }
      ;
      _this.explode();
    });
    return _this;
  }
  _createClass(Rocket, [{
    key: "update",
    value: function update() {
      if (!this.viewport) {
        return;
      }
      if (!this.thrusterSound) {
        this.thrusterSound = new Audio('/Sonic/mecha-sonic-thruster.wav');
      } else {
        this.thrusterSound.volume = 0.2 + Math.random() * -0.05;
        if (this.thrusterSound.currentTime > 1.5) {
          this.thrusterSound.currentTime = 0.5;
        }
      }
      _get(_getPrototypeOf(Rocket.prototype), "update", this).call(this);
      if (this.args.launched && Math.abs(this.args.xSpeed) < Math.abs(this.args.xMax)) {
        this.args.xSpeed += 0.5 * Math.sign(this.args.xMax);
      }
      if (this.args.launched && Math.abs(this.args.ySpeed) < Math.abs(this.args.yMax)) {
        this.args.ySpeed -= 0.5 * Math.sign(this.args.yMax);
      }
      if (this.args.launched && this.args.xSpeed === 0 && this.args.ySpeed === 0) {
        this.explode();
      }
    }
  }, {
    key: "activate",
    value: function activate() {
      this.viewport.auras.add(this);
      this.viewport.args.audio && this.thrusterSound && this.thrusterSound.play();
      this.args.launched = true;
      if (this.args.xMax) {
        this.args.xSpeed += 0.5;
      }
      if (this.args.yMax) {
        this.args.ySpeed -= 0.5;
      }
    }
  }, {
    key: "sleep",
    value: function sleep() {
      if (this.args.launched) {
        this.explode();
      }
    }
  }, {
    key: "wakeUp",
    value: function wakeUp() {
      // this.args.xSpeed = 0;
      // this.args.ySpeed = 0;
      // this.args.x = this.def.get('x');
      // this.args.y = this.def.get('y');
    }
  }, {
    key: "explode",
    value: function explode() {
      const viewport = this.viewport;
      if (!viewport) {
        return;
      }
      _Sfx.Sfx.play('OBJECT_DESTROYED');
      this.thrusterSound && this.thrusterSound.pause();
      const explosion = new _Tag.Tag('<div class = "particle-explosion">');
      explosion.style({
        '--x': this.x,
        '--y': this.y - 8
      });
      viewport.particles.add(explosion);
      setTimeout(() => viewport.particles.remove(explosion), 512);
      this.args.xSpeed = 0;
      this.args.ySpeed = 0;
      this.args.opacity = 0;
      this.args.launched = false;

      // this.args.xSpeed = 0;
      // this.args.ySpeed = 0;

      // this.args.x = this.def.get('x');
      // this.args.y = this.def.get('y');

      this.viewport.setColCell(this);
      this.viewport.onFrameOut(60, () => {});
      const exploded = new CustomEvent('exploded', {
        detail: {
          actor: this
        }
      });
      this.dispatchEvent(exploded);
      this.args.launched = false;
      this.args.opacity = 1;
      this.args.x = this.def.get('x');
      this.args.y = this.def.get('y');
      this.viewport.setColCell(this);
      this.viewport.auras.delete(this);
    }
  }]);
  return Rocket;
}(_PointActor2.PointActor);
exports.Rocket = Rocket;
});

;require.register("actor/RocketPlatform.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RocketPlatform = void 0;
var _Block2 = require("./Block");
var _Sfx = require("../audio/Sfx");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let RocketPlatform = /*#__PURE__*/function (_Block) {
  _inherits(RocketPlatform, _Block);
  var _super = _createSuper(RocketPlatform);
  function RocketPlatform() {
    var _this;
    _classCallCheck(this, RocketPlatform);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.width = 96;
    _this.args.height = 64;
    _this.args.platform = 1;
    _this.args.type = 'actor-item actor-rocket-platform';
    _this.args.static = 0;
    _this.args.activeTime = 0;
    return _this;
  }
  _createClass(RocketPlatform, [{
    key: "update",
    value: function update() {
      this.args.cameraBias = 0.2;
      if (this.standingUnder.size) {
        this.args.activeTime++;
        this.args.active = true;
      } else {
        this.args.activeTime = 0;
        this.args.active = false;
      }
      for (const other of this.standingUnder) {
        if (other.args.dead) {
          // this.args.y += -this.args.ySpeed;
          this.args.ySpeed = 0;
          this.standingUnder.delete(other);
        } else if (!this.args.falling) {
          other.args.y = Math.round(other.args.y);
        }
      }
      _get(_getPrototypeOf(RocketPlatform.prototype), "update", this).call(this);
      if (this.args.activeTime > 1) {
        this.args.ySpeed -= 0.1;
        this.args.float = 1;
        if (!this.args.falling) {
          this.args.falling = true;
          this.args.ySpeed = -1;
          this.args.y--;
        }
      }
    }
  }, {
    key: "collideA",
    value: function collideA(other, type) {
      if (type !== 0) {
        return _get(_getPrototypeOf(RocketPlatform.prototype), "collideA", this).call(this, other, type);
      }
      if (!other.controllable) {
        return _get(_getPrototypeOf(RocketPlatform.prototype), "collideA", this).call(this, other, type);
      }
      this.args.ySpeed -= 0.1;
      this.args.float = 1;
      if (this.args.ySpeed < -3) {
        this.args.ySpeed = -3;
      }
      return _get(_getPrototypeOf(RocketPlatform.prototype), "collideA", this).call(this, other, type);
    }
  }]);
  return RocketPlatform;
}(_Block2.Block);
exports.RocketPlatform = RocketPlatform;
});

;require.register("actor/Rocks.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Rocks = void 0;
var _PointActor2 = require("./PointActor");
var _Projectile = require("../actor/Projectile");
var _Tag = require("curvature/base/Tag");
var _Sfx = require("../audio/Sfx");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let Rocks = /*#__PURE__*/function (_PointActor) {
  _inherits(Rocks, _PointActor);
  var _super = _createSuper(Rocks);
  function Rocks(args, parent) {
    var _this;
    _classCallCheck(this, Rocks);
    _this = _super.call(this, args, parent);
    _this.args.type = 'actor-item actor-rocks-tall';
    _this.args.width = 48;
    _this.args.height = 80;
    _this.gone = false;
    _this.particleA = new _Tag.Tag('<div class = "particle-rock">');
    _this.particleB = new _Tag.Tag('<div class = "particle-rock">');
    _this.particleC = new _Tag.Tag('<div class = "particle-rock">');
    _this.particleD = new _Tag.Tag('<div class = "particle-rock">');
    _this.particleE = new _Tag.Tag('<div class = "particle-rock">');
    _this.particleF = new _Tag.Tag('<div class = "particle-rock">');
    _this.particleG = new _Tag.Tag('<div class = "particle-rock">');
    _this.particleH = new _Tag.Tag('<div class = "particle-rock">');
    return _this;
  }
  _createClass(Rocks, [{
    key: "onRendered",
    value: function onRendered(event) {
      _get(_getPrototypeOf(Rocks.prototype), "onRendered", this).call(this, event);

      // const direction = Math.sign(other.args.gSpeed || other.args.xSpeed);

      let direction = -1;
      const fuzzFactor = 20;
      const fallSpeed = 1550;
      const xForce = 60;
      const yForce = 40;
      const particleA = this.particleA;
      const particleB = this.particleB;
      const particleC = this.particleC;
      const particleD = this.particleD;
      const particleE = this.particleE;
      const particleF = this.particleF;
      const particleG = this.particleG;
      const particleH = this.particleH;
      particleA.style({
        '--x': this.x - 8,
        '--y': this.y - 8,
        '--fallSpeed': fallSpeed + fuzzFactor * Math.random(),
        '--xMomentum': xForce * direction + fuzzFactor * Math.random(),
        '--yMomentum': yForce,
        'z-index': 0
      });
      direction *= -1;
      particleB.style({
        '--x': this.x + 8,
        '--y': this.y - 0,
        '--fallSpeed': fallSpeed + fuzzFactor * Math.random(),
        '--xMomentum': xForce * direction + fuzzFactor * Math.random(),
        '--yMomentum': yForce,
        'z-index': 0
      });
      direction *= -1;
      particleC.style({
        '--x': this.x,
        '--y': this.y - 18,
        '--fallSpeed': fallSpeed + fuzzFactor * Math.random(),
        '--xMomentum': xForce * direction + fuzzFactor * Math.random(),
        '--yMomentum': yForce * 1.1,
        'z-index': 0
      });
      direction *= -1;
      particleD.style({
        '--x': this.x + 8,
        '--y': this.y - 10,
        '--fallSpeed': fallSpeed + fuzzFactor * Math.random(),
        '--xMomentum': xForce * direction + fuzzFactor * Math.random(),
        '--yMomentum': yForce * 1.1,
        'z-index': 0
      });
      direction *= -1;
      particleE.style({
        '--x': this.x - 8,
        '--y': this.y - 28,
        '--fallSpeed': fallSpeed + fuzzFactor * Math.random(),
        '--xMomentum': xForce * direction + fuzzFactor * Math.random(),
        '--yMomentum': yForce * 1.2,
        'z-index': 0
      });
      direction *= -1;
      particleF.style({
        '--x': this.x + 8,
        '--y': this.y - 20,
        '--fallSpeed': fallSpeed + fuzzFactor * Math.random(),
        '--xMomentum': xForce * direction + fuzzFactor * Math.random(),
        '--yMomentum': yForce * 1.2,
        'z-index': 0
      });
      direction *= -1;
      particleG.style({
        '--x': this.x - 8,
        '--y': this.y - 30,
        '--fallSpeed': fallSpeed + fuzzFactor * Math.random(),
        '--xMomentum': xForce * direction + fuzzFactor * Math.random(),
        '--yMomentum': yForce * 1.2,
        'z-index': 0
      });
      direction *= -1;
      particleH.style({
        '--x': this.x + 8,
        '--y': this.y - 30,
        '--fallSpeed': fallSpeed + fuzzFactor * Math.random(),
        '--xMomentum': xForce * direction + fuzzFactor * Math.random(),
        '--yMomentum': 50 * 1.3,
        'z-index': 0
      });
    }
  }, {
    key: "collideA",
    value: function collideA(other, type) {
      if (this.args.gone) {
        return false;
      }
      _get(_getPrototypeOf(Rocks.prototype), "collideA", this).call(this, other, type);
      if (other.occupant || other.args.rolling || other.punching) {
        this.pop(other);
        return false;
      }
      if (type !== 2 && (!this.args.falling || this.args.float === -1) && other.args.ySpeed > 0 && other.y < this.y && this.viewport && !this.args.gone) {
        if (this.args.falling && Math.abs(other.args.ySpeed) > 0) {
          other.args.xSpeed *= -1;
        }
        this.pop(other);
        return false;
      }
      if ((type === 1 || type === 3) && other instanceof _Projectile.Projectile && this.viewport && !this.args.gone) {
        this.pop(other);
        return false;
      }
      return true;
    }

    // collideB(other)
    // {
    // 	if(other.args.falling && this.args.gone)
    // 	{
    // 		other.args.ySpeed *= -1;
    // 		other.args.falling = true;
    // 	}

    // 	return false;
    // }
  }, {
    key: "pop",
    value: function pop(other) {
      this.args.gone = true;
      const viewport = this.viewport;
      if (!viewport) {
        return;
      }
      _Sfx.Sfx.play('ROCKS_DESTROYED');
      const particleA = this.particleA;
      const particleB = this.particleB;
      const particleC = this.particleC;
      const particleD = this.particleD;
      const particleE = this.particleE;
      const particleF = this.particleF;
      const particleG = this.particleG;
      const particleH = this.particleH;
      viewport.particles.add(particleA);
      viewport.particles.add(particleB);
      viewport.particles.add(particleC);
      viewport.particles.add(particleD);
      viewport.particles.add(particleE);
      viewport.particles.add(particleF);
      viewport.particles.add(particleG);
      viewport.particles.add(particleH);
      setTimeout(() => {
        viewport.particles.remove(particleA);
        viewport.particles.remove(particleB);
        viewport.particles.remove(particleC);
        viewport.particles.remove(particleD);
        viewport.particles.remove(particleE);
        viewport.particles.remove(particleF);
        viewport.particles.remove(particleG);
        viewport.particles.remove(particleH);
      }, 2500);
      this.onNextFrame(() => viewport.actors.remove(this));
    }
  }, {
    key: "canStick",
    get: function get() {
      return false;
    }
  }, {
    key: "solid",
    get: function get() {
      return !this.args.gone;
    }
  }]);
  return Rocks;
}(_PointActor2.PointActor);
exports.Rocks = Rocks;
});

;require.register("actor/RollingSign.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RollingSign = void 0;
var _PointActor2 = require("./PointActor");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let RollingSign = /*#__PURE__*/function (_PointActor) {
  _inherits(RollingSign, _PointActor);
  var _super = _createSuper(RollingSign);
  function RollingSign() {
    var _this$args$height;
    var _this;
    _classCallCheck(this, RollingSign);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.width = 20;
    _this.args.height = (_this$args$height = _this.args.height) !== null && _this$args$height !== void 0 ? _this$args$height : 80;
    _this.args.type = 'actor-item actor-rolling-sign';
    return _this;
  }
  _createClass(RollingSign, [{
    key: "solid",
    get: function get() {
      return false;
    }
  }], [{
    key: "fromDef",
    value: function fromDef(objDef) {
      const obj = _get(_getPrototypeOf(RollingSign), "fromDef", this).call(this, objDef);
      obj.args.width = objDef.width;
      obj.args.height = objDef.height;
      return obj;
    }
  }]);
  return RollingSign;
}(_PointActor2.PointActor);
exports.RollingSign = RollingSign;
});

;require.register("actor/Scratch.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Scratch = void 0;
var _Flickie = require("./Flickie");
var _Mixin = require("curvature/base/Mixin");
var _PointActor = require("./PointActor");
var _Patrol = require("../behavior/Patrol");
var _CanPop = require("../mixin/CanPop");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let Scratch = /*#__PURE__*/function (_Mixin$from) {
  _inherits(Scratch, _Mixin$from);
  var _super = _createSuper(Scratch);
  function Scratch() {
    var _this$args$patrolPaus, _this$args$patrolBeat, _this$args$patrolSpee;
    var _this;
    _classCallCheck(this, Scratch);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.behaviors.add(new _Patrol.Patrol());
    _this.args.type = 'actor-item actor-scratch';
    _this.args.animation = 'standing';
    _this.args.accel = 0.1;
    _this.args.decel = 0.5;
    _this.args.gSpeedMax = 5;
    _this.args.jumpForce = 5;
    _this.args.gravity = 0.5;
    _this.args.width = 32;
    _this.args.height = 39;
    _this.willStick = false;
    _this.stayStuck = false;
    _this.args.patrolPause = (_this$args$patrolPaus = _this.args.patrolPause) !== null && _this$args$patrolPaus !== void 0 ? _this$args$patrolPaus : 20;
    _this.args.patrolBeat = (_this$args$patrolBeat = _this.args.patrolBeat) !== null && _this$args$patrolBeat !== void 0 ? _this$args$patrolBeat : 120;
    _this.args.patrolSpeed = (_this$args$patrolSpee = _this.args.patrolSpeed) !== null && _this$args$patrolSpee !== void 0 ? _this$args$patrolSpee : 1;
    return _this;
  }
  _createClass(Scratch, [{
    key: "onRendered",
    value: function onRendered() {
      _get(_getPrototypeOf(Scratch.prototype), "onRendered", this).call(this);
      this.autoAttr.get(this.box)['data-color'] = 'color';
    }
  }, {
    key: "update",
    value: function update() {
      const direction = this.args.direction;
      const telegraph = this.args.shotTelegraph;
      const beat = this.args.patrolBeat;
      if (this.box) {
        if (this.args.moving && this.args.gSpeed) {
          this.box.setAttribute('data-animation', 'walking');
        } else {
          this.box.setAttribute('data-animation', 'standing');
        }
      }
      _get(_getPrototypeOf(Scratch.prototype), "update", this).call(this);
      this.args.direction = Math.sign(this.args.gSpeed);
    }
  }, {
    key: "effect",
    value: function effect(other) {
      _get(_getPrototypeOf(Scratch.prototype), "effect", this).call(this, other);

      // this.viewport.spawn.add({object:new Flickie({
      // 	x: this.args.x,
      // 	y: this.args.y,
      // })});
    }
  }, {
    key: "solid",
    get: function get() {
      return false;
    }
  }, {
    key: "isEffect",
    get: function get() {
      return false;
    }
    // get controllable() { return true; }
  }]);
  return Scratch;
}(_Mixin.Mixin.from(_PointActor.PointActor, _CanPop.CanPop));
exports.Scratch = Scratch;
});

;require.register("actor/Sean.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Sean = void 0;
var _PointActor2 = require("./PointActor");
var _Tag = require("curvature/base/Tag");
var _SkidDust = require("../behavior/SkidDust");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let Sean = /*#__PURE__*/function (_PointActor) {
  _inherits(Sean, _PointActor);
  var _super = _createSuper(Sean);
  function Sean() {
    var _this;
    _classCallCheck(this, Sean);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.behaviors.add(new _SkidDust.SkidDust());
    _this.args.type = 'actor-item actor-sean';
    _this.args.normalHeight = 35;
    _this.args.rollingHeight = 28;
    _this.args.accel = 0.25;
    _this.args.decel = 0.4;
    _this.args.gSpeedMax = 18;
    _this.args.jumpForce = 11;
    _this.args.gravity = 0.5;
    _this.args.width = 18;
    _this.args.height = 35;
    return _this;
  }
  _createClass(Sean, [{
    key: "onRendered",
    value: function onRendered(event) {
      _get(_getPrototypeOf(Sean.prototype), "onRendered", this).call(this, event);
      this.box = this.findTag('div');
    }
  }, {
    key: "update",
    value: function update() {
      const falling = this.args.falling;
      if (!this.box) {
        _get(_getPrototypeOf(Sean.prototype), "update", this).call(this);
        return;
      }
      if (!falling) {
        if (this.yAxis > 0) {
          this.args.crouching = true;
        } else {
          this.args.crouching = false;
        }
        const direction = this.args.direction;
        const gSpeed = this.args.gSpeed;
        const speed = Math.abs(gSpeed);
        const maxSpeed = this.args.gSpeedMax;
        if (this.args.rolling) {
          this.box.setAttribute('data-animation', 'rolling');
        } else if (Math.sign(this.args.gSpeed) !== direction && Math.abs(this.args.gSpeed - direction) > 5) {
          this.box.setAttribute('data-animation', 'standing');
        } else if (speed > maxSpeed * 0.25) {
          this.box.setAttribute('data-animation', 'running');
        } else if (this.args.moving && gSpeed) {
          this.box.setAttribute('data-animation', 'walking');
        }
        // else if(this.args.crouching || (this.args.standingOn && this.args.standingOn.isVehicle))
        // {
        // 	this.box.setAttribute('data-animation', 'crouching');
        // }
        else {
          this.box.setAttribute('data-animation', 'standing');
        }
      } else if (this.args.jumping) {
        this.box.setAttribute('data-animation', 'jumping');
      }
      _get(_getPrototypeOf(Sean.prototype), "update", this).call(this);
    }
  }, {
    key: "solid",
    get: function get() {
      return false;
    }
  }, {
    key: "canRoll",
    get: function get() {
      return true;
    }
  }, {
    key: "isEffect",
    get: function get() {
      return false;
    }
  }, {
    key: "controllable",
    get: function get() {
      return true;
    }
  }]);
  return Sean;
}(_PointActor2.PointActor);
exports.Sean = Sean;
});

;require.register("actor/SeeSaw.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SeeSaw = void 0;
var _PointActor2 = require("./PointActor");
var _Ring = require("./Ring");
var _Tag = require("curvature/base/Tag");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
const Side = Symbol('Side');
let SeeSaw = /*#__PURE__*/function (_PointActor) {
  _inherits(SeeSaw, _PointActor);
  var _super = _createSuper(SeeSaw);
  function SeeSaw(args, parent) {
    var _this$args$power, _this$args$power2;
    var _this;
    _classCallCheck(this, SeeSaw);
    _this = _super.call(this, args, parent);
    _this.args.width = 96;
    _this.args.height = 32;
    _this.noClip = true;
    _this.args.float = -1;
    _this.args.power = (_this$args$power = _this.args.power) !== null && _this$args$power !== void 0 ? _this$args$power : 20;
    _this.tiltTime = 0;

    // this.args.direction = this.args.direction || 1;

    _this.args.power = (_this$args$power2 = _this.args.power) !== null && _this$args$power2 !== void 0 ? _this$args$power2 : 12;
    _this.args.type = 'actor-item actor-see-saw';
    _this.args.bindTo('tilt', v => {
      _this.args.type = `actor-item actor-see-saw ${v}`;
      _this.tiltTime = 0;
    });
    return _this;
  }
  _createClass(SeeSaw, [{
    key: "onRendered",
    value: function onRendered(event) {
      _get(_getPrototypeOf(SeeSaw.prototype), "onRendered", this).call(this, event);
      if (!this.hub) {
        this.hub = new _Tag.Tag('<div class = "see-saw-hub">');
        this.box.appendChild(this.hub.node);
      }
    }
  }, {
    key: "collideA",
    value: function collideA(other, type) {
      if (other instanceof _Ring.Ring) {
        return;
      }
      if (!other.args.falling || other.args.ySpeed <= 0) {
        return;
      }
      other.args.groundAngle = 0;
      if (Math.abs(other.x - this.x) > 4) {
        const newTilt = Math.sign(other.x - this.x);
        this.reflectImpulse(other, newTilt * other.args.weight * Math.abs(other.args.ySpeed));
        if (other.x < this.x) {
          this.tiltClass = 'tilt-left';
          this.tilt = -1;
        } else if (other.x > this.x) {
          this.tiltClass = 'tilt-right';
          this.tilt = 1;
        }
        this.args.tilt = this.tiltClass;
      }
    }
  }, {
    key: "reflectImpulse",
    value: function reflectImpulse(other, direction) {
      if (this.reflectObject && this.reflectObject.args.falling && !other.args.falling) {
        return;
      }
      if (this.tilt === Math.sign(direction)) {
        return;
      }
      this.reflectObject = other;
      this.reflectForce = direction;
    }
  }, {
    key: "update",
    value: function update() {
      this.tiltTime++;
      _get(_getPrototypeOf(SeeSaw.prototype), "update", this).call(this);
    }
  }, {
    key: "updateEnd",
    value: function updateEnd() {
      _get(_getPrototypeOf(SeeSaw.prototype), "updateEnd", this).call(this);
      const collisions = this.viewport.collisions.get(this);
      if (!collisions) {
        this.reflectObject = null;
        this.reflectForce = 0;
        return;
      }
      for (const other of collisions.keys()) {
        if (other.args.falling) {
          continue;
        }
        other.args.groundAngle = 0;
        const armDist = other.x - this.x;
        const hang = Math.abs(armDist / (this.args.width / 2));
        const otherSide = Math.sign(armDist);
        if (!this.reflectForce || otherSide === Math.sign(this.reflectForce)) {
          continue;
        }
        if (Math.abs(armDist) < 4) {
          continue;
        }
        if (hang < 0.75) {
          other.args.x += armDist / 2;
          other.args.y -= 8;
        }
        const power = Math.abs(this.reflectForce / other.args.weight);
        const torque = Math.min(1, Math.ceil(hang * 3) / 3);
        other.args.gSpeed = 0;
        other.args.xSpeed = 0;
        other.args.ySpeed = Math.min(-6.5, -power * torque * 1.2);
        other.args.y -= 16;
        other.args.falling = true;
      }
      this.reflectObject = null;
      this.reflectForce = 0;
    }
  }]);
  return SeeSaw;
}(_PointActor2.PointActor);
exports.SeeSaw = SeeSaw;
});

;require.register("actor/Seymour.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Seymour = void 0;
var _PointActor2 = require("./PointActor");
var _Tag = require("curvature/base/Tag");
var _Spring = require("./Spring");
var _SkidDust = require("../behavior/SkidDust");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let Seymour = /*#__PURE__*/function (_PointActor) {
  _inherits(Seymour, _PointActor);
  var _super = _createSuper(Seymour);
  function Seymour() {
    var _this;
    _classCallCheck(this, Seymour);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.behaviors.add(new _SkidDust.SkidDust());
    _this.args.type = 'actor-item actor-seymour';
    _this.args.spriteSheet = _this.spriteSheet = '/secret/seymour-color-corrected.png';
    _this.superSpriteSheet = '/secret/super-seymour.png';
    _this.args.normalHeight = 44;
    _this.args.rollingHeight = 23;
    _this.args.accel = 0.25;
    _this.args.decel = 0.4;
    _this.args.gSpeedMax = 18;
    _this.args.jumpForce = 11;
    _this.args.gravity = 0.5;
    _this.args.width = 18;
    _this.args.height = 32;
    return _this;
  }
  _createClass(Seymour, [{
    key: "onRendered",
    value: function onRendered(event) {
      _get(_getPrototypeOf(Seymour.prototype), "onRendered", this).call(this, event);
      this.box = this.findTag('div');
    }
  }, {
    key: "update",
    value: function update() {
      const falling = this.args.falling;
      if (!this.box) {
        _get(_getPrototypeOf(Seymour.prototype), "update", this).call(this);
        return;
      }
      if (!falling) {
        this.springing = false;
        if (this.yAxis > 0) {
          this.args.crouching = true;
        } else {
          this.args.crouching = false;
        }
        const direction = this.args.direction;
        const gSpeed = this.args.gSpeed;
        const speed = Math.abs(gSpeed);
        const maxSpeed = this.args.gSpeedMax;
        if (this.args.rolling) {
          this.args.animation = 'rolling';
        } else if (Math.sign(this.args.gSpeed) !== direction && Math.abs(this.args.gSpeed - direction) > 5) {
          this.args.animation = 'standing';
        } else if (speed > maxSpeed * 0.5) {
          this.args.animation = 'running';
        } else if (this.args.moving && gSpeed) {
          this.args.animation = 'walking';
        }
        // else if(this.args.crouching || (this.args.standingOn && this.args.standingOn.isVehicle))
        // {
        // 	this.box.setAttribute('data-animation', 'crouching');
        // }
        else {
          this.args.animation = 'standing';
        }
      } else if (this.args.jumping) {
        this.args.animation = 'jumping';
      }
      if (this.args.falling && this.springing) {
        this.args.groundAngle = 0;
        this.args.animation = 'springing';
      }
      _get(_getPrototypeOf(Seymour.prototype), "update", this).call(this);
    }
  }, {
    key: "command_3",
    value: function command_3() {
      this.isSuper = !this.isSuper;
      this.onTimeout(150, () => {
        if (this.args.rings === 0) {
          // this.isSuper = false;
          this.setProfile();
        }
        ;
      });
      this.setProfile();
    }
  }, {
    key: "setProfile",
    value: function setProfile() {
      if (this.isSuper) {
        this.args.spriteSheet = this.superSpriteSheet;

        // this.args.gSpeedMax = this.gSpeedMaxSuper;
        // this.args.jumpForce = this.jumpForceSuper;
        // this.args.accel     = this.accelSuper;
      } else {
        this.args.spriteSheet = this.spriteSheet;

        // this.args.gSpeedMax = this.gSpeedMaxNormal;
        // this.args.jumpForce = this.jumpForceNormal;
        // this.args.accel     = this.accelNormal;
      }
    }
  }, {
    key: "collideA",
    value: function collideA(other) {
      if (other instanceof _Spring.Spring) {
        this.onNextFrame(() => {
          if (!this.args.falling) {
            return;
          }
          this.springing = true;
          this.args.animation = 'springing';
        });
      }
    }
  }, {
    key: "solid",
    get: function get() {
      return false;
    }
  }, {
    key: "canRoll",
    get: function get() {
      return true;
    }
  }, {
    key: "isEffect",
    get: function get() {
      return false;
    }
  }, {
    key: "controllable",
    get: function get() {
      return true;
    }
  }]);
  return Seymour;
}(_PointActor2.PointActor);
exports.Seymour = Seymour;
});

;require.register("actor/Signpost.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Signpost = void 0;
var _CharacterString = require("../ui/CharacterString");
var _PointActor2 = require("./PointActor");
var _Tag = require("curvature/base/Tag");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let Signpost = /*#__PURE__*/function (_PointActor) {
  _inherits(Signpost, _PointActor);
  var _super = _createSuper(Signpost);
  function Signpost() {
    var _this;
    _classCallCheck(this, Signpost);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.type = 'actor-item actor-signpost';
    _this.args.width = 48;
    _this.args.height = 256;
    _this.args.active = false;
    _this.args.follow = false;
    _this.args.activeTime = 0;
    _this.cleared = false;
    _this.willActivate = false;
    _this.clearedBy = null;
    return _this;
  }
  _createClass(Signpost, [{
    key: "collideA",
    value: function collideA(other) {
      if (!other.controllable || this.args.active) {
        return;
      }
      this.willActivate = true;
      this.viewport.onFrameOut(10, () => {
        this.args.active = true;
        this.clearedBy = other;
      });
      if (this.following) {
        return;
      }
      this.viewport.clearCheckpoints();
      if (!this.finishReward && other.args.popChain.length) {
        this.finishReward = {
          label: 'Big Finish',
          points: 1000,
          multiplier: 1,
          color: 'yellow'
        };
        other.args.popChain.push(this.finishReward);
      }
      const yardsPerFrame = (other.args.gSpeed || other.args.xSpeed) / 32;
      const feetPerSecond = yardsPerFrame * 60 * 3;
      other.args.clearSpeed = Math.abs(feetPerSecond);
      this.args.charStrings.push(new _CharacterString.CharacterString({
        value: `Speed: ${feetPerSecond.toFixed(2)} ft/sec`
      }));
      this.following = other;
      this.args.falling = true;
      this.args.follow = true;
      this.args.xSpeed = (other.args.gSpeed || other.args.xSpeed) * 1.1;
      this.args.ySpeed = -7;
      this.args.y--;
    }
  }, {
    key: "clear",
    value: function clear(other) {
      let showZonecard = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      this.cleared = true;
      other.totalCombo();
      this.box.setAttribute('data-cleared-by', other.args.name);
      this.tally = this.viewport.clearAct(`${other.args.name} GOT THROUGH\n${this.viewport.args.actName}`, showZonecard);
      this.viewport.onFrameOut(30, () => {
        this.args.follow = false;
        if (!this.args.boss) {
          return;
        }
      });
      this.viewport.onFrameOut(600, () => {
        if (!this.args.boss) {
          return;
        }
        const boss = this.viewport.actorsById[this.args.boss];
        this.viewport.auras.add(boss);
        boss.args.x = this.x + (this.x < 125000 ? 768 : -768);
        boss.args.y = this.y - 144;
        if (this.viewport.controlActor && this.viewport.controlActor.args.jumpForce < 10.5) {
          boss.args.y += 48;
        }
        boss.args.phase = 'intro';
        other.args.clearSpeed = 0;
      });
    }
  }, {
    key: "update",
    value: function update() {
      if (this.args.active) {
        this.args.activeTime++;
      }
      if (this.args.follow) {
        const other = this.following;
        if (other.skidding && !other.args.rolling && !other.args.falling) {
          if (!this.args.xStart) {
            this.skidLabel = new _CharacterString.CharacterString({
              value: `Skid: 0`
            });
            this.args.xStart = this.x;
            this.args.charStrings.push(this.skidLabel);
          }
          this.args.dragged = Math.trunc(Math.abs(this.args.xStart - this.x));
          this.skidLabel.args.value = `Skid: ${this.args.dragged}`;
          other.args.dragBonus = this.args.dragged;
        }
        const toX = Math.max(this.x, this.viewport.controlActor.x + -160);
        if (toX !== this.x) {
          if (!this.args.falling) {
            const dustParticle = new _Tag.Tag(`<div class = "particle-dust">`);
            const dustPoint = this.rotatePoint(this.args.gSpeed, 0);
            dustParticle.style({
              '--x': dustPoint[0] + this.x + -4,
              '--y': dustPoint[1] + this.y,
              'z-index': 0,
              opacity: Math.random() * 2
            });
            const viewport = this.viewport;
            viewport.particles.add(dustParticle);
            viewport.onFrameOut(30, () => viewport.particles.remove(dustParticle));
          }
          other.args.rolling = false;
          this.args.x = toX;
          while (this.getMapSolidAt(this.x, this.y - 1)) {
            this.args.y--;
          }
        }
      }
      _get(_getPrototypeOf(Signpost.prototype), "update", this).call(this);
      if (this.args.active && !this.cleared) {
        this.clear(this.clearedBy);
      }
    }
  }, {
    key: "rotateLock",
    get: function get() {
      return true;
    }
  }]);
  return Signpost;
}(_PointActor2.PointActor);
exports.Signpost = Signpost;
});

;require.register("actor/SkateBoard.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SkateBoard = void 0;
var _SnowBoard2 = require("./SnowBoard");
var _Tag = require("curvature/base/Tag");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let SkateBoard = /*#__PURE__*/function (_SnowBoard) {
  _inherits(SkateBoard, _SnowBoard);
  var _super = _createSuper(SkateBoard);
  function SkateBoard() {
    var _this;
    _classCallCheck(this, SkateBoard);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.height = 10;
    _this.args.width = 12;
    _this.args.seatHeight = 12;
    _this.sparks = new Set();
    _this.args.accelOrig = 0.5;
    _this.args.decelOrig = 0.6;
    _this.args.decel = 0.6;
    _this.args.accel = 0.8;
    _this.args.gravity = 0.65;
    _this.args.skidTraction = 0.85;
    _this.args.jumpForce = 12.5;
    _this.args.type = 'actor-item actor-snow-board actor-skate-board';
    _this.args.trick = null;
    _this.args.seatAngle = 0;
    _this.args.gSpeedMax = 18;
    _this.trickTimer = 0;
    _this.flipReward = false;
    _this.args.rotated = 0;
    _this.canGrind = true;
    _this.fakie = false;
    _this.silentSkid = true;

    // this.args.gravity = 0.1;

    _this.bindTo('occupant', v => {
      if (!v) return;
      _this.args.gSpeed = v.xSpeedLast || 0;
    });
    _this.args.bindTo('trick', v => {
      if (!_this.args.falling && v !== 'manual') {
        return;
      }
      if (!v || _this.args.grinding) {
        return;
      }
      const reward = {
        label: '',
        points: 100,
        multiplier: 1
      };
      switch (v) {
        case 'insult':
          reward.label = (_this.fakie ? 'fakie ' : '') + 'leanback';
          _this.occupant.args.popChain.push(reward);
          _this.occupant.args.popCombo += 1;
          break;
        case 'handstand':
          reward.label = (_this.fakie ? 'fakie ' : '') + 'handstand';
          _this.occupant.args.popChain.push(reward);
          _this.occupant.args.popCombo += 1;
          break;
        case 'manual':
          if (_this.occupant.args.popCombo) {
            reward.label = (_this.fakie ? 'fakie ' : '') + 'manual';
            _this.occupant.args.popChain.push(reward);
            _this.occupant.args.popCombo += 1;
          }
          break;
      }
    });
    return _this;
  }
  _createClass(SkateBoard, [{
    key: "update",
    value: function update() {
      if (!this.args.falling) {
        this.args.rolling = this.args.mode === 1 && this.args.gSpeed > 0 || this.args.mode === 3 && this.args.gSpeed < 0 || Math.sign(this.args.gSpeed) === Math.sign(this.args.direction) && !this.xAxis;

        // this.args.hLock = false;
      } else {
        if (this.args.jumping && this.fallTime === 1) {
          this.args.groundAngle += Math.PI / 8;
        }

        // this.args.hLock   = this.modeLast === 0;
        this.args.rolling = false;
      }
      if (!this.args.falling) {
        this.flipReward = false;
      }
      if (!this.occupant) {
        this.args.width = 64;
        this.args.height = 12;
      } else {
        this.args.width = 24;
        this.args.height = 40;
      }
      if (this.trickTimer > 0) {
        this.trickTimer--;
      } else {
        this.args.trick = null;
        this.trickTimer = 0;
      }

      // if(this.args.falling && Math.abs(this.yAxis) > 0.55)
      // {
      // 	const dir = (this.args.facing === 'left'?-1:1);

      // 	if(this.yAxis)
      // 	{
      // 		this.args.groundAngle += 0.1 * this.yAxis * dir;
      // 	}

      // 	if(this.yAxis > 0 && Math.abs(this.args.groundAngle) > Math.PI * 2)
      // 	{
      // 		const reward = {label:(this.fakie ? 'fakie ' : '') + 'backflip', points:100, multiplier:1};
      // 		this.occupant.args.popChain.push(reward);
      // 		this.occupant.args.popCombo += 1;
      // 		this.flipReward = true;

      // 		console.log(reward);

      // 		this.args.groundAngle = 0;
      // 	}
      // 	else if(this.yAxis < 0 && Math.abs(this.args.groundAngle) > Math.PI * 2)
      // 	{
      // 		const reward = {label:(this.fakie ? 'fakie ' : '') + 'frontflip', points:100, multiplier:1};
      // 		this.occupant.args.popChain.push(reward);
      // 		this.occupant.args.popCombo += 1;
      // 		this.flipReward = true;

      // 		console.log(reward);

      // 		this.args.groundAngle = 0;
      // 	}
      // }

      _get(_getPrototypeOf(SkateBoard.prototype), "update", this).call(this);
      if (this.args.falling) {
        this.args.rotated = this.args.groundAngle;
      } else {
        this.fakie = this.args.reversing;

        // if(this.groundTime === 2 && this.occupant)
        // {
        // 	const occupant = this.occupant;

        // 	let dropAngle = this.realAngle;
        // 	let rotated = this.args.rotated;

        // 	while(rotated < 0)
        // 	{
        // 		rotated += Math.PI * 2;
        // 	}

        // 	while(rotated > Math.PI * 2)
        // 	{
        // 		rotated -= Math.PI * 2;
        // 	}

        // 	while(dropAngle < 0)
        // 	{
        // 		dropAngle += Math.PI * 2;
        // 	}

        // 	while(dropAngle > Math.PI * 2)
        // 	{
        // 		dropAngle -= Math.PI * 2;
        // 	}

        // 	// console.log(this.args.rotated, rotated, dropAngle);

        // 	// const diff = Math.abs(rotated - dropAngle);
        // 	// const upsidedown = Math.abs(rotated - Math.PI);

        // 	// if((rotated && (diff > Math.PI)) || upsidedown < Math.PI * 0.25)
        // 	// {
        // 	// 	this.ignores.set(occupant, 30);
        // 	// 	occupant.args.standingOn  = null;
        // 	// 	occupant.args.groundAngle = 0;
        // 	// 	occupant.args.y -= Math.max(0, occupant.args.height * Math.cos(this.args.groundAngle));
        // 	// 	occupant.startle();

        // 	// 	occupant.totalCombo(false);
        // 	// }

        // 	// console.log({rotated, dropAngle, diff, upsidedown, a: (diff > Math.PI), b: upsidedown < Math.PI * 0.35});

        // 	// this.args.rotated = 0;
        // }
      }

      if (this.occupant && !this.trickTimer && !this.args.grinding && this.groundTime > 1 && this.args.trick !== 'manual') {
        this.occupant.totalCombo();
        this.args.trick = null;
      }
      this.ridingAnimation = this.args.gSpeed || this.args.xSpeed || this.args.ySpeed ? 'grinding' : 'standing';
      if (this.idleTime > 30) {
        this.ridingAnimation = 'idle';
      }
      this.crouching = false;
      if (this.yAxis > 0.55 && !this.args.falling) {
        this.ridingAnimation = 'grinding-crouching';
        this.crouching = true;
      }
      this.args.accel = this.args.accelOrig;
      this.args.decel = this.args.decelOrig;
      if (this.crouching) {
        // this.args.accel = accelOrig;
        this.args.decel = 0.1;
      }
      this.args.animation = 'idle-2';
      if (this.args.trick === 'handstand') {
        this.ridingAnimation = 'handstand';
        if (this.trickTimer > 20 || this.trickTimer < 10) {
          this.ridingAnimation = 'flip';
        }
      }
      if (!this.args.grinding && this.grindReward) {
        this.grindReward = null;
      }
      if (this.args.grinding) {
        this.ridingAnimation = 'board-grinding';
        this.args.animation = 'grinding';
        if (this.occupant && this.occupant.args.popCombo) {
          if (!this.grindReward) {
            const reward = {
              label: (this.fakie ? 'fakie ' : '') + 'rail grind',
              points: 100,
              multiplier: 1
            };
            this.grindReward = reward;
            this.occupant.args.popChain.push(reward);
            this.occupant.args.popCombo += 1;
          } else {
            this.grindReward.points += 10;
          }
        }
      } else if (this.args.trick === 'manual' && !this.args.falling) {
        this.ridingAnimation = 'manual';
        this.args.animation = 'manual';
      } else if (this.args.trick === 'insult') {
        this.ridingAnimation = 'insult';
      }
      if (this.args.grinding && !this.args.falling) {
        // `<div class = "particle-sparks">`

        const sparkTag = document.createElement('div');
        sparkTag.classList.add('particle-sparks');
        const sparkParticle = new _Tag.Tag(sparkTag);

        // `<div class = "envelope-sparks">`
        const envelopeTag = document.createElement('div');
        envelopeTag.classList.add('envelope-sparks');
        const sparkEnvelope = new _Tag.Tag(envelopeTag);
        sparkEnvelope.appendChild(sparkParticle.node);
        const sparkPoint = this.rotatePoint(10 * 1.75 * this.args.direction, 8);
        const flip = Math.sign(this.args.gSpeed);
        sparkEnvelope.style({
          '--x': sparkPoint[0] + this.args.x,
          '--y': sparkPoint[1] + this.args.y + Math.random() * -3,
          'z-index': 0,
          'animation-delay': -Math.random() * 0.25 + 's',
          '--xMomentum': Math.max(Math.abs(this.args.gSpeed), 4) * flip,
          '--flip': flip,
          '--angle': this.realAngle,
          opacity: Math.random() * 2
        });
        sparkEnvelope.particle = sparkParticle;
        this.viewport.particles.add(sparkEnvelope);
        this.sparks.add(sparkEnvelope);
        const viewport = this.viewport;
        this.viewport.onFrameOut(30, () => {
          viewport.particles.remove(sparkEnvelope);
          this.sparks.delete(sparkEnvelope);
        });
      }
    }
  }, {
    key: "command_1",
    value: function command_1() {
      if (this.args.grinding) {
        return;
      }
      if (this.trickTimer > 10) {
        return;
      }
      this.args.trick = 'insult';
      this.trickTimer = 30;
    }
  }, {
    key: "hold_1",
    value: function hold_1() {
      if (this.trickTimer > 10 || this.args.trick !== 'insult') {
        return;
      }
      this.trickTimer = Math.max(15, this.trickTimer);
      this.idleTime = 10;
    }
  }, {
    key: "release_1",
    value: function release_1() {
      if (this.args.trick !== 'insult') {
        return;
      }
      this.args.trick = 'insult';
      this.trickTimer = 10;
    }
  }, {
    key: "command_2",
    value: function command_2() {
      if (this.trickTimer > 10) {
        return;
      }
      this.args.trick = 'handstand';
      this.trickTimer = 30;
    }
  }, {
    key: "hold_2",
    value: function hold_2() {
      if (this.trickTimer > 10 || this.args.trick !== 'handstand') {
        return;
      }
      this.args.trick = 'handstand';
      this.trickTimer = Math.max(15, this.trickTimer);
      this.idleTime = 10;
    }
  }, {
    key: "release_2",
    value: function release_2() {
      if (this.args.trick !== 'handstand') {
        return;
      }
      this.trickTimer = 10;
    }
  }, {
    key: "command_3",
    value: function command_3() {
      if (this.args.grinding) {
        return;
      }
      if (this.args.trick && this.args.falling && this.args.trick !== 'manual') {
        return;
      }
      if (this.trickTimer > 10) {
        return;
      }
      this.args.trick = 'manual';
      this.trickTimer = 30;
    }
  }, {
    key: "hold_3",
    value: function hold_3() {
      if (this.args.falling && this.args.trick === 'manual') {
        this.trickTimer = Math.max(15, this.trickTimer);
        return;
      }
      if (this.args.falling || this.args.trick !== 'manual') {
        return;
      }
      if (this.trickTimer > 10 && this.args.trick !== 'manual') {
        return;
      }
      this.args.trick = 'manual';
      this.trickTimer = Math.max(15, this.trickTimer);
      this.idleTime = 10;
    }
  }, {
    key: "release_3",
    value: function release_3() {
      if (this.args.trick !== 'manual') {
        return;
      }
      this.args.trick = 'manual';
      this.trickTimer = 10;
    }
  }]);
  return SkateBoard;
}(_SnowBoard2.SnowBoard);
exports.SkateBoard = SkateBoard;
});

;require.register("actor/Skorp.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Skorp = void 0;
var _Tag = require("curvature/base/Tag");
var _Flickie = require("./Flickie");
var _Mixin = require("curvature/base/Mixin");
var _PointActor = require("./PointActor");
var _Patrol = require("../behavior/Patrol");
var _CanPop = require("../mixin/CanPop");
var _Projectile = require("../actor/Projectile");
var _Sfx = require("../audio/Sfx");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let Skorp = /*#__PURE__*/function (_Mixin$from) {
  _inherits(Skorp, _Mixin$from);
  var _super = _createSuper(Skorp);
  function Skorp() {
    var _this$args$color, _this$args$patrolPaus, _this$args$patrolBeat, _this$args$patrolSpee;
    var _this;
    _classCallCheck(this, Skorp);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.behaviors.add(new _Patrol.Patrol());
    _this.args.type = 'actor-item actor-skorp';
    _this.args.animation = 'standing';
    _this.args.accel = 0.1;
    _this.args.decel = 0.5;
    _this.args.gSpeedMax = 5;
    _this.args.jumpForce = 5;
    _this.args.gravity = 0.5;
    _this.args.width = 24;
    _this.args.height = 32;
    _this.args.color = (_this$args$color = _this.args.color) !== null && _this$args$color !== void 0 ? _this$args$color : 'green';
    _this.willStick = false;
    _this.stayStuck = false;
    _this.args.patrolPause = (_this$args$patrolPaus = _this.args.patrolPause) !== null && _this$args$patrolPaus !== void 0 ? _this$args$patrolPaus : 20;
    _this.args.patrolBeat = (_this$args$patrolBeat = _this.args.patrolBeat) !== null && _this$args$patrolBeat !== void 0 ? _this$args$patrolBeat : 120;
    _this.args.patrolSpeed = (_this$args$patrolSpee = _this.args.patrolSpeed) !== null && _this$args$patrolSpee !== void 0 ? _this$args$patrolSpee : 1;
    _this.args.segmentCount = 5;
    _this.args.segmentAngle = Math.PI / 2;
    _this.aggroCount = 0;
    _this.coolDown = 0;
    _this.args.shooting = 0;
    return _this;
  }
  _createClass(Skorp, [{
    key: "onRendered",
    value: function onRendered() {
      _get(_getPrototypeOf(Skorp.prototype), "onRendered", this).call(this);
      this.autoAttr.get(this.box)['data-color'] = 'color';
      this.autoAttr.get(this.box)['data-shooting'] = 'shooting';
      this.autoAttr.get(this.box)['data-aiming'] = 'aimDirection';
      this.autoStyle.get(this.box)['--segments'] = 'segmentCount';
      this.autoStyle.get(this.box)['--segmentAngle'] = 'segmentAngle';
      this.autoStyle.get(this.box)['--aim-direction'] = 'aimDirection';
      this.autoStyle.get(this.box)['--tail-angle'] = 'tailAngle';
      if (!this.tail) {
        this.tail = new _Tag.Tag(`<div class = "tail">`);
        const segments = [new _Tag.Tag(`<div   class = "segment" style = "--index:0">`), new _Tag.Tag(`<div class = "segment" style = "--index:1">`), new _Tag.Tag(`<div class = "segment" style = "--index:2">`), new _Tag.Tag(`<div class = "segment" style = "--index:3">`), new _Tag.Tag(`<div class = "segment" style = "--index:4">`), new _Tag.Tag(`<div class = "end gun" style = "--index:5">`)];
        let lastSegment;
        for (const segment of segments) {
          if (!lastSegment) {
            this.tail.append(segment.node);
          } else {
            lastSegment.append(segment.node);
          }
          lastSegment = segment;
        }
        this.box.appendChild(this.tail.node);
      }
    }
  }, {
    key: "update",
    value: function update() {
      const direction = this.args.direction;
      const telegraph = this.args.shotTelegraph;
      const beat = this.args.patrolBeat;
      if (this.box) {
        if (this.args.moving && this.args.gSpeed) {
          this.box.setAttribute('data-animation', 'walking');
        } else {
          this.box.setAttribute('data-animation', 'standing');
        }
      }
      const maxDist = 256;
      const leftDist = this.castRayQuick(maxDist, Math.PI, [0, -16], false) || maxDist;
      const rightDist = this.castRayQuick(maxDist, 0, [0, -16], false) || maxDist;
      const leftActors = this.viewport.actorsAtLine(this.x, this.y - 16, this.x - leftDist, this.y + -16);
      const rightActors = this.viewport.actorsAtLine(this.x, this.y - 16, this.x + rightDist, this.y + -16);
      const leftFiltered = [...leftActors.keys()].filter(a => a.controllable);
      const rightFiltered = [...rightActors.keys()].filter(a => a.controllable);
      if (leftFiltered.length) {
        this.args.aimDirection = -1;
      } else if (rightFiltered.length) {
        this.args.aimDirection = 1;
      } else {
        this.args.aimDirection = 0;
      }
      if (this.args.aimDirection) {
        if (this.args.aimDirection !== this.args.direction) {
          this.args.tailAngle = -19 * this.args.aimDirection;
        } else {
          this.args.tailAngle = -21 * this.args.aimDirection;
        }
        this.coolDown = 30;
        this.aggroCount++;
      } else {
        if (this.coolDown <= 0) {
          this.args.tailAngle = -8 * this.args.direction;
          if (!this.args.gSpeed) {
            this.args.tailAngle = 0;
          }
        } else {
          this.coolDown--;
        }
        this.aggroCount = 0;
      }
      if (this.aggroCount > 20) {
        if (this.args.aimDirection !== this.args.direction) {
          const ball = new _Projectile.Projectile({
            x: this.args.x + 60 * this.args.aimDirection,
            y: this.args.y - 28,
            xSpeed: 4 * this.args.aimDirection,
            ySpeed: 0.55,
            float: -1,
            owner: this
          });
          this.viewport.spawn.add({
            object: ball
          });
          this.aggroCount = 10;
          this.args.shooting = 6;
          _Sfx.Sfx.play('SHOT_FIRED');
        } else {
          const ball = new _Projectile.Projectile({
            x: this.args.x + 54 * this.args.aimDirection,
            y: this.args.y - 42,
            xSpeed: 4 * this.args.aimDirection,
            ySpeed: 0.55,
            float: -1,
            owner: this
          });
          this.viewport.spawn.add({
            object: ball
          });
          this.aggroCount = 10;
          this.args.shooting = 6;
          _Sfx.Sfx.play('SHOT_FIRED');
        }
      } else if (this.args.shooting > 0) {
        this.args.shooting--;
      }
      _get(_getPrototypeOf(Skorp.prototype), "update", this).call(this);
      this.args.direction = Math.sign(this.args.gSpeed) || this.args.direction;
    }
  }, {
    key: "effect",
    value: function effect(other) {
      _get(_getPrototypeOf(Skorp.prototype), "effect", this).call(this, other);

      // this.viewport.spawn.add({object:new Flickie({
      // 	x: this.args.x,
      // 	y: this.args.y,
      // })});
    }
  }, {
    key: "solid",
    get: function get() {
      return false;
    }
  }, {
    key: "isEffect",
    get: function get() {
      return false;
    }
    // get controllable() { return true; }
  }]);
  return Skorp;
}(_Mixin.Mixin.from(_PointActor.PointActor, _CanPop.CanPop));
exports.Skorp = Skorp;
});

;require.register("actor/Skull.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Skull = void 0;
var _PointActor2 = require("./PointActor");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let Skull = /*#__PURE__*/function (_PointActor) {
  _inherits(Skull, _PointActor);
  var _super = _createSuper(Skull);
  function Skull() {
    var _this;
    _classCallCheck(this, Skull);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.width = 17;
    _this.args.height = 15;
    _this.args.type = 'actor-item actor-skull';
    _this.bindTo('carriedBy', carrier => {
      if (_this.cX) {
        _this.cX();
        _this.cX = null;
      }
      if (_this.cY) {
        _this.cY();
        _this.cY = null;
      }
      if (carrier) {
        _this.cX = carrier.args.bindTo('x', v => _this.args.x = v + carrier.args.direction * 8);
        _this.cY = carrier.args.bindTo('y', v => _this.args.y = v + -16);
        carrier.carrying.add(_assertThisInitialized(_this));
        _this.args.float = -1;
      } else if (_this.carriedBy) {
        const carrier = _this.carriedBy;
        _this.carriedBy = null;
        _this.args.xSpeed = carrier.args.xSpeed;
        _this.args.ySpeed = carrier.args.ySpeed;
        _this.args.xSpeed += Math.sign(carrier.args.gSpeed || carrier.args.xSpeed) * 4;
        _this.args.ySpeed -= 4;
        carrier.carrying.delete(_assertThisInitialized(_this));
        _this.args.falling = true;
        _this.args.float = 0;
      }
    });
    return _this;
  }
  _createClass(Skull, [{
    key: "lift",
    value: function lift(actor) {
      if (this.carriedBy === actor) {
        this.carriedBy = null;
        return;
      }
      this.carriedBy = actor;
    }
  }, {
    key: "solid",
    get: function get() {
      return false;
    }
  }]);
  return Skull;
}(_PointActor2.PointActor);
exports.Skull = Skull;
});

;require.register("actor/SlotMachine.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SlotMachine = void 0;
var _Tag = require("curvature/base/Tag");
var _Sfx = require("../audio/Sfx");
var _PointActor2 = require("./PointActor");
var _Ring = require("./Ring");
var _AntiRing = require("./AntiRing");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let SlotMachine = /*#__PURE__*/function (_PointActor) {
  _inherits(SlotMachine, _PointActor);
  var _super = _createSuper(SlotMachine);
  function SlotMachine() {
    var _this;
    _classCallCheck(this, SlotMachine);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.width = 96;
    _this.args.height = 32;
    _this.args.type = 'actor-item actor-slot-machine';
    _this.args.float = -1;
    return _this;
  }
  _createClass(SlotMachine, [{
    key: "onRendered",
    value: function onRendered(event) {
      _get(_getPrototypeOf(SlotMachine.prototype), "onRendered", this).call(this, event);
      if (!this.boxes) {
        this.boxes = [new _Tag.Tag(`<div class = "slot-panel slot-panel-a">`), new _Tag.Tag(`<div class = "slot-panel slot-panel-b">`), new _Tag.Tag(`<div class = "slot-panel slot-panel-c">`)];
        this.boxes.forEach(box => this.box.appendChild(box.node));
      }
    }
  }, {
    key: "dropDelay",
    value: function dropDelay(other) {
      if (!other.controllable) {
        return;
      }
      this.args.type = 'actor-item actor-slot-machine actor-slot-machine-rolling';
      const pos = Symbol;
      const hand = Array(8).fill(0);
      const result = this.boxes.map(box => {
        box[pos] = box[pos] || 0;
        const scrollTo = 32 + box[pos] + Math.floor(Math.random() * 8);
        box.style({
          '--scrollTo': scrollTo * 32 + 'px'
        });
        box[pos] = scrollTo;
        return box[pos] % 8;
      });
      result.forEach(v => hand[v]++);
      return new Promise(accept => {
        this.viewport.onFrameOut(85, () => {
          this.args.type = 'actor-item actor-slot-machine';
          if (hand[0] === 1) {
            this.onTimeout(30, () => _Sfx.Sfx.play('FAIL'));
            if (other.args.rings > 50) {
              return this.punish(other, 10).then(accept);
            }
            return accept();
          } else if (hand[0] === 2) {
            return this.punish(other, 50).then(accept);
            return accept();
          } else if (hand[0] === 3) {
            if (other.args.rings > 0) {
              other.args.rings = 0;
            } else {
              return this.punish(other, 100).then(accept);
            }
            return accept();
          } else if (hand[5] === 2) {
            return this.reward(other, 25).then(accept);
          } else if (hand[5] === 3) {
            return this.reward(other, 100).then(accept);
          } else if (hand[6] === 2) {
            return this.reward(other, 50).then(accept);
          } else if (hand[6] === 3) {
            return this.reward(other, 75).then(accept);
          } else if (hand[7] === 2) {
            return this.reward(other, 15).then(accept);
          } else if (hand[7] === 3) {
            return this.reward(other, 20).then(accept);
          } else if (hand[2] === 3 || hand[3] === 3 || hand[4] === 3) {
            return this.reward(other, 50).then(accept);
          } else if (hand[1] === 1) {
            return this.reward(other, 2).then(accept);
          } else if (hand[1] === 2) {
            return this.reward(other, 30).then(accept);
          } else if (hand[1] === 3) {
            return this.reward(other, 60).then(accept);
          }
          accept();
        });
      });
    }
  }, {
    key: "reward",
    value: function reward(other) {
      let amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;
      const viewport = this.viewport;
      let angle = -1.57;
      for (let i = 0; i < amount; i++) {
        const cos = Math.cos(angle);
        const sin = Math.sin(angle);
        const ring = new _Ring.Ring({
          x: other.x + cos * 288,
          y: other.y + sin * 288,
          xSpeed: -cos * 7,
          ySpeed: -sin * 7,
          static: false,
          reward: true,
          noClip: true,
          float: -1
        });
        viewport.spawn.add({
          object: ring,
          frame: i * 3 + viewport.args.frameId
        });
        angle += Math.PI + (i % 2 ? 0.3 : 0);
      }
      return new Promise(accept => viewport.onFrameOut((16 + amount) * 3, () => accept()));
    }
  }, {
    key: "punish",
    value: function punish(other, amount) {
      _Sfx.Sfx.play('FAIL');
      const viewport = this.viewport;
      let angle = -1.57;
      for (let i = 0; i < amount; i++) {
        const cos = Math.cos(angle);
        const sin = Math.sin(angle);
        const ring = new _AntiRing.AntiRing({
          x: other.x + cos * 288,
          y: other.y + sin * 288,
          xSpeed: -cos * 7,
          ySpeed: -sin * 7,
          static: false,
          reward: true,
          noClip: true,
          float: -1
        });
        viewport.spawn.add({
          object: ring,
          frame: i * 3 + viewport.args.frameId
        });
        angle -= Math.PI + (i % 2 ? 0.3 : 0);
      }
      return new Promise(accept => viewport.onFrameOut((16 + amount) * 3, () => accept()));
    }
  }, {
    key: "solid",
    get: function get() {
      return false;
    }
  }]);
  return SlotMachine;
}(_PointActor2.PointActor);
/*
0 - robotnik
1 - ring
2 - tails
3 - knuckles
4 - sonic
5 - jackpot
6 - emerald
7 - bar
*/
exports.SlotMachine = SlotMachine;
});

;require.register("actor/SnailBot.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SnailBot = void 0;
var _Mixin = require("curvature/base/Mixin");
var _PointActor = require("./PointActor");
var _Patrol = require("../behavior/Patrol");
var _CanPop = require("../mixin/CanPop");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let SnailBot = /*#__PURE__*/function (_Mixin$from) {
  _inherits(SnailBot, _Mixin$from);
  var _super = _createSuper(SnailBot);
  function SnailBot() {
    var _this$args$patrolPaus, _this$args$patrolBeat, _this$args$patrolSpee;
    var _this;
    _classCallCheck(this, SnailBot);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.behaviors.add(new _Patrol.Patrol());
    _this.args.type = 'actor-item actor-snailbot';
    _this.args.animation = 'standing';
    _this.args.accel = 0.1;
    _this.args.decel = 0.5;
    _this.args.gSpeedMax = 5;
    _this.args.gravity = 0.5;
    _this.args.width = 24;
    _this.args.height = 32;
    _this.willStick = false;
    _this.stayStuck = false;
    _this.args.patrolPause = (_this$args$patrolPaus = _this.args.patrolPause) !== null && _this$args$patrolPaus !== void 0 ? _this$args$patrolPaus : 20;
    _this.args.patrolBeat = (_this$args$patrolBeat = _this.args.patrolBeat) !== null && _this$args$patrolBeat !== void 0 ? _this$args$patrolBeat : 100;
    _this.args.patrolSpeed = (_this$args$patrolSpee = _this.args.patrolSpeed) !== null && _this$args$patrolSpee !== void 0 ? _this$args$patrolSpee : 1;
    return _this;
  }
  _createClass(SnailBot, [{
    key: "update",
    value: function update() {
      _get(_getPrototypeOf(SnailBot.prototype), "update", this).call(this);
      if (this.args.moving && this.args.gSpeed) {
        this.args.animation = 'walking';
      } else {
        this.args.animation = 'standing';
      }
      this.args.direction = Math.sign(this.args.gSpeed);
    }
  }, {
    key: "solid",
    get: function get() {
      return false;
    }
  }, {
    key: "isEffect",
    get: function get() {
      return false;
    }
  }]);
  return SnailBot;
}(_Mixin.Mixin.from(_PointActor.PointActor, _CanPop.CanPop));
exports.SnailBot = SnailBot;
});

;require.register("actor/SnowBoard.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SnowBoard = void 0;
var _Vehicle2 = require("./Vehicle");
var _Tag = require("curvature/base/Tag");
var _SkidDust = require("../behavior/SkidDust");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let SnowBoard = /*#__PURE__*/function (_Vehicle) {
  _inherits(SnowBoard, _Vehicle);
  var _super = _createSuper(SnowBoard);
  function SnowBoard() {
    var _this;
    _classCallCheck(this, SnowBoard);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.behaviors.add(new _SkidDust.SkidDust('particle-dust'));
    _this.args.type = 'actor-item actor-snow-board';
    _this.args.width = 24;
    _this.args.height = 32;
    _this.removeTimer = null;
    _this.args.gSpeedMax = 15;
    _this.args.decel = 0.25;
    _this.args.accel = 0.75;
    _this.args.gravity = 0.75;
    // this.args.ignore    = -1;

    _this.args.seatHeight = 1;
    _this.args.skidTraction = 0.5;
    _this.args.jumpForce = 9.5;
    _this.dustCount = 0;
    _this.args.particleScale = 2;
    _this.args.started = false;
    _this.ridingAnimation = 'grinding';
    // this.alwaysSkidding  = true;
    _this.dustDist = -16;
    _this.dustFreq = 1;
    _this.broad = true;
    _this.slowSpin = true;
    _this.addEventListener('jump', event => {
      _this.args.groundAngle += Math.PI * 0.125 * Math.sign(_this.args.gSpeed || _this.args.direction);
    });
    return _this;
  }
  _createClass(SnowBoard, [{
    key: "update",
    value: function update() {
      this.originalSpeed = this.args.gSpeed || this.args.xSpeed;
      _get(_getPrototypeOf(SnowBoard.prototype), "update", this).call(this);
      if (this.occupant) {
        this.args.z = this.occupant.args.z - 1;
      }
      if (this.args.gSpeed !== 0 || this.args.xSpeed !== 0) {
        this.sprite.classList.add('moving');
        this.args.started = true;
      }
    }
  }, {
    key: "solid",
    get: function get() {
      return !this.occupant;
    }
  }]);
  return SnowBoard;
}(_Vehicle2.Vehicle);
exports.SnowBoard = SnowBoard;
});

;require.register("actor/Sonic.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Sonic = void 0;
var _PointActor2 = require("./PointActor");
var _Platformer = require("../behavior/Platformer");
var _Sfx = require("../audio/Sfx");
var _Tag = require("curvature/base/Tag");
var _View = require("curvature/base/View");
var _Twist = require("../effects/Twist");
var _Pinch = require("../effects/Pinch");
var _Png = require("../sprite/Png");
var _Ring = require("./Ring");
var _Spring = require("./Spring");
var _FireSheild = require("../powerups/FireSheild");
var _BubbleSheild = require("../powerups/BubbleSheild");
var _ElectricSheild = require("../powerups/ElectricSheild");
var _GrindingRegion = require("../region/GrindingRegion");
var _Marker = require("./Marker");
var _SkidDust = require("../behavior/SkidDust");
var _SuperForm = require("../behavior/SuperForm");
var _EmeraldHalo = require("../behavior/EmeraldHalo");
var _Color = require("../lib/Color");
var _Router = require("curvature/base/Router");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
const MODE_FLOOR = 0;
const MODE_LEFT = 1;
const MODE_CEILING = 2;
const MODE_RIGHT = 3;
let Sonic = /*#__PURE__*/function (_PointActor) {
  _inherits(Sonic, _PointActor);
  var _super = _createSuper(Sonic);
  function Sonic() {
    var _this;
    _classCallCheck(this, Sonic);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _defineProperty(_assertThisInitialized(_this), "png", new _Png.Png('/Sonic/sonic.png'));
    window.sonic = _assertThisInitialized(_this);
    _this.behaviors.add(new _SkidDust.SkidDust());
    _this.behaviors.add(new _SuperForm.SuperForm());
    _this.behaviors.add(new _EmeraldHalo.EmeraldHalo());
    _this.args.canonical = 'Sonic';
    _this.args.type = 'actor-sonic actor-item';
    _this.accelNormal = 0.15;
    _this.accelSuper = 0.24;
    _this.markers = new Set();
    _this.springing = false;
    _this.args.boltCount = 0;
    _this.args.accel = _this.accelNormal;
    _this.args.decel = 0.40;
    _this.gSpeedMaxNormal = 18;
    _this.gSpeedMaxSuper = 20;
    _this.gSpeedMaxHyper = 23;
    _this.jumpForceNormal = 11;
    _this.jumpForceSuper = 13;
    _this.jumpForceHyper = 15;
    _this.args.gSpeedMax = _this.gSpeedMaxNormal;
    _this.args.jumpForce = _this.jumpForceNormal;
    _this.args.gravity = 0.5;
    _this.args.width = 16;
    _this.args.height = 40;
    _this.args.normalHeight = 40;
    _this.args.rollingHeight = 28;
    _this.sparks = new Set();
    _this.spindashCharge = 0;
    _this.dropDashCharge = 0;
    _this.willStick = false;
    _this.stayStuck = false;
    _this.lightDashed = true;
    _this.dashed = false;
    _this.airControlCard = _View.View.from(require('../cards/sonic-air-controls.html'));
    _this.controlCard = _View.View.from(require('../cards/sonic-controls.html'));
    _this.moveCard = _View.View.from(require('../cards/basic-moves.html'));
    _this.args.spriteSheet = _this.spriteSheet = '/Sonic/sonic.png';
    _this.hyperSheet = 0;
    _this.costumes = {
      Santiago: {
        h: -30,
        s: 1.5,
        v: 1.25
      },
      Sequel: {
        h: -10,
        s: 1.5,
        v: 1.25
      },
      White: {
        h: 0,
        s: 0,
        v: 1.25
      },
      RedHot: {
        h: 115,
        s: 1.75,
        v: 1.00
      },
      Brown: {
        h: 125,
        s: 1.15,
        v: 0.50
      }
    };
    _this.args.bindTo('falling', v => {
      if (v) {
        return;
      }
      if (_this.willStick && (_this.args.mode === 1 || _this.args.mode === 3)) {
        _this.args.wallSticking = true;
        _this.onNextFrame(() => {
          _this.dashed = false;
        });
      } else {
        _this.onNextFrame(() => {
          _this.args.wallSticking = false;
        });
      }
    });
    _this.transformTime = 0;
    _this.args.minRingsSuper = 50;
    _this.args.minRingsHyper = 75;
    return _this;
  }
  _createClass(Sonic, [{
    key: "shiftColor",
    value: function shiftColor(color, h, s, v) {
      const c = new _Color.Color(color);
      return c.rotate(h, s, v);
    }
  }, {
    key: "onRendered",
    value: function onRendered(event) {
      _get(_getPrototypeOf(Sonic.prototype), "onRendered", this).call(this, event);
      const superColors = {
        '8080e0': 'e0e080',
        '6060c0': 'e0e000',
        '4040a0': 'e0e001',
        '202080': 'a0a000'
      };
      const hyperColorsRed = {
        '8080e0': 'fcfcfc',
        '6060c0': 'fcfcfc',
        '4040a0': 'fcd8d8',
        '202080': 'fcb4b4'
      };
      const hyperColorsPurple = {
        '8080e0': 'fcfcfc',
        '6060c0': 'fcfcfc',
        '4040a0': 'fcd8fc',
        '202080': 'd8b4d8'
      };
      const hyperColorsCyan = {
        '8080e0': 'd8fcfc',
        '6060c0': 'fcfcfc',
        '4040a0': 'b4d8fc',
        '202080': '90b4fc'
      };
      const hyperColorsBlue = {
        '8080e0': 'd8d8ff',
        '6060c0': 'b4b4d8',
        '4040a0': 'a4a4d8',
        '202080': '6c6cb4'
      };
      const hyperColorsGreen = {
        '8080e0': 'd8fcfc',
        '6060c0': 'd8fcd8',
        '4040a0': 'b4fcb4',
        '202080': '00fc24'
      };
      const hyperColorsYellow = {
        '8080e0': 'd8fcfc',
        '6060c0': 'd8fcb4',
        '4040a0': 'd8fc48',
        '202080': 'd8d800'
      };
      const hyperColorsWhite = {
        '8080e0': 'ffffff',
        '6060c0': 'fcfcfc',
        '4040a0': 'd8d8d8',
        '202080': 'b4b4b4'
      };

      // const rH = 180;
      // const rS = 1;
      // const rV = 1;

      // const rH2 = 0;
      // const rS2 = 1;
      // const rV2 = 1;

      this.rotatedSpriteSheet = this.spriteSheet;
      const updateSprite = () => {
        var _this$viewport$custom, _this$viewport$custom2, _this$viewport$custom3;
        let h = Number((_this$viewport$custom = this.viewport.customColor.h) !== null && _this$viewport$custom !== void 0 ? _this$viewport$custom : 0);
        let s = Number((_this$viewport$custom2 = this.viewport.customColor.s) !== null && _this$viewport$custom2 !== void 0 ? _this$viewport$custom2 : 1);
        let v = Number((_this$viewport$custom3 = this.viewport.customColor.v) !== null && _this$viewport$custom3 !== void 0 ? _this$viewport$custom3 : 1);
        this.rotateMainColor(h, s, v);

        // this.args.spriteSheet = this.args.rotatedSpriteSheet;

        this.box.node.style.setProperty('--sprite-sheet', `url(${this.args.rotatedSpriteSheet})`);
      };
      const debindH = this.viewport.customColor.bindTo('h', updateSprite, {
        wait: 0
      });
      const debindS = this.viewport.customColor.bindTo('s', updateSprite, {
        wait: 0
      });
      const debindV = this.viewport.customColor.bindTo('v', updateSprite, {
        wait: 0
      });
      this.onRemove(debindH);
      this.onRemove(debindS);
      this.onRemove(debindV);
      if (this.viewport.args.networked) {
        if (this.args.netplayer) {
          const costume = 'Santiago';
          Object.assign(this.viewport.customColor, this.costumes[costume]);
        } else {
          const costume = 'Sequel';
          Object.assign(this.viewport.customColor, this.costumes[costume]);
        }
      } else if (this.viewport.args.mainPallet && this.costumes[this.viewport.args.mainPallet]) {
        Object.assign(this.viewport.customColor, this.costumes[this.viewport.args.mainPallet]);
      }
      if (!this.superSpriteSheetLoader) {
        this.superSpriteSheetLoader = this.png.ready.then(() => {
          const newPng = this.png.recolor(superColors);
          this.superSpriteSheet = newPng.toUrl();
        });
      }
      if (!this.hyperSpriteSheetLoader) {
        this.hyperSpriteSheetLoader = this.png.ready.then(() => this.hyperSpriteSheets = [this.png.recolor(hyperColorsRed).toUrl(), this.png.recolor(hyperColorsCyan).toUrl(), this.png.recolor(hyperColorsPurple).toUrl(), this.png.recolor(hyperColorsWhite).toUrl(), this.png.recolor(hyperColorsGreen).toUrl(), this.png.recolor(hyperColorsBlue).toUrl(), this.png.recolor(hyperColorsYellow).toUrl()]);
      }
      if (!this.arm) {
        this.arm = new _Tag.Tag(`<div class = "rear-arm">`);
        this.box.appendChild(this.arm.node);
      }
      if (!this.swoosh) {
        this.swoosh = new _Tag.Tag(`<div class = "double-spin">`);
        this.box.appendChild(this.swoosh.node);
      }
      this.autoAttr.get(this.box)['data-doublespin'] = 'doubleSpin';
    }
  }, {
    key: "updateStart",
    value: function updateStart() {
      if (this.args.grinding && this.args.falling && this.args.ySpeed > 0) {
        this.args.animation = 'airdash';
        this.args.grinding = false;
      }
      _get(_getPrototypeOf(Sonic.prototype), "updateStart", this).call(this);
      if (this.args.dead) {
        this.args.animation = 'dead';
        return;
      }
    }
  }, {
    key: "updateEnd",
    value: function updateEnd() {
      // if(this.args.animation === 'transform')
      // {
      // 	this.transformTime++;
      // }
      // else if(this.transformTime > 0)
      // {
      // 	this.transformTime = 0;
      // }

      if (!this.args.falling && this.pinchFilterBg) {
        this.pinch(0, 0);
      }
      _get(_getPrototypeOf(Sonic.prototype), "updateEnd", this).call(this);
    }
  }, {
    key: "update",
    value: function update() {
      if (this.args.falling && this.isHyper && this.dashed && this.yAxis < -0.5) {
        this.args.ySpeed -= 0.6;
      }
      if (!this.args.falling && this.groundTime > 3 || this.args.falling && this.fallTime > 90) {
        this.args.trickRamp = false;
        this.args.twistRamp = false;
      }
      if (this.args.dead) {
        this.args.animation = 'dead';
        _get(_getPrototypeOf(Sonic.prototype), "update", this).call(this);
        return;
      }
      if (this.isSuper) {
        const tick = this.isHyper ? 30 : 60;
        if (this.viewport.args.frameId % tick === 0) {
          if (this.args.rings < 2) {
            this.isHyper = false;
            this.setProfile();
          }
          if (this.args.rings > 0) {
            this.args.rings--;
          } else {
            this.isSuper = false;
            this.isHyper = false;
            this.setProfile();
          }
        }
      }
      this.args.isSuper = this.isSuper;
      this.args.isHyper = this.isHyper;
      if (this.isHyper) {
        if (this.viewport.args.frameId % 45 === 0) {
          this.args.spriteSheet = this.hyperSpriteSheets[this.hyperSheet++];
          if (this.hyperSheet >= this.hyperSpriteSheets.length) {
            this.hyperSheet = 0;
          }
        }
      }
      if (this.args.falling) {
        if (this.args.wallSticking && !this.dashed) {
          if (this.args.mode === 1) {
            this.args.direction = -1;
            this.args.facing = 'left';
          } else if (this.args.mode === 3) {
            this.args.direction = 1;
            this.args.facing = 'right';
          }
          this.args.animation = 'wall-dropping-start';
          this.onTimeout(150, () => {
            if (this.args.falling && this.args.wallDropping) {
              this.args.animation = 'wall-dropping';
            }
          });
          this.args.wallDropping = true;
          this.args.groundAngle = 0;
          this.args.ignore = 30;
        }
        if (this.args.wallDropping) {
          this.args.groundAngle = 0;
        }
        if (this.args.animation === 'hanging' && this.args.ySpeed > -3) {
          this.args.animation = 'wall-dropping';
        }
        this.args.wallSticking = false;
      } else {
        this.args.wallDropping = false;
        this.swing = false;
        if (this.springing) {
          this.args.groundAngle = 0;
        }
        this.springing = false;
        this.args.doubleSpin = this.dashed = false;
        if (this.args.mode % 2 === 0) {
          this.args.wallSticking = false;
        }
        if (!this.args.wallSticking) {
          this.willStick = false;
        }

        // this.pincherBg.args.scale = 0;
      }

      if (this.lightDashingCoolDown > 0) {
        this.lightDashingCoolDown--;
      }
      if (this.dashTimer > 0) {
        this.dashTimer--;
      }
      const falling = this.args.falling;
      if (falling) {
        this.args.cameraBias = 0;
      }
      if (this.args.wallSticking) {
        this.args.animation = 'wall-stick';
        let slip = 3;
        if (this.yAxis < 0) {
          this.args.animation = 'wall-stick-brake';
          this.stayStuck = true;
          slip = 0;
        } else if (this.yAxis > 0) {
          slip = 6;
        }
        if (this.args.modeTime < 15) {
          slip = 0;
        }
        if (this.args.mode === 1) {
          this.args.facing = 'left';
          this.args.direction = 1;
          if (Math.abs(this.args.gSpeed) < slip) {
            this.args.gSpeed += 1;
          } else {
            this.args.gSpeed = slip;
          }
        } else if (this.args.mode === 3) {
          this.args.facing = 'right';
          this.args.direction = -1;
          if (Math.abs(this.args.gSpeed) < slip) {
            this.args.gSpeed -= 1;
          } else {
            this.args.gSpeed = -slip;
          }
        }
        const radius = Math.ceil(this.args.width / 2);
        const direction = Math.sign(this.args.gSpeed);
        const headPoint = this.rotatePoint(radius * -direction, this.args.height);
        if (this.getMapSolidAt(this.x + headPoint[0], this.y + headPoint[1])) {
          this.bMap('doJump', 0);
        }
      } else if (this.lightDashing) {
        const direction = Math.sign(this.args.xSpeed) || Math.sign(this.args.gSpeed);
        if (direction < 0) {
          this.args.animation = 'lightdash-back';
        } else if (direction > 0) {
          this.args.animation = 'lightdash';
        }
        if (falling) {
          this.args.direction = Math.sign(this.args.xSpeed) || this.args.direction;
          this.args.mode = MODE_FLOOR;
        }
      } else if (!falling) {
        const maxSpeedNormal = this.gSpeedMaxNormal / (this.isSuper ? 2 : 1);
        const friction = this.getLocalFriction();
        const direction = this.args.direction;
        const gSpeed = this.args.gSpeed;
        const speed = Math.abs(gSpeed) / Math.pow(friction, 2);
        const maxSpeed = this.args.gSpeedMax;
        this.dashed = false;
        this.lightDashed = false;
        this.lightDashReward = null;
        this.args.height = this.args.normalHeight;
        if (this.spindashCharge) {
          if (this.spindashCharge < 1) {
            this.spindashCharge = 0;
          } else {
            this.args.animation = 'spindash';
            this.spindashCharge -= 0.2;
            if (this.dashDust) {
              this.dashDust.style({
                '--dashCharge': this.spindashCharge
              });
            }
            let dashCharge = this.spindashCharge / 20;
            if (dashCharge > 1) {
              dashCharge = 1;
            }
            this.twist(120 * dashCharge * this.args.direction);
          }
        } else if (!this.args.rolling) {
          this.args.crouching = false;
          if (friction > 0.5 && Math.sign(direction) && Math.sign(gSpeed) && Math.sign(gSpeed) !== Math.sign(direction) && !this.args.antiSkid) {
            this.args.animation = 'skidding';
          } else if (this.args.moving && speed > maxSpeedNormal * 0.75) {
            if (this.xAxis || friction >= 0.5) {
              if (this.isSuper && this.args.moving && speed > maxSpeedNormal * 1.85) {
                this.args.animation = 'dash';
              } else if (this.args.moving && speed > maxSpeedNormal * 2.25) {
                this.args.animation = 'running-4';
              } else if (this.args.moving && speed > maxSpeedNormal * 1.75) {
                this.args.animation = 'running-3';
              } else if (this.args.moving && speed > maxSpeedNormal * 1.25) {
                this.args.animation = 'running-2';
              } else {
                this.args.animation = 'running';
              }
            } else {
              this.args.animation = 'sliding';
            }
          } else if (this.args.moving && this.args.gSpeed) {
            if (this.xAxis || friction > 0.5) {
              this.args.animation = 'walking';
            } else {
              this.args.animation = 'sliding';
            }
          } else if (this.xAxis && friction === 0) {
            this.args.animation = 'running';
            this.args.facing = this.xAxis === -1 ? 'left' : 'right';
          } else if (this.args.moving && this.args.gSpeed) {
            this.args.pushing = Math.sign(this.args.gSpeed);
          } else {
            if (this.yAxis > 0.5 && !this.args.ignore && !this.carrying.size) {
              this.args.animation = 'crouching';
              this.args.crouching = true;
              this.args.lookTime--;
              if (this.args.lookTime < -45) {
                this.args.cameraBias = -0.5;
              }
            } else if (this.yAxis && this.yAxis < -0.5 && !this.args.ignore) {
              this.args.animation = 'looking-up';
              this.args.lookTime++;
              if (this.args.lookTime > 45) {
                this.args.cameraBias = 0.25;
              }
            } else {
              const fieldType = this.viewport.meta['fieldType'];
              if (this.args.teeter) {
                this.args.animation = 'teeter';
                if (this.args.teeter === -1) {
                  this.args.animation = 'teeter--1';
                }
                if (this.args.teeter === 2) {
                  this.args.animation = 'teeter-2';
                }
              } else if (fieldType === 'garden' || fieldType === 'adventure') {
                this.args.animation = 'standing';
              } else if (this.idleTime > 60 * 300) {
                this.args.animation = 'idle-3';
              } else if (this.idleTime > 250) {
                this.args.animation = 'idle-2';
              } else if (this.idleTime > 200) {
                this.args.animation = 'idle';
              } else {
                this.args.animation = 'standing';
              }
              this.args.cameraBias = 0;
              this.args.lookTime = 0;
            }
          }
        }
        if (!this.spindashCharge && this.dashDust) {
          this.dashDust.remove();
          this.dashDust = null;
        }
        if (this.dropDashCharge) {
          this.args.animation = 'spindash';
          this.args.rolling = true;
        }
      } else if (!this.dashed) {
        this.args.height = this.args.rollingHeight;
        if (this.args.jumping) {
          this.args.animation = 'jumping';
        } else if (!this.args.xSpeed && !this.args.ySpeed) {
          // this.box.setAttribute('data-animation', 'airdash');
        }
      } else if (falling && !this.args.jumping && this.isSuper && this.args.ySpeed > 0) {
        this.args.animation = 'dropping';
        this.onTimeout(150, () => {
          if (this.args.falling) {
            this.args.animation = 'dropping';
          }
        });
      }
      if (falling && this.args.animation === 'standing') {
        this.args.animation = 'walking';
      }
      if (this.args.animation === 'skidding' && this.fallTime > 16) {
        if (Math.abs(this.args.groundAngle) > Math.PI / 2) {
          this.args.animation = 'walking';
        } else {
          this.args.animation = 'skidding-falling';
        }
      }
      if (this.args.hangingFrom) {
        this.args.animation = 'hanging';
      } else if (this.swing) {
        this.args.animation = 'jumping';
      }
      if (this.args.rolling) {
        if (this.args.animation !== 'spindash') {
          this.args.animation = 'rolling';
        } else {
          this.viewport.onFrameOut(14, () => this.args.animation = 'rolling');
          this.args.animation = 'spindash';
        }
      }
      if (this.skidding && !this.args.rolling && !this.args.falling && !this.spindashCharge) {
        this.args.xOff = 8 * -this.args.direction;
        this.args.yOff = 32;
        let warp = -this.args.gSpeed * 22;
        if (Math.abs(warp) > 256) {
          warp = 256 * Math.sign(warp);
        }
        this.twist(warp);
      } else if (!this.spindashCharge) {
        this.twister && (this.twister.args.scale = 0);
      }
      if (this.args.standingOn && this.args.standingOn.isVehicle) {
        this.args.animation = this.args.standingOn.ridingAnimation || 'standing';
      }
      if (this.viewport.args.frameId % this.viewport.settings.frameSkip === 0) {
        if (this.args.grinding && !this.args.falling) {
          // `<div class = "particle-sparks">`

          const sparkTag = document.createElement('div');
          sparkTag.classList.add('particle-sparks');
          const sparkParticle = new _Tag.Tag(sparkTag);

          // `<div class = "envelope-sparks">`
          const envelopeTag = document.createElement('div');
          envelopeTag.classList.add('envelope-sparks');
          const sparkEnvelope = new _Tag.Tag(envelopeTag);
          sparkEnvelope.appendChild(sparkParticle.node);
          const sparkPoint = this.rotatePoint(-this.args.gSpeed * 1.75 * this.args.direction, 8);
          const flip = Math.sign(this.args.gSpeed);
          sparkEnvelope.style({
            '--x': sparkPoint[0] + this.args.x,
            '--y': sparkPoint[1] + this.args.y + Math.random() * -3,
            'z-index': 0,
            'animation-delay': -Math.random() * 0.25 + 's',
            '--xMomentum': Math.max(Math.abs(this.args.gSpeed), 4) * flip,
            '--flip': flip,
            '--angle': this.realAngle,
            opacity: Math.random() * 2
          });
          sparkEnvelope.particle = sparkParticle;
          this.viewport.particles.add(sparkEnvelope);
          this.sparks.add(sparkEnvelope);
          const viewport = this.viewport;
          this.viewport.onFrameOut(30, () => {
            viewport.particles.remove(sparkEnvelope);
            this.sparks.delete(sparkEnvelope);
          });
        }
      }
      if (this.pincherBg) {
        this.pincherBg.args.scale *= 0.85;
        // this.pincherFg.args.scale *= 0.875;

        if (Math.abs(this.pincherBg.args.scale) < 0.1) {
          // this.pincherBg.args.scale = 0;
          // this.pincherFg.args.scale = 0;
        }
      } else {
        // this.pinch(0, 0);
      }
      if (!this.twister) {
        this.twist(0);
      }
      if (this.args.grinding) {
        this.args.rolling = false;
        if (this.yAxis > 0.5) {
          this.args.animation = 'grinding-crouching';
        } else {
          this.args.animation = 'grinding';
        }
      }
      _get(_getPrototypeOf(Sonic.prototype), "update", this).call(this);
      if (!this.yAxis && this.spindashCharge) {
        this.spindash();
      }
      if (this.args.falling && this.springing && this.args.ySpeed >= 0) {
        this.args.groundAngle = 0;
        this.args.animation = 'dropping-start';
        this.springing = false;
        this.onTimeout(150, () => {
          if (!this.args.falling || this.args.animation !== 'dropping-start') {
            return;
          }
          this.args.animation = 'dropping';
        });
      }
      if (this.args.boltDash) {
        this.dimmer = this.dimmer || new _Tag.Tag('<div class = "particle particle-dimmer">');
        const boltParticle = new _Tag.Tag('<div class = "particle particle-bolt">');
        const speed = this.args.falling ? this.args.airSpeed : this.args.gSpeed;
        const boltPoint = this.rotatePoint(speed < 0 ? 8 : -8, this.args.falling ? this.dashed ? speed < 0 ? 28 : 32 : 14 : 28);
        this.dimmer.style({
          '--x': this.args.x + boltPoint[0],
          '--y': this.args.y + boltPoint[1]
        });
        this.args.boltCount++;
        const direction = Math.sign(this.args.gSpeed || this.args.xSpeed);
        boltParticle.attr({
          'data-direction': direction
        });
        boltParticle.style({
          '--x': this.args.x + boltPoint[0],
          '--y': this.args.y + boltPoint[1],
          '--index': this.args.boltCount,
          '--direction': direction,
          '--mod': this.viewport.args.frameId % 4,
          '--wipe': Math.abs(speed),
          '--angle': this.args.falling ? this.args.airAngle : this.realAngle,
          '--dashCharge': 0
        });
        this.viewport.particles.add(boltParticle);
        if (Math.abs(speed) < 20 && this.args.falling) {
          this.args.boltDash = false;
        }
        this.viewport.particles.add(this.dimmer);
        this.viewport.onFrameOut(30, () => {
          this.viewport.particles.remove(boltParticle);
        });
      }
      if ([...this.regions].filter(r => r.isWater).length && !this.bMap('checkBelow', this.args.x, this.args.y + 16).get(_Platformer.Platformer) && this.args.falling && this.dashed) {
        if (this.yAxis < 0) {
          this.args.xSpeed = this.args.xSpeed * 0.95;
          this.args.ySpeed -= Math.abs(this.args.xSpeed) * 0.05;
        }
        if (this.yAxis > 0) {
          this.args.xSpeed += Math.abs(this.args.ySpeed) * 0.05 * Math.sign(this.args.xSpeed);
          this.args.ySpeed = this.args.ySpeed * 0.95;
        }
      }
      if (this.viewport.args.frameId % this.viewport.settings.frameSkip === 0) {
        if (this.args.grinding && !this.args.falling && this.args.gSpeed) {
          for (const spark of this.sparks) {
            const sparkPoint = this.rotatePoint(1.75 * this.args.direction, 8);
            spark.style({
              opacity: Math.random() * 2,
              '--x': sparkPoint[0] + this.x,
              '--y': sparkPoint[1] + this.y
            });
          }
        }
      }
      if (Math.abs(this.ySpeedLast) > 16) {
        const landingFrames = Math.min(8, this.ySpeedLast / 3) * (this.args.rolling ? 0.5 : 1);
        if (this.groundTime && this.groundTime > 2 && this.groundTime < landingFrames && this.ySpeedLast) {
          this.args.animation = 'landing';
        }
      }
      if (this.args.sliding) {
        this.args.animation = 'sliding';
      }
      if (this.args.trickRamp) {
        this.args.animation = 'adventure-pose';
      }
      if (this.args.twistRamp) {
        this.args.animation = 'side-flip';
      }
    }
  }, {
    key: "readInput",
    value: function readInput() {
      if (!this.lightDashing) {
        _get(_getPrototypeOf(Sonic.prototype), "readInput", this).call(this);
      }
    }
  }, {
    key: "airDash",
    value: function airDash(direction) {
      if (this.args.stuck || this.carrying.size) {
        return;
      }
      if (this.dashed || this.args.ignore && this.args.ignore !== -2) {
        return;
      }
      let dashSpeed = direction * (this.isSuper || this.isHyper ? 13 : 8);
      if (this.args.wallSticking) {
        this.args.x += dashSpeed;
        dashSpeed = direction * (this.isSuper || this.isHyper ? 18 : 9);
      }
      this.args.mode = 0;
      this.args.float = 2;
      this.args.rolling = false;
      this.args.height = this.args.normalHeight;
      if (this.args.xSpeed && Math.sign(this.args.xSpeed) !== Math.sign(direction)) {
        dashSpeed = direction * Math.abs(dashSpeed);
        this.args.float = 4;
        this.args.xSpeed = 0;
      }
      this.args.falling = true;
      if (this.args.mercy) {
        dashSpeed *= 0.75;
      }
      const finalSpeed = this.args.xSpeed + dashSpeed;

      // if(Math.abs(finalSpeed) > Math.abs(space))
      // {
      // 	dashSpeed = space * Math.sign(finalSpeed);
      // }

      this.args.animation = 'rolling';
      this.viewport.onFrameOut(3, () => this.args.animation = 'airdash');
      this.args.xSpeed = finalSpeed;
      this.args.ySpeed = 0;
      this.args.gSpeed = 0;
      this.dashTimer = 0;
      this.dashed = true;
      this.args.mode = 0;
      this.args.groundAngle = 0;
    }
  }, {
    key: "command_0",
    value: function command_0() {
      if (this.args.crouching && !this.args.rolling && this.yAxis) {
        this.spindashCharge += 10;
        let dashCharge = this.spindashCharge / 20;
        if (dashCharge > 1) {
          dashCharge = 1;
        }
        this.args.xOff = 5 * -this.args.direction;
        this.args.yOff = 32;
        this.twist(120 * dashCharge * this.args.direction);
        if (!this.dashDust) {
          this.showDashDust();
        } else if (this.dashDust) {
          this.dashDust.style({
            '--dashCharge': this.spindashCharge
          });
        }
        this.willJump = false;
        return;
      }
      this.dropDashCharge = 0;
      if (this.args.jumping && !this.args.wasHanging && !this.dashed && (!this.args.doubleSpin || this.args.doubleSpin === 2) && (!this.args.currentSheild || this.args.currentSheild.type === 'normal' || this.args.currentSheild.type === 'super')) {
        if (this.args.mercy < 120) {
          this.args.mercy = 0;
        }
        this.args.doubleSpin = true;
        this.args.xOff = 0;
        this.args.yOff = 32;

        // this.viewport.onFrameOut(15, () => this.args.doubleSpin = false);

        this.viewport.onFrameOut(5, () => this.pinch(-600, 50));
        const marker = new _Marker.Marker({
          x: this.args.x,
          y: this.args.y
        });
        marker.owner = this;
        this.markers.add(marker);
        this.viewport.spawn.add({
          object: marker
        });
        const debindX = this.args.bindTo('x', (v, k) => marker.args[k] = v);
        const debindY = this.args.bindTo('y', (v, k) => marker.args[k] = v + 18);
        this.viewport.onFrameOut(25, () => {
          this.viewport.actors.remove(marker);
          debindX();
          debindY();
        });
      }
      _get(_getPrototypeOf(Sonic.prototype), "command_0", this).call(this);
    }
  }, {
    key: "command_4",
    value: function command_4() {
      if (this.args.ignore) {
        return;
      }
      if (this.args.falling) {
        this.airDash(-1);
        this.willStick = 2;
        this.stayStuck = true;
      }
    }
  }, {
    key: "hold_4",
    value: function hold_4(button) {
      if (this.args.ignore) {
        return;
      }
      if (this.args.jumping || this.dashed) {
        this.dropDashCharge = 0;
        this.willStick = 2;
        this.stayStuck = true;
      }
    }
  }, {
    key: "release_4",
    value: function release_4() {
      this.onNextFrame(() => {
        this.willStick = false;
        this.stayStuck = false;
      });
      if (this.args.wallSticking && !this.dashed) {
        this.args.falling = true;
        if (this.args.ySpeed > 128) {
          // this.args.ySpeed = this.args.ySpeed / 4;
        } else {
          this.args.ySpeed = 0;
        }
        const mode = this.args.mode;
        this.airDash(mode === 1 ? 1 : -1);
        this.args.facing = mode === 1 ? 'left' : 'right';
        this.args.mode = 0;
        this.dashed = true;
      }
    }
  }, {
    key: "command_5",
    value: function command_5() {
      if (this.args.ignore) {
        return;
      }
      if (this.args.falling) {
        this.airDash(1);
        this.willStick = 2;
        this.stayStuck = true;
      }
    }
  }, {
    key: "hold_5",
    value: function hold_5(button) {
      if (this.args.ignore) {
        return;
      }
      if (this.args.jumping || this.dashed && this.args.mode !== 2) {
        this.dropDashCharge = 0;
        this.willStick = 2;
        this.stayStuck = true;
      }
    }
  }, {
    key: "release_5",
    value: function release_5() {
      this.onNextFrame(() => {
        this.willStick = false;
        this.stayStuck = false;
      });
      if (this.args.wallSticking && !this.dashed) {
        this.args.falling = true;
        this.args.ySpeed = 0;
        const mode = this.args.mode;
        this.airDash(mode === 1 ? 1 : -1);
        this.args.facing = mode === 1 ? 'left' : 'right';
        this.args.mode = 0;
        this.dashed = true;
      }
    }
  }, {
    key: "command_1",
    value: function command_1() {
      if (this.args.ignore) {
        return;
      }
      if (this.args.wallSticking) {
        this.args.x += this.args.width / 2 * (this.args.mode === 1 ? 1 : -1);
        this.bMap('doJump', 0);
      }
      if (this.args.gSpeed && !this.args.falling && !this.args.rolling && Math.sign(this.args.gSpeed) === this.args.direction) {
        this.args.rolling = true;
        const standOrRecheck = () => {
          const backOfHead = [this.args.width / 2, this.args.height + 4];

          // const actualBackOfHead = this.rotatePoint(...backOfHead);

          const solid = this.getMapSolidAt(this.x - backOfHead[0], this.y - backOfHead[1]);
          if (solid) {
            this.viewport.onFrameOut(10, standOrRecheck);
            this.args.gSpeed = this.args.gSpeed || this.args.direction * 4 || 4;
            this.args.rolling = true;
            return;
          }
          this.args.rolling = false;
        };
        this.viewport.onFrameOut(20, standOrRecheck);
      }
    }
  }, {
    key: "release_1",
    value: function release_1()
    // spindash
    {
      this.dropDashCharge = 0;
      if (!this.spindashCharge) {
        return;
      }
      if (!this.yAxis) {
        this.args.crouching = false;
      }
    }
  }, {
    key: "spindash",
    value: function spindash() {
      if (this.spindashCharge < 5 && (this.args.modeTime < 45 || this.args.skidding)) {
        this.spindashCharge = 15;
      }
      const direction = this.args.facing === 'left' ? -1 : 1;
      let dashPower = this.spindashCharge / 40;
      if (dashPower > 1) {
        dashPower = 1;
      }
      this.args.rolling = true;
      const dashBoost = dashPower * 32;
      this.castRayQuick(dashBoost * Math.sign(direction), [Math.PI, 0, 0][1 + Math.sign(direction)], [0, this.args.height / 2]);
      if (Math.sign(direction) !== Math.sign(this.args.gSpeed)) {
        this.args.gSpeed = dashBoost * Math.sign(direction);
      } else {
        this.args.gSpeed += dashBoost * Math.sign(direction);
      }
      this.args.ignore = 1;
      this.args.rolling = true;
      this.spindashCharge = 0;
      if (this.dashDust) {
        this.dashDust.remove();
      }
    }
  }, {
    key: "hold_1",
    value: function hold_1(button)
    // spindash
    {
      if (this.args.mercy) {
        return;
      }
      if (this.carrying.size) {
        return;
      }

      // if(this.skidding)
      // {
      // 	return;
      // }

      this.yAxis = this.yAxis || 1;
      if (this.args.ignore || this.args.rolling) {
        return;
      }
      if (this.args.jumping) {
        if (this.dropDashCharge < 15) {
          this.dropDashCharge++;
          return;
        }
      }
      if (this.args.modeTime === 0) {
        return;
      }
      if (this.dropDashCharge) {
        return;
      }
      if (this.args.falling || this.willJump || this.args.gSpeed && !this.skidding) {
        if (!this.skidding) {
          this.spindashCharge = 0;
        }
        return;
      }
      if (!this.spindashCharge && button.time > 6) {
        return;
      }
      this.args.ignore = 1;
      let dashCharge = this.spindashCharge / 20;
      if (dashCharge > 1) {
        dashCharge = 1;
      }
      this.spindashCharge = this.spindashCharge || 1;
      if (this.yAxis > 0.5) {
        this.spindashCharge = this.spindashCharge || 10;
      }
      this.args.crouching = true;
      if (!this.dashDust) {
        this.showDashDust();
      } else if (this.dashDust) {
        this.dashDust.style({
          '--dashCharge': this.spindashCharge
        });
      }
      this.spindashCharge++;
      this.args.xOff = 5 * -this.args.direction;
      this.args.yOff = 32;
      this.twist(120 * dashCharge * this.args.direction);
      this.args.animation = 'spindash';
      if (this.args.direction < 0) {
        this.args.facing = 'left';
      } else if (this.args.direction > 0) {
        this.args.facing = 'right';
      }
    }
  }, {
    key: "showDashDust",
    value: function showDashDust() {
      const viewport = this.viewport;
      const dustParticle = new _Tag.Tag('<div class = "particle-spindash-dust">');
      const dustPoint = this.rotatePoint(0, 0);
      dustParticle.style({
        '--x': dustPoint[0] + this.args.x,
        '--y': dustPoint[1] + this.args.y,
        '--direction': this.args.direction,
        '--dashCharge': this.spindashCharge
      });
      dustParticle.setAttribute('data-facing', this.args.facing);
      viewport.particles.add(dustParticle);
      this.dashDust = dustParticle;
    }
  }, {
    key: "hold_2",
    value: function hold_2() {
      if (this.args.stuck || !this.args.falling) {
        return;
      }
      if (this.lightDashing) {
        return;
      }
      if (this.lightDashingCoolDown > 0) {
        return;
      }
      const ring = this.findDashableRing(48);
      if (ring) {
        this.lightDash(ring);
        this.lightDashingCoolDown = 9;
        return;
      }
    }
  }, {
    key: "command_2",
    value: function command_2() {
      if (this.viewport.collisions.has(this)) {
        const objects = this.viewport.collisions.get(this);
        for (const object of objects.keys()) {
          if (this.carrying.size && !this.carrying.has(object)) {
            continue;
          }
          if (typeof object.lift === 'function') {
            object.lift(this);
          }
        }
      }
      this.onNextFrame(() => {
        const speed = this.args.falling ? this.args.airSpeed : this.args.gSpeed;
        if (this.isSuper && !this.lightDashing && !this.args.boltDash && Math.abs(speed) > 6) {
          const xSpeed = this.args.xSpeed;
          const ySpeed = this.args.ySpeed;
          const gSpeed = this.args.gSpeed;
          if (!this.args.falling) {
            this.args.gSpeed *= 3;
            this.args.gSpeed = Math.max(-128, Math.min(this.args.gSpeed, 128));
          } else {
            this.args.xSpeed = Math.max(-64, Math.min(this.args.xSpeed, 64));
            this.args.ySpeed = Math.max(-64, Math.min(this.args.ySpeed, 64));
            this.args.float = 5;
            this.args.xSpeed *= 5;
            this.args.ySpeed *= 5;
          }
          this.args.boltCount = 0;
          this.args.boltDash = true;
          _Sfx.Sfx.play('LIGTNING_STRIKE');
          this.args.opacity = 0;
          this.viewport.onFrameOut(35, () => {
            this.args.opacity = 1;
            this.args.boltDash = false;
            this.args.xSpeed = this.args.xSpeed ? xSpeed : 0;
            this.args.ySpeed = this.args.ySpeed ? ySpeed : 0;
            this.args.gSpeed = this.args.gSpeed ? gSpeed : 0;
            this.dimmer && this.viewport.particles.remove(this.dimmer);
            this.dimmer = false;
          });
        }
      });
    }
  }, {
    key: "release_2",
    value: function release_2() {
      if (!this.args.boltDash) {
        return;
      }
      this.args.opacity = 1;
      this.args.boltDash = false;
      this.args.xSpeed /= 2;
      this.args.ySpeed /= 2;
      this.args.gSpeed /= 3;
      this.dimmer && this.viewport.particles.remove(this.dimmer);
      this.dimmer = false;
    }
  }, {
    key: "command_3",
    value: function command_3() {}
  }, {
    key: "setProfile",
    value: function setProfile() {
      if (this.isHyper) {
        this.args.spriteSheet = this.superSpriteSheet;
        this.args.gSpeedMax = this.gSpeedMaxHyper;
        this.args.jumpForce = this.jumpForceHyper;
        this.args.accel = this.accelSuper;
      } else if (this.isSuper) {
        this.args.spriteSheet = this.superSpriteSheet;
        this.args.gSpeedMax = this.gSpeedMaxSuper;
        this.args.jumpForce = this.jumpForceSuper;
        this.args.accel = this.accelSuper;
      } else {
        this.args.spriteSheet = this.rotatedSpriteSheet;
        this.args.gSpeedMax = this.gSpeedMaxNormal;
        this.args.jumpForce = this.jumpForceNormal;
        this.args.accel = this.accelNormal;
      }
    }
  }, {
    key: "findNearestRing",
    value: function findNearestRing() {
      return this.findDashableRing(64);
    }
  }, {
    key: "findDashableRing",
    value: function findDashableRing() {
      let maxDist = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 128;
      const findRing = actor => {
        if (!(actor instanceof _Ring.Ring)) {
          return false;
        }
        const direction = Math.sign(this.args.xSpeed);
        if (direction > 0 && actor.x < this.x) {
          return false;
        }
        if (direction < 0 && actor.x > this.x) {
          return false;
        }
        return true;
      };
      const ring = this.findNearestActor(findRing, maxDist);
      if (!ring) {
        return;
      }
      const nextRing = ring.findNearestActor(findRing, maxDist);
      if (!nextRing) {
        return;
      }
      const firstAngle = Math.atan2(this.y - ring.y, this.x - ring.x);
      const secondAngle = Math.atan2(ring.y - nextRing.y, ring.x - nextRing.x);
      if (Math.abs(firstAngle - secondAngle) > Math.PI / 2) {
        return;
      }
      return ring;
    }
  }, {
    key: "lightDash",
    value: function lightDash(ring) {
      if (!this.args.falling) {
        this.lightDashing = false;
        return false;
      }
      if (this.args.popChain.length) {
        if (!this.lightDashReward) {
          this.lightDashReward = {
            label: 'lightdash',
            points: 10,
            multiplier: 1
          };
          this.args.popChain.push(this.lightDashReward);
        } else {
          this.lightDashReward.points += 10;
        }
      }
      this.lightDashed = true;
      let currentAngle;
      this.spindashCharge = 0;
      let angle = Math.atan2(ring.y - this.y + 8, ring.x - this.x);
      currentAngle = this.args.groundAngle;
      const angleDiff = Math.abs(currentAngle - angle);
      let dashSpeed = this.distanceFrom(ring) * 4 * (Math.PI / 2 / angleDiff);
      const maxDash = 55;
      if (dashSpeed > maxDash) {
        dashSpeed = maxDash;
      }

      // const space = this.bMap('scanForward', dashSpeed, 0.5).get(Platformer);

      // if(space && dashSpeed > space)
      // {
      // 	dashSpeed = space;
      // }

      const direction = Math.sign(this.args.xSpeed) || Math.sign(this.args.gSpeed);
      if (this.args.direction < 0) {
        this.args.animation = 'lightdash-back';
      } else if (this.args.direction > 0) {
        this.args.animation = 'lightdash';
      }
      const breakGroundAngle = Math.PI / 4;

      // this.args.airAngle  = angle;

      this.lightDashing = true;
      this.args.xSpeed = dashSpeed * Math.cos(angle) * 0.5;
      this.args.ySpeed = dashSpeed * Math.sin(angle) * 0.5;
      this.lightDashTimeout();
    }
  }, {
    key: "collect",
    value: function collect(pickup) {
      _get(_getPrototypeOf(Sonic.prototype), "collect", this).call(this, pickup);
      if (pickup instanceof _Ring.Ring) {
        if (this.lightDashing) {
          const ring = this.findNearestActor(actor => actor instanceof _Ring.Ring, 128);
          if (ring) {
            // this.args.x = pickup.args.x;
            // this.args.y = pickup.args.y;

            this.lightDash(ring);
          } else {
            this.lightDashing = false;
            this.args.float = 0;
          }
        }
      }
    }
  }, {
    key: "lightDashTimeout",
    value: function lightDashTimeout() {
      if (this.clearLightDash) {
        this.clearLightDash();
        this.clearLightDash = false;
      }
      this.clearLightDash = this.viewport.onFrameOut(9, () => {
        this.lightDashing = false;
        this.args.float = 0;
      });
    }
  }, {
    key: "setCameraMode",
    value: function setCameraMode() {
      if (!this.args.falling && this.regions) {
        for (const region of this.regions) {
          if (region.args.perspective) {
            this.args.cameraMode = 'perspective';
            return;
          }
        }
      }
      if (this.args.boltDash) {
        this.args.cameraMode = 'draggable';
      } else if (this.args.wallSticking) {
        if (this.args.cameraMode !== 'panning' && (this.args.cameraMode !== 'popping' || Math.abs(this.args.ySpeed) < Math.abs(this.args.xSpeed))) {
          this.args.cameraMode = 'aerial';
        }
      } else {
        _get(_getPrototypeOf(Sonic.prototype), "setCameraMode", this).call(this);
      }
    }
  }, {
    key: "startle",
    value: function startle(other) {
      _get(_getPrototypeOf(Sonic.prototype), "startle", this).call(this, other);
      this.onNextFrame(() => this.args.animation = 'startle');
    }
  }, {
    key: "die",
    value: function die() {
      _get(_getPrototypeOf(Sonic.prototype), "die", this).call(this);
      this.onNextFrame(() => this.args.animation = 'dead');
      this.pinch(0, 0);
      this.twist(0);
      _Sfx.Sfx.play('PLAYER_DAMAGED');
    }
  }, {
    key: "loseRings",
    value: function loseRings(count, age) {
      _get(_getPrototypeOf(Sonic.prototype), "loseRings", this).call(this, count, age);
      _Sfx.Sfx.play('RINGS_SCATTERED');
    }
  }, {
    key: "collideA",
    value: function collideA(other) {
      if (other instanceof _Spring.Spring) {
        this.onNextFrame(() => {
          if (!this.args.falling) {
            return;
          }
          this.springing = true;
          this.args.animation = 'springdash';
        });
      }
      if (other.pop && this.isHyper) {
        other.pop(this);
      }
    }
  }, {
    key: "solid",
    get: function get() {
      return false;
    }
  }, {
    key: "canRoll",
    get: function get() {
      return !this.args.wallSticking;
    }
  }, {
    key: "isEffect",
    get: function get() {
      return false;
    }
  }, {
    key: "controllable",
    get: function get() {
      return !this.args.npc;
    }
  }, {
    key: "facePoint",
    get: function get() {
      if (this.args.wallSticking) {
        return this.rotatePoint(0, -5);
      }
      return _get(_getPrototypeOf(Sonic.prototype), "facePoint", this);
    }
  }, {
    key: "crossRegionBoundary",
    value: function crossRegionBoundary(region, entered) {
      if (region instanceof _GrindingRegion.GrindingRegion) {
        if (!entered) {
          for (const r of this.regions) {
            if (r !== region && r instanceof _GrindingRegion.GrindingRegion) {
              return;
            }
          }
          if (this.args.wasGrinding && this.args.falling) {
            this.args.animation = 'springdash';
          } else {
            this.args.grinding = false;
          }
        }
      }
      _get(_getPrototypeOf(Sonic.prototype), "crossRegionBoundary", this).call(this, region, entered);
    }
  }, {
    key: "rotateMainColor",
    value: function rotateMainColor() {
      let rH = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      let rS = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      let rV = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
      const rotatedColors = {
        '8080e0': new _Color.Color('8080e0').rotate(rH, rS, rV).toString(),
        '6060c0': new _Color.Color('6060c0').rotate(rH, rS, rV).toString(),
        '4040a0': new _Color.Color('4040a0').rotate(rH, rS, rV).toString(),
        '202080': new _Color.Color('202080').rotate(rH, rS, rV).toString()
      };
      this.png.ready.then(() => {
        const newPng = this.png.recolor(rotatedColors);
        this.args.rotatedSpriteSheet = this.rotatedSpriteSheet = this.args.spriteSheet = this.spriteSheet = newPng.toUrl();
      });
    }
  }]);
  return Sonic;
}(_PointActor2.PointActor);
exports.Sonic = Sonic;
});

;require.register("actor/Sparkle.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Sparkle = void 0;
var _Mixin = require("curvature/base/Mixin");
var _Tag = require("curvature/base/Tag");
var _Flickie = require("./Flickie");
var _PointActor = require("./PointActor");
var _SkidDust = require("../behavior/SkidDust");
var _CanPop = require("../mixin/CanPop");
var _Explosion = require("../actor/Explosion");
var _Projectile = require("../actor/Projectile");
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let Sparkle = /*#__PURE__*/function (_Mixin$from) {
  _inherits(Sparkle, _Mixin$from);
  var _super = _createSuper(Sparkle);
  function Sparkle() {
    var _this$args$offset;
    var _this;
    _classCallCheck(this, Sparkle);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.type = 'actor-item actor-sparkle';
    _this.args.animation = 'standing';
    _this.args.width = 24;
    _this.args.height = 24;
    _this.willStick = true;
    _this.stayStuck = true;
    _this.args.float = -1;
    _this.args.static = true;
    _this.args.invincible = true;
    _this.args.offset = (_this$args$offset = _this.args.offset) !== null && _this$args$offset !== void 0 ? _this$args$offset : 0;
    return _this;
  }
  _createClass(Sparkle, [{
    key: "collideA",
    value: function collideA(other, type) {
      if (other instanceof _Projectile.Projectile) return false;
      _get(_getPrototypeOf(Sparkle.prototype), "collideA", this).call(this, other, type);
    }
  }, {
    key: "update",
    value: function update() {
      if (!this.viewport) {
        return;
      }
      const viewport = this.viewport;
      if (!this.lightning) {
        this.lightning = new _Tag.Tag(`<div class = "particle-sparkle-lightning">`);
        viewport.particles.add(this.lightning);
        this.lightning.style({
          '--x': this.args.x,
          '--y': this.args.y + -64
        });
      }
      const frameId = viewport.args.frameId + -this.args.offset;
      if (frameId % 180 > 150) {
        this.args.animation = 'flicker-fast';
      } else if (frameId % 180 > 120) {
        this.args.animation = 'flicker';
      } else {
        this.args.animation = 'standing';
      }
      const direction = this.args.mode === 0 ? 1 : -1;
      const angle = -Math.PI / 2 * direction;
      if (frameId % 180 > 168) {
        const length = this.castRayQuick(2048, angle);
        this.args.invincible = true;
        this.lightning.style({
          height: `${length - this.args.height}px`
        });
        const toX = this.args.x + Math.round(Math.cos(angle) * (length + -1));
        const toY = this.args.y + Math.round(Math.sin(angle) * (length + -1));
        const blocking = viewport.actorsAtLine(this.args.x, this.args.y, toX, toY);
        blocking.delete(this);
        for (const _ref of blocking) {
          var _ref2 = _slicedToArray(_ref, 2);
          const b = _ref2[0];
          const p = _ref2[1];
          if (!b.controllable) {
            continue;
          }
          b.damage(this, 'electric');
          b.pop && b.pop(this);
        }
      } else {
        this.lightning.style({
          height: '0px'
        });
        this.args.invincible = false;
      }
      if (frameId % 180 === 0) {
        const length = this.castRayQuick(2048, angle);
        this.lightning.style({
          '--x': this.args.x,
          '--y': this.args.y + -length * 0.5 + (this.args.mode === 2 ? length : 0) + direction * this.args.height * 0.5
        });
        const toX = this.args.x + Math.round(Math.cos(angle) * (length + -1));
        const toY = this.args.y + Math.round(Math.sin(angle) * (length + -1));
        this.args.x = toX;
        this.args.y = toY;
        this.args.facing = direction > 0 ? 'right' : 'left';
        this.args.mode = this.args.mode === 0 ? 2 : 0;
        if (this.vizi) {
          const speed = 0.25;
          const sparkL = new _Projectile.Projectile({
            owner: this,
            subType: 'spark',
            damageType: 'electric',
            gravity: 0,
            ySpeed: speed * direction,
            xSpeed: -speed,
            x: this.args.x,
            y: this.args.y
          });
          const sparkR = new _Projectile.Projectile({
            owner: this,
            subType: 'spark',
            damageType: 'electric',
            gravity: 0,
            ySpeed: speed * direction,
            xSpeed: speed,
            x: this.args.x,
            y: this.args.y
          });
          viewport.spawn.add({
            object: sparkL
          });
          viewport.spawn.add({
            object: sparkR
          });
        }
      }
      _get(_getPrototypeOf(Sparkle.prototype), "update", this).call(this);
    }
  }, {
    key: "effect",
    value: function effect(other) {
      _get(_getPrototypeOf(Sparkle.prototype), "effect", this).call(this, other);
    }
  }, {
    key: "pop",
    value: function pop(other) {
      const viewport = this.viewport;
      _get(_getPrototypeOf(Sparkle.prototype), "pop", this).call(this, other);
      if (this.args.gone) {
        viewport.particles.remove(this.lightning);
      }
    }
  }, {
    key: "solid",
    get: function get() {
      return false;
    }
  }, {
    key: "isEffect",
    get: function get() {
      return false;
    }
    // get controllable() { return true; }
  }]);
  return Sparkle;
}(_Mixin.Mixin.from(_PointActor.PointActor, _CanPop.CanPop));
exports.Sparkle = Sparkle;
});

;require.register("actor/Spawner.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Spawner = void 0;
var _PointActor2 = require("./PointActor");
var _ObjectPalette = require("../ObjectPalette");
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let Spawner = /*#__PURE__*/function (_PointActor) {
  _inherits(Spawner, _PointActor);
  var _super = _createSuper(Spawner);
  function Spawner() {
    var _this;
    _classCallCheck(this, Spawner);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.width = 16;
    _this.args.height = 32;
    _this.args.type = 'actor-item actor-spawner';
    return _this;
  }
  _createClass(Spawner, [{
    key: "activate",
    value: function activate() {
      if (!this.args.spawn || !this.args.point) {
        return;
      }
      const point = this.viewport.objDefs.get(this.args.point);
      const type = _ObjectPalette.ObjectPalette[this.args.spawn];
      if (!point || !type) {
        return;
      }
      const spawned = new type({
        x: point.x,
        y: point.y
      });
      for (const _ref of this.def) {
        var _ref2 = _slicedToArray(_ref, 2);
        const property = _ref2[0];
        const value = _ref2[1];
        if (property === 'point' || property === 'type') {
          continue;
        }
        spawned.args[property] = value;
      }
      spawned.args[name] = this.args.spawn;
      this.viewport.spawn.add({
        object: spawned
      });
      this.viewport.setColCell(spawned);
    }
  }, {
    key: "solid",
    get: function get() {
      return false;
    }
  }]);
  return Spawner;
}(_PointActor2.PointActor);
exports.Spawner = Spawner;
});

;require.register("actor/SpikeBomb.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SpikeBomb = void 0;
var _PointActor2 = require("./PointActor");
var _Sfx = require("../audio/Sfx");
var _Tag = require("curvature/base/Tag");
var _RedBomb = require("./RedBomb");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let SpikeBomb = /*#__PURE__*/function (_PointActor) {
  _inherits(SpikeBomb, _PointActor);
  var _super = _createSuper(SpikeBomb);
  function SpikeBomb() {
    var _this;
    _classCallCheck(this, SpikeBomb);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.width = 24;
    _this.args.height = 24;
    _this.args.type = 'actor-item actor-spike-bomb';
    _this.args.decel = 0;
    _this.explosions = new Set();
    return _this;
  }
  _createClass(SpikeBomb, [{
    key: "update",
    value: function update() {
      if (!this.args.falling && this.groundTime > 1) {
        this.explode();
      }
      _get(_getPrototypeOf(SpikeBomb.prototype), "update", this).call(this);
      for (const explosion of this.explosions) {
        explosion.style({
          '--x': this.args.x,
          '--y': this.args.y + -16
        });
      }
    }
  }, {
    key: "collideA",
    value: function collideA(other) {
      if (!other.controllable) {
        return;
      }
      other.damage(this);
      this.explode();
      this.args.float = -1;
      // this.args.xSpeed = 0;
      // this.args.ySpeed = 0;
    }
  }, {
    key: "explode",
    value: function explode() {
      if (this.exploded) {
        return;
      }
      this.exploded = true;
      this.args.type = 'actor-item actor-air-bomb hide';
      const redA = new _RedBomb.RedBomb({
        x: this.args.x,
        y: this.args.y + -1,
        owner: this
      });
      const redB = new _RedBomb.RedBomb({
        x: this.args.x,
        y: this.args.y + -1,
        owner: this
      });
      redA.args.ySpeed = -this.ySpeedLast * 0.5;
      redB.args.ySpeed = -this.ySpeedLast * 0.5;
      redA.args.xSpeed = -this.ySpeedLast * 0.35;
      redB.args.xSpeed = +this.ySpeedLast * 0.35;
      this.viewport.spawn.add({
        object: redA
      });
      this.viewport.spawn.add({
        object: redB
      });
      this.viewport.actors.remove(this);
      _Sfx.Sfx.play('OBJECT_DESTROYED');
    }
  }]);
  return SpikeBomb;
}(_PointActor2.PointActor);
exports.SpikeBomb = SpikeBomb;
});

;require.register("actor/SpikeRing.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SpikeRing = void 0;
var _PointActor2 = require("./PointActor");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let SpikeRing = /*#__PURE__*/function (_PointActor) {
  _inherits(SpikeRing, _PointActor);
  var _super = _createSuper(SpikeRing);
  function SpikeRing() {
    var _this;
    _classCallCheck(this, SpikeRing);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.width = 64;
    _this.args.height = 32;
    _this.args.type = 'actor-item actor-spike-ring';
    _this.args.float = -1;
    _this.oscMode = 0;
    return _this;
  }
  _createClass(SpikeRing, [{
    key: "collideA",
    value: function collideA(other) {
      if (other.controllable) {
        other.damage(this);
      }
    }
  }, {
    key: "update",
    value: function update() {
      const speed = 1.75;
      if (this.oscMode) {
        this.args.y -= speed * Math.sign(this.args.y - this.objDef.y);
        if (Math.abs(this.args.y - this.objDef.y) < speed) {
          this.args.y = this.objDef.y;
          this.oscMode = 0;
        }
      } else {
        this.args.y -= speed * Math.sign(this.args.y - this.args.riseTo);
        if (Math.abs(this.args.y - this.args.riseTo) < speed) {
          this.args.y = this.args.riseTo;
          this.oscMode = 1;
        }
      }
    }
  }]);
  return SpikeRing;
}(_PointActor2.PointActor);
exports.SpikeRing = SpikeRing;
});

;require.register("actor/Spikes.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Spikes = void 0;
var _PointActor2 = require("./PointActor");
var _Sfx = require("../audio/Sfx");
var _Block = require("./Block");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let Spikes = /*#__PURE__*/function (_PointActor) {
  _inherits(Spikes, _PointActor);
  var _super = _createSuper(Spikes);
  function Spikes() {
    var _this$args$retractibl;
    var _this;
    let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let parent = arguments.length > 1 ? arguments[1] : undefined;
    _classCallCheck(this, Spikes);
    _this = _super.call(this, args, parent);
    _this.args.type = 'actor-item actor-spikes';
    _this.args.width = args.width || 32;
    _this.args.height = args.height || 32;
    _this.args.pointing = _this.args.pointing || 0;
    _this.args.retractible = (_this$args$retractibl = _this.args.retractible) !== null && _this$args$retractibl !== void 0 ? _this$args$retractibl : false;
    _this.args.retracted = false;
    _this.args.offset = _this.args.offset || 0;
    _this.args.beat = _this.args.beat || 90;
    _this.hazard = true;
    return _this;
  }
  _createClass(Spikes, [{
    key: "updateStart",
    value: function updateStart() {
      if (this.args.retractible) {
        this.args.wasRetracted = this.args.retracted;
        const frameId = this.viewport.args.frameId + -this.viewport.args.startFrameId + -this.args.offset;
        this.args.retracted = !!(Math.floor(frameId / this.args.beat) % 2);
        if (!this.args.retracted && this.args.wasRetracted) {
          this.vizi && _Sfx.Sfx.play('SPIKES_OUT');
          const actors = this.viewport.actorsAtPoint(this.args.x, this.args.y, this.args.width, this.args.height);
          for (const actor of actors) {
            if (actor === this || actor.isRegion || actor.args.static) {
              continue;
            }
            switch (this.args.pointing) {
              case 0:
                actor.args.y = this.args.y + -this.args.height + -1;
                break;
              case 1:
                actor.args.x = this.args.x + -(this.args.width / 2) + -(actor.args.width / 2) + -1;
                actor.damage(this);
                break;
              case 2:
                actor.args.y = this.args.y + other.args.height;
                break;
              case 3:
                actor.args.x = this.args.y + this.args.width / 2 + actor.args.width / 2 + 1;
                actor.damage(this);
                break;
            }
          }
        }
        if (this.args.retracted && !this.args.wasRetracted) {
          this.vizi && _Sfx.Sfx.play('SPIKES_IN');
        }
      }
      _get(_getPrototypeOf(Spikes.prototype), "updateStart", this).call(this);
    }
  }, {
    key: "onRendered",
    value: function onRendered(event) {
      _get(_getPrototypeOf(Spikes.prototype), "onRendered", this).call(this, event);
      this.autoAttr.get(this.box)['data-pointing'] = 'pointing';
      this.autoAttr.get(this.box)['data-retracted'] = 'retracted';
    }
  }, {
    key: "startle",
    value: function startle() {}
  }, {
    key: "damage",
    value: function damage() {}
  }, {
    key: "collideA",
    value: function collideA(other, type) {
      if (this.args.retracted) {
        return false;
      }
      if (other.isRegion) {
        return;
      }

      // if(!other.controllable)
      // {
      // 	return true;
      // }

      if (!this.args.static && this.args.falling && !this.args.float) {
        other.damage(false);
        return true;
      }
      if (!(other instanceof _Block.Block) && type === this.args.pointing) {
        if (this.args.pointing === 3) {
          const speed = other.args.xSpeed || other.args.gSpeed * (other.args.mode === 2 ? -1 : 1);
          if (speed <= 0) {
            if (!other.noClip && !this.args.retracted && this.args.wasRetracted) {
              other.args.x = this.args.x + this.args.width / 2 + other.args.width / 2 + 4;
            }
            other.damage(this);
          }
        } else if (this.args.pointing === 1) {
          const speed = other.args.xSpeed || other.args.gSpeed * (other.args.mode === 2 ? -1 : 1);
          if (speed >= 0) {
            if (!other.noClip && !this.args.retracted && this.args.wasRetracted) {
              other.args.x = this.args.x + -(this.args.width / 2) + -(other.args.width / 2) + -4;
            }
            other.damage(this);
          }
        } else if (this.args.pointing === 2) {
          const speed = other.args.ySpeed || other.args.gSpeed * (other.args.mode === 1 ? -1 : 1);
          if (speed <= 0) {
            if (!other.noClip && !this.args.retracted && this.args.wasRetracted) {
              other.args.y = this.args.y + other.args.height;
            }
            other.damage(this);
          }
        } else if (this.args.pointing === 0) {
          const speed = other.args.ySpeed || other.args.gSpeed * (other.args.mode === 3 ? -1 : 1);
          if (speed >= 0) {
            if (!other.noClip && !this.args.retracted && this.args.wasRetracted) {
              other.args.y = this.args.y + -this.args.height + 0;
            }
            other.damage(this);
          }
        }
      }
      return true;
    }
  }, {
    key: "solid",
    get: function get() {
      return !this.args.retracted && !this.args.wasRetracted;
    }
  }], [{
    key: "fromDef",
    value: function fromDef(objDef) {
      const obj = _get(_getPrototypeOf(Spikes), "fromDef", this).call(this, objDef);
      obj.args.width = objDef.width;
      obj.args.height = objDef.height;
      obj.args.x = obj.originalX = objDef.x + Math.floor(objDef.width / 2);
      return obj;
    }
  }]);
  return Spikes;
}(_PointActor2.PointActor);
exports.Spikes = Spikes;
});

;require.register("actor/SpikesSmall.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SpikesSmall = void 0;
var _Tag = require("curvature/base/Tag");
var _Sfx = require("../audio/Sfx");
var _PointActor = require("./PointActor");
var _Spikes2 = require("./Spikes");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let SpikesSmall = /*#__PURE__*/function (_Spikes) {
  _inherits(SpikesSmall, _Spikes);
  var _super = _createSuper(SpikesSmall);
  function SpikesSmall() {
    var _this;
    let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let parent = arguments.length > 1 ? arguments[1] : undefined;
    _classCallCheck(this, SpikesSmall);
    _this = _super.call(this, args, parent);
    _this.args.type = 'actor-item actor-spikes actor-spikes-small';
    _this.args.width = args.width || 32;
    _this.args.height = 10;
    _this.args.pointing = _this.args.pointing || 0;
    _this.hazard = true;
    if (_this.args.width < 16) {
      _this.args.narrow = true;
    }
    return _this;
  }
  _createClass(SpikesSmall, [{
    key: "update",
    value: function update() {
      _get(_getPrototypeOf(SpikesSmall.prototype), "update", this).call(this);
      const breakSplit = 4;
      if (this.sprite && !this.graphic) {
        this.graphic = new _Tag.Tag(`<svg style  = "--breakSplit: ${breakSplit};" data-narrow = "${this.args.narrow}">
				<defs>
					<pattern
						id     = "spikes-${this._id}"
						width  = "${16 / this.args.width}"
						height = "1"
						x      = "0"
						y      = "0"
					>
						<image href = "/Sonic/spikes-small-single.png">
					</pattern>
				</defs>
				<rect fill = "url(#spikes-${this._id})"></rect>
				<rect fill = "url(#spikes-${this._id})"></rect>
			</svg>`);
        this.sprite.appendChild(this.graphic.node);
      }
    }
  }, {
    key: "collideA",
    value: function collideA(other, type) {
      if (this.args.broken || other instanceof _Spikes2.Spikes || other.args.static) {
        return false;
      }
      if (other.isVehicle) {
        this.args.broken = true;
        this.args.gravity = 0.40;
        other.halt(10);
        const minSpace = 8 + (other.args.width + this.args.width) / 2;
        other.args.x = this.x + -minSpace * Math.sign(this.x - other.x);
        this.args.type = 'actor-item actor-spikes actor-spikes-small actor-spikes-breaking';
        this.viewport.onFrameOut(7, () => {
          this.args.falling = true;
          this.args.xSpeed = other.args.hSpeed * 0.25 + 1 * Math.pow(Math.random(), 2);
          this.args.ySpeed = -5 + -5 * Math.pow(Math.random(), 2);
          this.args.type = 'actor-item actor-spikes actor-spikes-small actor-spikes-broken';
          _Sfx.Sfx.play('BLOCK_DESTROYED');
        });
        this.args.float = 8;
        this.noClip = true;
        return false;
      }
      return _get(_getPrototypeOf(SpikesSmall.prototype), "collideA", this).call(this, other, type);
    }
  }, {
    key: "activate",
    value: function activate() {
      this.args.float = 0;
      this.noClip = true;
    }
  }, {
    key: "solid",
    get: function get() {
      return !this.args.broken && !this.noClip;
    }
  }], [{
    key: "fromDef",
    value: function fromDef(objDef) {
      const obj = _get(_getPrototypeOf(SpikesSmall), "fromDef", this).call(this, objDef);
      obj.args.width = objDef.width;
      obj.args.height = 10;
      obj.args.x = obj.originalX = objDef.x + Math.floor(objDef.width / 2);
      return obj;
    }
  }]);
  return SpikesSmall;
}(_Spikes2.Spikes);
exports.SpikesSmall = SpikesSmall;
});

;require.register("actor/SpinBridge.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SpinBridge = void 0;
var _Block2 = require("./Block");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let SpinBridge = /*#__PURE__*/function (_Block) {
  _inherits(SpinBridge, _Block);
  var _super = _createSuper(SpinBridge);
  function SpinBridge() {
    var _this;
    let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let parent = arguments.length > 1 ? arguments[1] : undefined;
    _classCallCheck(this, SpinBridge);
    _this = _super.call(this, args, parent);
    _defineProperty(_assertThisInitialized(_this), "segments", new Set());
    _this.args.offset = _this.args.offset || 0;
    _this.args.speed = _this.args.speed || 1;
    return _this;
  }
  _createClass(SpinBridge, [{
    key: "initialize",
    value: function initialize() {
      _get(_getPrototypeOf(SpinBridge.prototype), "initialize", this).call(this);
      if (!this.getMapSolidAt(this.args.x + this.args.width, this.args.y)) {
        const firstSegment = this.args.prevSegment ? this.args.prevSegment.args.firstSegment : this;
        if (!this.args.segmentIndex) {
          this.args.segmentIndex = 0;
          this.args.firstSegment = this;
          this.segments.add(firstSegment);
        }
        if (this.args.segmentIndex >= 7) {
          return;
        }
        const next = new this.constructor({
          platform: this.args.platform,
          segmentIndex: this.args.segmentIndex + 1,
          prevSegment: this,
          firstSegment: firstSegment,
          float: -1,
          width: this.args.width,
          height: this.args.height,
          tileId: this.args.tileId,
          speed: this.args.speed,
          offset: this.args.offset,
          x: this.args.x + this.args.width,
          y: this.args.y + 4
        });
        firstSegment.segments.add(next);
        this.args.nextSegment = next;
        this.viewport.spawn.add({
          object: next
        });
        firstSegment.args.platform = true;
      }
    }
  }, {
    key: "updateEnd",
    value: function updateEnd() {
      const age = this.viewport.args.frameId * this.args.speed + this.args.offset;
      const originX = this.args.firstSegment.args.x;
      const originY = this.args.firstSegment.args.y;
      const dist = this.args.segmentIndex * 16;
      this.args.x = originX + Math.cos(age / 120 * Math.PI) * dist;
      this.args.y = originY + Math.sin(age / 120 * Math.PI) * dist;
      _get(_getPrototypeOf(SpinBridge.prototype), "updateEnd", this).call(this);
    }
  }, {
    key: "collideA",
    value: function collideA(other, type) {
      if (other instanceof SpinBridge) {
        return false;
      }
      return _get(_getPrototypeOf(SpinBridge.prototype), "collideA", this).call(this, other, type);
    }
  }]);
  return SpinBridge;
}(_Block2.Block);
exports.SpinBridge = SpinBridge;
});

;require.register("actor/Sping.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Sping = void 0;
var _Flickie = require("./Flickie");
var _Mixin = require("curvature/base/Mixin");
var _Tag = require("curvature/base/Tag");
var _PointActor = require("./PointActor");
var _SkidDust = require("../behavior/SkidDust");
var _CanPop = require("../mixin/CanPop");
var _Explosion = require("../actor/Explosion");
var _Projectile = require("../actor/Projectile");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let Sping = /*#__PURE__*/function (_Mixin$from) {
  _inherits(Sping, _Mixin$from);
  var _super = _createSuper(Sping);
  function Sping() {
    var _this;
    _classCallCheck(this, Sping);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _defineProperty(_assertThisInitialized(_this), "name", 'Spiny');
    _this.behaviors.add(new _SkidDust.SkidDust());
    _this.args.type = 'actor-item actor-sping';
    _this.args.animation = 'standing';
    _this.args.accel = 0.1;
    _this.args.decel = 0.5;
    _this.args.gSpeedMax = 5;
    _this.args.jumpForce = 5;
    _this.args.gravity = 0.5;
    _this.args.width = 48;
    _this.args.height = 22;
    _this.willStick = false;
    _this.stayStuck = false;
    return _this;
  }
  _createClass(Sping, [{
    key: "update",
    value: function update() {
      const direction = this.args.direction;
      const speed = 0.125;
      const beat = 90;
      if (this.age % beat < beat - 25) {
        if (Math.floor(this.age / beat) % 2) {
          this.args.gSpeed = -speed;
        } else {
          this.args.gSpeed = speed;
        }
      }
      if (this.box) {
        this.box.setAttribute('data-animation', 'walking');
        if (this.age % beat < 15 || this.age % beat > beat - 5) {
          this.box.setAttribute('data-animation', 'shooting');
        }
      }
      _get(_getPrototypeOf(Sping.prototype), "update", this).call(this);
      if (this.age % beat === beat - 3) {
        const x = this.x - 2;
        const y = this.y - 12;
        const z = -1;
        const xSpeed = -1.5 * Math.sign(this.gSpeedLast);
        const ySpeed = -3;
        const owner = this;
        const ball = new _Projectile.Projectile({
          x: x,
          y: y,
          z: z,
          owner: owner
        });
        if (!this.viewport) {
          return;
        }
        this.viewport.onFrameOut(2, () => {
          Object.assign(ball.args, {
            xSpeed: xSpeed,
            ySpeed: ySpeed
          });
        });
        this.viewport.spawn.add({
          object: ball
        });
      }
    }
  }, {
    key: "effect",
    value: function effect(other) {
      _get(_getPrototypeOf(Sping.prototype), "effect", this).call(this, other);

      // this.viewport.spawn.add({object:new Flickie({
      // 	x: this.args.x,
      // 	y: this.args.y,
      // })});
    }
  }, {
    key: "solid",
    get: function get() {
      return false;
    }
  }, {
    key: "isEffect",
    get: function get() {
      return false;
    }
    // get controllable() { return true; }
  }]);
  return Sping;
}(_Mixin.Mixin.from(_PointActor.PointActor, _CanPop.CanPop));
exports.Sping = Sping;
});

;require.register("actor/Spinner.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Spinner = void 0;
var _PointActor2 = require("./PointActor");
var _Block = require("./Block");
var _Sfx = require("../audio/Sfx");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
const Boosted = Symbol('Boosted');
let Spinner = /*#__PURE__*/function (_PointActor) {
  _inherits(Spinner, _PointActor);
  var _super = _createSuper(Spinner);
  function Spinner() {
    var _this;
    _classCallCheck(this, Spinner);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.type = 'actor-item actor-spinner';
    _this.args.width = 64;
    _this.args.height = 24;
    _this.args.direction = _this.args.direction || 1;
    _this.args.static = true;
    return _this;
  }
  _createClass(Spinner, [{
    key: "update",
    value: function update() {
      _get(_getPrototypeOf(Spinner.prototype), "update", this).call(this);
    }
  }, {
    key: "collideA",
    value: function collideA(other) {
      if (other.isRegion || other.args.static || other instanceof _Block.Block) {
        return;
      }
      if (other instanceof Spinner) {
        return;
      }
      if (other.args.gSpeed === 0) {
        // return;
      }
      if (other.args.falling || Math.sign(other.args.gSpeed) === Math.sign(this.args.direction) && Math.abs(other.args.gSpeed) > this.args.toSpeed) {
        return;
      }
      this.viewport.onFrameOut(10, () => delete other[Boosted]);
      other[Boosted] = this;
      const toSpeed = this.args.toSpeed || 40;
      other.args.ignore = 2;
      other.args.direction = this.args.direction;
      other.args.facing = this.args.direction > 0 ? 'right' : 'left';
      other.args.gSpeed = Math.max(Math.abs(other.args.gSpeed), toSpeed) * Math.sign(this.args.direction || 1);
      other.xAxis = 0;
      _Sfx.Sfx.play('SPEEDPAD_HIT');
    }
  }]);
  return Spinner;
}(_PointActor2.PointActor);
exports.Spinner = Spinner;
});

;require.register("actor/SpinningFloat.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SpinningFloat = void 0;
var _Block2 = require("./Block");
var _Sfx = require("../audio/Sfx");
var _Region = require("../region/Region");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let SpinningFloat = /*#__PURE__*/function (_Block) {
  _inherits(SpinningFloat, _Block);
  var _super = _createSuper(SpinningFloat);
  function SpinningFloat() {
    var _this;
    _classCallCheck(this, SpinningFloat);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.hitBlocks = true;
    _this.invertsBias = true;
    _this.args.width = 64;
    _this.args.height = 64;
    _this.args.platform = 1;
    // this.args.float    = -1;
    _this.args.type = 'actor-item actor-spinning-float';
    _this.args.static = 0;
    _this.args.gravity = 0.40;
    _this.args.spinning = 0;
    _this.args.bouncing = 0;
    _this.args.treadmill = true;
    _this.args.trackX = true;
    _this.args.particleScale = 1.25;
    _this.lastConvey = 0;
    return _this;
  }
  _createClass(SpinningFloat, [{
    key: "collideA",
    value: function collideA(other, type) {
      if (other.args.platform) {
        return false;
      }
      return _get(_getPrototypeOf(SpinningFloat.prototype), "collideA", this).call(this, other, type);
    }
  }, {
    key: "update",
    value: function update() {
      _get(_getPrototypeOf(SpinningFloat.prototype), "update", this).call(this);
      this.args.moving = this.args.falling || this.args.gSpeed;
      let inWater = false,
        topWater = false;
      const topRegions = this.viewport.regionsAtPoint(this.args.x, this.args.y - 36);
      for (const region of this.regions) {
        if (region.isWater) {
          inWater = true;
        }
      }
      for (const region of topRegions) {
        if (region.isWater) {
          topWater = true;
        }
      }
      if (topWater) {
        this.args.ySpeed -= this.args.gravity;
        this.args.falling = true;
        if (this.args.ySpeed > 0) {
          this.args.ySpeed *= 0.95;
        }
      }
      const bob = 0.25 + 3.5 * Math.abs(this.args.convey / 20);
      if (inWater && this.args.falling && Math.abs(this.args.ySpeed) < bob && (this.args.ySpeed > 0 || this.args.convey)) {
        if (!topWater && this.args.ySpeed > 0 || topWater && this.args.ySpeed < 0) {
          this.args.ySpeed = Math.sign(this.args.ySpeed) * bob;
        }
      }
      this.standingUnder.forEach(a => {
        a.args.xSpeed = this.args.xSpeed || this.args.gSpeed;
        if (a.xAxis && Math.abs(a.args.gSpeed) > 1) {
          if (!this.args.falling) {
            a.args.gSpeed *= 0.90;
          } else if (!inWater) {
            a.args.gSpeed *= 0.99;
          }
        }
        if (Math.abs(a.args.gSpeed) > 14) {
          a.args.gSpeed = 14 * Math.sign(a.args.gSpeed);
        }
        if (Math.abs(this.args.convey) > 8) {
          a.args.x = this.args.x;
        } else {
          if (a.groundTime < 2) {
            a.args.gSpeed = 0;
            a.args.xSpeed = 0;
            this.args.convey = 0;
          }
          if (Math.abs(this.args.x - a.args.x) < 1) {
            a.args.x = this.args.x;
          }
          a.args.x += 0.2 * (this.args.x - a.args.x);
        }
      });
      if (!this.args.falling && Math.abs(this.args.gSpeed) < Math.abs(this.args.convey)) {
        this.args.gSpeed = this.args.convey;
        this.args.xSpeed = this.args.gSpeed;
      } else if (inWater) {
        if (!this.args.xSpeed && this.gSpeedLast) {
          this.args.xSpeed = this.gSpeedLast;
          this.gSpeedLast = 0;
        }
        if (topWater && this.getMapSolidAt(this.x, this.y + 1)) {
          this.args.y--;
        }
        if (Math.abs(this.args.xSpeed) < 8) {
          this.args.xSpeed += 0.005 * this.args.convey;
        }
        if (this.args.falling) {
          this.args.xSpeed *= 0.99;
        } else {
          this.args.gSpeed = this.args.xSpeed;
        }
      }
    }
  }, {
    key: "sleep",
    value: function sleep() {
      this.args.y = this.originalY;
    }

    // get solid() { return true; }
  }]);
  return SpinningFloat;
}(_Block2.Block);
exports.SpinningFloat = SpinningFloat;
});

;require.register("actor/SpitFire.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SpitFire = void 0;
var _PointActor2 = require("./PointActor");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let SpitFire = /*#__PURE__*/function (_PointActor) {
  _inherits(SpitFire, _PointActor);
  var _super = _createSuper(SpitFire);
  function SpitFire() {
    var _this;
    _classCallCheck(this, SpitFire);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.type = 'actor-item actor-spitfire';
    _this.args.width = 99;
    _this.args.height = 32;
    _this.args.float = -1;
    _this.noClip = true;
    return _this;
  }
  _createClass(SpitFire, [{
    key: "update",
    value: function update() {
      if (this.age > 45) {
        this.args.gone = true;
        this.viewport.actors.remove(this);
        this.remove();
        return;
      }
      _get(_getPrototypeOf(SpitFire.prototype), "update", this).call(this);
    }
  }, {
    key: "collideA",
    value: function collideA(other) {
      if (this.age < 10) {
        return;
      }
      if (other.immune(this, 'fire')) {
        return;
      }
      if (this.args.owner && !this.args.owner.args.gone) {
        other.controllable && other.damage(this, 'fire');
      }
    }
  }]);
  return SpitFire;
}(_PointActor2.PointActor);
exports.SpitFire = SpitFire;
});

;require.register("actor/SpitSteam.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SpitSteam = void 0;
var _PointActor2 = require("./PointActor");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let SpitSteam = /*#__PURE__*/function (_PointActor) {
  _inherits(SpitSteam, _PointActor);
  var _super = _createSuper(SpitSteam);
  function SpitSteam() {
    var _this;
    _classCallCheck(this, SpitSteam);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.type = 'actor-item actor-spitsteam';
    _this.args.width = 79;
    _this.args.height = 16;
    _this.args.float = -1;
    _this.noClip = true;
    return _this;
  }
  _createClass(SpitSteam, [{
    key: "update",
    value: function update() {
      if (this.age > 30) {
        this.args.gone = true;
        this.viewport.actors.remove(this);
        this.remove();
        return;
      }
      _get(_getPrototypeOf(SpitSteam.prototype), "update", this).call(this);
    }
  }, {
    key: "collideA",
    value: function collideA(other) {
      if (this.age < 8) {
        return;
      }
      if (!other.controllable) {
        return;
      }
      if (this.args.owner && !this.args.owner.args.gone) {
        other.args.ignore = 3;
        other.args.antiSkid = 8;
        other.args.x += this.args.direction;
        other.args.xSpeed = this.args.direction * 12;
        other.args.falling = true;
        // other.controllable && other.damage(this, 'fire');
      }
    }
  }]);
  return SpitSteam;
}(_PointActor2.PointActor);
exports.SpitSteam = SpitSteam;
});

;require.register("actor/Splats.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Splats = void 0;
var _Flickie = require("./Flickie");
var _Mixin = require("curvature/base/Mixin");
var _PointActor = require("./PointActor");
var _Patrol = require("../behavior/Patrol");
var _CanPop = require("../mixin/CanPop");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let Splats = /*#__PURE__*/function (_Mixin$from) {
  _inherits(Splats, _Mixin$from);
  var _super = _createSuper(Splats);
  function Splats() {
    var _this$args$patrolPaus, _this$args$patrolBeat, _this$args$patrolSpee;
    var _this;
    _classCallCheck(this, Splats);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.behaviors.add(new _Patrol.Patrol());
    _this.args.type = 'actor-item actor-splats';
    _this.args.animation = 'standing';
    _this.args.accel = 0.1;
    _this.args.decel = 0.5;
    _this.args.gSpeedMax = 5;
    _this.args.jumpForce = 5;
    _this.args.gravity = 0.5;
    _this.args.width = 24;
    _this.args.height = 48;
    _this.willStick = false;
    _this.stayStuck = false;
    _this.args.patrolPause = (_this$args$patrolPaus = _this.args.patrolPause) !== null && _this$args$patrolPaus !== void 0 ? _this$args$patrolPaus : 40;
    _this.args.patrolBeat = (_this$args$patrolBeat = _this.args.patrolBeat) !== null && _this$args$patrolBeat !== void 0 ? _this$args$patrolBeat : 140;
    _this.args.patrolSpeed = (_this$args$patrolSpee = _this.args.patrolSpeed) !== null && _this$args$patrolSpee !== void 0 ? _this$args$patrolSpee : 1;
    return _this;
  }
  _createClass(Splats, [{
    key: "update",
    value: function update() {
      const direction = this.args.direction;
      const telegraph = this.args.shotTelegraph;
      const beat = this.args.patrolBeat;
      if (this.box) {
        if (this.args.moving && this.args.gSpeed) {
          this.box.setAttribute('data-animation', 'walking');
        } else {
          this.box.setAttribute('data-animation', 'standing');
        }
      }
      _get(_getPrototypeOf(Splats.prototype), "update", this).call(this);
      this.args.direction = Math.sign(this.args.xSpeed || this.args.gSpeed);
      if (!this.args.falling && !this.jumpTimer) {
        this.jumpTimer = this.onNextFrame(() => {
          this.args.ySpeed = Math.max(-this.ySpeedLast, -12) || -6;
          this.args.xSpeed = this.args.gSpeed;
          this.args.falling = true;
          this.jumpTimer = false;
          this.args.y -= 32;
        });
      }
    }
  }, {
    key: "effect",
    value: function effect(other) {
      _get(_getPrototypeOf(Splats.prototype), "effect", this).call(this, other);

      // this.viewport.spawn.add({object:new Flickie({
      // 	x: this.args.x,
      // 	y: this.args.y,
      // })});
    }
  }, {
    key: "solid",
    get: function get() {
      return false;
    }
  }, {
    key: "isEffect",
    get: function get() {
      return false;
    }
    // get controllable() { return true; }
  }]);
  return Splats;
}(_Mixin.Mixin.from(_PointActor.PointActor, _CanPop.CanPop));
exports.Splats = Splats;
});

;require.register("actor/Spring.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Spring = void 0;
var _LayerSwitch = require("./LayerSwitch");
var _PointActor2 = require("./PointActor");
var _BreakableBlock = require("./BreakableBlock");
var _Region = require("../region/Region");
var _Sfx = require("../audio/Sfx");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
const WillSpring = Symbol('WillSpring');
const WontSpring = Symbol('WontSpring');
let Spring = /*#__PURE__*/function (_PointActor) {
  _inherits(Spring, _PointActor);
  var _super = _createSuper(Spring);
  function Spring() {
    var _this$args$static;
    var _this;
    _classCallCheck(this, Spring);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _defineProperty(_assertThisInitialized(_this), "float", -1);
    _defineProperty(_assertThisInitialized(_this), "keepAngle", true);
    _defineProperty(_assertThisInitialized(_this), "template", `<div
		class = "point-actor actor-item [[type]] [[collType]] [[active]]"
		style = "
			display:[[display]];
			--angle:[[angle]];
			--airAngle:[[airAngle]];
			--ground-angle:[[groundAngle]];
			--height:[[height]];
			--width:[[width]];
			--x:[[x]];
			--y:[[y]];
		"
		data-colliding = "[[colliding]]"
		data-diagonal  = "[[diagonal]]"
		data-falling   = "[[falling]]"
		data-facing    = "[[facing]]"
		data-angle     = "[[angle|rad2deg]]"
		data-mode      = "[[mode]]"
	>
		<div
			data-color = "[[color]]"
			data-type  = "[[base]]"
			class      = "spring-pad"
			style = "--color:[[color]]deg"
		></div>
		<div class = "sprite"></div>
	</div>`);
    _this.args.type = 'actor-item actor-spring';
    _this.args.width = _this.args.width || 32;
    _this.args.height = _this.args.height || 32;
    _this.args.color = _this.args.color || 0;
    _this.args.static = (_this$args$static = _this.args.static) !== null && _this$args$static !== void 0 ? _this$args$static : true;
    _this.args.actingOn = new Set();
    _this.args.blocked = false;
    _this.holding = new Set();
    return _this;
  }
  _createClass(Spring, [{
    key: "updateEnd",
    value: function updateEnd() {
      _get(_getPrototypeOf(Spring.prototype), "updateEnd", this).call(this);
      this.args.blocked = false;
      if (this.viewport.collisions.has(this)) {
        for (const _ref of this.viewport.collisions.get(this)) {
          var _ref2 = _slicedToArray(_ref, 2);
          const third = _ref2[0];
          const thirdType = _ref2[1];
          if (thirdType === -1 && !third.broken && third instanceof _BreakableBlock.BreakableBlock) {
            this.args.blocked = true;
          }
        }
      }
      if (this.args.blocked) {
        return false;
      }
      for (const other of this.holding) {
        this.springActor(other);
        this.viewport.onFrameOut(5, () => {
          this.holding.delete(other);
        });
      }
    }
  }, {
    key: "collideA",
    value: function collideA(other, type) {
      if (this.args.blocked) {
        return false;
      }
      if (other.carriedBy) {
        return false;
      }
      if (other.args.hangingFrom) {
        other.args.hangingFrom.unhook(other);
      }
      if (other[WillSpring] || other[WontSpring]) {
        return false;
      }
      if (other.args.static) {
        return false;
      }
      if (other instanceof this.constructor) {
        return false;
      }
      if (other instanceof _LayerSwitch.LayerSwitch) {
        return false;
      }
      _get(_getPrototypeOf(Spring.prototype), "collideA", this).call(this, other, type);
      if (this.args.actingOn.has(other)) {
        return false;
      }
      if (other.args.platform) {
        return false;
      }
      if (other instanceof _Region.Region) {
        return false;
      }
      other.args.falling = true;
      this.holding.add(other);
      if (other.controllable) {
        this.args.gSpeed = 0;
      }
      return false;
    }
  }, {
    key: "springActor",
    value: function springActor(other) {
      if (other[WillSpring]) {
        return false;
      }
      _Sfx.Sfx.play('SPRING_HIT');
      const rounded = this.roundAngle(this.args.angle, 8, true);
      other.args.x = this.args.x + Math.cos(rounded) * 4;
      other.args.y = this.args.y + Math.sin(rounded) * 4;
      this.args.actingOn.add(other);
      this.viewport.onFrameOut(1, () => {
        this.args.active = true;
      });
      this.viewport.onFrameOut(5, () => {
        delete other[WillSpring];
        this.args.active = false;
        this.args.actingOn.delete(other);
      });
      if (other.noClip) {
        return false;
      }
      other.args.gSpeed = 0;
      other.args.xSpeed = 0;
      other.args.ySpeed = 0;

      // other.args.direction = Math.sign(this.args.gSpeed);

      other[WillSpring] = true;
      other.args.mercy = 0;

      // const rounded = this.roundAngle(this.args.angle, 8, true);

      if (this.viewport.settings.rumble && other.controller && other.controller.rumble) {
        other.controller.rumble({
          duration: 120,
          strongMagnitude: 1.0,
          weakMagnitude: 1.0
        });
        this.onTimeout(100, () => {
          other.controller.rumble({
            duration: 500,
            strongMagnitude: 0.0,
            weakMagnitude: 0.25
          });
        });
      }
      other.locked = 2;
      other.args.jumping = false;
      other.args.ignore = other.args.ignore || (other.args.falling ? 12 : 2);
      other.args.float = Math.max(2, other.args.float);
      this.viewport.onFrameOut(1, () => {
        other.args.float = Math.max(2, other.args.float);
        other.args.mode = 0;
        other.args.direction = Math.sign(xImpulse) || other.args.direction;
        other.args.flying = false;
        other.impulse(this.args.power, rounded, ![0, Math.PI].includes(this.args.angle) && Math.abs(Math.PI - this.args.angle) > 0.01);
      });
      const xImpulse = Number(Number(Math.cos(rounded) * 1).toFixed(3));
      const yImpulse = Number(Number(Math.sin(rounded) * 1).toFixed(3));
      const isRolling = other.args.rolling;
      if (![0, Math.PI].includes(this.args.angle) && Math.abs(Math.PI - this.args.angle) > 0.01 || other.args.falling || other.args.mode !== 0) {
        other.args.falling = true;
        other.args.mode = 0;
      } else {
        // this.viewport.onFrameOut(4, () => other.args.rolling = isRolling);
        // this.viewport.onFrameOut(3, () => other.args.rolling = isRolling);
        // this.viewport.onFrameOut(2, () => other.args.rolling = isRolling);
        this.viewport.onFrameOut(1, () => other.args.rolling = isRolling);
      }
      if (Math.abs(other.args.xSpeed) < 3 || Math.sign(other.args.xSpeed) !== Math.sign(xImpulse)) {
        other.args.xSpeed = xImpulse;
      } else {
        other.args.xSpeed += xImpulse;
      }
      if (Math.abs(other.args.ySpeed) < 3 || Math.sign(other.args.ySpeed) !== Math.sign(yImpulse)) {
        other.args.ySpeed = yImpulse;
      } else {
        other.args.ySpeed += yImpulse;
      }
      other.args.airAngle = this.args.angle;
      other.args.displayAngle = 0;
      other.args.groundAngle = 0;
      other.args.airAngle = -Math.PI / 2;
      other.args.mode = 0;
    }
  }, {
    key: "sleep",
    value: function sleep() {
      this.args.actingOn.clear();
      this.args.active = false;
    }
  }, {
    key: "canStick",
    get: function get() {
      return false;
    }
  }, {
    key: "solid",
    get: function get() {
      return false;
    }
  }], [{
    key: "fromDef",
    value: function fromDef(objDef) {
      const obj = _get(_getPrototypeOf(Spring), "fromDef", this).call(this, objDef);
      obj.args.angle = Number(obj.args.angle);
      obj.args.width = objDef.width || 32;
      obj.args.height = objDef.height || 32;
      return obj;
    }
  }]);
  return Spring;
}(_PointActor2.PointActor);
exports.Spring = Spring;
_defineProperty(Spring, "WontSpring", WontSpring);
});

;require.register("actor/SpringTurtle.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SpringTurtle = void 0;
var _Mixin = require("curvature/base/Mixin");
var _PointActor = require("./PointActor");
var _Patrol = require("../behavior/Patrol");
var _CanPop = require("../mixin/CanPop");
var _Ring = require("./Ring");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let SpringTurtle = /*#__PURE__*/function (_Mixin$from) {
  _inherits(SpringTurtle, _Mixin$from);
  var _super = _createSuper(SpringTurtle);
  function SpringTurtle() {
    var _this$args$patrolPaus, _this$args$patrolBeat, _this$args$patrolSpee;
    var _this;
    _classCallCheck(this, SpringTurtle);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.behaviors.add(new _Patrol.Patrol());
    _this.args.type = 'actor-item actor-spring-turtle';
    _this.args.animation = 'standing';
    _this.args.accel = 0.1;
    _this.args.decel = 0.5;
    _this.args.gSpeedMax = 3;
    _this.args.gravity = 0.5;
    _this.args.width = 24;
    _this.args.height = 32;
    _this.willStick = false;
    _this.stayStuck = false;
    _this.args.patrolPause = (_this$args$patrolPaus = _this.args.patrolPause) !== null && _this$args$patrolPaus !== void 0 ? _this$args$patrolPaus : 10;
    _this.args.patrolBeat = (_this$args$patrolBeat = _this.args.patrolBeat) !== null && _this$args$patrolBeat !== void 0 ? _this$args$patrolBeat : 120;
    _this.args.patrolSpeed = (_this$args$patrolSpee = _this.args.patrolSpeed) !== null && _this$args$patrolSpee !== void 0 ? _this$args$patrolSpee : 1;
    _this.args.lastSpring = 0;
    return _this;
  }
  _createClass(SpringTurtle, [{
    key: "onRendered",
    value: function onRendered(event) {
      _get(_getPrototypeOf(SpringTurtle.prototype), "onRendered", this).call(this, event);
      this.autoAttr.get(this.box)['data-spring'] = 'springing';
    }
  }, {
    key: "collideA",
    value: function collideA(other, type) {
      if (other.args.static) {
        return;
      }
      if (type === 0 || other.args.falling) {
        this.ignores.set(other, 15);
        other.args.ySpeed = -20;
        other.args.xSpeed = 0;
        this.args.lastSpring = 10;
        return;
      }
      return _get(_getPrototypeOf(SpringTurtle.prototype), "collideA", this).call(this, other, type);
    }
  }, {
    key: "update",
    value: function update() {
      _get(_getPrototypeOf(SpringTurtle.prototype), "update", this).call(this);
      if (this.args.lastSpring > 0) {
        this.args.lastSpring--;
      }
      this.args.springing = !!this.args.lastSpring;
      if (this.args.moving && this.args.gSpeed) {
        this.args.animation = 'walking';
      } else {
        this.args.animation = 'standing';
      }
      this.args.direction = Math.sign(this.args.gSpeed);
    }
  }, {
    key: "solid",
    get: function get() {
      return false;
    }
  }, {
    key: "isEffect",
    get: function get() {
      return false;
    }
  }]);
  return SpringTurtle;
}(_Mixin.Mixin.from(_PointActor.PointActor, _CanPop.CanPop));
exports.SpringTurtle = SpringTurtle;
});

;require.register("actor/Springboard.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Springboard = void 0;
var _PointActor2 = require("./PointActor");
var _Sfx = require("../audio/Sfx");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let Springboard = /*#__PURE__*/function (_PointActor) {
  _inherits(Springboard, _PointActor);
  var _super = _createSuper(Springboard);
  function Springboard() {
    var _this;
    _classCallCheck(this, Springboard);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.type = 'actor-item actor-springboard';
    _this.args.width = 56;
    _this.args.height = 16;
    _this.args.animation = 'idle';
    return _this;
  }
  _createClass(Springboard, [{
    key: "collideA",
    value: function collideA(other, type) {
      if (this.args.ignore) {
        return;
      }
      let power = Math.min(1, Math.max(0, 1 + (-this.x + -26 + other.x) / 56));
      if (power < 0.5) {
        power *= 0.5;
      }
      this.args.animation = 'depressed';
      if (other.args.jumping && this.args.animation !== 'idle' && other.args.ySpeed < 0) {
        this.args.ignore = 6;
        this.args.animation = 'idle';
        const xSpeed = Math.max(other.args.gSpeed / 2, other.args.xSpeed);
        this.onNextFrame(() => {
          other.args.xSpeed = xSpeed;
          other.args.ySpeed += -12 * power;
        });
        _Sfx.Sfx.play('SPRING_HIT');
      }
      if (-this.x + other.x <= -26) {
        this.args.animation = 'idle';
      }
      if ((-this.x + other.x >= 26 || Math.abs(other.args.gSpeed) > 13) && other.args.mode === 0) {
        this.args.ignore = 6;
        const xSpeed = Math.max(other.args.gSpeed / 2, other.args.xSpeed);
        this.onNextFrame(() => {
          other.args.falling = true;
          other.args.xSpeed = xSpeed;
          other.args.ySpeed = -8;
        });
        this.viewport.onFrameOut(5, () => this.args.animation = 'idle');
        _Sfx.Sfx.play('SPRING_HIT');
      }
      if (other.args.ySpeed < 0) {
        this.args.animation = 'idle';
      }
    }
  }]);
  return Springboard;
}(_PointActor2.PointActor);
exports.Springboard = Springboard;
});

;require.register("actor/StarBalloon.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.StarBalloon = void 0;
var _Balloon2 = require("./Balloon");
var _Spring = require("./Spring");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let StarBalloon = /*#__PURE__*/function (_Balloon) {
  _inherits(StarBalloon, _Balloon);
  var _super = _createSuper(StarBalloon);
  function StarBalloon() {
    var _this;
    _classCallCheck(this, StarBalloon);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.type = 'actor-item actor-balloon actor-star-balloon';
    _this.args.target = _this.args.target || 0;
    _this.args.gravity = 0.475;
    _this[_Spring.Spring.WontSpring] = true;
    return _this;
  }
  _createClass(StarBalloon, [{
    key: "update",
    value: function update() {
      _get(_getPrototypeOf(StarBalloon.prototype), "update", this).call(this);
      if (!this.popped) {
        if (!this.launched) {
          this.args.ySpeed = Math.sin(this.viewport.args.frameId / 10) / 5;
        } else {
          if (!this.args.ySpeed) {
            this.args.ySpeed = -1;
          }
          if (this.args.ySpeed > -8) {
            this.args.ySpeed -= 0.08;
          }
          if (this.args.y < this.args.target) {
            this.args.y = this.args.target;
            this.args.ySpeed = 0;
          }
        }
      }
      this.args.groundAngle = 0;
    }
  }, {
    key: "activate",
    value: function activate() {
      this.args.ySpeed = 2;
      this.viewport.onFrameOut(20, () => this.launched = true);
    }
  }, {
    key: "collideA",
    value: function collideA(other) {
      if (!other.controllable || other.args.hangingFrom) {
        return false;
      }
      if (this.popped) {
        return false;
      }
      if (other.args.ySpeed >= 0 || other.args.spinning) {
        other.args.ySpeed = -14;
        this.pop();
      }
    }
  }, {
    key: "sleep",
    value: function sleep() {
      if (!this.viewport) {
        return;
      }
      this.tags.sprite && this.tags.sprite.classList.remove('popped');
      this.args.x = this.def.get('x');
      this.args.y = this.def.get('y');
      this.args.xSpeed = 0;
      this.args.ySpeed = 0;
      this.args.float = -1;
      this.popped = this.launched = false;
      this.args.falling = true;
      this.viewport.setColCell(this);
      this.noClip = false;
    }
  }, {
    key: "damage",
    value: function damage() {
      this.pop();
    }
  }, {
    key: "pop",
    value: function pop() {
      const exploded = new CustomEvent('exploded', {
        detail: {
          actor: this
        }
      });
      this.dispatchEvent(exploded);
      this.tags.sprite.classList.add('popped');
      this.popped = true;
      this.args.float = 0;
      this.noClip = true;
    }
  }]);
  return StarBalloon;
}(_Balloon2.Balloon);
exports.StarBalloon = StarBalloon;
});

;require.register("actor/StarPost.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.StarPost = void 0;
var _CharacterString = require("../ui/CharacterString");
var _PointActor2 = require("./PointActor");
var _Tag = require("curvature/base/Tag");
var _Sfx = require("../audio/Sfx");
var _Monitor = require("./Monitor");
var _RingMonitor = require("./monitor/RingMonitor");
var _SheildElectricMonitor = require("./monitor/SheildElectricMonitor");
var _SheildWaterMonitor = require("./monitor/SheildWaterMonitor");
var _SheildFireMonitor = require("./monitor/SheildFireMonitor");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let StarPost = /*#__PURE__*/function (_PointActor) {
  _inherits(StarPost, _PointActor);
  var _super = _createSuper(StarPost);
  function StarPost() {
    var _this$args$active;
    var _this;
    _classCallCheck(this, StarPost);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.type = 'actor-item actor-star-post';
    _this.args.width = 16;
    _this.args.height = 48;
    _this.args.active = (_this$args$active = _this.args.active) !== null && _this$args$active !== void 0 ? _this$args$active : false;
    _this.args.static = true;
    _this.spinning = false;
    return _this;
  }
  _createClass(StarPost, [{
    key: "update",
    value: function update() {
      _get(_getPrototypeOf(StarPost.prototype), "update", this).call(this);
      if (this.args.wasActive) {
        const monitor = new _RingMonitor.RingMonitor({
          direction: 0,
          ySpeed: -4,
          x: this.x - 10,
          y: this.y - 48
        });
        this.viewport.onFrameOut(12, () => {
          this.viewport.spawn.add({
            object: monitor
          });
        });
        this.args.wasActive = false;
      }
    }
  }, {
    key: "onRendered",
    value: function onRendered() {
      _get(_getPrototypeOf(StarPost.prototype), "onRendered", this).call(this);
      this.sprite = this.findTag('div.sprite');
      this.box = this.findTag('div');
      this.headBox = new _Tag.Tag('<div class = "star-post-head-box">');
      this.head = new _Tag.Tag('<div class = "star-post-head">');
      this.headBox.appendChild(this.head.node);
      this.box.appendChild(this.headBox.node);
    }
  }, {
    key: "collideA",
    value: function collideA(other) {
      _get(_getPrototypeOf(StarPost.prototype), "collideA", this).call(this, other);
      if (other.args.owner) {
        other = other.args.owner;
      }
      if (!other.controllable && !other.occupant) {
        return;
      }
      if (!this.box) {
        return;
      }
      if (!this.args.active) {
        this.args.active = true;
        this.box.setAttribute('data-direction', other.args.direction);
        this.box.setAttribute('data-active', 'true');
        this.box.setAttribute('data-spin', 'true');
        _Sfx.Sfx.play('STARPOST_HIT');
        let throwSpeed = other.args.gSpeed || other.args.xSpeed;
        if (Math.abs(throwSpeed) > 20) {
          throwSpeed += 3;
        }
        const frameId = this.viewport.args.frameId + -this.viewport.args.startFrameId;
        const monitorClasses = other.args.rings > 50 ? [_RingMonitor.RingMonitor, _SheildFireMonitor.SheildFireMonitor, _SheildWaterMonitor.SheildWaterMonitor, _SheildElectricMonitor.SheildElectricMonitor] : [_RingMonitor.RingMonitor];

        // const monitorClass = monitorClasses[Math.floor( Math.random() * monitorClasses.length )];
        const monitorClass = monitorClasses[frameId % monitorClasses.length];
        const monitor = new monitorClass({
          direction: other.args.direction,
          xSpeed: throwSpeed,
          ySpeed: -5,
          x: this.x - 10,
          y: this.y - 48
        });
        this.viewport.storeCheckpoint(other.args.canonical, this.oid || this.args.id);
        this.viewport.spawn.add({
          object: monitor
        });

        // this.viewport.onFrameOut(360, () => {
        // 	this.box.setAttribute('data-active', 'false');
        // 	this.box.setAttribute('data-spin', 'false');
        // 	this.args.active = false;
        // });

        this.spinning = true;
        this.viewport.onFrameOut(36, () => {
          this.spinning = false;
        });
        if (typeof ga === 'function') {
          ga('send', 'event', {
            eventCategory: 'starpost',
            eventAction: 'activated',
            eventLabel: `${this.viewport.args.actName}::${this.args.id}`
          });
        }

        // const time  = (this.viewport.args.frameId - this.viewport.args.startFrameId) / 60;
        // let minutes = String(Math.floor(Math.abs(time) / 60)).padStart(2,'0')
        // let seconds = String((Math.abs(time) % 60).toFixed(0)).padStart(2,'0');

        // const neg = time < 0 ? '-' : '';

        // if(neg)
        // {
        // 	minutes = Number(minutes);
        // }

        // const yardsPerFrame = other.args.gSpeed / 32;
        // const feetPerSecond = yardsPerFrame * 60 * 3;

        // this.args.charStrings = [
        // 	new CharacterString({value: `Speed: ${feetPerSecond.toFixed(3)} ft/s`})
        // 	, new CharacterString({value: `Time: ${neg}${minutes}:${seconds}`})
        // 	, new CharacterString({value: `Score: ${other.args.score}`})
        // 	, new CharacterString({value: `Rings: ${other.args.rings}`})
        // ];
      }
      // else if(other instanceof Projectile && !this.spinning)
      // {
      // 	this.box.setAttribute('data-direction', other.args.direction);
      // 	this.box.setAttribute('data-spin', 'false');

      // 	if(this.viewport.args.audio && this.sample)
      // 	{
      // 		this.sample.currentTime = 0;
      // 		this.sample.play();
      // 	}

      // 	this.onTimeout(0, () => this.box.setAttribute('data-spin', 'true'));

      // 	this.spinning = true;

      // 	this.onTimeout(600, () => this.spinning = false);
      // }
    }
  }, {
    key: "solid",
    get: function get() {
      return false;
    }
  }]);
  return StarPost;
}(_PointActor2.PointActor);
exports.StarPost = StarPost;
});

;require.register("actor/SteelCrate.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SteelCrate = void 0;
var _Block = require("./Block");
var _BreakableBlock2 = require("./BreakableBlock");
var _Projectile = require("./Projectile");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let SteelCrate = /*#__PURE__*/function (_BreakableBlock) {
  _inherits(SteelCrate, _BreakableBlock);
  var _super = _createSuper(SteelCrate);
  function SteelCrate() {
    var _this$args$static;
    var _this;
    _classCallCheck(this, SteelCrate);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.type = 'actor-item actor-breakable-block actor-steel-crate';
    _this.args.width = 64;
    _this.args.height = 64;
    _this.args.static = (_this$args$static = _this.args.static) !== null && _this$args$static !== void 0 ? _this$args$static : false;
    return _this;
  }
  _createClass(SteelCrate, [{
    key: "collideA",
    value: function collideA(other, type) {
      if (other instanceof _Block.Block) {
        return true;
      }
      if (other instanceof _Projectile.Projectile && !this.broken) {
        this.break();
        return true;
      }
      if (other.args.bouncing && !this.broken) {
        this.break();
        return true;
      }
      if (other.punching && !this.broken) {
        this.break();
        return false;
      }
      if (other.args.rolling && !this.broken) {
        return true;
      }
      if (type === 0 && other.controllable) {
        return true;
      }
      if (type !== 1 && type !== 3 || other.y <= this.y - this.args.height) {
        return true;
      }
      if (!this.viewport) {
        return false;
      }
      if (type === -1 || other.args.rolling) {
        return _get(_getPrototypeOf(SteelCrate.prototype), "collideA", this).call(this, other, type);
      }
      return true;
    }
  }, {
    key: "setTile",
    value: function setTile() {
      this.args.spriteSheet = '/custom/steel-crate.png';
    }
  }]);
  return SteelCrate;
}(_BreakableBlock2.BreakableBlock);
exports.SteelCrate = SteelCrate;
});

;require.register("actor/StoneAltar.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.StoneAltar = void 0;
var _Block2 = require("./Block");
var _WindStone = require("./WindStone");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let StoneAltar = /*#__PURE__*/function (_Block) {
  _inherits(StoneAltar, _Block);
  var _super = _createSuper(StoneAltar);
  function StoneAltar() {
    var _this;
    let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let parent = arguments.length > 1 ? arguments[1] : undefined;
    _classCallCheck(this, StoneAltar);
    _this = _super.call(this, args, parent);
    _this.args.float = -1;
    _this.args.static = true;
    _this.args.hidden = true;
    _this.args.platform = true;
    _this.args.activated = false;
    return _this;
  }
  _createClass(StoneAltar, [{
    key: "update",
    value: function update() {
      _get(_getPrototypeOf(StoneAltar.prototype), "update", this).call(this);
      this.args.active = false;
      for (const actor of this.standingUnder) {
        if (!(actor instanceof _WindStone.WindStone)) {
          continue;
        }
        actor.args.inPlace = true;
        this.args.active = true;
      }
    }
  }]);
  return StoneAltar;
}(_Block2.Block);
exports.StoneAltar = StoneAltar;
});

;require.register("actor/Stopper.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Stopper = void 0;
var _BreakableBlock2 = require("./BreakableBlock");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let Stopper = /*#__PURE__*/function (_BreakableBlock) {
  _inherits(Stopper, _BreakableBlock);
  var _super = _createSuper(Stopper);
  function Stopper() {
    var _this;
    let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let parent = arguments.length > 1 ? arguments[1] : undefined;
    _classCallCheck(this, Stopper);
    _this = _super.call(this, args, parent);
    _this.args.type = 'actor-item actor-breakable-block actor-stopper';
    _this.args.height = 16;
    _this.args.float = -1;
    return _this;
  }
  _createClass(Stopper, [{
    key: "collideA",
    value: function collideA(other, type) {
      if (other.isVehicle) {
        return true;
      }
      if (this.broken) {
        return false;
      }
      if (!this.broken && type === 2 || Math.abs(other.args.ySpeed) > 20 && type === 0) {
        if (other.args.ySpeed > 0 || other.ySpeedLast > 0) {
          other.args.groundAngle = 0;
          other.args.x = this.args.x;
          other.args.xSpeed = 0;
          other.args.ySpeed = Math.abs(other.args.gSpeed);
          other.args.falling = true;
          other.args.bouncing = false;
          other.args.jumping = false;
          other.args.mode = 0;
          this.break();
          return false;
        }
        return true;
      } else if (other.args.jumping && other.args.ySpeed > 0 || other.args.rolling) {
        other.args.x = this.args.x;
        other.args.y = this.args.y;
        this.viewport.onFrameOut(1, () => {
          other.args.groundAngle = 0;
          other.args.falling = true;
          other.args.animation = 'rolling';
          other.args.x = this.args.x;
          other.args.gSpeed = 0;
          other.args.xSpeed = 0;
          other.args.ySpeed = Math.abs(other.args.gSpeed);
        });
        if (other.args.jumping) {
          other.args.gSpeed = 0;
          other.args.xSpeed = 0;
          other.args.ySpeed = 0;
          other.args.ignore = 30;
          other.args.float = 30;
          this.viewport.onFrameOut(30, () => {
            other.args.xSpeed = 0;
            other.args.ySpeed = 10;
          });
        }
        return _get(_getPrototypeOf(Stopper.prototype), "collideA", this).call(this, other, type);
      }
      return true;
    }
  }]);
  return Stopper;
}(_BreakableBlock2.BreakableBlock);
exports.Stopper = Stopper;
});

;require.register("actor/SuperRing.js", function(exports, require, module) {
// import { PointActor } from './PointActor';

// const THREE         = require('three')
// const ColladaLoader = require('three-collada-loader');

// export class SuperRing extends PointActor
// {
// 	constructor(...args)
// 	{
// 		super(...args);

// 		this.args.type = 'actor-super-ring actor-item';

// 		this.args.width  = 64;
// 		this.args.height = 64;
// 		this.args.float  = -1;
// 		this.args.gone   = false;

// 		this.args.xRot = 0;
// 		this.args.yRot = 0;
// 		this.args.zRot = 0;

// 		this.args.speed = 4;

// 		this.leaving = new WeakSet;

// 		this.args.xOff = 0;
// 		this.args.yOff = 0;
// 	}

// 	onAttached()
// 	{
// 		this.initRenderer();

// 		this.pinch(0);
// 	}

// 	initRenderer()
// 	{
// 		this.cameraRear = new THREE.PerspectiveCamera(12.5, undefined, 10, 100);
// 		this.cameraFore = new THREE.PerspectiveCamera(12.5, undefined, 1, 10.1);

// 		const modelUrl   = '/models/ring.dae';

// 		const specular   = 0xBBBBBB;
// 		const color      = 0xBBBB00;
// 		const outline    = 0x000000;

// 		// const finalX     = qTurn / 8 * 7;

// 		const emissive   = 0x999900;
// 		const lineColor  = 0x0000AA;

// 		const colladaLoader = new ColladaLoader;

// 		colladaLoader.load(modelUrl, response => {
// 			const geometry = response.dae.geometries['root-mesh'].mesh.geometry3js;

// 			this.cameraRear.position.z = 10;
// 			this.cameraRear.position.x = 0;
// 			this.cameraRear.position.y = 0;

// 			this.cameraFore.position.z = 10;
// 			this.cameraFore.position.x = 0;
// 			this.cameraFore.position.y = 0;

// 			this.scene = new THREE.Scene();

// 			const edgeGeometry = new THREE.EdgesGeometry(geometry);

// 			const goldMaterial = new THREE.MeshPhongMaterial({
// 				side:          THREE.FrontSide
// 				, transparent: true
// 				, skinning:    true
// 				, emissive
// 				, specular
// 				, color
// 			});

// 			const blackMaterial = new THREE.MeshBasicMaterial({
// 				color: outline
// 				, side: THREE.BackSide
// 			});

// 			this.mainMesh = new THREE.Mesh(geometry, goldMaterial);
// 			this.outlineMesh = new THREE.Mesh(geometry, blackMaterial);
// 			this.inlineMesh = new THREE.Mesh(geometry, blackMaterial);

// 			this.outlineMesh.scale.multiplyScalar(1.075);
// 			this.inlineMesh.scale.multiplyScalar(0.925);

// 			this.wireMaterial = new THREE.LineBasicMaterial({
// 				depthTest:   true
// 				, linewidth:   1.25
// 				, color:       lineColor
// 				, transparent: true
// 				, opacity:     0.125
// 			} );

// 			this.wireframe = new THREE.LineSegments(edgeGeometry, this.wireMaterial);

// 			const light = new THREE.DirectionalLight(0xFFFFFF, 0.333);
// 			light.position.set(1, 1.75, 0).normalize();

// 			light.target = this.wireframe;

// 			const light2 = new THREE.DirectionalLight(0xFFFFFF);
// 			light2.position.set(0.75, -1, 0).normalize();

// 			light.target = this.wireframe;

// 			this.scene.add(this.mainMesh);
// 			this.scene.add(this.outlineMesh);
// 			this.scene.add(this.inlineMesh);
// 		 	this.scene.add(this.wireframe);

// 			this.scene.add(light);

// 			this.rendererRear = new THREE.WebGLRenderer({
// 				antialias: true
// 				, alpha:   true
// 			});

// 			this.rendererFore = new THREE.WebGLRenderer({
// 				antialias: true
// 				, alpha:   true
// 			});

// 			this.resizeRenderer();

// 			const parent = this.tags.sprite.node.parentNode;

// 			parent.appendChild(this.rendererRear.domElement);
// 			parent.appendChild(this.rendererFore.domElement);

// 			this.rendererRear.render(this.scene, this.cameraRear);
// 			this.rendererFore.render(this.scene, this.cameraFore);
// 		});

// 	}

// 	resizeRenderer()
// 	{
// 		const parent    = this.tags.sprite.node;

// 		const width     = this.args.width;  //parent.clientWidth  || parent.offsetWidth || width || 0;
// 		const height    = this.args.height; //parent.clientHeight || parent.offsetHeight || height || 0;
// 		const longAxis  = width > height ? width : height;
// 		const shortAxis = width < height ? width : height;

// 		this.cameraRear.aspect = 1;
// 		this.cameraFore.aspect = 1;

// 		this.rendererRear.setSize(shortAxis,  shortAxis);
// 		this.rendererFore.setSize(shortAxis,  shortAxis);

// 		// parent.style.setProperty('--long-axis', longAxis + 'px');
// 		// parent.style.setProperty('--short-axis', shortAxis + 'px');

// 		this.wireMaterial.linewidth = shortAxis / 750;
// 	}

// 	update()
// 	{
// 		super.update();

// 		if(!this.wireframe)
// 		{
// 			return;
// 		}

// 		if(this.caught)
// 		{
// 			this.wireframe.material.opacity = 0.125;

// 			const caught = this.caught;

// 			caught.args.xSpeed = 0;
// 			caught.args.ySpeed = 0;

// 			if(this.caught.yAxis > 0)
// 			{
// 				this.drop();
// 			}
// 			else if(this.caught.yAxis < 0)
// 			{
// 				this.wireframe.material.opacity = 0.25;

// 				this.args.speed++;

// 				caught.args.x = this.args.x;
// 				caught.args.y = this.args.y - 16;
// 			}
// 			else
// 			{
// 				const toX = this.args.x;
// 				const toY = this.args.y - 16;

// 				const speed = 12;

// 				if(caught.args.x !== toX)
// 				{
// 					caught.args.x += Math.sign(toX - caught.args.x) * this.args.speed;
// 				}

// 				if(caught.args.y !== toY)
// 				{
// 					caught.args.y += Math.sign(toY - caught.args.y) * this.args.speed;
// 				}

// 				if(Math.abs(caught.args.x - toX) < speed)
// 				{
// 					caught.args.x = toX;
// 				}

// 				if(Math.abs(caught.args.y - toY) < speed)
// 				{
// 					caught.args.y = toY;
// 				}
// 			}

// 			if(this.args.speed < 5)
// 			{
// 				this.args.speed += 0.25;
// 			}

// 			if(this.args.speed > 5)
// 			{
// 				this.args.speed -= 0.5;
// 			}
// 		}
// 		else
// 		{
// 			this.wireframe.material.opacity = 0.1;

// 			if(this.args.speed > 4)
// 			{
// 				this.args.speed -= 0.125;
// 			}
// 		}

// 		const yRot = (this.args.yRot / 60) % (Math.PI * 2);

// 		if(yRot > (Math.PI / 2 - 0.125) && yRot < (Math.PI / 2 + 0.125))
// 		{
// 			if(this.args.speed > 20)
// 			{
// 				this.onTimeout(500, ()=>this.drop());
// 			}
// 		}

// 		// this.wireframe.rotation.x
// 		//	= this.mainMesh.rotation.x
// 		//	= this.outlineMesh.rotation.x
// 		//	= this.inlineMesh.rotation.x
// 		//	= this.args.xRot / 200;

// 		this.wireframe.rotation.y
// 			= this.mainMesh.rotation.y
// 			= this.outlineMesh.rotation.y
// 			= this.inlineMesh.rotation.y
// 			= yRot;

// 		this.wireframe.rotation.z
// 			= this.mainMesh.rotation.z
// 			= this.outlineMesh.rotation.z
// 			= this.inlineMesh.rotation.z
// 			= this.args.zRot / 60;

// 		this.args.yRot += this.args.speed;
// 		// this.args.xRot++;
// 		this.args.zRot++;

// 		this.onTimeout(0, () => {
// 			this.rendererRear.render(this.scene, this.cameraRear);
// 			this.rendererFore.render(this.scene, this.cameraFore);
// 		});
// 	}

// 	collideA(other)
// 	{
// 		super.collideA(other);

// 		if(!other.controllable || other.args.flying)
// 		{
// 			if(this.leaving.delete(other))
// 			{
// 				return;
// 			}
// 			return;
// 		}

// 		if(this.leaving.has(other))
// 		{
// 			return;
// 		}

// 		if(this.caught)
// 		{
// 			this.caught.args.xSpeed = (Math.sign(other.args.xSpeed) * 3) || 3;

// 			this.leaving.add(this.caught);
// 		}

// 		if(this.caught !== other)
// 		{
// 			this.drop();

// 			if(this.leaving.has(other))
// 			{
// 				return;
// 			}

// 			this.onTimeout(500, () => {

// 				if(this.leaving.has(other))
// 				{
// 					return;
// 				}

// 				this.caught = other

// 			});

// 			this.grab();
// 		}

// 		other.args.xSpeed = 0;
// 		other.args.ySpeed = 0;
// 		other.args.float  = -1;
// 	}

// 	drop()
// 	{
// 		if(this.caught)
// 		{
// 			const caught = this.caught;

// 			this.pinchFilterBg.classList.add('grabbing-start');
// 			this.pinch(-50, 15);

// 			this.leaving.add(caught);

// 			if(this.startGrab)
// 			{
// 				clearTimeout(this.startDrop);
// 				this.startDrop = false;
// 			}

// 			this.startDrop = this.onTimeout(150, () => {
// 				this.pinchFilterBg.classList.add('grabbing');

// 				caught.args.float = 0;
// 				caught.args.ySpeed = 10;

// 				if(this.dropDone)
// 				{
// 					clearTimeout(this.dropDone);
// 					this.dropDone = false;
// 				}

// 				this.dropDone = this.onTimeout(650, () => {
// 					this.pinchFilterBg.classList.remove('grabbing-start');
// 					this.pinchFilterBg.classList.remove('grabbing');
// 					this.pinch(0, 0);
// 				});

// 				this.caught = null;
// 			});

// 			this.onTimeout(1500, () => {
// 				this.leaving.delete(caught);
// 			});
// 		}
// 	}

// 	grab()
// 	{
// 		if(this.pinchFilterFg)
// 		{
// 			this.pinchFilterFg.classList.add('grabbing-start');
// 			this.onTimeout(150, () => {
// 				this.pinchFilterFg.classList.add('grabbing');

// 				this.pinch(0, 100);

// 				this.onTimeout(650, () => {
// 					this.pinch(0, 0);

// 					this.pinchFilterFg.classList.remove('grabbing-start');
// 					this.pinchFilterFg.classList.remove('grabbing');
// 				});
// 			});
// 		}
// 	}
// }
"use strict";
});

;require.register("actor/Switch.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Switch = void 0;
var _PointActor2 = require("./PointActor");
var _Sfx = require("../audio/Sfx");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let Switch = /*#__PURE__*/function (_PointActor) {
  _inherits(Switch, _PointActor);
  var _super = _createSuper(Switch);
  function Switch() {
    var _this$args$threshold;
    var _this;
    _classCallCheck(this, Switch);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.type = 'actor-item actor-switch';
    _this.args.width = 32;
    _this.args.height = 10; //this.height = 16;

    // this.args.float  = -1;

    _this.removeTimer = null;
    _this.args.active = false;
    _this.args.latch = _this.args.latch || false;
    _this.activator = null;
    _this.args.bindTo('active', v => {
      _this.box && _this.box.setAttribute('data-active', v ? 'true' : 'false');
    });
    _this.args.threshold = (_this$args$threshold = _this.args.threshold) !== null && _this$args$threshold !== void 0 ? _this$args$threshold : 100;
    _this.ignore = 0;
    _this.args.activeTime = 0;
    return _this;
  }
  _createClass(Switch, [{
    key: "update",
    value: function update() {
      _get(_getPrototypeOf(Switch.prototype), "update", this).call(this);
      if (this.ignore > 0) {
        this.ignore--;
        return;
      }
      if (this.args.latch) {
        return;
      }

      // if(this.activator && this.activator.args.ySpeed > 0)
      // {
      // 	this.activator.args.ySpeed = Math.sign(this.activator.args.ySpeed);
      // }

      if (this.args.active) {
        this.args.activeTime++;
      } else {
        this.args.activeTime = 0;
      }
      if (this.args.activeTime > 2 && (!this.activator || this.activator.args.standingOn !== this || this.activator.y === this.args.y)) {
        this.args.active = false;
        this.activator = null;
      }
    }
  }, {
    key: "updateEnd",
    value: function updateEnd() {
      _get(_getPrototypeOf(Switch.prototype), "updateEnd", this).call(this);
      if (this.args.active) {
        // this.args.height = this.height + -6;
      } else {
        // this.args.height = this.height;
      }
    }
  }, {
    key: "onRendered",
    value: function onRendered(event) {
      _get(_getPrototypeOf(Switch.prototype), "onRendered", this).call(this, event);
      this.box = this.findTag('div');
    }
  }, {
    key: "collideA",
    value: function collideA(other, type) {
      // if(!other.args.falling || other.args.y >= this.args.y)
      if (other.args.y >= this.args.y) {
        return false;
      }
      if (this.activator === other && other.y > this.args.y) {
        this.ignore = 8;
        return true;
      }
      if (other.args.ySpeed < 0) {
        // if(other.args.ySpeed === 0 && other.y > this.y)
        // {
        // 	return true;
        // }

        return false;
      }
      if (this.args.active && other.y < this.y) {
        return true;
      }
      if (other.isEffect || other.isRegion) {
        return;
      }
      if (other.y > this.y - this.args.height + 0) {
        return false;
      }
      if (this.args.threshold && other.args.weight < this.args.threshold) {
        return true;
      }
      other.onRemove(() => this.activator = null);
      if (other.y <= this.y - this.args.height) {
        if (!this.args.active) {
          this.activate(other);
        }
        this.ignore = 8;
        this.args.active = true;
        this.activator = other;
        if (other.args.falling && other.args.ySpeed > 1) {
          other.args.ySpeed = 1;
        }
        if (this.activator && Math.abs(this.activator.args.x - this.args.x) > 4 && this.args.activeTime < 1) {
          const originalXSpeed = this.activator.args.xSpeed;

          // this.activator.args.x -= (this.activator.args.x - this.args.x);
          // this.activator.args.xSpeed = 0;
          // this.activator.args.groundAngle = 0;

          this.viewport.onFrameOut(1, () => {
            this.activator.args.gSpeed = originalXSpeed;
            this.activator.args.groundAngle = 0;
          });
        }

        // if(type === 1 || type === 3)
        // {
        // 	return false;
        // }

        return true;
      }
      return false;
    }
  }, {
    key: "activate",
    value: function activate(other) {
      this.beep();
      if (this.args.target && this.viewport.actorsById[this.args.target]) {
        const target = this.viewport.actorsById[this.args.target];
        target.activate(other, this);
      }
      if (this.args.destroyLayer) {
        const layerId = this.args.destroyLayer;
        const layer = this.viewport.args.layers[layerId];
        if (layer) {
          layer.args.destroyed = true;
        }
      }
      if (this.args.water) {
        var _this$args$fillSpeed, _this$args$drainSpeed;
        const water = this.viewport.actorsById[this.args.water];
        const level = this.viewport.objDefs.get(this.args.setPoint);
        water.target = Number(water.y || 0) - Number(level.y || 0);
        water.args.fillSpeed = (_this$args$fillSpeed = this.args.fillSpeed) !== null && _this$args$fillSpeed !== void 0 ? _this$args$fillSpeed : water.args.fillSpeed;
        water.args.drainSpeed = (_this$args$drainSpeed = this.args.drainSpeed) !== null && _this$args$drainSpeed !== void 0 ? _this$args$drainSpeed : water.args.drainSpeed;
      }
      const spawnPoint = this.viewport.objDefs.get(this.args.point);
      const spawnType = this.viewport.objectPalette[this.args.spawn];
      if (spawnType && spawnPoint) {
        this.viewport.spawn.add({
          object: new spawnType({
            x: spawnPoint.x,
            y: spawnPoint.y
          })
        });
      }
      this.args.active = true;
    }
  }, {
    key: "beep",
    value: function beep() {
      if (!this.viewport) {
        return;
      }
      if (this.args.silent) {
        return;
      }
      _Sfx.Sfx.play('SWITCH_HIT');
    }
  }, {
    key: "sleep",
    value: function sleep() {
      if (!this.viewport || !this.def) {
        return;
      }
      this.args.x = this.def.get('x');
      this.args.y = this.def.get('y');
      this.onNextFrame(() => {
        this.args.x = this.def.get('x');
        this.args.y = this.def.get('y');
        this.viewport.setColCell(this);
        this.args.xSpeed = 0;
        this.args.ySpeed = 0;
        this.args.pushed = 0;
        this.args.float = 0;
      });
    }
  }, {
    key: "solid",
    get: function get() {
      return this.args.active;
    }
  }]);
  return Switch;
}(_PointActor2.PointActor);
exports.Switch = Switch;
});

;require.register("actor/Tails.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Tails = void 0;
var _PointActor2 = require("./PointActor");
var _Tag = require("curvature/base/Tag");
var _Spring = require("./Spring");
var _SkidDust = require("../behavior/SkidDust");
var _Spindash = require("../behavior/Spindash");
var _Crouch = require("../behavior/Crouch");
var _LookUp = require("../behavior/LookUp");
var _EmeraldHalo = require("../behavior/EmeraldHalo");
var _SuperForm = require("../behavior/SuperForm");
var _Color = require("../lib/Color");
var _Png = require("../sprite/Png");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let Tails = /*#__PURE__*/function (_PointActor) {
  _inherits(Tails, _PointActor);
  var _super = _createSuper(Tails);
  function Tails() {
    var _this;
    _classCallCheck(this, Tails);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _defineProperty(_assertThisInitialized(_this), "png", new _Png.Png('/Sonic/tails.png'));
    _defineProperty(_assertThisInitialized(_this), "pngTails", new _Png.Png('/Sonic/tails-tails.png'));
    _this.args.canonical = 'Tails';
    _this.behaviors.add(new _SkidDust.SkidDust());
    _this.behaviors.add(new _Spindash.Spindash());
    _this.behaviors.add(new _Crouch.Crouch());
    _this.behaviors.add(new _LookUp.LookUp());
    _this.behaviors.add(new _SuperForm.SuperForm());
    _this.behaviors.add(new _EmeraldHalo.EmeraldHalo());
    _this.args.type = 'actor-item actor-tails';
    _this.accelNormal = 0.15;
    _this.accelSuper = 0.24;
    _this.args.accel = _this.accelNormal;
    _this.args.decel = 0.4;
    _this.args.flySpeedMax = 25;
    _this.gSpeedMaxNormal = 18;
    _this.gSpeedMaxSuper = 20;
    _this.gSpeedMaxHyper = 23;
    _this.jumpForceNormal = 11;
    _this.jumpForceSuper = 13;
    _this.jumpForceHyper = 15;
    _this.args.maxFlyTimeNormal = 350;
    _this.args.maxFlyTimeSuper = 600;
    _this.args.maxFlyTimeHyper = Infinity;
    _this.args.flyBoostNormal = -1.5;
    _this.args.flyBoostSuper = -1.75;
    _this.args.flyBoostHyper = -2.0;
    _this.args.flyBoost = _this.args.flyBoostNormal;
    _this.args.maxFlyTime = _this.args.maxFlyTimeNormal;
    _this.args.gSpeedMax = _this.gSpeedMaxNormal;
    _this.args.jumpForce = _this.jumpForceNormal;
    _this.args.gravity = 0.5;
    _this.args.normalGravity = _this.args.gravity;
    _this.args.slowGravity = _this.args.gravity * 0.125;
    _this.args.width = 16;
    _this.args.height = 34;
    _this.args.weight = 80;
    _this.args.normalHeight = 32;
    _this.args.rollingHeight = 28;
    ;
    _this.willStick = false;
    _this.stayStuck = false;
    _this.flyTime = 0;
    _this.sparks = new Set();
    _this.spriteSheet = '/Sonic/tails.png';
    _this.args.spriteSheet = `url('${_this.args.spriteSheet}')`;
    _this.spriteSheetTails = '/Sonic/tails-tails.png';
    _this.args.spriteSheetTails = `url('${_this.spriteSheetTails}')`;
    _this.costumes = {
      SkyCamo: {
        h: 120,
        s: 0.8,
        v: 1.00
      },
      Copper: {
        h: -45,
        s: 1.0,
        v: 1.00
      },
      Patina: {
        h: 90,
        s: 0.8,
        v: 0.85
      },
      Arctic: {
        h: 0,
        s: 0.0,
        v: 0.85
      }
    };
    _this.args.minRingsSuper = 40;
    _this.args.minRingsHyper = 60;
    _this.transformTime = 0;
    return _this;
  }
  _createClass(Tails, [{
    key: "onRendered",
    value: function onRendered(event) {
      _get(_getPrototypeOf(Tails.prototype), "onRendered", this).call(this, event);
      if (this.tails) {
        return;
      }

      // this.box = this.findTag('div');
      // this.sprite = this.findTag('div.sprite');

      this.tails = new _Tag.Tag('<div class = "tails-tails">');
      this.sprite.appendChild(this.tails.node);
      this.flyingSound = new Audio('/Sonic/tails-flying.wav');
      this.flyingSound.volume = 0.35 + Math.random() * -0.3;
      this.flyingSound.loop = true;
      this.rotatedSpriteSheet = this.spriteSheet;
      this.rotatedSpriteSheetTails = this.spriteSheetTails;
      this.autoStyle.get(this.box)['--sprite-sheet'] = 'spriteSheet';
      this.autoStyle.get(this.box)['--sprite-sheet-tails'] = 'spriteSheetTails';
      const updateSprite = () => {
        var _this$viewport$custom, _this$viewport$custom2, _this$viewport$custom3;
        let h = Number((_this$viewport$custom = this.viewport.customColor.h) !== null && _this$viewport$custom !== void 0 ? _this$viewport$custom : 0);
        let s = Number((_this$viewport$custom2 = this.viewport.customColor.s) !== null && _this$viewport$custom2 !== void 0 ? _this$viewport$custom2 : 1);
        let v = Number((_this$viewport$custom3 = this.viewport.customColor.v) !== null && _this$viewport$custom3 !== void 0 ? _this$viewport$custom3 : 1);
        this.rotateMainColor(h, s, v).then(() => {
          this.box.node.style.setProperty('--sprite-sheet', `url(${this.args.rotatedSpriteSheet})`);
          this.box.node.style.setProperty('--sprite-sheet-tails', `url(${this.args.rotatedSpriteSheetTails})`);
        });
      };
      const debindH = this.viewport.customColor.bindTo('h', updateSprite, {
        wait: 0
      });
      const debindS = this.viewport.customColor.bindTo('s', updateSprite, {
        wait: 0
      });
      const debindV = this.viewport.customColor.bindTo('v', updateSprite, {
        wait: 0
      });
      this.onRemove(debindH);
      this.onRemove(debindS);
      this.onRemove(debindV);
      if (this.viewport.args.mainPallet && this.costumes[this.viewport.args.mainPallet]) {
        Object.assign(this.viewport.customColor, this.costumes[this.viewport.args.mainPallet]);
      }
      this.superSheet = 0;
      const superColorsA = {
        'ffb691': 'efefef',
        'fcb400': 'ebebeb',
        'fc9000': 'd4d4d4',
        'b46c48': 'b8b8b8'
      };
      const superColorsB = {
        'ffb691': 'fff79e',
        'fcb400': 'fefb00',
        'fc9000': 'fef500',
        'b46c48': 'ceae30'
      };
      if (!this.superSpriteSheetLoaders) {
        this.superSpriteSheetLoaders = this.png.ready.then(() => this.superSpriteSheets = [this.png.recolor(superColorsA).toUrl(), this.png.recolor(superColorsB).toUrl()]);
        this.superSpriteSheetTailsLoaders = this.pngTails.ready.then(() => this.superSpriteSheetsTails = [this.pngTails.recolor(superColorsA).toUrl(), this.pngTails.recolor(superColorsB).toUrl()]);
      }
      this.hyperSheet = 0;
      const hyperColorsRed = {
        'ffb691': 'fcfcfc',
        'fcb400': 'fcfcfc',
        'fc9000': 'fcd8d8',
        'b46c48': 'fcb4b4'
      };
      const hyperColorsPurple = {
        'ffb691': 'fcfcfc',
        'fcb400': 'fcfcfc',
        'fc9000': 'fcd8fc',
        'b46c48': 'd8b4d8'
      };
      const hyperColorsCyan = {
        'ffb691': 'd8fcfc',
        'fcb400': 'fcfcfc',
        'fc9000': 'b4d8fc',
        'b46c48': '90b4fc'
      };
      const hyperColorsBlue = {
        'ffb691': 'd8d8ff',
        'fcb400': 'b4b4d8',
        'fc9000': 'a4a4d8',
        'b46c48': '6c6cb4'
      };
      const hyperColorsGreen = {
        'ffb691': 'd8fcfc',
        'fcb400': 'd8fcd8',
        'fc9000': 'b4fcb4',
        'b46c48': '00fc24'
      };
      const hyperColorsYellow = {
        'ffb691': 'd8fcfc',
        'fcb400': 'd8fcb4',
        'fc9000': 'd8fc48',
        'b46c48': 'd8d800'
      };
      const hyperColorsWhite = {
        'ffb691': 'ffffff',
        'fcb400': 'fcfcfc',
        'fc9000': 'd8d8d8',
        'b46c48': 'b4b4b4'
      };
      if (!this.hyperSpriteSheetLoader) {
        this.hyperSpriteSheetLoader = this.png.ready.then(() => this.hyperSpriteSheets = [this.png.recolor(hyperColorsRed).toUrl(), this.png.recolor(hyperColorsCyan).toUrl(), this.png.recolor(hyperColorsPurple).toUrl(), this.png.recolor(hyperColorsWhite).toUrl(), this.png.recolor(hyperColorsGreen).toUrl(), this.png.recolor(hyperColorsBlue).toUrl(), this.png.recolor(hyperColorsYellow).toUrl()]);
        this.hyperSpriteSheetLoaderTails = this.pngTails.ready.then(() => this.hyperSpriteSheetsTails = [this.pngTails.recolor(hyperColorsRed).toUrl(), this.pngTails.recolor(hyperColorsCyan).toUrl(), this.pngTails.recolor(hyperColorsPurple).toUrl(), this.pngTails.recolor(hyperColorsWhite).toUrl(), this.pngTails.recolor(hyperColorsGreen).toUrl(), this.pngTails.recolor(hyperColorsBlue).toUrl(), this.pngTails.recolor(hyperColorsYellow).toUrl()]);
      }
    }
  }, {
    key: "startle",
    value: function startle() {
      _get(_getPrototypeOf(Tails.prototype), "startle", this).call(this);
      this.args.animation = 'startle';
      this.onNextFrame(() => this.args.animation = 'startle');
    }
  }, {
    key: "updateStart",
    value: function updateStart() {
      if (this.args.grinding && this.args.falling && this.args.ySpeed > 0) {
        this.args.animation = 'springdash';
        this.args.grinding = false;
      }
      _get(_getPrototypeOf(Tails.prototype), "updateStart", this).call(this);
      if (this.args.dead) {
        this.args.animation = 'dead';
        return;
      }
    }
  }, {
    key: "update",
    value: function update() {
      if (this.isSuper) {
        if (this.isHyper) {
          if (this.viewport.args.frameId % 15 === 0) {
            this.hyperSheet++;
            if (this.hyperSheet >= this.hyperSpriteSheets.length) {
              this.hyperSheet = 0;
            }
          }
          this.hyperSpriteSheet = this.hyperSpriteSheets[this.hyperSheet];
          this.hyperSpriteSheetTails = this.hyperSpriteSheetsTails[this.hyperSheet];
          this.args.spriteSheet = `url(${this.hyperSpriteSheet})`;
          this.args.spriteSheetTails = `url(${this.hyperSpriteSheetTails})`;
        } else {
          if (this.viewport.args.frameId % 15 === 0) {
            this.superSheet++;
            if (this.superSheet >= this.superSpriteSheets.length) {
              this.superSheet = 0;
            }
          }
          this.superSpriteSheet = this.superSpriteSheets[this.superSheet];
          this.superSpriteSheetTails = this.superSpriteSheetsTails[this.superSheet];
          this.args.spriteSheet = `url(${this.superSpriteSheet})`;
          this.args.spriteSheetTails = `url(${this.superSpriteSheetTails})`;
        }
        const tick = this.isHyper ? 30 : 60;
        if (this.viewport.args.frameId % tick === 0) {
          if (this.args.rings < 2) {
            this.isHyper = false;
            this.setProfile();
          }
          if (this.args.rings > 0) {
            this.args.rings--;
          } else {
            this.isSuper = false;
            this.isHyper = false;
            this.setProfile();
          }
        }
      }
      this.args.isSuper = this.isSuper;
      this.args.isHyper = this.isHyper;
      if (!this.args.falling && this.groundTime > 3 || this.args.falling && this.fallTime > 90) {
        this.args.twistRamp = false;
      }
      if (this.yAxis === 0) {
        this.args.lookTime = 0;
        this.args.cameraBias = 0;
      }
      const falling = this.args.falling;
      if (!this.viewport) {
        return;
      }
      if (this.args.bouncing || this.args.wasHanging) {
        this.args.flying = false;
        if (this.flyingSound) {
          this.flyingSound.pause();
        }
      }
      if (this.args.flying) {
        this.args.gravity = this.args.slowGravity;
        this.args.ySpeed = Math.min(3, this.args.ySpeed);
      } else {
        this.args.gravity = this.args.normalGravity;
      }
      if (this.viewport.args.audio && this.flyingSound) {
        if (!this.flyingSound.paused) {
          this.flyingSound.volume = 0.35 + Math.random() * -0.3;
        }
        if (this.flyingSound.currentTime > 0.2) {
          this.flyingSound.currentTime = 0.0;
        }
      }
      if (!this.box) {
        _get(_getPrototypeOf(Tails.prototype), "update", this).call(this);
        return;
      }
      if (this.args.tailFlyCoolDown > 0) {
        this.args.tailFlyCoolDown--;
      }
      if (this.args.tailFlyCoolDown < 0) {
        this.args.tailFlyCoolDown++;
      }
      if (this.args.tailFlyCoolDown === 0) {
        // this.flyingSound.pause();
        // this.args.flying = false;
      }
      if (!falling) {
        this.args.tailFlyCoolDown = 0;
        this.flyingSound.pause();
        const direction = this.args.direction;
        const gSpeed = this.args.gSpeed;
        const speed = Math.abs(gSpeed);
        const maxSpeed = this.args.gSpeedMax;
        if (this.args.grinding) {
          this.args.animation = 'grinding';
          this.args.rolling = false;
        } else if (this.args.rolling) {
          this.args.animation = 'rolling';
        } else {
          if (Math.sign(this.args.gSpeed) !== direction && Math.abs(this.args.gSpeed - direction) > 5) {
            this.args.animation = 'skidding';
          } else if (speed > maxSpeed) {
            this.args.animation = 'running-2';
          } else if (speed > maxSpeed / 2) {
            this.args.animation = 'running';
          } else if (this.args.moving && this.args.gSpeed) {
            this.args.animation = 'walking';
          } else if (this.args.teeter) {
            this.args.animation = 'teeter';
          } else if (this.idleTime > 60) {
            this.args.animation = 'idle';
          } else {
            this.args.animation = 'standing';
          }
        }
      } else if (this.args.flying && !this.args.startled) {
        if (this.yAxis > 0 && this.args.flying) {
          this.flyingSound.pause();
          this.args.animation = 'jumping';
          this.args.float = 0;
          this.args.flying = false;
          this.args.ySpeed = this.args.ySpeed > this.args.jumpForce ? this.args.ySpeed : this.args.jumpForce;
        } else {
          if (this.viewport.args.audio) {
            this.flyingSound.play();
          }
          this.args.animation = 'flying';
          if (this.flyTime > this.args.maxFlyTime) {
            this.args.animation = 'flying-tired';
          }
        }
      } else if (this.args.jumping) {
        this.flyingSound.pause();
        this.args.animation = 'jumping';
      }
      if (!this.args.startled) {} else {
        this.flyingSound.pause();
        this.args.flying = false;
      }
      _get(_getPrototypeOf(Tails.prototype), "update", this).call(this);
      if (this.args.hangingFrom) {
        this.args.flying = false;
        this.flyTime = 0;
        this.args.animation = 'hanging';
      }
      if (this.args.grinding && !this.args.falling && this.args.gSpeed) {
        const sparkParticle = new _Tag.Tag(`<div class = "particle-sparks">`);
        const sparkEnvelope = new _Tag.Tag(`<div class = "envelope-sparks">`);
        sparkEnvelope.appendChild(sparkParticle.node);
        const sparkPoint = this.rotatePoint(-this.args.gSpeed * 1.75 * this.args.direction, 8);
        const flip = Math.sign(this.args.gSpeed);
        sparkEnvelope.style({
          '--x': sparkPoint[0] + this.x,
          '--y': sparkPoint[1] + this.y + Math.random * -3,
          'z-index': 0,
          'animation-delay': -Math.random() * 0.25 + 's',
          '--xMomentum': Math.max(Math.abs(this.args.gSpeed), 4) * flip,
          '--flip': flip,
          '--angle': this.realAngle,
          opacity: Math.random() * 2
        });
        sparkEnvelope.particle = sparkParticle;
        this.viewport.particles.add(sparkEnvelope);
        this.sparks.add(sparkEnvelope);
        this.viewport.onFrameOut(30, () => {
          this.viewport.particles.remove(sparkEnvelope);
          this.sparks.delete(sparkEnvelope);
        });
      }
      if (this.sparks.size) {
        for (const spark of this.sparks) {
          const sparkPoint = this.rotatePoint(1.75 * this.args.direction, 8);
          spark.style({
            opacity: Math.random() * 2,
            '--x': sparkPoint[0] + this.x,
            '--y': sparkPoint[1] + this.y
          });
        }
      }
      if (this.args.flying) {
        this.flyTime++;
      }
      if (!this.args.falling) {
        this.flyTime = 0;
        this.args.flying = false;
      } else {
        if (this.args.animation === 'springdash' && this.args.ySpeed >= 0) {
          this.args.animation = 'dropping';
        }
      }
      if (this.args.twistRamp) {
        this.args.animation = 'side-flip';
      }
      if (!this.args.falling) {
        this.dashed = false;
      }
    }
  }, {
    key: "updateEnd",
    value: function updateEnd() {
      _get(_getPrototypeOf(Tails.prototype), "updateEnd", this).call(this);
    }
  }, {
    key: "command_0",
    value: function command_0(button) {
      if (this.args.hangingFrom) {
        _get(_getPrototypeOf(Tails.prototype), "command_0", this).call(this);
        return;
      }
      _get(_getPrototypeOf(Tails.prototype), "command_0", this).call(this, button);
      if (!this.args.jumping) {
        return;
      }
      if (this.args.wasHanging) {
        return;
      }
      if (!this.args.falling) {
        this.args.tailFlyCoolDown = -80;
        return;
      }
      if (this.args.flying && this.args.tailFlyCoolDown === 0) {
        this.args.tailFlyCoolDown = 80;
        return;
      }
      if (this.args.flying && (this.flyTime > this.args.maxFlyTime || this.args.float)) {
        return;
      }
      if (this.args.flying && !this.args.float) {
        this.args.ySpeed = this.args.flyBoost;
        this.args.float = 8;
      }
      this.args.tailFlyCoolDown = 80;
      this.args.flying = true;
      this.flyingSound.volume = 0.35 + Math.random() * -0.3;
      if (this.viewport.args.audio && this.flyingSound.paused) {
        this.flyingSound.play();
      }
    }
  }, {
    key: "hold_0",
    value: function hold_0(button) {
      if (this.args.flying && button.time > 10 && button.time < 30 && this.flyTime < 400) {
        this.args.ySpeed *= 0.99;
        this.args.float = 16;
      }
    }
  }, {
    key: "sleep",
    value: function sleep() {
      this.flyingSound && this.flyingSound.pause();
    }
  }, {
    key: "collideA",
    value: function collideA(other) {
      if (other instanceof _Spring.Spring) {
        this.onNextFrame(() => {
          if (!this.args.falling) {
            return;
          }
          this.springing = true;
          this.args.animation = 'springdash';
        });
      }
      if (other.pop && this.isHyper) {
        other.pop(this);
      }
    }
  }, {
    key: "damage",
    value: function damage() {
      this.args.flying = false;
      this.flyingSound && this.flyingSound.pause();
      _get(_getPrototypeOf(Tails.prototype), "damage", this).call(this);
    }
  }, {
    key: "rotateMainColor",
    value: function rotateMainColor() {
      let rH = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      let rS = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      let rV = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
      const rotatedColors = {
        'ffb691': new _Color.Color('ffb691').rotate(rH, rS, rV).toString(),
        'fcb400': new _Color.Color('fcb400').rotate(rH, rS, rV).toString(),
        'fc9000': new _Color.Color('fc9000').rotate(rH, rS, rV).toString(),
        'b46c48': new _Color.Color('b46c48').rotate(rH, rS, rV).toString()
      };
      this.png.ready.then(() => {
        const newPng = this.png.recolor(rotatedColors);
        this.args.rotatedSpriteSheet = this.rotatedSpriteSheet = this.spriteSheet = newPng.toUrl();
        this.args.spriteSheet = `url(${this.spriteSheet})`;
      });
      this.pngTails.ready.then(() => {
        const newPng = this.pngTails.recolor(rotatedColors);
        this.args.rotatedSpriteSheetTails = this.rotatedSpriteSheetTails = this.spriteSheetTails = newPng.toUrl();
        this.args.spriteSheetTails = `url(${this.spriteSheetTails})`;
      });
      return Promise.all([this.png.ready, this.pngTails.ready]);
    }
  }, {
    key: "setProfile",
    value: function setProfile() {
      if (this.isHyper) {
        this.args.spriteSheet = `url('${this.hyperSpriteSheet}')`;
        this.args.spriteSheetTails = `url('${this.hyperSpriteSheetTails}')`;
        this.args.maxFlyTime = this.args.maxFlyTimeHyper;
        this.args.flyBoost = this.args.flyBoostHyper;
        this.args.gSpeedMax = this.gSpeedMaxHyper;
        this.args.jumpForce = this.jumpForceHyper;
        this.args.accel = this.accelSuper;
      } else if (this.isSuper) {
        this.args.spriteSheet = `url('${this.superSpriteSheet}')`;
        this.args.spriteSheetTails = `url('${this.superSpriteSheetTails}')`;
        this.args.maxFlyTime = this.args.maxFlyTimeSuper;
        this.args.flyBoost = this.args.flyBoostSuper;
        this.args.gSpeedMax = this.gSpeedMaxSuper;
        this.args.jumpForce = this.jumpForceSuper;
        this.args.accel = this.accelSuper;
      } else {
        this.args.spriteSheet = `url('${this.rotatedSpriteSheet}')`;
        this.args.spriteSheetTails = `url('${this.rotatedSpriteSheetTails}')`;
        this.args.maxFlyTime = this.args.maxFlyTimeNormal;
        this.args.flyBoost = this.args.flyBoostNormal;
        this.args.gSpeedMax = this.gSpeedMaxNormal;
        this.args.jumpForce = this.jumpForceNormal;
        this.args.accel = this.accelNormal;
      }
    }
  }, {
    key: "command_2",
    value: function command_2() {
      if (this.viewport.collisions.has(this)) {
        const objects = this.viewport.collisions.get(this);
        for (const object of objects.keys()) {
          if (this.carrying.size && !this.carrying.has(object)) {
            continue;
          }
          if (typeof object.lift === 'function') {
            object.lift(this);
          }
        }
      }
    }
  }, {
    key: "command_3",
    value: function command_3() {}
  }, {
    key: "solid",
    get: function get() {
      return false;
    }
  }, {
    key: "canRoll",
    get: function get() {
      return true;
    }
  }, {
    key: "canFly",
    get: function get() {
      return true;
    }
  }, {
    key: "isEffect",
    get: function get() {
      return false;
    }
  }, {
    key: "controllable",
    get: function get() {
      return !this.args.npc;
    }
  }]);
  return Tails;
}(_PointActor2.PointActor);
exports.Tails = Tails;
});

;require.register("actor/TechnoSqueak.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TechnoSqueak = void 0;
var _Flickie = require("./Flickie");
var _Mixin = require("curvature/base/Mixin");
var _PointActor = require("./PointActor");
var _Patrol = require("../behavior/Patrol");
var _CanPop = require("../mixin/CanPop");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let TechnoSqueak = /*#__PURE__*/function (_Mixin$from) {
  _inherits(TechnoSqueak, _Mixin$from);
  var _super = _createSuper(TechnoSqueak);
  function TechnoSqueak() {
    var _this$args$patrolPaus, _this$args$patrolBeat, _this$args$patrolSpee;
    var _this;
    _classCallCheck(this, TechnoSqueak);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.behaviors.add(new _Patrol.Patrol());
    _this.args.type = 'actor-item actor-techno-squeak';
    _this.args.animation = 'standing';
    _this.args.accel = 0.75;
    _this.args.decel = 0.5;
    _this.args.gSpeedMax = 15;
    _this.args.jumpForce = 5;
    _this.args.gravity = 0.5;
    _this.args.width = 24;
    _this.args.height = 14;
    _this.willStick = true;
    _this.stayStuck = true;
    _this.args.patrolPause = (_this$args$patrolPaus = _this.args.patrolPause) !== null && _this$args$patrolPaus !== void 0 ? _this$args$patrolPaus : 20;
    _this.args.patrolBeat = (_this$args$patrolBeat = _this.args.patrolBeat) !== null && _this$args$patrolBeat !== void 0 ? _this$args$patrolBeat : 120;
    _this.args.patrolSpeed = (_this$args$patrolSpee = _this.args.patrolSpeed) !== null && _this$args$patrolSpee !== void 0 ? _this$args$patrolSpee : 4;
    _this.args.tailOffset = 0;
    _this.stayStuck = true;
    return _this;
  }
  _createClass(TechnoSqueak, [{
    key: "onRendered",
    value: function onRendered(event) {
      _get(_getPrototypeOf(TechnoSqueak.prototype), "onRendered", this).call(this, event);
      this.autoStyle.get(this.box)['--tailOffset'] = 'tailOffset';
      this.autoAttr.get(this.box)['data-color'] = 'color';
    }
  }, {
    key: "update",
    value: function update() {
      // const direction = this.args.direction;
      const telegraph = this.args.shotTelegraph;
      const beat = this.args.patrolBeat;
      const moved = this.args.x - this.xLast;
      this.args.tailOffset += isNaN(moved) ? 0 : moved;
      if (this.box) {
        if (this.args.moving && this.args.gSpeed) {
          this.box.setAttribute('data-animation', 'walking');
        } else {
          this.box.setAttribute('data-animation', 'standing');
        }
      }
      _get(_getPrototypeOf(TechnoSqueak.prototype), "update", this).call(this);
      this.args.direction = Math.sign(this.args.gSpeed);
    }
  }, {
    key: "effect",
    value: function effect(other) {
      _get(_getPrototypeOf(TechnoSqueak.prototype), "effect", this).call(this, other);

      // this.viewport.spawn.add({object:new Flickie({
      // 	x: this.args.x,
      // 	y: this.args.y,
      // })});
    }
  }, {
    key: "solid",
    get: function get() {
      return false;
    }
  }, {
    key: "isEffect",
    get: function get() {
      return false;
    }
    // get controllable() { return true; }
  }]);
  return TechnoSqueak;
}(_Mixin.Mixin.from(_PointActor.PointActor, _CanPop.CanPop));
exports.TechnoSqueak = TechnoSqueak;
});

;require.register("actor/Tester.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Tester = void 0;
var _PointActor2 = require("./PointActor");
var _Cursor = require("./Cursor");
var _ObjectPalette = require("../ObjectPalette");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
window.testRuns = [];
let Tester = /*#__PURE__*/function (_PointActor) {
  _inherits(Tester, _PointActor);
  var _super = _createSuper(Tester);
  function Tester() {
    var _this;
    _classCallCheck(this, Tester);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _defineProperty(_assertThisInitialized(_this), "count", 0);
    _defineProperty(_assertThisInitialized(_this), "char", null);
    return _this;
  }
  _createClass(Tester, [{
    key: "update",
    value: function update() {
      if (!this.char) {
        const charType = _ObjectPalette.ObjectPalette['sonic'];
        const count = this.count;
        this.char = new charType({
          name: `Test #${count}`,
          x: this.x + -(count % 160) + +80,
          y: this.y
        });

        // this.char.cursor = new Cursor;

        const debind = this.char.args.bindTo('falling', () => {
          const landed = this.char.x;
          this.viewport.onFrameOut(5, () => {
            console.log({
              count: count,
              landed: landed,
              groundAngle: this.char.args.groundAngle,
              gSpeed: this.char.args.gSpeed
            });
          });
          debind();
        }, {
          now: false,
          frame: 1
        });
        window.testRuns[count] = this.char;
        this.count++;
        this.viewport.spawn.add({
          object: this.char
        });
        // this.viewport.spawn.add({object: this.char.cursor});
      } else {
        const controller = this.char.controller;
        const press = 4;
        if (this.char.age === 5) {
          controller.press(press, 1);
        }
        if (this.char.age === 6) {
          controller.press(press, 0);
        }
        this.char.readInput();
      }
      if (this.char.args.dead) {
        const dead = this.char;
        this.char = null;

        // this.viewport.actors.remove(dead.cursor)

        // dead.cursor.remove();

        this.viewport.onFrameOut(100, () => this.viewport.actors.remove(dead));
      } else if (this.char.age > 30) {
        this.char.xAxis = +1;
      }
    }
  }, {
    key: "updateEnd",
    value: function updateEnd() {
      if (this.char) {
        // this.char.cursor.args.x        = this.char.x;
        // this.char.cursor.args.y        = this.char.y;

        // this.char.cursor.args.angle    = this.char.angle;
        // this.char.cursor.args.airAngle = this.char.airAngle;

        // this.char.cursor.args.groundAngle = this.char.groundAngle;
      }
    }
  }]);
  return Tester;
}(_PointActor2.PointActor);
exports.Tester = Tester;
});

;require.register("actor/TextActor.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TextActor = void 0;
var _PointActor2 = require("./PointActor");
var _CharacterString = require("../ui/CharacterString");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let TextActor = /*#__PURE__*/function (_PointActor) {
  _inherits(TextActor, _PointActor);
  var _super = _createSuper(TextActor);
  function TextActor() {
    var _this;
    let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let parent = arguments.length > 1 ? arguments[1] : undefined;
    _classCallCheck(this, TextActor);
    _this = _super.call(this, args, parent);
    _defineProperty(_assertThisInitialized(_this), "float", -1);
    _this.args.type = 'actor-item actor-text-actor';
    _this.args.float = -1;
    _this.args.static = true;
    _this.text = new _CharacterString.CharacterString({
      value: ''
    });

    // this.args.x = args.x - 48;

    _this.args.bindTo('content', v => {
      _this.text.args.value = v;
      _this.text.args.color = args.color;
      _this.args.width = v ? v.length * 18 : 0;
      _this.args.height = 18;
    });
    return _this;
  }
  _createClass(TextActor, [{
    key: "onRendered",
    value: function onRendered(event) {
      _get(_getPrototypeOf(TextActor.prototype), "onRendered", this).call(this, event);
      this.sprite = this.findTag('div.sprite');
      this.text.render(this.sprite);
    }
  }, {
    key: "solid",
    get: function get() {
      return false;
    }
  }, {
    key: "isEffect",
    get: function get() {
      return true;
    }
  }]);
  return TextActor;
}(_PointActor2.PointActor);
exports.TextActor = TextActor;
});

;require.register("actor/TilesetSwapper.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TilesetSwapper = void 0;
var _PointActor2 = require("./PointActor");
var _ScreenFire = require("../effects/ScreenFire");
var _BackdropPalette = require("../BackdropPalette");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let TilesetSwapper = /*#__PURE__*/function (_PointActor) {
  _inherits(TilesetSwapper, _PointActor);
  var _super = _createSuper(TilesetSwapper);
  function TilesetSwapper(args, parent) {
    var _this;
    _classCallCheck(this, TilesetSwapper);
    _this = _super.call(this, args, parent);
    _this.args.hidden = true;
    const img = new Image('../Sonic/tiles/azure-lake/azure-lake-burnt.png');
    if (_BackdropPalette.BackdropPalette[_this.args.backdrop]) {
      const backdropClass = _BackdropPalette.BackdropPalette[_this.args.backdrop];
      _this.args.backdrop = new backdropClass();
    }
    return _this;
  }
  _createClass(TilesetSwapper, [{
    key: "activate",
    value: function activate(other, button) {
      // this.viewport.tilemap.replacements.set(
      // 	this.args.original//'../Sonic/tiles/azure-lake/azure-lake.png'
      // 	, this.args.replacement//'../Sonic/tiles/azure-lake/azure-lake-burnt.png'
      // );

      if (this.activated) {
        return;
      }
      this.activated = true;
      this.viewport.onFrameOut(15, () => {
        const fire = new _ScreenFire.ScreenFire();
        this.viewport.args.screenEffects.add(fire);
        this.viewport.onFrameOut(60 * 5, () => {
          this.viewport.args.screenEffects.remove(fire);
          fire.remove();
        });
        this.viewport.onFrameOut(60 * 1.5, () => {
          this.viewport.tileMap.replacements.set('/map/../Sonic/tiles/azure-lake/azure-lake.png', '/map/../Sonic/tiles/azure-lake/azure-lake-burnt.png');
          this.viewport.args.backdrop = this.args.backdrop;
          this.viewport.tileMap.replacements.set('/map/../Sonic/tiles/azure-lake/azure-lake-shapes.png', '/map/../Sonic/tiles/azure-lake/azure-lake-burnt-shapes.png');
          this.viewport.tileMap.replacements.set('/map/../Sonic/tiles/azure-lake/rolling.png', '/map/../Sonic/tiles/azure-lake/rolling-burnt.png');
          this.viewport.tileMap.replacements.set('/map/../Sonic/tiles/azure-lake/giant-loop.png', '/map/../Sonic/tiles/azure-lake/giant-loop-burnt.png');
          this.viewport.tileMap.replacements.set('/map/../Sonic/azure-lake-platform.png', '/map/../Sonic/azure-lake-platform-burnt.png');
        });
      });
    }
  }]);
  return TilesetSwapper;
}(_PointActor2.PointActor);
exports.TilesetSwapper = TilesetSwapper;
});

;require.register("actor/Torch.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Torch = void 0;
var _PointActor2 = require("./PointActor");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let Torch = /*#__PURE__*/function (_PointActor) {
  _inherits(Torch, _PointActor);
  var _super = _createSuper(Torch);
  function Torch() {
    var _this;
    _classCallCheck(this, Torch);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.width = 16;
    _this.args.height = 32;
    _this.args.type = 'actor-item actor-torch';
    _this.args.float = -1;
    return _this;
  }
  _createClass(Torch, [{
    key: "solid",
    get: function get() {
      return false;
    }
  }]);
  return Torch;
}(_PointActor2.PointActor);
exports.Torch = Torch;
});

;require.register("actor/Tornado.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Tornado = void 0;
var _Vehicle2 = require("./Vehicle");
var _Tag = require("curvature/base/Tag");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let Tornado = /*#__PURE__*/function (_Vehicle) {
  _inherits(Tornado, _Vehicle);
  var _super = _createSuper(Tornado);
  function Tornado() {
    var _this;
    _classCallCheck(this, Tornado);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.type = 'actor-item actor-tornado';
    _this.args.width = 96;
    _this.args.height = 48;
    _this.removeTimer = null;
    _this.args.xSpeedMaxThrusting = 64;
    _this.args.xSpeedMaxOriginal = 32;
    _this.args.xSpeedMax = _this.args.xSpeedMaxOriginal;
    _this.args.gSpeedMax = 5;
    _this.args.decel = 0.15;
    _this.args.accel = 0.5;
    _this.args.seatHeight = 14;
    _this.args.seatForward = -32;
    _this.args.skidTraction = 0.95;
    _this.dustCount = 0;
    _this.args.flyAngle = -0.25;
    _this.args.particleScale = 2;
    _this.args.float = -1;
    _this.args.thrusting = false;
    _this.args.landingGear = true;
    _this.args.jumpForce = 8;
    _this.args.fuelLevel = 100;
    _this.args.thrusterFill = 0;
    _this.args.noThrust = 0;
    _this.plane = new _Tag.Tag('<div class = "plane">');
    _this.fuselage = new _Tag.Tag('<div class = "fuselage">');
    _this.propeller = new _Tag.Tag('<div class = "propeller">');
    _this.thruster = new _Tag.Tag('<div class = "thruster">');
    _this.fuelMeter = new _Tag.Tag('<div class = "fuel-meter">');
    _this.frontGear = new _Tag.Tag('<div class = "front-landing-gear">');
    _this.rearGear = new _Tag.Tag('<div class = "rear-landing-gear">');
    return _this;
  }
  _createClass(Tornado, [{
    key: "onRendered",
    value: function onRendered(event) {
      _get(_getPrototypeOf(Tornado.prototype), "onRendered", this).call(this, event);
      this.box = this.findTag('div');
      this.sprite = this.findTag('div.sprite');
      this.sprite.appendChild(this.plane.node);
      this.thruster.appendChild(this.fuelMeter.node);
      this.plane.appendChild(this.thruster.node);
      this.plane.appendChild(this.propeller.node);
      this.plane.appendChild(this.frontGear.node);
      this.plane.appendChild(this.rearGear.node);
      this.plane.appendChild(this.fuselage.node);
      this.args.bindTo('landingGear', v => {
        if (this.plane) {
          this.plane.setAttribute('data-landing-gear', v);
        }
      });
      this.args.bindTo('thrusting', v => {
        if (this.plane) {
          this.plane.setAttribute('data-thrusting', v);
        }
      });
    }
  }, {
    key: "update",
    value: function update() {
      if (!this.occupant || !this.args.falling) {
        this.args.flyAngle = this.args.falling ? 0.26 : -0.26;
        this.args.flying = false;
        this.args.float = 0;
      }
      if (!this.args.thrusting && Math.abs(this.args.xSpeed) < 8) {
        this.args.float = 0;
        this.args.flying = false;
      } else if (this.args.falling) {
        this.args.float = -1;
        this.args.flying = true;
      }
      if (!this.args.jumping && this.args.xSpeed === 0 && this.args.falling) {
        this.args.flying = false;
        this.args.float = 0;
        if (this.args.thrusting) {
          this.args.crashed = true;
          this.args.thrusting = false;
          this.args.noThrust = Date.now() + 500;
        }
        _get(_getPrototypeOf(Tornado.prototype), "update", this).call(this);
        return;
      }
      const maxAirSpeed = this.args.xSpeedMaxThrusting;
      if (this.args.thrusting && this.args.fuelLevel <= 0) {
        this.args.thrusting = false;
        this.args.noThrust = Date.now() + 500;
        this.args.thrusterFill = Date.now() + 500;
      }
      if (this.args.thrusting) {
        this.args.xSpeedMax = this.args.xSpeedMaxThrusting;
        if (this.args.fuelLevel > 0) {
          this.args.fuelLevel -= 0.1;
        }
      } else {
        this.args.xSpeedMax = this.args.xSpeedMaxOriginal;
        if (this.args.thrusterFill < Date.now() && this.args.fuelLevel < 100) {
          this.args.fuelLevel += 0.25;
        }
      }
      this.fuelMeter.style({
        '--fuelLevel': this.args.fuelLevel / 100
      });
      if (!this.args.thrusting && Math.abs(this.args.xSpeed) > maxAirSpeed) {
        this.args.xSpeed -= Math.sign(this.args.xSpeed) * 0.2;
      }
      if (this.args.thrusting && (Math.sign(this.args.xSpeed) !== this.args.direction || Math.abs(this.args.xSpeed) < maxAirSpeed)) {
        if (!this.args.falling && this.args.xSpeed === 0) {
          this.args.flyAngle = -0.26;
          this.args.falling = true;
          this.args.flying = true;
          this.args.ySpeed = -5;
        }
        this.args.xSpeed += Math.sign(this.args.direction) * 4;
      }
      if (Math.abs(this.args.xSpeed) > this.args.xSpeedMax / 2 && !this.args.thrusting && !this.xAxis) {
        this.args.xSpeed *= 0.95;
      }
      if (Math.abs(this.args.xSpeed) > maxAirSpeed) {
        this.args.xSpeed = maxAirSpeed * Math.sign(this.args.direction);
      }
      if (this.args.flying) {
        if (this.args.ySpeed === 0) {
          this.args.flyAngle = 0;
        }
        if (this.args.landingGear) {
          if (!this.args.thrusting && this.args.flyAngle < Math.PI / 4) {
            this.args.flyAngle += 0.005;
          } else if (this.args.thrusting && this.args.flyAngle > -Math.PI / 4) {
            this.args.flyAngle -= 0.005;
          }
        } else {
          if (Math.abs(this.args.flyAngle) > 0.00125) {
            this.args.flyAngle -= 0.00125 * Math.sign(this.args.flyAngle);
          } else {
            this.args.flyAngle = 0;
          }
        }
        if (!this.args.xSpeed) {
          this.args.flying = false;
          return;
        }
        const newAngle = this.args.flyAngle + Math.sign(this.yAxis) * 0.035;
        if (this.args.flyAngle > 0) {
          this.args.xSpeed *= 1.025;
        } else if (this.args.flyAngle > 0) {
          this.args.xSpeed /= 1.025;
        }
        if (this.yAxis && Math.abs(newAngle) < Math.PI / 2) {
          this.args.flyAngle = newAngle;
        }
        if (Math.sign(this.args.xSpeed) === this.args.direction) {
          const speed = this.args.xSpeed || this.args.gSpeed;
          this.args.ySpeed = Math.sin(this.args.flyAngle) * speed * (this.args.direction || Math.sign(speed)) * 2;
        }
      } else {
        if (!this.args.thrusting && this.args.flyAngle < Math.PI / 2 && this.args.ySpeed > 0) {
          this.args.flyAngle += 0.025;
        }
      }
      if (this.args.flying) {
        this.args.airAngle = this.args.flyAngle;
        this.args.jumping = false;
      }
      if (!this.args.falling) {
        this.args.landingGear = true;
        this.args.flyAngle = -0.26;
      }
      _get(_getPrototypeOf(Tornado.prototype), "update", this).call(this);
      if (this.args.flying) {
        this.args.cameraMode = 'airplane';
      }
    }
  }, {
    key: "command_1",
    value: function command_1() {
      if (this.args.falling) {
        this.args.landingGear = !this.args.landingGear;
      }
    }
  }, {
    key: "hold_2",
    value: function hold_2() {
      if (!this.args.thrusting && this.args.fuelLevel <= 1) {
        return;
      }
      if (this.args.fuelLevel <= 0) {
        return;
      }
      if (this.args.crashed || this.args.noThrust > Date.now()) {
        this.args.false = true;
        return;
      }
      this.args.thrusting = true;
    }
  }, {
    key: "release_2",
    value: function release_2() {
      this.args.thrusting = false;
      this.args.crashed = false;
    }
  }, {
    key: "solid",
    get: function get() {
      return !this.occupant;
    }
  }]);
  return Tornado;
}(_Vehicle2.Vehicle);
exports.Tornado = Tornado;
});

;require.register("actor/ToxicBarrel.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ToxicBarrel = void 0;
var _MarbleBlock2 = require("./MarbleBlock");
var _BarnacleTrap = require("./BarnacleTrap");
var _Sfx = require("../audio/Sfx");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let ToxicBarrel = /*#__PURE__*/function (_MarbleBlock) {
  _inherits(ToxicBarrel, _MarbleBlock);
  var _super = _createSuper(ToxicBarrel);
  function ToxicBarrel() {
    var _this;
    let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    _classCallCheck(this, ToxicBarrel);
    _this = _super.call(this, args);
    _this.args.type = 'actor-item actor-toxic-barrel';
    _this.args.density = _this.args.density || 9.5;
    _this.played = false;
    _this.args.width = 23;
    _this.args.height = 32;
    _this.args.weight = 0;
    return _this;
  }
  _createClass(ToxicBarrel, [{
    key: "collideA",
    value: function collideA(other, type) {
      if (other instanceof _BarnacleTrap.BarnacleTrap) {
        return false;
      }
      if (this.args.falling && other.pop) {
        this.pop();
      }
      if (this.args.animation === 'exploding') {
        other.damage && other.damage(this, 'explosion');
        other.pop && other.pop(this);
        return false;
      }
      if (this.args.falling && other.args.modeTime < 3) {
        other.args.gSpeed = 0;
      }
      if (this.args.falling) {
        return false;
      }
      return _get(_getPrototypeOf(ToxicBarrel.prototype), "collideA", this).call(this, other, type);
    }
  }, {
    key: "update",
    value: function update() {
      if (this.args.animation === 'exploding') {
        this.args.float = -1;
        this.args.xSpeed = 0;
        this.args.ySpeed = 0;
        this.castRayQuick(32, 0, [0, -16]);
        this.castRayQuick(32, Math.PI, [0, -16]);
        this.castRayQuick(32, Math.PI / 2, [0, -16]);
        this.castRayQuick(32, Math.PI / -2, [0, -16]);
      }
      _get(_getPrototypeOf(ToxicBarrel.prototype), "update", this).call(this);
      if (!this.args.falling && this.ySpeedLast > 3) {
        this.pop();
      }
    }
  }, {
    key: "pop",
    value: function pop() {
      this.args.animation = 'exploding';
      const viewport = this.viewport;
      viewport.onFrameOut(20, () => viewport.actors.remove(this));
      if (!this.played) {
        _Sfx.Sfx.play('BARREL_EXPLODE');
        this.played = true;
      }
    }
  }, {
    key: "sleep",
    value: function sleep() {
      this.args.x = this.def.get('x');
      this.args.y = this.def.get('y');
      this.ySpeedLast = 0;
      this.onNextFrame(() => {
        this.args.x = this.def.get('x');
        this.args.y = this.def.get('y');
        this.viewport.setColCell(this);
        this.args.xSpeed = 0;
        this.args.ySpeed = 0;
        this.args.pushed = 0;
        this.args.float = 0;
      });
    }
  }, {
    key: "solid",
    get: function get() {
      return !this.args.falling;
    }
  }]);
  return ToxicBarrel;
}(_MarbleBlock2.MarbleBlock);
exports.ToxicBarrel = ToxicBarrel;
});

;require.register("actor/Tree.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Tree = void 0;
var _PointActor2 = require("./PointActor");
var _Coconut = require("./Coconut");
var _Tag = require("curvature/base/Tag");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let Tree = /*#__PURE__*/function (_PointActor) {
  _inherits(Tree, _PointActor);
  var _super = _createSuper(Tree);
  function Tree() {
    var _this;
    _classCallCheck(this, Tree);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.type = 'actor-item actor-tree';
    _this.args.z = -1;
    _this.args.width = 80;
    _this.args.lean = 0;
    _this.args.coconutCount = 4;
    _this.args.shakeTime = 0;
    return _this;
  }
  _createClass(Tree, [{
    key: "updateEnd",
    value: function updateEnd() {
      _get(_getPrototypeOf(Tree.prototype), "updateEnd", this).call(this);
      const objects = this.viewport.collisions.get(this);
      let shaking = false;
      if (objects) for (const object of objects.keys()) {
        if (object.args.currentState === 'shakingTree') {
          shaking = Math.sign(this.args.x - object.args.x);
        }
      }
      this.args.shaking = shaking;
    }
  }, {
    key: "update",
    value: function update() {
      const frame = this.viewport.args.frameId;
      if (this.args.shaking) {
        this.args.lean = 2 * (Math.trunc(this.args.shakeTime / 10) % 2) + -1 * this.args.shaking;
        this.args.shakeTime++;
      } else {
        if (this.viewport.args.frameId - this.args.lastChange > 1200 && this.args.coconutCount < 4) {
          this.args.coconutCount++;
          this.args.lastChange = this.viewport.args.frameId;
        }
        this.args.shakeTime = 0;
        this.args.lean = 0;
      }
      if (this.args.shakeTime > 120) {
        this.args.shakeTime = -60;
        this.dropFruit();
      }
      _get(_getPrototypeOf(Tree.prototype), "update", this).call(this);
    }
  }, {
    key: "onRendered",
    value: function onRendered(event) {
      _get(_getPrototypeOf(Tree.prototype), "onRendered", this).call(this, event);
      if (this.box && !this.top) {
        this.top = new _Tag.Tag(`<div class = "tree-top">`);
        this.box.appendChild(this.top.node);
      }
      this.autoStyle.get(this.box)['--count'] = 'coconutCount';
      this.autoStyle.get(this.box)['--lean'] = 'lean';
    }
  }, {
    key: "collideA",
    value: function collideA(other, type) {
      if (!other.controllable) {
        return;
      }
      // else
      // {
      // 	this.args.shaking = true;
      // }

      if (Math.abs(other.args.x - this.args.x) > 20) {
        return;
      }
      if (other.args.y > this.args.y + -this.args.height + 64) {
        return;
      }
      this.ignores.set(other, 45);
      this.dropFruit(other);
    }
  }, {
    key: "dropFruit",
    value: function dropFruit(other) {
      if (this.args.coconutCount) {
        this.args.coconutCount--;
        this.args.lastChange = this.viewport.args.frameId;
        const coconut = new _Coconut.Coconut();

        // coconut.args.ySpeed = -2;
        coconut.args.x = this.args.x;
        coconut.args.y = this.args.y + -this.args.height + 48;
        this.viewport.spawn.add({
          object: coconut
        });
        if (other) {
          this.viewport.onFrameOut(1, () => coconut.args.xSpeed = other.args.xSpeed || other.args.direction * Math.random() * 2);
          this.args.lean = 5 * Math.sign(other.args.xSpeed);
        } else {
          this.viewport.onFrameOut(1, () => coconut.args.xSpeed = this.args.lean * 0.5 + this.args.lean * 2.5 * Math.random());
        }
        this.viewport.onFrameOut(10, () => this.args.lean = 0);
      }
    }
  }, {
    key: "sleep",
    value: function sleep() {
      this.args.coconutCount = 4;
    }
  }, {
    key: "solid",
    get: function get() {
      return false;
    }
  }], [{
    key: "fromDef",
    value: function fromDef(objDef) {
      const obj = _get(_getPrototypeOf(Tree), "fromDef", this).call(this, objDef);
      obj.args.height = objDef.height;
      return obj;
    }
  }]);
  return Tree;
}(_PointActor2.PointActor);
exports.Tree = Tree;
});

;require.register("actor/TrickRamp.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TrickRamp = void 0;
var _PointActor2 = require("./PointActor");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let TrickRamp = /*#__PURE__*/function (_PointActor) {
  _inherits(TrickRamp, _PointActor);
  var _super = _createSuper(TrickRamp);
  function TrickRamp() {
    var _this;
    _classCallCheck(this, TrickRamp);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.type = 'actor-item actor-trick-ramp';
    _this.args.width = _this.args.width || 64;
    _this.args.height = _this.args.height || 64;
    _this.args.float = -1;
    _this.args.static = 1;
    _this.args.power = _this.args.power || 24;
    // this.args.hidden  = true;
    return _this;
  }
  _createClass(TrickRamp, [{
    key: "collideA",
    value: function collideA(other) {
      if (other.args.x < this.args.x) {
        return;
      }
      if (Math.abs(other.args.gSpeed) < 8 && other.willJump) {
        return;
      }
      if (Math.abs(other.args.gSpeed) < 14 && other.args.rolling && !other.willJump) {
        return;
      }
      if (other.willJump || other.args.rolling) {
        if (!other.args.falling) {
          const reward = {
            label: 'OFF THE RAMP',
            points: 100,
            multiplier: 1,
            color: 'orange',
            special: true
          };
          other.args.popChain.push(reward);
          other.args.popCombo += 1;
        }
        const dir = Math.sign(other.args.gSpeed || other.gSpeedLast);
        ;
        other.args.trickRamp = true;
        other.args.ignore = 5;
        other.args.xSpeed = this.args.power * dir;
        other.args.ySpeed = -this.args.power * 0.65;
        other.args.float = 18;
        other.args.y -= 5;
        other.args.rolling = true;
        other.args.falling = true;
        other.willJump = false;
        other.dashed = true;
      }
    }
  }], [{
    key: "fromDef",
    value: function fromDef(objDef) {
      const obj = _get(_getPrototypeOf(TrickRamp), "fromDef", this).call(this, objDef);
      obj.args.width = objDef.width;
      obj.args.height = objDef.height;
      return obj;
    }
  }]);
  return TrickRamp;
}(_PointActor2.PointActor);
exports.TrickRamp = TrickRamp;
});

;require.register("actor/TruckBody.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TruckBody = void 0;
var _PointActor = require("./PointActor");
var _Mixin = require("curvature/base/Mixin");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
// import { Sfx } from '../audio/Sfx';
let TruckBody = /*#__PURE__*/function (_Mixin$from) {
  _inherits(TruckBody, _Mixin$from);
  var _super = _createSuper(TruckBody);
  function TruckBody() {
    var _this;
    _classCallCheck(this, TruckBody);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.type = 'actor-item actor-truck-body';
    _this.args.width = 145;
    _this.args.height = 48;
    _this.args.gravity = 0.4;
    _this.args.float = -1;
    _this.noClip = 1;
    _this.args.driver = _this.args.driver || null;
    _this.args.ramming = true;
    return _this;
  }

  // collideA(other,type)
  // {
  // 	if(!other.controllable)
  // 	{
  // 		return;
  // 	}

  // 	other.damage(this);
  // }
  _createClass(TruckBody, [{
    key: "collideA",
    value: function collideA(other, type) {
      if (this.args.destroyed) {
        return;
      }
      if (other.break) {
        other.break(this);
        return;
      }
      if (other.pop) {
        other.pop(this);
        return;
      }
      if (!other.controllable) {
        return;
      }
      other.damage(this);
    }
  }]);
  return TruckBody;
}(_Mixin.Mixin.from(_PointActor.PointActor));
exports.TruckBody = TruckBody;
});

;require.register("actor/TruckCab.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TruckCab = void 0;
var _PointActor = require("./PointActor");
var _Mixin = require("curvature/base/Mixin");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
// import { Sfx } from '../audio/Sfx';
let TruckCab = /*#__PURE__*/function (_Mixin$from) {
  _inherits(TruckCab, _Mixin$from);
  var _super = _createSuper(TruckCab);
  function TruckCab() {
    var _this;
    _classCallCheck(this, TruckCab);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.type = 'actor-item actor-truck-cab';
    _this.args.width = 49;
    _this.args.height = 51;
    _this.args.gravity = 0.4;
    _this.args.float = -1;
    _this.noClip = 1;
    _this.args.driver = _this.args.driver || null;
    _this.args.ramming = true;
    return _this;
  }
  _createClass(TruckCab, [{
    key: "collideA",
    value: function collideA(other, type) {
      if (this.args.destroyed) {
        return;
      }
      if (other.break) {
        other.break(this);
        return;
      }
      if (other.pop) {
        other.pop(this);
        return;
      }
      if (!other.controllable) {
        return;
      }
      other.damage(this);
    }
  }]);
  return TruckCab;
}(_Mixin.Mixin.from(_PointActor.PointActor));
exports.TruckCab = TruckCab;
});

;require.register("actor/Tumbler.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Tumbler = void 0;
var _PointActor2 = require("./PointActor");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let Tumbler = /*#__PURE__*/function (_PointActor) {
  _inherits(Tumbler, _PointActor);
  var _super = _createSuper(Tumbler);
  function Tumbler() {
    var _this;
    _classCallCheck(this, Tumbler);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.decel = 0.1;
    _this.args.width = 96;
    _this.args.height = 35;
    _this.args.type = 'actor-item actor-tumbler';
    _this.args.color = _this.args.color || ['red', 'green', 'blue'][Math.trunc(3 * Math.random())];
    _this.tumbling = false;
    _this.bounced = 0;
    return _this;
  }
  _createClass(Tumbler, [{
    key: "onRendered",
    value: function onRendered(event) {
      _get(_getPrototypeOf(Tumbler.prototype), "onRendered", this).call(this, event);
      this.autoAttr.get(this.box)['data-color'] = 'color';
      this.autoAttr.get(this.box)['data-model'] = 'model';
    }
  }, {
    key: "update",
    value: function update() {
      if (this.tumbling && !this.args.falling) {
        this.args.xSpeed = this.xSpeedLast;
        this.args.ySpeed = Math.max(-10, -this.ySpeedLast);
        this.args.y--;
        this.args.falling = true;
        this.bounced++;
      }
      if (this.tumbling) {
        // this.args.xSpeed = (this.args.xSpeed || this.xSpeedLast) * 0.7;
      }
      this.noClip = !!this.bounced;
      if (this.noClip) {
        this.args.xSpeed = this.args.gSpeed = 0;
      }
      _get(_getPrototypeOf(Tumbler.prototype), "update", this).call(this);
    }
  }, {
    key: "collideA",
    value: function collideA(other, type) {
      if (!other.controllable && !other.isVehicle || this.args.falling) {
        return;
      }
      const speed = other.args.gSpeed || other.args.xSpeed;
      if (Math.abs(speed) > 8) {
        this.args.animation = 'tumbling';
        this.args.xSpeed = speed + 5 * Math.random();
        this.args.ySpeed = Math.max(-10, -Math.abs(speed * 0.25) + -2 * Math.random());
        this.args.falling = true;
        this.tumbling = true;
        this.isGhost = true;
      }
      _get(_getPrototypeOf(Tumbler.prototype), "collideA", this).call(this, other, type);
    }
  }]);
  return Tumbler;
}(_PointActor2.PointActor);
exports.Tumbler = Tumbler;
});

;require.register("actor/Turtloid.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Turtloid = void 0;
var _Block2 = require("./Block");
var _Sfx = require("../audio/Sfx");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let Turtloid = /*#__PURE__*/function (_Block) {
  _inherits(Turtloid, _Block);
  var _super = _createSuper(Turtloid);
  function Turtloid() {
    var _this;
    _classCallCheck(this, Turtloid);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.width = 56;
    _this.args.height = 24;
    _this.args.platform = 1;
    _this.args.float = -1;
    _this.args.type = 'actor-item actor-turtloid';
    _this.args.static = 0;
    _this.args.pathSpeed = 4;
    return _this;
  }
  _createClass(Turtloid, [{
    key: "updateStart",
    value: function updateStart() {
      if (this.standingUnder.size) {
        this.otherDefs.path = this.otherDefs.ridePath;
      } else {
        this.otherDefs.path = null;
      }
      _get(_getPrototypeOf(Turtloid.prototype), "updateStart", this).call(this);
      this.args.direction = Math.sign(this.args.x - this.xLast) || this.args.direction;
      const xSpeed = this.xLast - this.args.x;
      const ySpeed = this.yLast - this.args.y;
      if (xSpeed) {
        this.args.animation = 'swimming';
      } else if (ySpeed) {
        this.args.animation = 'sinking';
      } else {
        this.args.animation = 'idle';
      }
    }

    // sleep()
    // {
    // 	this.args.y = this.originalY;
    // }
  }]);
  return Turtloid;
}(_Block2.Block);
exports.Turtloid = Turtloid;
});

;require.register("actor/TwistRamp.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TwistRamp = void 0;
var _PointActor2 = require("./PointActor");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let TwistRamp = /*#__PURE__*/function (_PointActor) {
  _inherits(TwistRamp, _PointActor);
  var _super = _createSuper(TwistRamp);
  function TwistRamp() {
    var _this;
    _classCallCheck(this, TwistRamp);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.type = 'actor-item actor-twist-ramp';
    _this.args.width = _this.args.width || 64;
    _this.args.height = _this.args.height || 64;
    _this.args.float = -1;
    _this.args.static = 1;
    _this.args.power = _this.args.power || 24;
    // this.args.hidden  = true;
    return _this;
  }
  _createClass(TwistRamp, [{
    key: "collideA",
    value: function collideA(other) {
      if (other.args.x < this.args.x) {
        return;
      }
      if (Math.abs(other.args.gSpeed) < 8 && other.willJump) {
        return;
      }
      if (Math.abs(other.args.gSpeed) < 14 && other.args.rolling && !other.willJump) {
        return;
      }
      if (Math.abs(other.args.gSpeed) > 8) {
        // if(!other.args.falling)
        // {
        // 	const reward = {label:'OFF THE RAMP', points:100, multiplier: 1, color: 'orange', special: true};
        // 	other.args.popChain.push(reward);
        // 	other.args.popCombo += 1;
        // }

        const dir = Math.sign(other.args.gSpeed || other.gSpeedLast);
        other.args.twistRamp = true;
        other.args.ignore = 5;
        if (other.args.mode === 0) {
          other.args.xSpeed = this.args.power * dir;
          other.args.ySpeed = -this.args.power * 0.65;
          other.args.y -= 5;
        } else if (other.args.mode === 2) {
          other.args.xSpeed = -this.args.power * dir;
          other.args.ySpeed = this.args.power * 0.65;
          other.args.y += 5;
        } else if (other.args.mode === 3) {
          other.args.xSpeed = -this.args.power * 0.65;
          other.args.ySpeed = -this.args.power * dir;
          other.args.x -= 5;
        } else if (other.args.mode === 1) {
          other.args.xSpeed = this.args.power * 0.65;
          other.args.ySpeed = this.args.power * dir;
          other.args.x += 5;
        }
        other.args.float = 18;
        other.args.rolling = true;
        other.args.falling = true;
        other.willJump = false;
        other.dashed = true;
      }
    }
  }], [{
    key: "fromDef",
    value: function fromDef(objDef) {
      const obj = _get(_getPrototypeOf(TwistRamp), "fromDef", this).call(this, objDef);
      obj.args.width = objDef.width;
      obj.args.height = objDef.height;
      return obj;
    }
  }]);
  return TwistRamp;
}(_PointActor2.PointActor);
exports.TwistRamp = TwistRamp;
});

;require.register("actor/Umbrella.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Umbrella = void 0;
var _PointActor2 = require("./PointActor");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let Umbrella = /*#__PURE__*/function (_PointActor) {
  _inherits(Umbrella, _PointActor);
  var _super = _createSuper(Umbrella);
  function Umbrella() {
    var _this$args$height;
    var _this;
    _classCallCheck(this, Umbrella);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.width = 20;
    _this.args.height = (_this$args$height = _this.args.height) !== null && _this$args$height !== void 0 ? _this$args$height : 80;
    _this.args.type = 'actor-item actor-umbrella';
    return _this;
  }
  _createClass(Umbrella, [{
    key: "solid",
    get: function get() {
      return false;
    }
  }], [{
    key: "fromDef",
    value: function fromDef(objDef) {
      const obj = _get(_getPrototypeOf(Umbrella), "fromDef", this).call(this, objDef);
      obj.args.width = objDef.width;
      obj.args.height = objDef.height;
      return obj;
    }
  }]);
  return Umbrella;
}(_PointActor2.PointActor);
exports.Umbrella = Umbrella;
});

;require.register("actor/UnbreakableCrate.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.UnbreakableCrate = void 0;
var _PointActor = require("./PointActor");
var _Block2 = require("./Block");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let UnbreakableCrate = /*#__PURE__*/function (_Block) {
  _inherits(UnbreakableCrate, _Block);
  var _super = _createSuper(UnbreakableCrate);
  function UnbreakableCrate(args, parent) {
    var _this;
    _classCallCheck(this, UnbreakableCrate);
    _this = _super.call(this, args, parent);
    _this.args.type = 'actor-item actor-unbreakable-crate';
    _this.args.width = 64;
    _this.args.height = 64;
    _this.args.static = false;
    return _this;
  }
  _createClass(UnbreakableCrate, [{
    key: "update",
    value: function update() {
      if (this.viewport && this.args.gate) {
        const gatekeeper = this.viewport.actorsById[this.args.gate];
        if (!gatekeeper.args.hitPoints) {
          this.viewport.actors.remove(this);
        }
      }
      _get(_getPrototypeOf(UnbreakableCrate.prototype), "update", this).call(this);
    }
  }, {
    key: "collideA",
    value: function collideA(other, type) {
      return true;
    }
  }, {
    key: "damage",
    value: function damage(other, type) {
      return true;
    }
  }]);
  return UnbreakableCrate;
}(_Block2.Block);
exports.UnbreakableCrate = UnbreakableCrate;
});

;require.register("actor/Vehicle.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Vehicle = void 0;
var _PointActor2 = require("./PointActor");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let Vehicle = /*#__PURE__*/function (_PointActor) {
  _inherits(Vehicle, _PointActor);
  var _super = _createSuper(Vehicle);
  function Vehicle() {
    var _this;
    _classCallCheck(this, Vehicle);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _defineProperty(_assertThisInitialized(_this), "dead", false);
    return _this;
  }
  _createClass(Vehicle, [{
    key: "update",
    value: function update() {
      if (this.occupant) {
        this.running = this.occupant.running;
        this.crawling = this.occupant.crawling;
      }
      _get(_getPrototypeOf(Vehicle.prototype), "update", this).call(this);
    }
  }, {
    key: "collideA",
    value: function collideA(other, type) {
      if (other.noClip) {
        return false;
      }
      if (other.controllable) {
        if (other.args.falling && this.y + -other.y + 24 <= this.args.seatHeight) {
          return false;
        } else if (other.args.ySpeed > 0 && !this.occupant) {
          const seatHeight = this.args.seatHeight || 0;
          other.args.ySpeed = 0;
          other.args.y = this.y + -seatHeight + 1;
          other.args.x = this.x;
          other.args.standingOn = this;
          return true;
        } else {
          return false;
        }
      }
      if (other.y >= this.y) {
        return false;
      }
      if (!other.args.float) {
        other.args.ySpeed = -other.args.ySpeed;
        other.args.xSpeed = other.args.xSpeed || other.args.direction * 5;
        if (other.args.ySpeed > -5) {
          other.args.ySpeed = -5;
        }
      }
      return false;
    }
  }, {
    key: "standBelow",
    value: function standBelow(other) {
      if (!other.controllable) {
        other.args.ySpeed = -other.args.ySpeed;
        other.args.xSpeed = other.args.xSpeed || other.args.direction * 5;
        if (other.args.ySpeed > -5) {
          other.args.ySpeed = -5;
        }
      }
    }
  }, {
    key: "isVehicle",
    get: function get() {
      return true;
    }
  }, {
    key: "sleep",
    value: function sleep() {
      _get(_getPrototypeOf(Vehicle.prototype), "sleep", this).call(this);
      if (this.dead) {
        this.viewport.actors.remove(this);
        return;
      }
    }
  }]);
  return Vehicle;
}(_PointActor2.PointActor);
exports.Vehicle = Vehicle;
});

;require.register("actor/Voltorb.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Voltorb = void 0;
var _GohlaBall2 = require("../actor/GohlaBall");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let Voltorb = /*#__PURE__*/function (_GohlaBall) {
  _inherits(Voltorb, _GohlaBall);
  var _super = _createSuper(Voltorb);
  function Voltorb() {
    var _this;
    _classCallCheck(this, Voltorb);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.type = 'actor-item actor-gohla-ball actor-voltorb';
    return _this;
  }
  _createClass(Voltorb, [{
    key: "update",
    value: function update() {
      _get(_getPrototypeOf(Voltorb.prototype), "update", this).call(this);
      if (!this.viewport) {
        return;
      }
      if (!this.viewport.controlActor) {
        return;
      }
      const player = this.viewport.controlActor;
      this.direction = Math.sign(this.x - player.x);
      this.args.facing = this.direction < 0 ? 'left' : 'right';
      if (Math.abs(player.y - this.y) <= 16) {
        if (Math.abs(player.x - this.x) < 34) {
          this.args.animation = 'sparking';
          player.damage(this, 'electric');
        } else if (!player.args.dead && !player.args.mercy) {
          this.args.animation = 'standing';
        }
      } else if (!player.args.dead && !player.args.mercy) {
        this.args.animation = 'standing';
      }
    }
  }]);
  return Voltorb;
}(_GohlaBall2.GohlaBall);
exports.Voltorb = Voltorb;
});

;require.register("actor/WaterController.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WaterController = void 0;
var _PointActor2 = require("./PointActor");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let WaterController = /*#__PURE__*/function (_PointActor) {
  _inherits(WaterController, _PointActor);
  var _super = _createSuper(WaterController);
  function WaterController(args, parent) {
    var _this;
    _classCallCheck(this, WaterController);
    _this = _super.call(this, args, parent);
    _this.args.activated = false;
    _this.args.levelLimit = _this.args.levelLimit || 0;
    _this.args.levelSpeed = _this.args.levelSpeed || 1;
    _this.args.level = _this.args.level || 0;
    _this.args.static = true;
    _this.args.hidden = true;
    return _this;
  }
  _createClass(WaterController, [{
    key: "updateStart",
    value: function updateStart() {
      _get(_getPrototypeOf(WaterController.prototype), "updateStart", this).call(this);
      if (this.args.switch && !this.switch) {
        this.switch = this.viewport.actorsById[this.args.switch];
      }
      if (this.switch) {
        if (this.switch.args.active > 0) {
          this.activate(this.switch.activator, this.switch);
        }
      }
    }
  }, {
    key: "update",
    value: function update() {
      // if(this.args.activated && this.args.levelSpeed < 18)
      // {
      // 	this.args.levelSpeed += 1;
      // }

      if (this.args.level < this.args._levelLimit) {
        this.args.level += this.args.levelSpeed || 0;
      }
      if (this.args.level > this.args._levelLimit) {
        this.args.levelSpeed = 0;
        this.args.level = this.args._levelLimit;
        const viewport = this.viewport;
        viewport.onFrameOut(30, () => {
          viewport.auras.delete(this);
          if (this.args.target !== undefined) {
            const target = viewport.actorsById[this.args.target];
            viewport.auras.delete(target);
          }
        });
      }
    }
  }, {
    key: "activate",
    value: function activate(other, button) {
      if (this.args.activated) {
        return;
      }
      this.args._levelLimit = this.args.levelLimit || 4096;
      this.viewport.auras.add(this);
      this.args.activated = true;
      if (this.args.target !== undefined && this.viewport.actorsById[this.args.target]) {
        const target = this.viewport.actorsById[this.args.target];
        this.viewport.auras.add(target);
        target.activate(other, this);
      }
    }
  }]);
  return WaterController;
}(_PointActor2.PointActor);
exports.WaterController = WaterController;
});

;require.register("actor/WaterFall.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WaterFall = void 0;
var _PointActor2 = require("./PointActor");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let WaterFall = /*#__PURE__*/function (_PointActor) {
  _inherits(WaterFall, _PointActor);
  var _super = _createSuper(WaterFall);
  function WaterFall() {
    var _this$args$upward;
    var _this;
    _classCallCheck(this, WaterFall);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _defineProperty(_assertThisInitialized(_this), "float", -1);
    _this.args.width = _this.args.width || 32;
    _this.args.height = _this.args.height || 64;
    _this.args.upward = (_this$args$upward = _this.args.upward) !== null && _this$args$upward !== void 0 ? _this$args$upward : false;
    _this.args.type = 'actor-item actor-water-fall';
    _this.args.active = false;
    _this.args.static = true;
    return _this;
  }
  _createClass(WaterFall, [{
    key: "onRendered",
    value: function onRendered() {
      _get(_getPrototypeOf(WaterFall.prototype), "onRendered", this).call(this);
      this.autoAttr.get(this.box)['data-upward'] = 'upward';
    }
  }, {
    key: "wakeUp",
    value: function wakeUp() {
      this.switch = this.viewport.actorsById[this.args.switch];
    }
  }, {
    key: "update",
    value: function update() {
      _get(_getPrototypeOf(WaterFall.prototype), "update", this).call(this);
      if (this.args.toHeight !== this.args.height) {
        const diff = this.args.toHeight - this.args.height;
        const increment = Math.sign(diff) * 32;
        if (diff <= increment) {
          this.args.height = this.args.toHeight;
          this.args.y = this.args.yOriginal + this.args.toHeight;
        } else {
          this.args.height += increment;
          this.args.y += increment;
        }
      }
      if (this.switch && this.switch.args.active > 0 && !this.args.active) {
        this.args.active = true;
        this.args.toHeight = this.args.openHeight;
        this.args.y -= this.args.openOffset;
      }
    }
  }, {
    key: "solid",
    get: function get() {
      return false;
    }
  }, {
    key: "isEffect",
    get: function get() {
      return true;
    }
  }], [{
    key: "fromDef",
    value: function fromDef(objDef) {
      const obj = _get(_getPrototypeOf(WaterFall), "fromDef", this).call(this, objDef);
      obj.args.width = objDef.width;
      obj.args.height = objDef.height;
      obj.args.toHeight = objDef.toHeight || 0;
      obj.args.x = objDef.x + 32;
      obj.args.yOriginal = objDef.y;
      return obj;
    }
  }]);
  return WaterFall;
}(_PointActor2.PointActor);
exports.WaterFall = WaterFall;
});

;require.register("actor/WaterJet.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WaterJet = void 0;
var _PointActor2 = require("./PointActor");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let WaterJet = /*#__PURE__*/function (_PointActor) {
  _inherits(WaterJet, _PointActor);
  var _super = _createSuper(WaterJet);
  function WaterJet() {
    var _this;
    _classCallCheck(this, WaterJet);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _defineProperty(_assertThisInitialized(_this), "float", -1);
    _this.args.width = _this.args.width || 32;
    _this.args.height = _this.args.height || 64;
    _this.args.type = 'actor-item actor-water-jet';
    _this.args.active = false;
    _this.args.static = true;
    return _this;
  }
  _createClass(WaterJet, [{
    key: "wakeUp",
    value: function wakeUp() {
      this.switch = this.viewport.actorsById[this.args.switch];
    }
  }, {
    key: "update",
    value: function update() {
      _get(_getPrototypeOf(WaterJet.prototype), "update", this).call(this);
      if (!this.viewport || !this.args.switch) {
        return;
      }
      if (!this.switch) {
        return;
      }
      if (this.switch.args.active && !this.args.active) {
        this.args.active = true;
        this.onNextFrame(() => {
          this.args.x += 0.5 * this.args.openWidth + -0.5 * this.args.width;
          this.args.width = this.args.openWidth;
        });
      }
    }
  }, {
    key: "solid",
    get: function get() {
      return false;
    }
  }, {
    key: "isEffect",
    get: function get() {
      return true;
    }
  }], [{
    key: "fromDef",
    value: function fromDef(objDef) {
      const obj = _get(_getPrototypeOf(WaterJet), "fromDef", this).call(this, objDef);
      obj.args.width = objDef.width;
      obj.args.height = objDef.height;
      obj.args.x = objDef.x + objDef.width / 2;
      return obj;
    }
  }]);
  return WaterJet;
}(_PointActor2.PointActor);
exports.WaterJet = WaterJet;
});

;require.register("actor/WaterSpout.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WaterSpout = void 0;
var _PointActor2 = require("./PointActor");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let WaterSpout = /*#__PURE__*/function (_PointActor) {
  _inherits(WaterSpout, _PointActor);
  var _super = _createSuper(WaterSpout);
  function WaterSpout() {
    var _this$args$float, _this$args$static;
    var _this;
    let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let parent = arguments.length > 1 ? arguments[1] : undefined;
    _classCallCheck(this, WaterSpout);
    _this = _super.call(this, args, parent);
    _this.args.type = 'actor-item actor-water-spout';
    _this.args.float = (_this$args$float = _this.args.float) !== null && _this$args$float !== void 0 ? _this$args$float : -1;
    _this.args.static = (_this$args$static = _this.args.static) !== null && _this$args$static !== void 0 ? _this$args$static : true;
    _this.args.width = args.width || 32;
    _this.args.height = args.height || 64;
    return _this;
  }
  _createClass(WaterSpout, [{
    key: "solid",
    get: function get() {
      return false;
    }
  }], [{
    key: "fromDef",
    value: function fromDef(objDef) {
      const obj = _get(_getPrototypeOf(WaterSpout), "fromDef", this).call(this, objDef);
      obj.args.rotation = objDef.rotation;
      obj.args.height = objDef.height;
      return obj;
    }
  }]);
  return WaterSpout;
}(_PointActor2.PointActor);
exports.WaterSpout = WaterSpout;
});

;require.register("actor/WindStone.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WindStone = void 0;
var _CharacterString = require("../ui/CharacterString");
var _PointActor2 = require("./PointActor");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let WindStone = /*#__PURE__*/function (_PointActor) {
  _inherits(WindStone, _PointActor);
  var _super = _createSuper(WindStone);
  function WindStone() {
    var _this;
    _classCallCheck(this, WindStone);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.width = 8;
    _this.args.height = 24;
    _this.args.type = 'actor-item actor-wind-stone';
    _this.args.inPlace = false;
    _this.label = new _CharacterString.CharacterString({
      value: '❷'
    });
    _this.args.charStrings = [_this.label];
    _this.args.bindTo('inPlace', v => {
      if (!v) {
        _this.args.charStrings[0] = _this.label;
        return;
      }
      _this.args.charStrings.splice(0);
    });
    _this.bindTo('carriedBy', carrier => {
      if (_this.cX) {
        _this.cX();
        _this.cX = null;
      }
      if (_this.cY) {
        _this.cY();
        _this.cY = null;
      }
      if (carrier) {
        _this.cX = carrier.args.bindTo('x', v => _this.args.x = v + carrier.args.direction * 8);
        _this.cY = carrier.args.bindTo('y', v => _this.args.y = v + -16);
        carrier.carrying.add(_assertThisInitialized(_this));
        _this.args.float = -1;
        _this.args.charStrings.splice(0);
      } else if (_this.carriedBy) {
        const carrier = _this.carriedBy;
        _this.carriedBy = null;
        _this.args.xSpeed = carrier.args.xSpeed;
        _this.args.ySpeed = carrier.args.ySpeed;
        _this.args.xSpeed += Math.sign(carrier.args.gSpeed || carrier.args.xSpeed) * 4;
        _this.args.ySpeed -= 4;
        carrier.carrying.delete(_assertThisInitialized(_this));
        _this.args.falling = true;
        _this.args.float = 0;
        if (!_this.args.inPlace) {
          _this.args.charStrings[0] = _this.label;
        }
      }
    });
    return _this;
  }
  _createClass(WindStone, [{
    key: "lift",
    value: function lift(actor) {
      if (this.args.inPlace) {
        return;
      }
      if (this.carriedBy === actor) {
        this.carriedBy = null;
        return;
      }
      this.carriedBy = actor;
    }
  }, {
    key: "update",
    value: function update() {
      _get(_getPrototypeOf(WindStone.prototype), "update", this).call(this);
      if (this.args.inPlace) {
        this.args.x += Math.sign(this.args.standingOn.args.x - this.args.x);
        ;
      }
    }
  }, {
    key: "solid",
    get: function get() {
      return false;
    }
  }]);
  return WindStone;
}(_PointActor2.PointActor);
exports.WindStone = WindStone;
});

;require.register("actor/Window.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Window = void 0;
var _PointActor2 = require("./PointActor");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let Window = /*#__PURE__*/function (_PointActor) {
  _inherits(Window, _PointActor);
  var _super = _createSuper(Window);
  function Window() {
    var _this;
    _classCallCheck(this, Window);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _defineProperty(_assertThisInitialized(_this), "float", -1);
    _this.args.type = 'actor-item actor-window';
    _this.args.width = 64;
    _this.args.height = 160;
    return _this;
  }
  _createClass(Window, [{
    key: "solid",
    get: function get() {
      return false;
    }
  }, {
    key: "isEffect",
    get: function get() {
      return true;
    }
  }]);
  return Window;
}(_PointActor2.PointActor);
exports.Window = Window;
});

;require.register("actor/WoodenCrate.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WoodenCrate = void 0;
var _BreakableBlock2 = require("./BreakableBlock");
var _Platformer = require("../behavior/Platformer");
var _Projectile = require("./Projectile");
var _Spring = require("./Spring");
var _Block = require("./Block");
var _Sfx = require("../audio/Sfx");
var _OrbSmall = require("./OrbSmall");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let WoodenCrate = /*#__PURE__*/function (_BreakableBlock) {
  _inherits(WoodenCrate, _BreakableBlock);
  var _super = _createSuper(WoodenCrate);
  function WoodenCrate() {
    var _this;
    _classCallCheck(this, WoodenCrate);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.type = 'actor-item actor-breakable-block actor-wooden-crate';
    _this.args.width = 64;
    _this.args.height = 64;
    _this.args.static = false;
    _this[_Spring.Spring.WontSpring] = true;
    return _this;
  }
  _createClass(WoodenCrate, [{
    key: "updateStart",
    value: function updateStart() {
      if (this.args.static) {
        this.args.static = !!this.bMap('checkBelow', this.x, this.y + 1).get(_Platformer.Platformer);
      } else {
        this.args.static = !this.args.falling;
      }
      if (this.args.gSpeed || this.args.xSpeed) {
        this.args.static = false;
      }
      _get(_getPrototypeOf(WoodenCrate.prototype), "updateStart", this).call(this);
    }
  }, {
    key: "update",
    value: function update() {
      const wasFalling = this.args.falling;
      _get(_getPrototypeOf(WoodenCrate.prototype), "update", this).call(this);
      if (wasFalling && !this.args.falling && this.ySpeedLast > 9) {
        _Sfx.Sfx.play('WOOD_THUD');
      }
    }
  }, {
    key: "collideA",
    value: function collideA(other, type) {
      if (other.args.ramming) {
        return false;
      }
      if (other instanceof _Block.Block) {
        return true;
      }
      if (type === 0 && other.controllable) {
        return true;
        // return super.collideA(other, type);
      }

      if (other instanceof _OrbSmall.OrbSmall && !this.broken) {
        this.break(other);
        return false;
      }
      if (other instanceof _Projectile.Projectile && !this.broken) {
        this.break(other);
        return true;
      }

      // if(other.spindashCharge)
      // {
      // 	this.break(other);
      // 	return true;
      // }

      // if(type === -1 && !other.args.gSpeed && !other.args.falling && other.controllable)
      // {
      // 	this.break(other);
      // 	return false;
      // }

      if (type !== 1 && type !== 3 || other.y <= this.y - this.args.height) {
        return true;
      }
      if (other.args.rolling || type === 2) {
        this.args.gSpeed = 0;
        this.args.xSpeed = 0;
        this.break(other);
        return false;
      }
      if (other.punching && !this.broken) {
        this.args.gSpeed = 0;
        this.args.xSpeed = 0;
        this.break(other);
        return false;
      }
      if (!this.viewport) {
        return false;
      }
      if (type === -1 || other.args.rolling) {
        return _get(_getPrototypeOf(WoodenCrate.prototype), "collideA", this).call(this, other, type);
      }
      return true;
    }
  }, {
    key: "setTile",
    value: function setTile() {
      this.args.spriteSheet = '/Sonic/wooden-crate.png';
    }
  }]);
  return WoodenCrate;
}(_BreakableBlock2.BreakableBlock);
exports.WoodenCrate = WoodenCrate;
});

;require.register("actor/Zipline.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Zipline = void 0;
var _PointActor2 = require("./PointActor");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let Zipline = /*#__PURE__*/function (_PointActor) {
  _inherits(Zipline, _PointActor);
  var _super = _createSuper(Zipline);
  function Zipline() {
    var _this;
    _classCallCheck(this, Zipline);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.width = 1;
    _this.args.height = 1;
    _this.args.type = 'actor-item actor-zipline';
    _this.args.z = 128;
    _this.args.static = false;
    _this.breakable = false;
    _this.args.decel = 0;
    _this.args.accel = 0;
    return _this;
  }
  _createClass(Zipline, [{
    key: "activate",
    value: function activate() {
      this.viewport.auras.add(this);
      this.args.launched = true;
    }
  }, {
    key: "update",
    value: function update() {
      if (this.args.launched) {
        if (this.args.gSpeed < 1) {
          this.args.gSpeed = 1;
        }
        this.args.gSpeed += 0.1;
        const maxSpeed = Infinity;
        // const maxSpeed = 25;

        if (this.args.gSpeed > maxSpeed) {
          this.args.gSpeed = maxSpeed;
        }
      }
      _get(_getPrototypeOf(Zipline.prototype), "update", this).call(this);
    }
  }, {
    key: "collideA",
    value: function collideA(other, type) {
      if (!this.breakable) {
        return true;
      }
      return _get(_getPrototypeOf(Zipline.prototype), "collideA", this).call(this, other, type);
    }
  }]);
  return Zipline;
}(_PointActor2.PointActor);
exports.Zipline = Zipline;
});

;require.register("actor/monitor/InfoMonitor.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.InfoMonitor = void 0;
var _Monitor2 = require("../Monitor");
var _Sfx = require("../../audio/Sfx");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let InfoMonitor = /*#__PURE__*/function (_Monitor) {
  _inherits(InfoMonitor, _Monitor);
  var _super = _createSuper(InfoMonitor);
  function InfoMonitor() {
    var _this;
    _classCallCheck(this, InfoMonitor);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _defineProperty(_assertThisInitialized(_this), "name", 'Info Monitor');
    return _this;
  }
  _createClass(InfoMonitor, [{
    key: "onRendered",
    value: function onRendered(event) {
      _get(_getPrototypeOf(InfoMonitor.prototype), "onRendered", this).call(this, event);
      this.box.attr({
        'data-monitor': 'info'
      });
    }
  }, {
    key: "effect",
    value: function effect(other) {
      if (this.args.target && this.viewport.actorsById[this.args.target]) {
        const target = this.viewport.actorsById[this.args.target];
        target.activate(other, this, true);
        other.args.xSpeed *= 0.25;
        other.dropDashCharge = 0;
      }
    }
  }]);
  return InfoMonitor;
}(_Monitor2.Monitor);
exports.InfoMonitor = InfoMonitor;
});

;require.register("actor/monitor/RingMonitor.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RingMonitor = void 0;
var _Monitor2 = require("../Monitor");
var _Sfx = require("../../audio/Sfx");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let RingMonitor = /*#__PURE__*/function (_Monitor) {
  _inherits(RingMonitor, _Monitor);
  var _super = _createSuper(RingMonitor);
  function RingMonitor() {
    var _this;
    _classCallCheck(this, RingMonitor);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _defineProperty(_assertThisInitialized(_this), "name", 'Ring Monitor');
    return _this;
  }
  _createClass(RingMonitor, [{
    key: "onRendered",
    value: function onRendered(event) {
      _get(_getPrototypeOf(RingMonitor.prototype), "onRendered", this).call(this, event);
      this.box.attr({
        'data-monitor': 'ring'
      });
    }
  }, {
    key: "effect",
    value: function effect(other) {
      other.args.rings += 10;
      _Sfx.Sfx.play('RING_COLLECTED');
    }
  }]);
  return RingMonitor;
}(_Monitor2.Monitor);
exports.RingMonitor = RingMonitor;
});

;require.register("actor/monitor/SheildElectricMonitor.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SheildElectricMonitor = void 0;
var _Monitor2 = require("../Monitor");
var _ElectricSheild = require("../../powerups/ElectricSheild");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let SheildElectricMonitor = /*#__PURE__*/function (_Monitor) {
  _inherits(SheildElectricMonitor, _Monitor);
  var _super = _createSuper(SheildElectricMonitor);
  function SheildElectricMonitor() {
    var _this;
    _classCallCheck(this, SheildElectricMonitor);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _defineProperty(_assertThisInitialized(_this), "name", 'Lightning Monitor');
    return _this;
  }
  _createClass(SheildElectricMonitor, [{
    key: "onRendered",
    value: function onRendered(event) {
      _get(_getPrototypeOf(SheildElectricMonitor.prototype), "onRendered", this).call(this, event);
      this.box && this.box.attr({
        'data-monitor': 'sheild-electric'
      });
    }
  }, {
    key: "effect",
    value: function effect(other) {
      if (!other.controllable) {
        return;
      }
      const sheild = new _ElectricSheild.ElectricSheild();
      other.inventory.add(sheild);
    }
  }]);
  return SheildElectricMonitor;
}(_Monitor2.Monitor);
exports.SheildElectricMonitor = SheildElectricMonitor;
});

;require.register("actor/monitor/SheildFireMonitor.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SheildFireMonitor = void 0;
var _Monitor2 = require("../Monitor");
var _FireSheild = require("../../powerups/FireSheild");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let SheildFireMonitor = /*#__PURE__*/function (_Monitor) {
  _inherits(SheildFireMonitor, _Monitor);
  var _super = _createSuper(SheildFireMonitor);
  function SheildFireMonitor() {
    var _this;
    _classCallCheck(this, SheildFireMonitor);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _defineProperty(_assertThisInitialized(_this), "name", 'Fire Monitor');
    return _this;
  }
  _createClass(SheildFireMonitor, [{
    key: "onRendered",
    value: function onRendered(event) {
      _get(_getPrototypeOf(SheildFireMonitor.prototype), "onRendered", this).call(this, event);
      this.box.attr({
        'data-monitor': 'sheild-fire'
      });
    }
  }, {
    key: "effect",
    value: function effect(other) {
      if (!other.controllable) {
        return;
      }
      const sheild = new _FireSheild.FireSheild();
      other.inventory.add(sheild);
    }
  }]);
  return SheildFireMonitor;
}(_Monitor2.Monitor);
exports.SheildFireMonitor = SheildFireMonitor;
});

;require.register("actor/monitor/SheildNormalMonitor.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SheildNormalMonitor = void 0;
var _Monitor2 = require("../Monitor");
var _NormalSheild = require("../../powerups/NormalSheild");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let SheildNormalMonitor = /*#__PURE__*/function (_Monitor) {
  _inherits(SheildNormalMonitor, _Monitor);
  var _super = _createSuper(SheildNormalMonitor);
  function SheildNormalMonitor() {
    var _this;
    _classCallCheck(this, SheildNormalMonitor);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _defineProperty(_assertThisInitialized(_this), "name", 'Shield Monitor');
    return _this;
  }
  _createClass(SheildNormalMonitor, [{
    key: "onRendered",
    value: function onRendered(event) {
      _get(_getPrototypeOf(SheildNormalMonitor.prototype), "onRendered", this).call(this, event);
      this.box && this.box.attr({
        'data-monitor': 'sheild-normal'
      });
    }
  }, {
    key: "effect",
    value: function effect(other) {
      if (!other.controllable) {
        return;
      }
      const sheild = new _NormalSheild.NormalSheild();
      other.inventory.add(sheild);
    }
  }]);
  return SheildNormalMonitor;
}(_Monitor2.Monitor);
exports.SheildNormalMonitor = SheildNormalMonitor;
});

;require.register("actor/monitor/SheildStarMonitor.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SheildStarMonitor = void 0;
var _Monitor2 = require("../Monitor");
var _StarSheild = require("../../powerups/StarSheild");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let SheildStarMonitor = /*#__PURE__*/function (_Monitor) {
  _inherits(SheildStarMonitor, _Monitor);
  var _super = _createSuper(SheildStarMonitor);
  function SheildStarMonitor() {
    var _this;
    _classCallCheck(this, SheildStarMonitor);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _defineProperty(_assertThisInitialized(_this), "name", 'Star Monitor');
    return _this;
  }
  _createClass(SheildStarMonitor, [{
    key: "onRendered",
    value: function onRendered(event) {
      _get(_getPrototypeOf(SheildStarMonitor.prototype), "onRendered", this).call(this, event);
      this.box.attr({
        'data-monitor': 'sheild-star'
      });
    }
  }, {
    key: "effect",
    value: function effect(other) {
      if (!other.controllable) {
        return;
      }
      const sheild = new _StarSheild.StarSheild();
      other.inventory.add(sheild);
    }
  }]);
  return SheildStarMonitor;
}(_Monitor2.Monitor);
exports.SheildStarMonitor = SheildStarMonitor;
});

;require.register("actor/monitor/SheildWaterMonitor.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SheildWaterMonitor = void 0;
var _Monitor2 = require("../Monitor");
var _BubbleSheild = require("../../powerups/BubbleSheild");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let SheildWaterMonitor = /*#__PURE__*/function (_Monitor) {
  _inherits(SheildWaterMonitor, _Monitor);
  var _super = _createSuper(SheildWaterMonitor);
  function SheildWaterMonitor() {
    var _this;
    _classCallCheck(this, SheildWaterMonitor);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _defineProperty(_assertThisInitialized(_this), "name", 'Bubble Monitor');
    return _this;
  }
  _createClass(SheildWaterMonitor, [{
    key: "onRendered",
    value: function onRendered(event) {
      _get(_getPrototypeOf(SheildWaterMonitor.prototype), "onRendered", this).call(this, event);
      this.box.attr({
        'data-monitor': 'sheild-water'
      });
    }
  }, {
    key: "effect",
    value: function effect(other) {
      if (!other.controllable) {
        return;
      }
      const sheild = new _BubbleSheild.BubbleSheild();
      other.inventory.add(sheild);
    }
  }]);
  return SheildWaterMonitor;
}(_Monitor2.Monitor);
exports.SheildWaterMonitor = SheildWaterMonitor;
});

;require.register("actor/monitor/TripleRingMonitor.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TripleRingMonitor = void 0;
var _Monitor2 = require("../Monitor");
var _Sfx = require("../../audio/Sfx");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let TripleRingMonitor = /*#__PURE__*/function (_Monitor) {
  _inherits(TripleRingMonitor, _Monitor);
  var _super = _createSuper(TripleRingMonitor);
  function TripleRingMonitor() {
    var _this;
    _classCallCheck(this, TripleRingMonitor);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _defineProperty(_assertThisInitialized(_this), "name", 'Triple Ring Monitor');
    return _this;
  }
  _createClass(TripleRingMonitor, [{
    key: "onRendered",
    value: function onRendered(event) {
      _get(_getPrototypeOf(TripleRingMonitor.prototype), "onRendered", this).call(this, event);
      this.box.attr({
        'data-monitor': 'triple-ring'
      });
    }
  }, {
    key: "effect",
    value: function effect(other) {
      other.args.rings += 30;
      this.viewport.onFrameOut(6, () => _Sfx.Sfx.play('RING_COLLECTED'));
      this.viewport.onFrameOut(18, () => _Sfx.Sfx.play('RING_COLLECTED'));
      this.viewport.onFrameOut(32, () => _Sfx.Sfx.play('RING_COLLECTED'));
    }
  }]);
  return TripleRingMonitor;
}(_Monitor2.Monitor);
exports.TripleRingMonitor = TripleRingMonitor;
});

;require.register("actor/monitor/WebMonitor.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WebMonitor = void 0;
var _HtmlFrame = require("../HtmlFrame");
var _Monitor2 = require("../Monitor");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let WebMonitor = /*#__PURE__*/function (_Monitor) {
  _inherits(WebMonitor, _Monitor);
  var _super = _createSuper(WebMonitor);
  function WebMonitor() {
    var _this;
    _classCallCheck(this, WebMonitor);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _defineProperty(_assertThisInitialized(_this), "name", 'Web Monitor');
    return _this;
  }
  _createClass(WebMonitor, [{
    key: "onRendered",
    value: function onRendered(event) {
      _get(_getPrototypeOf(WebMonitor.prototype), "onRendered", this).call(this, event);
      this.box.attr({
        'data-monitor': 'web-monitor'
      });
    }
  }, {
    key: "effect",
    value: function effect(other) {
      const frame = new _HtmlFrame.HtmlFrame({
        x: this.x,
        y: this.y,
        width: 240,
        height: 180
      });
      this.viewport.spawn.add({
        object: frame
      });
    }
  }]);
  return WebMonitor;
}(_Monitor2.Monitor);
exports.WebMonitor = WebMonitor;
});

;require.register("audio/AudioManager.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AudioManager = void 0;
var _Pool = require("curvature/base/Pool");
var _Elicit = require("curvature/net/Elicit");
var _Mixin = require("curvature/base/Mixin");
var _EventTargetMixin = require("curvature/mixin/EventTargetMixin");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let AudioManager = /*#__PURE__*/function (_Mixin$with) {
  _inherits(AudioManager, _Mixin$with);
  var _super = _createSuper(AudioManager);
  function AudioManager() {
    var _this;
    _classCallCheck(this, AudioManager);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _defineProperty(_assertThisInitialized(_this), "volume", 1.0);
    _defineProperty(_assertThisInitialized(_this), "theme", '/Sonic/carnival-night-zone-act-2-beta.mp3');
    _defineProperty(_assertThisInitialized(_this), "overlay", '/audio/leslie-wai/feel-the-sunshine.mp3');
    _defineProperty(_assertThisInitialized(_this), "tracks", new Map());
    _defineProperty(_assertThisInitialized(_this), "plays", new Map());
    _defineProperty(_assertThisInitialized(_this), "tags", new Map());
    _defineProperty(_assertThisInitialized(_this), "factors", new Map());
    _defineProperty(_assertThisInitialized(_this), "stack", []);
    _defineProperty(_assertThisInitialized(_this), "playing", null);
    _defineProperty(_assertThisInitialized(_this), "id3", new Map());
    _defineProperty(_assertThisInitialized(_this), "request", []);
    _defineProperty(_assertThisInitialized(_this), "pool", new _Pool.Pool({
      max: 2,
      init: item => {
        item.open();
        return item;
      }
    }));
    _defineProperty(_assertThisInitialized(_this), "tracksPlaying", new Set());
    _defineProperty(_assertThisInitialized(_this), "tracksPaused", new Set());
    return _this;
  }
  _createClass(AudioManager, [{
    key: "setVolume",
    value: function setVolume() {
      let volume = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      this.volume = volume;
      if (this.playing) {
        this.playing.volume = volume;
      }
    }
  }, {
    key: "register",
    value: function register(tag, url) {
      let _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
        _ref$maxConcurrent = _ref.maxConcurrent,
        maxConcurrent = _ref$maxConcurrent === void 0 ? 1 : _ref$maxConcurrent,
        _ref$volume = _ref.volume,
        volume = _ref$volume === void 0 ? 1 : _ref$volume,
        _ref$fudgeFactor = _ref.fudgeFactor,
        fudgeFactor = _ref$fudgeFactor === void 0 ? 0 : _ref$fudgeFactor,
        _ref$startTime = _ref.startTime,
        startTime = _ref$startTime === void 0 ? 0 : _ref$startTime;
      const getTags = new _Elicit.Elicit(url, {
        defer: true
      });
      getTags.addEventListener('error', event => event.preventDefault());
      this.pool.add(getTags);
      if (url.substr(-3) === 'mp3') {
        this.request.push(getTags.buffer().then(buffer => {
          const list = Array(maxConcurrent).fill().map(x => new Audio(url));
          this.tracks.set(tag, list);
          for (const track of list) {
            this.factors.set(track, {
              volume: volume,
              fudgeFactor: fudgeFactor,
              startTime: startTime
            });
          }
          const bytes = new Uint8Array(buffer);
          const prefix = String.fromCharCode(...bytes.slice(0, 3));
          if (prefix !== 'ID3') {
            return;
          }
          const version = bytes[3];
          const revision = bytes[4];
          const flags = bytes[5];
          const size = bytes[6] << 21 | bytes[7] << 14 | bytes[8] << 7 | bytes[9];
          let i = 10;
          const tags = {};
          while (i < size) {
            const framePrefix = String.fromCharCode(...bytes.slice(i, i + 4));
            const frameSize = 10 + (bytes[i + 4] << 21 | bytes[i + 5] << 14 | bytes[i + 6] << 7 | bytes[i + 7]);
            if (frameSize === 10) {
              break;
            }
            if (i + frameSize > size) {
              break;
            }
            const frameValue = String.fromCharCode(...bytes.slice(i + 11, i + frameSize));
            if (!framePrefix) {
              break;
            }
            i += frameSize;
            if (!framePrefix) {
              break;
            }
            tags[framePrefix] = frameValue;
          }
          for (const track of list) {
            this.id3.set(track, tags);
          }
        }));
      } else {
        getTags.objectUrl().then(objectUrl => {
          const list = Array(maxConcurrent).fill().map(x => new Audio(objectUrl));
          this.tracks.set(tag, list);
          for (const track of list) {
            this.factors.set(track, {
              volume: volume,
              fudgeFactor: fudgeFactor,
              startTime: startTime
            });
          }
        });
      }
    }
  }, {
    key: "play",
    value: function play(tag) {
      let loop = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      let options = {
        loop: loop
      };
      if (_typeof(loop) === 'object') {
        options = loop;
        loop = loop.loop;
      }
      if (!this.playing) {
        this.playing = this.stack[this.stack.length - 1];
      }

      // if(this.playing && this.tags.get(this.playing) === tag)
      // {
      // 	if(this.playing.paused)
      // 	{
      // 		const cancelable = true;
      // 		const detail = this.id3.get(this.playing);

      // 		const play = new CustomEvent('play', {detail, cancelable});

      // 		if(!this.dispatchEvent(play))
      // 		{
      // 			return;
      // 		}

      // 		return this.unpause();
      // 	}
      // }
      // else if(this.playing)
      // {
      // 	this.playing.pause();
      // }

      if (!this.tracks.has(tag)) {
        return;
      }
      const candidates = new Map();
      const tracks = this.tracks.get(tag);
      let selected = null;
      for (const track of tracks) {
        if (!this.plays.has(track)) {
          selected = track;
          break;
        }
        candidates.set(track, this.plays.get(track));
      }
      if (!selected) {
        const sorted = [...candidates].sort((a, b) => Math.sign(a[1] - b[1]));
        selected = sorted[0][0];
      }
      if (selected) {
        let _this$factors$get = this.factors.get(selected),
          volume = _this$factors$get.volume,
          fudgeFactor = _this$factors$get.fudgeFactor,
          startTime = _this$factors$get.startTime;
        if ('volume' in options) {
          volume = options.volume;
        }
        const vol = this.volume * (volume + fudgeFactor * (Math.random() + -0.5));
        selected.playbackRate = 1.0;
        selected.currentTime = startTime;
        selected.volume = Math.max(0, Math.min(1, vol));
        selected.loop = loop;
        this.plays.set(selected, Date.now());
        this.playing = selected;
        this.stack.push(this.playing);
        const onCompleted = event => {
          this.playing = this.stack[this.stack.length - 1];
          this.tracksPlaying.delete(selected);
          this.stack.pop();
          this.play();
        };
        if (!loop) {
          this.playing.addEventListener('ended', onCompleted, {
            once: true
          });
        }
        this.tags.set(selected, tag);
        const cancelable = true;
        const play = new CustomEvent('play', {
          cancelable: cancelable
        });
        if (this.dispatchEvent(play)) {
          try {
            selected.play();
          } catch (error) {
            console.warn(error);
          }
        }
        Promise.all(this.request).then(() => {
          // const detail = this.id3.get(selected);
        });
        this.tracksPlaying.add(selected);
        return true;
      }
    }
  }, {
    key: "stop",
    value: function stop() {
      let tag = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      let requeue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      if (tag === null && this.playing) {
        this.playing.pause();
        this.playing = null;
      }
      for (const t of Object.keys(this.stack)) {
        const track = this.stack[t];
        if (!this.tags.has(track)) {
          delete this.stack.splice(t, 1);
          continue;
        }
        if (tag === null || this.tags.get(track) === tag) {
          const cancelable = true;
          const detail = this.id3.get(this.playing);
          const stop = new CustomEvent('stop', {
            detail: detail,
            cancelable: cancelable
          });
          if (this.dispatchEvent(stop)) {
            if (!track.paused) {
              track.pause();
            }
            delete this.stack.splice(t, 1);
          }
        }
      }
      if (requeue) {
        this.playing = this.stack[this.stack.length - 1];
        if (this.playing) {
          this.play(this.tags.get(this.playing));
        }
      }
    }
  }, {
    key: "pause",
    value: function pause() {
      if (!this.playing || this.playing.paused) {
        return;
      }
      const cancelable = true;
      const detail = this.id3.get(this.playing);
      const pause = new CustomEvent('pause', {
        detail: detail,
        cancelable: cancelable
      });
      if (!this.dispatchEvent(pause)) {
        return;
      }
      for (const track of this.tracksPlaying) {
        this.tracksPaused.add(track);
        track.pause();
      }

      // this.playing.pause();
    }
  }, {
    key: "unpause",
    value: function unpause() {
      if (!this.playing || !this.playing.paused) {
        return;
      }
      const cancelable = true;
      const detail = this.id3.get(this.playing);
      const unpause = new CustomEvent('unpause', {
        detail: detail,
        cancelable: cancelable
      });
      if (!this.dispatchEvent(unpause)) {
        return;
      }
      for (const track of this.tracksPaused) {
        this.tracksPaused.delete(track);
        if (track.played && track.played < 1) {
          track.play();
        } else {
          this.tracksPaused.delete(track);
        }
      }

      // this.playing && this.playing.play();
    }
  }, {
    key: "fadeOut",
    value: function fadeOut(time) {
      return new Promise(accept => {
        let track;
        let start;
        let initial;
        let interval;
        const fade = () => {
          track = this.playing;
          if (!track) {
            return;
          }
          if (!start) {
            initial = track.volume;
            start = Date.now();
          }
          const now = Date.now();
          const vol = 1 - Math.min(1, (now - start) / time);
          track.volume = vol * initial;
          if (!vol) {
            this.stop(this.tags.get(track));
            clearInterval(interval);
            accept();
          }
        };
        interval = setInterval(fade, 16);
      });
    }
  }]);
  return AudioManager;
}(_Mixin.Mixin.with(_EventTargetMixin.EventTargetMixin));
exports.AudioManager = AudioManager;
});

;require.register("audio/Bgm.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BgmHandler = exports.Bgm = void 0;
var _Pool = require("curvature/base/Pool");
var _Elicit = require("curvature/net/Elicit");
var _Mixin = require("curvature/base/Mixin");
var _EventTargetMixin = require("curvature/mixin/EventTargetMixin");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let BgmHandler = /*#__PURE__*/function (_Mixin$with) {
  _inherits(BgmHandler, _Mixin$with);
  var _super = _createSuper(BgmHandler);
  function BgmHandler() {
    var _this;
    _classCallCheck(this, BgmHandler);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _defineProperty(_assertThisInitialized(_this), "volume", 1.0);
    _defineProperty(_assertThisInitialized(_this), "tracks", new Map());
    _defineProperty(_assertThisInitialized(_this), "plays", new Map());
    _defineProperty(_assertThisInitialized(_this), "tags", new Map());
    _defineProperty(_assertThisInitialized(_this), "stack", []);
    _defineProperty(_assertThisInitialized(_this), "playing", null);
    _defineProperty(_assertThisInitialized(_this), "id3", new Map());
    _defineProperty(_assertThisInitialized(_this), "request", []);
    _defineProperty(_assertThisInitialized(_this), "pool", new _Pool.Pool({
      max: 3,
      init: item => {
        item.open();
        return item;
      }
    }));
    _defineProperty(_assertThisInitialized(_this), "downloads", new Map());
    _defineProperty(_assertThisInitialized(_this), "cancels", new Map());
    return _this;
  }
  _createClass(BgmHandler, [{
    key: "setVolume",
    value: function setVolume() {
      let volume = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      this.volume = volume;
      if (this.playing) {
        this.playing.volume = volume;
      }
    }
  }, {
    key: "register",
    value: function register(tag, url) {
      let maxConcurrent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
      const getTags = new _Elicit.Elicit(url, {
        defer: true
      });
      getTags.addEventListener('error', event => event.preventDefault());
      const getBlob = getTags.blob();
      this.pool.add(getTags);
      const registerTrack = getBlob.then(blob => Promise.all([blob.arrayBuffer(), URL.createObjectURL(blob)])).then(_ref => {
        let _ref2 = _slicedToArray(_ref, 2),
          buffer = _ref2[0],
          objectUrl = _ref2[1];
        this.downloads.delete(tag);
        const list = Array(maxConcurrent).fill().map(x => new Audio(objectUrl));
        this.tracks.set(tag, list);
        const bytes = new Uint8Array(buffer);
        const prefix = String.fromCharCode(...bytes.slice(0, 3));
        if (prefix !== 'ID3') {
          return;
        }
        const version = bytes[3];
        const revision = bytes[4];
        const flags = bytes[5];
        const size = bytes[6] << 21 | bytes[7] << 14 | bytes[8] << 7 | bytes[9];
        let i = 10;
        const tags = {};
        while (i < size) {
          const framePrefix = String.fromCharCode(...bytes.slice(i, i + 4));
          const frameSize = 10 + (bytes[i + 4] << 21 | bytes[i + 5] << 14 | bytes[i + 6] << 7 | bytes[i + 7]);
          if (frameSize === 10) {
            break;
          }
          if (i + frameSize > size) {
            break;
          }
          const frameValue = String.fromCharCode(...bytes.slice(i + 11, i + frameSize));
          if (!framePrefix) {
            break;
          }
          i += frameSize;
          if (!framePrefix) {
            break;
          }
          tags[framePrefix] = frameValue;
        }
        const commentPrefixU = "XXXComment\0";
        const commentPrefixL = "xxxComment\0";
        if (tags['COMM'] && tags['COMM'].substr(0, commentPrefixU.length) === commentPrefixU) {
          tags['COMM'] = tags['COMM'].slice(commentPrefixU.length);
        } else if (tags['COMM'] && tags['COMM'].substr(0, commentPrefixL.length) === commentPrefixL) {
          tags['COMM'] = tags['COMM'].slice(commentPrefixL.length);
        }
        for (const track of list) {
          this.id3.set(track, tags);
        }
      });
      this.request.push(registerTrack);
      this.downloads.set(tag, registerTrack);
    }
  }, {
    key: "play",
    value: function play(tag) {
      let _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        _ref3$loop = _ref3.loop,
        loop = _ref3$loop === void 0 ? false : _ref3$loop,
        _ref3$interlude = _ref3.interlude,
        interlude = _ref3$interlude === void 0 ? false : _ref3$interlude,
        _ref3$dontClear = _ref3.dontClear,
        dontClear = _ref3$dontClear === void 0 ? false : _ref3$dontClear;
      if (this.downloads.has(tag)) {
        this.downloads.get(tag).then(() => {
          this.downloads.delete(tag);
          this.play(tag, {
            loop: loop,
            interlude: interlude,
            dontClear: dontClear
          });
        });
        return;
      }
      if (this.tags.get(this.playing) !== tag && !interlude && !dontClear) {
        for (const track of this.stack) {
          track.pause();
        }
        this.stack.length = 0;
        this.playing = false;
      }
      if (!this.playing) {
        this.playing = this.stack[this.stack.length - 1];
      }
      if (this.playing && this.tags.get(this.playing) === tag) {
        if (this.playing.paused) {
          const cancelable = true;
          const detail = this.id3.get(this.playing);
          const play = new CustomEvent('play', {
            detail: detail,
            cancelable: cancelable
          });
          if (!this.dispatchEvent(play)) {
            return;
          }
          return this.unpause();
        }
      } else if (this.playing) {
        this.playing.pause();
      }
      if (!this.tracks.has(tag)) {
        return;
      }
      const candidates = new Map();
      const tracks = this.tracks.get(tag);
      let selected = null;
      for (const track of tracks) {
        if (!this.plays.has(track)) {
          selected = track;
          break;
        }
        candidates.set(this.plays.get(track), track);
      }
      if (!selected) {
        const sorted = [...candidates].sort((a, b) => Math.sign(a[0] - b[0]));
        selected = sorted[0][1];
      }
      if (selected && selected !== this.playing) {
        selected.playbackRate = 1.0;
        selected.currentTime = 0.0;
        selected.volume = this.volume;
        selected.loop = loop;
        this.plays.set(selected, Date.now());
        this.playing = selected;
        this.stack.push(this.playing);
        const onCompleted = event => {
          this.stack.pop();
          this.playing = this.stack[this.stack.length - 1];
          // this.play();
        };

        if (!loop) {
          this.playing.addEventListener('ended', onCompleted, {
            once: true
          });
        }
        this.tags.set(selected, tag);
        Promise.all(this.request).then(() => {
          const cancelable = true;
          const detail = this.id3.get(selected);
          const play = new CustomEvent('play', {
            detail: detail,
            cancelable: cancelable
          });
          if (this.dispatchEvent(play)) {
            try {
              selected.play();
            } catch (error) {
              console.warn(error);
            }
          }
        });
      }
    }
  }, {
    key: "stop",
    value: function stop() {
      let tag = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      if (tag === null && this.playing) {
        this.playing.pause();
        this.playing = null;
      }
      for (const t of Object.keys(this.stack)) {
        const track = this.stack[t];
        if (!this.tags.has(track)) {
          delete this.stack.splice(t, 1);
          continue;
        }
        if (tag === null || this.tags.get(track) === tag) {
          const cancelable = true;
          const detail = this.id3.get(this.playing);
          const stop = new CustomEvent('stop', {
            detail: detail,
            cancelable: cancelable
          });
          if (this.dispatchEvent(stop)) {
            if (!track.paused) {
              track.pause();
            }
            delete this.stack.splice(t, 1);
          }
        }
      }
      this.playing = this.stack[this.stack.length - 1];
      if (this.playing) {
        this.play(this.tags.get(this.playing), {
          dontClear: true
        });
      }
    }
  }, {
    key: "pause",
    value: function pause() {
      if (!this.playing || this.playing.paused) {
        return;
      }
      const cancelable = true;
      const detail = this.id3.get(this.playing);
      const pause = new CustomEvent('pause', {
        detail: detail,
        cancelable: cancelable
      });
      if (!this.dispatchEvent(pause)) {
        return;
      }
      this.playing.pause();
    }
  }, {
    key: "unpause",
    value: function unpause() {
      if (!this.playing || !this.playing.paused) {
        return;
      }
      const cancelable = true;
      const detail = this.id3.get(this.playing);
      const unpause = new CustomEvent('unpause', {
        detail: detail,
        cancelable: cancelable
      });
      if (!this.dispatchEvent(unpause)) {
        return;
      }
      this.playing && this.playing.play();
    }
  }, {
    key: "fadeOut",
    value: function fadeOut(time) {
      return new Promise(accept => {
        let track;
        let start;
        let initial;
        let interval;
        track = this.playing;
        const fade = () => {
          if (!track) {
            clearInterval(interval);
            return;
          }
          if (!start) {
            initial = track.volume;
            start = Date.now();
          }
          const now = Date.now();
          const vol = 1 - Math.min(1, (now - start) / time);
          track.volume = vol * initial;
          if (!vol) {
            this.stop(this.tags.get(track));
            clearInterval(interval);
            accept();
          }
        };
        interval = setInterval(fade, 16);
      });
    }
  }]);
  return BgmHandler;
}(_Mixin.Mixin.with(_EventTargetMixin.EventTargetMixin));
exports.BgmHandler = BgmHandler;
const Bgm = new BgmHandler();
exports.Bgm = Bgm;
});

require.register("audio/Sfx.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Sfx = void 0;
var _AudioManager = require("./AudioManager");
const Sfx = new _AudioManager.AudioManager();
exports.Sfx = Sfx;
});

require.register("backdrop/AngelIsland.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AngelIsland = void 0;
var _Backdrop2 = require("./Backdrop");
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
const recolor = [{
  '990099': 'fcfcfc',
  '770077': '0048fc',
  '550055': '90fcfc'
}, {
  '990099': '90fcfc',
  '770077': 'fcfcfc',
  '550055': '90fcfc'
}, {
  '990099': '6c90fc',
  '770077': '90fcfc',
  '550055': '90fcfc'
}, {
  '990099': '0048fc',
  '770077': '6c90fc',
  '550055': '90fcfc'
}, {
  '990099': 'fcfcfc',
  '770077': '0048fc',
  '550055': '6c90fc'
}, {
  '990099': '90fcfc',
  '770077': 'fcfcfc',
  '550055': '0048fc'
}, {
  '990099': '6c90fc',
  '770077': '90fcfc',
  '550055': 'fcfcfc'
}, {
  '990099': '0048fc',
  '770077': '6c90fc',
  '550055': '90fcfc'
}];
let AngelIsland = /*#__PURE__*/function (_Backdrop) {
  _inherits(AngelIsland, _Backdrop);
  var _super = _createSuper(AngelIsland);
  function AngelIsland(args, parent) {
    var _this;
    _classCallCheck(this, AngelIsland);
    _this = _super.call(this, args, parent);
    _this.args.name = 'angel-island';
    _this.args.strips = [{
      autoscroll: -0.230,
      parallax: 0.005,
      url: '/Sonic/backdrop/angel-island/sky-0.png',
      height: 196
    }, {
      autoscroll: -0.230,
      parallax: 0.005,
      url: '/Sonic/backdrop/angel-island/reflection.png',
      height: 33
    }, {
      autoscroll: 0.000,
      parallax: 0.009,
      url: '/Sonic/backdrop/angel-island/water-1.png',
      interval: 12,
      timeout: 100,
      frame: 0,
      recolor: recolor,
      height: -16
    }, {
      autoscroll: 0.000,
      parallax: 0.011,
      url: '/Sonic/backdrop/angel-island/water-2.png',
      height: 8,
      interval: 14,
      timeout: 100,
      frame: 0,
      recolor: recolor
    }, {
      autoscroll: 0.000,
      parallax: 0.013,
      url: '/Sonic/backdrop/angel-island/water-3.png',
      height: 8,
      interval: 16,
      timeout: 100,
      frame: 0,
      recolor: recolor
    }, {
      autoscroll: 0.000,
      parallax: 0.015,
      url: '/Sonic/backdrop/angel-island/water-4.png',
      height: 16,
      interval: 16,
      timeout: 100,
      frame: 0,
      recolor: recolor
    }, {
      autoscroll: 0.000,
      parallax: 0.017,
      url: '/Sonic/backdrop/angel-island/water-5.png',
      height: 8,
      interval: 16,
      timeout: 100,
      frame: 4,
      recolor: recolor
    }, {
      autoscroll: 0.000,
      parallax: 0.019,
      url: '/Sonic/backdrop/angel-island/water-6.png',
      height: 8,
      interval: 13,
      timeout: 100,
      frame: 0,
      recolor: recolor
    }, {
      autoscroll: 0.000,
      parallax: 0.021,
      url: '/Sonic/backdrop/angel-island/water-7.png',
      height: 16,
      interval: 11,
      timeout: 100,
      frame: 1,
      recolor: recolor
    }, {
      autoscroll: 0.000,
      parallax: 0.023,
      url: '/Sonic/backdrop/angel-island/water-8.png',
      height: 8,
      interval: 12,
      timeout: 100,
      frame: 2,
      recolor: recolor
    }, {
      autoscroll: 0.000,
      parallax: 0.025,
      url: '/Sonic/backdrop/angel-island/water-9.png',
      height: 8,
      interval: 11,
      timeout: 100,
      frame: 0,
      recolor: recolor
    }, {
      autoscroll: 0.000,
      parallax: 0.028,
      url: '/Sonic/backdrop/angel-island/water-10.png',
      height: 8,
      interval: 13,
      timeout: 100,
      frame: 3,
      recolor: recolor
    }, {
      autoscroll: 0.000,
      parallax: 0.030,
      url: '/Sonic/backdrop/angel-island/water-11.png',
      height: 16,
      interval: 13,
      timeout: 100,
      frame: 4,
      recolor: recolor
    }, {
      autoscroll: 0.000,
      parallax: 0.033,
      url: '/Sonic/backdrop/angel-island/water-12.png',
      height: 8,
      interval: 11,
      timeout: 100,
      frame: 5,
      recolor: recolor
    }, {
      autoscroll: 0.000,
      parallax: 0.035,
      url: '/Sonic/backdrop/angel-island/water-13.png',
      height: 7,
      interval: 15,
      timeout: 100,
      frame: 0,
      recolor: recolor
    }, {
      autoscroll: 0.000,
      parallax: 0.037,
      url: '/Sonic/backdrop/angel-island/water-14.png',
      height: 8,
      interval: 17,
      timeout: 100,
      frame: 1,
      recolor: recolor
    }, {
      autoscroll: 0.000,
      parallax: 0.039,
      url: '/Sonic/backdrop/angel-island/water-15.png',
      height: 8,
      interval: 19,
      timeout: 100,
      frame: 2,
      recolor: recolor
    }, {
      autoscroll: 0.000,
      parallax: 0.041,
      url: '/Sonic/backdrop/angel-island/water-16.png',
      height: 6,
      interval: 11,
      timeout: 100,
      frame: 3,
      recolor: recolor
    }, {
      autoscroll: 0.000,
      parallax: 0.044,
      url: '/Sonic/backdrop/angel-island/water-17.png',
      height: 10,
      interval: 13,
      timeout: 100,
      frame: 4,
      recolor: recolor
    }, {
      autoscroll: 0.000,
      parallax: 0.000,
      url: '/Sonic/backdrop/angel-island/water-18.png',
      height: 32
    }];
    return _this;
  }
  return _createClass(AngelIsland);
}(_Backdrop2.Backdrop);
exports.AngelIsland = AngelIsland;
});

;require.register("backdrop/Backdrop.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Backdrop = void 0;
var _View2 = require("curvature/base/View");
var _Png = require("../sprite/Png");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
const layers = [];
let Backdrop = /*#__PURE__*/function (_View) {
  _inherits(Backdrop, _View);
  var _super = _createSuper(Backdrop);
  function Backdrop() {
    var _this;
    _classCallCheck(this, Backdrop);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _defineProperty(_assertThisInitialized(_this), "template", `<div class = "backdrop [[name]]">
		<div cv-ref = "backdrop" class = "parallax"></div>
	</div>`);
    _defineProperty(_assertThisInitialized(_this), "layers", []);
    _defineProperty(_assertThisInitialized(_this), "urls", []);
    _defineProperty(_assertThisInitialized(_this), "stacked", 0);
    return _this;
  }
  _createClass(Backdrop, [{
    key: "onAttached",
    value: function onAttached(event) {
      if (this.alreadyAttached) {
        return;
      }
      this.alreadyAttached = true;
      const backdrop = this.tags.backdrop;
      const strips = this.args.strips.reverse();
      const yPositions = [];
      const xPositions = [];
      const urls = [];
      let stacked = 0;
      for (const i in strips) {
        const recolors = [];
        const strip = strips[i];
        yPositions.push(`calc(100% - calc(1px * ${stacked}))`);
        let xFormula = `calc(var(--xOffset, 0px) * 1px)`;
        if (strip.parallax) {
          xFormula = `calc(${xFormula} + calc(1px * calc(${strip.parallax} * var(--xPan))))`;
        }
        if (strip.autoscroll) {
          xFormula = `calc(${xFormula} + calc(1px * calc(${strip.autoscroll} * var(--frame) )) )`;
        }
        xPositions.push(xFormula);
        urls.push(strips[i].url);
        stacked += strips[i].height - 1;
        if (strip.recolor) {
          const stripPng = new _Png.Png(strip.url);
          for (const pallete of strip.recolor) {
            recolors.push(stripPng.ready.then(() => stripPng.recolor(pallete).toDataUri()));
          }
          Promise.all(recolors).then(frames => strip.frames = frames);
        }
      }
      this.urls = urls;
      this.stacked = stacked;
      const xPos = xPositions.join(', ');
      const yPos = yPositions.join(', ');
      const url = this.urls.map(u => `url(${u})`).join(', ');
      this.args.xOffset = 0;
      backdrop.style({
        'background-position-y': yPos,
        'background-position-x': xPos,
        'background-repeat': 'repeat-x',
        'background-image': url,
        '--stackHeight': stacked
      });
      this.args.bindTo(['x', 'y', 'xPan', 'yPan', 'bX', 'bY', 'width', 'height', 'right', 'xMax', 'yMax', 'frame', 'stacked', 'top', 'bottom', 'xOffset'], (v, k) => backdrop.style(_defineProperty({}, `--${k}`, v)));
      this.args.bindTo('frame', (v, k) => {
        for (const i in this.args.strips) {
          const strip = this.args.strips[i];
          if (strip.frames) {
            if (strip.timeout-- === 0) {
              strip.timeout = strip.interval;
              strip.frame++;
              if (strip.frame >= strip.frames.length) {
                strip.frame = 0;
              }
              this.urls[i] = strip.frames[strip.frame];
              this.refreshLayers();
            }
          }
        }
      });
    }
  }, {
    key: "refreshLayers",
    value: function refreshLayers() {
      this.tags.backdrop.style({
        'background-image': this.urls.map(u => `url(${u})`).join(', ')
      });
    }
  }]);
  return Backdrop;
}(_View2.View);
exports.Backdrop = Backdrop;
});

;require.register("backdrop/City.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.City = void 0;
var _Backdrop2 = require("./Backdrop");
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let City = /*#__PURE__*/function (_Backdrop) {
  _inherits(City, _Backdrop);
  var _super = _createSuper(City);
  function City(args, parent) {
    var _this;
    _classCallCheck(this, City);
    _this = _super.call(this, args, parent);
    _this.args.name = 'city';
    _this.args.strips = [{
      autoscroll: 0.0,
      parallax: 0.128,
      url: '/bttf2/city/sky.png',
      height: 85
    }, {
      autoscroll: 0.0,
      parallax: 0.096,
      url: '/bttf2/city/sky.png',
      height: 85
    }, {
      autoscroll: 0.0,
      parallax: 0.064,
      url: '/bttf2/city/sky.png',
      height: 85
    }, {
      autoscroll: 0.0,
      parallax: 0.048,
      url: '/bttf2/city/sky.png',
      height: 85
    }, {
      autoscroll: 0.0,
      parallax: 0.032,
      url: '/bttf2/city/sky.png',
      height: 85
    }, {
      autoscroll: 0.0,
      parallax: 0.05,
      url: '/bttf2/city/buildings-bg.png',
      height: 76
    }, {
      autoscroll: 0.0,
      parallax: 0.1,
      url: '/bttf2/city/bushes.png',
      height: 144
    }, {
      autoscroll: 0.0,
      parallax: 0.2,
      url: '/bttf2/city/buildings-fg-recolor.png',
      height: 64
    }];
    return _this;
  }
  return _createClass(City);
}(_Backdrop2.Backdrop);
exports.City = City;
});

;require.register("backdrop/DarkClouds.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DarkClouds = void 0;
var _Backdrop2 = require("./Backdrop");
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let DarkClouds = /*#__PURE__*/function (_Backdrop) {
  _inherits(DarkClouds, _Backdrop);
  var _super = _createSuper(DarkClouds);
  function DarkClouds(args, parent) {
    var _this;
    _classCallCheck(this, DarkClouds);
    _this = _super.call(this, args, parent);
    _this.args.name = 'dark-clouds';
    _this.args.strips = [{
      autoscroll: 0.14,
      parallax: 0.02,
      url: '/Sonic/backdrop/west-side/clouds--1.png',
      height: 64
    }, {
      autoscroll: 0.14,
      parallax: 0.02,
      url: '/Sonic/backdrop/west-side/clouds-0.png',
      height: 33
    }, {
      autoscroll: 0.13,
      parallax: 0.014,
      url: '/Sonic/backdrop/west-side/clouds-1.png',
      height: 32
    }, {
      autoscroll: 0.12,
      parallax: 0.013,
      url: '/Sonic/backdrop/west-side/clouds-2.png',
      height: 24
    }, {
      autoscroll: 0.11,
      parallax: 0.012,
      url: '/Sonic/backdrop/west-side/clouds-3.png',
      height: 16
    }, {
      autoscroll: 0.10,
      parallax: 0.011,
      url: '/Sonic/backdrop/west-side/clouds-4.png',
      height: 5
    }, {
      autoscroll: 0.09,
      parallax: 0.010,
      url: '/Sonic/backdrop/west-side/clouds-5.png',
      height: 3
    }, {
      autoscroll: 0.08,
      parallax: 0.009,
      url: '/Sonic/backdrop/west-side/clouds-6.png',
      height: 8
    }, {
      autoscroll: 0.07,
      parallax: 0.008,
      url: '/Sonic/backdrop/west-side/clouds-7.png',
      height: 5
    }, {
      autoscroll: 0.06,
      parallax: 0.007,
      url: '/Sonic/backdrop/west-side/clouds-8.png',
      height: 3
    }, {
      autoscroll: 0.05,
      parallax: 0.006,
      url: '/Sonic/backdrop/west-side/clouds-9.png',
      height: 8
    }, {
      autoscroll: 0.04,
      parallax: 0.005,
      url: '/Sonic/backdrop/west-side/clouds-10.png',
      height: 8
    }, {
      autoscroll: 0.03,
      parallax: 0.004,
      url: '/Sonic/backdrop/west-side/clouds-11.png',
      height: 32
    }, {
      autoscroll: 0.02,
      parallax: 0.003,
      url: '/Sonic/backdrop/west-side/clouds-12.png',
      height: 8
    }, {
      autoscroll: 0.015,
      parallax: 0.002,
      url: '/Sonic/backdrop/west-side/clouds-13.png',
      height: 32
    }, {
      autoscroll: 0.015,
      parallax: 0.002,
      url: '/Sonic/backdrop/west-side/empty.png',
      height: 120
    }];
    _this.args.bindTo('frame', v => {
      if (_this.args.ligtening) {
        return;
      }
      if (Math.random() > 0.995) {
        _this.args.name = 'dark-clouds lightning';
        _this.args.lightning = true;
        _this.onTimeout(1000, () => {
          _this.args.name = 'dark-clouds';
          _this.args.lightning = false;
        });
      }
    });
    return _this;
  }
  return _createClass(DarkClouds);
}(_Backdrop2.Backdrop);
exports.DarkClouds = DarkClouds;
});

;require.register("backdrop/Desert.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Desert = void 0;
var _Backdrop2 = require("./Backdrop");
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let Desert = /*#__PURE__*/function (_Backdrop) {
  _inherits(Desert, _Backdrop);
  var _super = _createSuper(Desert);
  function Desert(args, parent) {
    var _this;
    _classCallCheck(this, Desert);
    _this = _super.call(this, args, parent);
    _this.args.name = 'desert';
    _this.args.strips = [{
      autoscroll: 0.0,
      parallax: 0.0,
      url: '/Sonic/backdrop/desert-palace/sky.png',
      height: 32
    }, {
      autoscroll: 0.0,
      parallax: 0.0,
      url: '/Sonic/backdrop/desert-palace/sky.png',
      height: 32
    }, {
      autoscroll: 0.0,
      parallax: 0.0,
      url: '/Sonic/backdrop/desert-palace/sky.png',
      height: 32
    }, {
      autoscroll: 0.0,
      parallax: 0.0,
      url: '/Sonic/backdrop/desert-palace/sky.png',
      height: 32
    }, {
      autoscroll: 0.0,
      parallax: 0.3,
      url: '/Sonic/backdrop/desert-palace/dunes.png',
      height: 28
    }, {
      autoscroll: 0.0,
      parallax: 0.4,
      url: '/Sonic/backdrop/desert-palace/dunes-fg.png',
      height: 12
    }, {
      autoscroll: 0.0,
      parallax: 0.0,
      url: '/Sonic/backdrop/desert-palace/sand-color.png',
      height: 8
    }, {
      autoscroll: 0.0,
      parallax: 0.5,
      url: '/Sonic/backdrop/desert-palace/dunes-fg.png',
      height: 12
    }, {
      autoscroll: 0.0,
      parallax: 0.0,
      url: '/Sonic/backdrop/desert-palace/sand-color.png',
      height: 8
    }, {
      autoscroll: 0.0,
      parallax: 0.0,
      url: '/Sonic/backdrop/desert-palace/sand-color.png',
      height: 8
    }, {
      autoscroll: 0.0,
      parallax: 0.0,
      url: '/Sonic/backdrop/desert-palace/sand-color.png',
      height: 8
    }, {
      autoscroll: 0.0,
      parallax: 0.0,
      url: '/Sonic/backdrop/desert-palace/sand-color.png',
      height: 8
    }, {
      autoscroll: 0.0,
      parallax: 0.6,
      url: '/Sonic/backdrop/desert-palace/dunes-fg.png',
      height: 12
    }, {
      autoscroll: 0.0,
      parallax: 0.0,
      url: '/Sonic/backdrop/desert-palace/sand-color.png',
      height: 8
    }, {
      autoscroll: 0.0,
      parallax: 0.0,
      url: '/Sonic/backdrop/desert-palace/sand-color.png',
      height: 8
    }, {
      autoscroll: 0.0,
      parallax: 0.0,
      url: '/Sonic/backdrop/desert-palace/sand-color.png',
      height: 8
    }, {
      autoscroll: 0.0,
      parallax: 0.0,
      url: '/Sonic/backdrop/desert-palace/sand-color.png',
      height: 8
    }, {
      autoscroll: 0.0,
      parallax: 0.0,
      url: '/Sonic/backdrop/desert-palace/sand-color.png',
      height: 8
    }, {
      autoscroll: 0.0,
      parallax: 0.0,
      url: '/Sonic/backdrop/desert-palace/sand-color.png',
      height: 8
    }, {
      autoscroll: 0.0,
      parallax: 0.0,
      url: '/Sonic/backdrop/desert-palace/sand-color.png',
      height: 8
    }, {
      autoscroll: 0.0,
      parallax: 0.0,
      url: '/Sonic/backdrop/desert-palace/sand-color.png',
      height: 8
    }, {
      autoscroll: 0.0,
      parallax: 0.0,
      url: '/Sonic/backdrop/desert-palace/sand-color.png',
      height: 8
    }, {
      autoscroll: 0.0,
      parallax: 0.0,
      url: '/Sonic/backdrop/desert-palace/sand-color.png',
      height: 8
    }, {
      autoscroll: 0.0,
      parallax: 0.0,
      url: '/Sonic/backdrop/desert-palace/sand-color.png',
      height: 8
    }, {
      autoscroll: 0.0,
      parallax: 0.0,
      url: '/Sonic/backdrop/desert-palace/sand-color.png',
      height: 8
    }, {
      autoscroll: 0.0,
      parallax: 0.0,
      url: '/Sonic/backdrop/desert-palace/sand-color.png',
      height: 8
    }, {
      autoscroll: 0.0,
      parallax: 0.0,
      url: '/Sonic/backdrop/desert-palace/sand-color.png',
      height: 8
    }, {
      autoscroll: 0.0,
      parallax: 0.0,
      url: '/Sonic/backdrop/desert-palace/sand-color.png',
      height: 8
    }];
    return _this;
  }
  return _createClass(Desert);
}(_Backdrop2.Backdrop);
exports.Desert = Desert;
});

;require.register("backdrop/IceCap.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.IceCap = void 0;
var _Backdrop2 = require("./Backdrop");
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let IceCap = /*#__PURE__*/function (_Backdrop) {
  _inherits(IceCap, _Backdrop);
  var _super = _createSuper(IceCap);
  function IceCap(args, parent) {
    var _this;
    _classCallCheck(this, IceCap);
    _this = _super.call(this, args, parent);
    _this.args.name = 'ice-cap';
    _this.args.strips = [{
      autoscroll: 0,
      parallax: 0,
      url: '/Sonic/backdrop/ice-cap/mountains-13.png',
      height: 64
    }, {
      autoscroll: 0,
      parallax: 0.01,
      url: '/Sonic/backdrop/ice-cap/mountains-12.png',
      height: 4
    }, {
      autoscroll: 0,
      parallax: 0.02,
      url: '/Sonic/backdrop/ice-cap/mountains-11.png',
      height: 12
    }, {
      autoscroll: 0,
      parallax: 0.025,
      url: '/Sonic/backdrop/ice-cap/mountains-10.png',
      height: 11
    }, {
      autoscroll: 0,
      parallax: 0.03,
      url: '/Sonic/backdrop/ice-cap/mountains-9.png',
      height: 13
    }, {
      autoscroll: 0,
      parallax: 0.03,
      url: '/Sonic/backdrop/ice-cap/mountains-8.png',
      height: 24
    }, {
      autoscroll: 0,
      parallax: 0.045,
      url: '/Sonic/backdrop/ice-cap/mountains-7.png',
      height: 80
    }, {
      autoscroll: 0,
      parallax: 0.05,
      url: '/Sonic/backdrop/ice-cap/mountains-6.png',
      height: 3
    }, {
      autoscroll: 0,
      parallax: 0.06,
      url: '/Sonic/backdrop/ice-cap/mountains-5.png',
      height: 7
    }, {
      autoscroll: 0,
      parallax: 0.07,
      url: '/Sonic/backdrop/ice-cap/mountains-4.png',
      height: 14
    }, {
      autoscroll: 0,
      parallax: 0.08,
      url: '/Sonic/backdrop/ice-cap/mountains-3.png',
      height: 24
    }, {
      autoscroll: 0,
      parallax: 0.09,
      url: '/Sonic/backdrop/ice-cap/mountains-2.png',
      height: 32
    }, {
      autoscroll: 0,
      parallax: 0.9,
      url: '/Sonic/backdrop/ice-cap/mountains-1.png',
      height: 32
    }];
    return _this;
  }
  return _createClass(IceCap);
}(_Backdrop2.Backdrop);
exports.IceCap = IceCap;
});

;require.register("backdrop/Industrial.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Industrial = void 0;
var _Backdrop2 = require("./Backdrop");
var _Tag = require("curvature/base/Tag");
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let Industrial = /*#__PURE__*/function (_Backdrop) {
  _inherits(Industrial, _Backdrop);
  var _super = _createSuper(Industrial);
  function Industrial(args, parent) {
    var _this;
    _classCallCheck(this, Industrial);
    _this = _super.call(this, args, parent);
    _this.args.name = 'industrial';
    _this.args.sunrise = 0;
    _this.args.bindTo('sunrise', v => {
      _this.nodes[1] && _this.nodes[1].style.setProperty('--sunrise', v);
    });
    _this.args.strips = [{
      autoscroll: 0.7,
      parallax: 0.055,
      url: '/Sonic/backdrop/labrynth-industrial/0.png',
      height: 24
    }, {
      autoscroll: 0.65,
      parallax: 0.050,
      url: '/Sonic/backdrop/labrynth-industrial/1.png',
      height: 24
    }, {
      autoscroll: 0.60,
      parallax: 0.045,
      url: '/Sonic/backdrop/labrynth-industrial/0.png',
      height: 24
    }, {
      autoscroll: 0.55,
      parallax: 0.040,
      url: '/Sonic/backdrop/labrynth-industrial/1.png',
      height: 24
    }, {
      autoscroll: 0.50,
      parallax: 0.035,
      url: '/Sonic/backdrop/labrynth-industrial/0.png',
      height: 24
    }, {
      autoscroll: 0.40,
      parallax: 0.030,
      url: '/Sonic/backdrop/labrynth-industrial/1.png',
      height: 24
    }, {
      autoscroll: 0.35,
      parallax: 0.025,
      url: '/Sonic/backdrop/labrynth-industrial/0.png',
      height: 24
    }, {
      autoscroll: 0.30,
      parallax: 0.020,
      url: '/Sonic/backdrop/labrynth-industrial/1.png',
      height: 24
    }, {
      autoscroll: 0.25,
      parallax: 0.015,
      url: '/Sonic/backdrop/labrynth-industrial/2.png',
      height: 24
    }, {
      autoscroll: 0.20,
      parallax: 0.010,
      url: '/Sonic/backdrop/labrynth-industrial/3.png',
      height: 24
    }, {
      autoscroll: 0,
      parallax: 0.02,
      url: '/Sonic/backdrop/labrynth-industrial/4-dist.png',
      height: 70
    }, {
      autoscroll: 0,
      parallax: 0.05,
      url: '/Sonic/backdrop/labrynth-industrial/4.png',
      height: 0
    }, {
      autoscroll: 0,
      parallax: 0.05,
      url: '/Sonic/backdrop/labrynth-industrial/flame-0.png',
      height: 1,
      interval: 1,
      timeout: 0,
      frame: 0,
      frames: ['/Sonic/backdrop/labrynth-industrial/flame-0a.png', '/Sonic/backdrop/labrynth-industrial/flame-1.png', '/Sonic/backdrop/labrynth-industrial/flame-1.png', '/Sonic/backdrop/labrynth-industrial/flame-2.png', '/Sonic/backdrop/labrynth-industrial/flame-0.png', '/Sonic/backdrop/labrynth-industrial/flame-2.png', '/Sonic/backdrop/labrynth-industrial/flame-2.png', '/Sonic/backdrop/labrynth-industrial/flame-2.png', '/Sonic/backdrop/labrynth-industrial/flame-3.png', '/Sonic/backdrop/labrynth-industrial/flame-0.png', '/Sonic/backdrop/labrynth-industrial/flame-3.png', '/Sonic/backdrop/labrynth-industrial/flame-3.png', '/Sonic/backdrop/labrynth-industrial/flame-4.png', '/Sonic/backdrop/labrynth-industrial/flame-0.png', '/Sonic/backdrop/labrynth-industrial/flame-4.png', '/Sonic/backdrop/labrynth-industrial/flame-5.png', '/Sonic/backdrop/labrynth-industrial/flame-6.png', '/Sonic/backdrop/labrynth-industrial/flame-0.png', '/Sonic/backdrop/labrynth-industrial/flame-6.png', '/Sonic/backdrop/labrynth-industrial/flame-6.png', '/Sonic/backdrop/labrynth-industrial/flame-0.png', '/Sonic/backdrop/labrynth-industrial/flame-0.png', '/Sonic/backdrop/labrynth-industrial/flame-0.png', '/Sonic/backdrop/labrynth-industrial/flame-0.png', '/Sonic/backdrop/labrynth-industrial/flame-0.png', '/Sonic/backdrop/labrynth-industrial/flame-0.png', '/Sonic/backdrop/labrynth-industrial/flame-0.png', '/Sonic/backdrop/labrynth-industrial/flame-0.png', '/Sonic/backdrop/labrynth-industrial/flame-0.png', '/Sonic/backdrop/labrynth-industrial/flame-0.png', '/Sonic/backdrop/labrynth-industrial/flame-0.png', '/Sonic/backdrop/labrynth-industrial/flame-0.png', '/Sonic/backdrop/labrynth-industrial/flame-0.png', '/Sonic/backdrop/labrynth-industrial/flame-0.png', '/Sonic/backdrop/labrynth-industrial/flame-0.png', '/Sonic/backdrop/labrynth-industrial/flame-0.png', '/Sonic/backdrop/labrynth-industrial/flame-0.png', '/Sonic/backdrop/labrynth-industrial/flame-0.png']
    }, {
      autoscroll: 0,
      parallax: 0.05,
      url: '/Sonic/backdrop/labrynth-industrial/flame-0.png',
      height: 1,
      interval: 1,
      timeout: 0,
      frame: 0,
      frames: ['/Sonic/backdrop/labrynth-industrial/flame-b-0a.png', '/Sonic/backdrop/labrynth-industrial/flame-b-1.png', '/Sonic/backdrop/labrynth-industrial/flame-b-1.png', '/Sonic/backdrop/labrynth-industrial/flame-b-2.png', '/Sonic/backdrop/labrynth-industrial/flame-b-0.png', '/Sonic/backdrop/labrynth-industrial/flame-b-2.png', '/Sonic/backdrop/labrynth-industrial/flame-b-2.png', '/Sonic/backdrop/labrynth-industrial/flame-b-2.png', '/Sonic/backdrop/labrynth-industrial/flame-b-3.png', '/Sonic/backdrop/labrynth-industrial/flame-b-0.png', '/Sonic/backdrop/labrynth-industrial/flame-b-3.png', '/Sonic/backdrop/labrynth-industrial/flame-b-3.png', '/Sonic/backdrop/labrynth-industrial/flame-b-4.png', '/Sonic/backdrop/labrynth-industrial/flame-b-0.png', '/Sonic/backdrop/labrynth-industrial/flame-b-4.png', '/Sonic/backdrop/labrynth-industrial/flame-b-5.png', '/Sonic/backdrop/labrynth-industrial/flame-b-6.png', '/Sonic/backdrop/labrynth-industrial/flame-b-0.png', '/Sonic/backdrop/labrynth-industrial/flame-b-6.png', '/Sonic/backdrop/labrynth-industrial/flame-b-6.png', '/Sonic/backdrop/labrynth-industrial/flame-b-0.png', '/Sonic/backdrop/labrynth-industrial/flame-b-0.png', '/Sonic/backdrop/labrynth-industrial/flame-b-0.png', '/Sonic/backdrop/labrynth-industrial/flame-b-0.png', '/Sonic/backdrop/labrynth-industrial/flame-b-0.png', '/Sonic/backdrop/labrynth-industrial/flame-b-0.png', '/Sonic/backdrop/labrynth-industrial/flame-b-0.png', '/Sonic/backdrop/labrynth-industrial/flame-b-0.png', '/Sonic/backdrop/labrynth-industrial/flame-b-0.png', '/Sonic/backdrop/labrynth-industrial/flame-b-0.png', '/Sonic/backdrop/labrynth-industrial/flame-b-0.png', '/Sonic/backdrop/labrynth-industrial/flame-b-0.png', '/Sonic/backdrop/labrynth-industrial/flame-b-0.png', '/Sonic/backdrop/labrynth-industrial/flame-b-0.png', '/Sonic/backdrop/labrynth-industrial/flame-b-0.png', '/Sonic/backdrop/labrynth-industrial/flame-b-0.png', '/Sonic/backdrop/labrynth-industrial/flame-b-0.png', '/Sonic/backdrop/labrynth-industrial/flame-b-0.png']
    }, {
      autoscroll: 0,
      parallax: 0.05,
      url: '/Sonic/backdrop/labrynth-industrial/flame-0.png',
      height: 1,
      interval: 1,
      timeout: 0,
      frame: 0,
      frames: ['/Sonic/backdrop/labrynth-industrial/flame-c-0a.png', '/Sonic/backdrop/labrynth-industrial/flame-c-1.png', '/Sonic/backdrop/labrynth-industrial/flame-c-1.png', '/Sonic/backdrop/labrynth-industrial/flame-c-2.png', '/Sonic/backdrop/labrynth-industrial/flame-c-0.png', '/Sonic/backdrop/labrynth-industrial/flame-c-2.png', '/Sonic/backdrop/labrynth-industrial/flame-c-2.png', '/Sonic/backdrop/labrynth-industrial/flame-c-2.png', '/Sonic/backdrop/labrynth-industrial/flame-c-3.png', '/Sonic/backdrop/labrynth-industrial/flame-c-0.png', '/Sonic/backdrop/labrynth-industrial/flame-c-3.png', '/Sonic/backdrop/labrynth-industrial/flame-c-3.png', '/Sonic/backdrop/labrynth-industrial/flame-c-4.png', '/Sonic/backdrop/labrynth-industrial/flame-c-0.png', '/Sonic/backdrop/labrynth-industrial/flame-c-4.png', '/Sonic/backdrop/labrynth-industrial/flame-c-5.png', '/Sonic/backdrop/labrynth-industrial/flame-c-6.png', '/Sonic/backdrop/labrynth-industrial/flame-c-0.png', '/Sonic/backdrop/labrynth-industrial/flame-c-6.png', '/Sonic/backdrop/labrynth-industrial/flame-c-6.png', '/Sonic/backdrop/labrynth-industrial/flame-c-0.png']
    }, {
      autoscroll: 0,
      parallax: 0.125,
      url: '/Sonic/backdrop/labrynth-industrial/5-bw-small.png',
      height: 10
    }, {
      autoscroll: 0,
      parallax: 0.15,
      url: '/Sonic/backdrop/labrynth-industrial/5-bw-small.png',
      height: 10
    }, {
      autoscroll: 0,
      parallax: 0.275,
      url: '/Sonic/backdrop/labrynth-industrial/5-dim.png',
      height: 50
    }, {
      autoscroll: 0,
      parallax: 0.275,
      url: '/Sonic/backdrop/labrynth-industrial/5-pink-lights.png',
      height: 1,
      interval: 20,
      timeout: 0,
      frame: 0,
      frames: ['/Sonic/backdrop/labrynth-industrial/5-lights-0.png', '/Sonic/backdrop/labrynth-industrial/5-lights-0.png', '/Sonic/backdrop/labrynth-industrial/5-lights-1.png', '/Sonic/backdrop/labrynth-industrial/5-lights-1.png', '/Sonic/backdrop/labrynth-industrial/5-lights-2.png', '/Sonic/backdrop/labrynth-industrial/5-lights-2.png']
    }, {
      autoscroll: 0,
      parallax: 0.275,
      url: '/Sonic/backdrop/labrynth-industrial/5-signals-0.png',
      height: 1,
      interval: 10,
      timeout: 0,
      frame: 0,
      frames: ['/Sonic/backdrop/labrynth-industrial/5-signals-0.png', '/Sonic/backdrop/labrynth-industrial/5-signals-1.png', '/Sonic/backdrop/labrynth-industrial/5-signals-1.png', '/Sonic/backdrop/labrynth-industrial/5-signals-1.png', '/Sonic/backdrop/labrynth-industrial/5-signals-1.png', '/Sonic/backdrop/labrynth-industrial/5-signals-0.png', '/Sonic/backdrop/labrynth-industrial/5-signals-2.png', '/Sonic/backdrop/labrynth-industrial/5-signals-2.png', '/Sonic/backdrop/labrynth-industrial/5-signals-2.png', '/Sonic/backdrop/labrynth-industrial/5-signals-2.png']
    }, {
      autoscroll: 0,
      parallax: 0.35,
      url: '/Sonic/backdrop/labrynth-industrial/5.png',
      height: 40
    }, {
      autoscroll: 0,
      parallax: 0.35,
      url: '/Sonic/backdrop/labrynth-industrial/5-pink-lights.png',
      height: 1
      // , interval: 100
      // , timeout:  0
      // , frame:    0
      // , frames:   [
      // 	'/Sonic/backdrop/labrynth-industrial/5-lights-0.png',
      // 	'/Sonic/backdrop/labrynth-industrial/5-lights-1.png'
      // ]
    }, {
      autoscroll: 0,
      parallax: 0.35,
      url: '/Sonic/backdrop/labrynth-industrial/5-signals-0.png',
      height: 1,
      interval: 20,
      timeout: 0,
      frame: 0,
      frames: ['/Sonic/backdrop/labrynth-industrial/5-signals-0.png', '/Sonic/backdrop/labrynth-industrial/5-signals-2.png', '/Sonic/backdrop/labrynth-industrial/5-signals-2.png', '/Sonic/backdrop/labrynth-industrial/5-signals-2.png', '/Sonic/backdrop/labrynth-industrial/5-signals-2.png', '/Sonic/backdrop/labrynth-industrial/5-signals-0.png', '/Sonic/backdrop/labrynth-industrial/5-signals-1.png', '/Sonic/backdrop/labrynth-industrial/5-signals-1.png', '/Sonic/backdrop/labrynth-industrial/5-signals-1.png', '/Sonic/backdrop/labrynth-industrial/5-signals-1.png']
    }, {
      autoscroll: 0,
      parallax: 0.4,
      url: '/Sonic/backdrop/labrynth-industrial/6-half.png',
      height: 88
    }];
    return _this;
  }
  return _createClass(Industrial);
}(_Backdrop2.Backdrop);
exports.Industrial = Industrial;
});

;require.register("backdrop/MarbleGarden.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MarbleGarden = void 0;
var _Backdrop2 = require("./Backdrop");
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let MarbleGarden = /*#__PURE__*/function (_Backdrop) {
  _inherits(MarbleGarden, _Backdrop);
  var _super = _createSuper(MarbleGarden);
  function MarbleGarden(args, parent) {
    var _this;
    _classCallCheck(this, MarbleGarden);
    _this = _super.call(this, args, parent);
    _this.args.name = 'marble-garden';
    _this.args.strips = [{
      autoscroll: -1.25,
      parallax: 0.015,
      url: '/Sonic/backdrop/marble-garden/0.png',
      height: 32
    }, {
      autoscroll: -1,
      parallax: 0.015,
      url: '/Sonic/backdrop/marble-garden/1.png',
      height: 24
    }, {
      autoscroll: -0.9,
      parallax: 0.015,
      url: '/Sonic/backdrop/marble-garden/2.png',
      height: 8
    }, {
      autoscroll: -0.8,
      parallax: 0.015,
      url: '/Sonic/backdrop/marble-garden/3.png',
      height: 24
    }, {
      autoscroll: -0.7,
      parallax: 0.015,
      url: '/Sonic/backdrop/marble-garden/4.png',
      height: 8
    }, {
      autoscroll: -0.6,
      parallax: 0.0125,
      url: '/Sonic/backdrop/marble-garden/5.png',
      height: 24
    }, {
      autoscroll: -0.5,
      parallax: 0.0125,
      url: '/Sonic/backdrop/marble-garden/6.png',
      height: 16
    }, {
      autoscroll: -0.45,
      parallax: 0.0125,
      url: '/Sonic/backdrop/marble-garden/7.png',
      height: 8
    }, {
      autoscroll: -0.45,
      parallax: 0.0125,
      url: '/Sonic/backdrop/marble-garden/8.png',
      height: 16
    }, {
      autoscroll: -0.4,
      parallax: 0.0125,
      url: '/Sonic/backdrop/marble-garden/9.png',
      height: 8
    }, {
      autoscroll: -0.35,
      parallax: 0.0125,
      url: '/Sonic/backdrop/marble-garden/10.png',
      height: 16
    }, {
      autoscroll: -0.3,
      parallax: 0.01,
      url: '/Sonic/backdrop/marble-garden/11.png',
      height: 8
    }, {
      autoscroll: -0.25,
      parallax: 0.0075,
      url: '/Sonic/backdrop/marble-garden/12.png',
      height: 8
    }, {
      autoscroll: -0.2,
      parallax: 0.0075,
      url: '/Sonic/backdrop/marble-garden/13.png',
      height: 8
    }, {
      autoscroll: -0.15,
      parallax: 0.01,
      url: '/Sonic/backdrop/marble-garden/14.png',
      height: 8
    }, {
      autoscroll: -0.1,
      parallax: 0.01,
      url: '/Sonic/backdrop/marble-garden/15.png',
      height: 5
    }, {
      autoscroll: 0,
      parallax: 0.1,
      url: '/Sonic/backdrop/marble-garden/16.png',
      height: 30
    }, {
      autoscroll: 0,
      parallax: 0.125,
      url: '/Sonic/backdrop/marble-garden/17.png',
      height: 12
    }, {
      autoscroll: 0,
      parallax: 0.125,
      url: '/Sonic/backdrop/marble-garden/18.png',
      height: 6
    }, {
      autoscroll: 0,
      parallax: 0.15,
      url: '/Sonic/backdrop/marble-garden/19.png',
      height: 6
    }, {
      autoscroll: 0,
      parallax: 0.175,
      url: '/Sonic/backdrop/marble-garden/20.png',
      height: 8
    }, {
      autoscroll: 0,
      parallax: 0.2,
      url: '/Sonic/backdrop/marble-garden/21.png',
      height: 8
    }, {
      autoscroll: 0,
      parallax: 0.225,
      url: '/Sonic/backdrop/marble-garden/22.png',
      height: 24
    }, {
      autoscroll: 0,
      parallax: 0.25,
      url: '/Sonic/backdrop/marble-garden/23.png',
      height: 344
    }];
    return _this;
  }
  return _createClass(MarbleGarden);
}(_Backdrop2.Backdrop);
exports.MarbleGarden = MarbleGarden;
});

;require.register("backdrop/Moon.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Moon = void 0;
var _Backdrop2 = require("./Backdrop");
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let Moon = /*#__PURE__*/function (_Backdrop) {
  _inherits(Moon, _Backdrop);
  var _super = _createSuper(Moon);
  function Moon(args, parent) {
    var _this;
    _classCallCheck(this, Moon);
    _this = _super.call(this, args, parent);
    _this.args.name = 'moon';
    _this.args.strips = [{
      autoscroll: 0.035,
      parallax: 0.0019,
      url: '/Sonic/backdrop/doomsday/backdrop-inverted-0-0a.png',
      height: 13
    }, {
      autoscroll: 0.03,
      parallax: 0.0016,
      url: '/Sonic/backdrop/doomsday/backdrop-inverted-0-0b.png',
      height: 13
    }, {
      autoscroll: 0.025,
      parallax: 0.0015,
      url: '/Sonic/backdrop/doomsday/backdrop-inverted-0-1.png',
      height: 12
    }, {
      autoscroll: 0.02,
      parallax: 0.0013,
      url: '/Sonic/backdrop/doomsday/backdrop-inverted-0-2.png',
      height: 12
    }, {
      autoscroll: 0.015,
      parallax: 0.0010,
      url: '/Sonic/backdrop/doomsday/backdrop-inverted-0-3.png',
      height: 8
    }, {
      autoscroll: 0.01,
      parallax: 0.0009,
      url: '/Sonic/backdrop/doomsday/backdrop-inverted-0-4.png',
      height: 5
    }, {
      autoscroll: 0.005,
      parallax: 0.0007,
      url: '/Sonic/backdrop/doomsday/backdrop-inverted-0-5.png',
      height: 14
    }, {
      autoscroll: 0.0025,
      parallax: 0.0005,
      url: '/Sonic/backdrop/doomsday/backdrop-inverted-0-6.png',
      height: 140
    }, {
      autoscroll: 0,
      parallax: 0.015,
      url: '/mmpr/moon/terrain-00-00.png',
      height: 0
    }, {
      autoscroll: 0,
      parallax: 0.035,
      url: '/mmpr/moon/terrain-00-01.png',
      height: 2
    }, {
      autoscroll: 0,
      parallax: 0.045,
      url: '/mmpr/moon/terrain-00-02.png',
      height: 3
    }, {
      autoscroll: 0,
      parallax: 0.055,
      url: '/mmpr/moon/terrain-00-03.png',
      height: 4
    }, {
      autoscroll: 0,
      parallax: 0.065,
      url: '/mmpr/moon/terrain-00-04.png',
      height: 4
    }, {
      autoscroll: 0,
      parallax: 0.075,
      url: '/mmpr/moon/terrain-00-05.png',
      height: 10
    }, {
      autoscroll: 0,
      parallax: 0.085,
      url: '/mmpr/moon/terrain-00-06.png',
      height: 5
    }, {
      autoscroll: 0,
      parallax: 0.095,
      url: '/mmpr/moon/terrain-00-07-b.png',
      height: 10
    }, {
      autoscroll: 0,
      parallax: 0.1,
      url: '/mmpr/moon/terrain-00-08.png',
      height: 10
    }, {
      autoscroll: 0,
      parallax: 0.105,
      url: '/mmpr/moon/terrain-00-09.png',
      height: 12
    }, {
      autoscroll: 0,
      parallax: 0.115,
      url: '/mmpr/moon/terrain-00-10-b.png',
      height: 12
    }, {
      autoscroll: 0,
      parallax: 0.125,
      url: '/mmpr/moon/terrain-00-11.png',
      height: 5
    }, {
      autoscroll: 0,
      parallax: 0.1325,
      url: '/mmpr/moon/terrain-00-09-b.png',
      height: 12
    }
    // , {
    // 	autoscroll:  0
    // 	, parallax:  0.145
    // 	, url:       '/mmpr/moon/terrain-00-10.png'
    // 	, height:    12
    // }
    , {
      autoscroll: 0,
      parallax: 0.1435,
      url: '/mmpr/moon/terrain-00-12.png',
      height: 22
    }];
    return _this;
  }
  return _createClass(Moon);
}(_Backdrop2.Backdrop);
exports.Moon = Moon;
});

;require.register("backdrop/MushroomHill.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MushroomHill = void 0;
var _Backdrop2 = require("./Backdrop");
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let MushroomHill = /*#__PURE__*/function (_Backdrop) {
  _inherits(MushroomHill, _Backdrop);
  var _super = _createSuper(MushroomHill);
  function MushroomHill(args, parent) {
    var _this;
    _classCallCheck(this, MushroomHill);
    _this = _super.call(this, args, parent);
    _this.args.name = 'mushroom-hill-summer';
    _this.args.strips = [{
      autoscroll: 0,
      parallax: 0,
      url: '/Sonic/backdrop/mushroom-hill/blank.png',
      height: 320 + 12
    }, {
      autoscroll: 0,
      parallax: 0.05,
      url: '/Sonic/backdrop/marble-garden-1/hills-recolored_1.png',
      height: 8
    }, {
      autoscroll: 0,
      parallax: 0.06,
      url: '/Sonic/backdrop/marble-garden-1/hills-recolored_2.png',
      height: 8
    }, {
      autoscroll: 0,
      parallax: 0.07,
      url: '/Sonic/backdrop/marble-garden-1/hills-recolored_3.png',
      height: 8
    }, {
      autoscroll: 0,
      parallax: 0.08,
      url: '/Sonic/backdrop/marble-garden-1/hills-recolored_4.png',
      height: 24
    }, {
      autoscroll: 0,
      parallax: 0.09,
      url: '/Sonic/backdrop/marble-garden-1/hills-recolored_5.png',
      height: 120
    }
    // , {
    // 	autoscroll: 0
    // 	, parallax: 0.10
    // 	, url:      '/Sonic/backdrop/mushroom-hill/background-hills-summer.png'
    // 	, height:   10 + -32
    // }
    , {
      autoscroll: 0,
      parallax: 0.11,
      url: '/Sonic/backdrop/mushroom-hill/background-trees-summer-edit.png',
      height: 0
    }, {
      autoscroll: 0,
      parallax: 0.165,
      url: '/Sonic/backdrop/mushroom-hill/foreground-summer.png',
      height: 224
    }];
    return _this;
  }
  return _createClass(MushroomHill);
}(_Backdrop2.Backdrop);
exports.MushroomHill = MushroomHill;
});

;require.register("backdrop/MysticCave.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MysticCave = void 0;
var _Backdrop2 = require("./Backdrop");
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let MysticCave = /*#__PURE__*/function (_Backdrop) {
  _inherits(MysticCave, _Backdrop);
  var _super = _createSuper(MysticCave);
  function MysticCave(args, parent) {
    var _this;
    _classCallCheck(this, MysticCave);
    _this = _super.call(this, args, parent);
    _this.args.name = 'mystic-cave';
    _this.args.strips = [{
      autoscroll: 0,
      parallax: 0.27,
      url: '/Sonic/backdrop/mystic-cave/1.png',
      height: 37
    }, {
      autoscroll: 0,
      parallax: 0.23,
      url: '/Sonic/backdrop/mystic-cave/2.png',
      height: 23
    }, {
      autoscroll: 0,
      parallax: 0.21,
      url: '/Sonic/backdrop/mystic-cave/3.png',
      height: 18
    }, {
      autoscroll: 0,
      parallax: 0.20,
      url: '/Sonic/backdrop/mystic-cave/4.png',
      height: 7
    }, {
      autoscroll: 0,
      parallax: 0.19,
      url: '/Sonic/backdrop/mystic-cave/5.png',
      height: 6
    }, {
      autoscroll: 0,
      parallax: 0.18,
      url: '/Sonic/backdrop/mystic-cave/6.png',
      height: 1
    }, {
      autoscroll: 0,
      parallax: 0.17,
      url: '/Sonic/backdrop/mystic-cave/7.png',
      height: 1
    }, {
      autoscroll: 0,
      parallax: 0.16,
      url: '/Sonic/backdrop/mystic-cave/8.png',
      height: 1
    }, {
      autoscroll: 0,
      parallax: 0.15,
      url: '/Sonic/backdrop/mystic-cave/9.png',
      height: 1
    }, {
      autoscroll: 0,
      parallax: 0.14,
      url: '/Sonic/backdrop/mystic-cave/10.png',
      height: 1
    }, {
      autoscroll: 0,
      parallax: 0.13,
      url: '/Sonic/backdrop/mystic-cave/11.png',
      height: 48
    }, {
      autoscroll: 0,
      parallax: 0.14,
      url: '/Sonic/backdrop/mystic-cave/12.png',
      height: 13
    }, {
      autoscroll: 0,
      parallax: 0.15,
      url: '/Sonic/backdrop/mystic-cave/13.png',
      height: 19
    }, {
      autoscroll: 0,
      parallax: 0.17,
      url: '/Sonic/backdrop/mystic-cave/14.png',
      height: 34
    }, {
      autoscroll: 0,
      parallax: 0.20,
      url: '/Sonic/backdrop/mystic-cave/15.png',
      height: 62
    }, {
      autoscroll: 0,
      parallax: 0.17,
      url: '/Sonic/backdrop/mystic-cave/16.png',
      height: 32
    }, {
      autoscroll: 0,
      parallax: 0.14,
      url: '/Sonic/backdrop/mystic-cave/16.5.png',
      height: 19
    }, {
      autoscroll: 0,
      parallax: 0.13,
      url: '/Sonic/backdrop/mystic-cave/17.png',
      height: 13
    }, {
      autoscroll: 0,
      parallax: 0.12,
      url: '/Sonic/backdrop/mystic-cave/18.png',
      height: 48
    }, {
      autoscroll: 0,
      parallax: 0.13,
      url: '/Sonic/backdrop/mystic-cave/19.png',
      height: 1
    }, {
      autoscroll: 0,
      parallax: 0.14,
      url: '/Sonic/backdrop/mystic-cave/20.png',
      height: 1
    }, {
      autoscroll: 0,
      parallax: 0.16,
      url: '/Sonic/backdrop/mystic-cave/21.png',
      height: 1
    }, {
      autoscroll: 0,
      parallax: 0.18,
      url: '/Sonic/backdrop/mystic-cave/22.png',
      height: 1
    }, {
      autoscroll: 0,
      parallax: 0.20,
      url: '/Sonic/backdrop/mystic-cave/23.png',
      height: 1
    }, {
      autoscroll: 0,
      parallax: 0.22,
      url: '/Sonic/backdrop/mystic-cave/24.png',
      height: 6
    }, {
      autoscroll: 0,
      parallax: 0.24,
      url: '/Sonic/backdrop/mystic-cave/25.png',
      height: 7
    }, {
      autoscroll: 0,
      parallax: 0.28,
      url: '/Sonic/backdrop/mystic-cave/26.png',
      height: 32
    }, {
      autoscroll: 0,
      parallax: 0.33,
      url: '/Sonic/backdrop/mystic-cave/27.png',
      height: 18
    }, {
      autoscroll: 0,
      parallax: 0.35,
      url: '/Sonic/backdrop/mystic-cave/28.png',
      height: 23
    }, {
      autoscroll: 0,
      parallax: 0.37,
      url: '/Sonic/backdrop/mystic-cave/29.png',
      height: 37
    }];
    return _this;
  }
  return _createClass(MysticCave);
}(_Backdrop2.Backdrop);
exports.MysticCave = MysticCave;
});

;require.register("backdrop/Overcast.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Overcast = void 0;
var _Backdrop2 = require("./Backdrop");
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let Overcast = /*#__PURE__*/function (_Backdrop) {
  _inherits(Overcast, _Backdrop);
  var _super = _createSuper(Overcast);
  function Overcast(args, parent) {
    var _this;
    _classCallCheck(this, Overcast);
    _this = _super.call(this, args, parent);
    _this.args.name = 'overcast';
    _this.args.strips = [{
      autoscroll: 0.14,
      parallax: 0.06,
      url: '/Sonic/backdrop/stardust-speedway/sky-0.png',
      height: 32
    }, {
      autoscroll: 0.13,
      parallax: 0.055,
      url: '/Sonic/backdrop/stardust-speedway/sky-1.png',
      height: 32
    }, {
      autoscroll: 0.12,
      parallax: 0.05,
      url: '/Sonic/backdrop/stardust-speedway/sky-2.png',
      height: 16
    }, {
      autoscroll: 0.11,
      parallax: 0.045,
      url: '/Sonic/backdrop/stardust-speedway/sky-3.png',
      height: 16
    }, {
      autoscroll: 0.10,
      parallax: 0.05,
      url: '/Sonic/backdrop/stardust-speedway/sky-4.png',
      height: 16
    }, {
      autoscroll: 0.09,
      parallax: 0.05,
      url: '/Sonic/backdrop/stardust-speedway/sky-5.png',
      height: 32
    }, {
      autoscroll: 0.08,
      parallax: 0.04,
      url: '/Sonic/backdrop/stardust-speedway/sky-6.png',
      height: 32
    }, {
      autoscroll: 0.07,
      parallax: 0.03,
      url: '/Sonic/backdrop/stardust-speedway/sky-7.png',
      height: 16
    }, {
      autoscroll: 0.06,
      parallax: 0.02,
      url: '/Sonic/backdrop/stardust-speedway/sky-8.png',
      height: 32
    }, {
      autoscroll: 0.05,
      parallax: 0.01,
      url: '/Sonic/backdrop/stardust-speedway/sky-9.png',
      height: 16
    }, {
      autoscroll: 0.04,
      parallax: 0.005,
      url: '/Sonic/backdrop/stardust-speedway/sky-10.png',
      height: 16
    }, {
      autoscroll: 0.03,
      parallax: 0.004,
      url: '/Sonic/backdrop/stardust-speedway/sky-11.png',
      height: 16
    }, {
      autoscroll: 0.02,
      parallax: 0.003,
      url: '/Sonic/backdrop/stardust-speedway/sky-12.png',
      height: 16
    }, {
      autoscroll: 0.015,
      parallax: 0.002,
      url: '/Sonic/backdrop/stardust-speedway/sky-13.png',
      height: 8
    }, {
      autoscroll: 0.015,
      parallax: 0.002,
      url: '/Sonic/backdrop/stardust-speedway/sky-14.png',
      height: 51
    }, {
      autoscroll: 0.015,
      parallax: 0.002,
      url: '/Sonic/backdrop/west-side/empty.png',
      height: 51
    }];

    // this.args.bindTo('frame', v => {

    // 	if(this.args.ligtening)
    // 	{
    // 		return;
    // 	}

    // 	if(Math.random() > 0.995)
    // 	{
    // 		this.args.name = 'dark-clouds lightning';
    // 		this.args.lightning = true;

    // 		this.onTimeout(1000, () => {
    // 			this.args.name = 'dark-clouds';
    // 			this.args.lightning = false;
    // 		});
    // 	}

    // });
    return _this;
  }
  return _createClass(Overcast);
}(_Backdrop2.Backdrop);
exports.Overcast = Overcast;
});

;require.register("backdrop/PhazonMines.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PhazonMines = void 0;
var _Backdrop2 = require("./Backdrop");
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let PhazonMines = /*#__PURE__*/function (_Backdrop) {
  _inherits(PhazonMines, _Backdrop);
  var _super = _createSuper(PhazonMines);
  function PhazonMines(args, parent) {
    var _this;
    _classCallCheck(this, PhazonMines);
    _this = _super.call(this, args, parent);
    _this.args.name = 'scrap-brain';
    _this.args.strips = [{
      autoscroll: 0.0,
      parallax: 0.1,
      url: '/Sonic/backdrop/tidal-tempest/phazon-mines.png',
      height: 512
    }];
    return _this;
  }
  return _createClass(PhazonMines);
}(_Backdrop2.Backdrop);
exports.PhazonMines = PhazonMines;
});

;require.register("backdrop/ProtoLabrynth.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ProtoLabrynth = void 0;
var _Backdrop2 = require("./Backdrop");
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let ProtoLabrynth = /*#__PURE__*/function (_Backdrop) {
  _inherits(ProtoLabrynth, _Backdrop);
  var _super = _createSuper(ProtoLabrynth);
  function ProtoLabrynth(args, parent) {
    var _this;
    _classCallCheck(this, ProtoLabrynth);
    _this = _super.call(this, args, parent);
    _this.args.name = 'proto-labrynth';
    _this.args.strips = [{
      autoscroll: 0,
      parallax: 0.15,
      url: '/Sonic/backdrop/protolabrynth/0.png',
      height: 48
    }, {
      autoscroll: 0,
      parallax: 0.125,
      url: '/Sonic/backdrop/protolabrynth/1.png',
      height: 24
    }, {
      autoscroll: 0,
      parallax: 0.1,
      url: '/Sonic/backdrop/protolabrynth/2.png',
      height: 8
    }, {
      autoscroll: 0,
      parallax: 0.075,
      url: '/Sonic/backdrop/protolabrynth/3.png',
      height: 68
    }, {
      autoscroll: 0,
      parallax: 0.1,
      url: '/Sonic/backdrop/protolabrynth/4.png',
      height: 18
    }, {
      autoscroll: 0,
      parallax: 0.125,
      url: '/Sonic/backdrop/protolabrynth/5.png',
      height: 27
    }, {
      autoscroll: 0,
      parallax: 0.15,
      url: '/Sonic/backdrop/protolabrynth/5.png',
      height: 27
    }, {
      autoscroll: 0,
      parallax: 0.175,
      url: '/Sonic/backdrop/protolabrynth/6.png',
      height: 76
    }];
    return _this;
  }
  return _createClass(ProtoLabrynth);
}(_Backdrop2.Backdrop);
exports.ProtoLabrynth = ProtoLabrynth;
});

;require.register("backdrop/ScrapBrainDark.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ScrapBrainDark = void 0;
var _Backdrop2 = require("./Backdrop");
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let ScrapBrainDark = /*#__PURE__*/function (_Backdrop) {
  _inherits(ScrapBrainDark, _Backdrop);
  var _super = _createSuper(ScrapBrainDark);
  function ScrapBrainDark(args, parent) {
    var _this;
    _classCallCheck(this, ScrapBrainDark);
    _this = _super.call(this, args, parent);
    _this.args.name = 'scrap-brain';
    _this.args.strips = [{
      autoscroll: 0.0,
      parallax: 0.1,
      url: '/Sonic/backdrop/scrap-brain/indoors-dark.png',
      height: 1024
    }];
    return _this;
  }
  return _createClass(ScrapBrainDark);
}(_Backdrop2.Backdrop);
exports.ScrapBrainDark = ScrapBrainDark;
});

;require.register("backdrop/SouthRidge.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SouthRidge = void 0;
var _Backdrop2 = require("./Backdrop");
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let SouthRidge = /*#__PURE__*/function (_Backdrop) {
  _inherits(SouthRidge, _Backdrop);
  var _super = _createSuper(SouthRidge);
  function SouthRidge(args, parent) {
    var _this;
    _classCallCheck(this, SouthRidge);
    _this = _super.call(this, args, parent);
    _this.args.name = 'south-ridge';
    _this.args.strips = [{
      autoscroll: -0.03,
      parallax: 0.11,
      url: '/Sonic/backdrop/south-ridge/clouds-10.png',
      height: 10
    }, {
      autoscroll: 0,
      parallax: 0.1,
      url: '/Sonic/backdrop/south-ridge/ridge.png',
      height: 10
    }, {
      autoscroll: -0.06,
      parallax: 0.12,
      url: '/Sonic/backdrop/south-ridge/clouds-9.png',
      height: 0
    }, {
      autoscroll: -0.06,
      parallax: 0.12,
      url: '/Sonic/backdrop/south-ridge/clouds-9b.png',
      height: 8
    }, {
      autoscroll: -0.065,
      parallax: 0.13,
      url: '/Sonic/backdrop/south-ridge/clouds-8.png',
      height: 11
    }, {
      autoscroll: 0,
      parallax: 0.11,
      url: '/Sonic/backdrop/south-ridge/ridge-b.png',
      height: 20
    }, {
      autoscroll: -0.07,
      parallax: 0.14,
      url: '/Sonic/backdrop/south-ridge/clouds-7.png',
      height: 11 - 20
    }, {
      autoscroll: -0.075,
      parallax: 0.15,
      url: '/Sonic/backdrop/south-ridge/clouds-6.png',
      height: 9
    }, {
      autoscroll: -0.08,
      parallax: 0.16,
      url: '/Sonic/backdrop/south-ridge/clouds-5.png',
      height: 8
    }, {
      autoscroll: -0.09,
      parallax: 0.18,
      url: '/Sonic/backdrop/south-ridge/clouds-4.png',
      height: 16
    }, {
      autoscroll: -0.1,
      parallax: 0.20,
      url: '/Sonic/backdrop/south-ridge/clouds-3.png',
      height: 13
    }, {
      autoscroll: -0.1125,
      parallax: 0.22,
      url: '/Sonic/backdrop/south-ridge/clouds-2.png',
      height: 17
    }, {
      autoscroll: -0.15,
      parallax: 0.21,
      url: '/Sonic/backdrop/south-ridge/clouds-1.png',
      height: 15
    }, {
      autoscroll: -0.175,
      parallax: 0.21,
      url: '/Sonic/backdrop/south-ridge/clouds-0.png',
      height: 16
    }, {
      autoscroll: -0.15,
      parallax: 0.22,
      url: '/Sonic/backdrop/south-ridge/clouds-1.png',
      height: 15
    }, {
      autoscroll: -0.175,
      parallax: 0.23,
      url: '/Sonic/backdrop/south-ridge/clouds-0.png',
      height: 16
    }];
    return _this;
  }
  return _createClass(SouthRidge);
}(_Backdrop2.Backdrop);
exports.SouthRidge = SouthRidge;
});

;require.register("backdrop/Underground.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Underground = void 0;
var _Backdrop2 = require("./Backdrop");
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let Underground = /*#__PURE__*/function (_Backdrop) {
  _inherits(Underground, _Backdrop);
  var _super = _createSuper(Underground);
  function Underground(args, parent) {
    var _this;
    _classCallCheck(this, Underground);
    _this = _super.call(this, args, parent);
    _this.args.name = 'underground';
    _this.args.strips = [{
      autoscroll: 0.045,
      parallax: 0.075,
      url: '/Sonic/backdrop/wing-fortress/sky-1b-recolor.png',
      height: 32
    }, {
      autoscroll: 0.043,
      parallax: 0.070,
      url: '/Sonic/backdrop/wing-fortress/sky-0-recolor.png',
      height: 48
    }, {
      autoscroll: 0.041,
      parallax: 0.065,
      url: '/Sonic/backdrop/wing-fortress/sky-1-recolor.png',
      height: 32
    }, {
      autoscroll: 0.039,
      parallax: 0.060,
      url: '/Sonic/backdrop/wing-fortress/sky-2-recolor.png',
      height: 48
    }, {
      autoscroll: 0,
      parallax: 0.075,
      url: '/Sonic/backdrop/aquatic-ruin/mountains-0-recolor.png',
      height: 0
    }, {
      autoscroll: 0,
      parallax: 0,
      url: '/Sonic/backdrop/aquatic-ruin/mountains-1-recolor.png',
      height: 48
    }, {
      autoscroll: 0,
      parallax: 0,
      url: '/Sonic/backdrop/aquatic-ruin/mountains-1-recolor.png',
      height: 48
    }, {
      autoscroll: 0,
      parallax: 0,
      url: '/Sonic/backdrop/aquatic-ruin/mountains-1-recolor.png',
      height: 24
    }];
    return _this;
  }
  return _createClass(Underground);
}(_Backdrop2.Backdrop);
exports.Underground = Underground;
});

;require.register("backdrop/WestSide.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WestSide = void 0;
var _Backdrop2 = require("./Backdrop");
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let WestSide = /*#__PURE__*/function (_Backdrop) {
  _inherits(WestSide, _Backdrop);
  var _super = _createSuper(WestSide);
  function WestSide(args, parent) {
    var _this;
    _classCallCheck(this, WestSide);
    _this = _super.call(this, args, parent);
    _this.args.name = 'west-side';
    _this.args.strips = [{
      autoscroll: 0.001,
      parallax: 0.001,
      url: '/Sonic/backdrop/west-side/stars-before.png',
      height: 64
    }, {
      autoscroll: 0.001,
      parallax: 0.001,
      url: '/Sonic/backdrop/west-side/stars.png',
      height: 205
    }, {
      autoscroll: 0,
      parallax: 0.0005,
      url: '/Sonic/backdrop/west-side/island-dark.png',
      height: 0
    }, {
      autoscroll: 0,
      parallax: 0.0005,
      url: '/Sonic/backdrop/west-side/water-shine-0.png',
      height: 3
    }, {
      autoscroll: 0,
      parallax: 0.0005,
      url: '/Sonic/backdrop/west-side/water-shine-1.png',
      height: 3
    }
    // , {
    // 	autoscroll: 0
    // 	, parallax: 0.0004
    // 	, url:      '/Sonic/backdrop/west-side/water-shine-2.png'
    // 	, height:   3
    // }
    , {
      autoscroll: 0,
      parallax: 0.004,
      url: '/Sonic/backdrop/west-side/water-night.png',
      height: 144
    }, {
      autoscroll: 0.001,
      parallax: 0.001,
      url: '/Sonic/backdrop/west-side/stars-reflected.png',
      height: 0
    }, {
      autoscroll: 0,
      parallax: 0.0005,
      url: '/Sonic/backdrop/west-side/island-dark-reflected.png',
      height: 0
    }, {
      autoscroll: 0,
      parallax: 0.03,
      url: '/Sonic/backdrop/launch-base/bushes-0-night.png',
      height: 0
    }, {
      autoscroll: 0,
      parallax: 0.05,
      url: '/Sonic/backdrop/launch-base/bushes-1-night.png',
      height: 0
    }, {
      autoscroll: 0,
      parallax: 0.05,
      url: '/Sonic/backdrop/launch-base/bushes-2-night.png',
      height: 48
    }, {
      autoscroll: 0,
      parallax: 0.05,
      url: '/Sonic/backdrop/launch-base/bushes-3-night.png',
      height: 128
    }];
    return _this;
  }
  return _createClass(WestSide);
}(_Backdrop2.Backdrop);
exports.WestSide = WestSide;
});

;require.register("backdrop/WestSideCloudy.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WestSideCloudy = void 0;
var _Backdrop2 = require("./Backdrop");
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let WestSideCloudy = /*#__PURE__*/function (_Backdrop) {
  _inherits(WestSideCloudy, _Backdrop);
  var _super = _createSuper(WestSideCloudy);
  function WestSideCloudy(args, parent) {
    var _this;
    _classCallCheck(this, WestSideCloudy);
    _this = _super.call(this, args, parent);
    _this.args.name = 'west-side-cloudy';
    _this.args.strips = [{
      autoscroll: 0.14,
      parallax: 0.02,
      url: '/Sonic/backdrop/west-side/clouds--1.png',
      height: 64
    }, {
      autoscroll: 0.14,
      parallax: 0.02,
      url: '/Sonic/backdrop/west-side/clouds-0.png',
      height: 33
    }, {
      autoscroll: 0.13,
      parallax: 0.014,
      url: '/Sonic/backdrop/west-side/clouds-1.png',
      height: 32
    }, {
      autoscroll: 0.12,
      parallax: 0.013,
      url: '/Sonic/backdrop/west-side/clouds-2.png',
      height: 24
    }, {
      autoscroll: 0.11,
      parallax: 0.012,
      url: '/Sonic/backdrop/west-side/clouds-3.png',
      height: 16
    }, {
      autoscroll: 0.10,
      parallax: 0.011,
      url: '/Sonic/backdrop/west-side/clouds-4.png',
      height: 5
    }, {
      autoscroll: 0.09,
      parallax: 0.010,
      url: '/Sonic/backdrop/west-side/clouds-5.png',
      height: 3
    }, {
      autoscroll: 0.08,
      parallax: 0.009,
      url: '/Sonic/backdrop/west-side/clouds-6.png',
      height: 8
    }, {
      autoscroll: 0.07,
      parallax: 0.008,
      url: '/Sonic/backdrop/west-side/clouds-7.png',
      height: 5
    }, {
      autoscroll: 0.06,
      parallax: 0.007,
      url: '/Sonic/backdrop/west-side/clouds-8.png',
      height: 3
    }, {
      autoscroll: 0.05,
      parallax: 0.006,
      url: '/Sonic/backdrop/west-side/clouds-9.png',
      height: 8
    }, {
      autoscroll: 0.04,
      parallax: 0.005,
      url: '/Sonic/backdrop/west-side/clouds-10.png',
      height: 8
    }, {
      autoscroll: 0.03,
      parallax: 0.004,
      url: '/Sonic/backdrop/west-side/clouds-11.png',
      height: 32
    }, {
      autoscroll: 0.02,
      parallax: 0.003,
      url: '/Sonic/backdrop/west-side/clouds-12.png',
      height: 8
    }, {
      autoscroll: 0.015,
      parallax: 0.002,
      url: '/Sonic/backdrop/west-side/clouds-13.png',
      height: 32
    }, {
      autoscroll: 0,
      parallax: 0.0005,
      url: '/Sonic/backdrop/west-side/water-shine-cloudy.png',
      height: 2
    }, {
      autoscroll: 0,
      parallax: 0.0005,
      url: '/Sonic/backdrop/west-side/island-dark-cloudy.png',
      height: 0
    }, {
      autoscroll: 0.015,
      parallax: 0.002,
      url: '/Sonic/backdrop/west-side/reflected-clouds-0.png',
      height: 32
    }, {
      autoscroll: 0.02,
      parallax: 0.003,
      url: '/Sonic/backdrop/west-side/reflected-clouds-1.png',
      height: 8
    }, {
      autoscroll: 0.03,
      parallax: 0.004,
      url: '/Sonic/backdrop/west-side/reflected-clouds-2.png',
      height: 32
    }, {
      autoscroll: 0.04,
      parallax: 0.005,
      url: '/Sonic/backdrop/west-side/reflected-clouds-3.png',
      height: 8
    }, {
      autoscroll: 0.05,
      parallax: 0.006,
      url: '/Sonic/backdrop/west-side/reflected-clouds-4.png',
      height: 8
    }, {
      autoscroll: 0.06,
      parallax: 0.007,
      url: '/Sonic/backdrop/west-side/reflected-clouds-5.png',
      height: 3
    }, {
      autoscroll: 0.07,
      parallax: 0.008,
      url: '/Sonic/backdrop/west-side/reflected-clouds-6.png',
      height: 5
    }, {
      autoscroll: 0.08,
      parallax: 0.009,
      url: '/Sonic/backdrop/west-side/reflected-clouds-7.png',
      height: 16
    }, {
      autoscroll: 0.09,
      parallax: 0.010,
      url: '/Sonic/backdrop/west-side/reflected-clouds-8.png',
      height: 24
    }, {
      autoscroll: 0.1,
      parallax: 0.011,
      url: '/Sonic/backdrop/west-side/reflected-clouds-9.png',
      height: 20
    }, {
      autoscroll: 0,
      parallax: 0.0005,
      url: '/Sonic/backdrop/west-side/island-dark-cloudy-reflected.png',
      height: 0
    }, {
      autoscroll: 0,
      parallax: 0.004,
      url: '/Sonic/backdrop/west-side/water-cloudy.png',
      height: 46
    }, {
      autoscroll: 0,
      parallax: 0.000,
      url: '/Sonic/backdrop/west-side/water-cloudy-after.png',
      height: 128
    }];
    _this.args.bindTo('frame', v => {
      if (_this.args.ligtening) {
        return;
      }
      if (Math.random() > 0.995) {
        _this.args.name = 'west-side-cloudy lightning';
        _this.args.lightning = true;
        _this.onTimeout(1000, () => {
          _this.args.name = 'west-side-cloudy';
          _this.args.lightning = false;
        });
      }
    });
    return _this;
  }
  return _createClass(WestSideCloudy);
}(_Backdrop2.Backdrop);
exports.WestSideCloudy = WestSideCloudy;
});

;require.register("backdrop/WestSideDay.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WestSideDay = void 0;
var _Backdrop2 = require("./Backdrop");
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
// d6ffe0
// fffee0

const recolor = [, {
  'e0e0e5': 'afafc1'
}, {
  'e0e0e5': 'afafc1'
}, {
  'e0e0e5': 'afafc1'
}, {
  'e0e0e5': 'afafc1'
}, {
  'e0e0e5': 'afafc1'
}, {
  'e0e0e5': 'e0e0e5'
}, {
  'e0e0e5': 'afafc1'
}, {
  'e0e0e5': 'e0e0e5'
}, {
  'e0e0e5': 'e0e0e5'
}];
let WestSideDay = /*#__PURE__*/function (_Backdrop) {
  _inherits(WestSideDay, _Backdrop);
  var _super = _createSuper(WestSideDay);
  function WestSideDay(args, parent) {
    var _this;
    _classCallCheck(this, WestSideDay);
    _this = _super.call(this, args, parent);
    _this.args.name = 'west-side-day';
    _this.args.strips = [{
      autoscroll: 0.001,
      parallax: 0.001,
      url: '/Sonic/backdrop/west-side/empty.png',
      height: 64
    }, {
      autoscroll: 0.001,
      parallax: 0.001,
      url: '/Sonic/backdrop/west-side/empty.png',
      height: 205
    }, {
      autoscroll: 0,
      parallax: 0.0005,
      url: '/Sonic/backdrop/west-side/island-day.png',
      height: 0
    }, {
      autoscroll: 0,
      parallax: 0.0005,
      url: '/Sonic/backdrop/west-side/water-shine-0.png',
      height: 3
    }, {
      autoscroll: 0,
      parallax: 0.0005,
      url: '/Sonic/backdrop/west-side/water-shine-1.png',
      height: 3
    }
    // , {
    // 	autoscroll: 0
    // 	, parallax: 0.0004
    // 	, url:      '/Sonic/backdrop/west-side/water-shine-2.png'
    // 	, height:   3
    // }
    , {
      autoscroll: 0,
      parallax: 0.004,
      url: '/Sonic/backdrop/west-side/water.png',
      height: 144
    }, {
      autoscroll: 0,
      parallax: 0,
      url: '/Sonic/backdrop/west-side/empty.png',
      height: 0
    }, {
      autoscroll: 0,
      parallax: 0.0005,
      url: '/Sonic/backdrop/west-side/island-day-reflected.png',
      height: 0
    }, {
      autoscroll: 0,
      parallax: 0.0005,
      url: '/Sonic/backdrop/west-side/island-shine.png',
      height: 1,
      interval: 26,
      timeout: 100,
      frame: 0,
      recolor: recolor
    }, {
      autoscroll: 0,
      parallax: 0.03,
      url: '/Sonic/backdrop/launch-base/bushes-0.png',
      height: 0
    }, {
      autoscroll: 0,
      parallax: 0.05,
      url: '/Sonic/backdrop/launch-base/bushes-1.png',
      height: 0
    }, {
      autoscroll: 0,
      parallax: 0.05,
      url: '/Sonic/backdrop/launch-base/bushes-2.png',
      height: 48
    }, {
      autoscroll: 0,
      parallax: 0.05,
      url: '/Sonic/backdrop/launch-base/bushes-3.png',
      height: 128
    }];
    return _this;
  }
  return _createClass(WestSideDay);
}(_Backdrop2.Backdrop);
exports.WestSideDay = WestSideDay;
});

;require.register("backdrop/WestSideNight.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WestSideNight = void 0;
var _Backdrop2 = require("./Backdrop");
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let WestSideNight = /*#__PURE__*/function (_Backdrop) {
  _inherits(WestSideNight, _Backdrop);
  var _super = _createSuper(WestSideNight);
  function WestSideNight(args, parent) {
    var _this;
    _classCallCheck(this, WestSideNight);
    _this = _super.call(this, args, parent);
    _this.args.name = 'west-side';
    _this.args.strips = [{
      autoscroll: 0,
      parallax: 0.001,
      url: '/Sonic/backdrop/west-side/stars.png',
      height: 0
    }, {
      autoscroll: 0,
      parallax: 0.0005,
      url: '/Sonic/backdrop/west-side/island-dark.png',
      height: 0
    }, {
      autoscroll: 0,
      parallax: 0.0005,
      url: '/Sonic/backdrop/west-side/water-shine-0.png',
      height: 3
    }, {
      autoscroll: 0,
      parallax: 0.0005,
      url: '/Sonic/backdrop/west-side/water-shine-1.png',
      height: 3
    }, {
      autoscroll: 0,
      parallax: 0.0004,
      url: '/Sonic/backdrop/west-side/water-shine-2.png',
      height: 3
    }, {
      autoscroll: 0,
      parallax: 0.004,
      url: '/Sonic/backdrop/west-side/water.png',
      height: 142
    }, {
      autoscroll: 0,
      parallax: 0.001,
      url: '/Sonic/backdrop/west-side/stars-reflected.png',
      height: 0
    }, {
      autoscroll: 0,
      parallax: 0.0005,
      url: '/Sonic/backdrop/west-side/island-dark-reflected.png',
      height: 0
    }];
    return _this;
  }
  return _createClass(WestSideNight);
}(_Backdrop2.Backdrop);
exports.WestSideNight = WestSideNight;
});

;require.register("backdrop/Wood.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Wood = void 0;
var _Backdrop2 = require("./Backdrop");
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let Wood = /*#__PURE__*/function (_Backdrop) {
  _inherits(Wood, _Backdrop);
  var _super = _createSuper(Wood);
  function Wood(args, parent) {
    var _this;
    _classCallCheck(this, Wood);
    _this = _super.call(this, args, parent);
    _this.args.name = 'wood';
    _this.args.strips = [{
      autoscroll: 0.0,
      parallax: 0.1,
      url: '/Sonic/backdrop/wood/forest.png',
      height: 1600
    }];
    return _this;
  }
  return _createClass(Wood);
}(_Backdrop2.Backdrop);
exports.Wood = Wood;
});

;require.register("behavior/Behavior.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Behavior = void 0;
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let Behavior = /*#__PURE__*/function () {
  function Behavior() {
    _classCallCheck(this, Behavior);
  }
  _createClass(Behavior, [{
    key: "update",
    value: function update(host) {}
  }]);
  return Behavior;
}();
exports.Behavior = Behavior;
});

;require.register("behavior/Crouch.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Crouch = void 0;
var _Tag = require("curvature/base/Tag");
var _Behavior2 = require("./Behavior");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let Crouch = /*#__PURE__*/function (_Behavior) {
  _inherits(Crouch, _Behavior);
  var _super = _createSuper(Crouch);
  function Crouch() {
    var _this;
    _classCallCheck(this, Crouch);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _defineProperty(_assertThisInitialized(_this), "spindashCharge", 0);
    return _this;
  }
  _createClass(Crouch, [{
    key: "command_0",
    value: function command_0(host, button) {
      if (host.yAxis > 0.55 && !host.args.falling && !host.args.gSpeed) {
        // return false;
      }
    }
  }, {
    key: "update",
    value: function update(host) {
      if (host.args.grinding) {
        if (host.yAxis > 0.55) {
          host.args.animation = 'grinding-crouching';
          host.args.crouching = true;
        } else {
          host.args.crouching = false;
        }
        return;
      }
      if (host.yAxis > 0.55 && !host.args.gSpeed && !host.args.falling && !host.spindashCharge) {
        host.args.lookTime--;
        if (host.args.lookTime < -45) {
          host.args.cameraBias = -0.5;
        }
        host.args.animation = 'crouching';
        host.args.crouching = true;
      } else {
        host.args.crouching = false;
      }
    }
  }]);
  return Crouch;
}(_Behavior2.Behavior);
exports.Crouch = Crouch;
});

;require.register("behavior/EmeraldHalo.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EmeraldHalo = void 0;
var _Tag = require("curvature/base/Tag");
var _Behavior2 = require("./Behavior");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let EmeraldHalo = /*#__PURE__*/function (_Behavior) {
  _inherits(EmeraldHalo, _Behavior);
  var _super = _createSuper(EmeraldHalo);
  function EmeraldHalo() {
    var _this;
    _classCallCheck(this, EmeraldHalo);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _defineProperty(_assertThisInitialized(_this), "emeraldColors", ['red-alt', 'yellow', 'green', 'cyan', 'white', 'purple', 'pink']);
    _defineProperty(_assertThisInitialized(_this), "emeraldParticles", new Set());
    return _this;
  }
  _createClass(EmeraldHalo, [{
    key: "command_3",
    value: function command_3(host, button) {
      if (!host.isSuper && host.args.rings < host.args.minRingsSuper) {
        return;
      }
      if (host.isSuper && !host.isHyper && host.args.rings < host.args.minRingsHyper) {
        return;
      }
      if (host.isHyper || !host.args.falling || !host.args.jumping) {
        return;
      }
      while (this.emeraldParticles.size < 7) {
        const color = this.emeraldColors[this.emeraldParticles.size];
        const emerald = host.isSuper ? new _Tag.Tag(`<img src = "/Sonic/emerald-super-${color}-mini.png">`) : new _Tag.Tag(`<img src = "/Sonic/emerald-${color}-mini.png">`);
        emerald.index = this.emeraldParticles.size;
        emerald.style({
          '--x': host.args.x,
          '--y': host.args.y,
          '--z': host.args.z + 1,
          width: host.isSuper ? '14px' : '8px',
          height: host.isSuper ? '10px' : '8px'
        });
        host.viewport.particles.add(emerald);
        this.emeraldParticles.add(emerald);
        host.viewport.onFrameOut(60, () => {
          host.viewport.particles.remove(emerald);
          this.emeraldParticles.delete(emerald);
        });
      }
    }
  }, {
    key: "updateEnd",
    value: function updateEnd(host) {
      for (const emerald of this.emeraldParticles) {
        const t = host.transformTime;
        const offset = 2 * Math.PI * emerald.index / this.emeraldParticles.size;
        const radius = t < 30 ? Math.min(t * 2, 32) || 3 : 45 + -t + 15;
        const x = Math.cos(offset + t * 0.15) * radius;
        const w = -Math.sin(offset + t * 0.15) * radius;
        const y = Math.cos(t * 0.075) * w;
        emerald.style({
          '--x': host.args.x + 0 + x,
          '--y': host.args.y + -(host.args.height * 0.65) + y,
          'z-index': host.args.z + -Math.sign(w)
        });
      }
    }
  }]);
  return EmeraldHalo;
}(_Behavior2.Behavior);
exports.EmeraldHalo = EmeraldHalo;
});

;require.register("behavior/Liftable.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Liftable = void 0;
var _Behavior2 = require("./Behavior");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
const _rendered = Symbol('rendered');
let Liftable = /*#__PURE__*/function (_Behavior) {
  _inherits(Liftable, _Behavior);
  var _super = _createSuper(Liftable);
  function Liftable() {
    _classCallCheck(this, Liftable);
    return _super.apply(this, arguments);
  }
  _createClass(Liftable, [{
    key: "rendered",
    value: function rendered(host) {
      if (host[_rendered]) {
        return;
      }
      host[_rendered] = true;
      host.bindTo('carriedBy', carrier => {
        if (host.cX) {
          host.cX();
          host.cX = null;
        }
        if (host.cY) {
          host.cY();
          host.cY = null;
        }
        if (host.carriedBy) {
          const carrier = host.carriedBy;
          host.carriedBy = null;
          host.args.xSpeed = carrier.args.xSpeed;
          host.args.ySpeed = carrier.args.falling ? carrier.args.ySpeed : 0;
          host.args.xSpeed += Math.sign(carrier.args.gSpeed || carrier.args.xSpeed) * 4;
          host.args.ySpeed -= 4;
          carrier.carrying.delete(host);
          host.args.falling = true;
          host.args.float = 0;
        }
        if (carrier) {
          host.cX = carrier.args.bindTo('x', v => host.args.x = v + carrier.args.direction * carrier.xHold);
          host.cY = carrier.args.bindTo('y', v => host.args.y = v + -carrier.yHold);
          host.args.xSpeed = 0;
          host.args.ySpeed = 0;
          carrier.carrying.add(host);
          host.args.standingOn = null;
          host.args.float = -1;
        }
      });
    }
  }, {
    key: "update",
    value: function update(host) {
      if (host.carriedBy) {
        host.args.float = -1;
      }
    }
  }]);
  return Liftable;
}(_Behavior2.Behavior);
exports.Liftable = Liftable;
});

;require.register("behavior/LookUp.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LookUp = void 0;
var _Tag = require("curvature/base/Tag");
var _Behavior2 = require("./Behavior");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let LookUp = /*#__PURE__*/function (_Behavior) {
  _inherits(LookUp, _Behavior);
  var _super = _createSuper(LookUp);
  function LookUp() {
    var _this;
    _classCallCheck(this, LookUp);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _defineProperty(_assertThisInitialized(_this), "lookTime", 0);
    return _this;
  }
  _createClass(LookUp, [{
    key: "update",
    value: function update(host) {
      if (host.args.mode !== 0) {
        return;
      }
      if (host.yAxis < -0.55 && !host.args.gSpeed && !host.args.falling && !host.spindashCharge) {
        host.args.animation = 'looking-up';
        host.args.lookTime++;
        if (host.args.lookTime > 45) {
          host.args.cameraBias = +0.25;
        }
      } else {
        this.lookTime = 0;
      }
    }
  }]);
  return LookUp;
}(_Behavior2.Behavior);
exports.LookUp = LookUp;
});

;require.register("behavior/Patrol.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Patrol = void 0;
var _Behavior2 = require("./Behavior");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let Patrol = /*#__PURE__*/function (_Behavior) {
  _inherits(Patrol, _Behavior);
  var _super = _createSuper(Patrol);
  function Patrol() {
    _classCallCheck(this, Patrol);
    return _super.apply(this, arguments);
  }
  _createClass(Patrol, [{
    key: "update",
    value: function update(host) {
      var _host$args$direction, _host$args$patrolSpee, _host$args$patrolOffs, _host$args$patrolBeat, _host$args$patrolPaus;
      const direction = (_host$args$direction = host.args.direction) !== null && _host$args$direction !== void 0 ? _host$args$direction : 1;
      const speed = (_host$args$patrolSpee = host.args.patrolSpeed) !== null && _host$args$patrolSpee !== void 0 ? _host$args$patrolSpee : 1;
      const offset = (_host$args$patrolOffs = host.args.patrolOffset) !== null && _host$args$patrolOffs !== void 0 ? _host$args$patrolOffs : 0;
      const beat = (_host$args$patrolBeat = host.args.patrolBeat) !== null && _host$args$patrolBeat !== void 0 ? _host$args$patrolBeat : 90;
      const pause = (_host$args$patrolPaus = host.args.patrolPause) !== null && _host$args$patrolPaus !== void 0 ? _host$args$patrolPaus : 25;
      host.age = host.age || 0;
      const age = host.age + offset;
      if (age % beat < beat - pause) {
        if (Math.floor(age / beat) % 2) {
          host.args.gSpeed = -speed;
        } else {
          host.args.gSpeed = speed;
        }
        host.args.direction = -Math.sign(host.args.gSpeed) || host.args.direction;
      } else {
        host.args.direction = -Math.sign(host.gSpeedLast) || host.args.direction;
      }
    }
  }]);
  return Patrol;
}(_Behavior2.Behavior);
exports.Patrol = Patrol;
});

;require.register("behavior/Platformer.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Platformer = void 0;
var _Tag = require("curvature/base/Tag");
var _Bindable = require("curvature/base/Bindable");
var _PointActor = require("../actor/PointActor");
var _Layer = require("../viewport/Layer");
var _CharacterString = require("../ui/CharacterString");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
const MODE_FLOOR = 0;
const MODE_LEFT = 1;
const MODE_CEILING = 2;
const MODE_RIGHT = 3;
let Platformer = /*#__PURE__*/function () {
  function Platformer() {
    _classCallCheck(this, Platformer);
    _defineProperty(this, "collisionMap", null);
  }
  _createClass(Platformer, [{
    key: "updateStart",
    value: function updateStart(host) {
      host.args.wasHanging = host.args.falling && host.args.hangingFrom;
      this.stepsTaken = 0;
      if (host.knocked) {
        host.args.knocked = Math.sign(host.args.xSpeed || host.args.gSpeed);
      }
      if (!host.args.falling && host.knocked) {
        if (host.args.ySpeedLast < 3 && host.pop) {
          host.pop(host.knocked);
        }
        host.args.ySpeed = -host.ySpeedLast * 0.7;
        host.args.falling = true;
        host.args.y--;
      }
      if (!host.args.falling) {
        host.modeLast = host.args.mode;
        if (host.args.grinding) {
          host.args.wasGrinding = true;
        } else {
          host.args.wasGrinding = false;
        }
      }
      host.args.sliding = false;
      host.lastLayer = null;
      host.args.localCameraMode = null;
      if (host.args.dead) {
        return;
      }
      if (host.args.standingLayer && !host.args.static) {
        const layer = host.args.standingLayer.layer;
        let grindRegion = false;
        for (const region of host.regions) {
          if (region.grind) {
            grindRegion = true;
          }
        }
        if (!host.controllable && !host.canGrind) {
          host.args.grinding = false;
        } else if (layer && layer.meta.grinding) {
          host.args.grinding = true;
          host.args.direction = Math.sign(host.args.xSpeed || host.args.gSpeed);
        } else if (!grindRegion) {
          host.args.grinding = false;
        }
        if (host.args.grinding && host.args.falling) {
          host.args.grinding = false;
        }
      }
      if (!host.args.falling) {
        host.fallTime = 0;
      }
    }
  }, {
    key: "updateEnd",
    value: function updateEnd(host) {
      if (!host.args.falling) {
        host.args.jumpArced = false;
      } else if (host.args.jumping && (host.args.ySpeed > -3 || host.args.ySpeed >= 0 && host.ySpeedLast < 0)) {
        host.args.jumpArced = true;
      }
      if (!host.args.static && host.args.falling) {
        if (host.args.standingLayer && host.fallTime === 0) {
          host.args.xSpeed += host.args.standingLayer.offsetXChanged || 0;
          host.args.ySpeed += host.args.standingLayer.offsetYChanged || 0;
        }
        host.args.standingLayer = null;
      }
      if (!host.controllable) {
        return;
      }
      if (host.args.popChain.length && host.args.grinding) {
        if (!host.grindReward) {
          host.grindReward = {
            label: 'Rail Grind',
            points: 100,
            multiplier: 1,
            direction: Math.sign(host.args.gSpeed)
          };
          host.args.popChain.push(host.grindReward);
        }
        host.grindReward.points += Math.round(host.args.gSpeed / 10) * host.grindReward.direction || 1;
      }
      if (host.airReward && host.args.falling) {
        // host.grindReward.points += (Math.round(host.args.gSpeed / 10) * host.grindReward.direction) || 1;
        host.airReward.points += Math.ceil(Math.abs(host.args.ySpeed) + Math.abs(host.args.xSpeed));
      }
      if (!host.args.popChain) {
        host.grindReward = null;
        host.airReward = null;
      }
      if (!host.args.falling && !host.args.grinding && host.groundTime > 1) {
        host.grindReward = null;
        host.airReward = null;
      }
      if (host.follower) {
        const frame = host.viewport.serializePlayer();
        const follower = host.follower;
        host.viewport.onFrameOut(5, () => {
          if (frame.input) {
            follower.controller && follower.controller.replay(frame.input);
            follower.readInput();
          }
          if (frame.args) {
            Object.assign(follower.args, frame.args);
            follower.viewport && follower.viewport.setColCell(host);
          }
        });
        if (host.follower.args.dead) {
          host.follower.args.dead = false;
          host.follower.args.x = host.x;
          host.follower.args.y = host.y;
        }
      }
      if (!host.args.falling && !host.args.rolling && !host.args.hangingFrom && !host.args.grinding && host.groundTime > 1 && !host.args.bouncing && !host.punched && !host.readyTime && host.args.popChain.length) {
        host.totalCombo();
      }
    }
  }, {
    key: "update",
    value: function update(host) {
      if (host.args.mercy) {
        host.args.spindashCharge = 0;
        host.args.dropDashCharge = 0;
      }
      if (typeof host.args.standingOn === 'number') {
        const standId = host.args.standingOn;
        const standOn = host.viewport.actorsById[standId];
        if (standOn) {
          host.args.standingOn = standOn;
          host.args.x = standOn.x;
          host.args.y = standOn.y - standOn.args.height;
        }
      }
      host.args.jumpBlocked = false;
      if (!host.xAxis || Math.sign(host.args.gSpeed) !== host.args.pushing || Math.sign(host.xAxis) !== host.args.pushing) {
        host.args.pushing = false;
      }
      const startX = host.args.x;
      const startY = host.args.y;
      if (host.noClip && !host.controllable) {
        if (host.args.xSpeed) {
          host.args.x += host.args.xSpeed;
        }
        if (host.args.ySpeed) {
          host.args.y += host.args.ySpeed;
        }
        if (!host.args.float && host.args.falling) {
          host.args.ySpeed += host.args.gravity;
        }
        if (host.impulseMag !== null) {
          this.applyImpulse(host);
        }
        if (host.args.float > 0) {
          host.args.float--;
        }
        let collisions;
        switch (host.args.mode) {
          case MODE_CEILING:
            collisions = viewport.actorsAtPoint(host.args.x, host.args.y + host.args.height, host.args.width, host.args.height);
            break;
          case MODE_LEFT:
            collisions = viewport.actorsAtPoint(host.args.x - host.args.height / 2, host.args.y + host.args.width / 2, host.args.height, host.args.width);
            break;
          case MODE_RIGHT:
            collisions = viewport.actorsAtPoint(host.args.x + host.args.height / 2, host.args.y + host.args.width / 2, host.args.height, host.args.width);
            break;
          default:
          case MODE_FLOOR:
            collisions = viewport.actorsAtPoint(host.args.x, host.args.y, host.args.width, host.args.height);
            break;
        }
        if (collisions) {
          for (const actor of collisions) {
            if (actor.args === host.args) {
              continue;
            }
            actor.callCollideHandler(host);
          }
        }
        return;
      }
      if (!host.args.falling && !host.args.rolling && host.args.modeTime >= 1) {
        host.args.spinning = false;
      }
      if (host.args.rolling || host.args.jumping || host.spindashCharge) {
        host.args.spinning = true;
      }
      if (host.viewport && host.args.respawning && !host.args.npc && !host.viewport.args.isRecording && !host.viewport.args.isReplaying) {
        const stored = host.viewport.getCheckpoint(host.args.canonical);
        let toX, toY;
        if (stored && stored.checkpointId) {
          const viewport = host.viewport;
          const checkpoint = viewport.defsByMap.get(viewport.currentMap)[stored.checkpointId];
          toX = checkpoint.x;
          toY = checkpoint.y;
        } else if (host.def) {
          toX = host.def.get('x');
          toY = host.def.get('y');
        } else if (!host.canRoll && host.viewport.defsByName.get('wide-player-start')) {
          const startDef = host.viewport.defsByName.get('wide-player-start');
          toX = startDef.x;
          toY = startDef.y;
        } else if (host.viewport.defsByName.has('player-start')) {
          const startDef = host.viewport.defsByName.get('player-start');
          toX = startDef.x;
          toY = startDef.y;
        }
        host.args.animation = 'dropping';
        host.args.standingLayer = null;
        host.args.standingOn = null;
        host.lastLayer = null;
        const xDiff = host.args.x - toX;
        const yDiff = host.args.y - toY;
        const xPanSpeed = Math.max(Math.abs(xDiff / 8), 16);
        const yPanSpeed = Math.max(Math.abs(yDiff / 8), 16);
        host.args.x -= Math.sign(xDiff) * xPanSpeed;
        host.args.y -= Math.sign(yDiff) * yPanSpeed;
        const viewport = host.viewport;
        if (Math.abs(xDiff) <= xPanSpeed) {
          host.args.x = toX;
        }
        if (Math.abs(yDiff) <= yPanSpeed) {
          host.args.y = toY;
        }
        if (Math.abs(xDiff) <= xPanSpeed && Math.abs(yDiff) <= yPanSpeed) {
          host.viewport.onFrameOut(60, () => {
            if (host.viewport.args.networked) {
              host.args.dead = false;
              host.noClip = false;
              host.args.respawning = false;
              host.args.display = 'initial';
              host.args.ignore = 4;
              host.args.xSpeed = 0;
              host.args.ySpeed = -3;
            } else {
              viewport.reset();
              viewport.startLevel(false);
            }
            viewport.args.paused = false;
          });
        }
        host.viewport && host.viewport.setColCell(host);
        return;
      }
      if (host.viewport && host.viewport.meta.deathLine && !host.args.dead && host.controllable && host.y > host.viewport.meta.deathLine) {
        host.die();
        return;
      }
      if (host.controllable && !host.args.dead) {
        const radius = 0.5 * host.args.width;
        const direction = Math.sign(host.args.xSpeed);
        const height = Math.max(host.args.height, 0);
        const headPoint = host.rotatePoint(0, height * 0.75);
        // const headPoint = host.rotatePoint(radius * -direction, host.args.height * 0.75);

        let jumpBlock = host.getMapSolidAt(host.args.x + headPoint[0], host.args.y + headPoint[1]);
        if (Array.isArray(jumpBlock)) {
          jumpBlock = !!jumpBlock.filter(a => !a.args.platform && !a.isVehicle).length;
        }
        if (host.args.rolling) {
          const rollTopPoint = host.rotatePoint(0, height);
          // const headPoint = host.rotatePoint(radius * -direction, host.args.height * 0.75);

          let rollJumpBlock = host.getMapSolidAt(host.args.x + rollTopPoint[0], host.args.y + rollTopPoint[1]);
          if (Array.isArray(rollJumpBlock)) {
            rollJumpBlock = !!rollJumpBlock.filter(a => !a.args.platform && !a.isVehicle).length;
            host.args.jumpBlocked = !!rollJumpBlock;
          }
          host.args.jumpBlocked = !!rollJumpBlock;
        }
        if (!host.args.hangingFrom && !host.noClip && !host.args.falling && this.checkBelow(host, host.args.x, host.args.y) && jumpBlock) {
          host.die();
          return;
        }
        if (!host.args.falling && host.args.mode === 0) {
          const upFirstSpace = host.castRay(host.maxStep, host.upAngle, this.findUpSpace);
          if (upFirstSpace) {
            host.args.y -= upFirstSpace;
          }
        }
      }
      host.args.skimming = false;
      if (host.args.falling) {
        host.args.airAngle = host.airAngle;
        if (host.args.displayAngle !== host.args.groundAngle) {
          const angleDiff = host.args.groundAngle + -host.args.displayAngle;
          host.args.displayAngle += Math.sign(angleDiff) * (Math.abs(angleDiff) > 1 ? 1 : Math.abs(angleDiff)) * 0.5;
        }
      } else {
        host.args.airAngle = 0;
        host.args.displayAngle = host.args.groundAngle;
      }
      if (host.args.halted < 1 && host.args.halted > 0) {
        host.args.halted = 0;
      }
      if (host.args.halted > 0) {
        host.args.halted--;
        return;
      }
      if (host.args.currentSheild && 'update' in host.args.currentSheild) {
        host.args.currentSheild.update(host);
      }
      if (host.args.rolling) {
        host.args.height = host.args.rollingHeight || host.args.height;
      } else if (host.args.jumping) {
        host.args.height = host.args.rollingHeight || host.args.height;
      } else if (host.canRoll) {
        host.args.height = host.args.normalHeight || host.args.height;
      }
      if (host.args.dontJump > 0) {
        host.args.dontJump--;
      }
      if (host.args.dontJump < 0) {
        host.args.dontJump = 0;
      }
      if (!host.viewport || host.removed) {
        return;
      }
      host.args.modeTime++;
      if (!host.args.falling) {
        if (Math.abs(host.args.gSpeed) < 1 && !host.impulseMag && host.args.modeTime > 3) {
          host.args.rolling = false;
        }
        if (Math.abs(host.args.gSpeed) < 0.01) {
          host.args.gSpeed = 0;
        } else if (host.canRoll && host.yAxis > 0.55 && !host.args.ignore && !host.carrying.size) {
          host.args.rolling = true;
        }
        if (host.args.mode === 0 && !host.args.groundAngle) {
          const dSolid = host.getMapSolidAt(host.args.x + 0 * host.args.direction, host.args.y + 2);
          const dSolidF = host.getMapSolidAt(host.args.x + 4 * host.args.direction, host.args.y + 2);
          const uSolidF = host.getMapSolidAt(host.args.x + 4 * host.args.direction, host.args.y - 2);
          const dSolidF2 = host.getMapSolidAt(host.args.x + 2 * host.args.direction, host.args.y + 2);
          const dSolidB = host.getMapSolidAt(host.args.x - 4 * host.args.direction, host.args.y + 2);
          const uSolidB = host.getMapSolidAt(host.args.x - 4 * host.args.direction, host.args.y - 2);
          if (dSolid && !dSolidF && !uSolidF) {
            host.args.teeter = 1;
            if (!dSolidF2) {
              host.args.teeter = 2;
            }
          } else if (dSolid && !dSolidB && !uSolidB) {
            host.args.teeter = -1;
          } else {
            host.args.teeter = 0;
          }
        } else {
          host.args.teeter = 0;
        }
      }
      host.args.driving = false;
      if (host.args.standingOn && host.args.standingOn.isVehicle && !host.isVehicle) {
        const vehicle = host.args.standingOn;
        host.args.groundTimeTotal++;
        host.args.falling = true;
        host.args.flying = false;
        host.args.jumping = false;
        host.args.driving = true;
        host.processInput();
        host.args.cameraMode = vehicle.args.cameraMode;
        if (!host.args.standingOn.args.lockedIn && host.willJump && (host.yAxis < 0 || host.args.standingOn && host.args.standingOn.quickDrop)) {
          const leaving = host.args.standingOn;
          host.args.standingLayer = false;
          host.args.standingOn = false;
          host.willJump = false;
          leaving.occupant = null;
          host.args.falling = true;
          host.args.jumping = true;

          // host.args.y -= vehicle.args.seatHeight || vehicle.args.height;
          host.args.y -= 16;
          if (!(leaving && leaving.quickDrop)) {
            host.args.xSpeed = vehicle.args.direction * 2 * -Math.sign(vehicle.args.seatAngle || -1);
            host.args.ySpeed = -host.args.jumpForce;
          } else {
            host.args.ySpeed = -host.args.jumpForce + Math.max(leaving.args.ySpeed, 0);
          }
          vehicle.args.ySpeed = 0;
        }
        host.args.groundAngle = (vehicle.args.groundAngle || 0) + (vehicle.args.seatAngle || 0);
        if (host.willJump && host.yAxis >= 0) {
          host.args.standingOn.falling = false;
          host.willJump = false;
          host.args.standingOn.command_0();
        }
        return;
      }
      if (host.impulseMag !== null) {
        this.applyImpulse(host);
      }
      if (host.args.ignore === -2 && (host.args.falling === false || host.args.ySpeed > 64)) {
        host.args.ignore = 0;
      }
      if (host.args.ignore === -3 && (!host.args.falling || host.args.ySpeed >= -10)) {
        host.viewport.onFrameOut(1, () => host.args.ignore = 0);
      }
      if (host.args.ignore === -4 && !host.args.falling) {
        host.args.ignore = 30;
      }
      if (host.args.ignore < 1 && host.args.ignore > 0) {
        host.args.ignore = 0;
      }
      if (host.args.ignore > 0) {
        host.args.ignore--;
      }
      if (host.args.cameraIgnore > 0) {
        host.args.cameraIgnore--;
      }
      if (host.args.mercy > 0) {
        host.args.mercy--;
      }
      if (host.args.startled > 0) {
        host.args.startled--;
      }
      if (host.args.antiSkid > 0) {
        host.args.antiSkid--;
      }
      if (host.args.float > 0) {
        host.args.float--;
      }
      if (host.args.standingOn instanceof _PointActor.PointActor) {
        host.args.standingOn.callCollideHandler(host);
      }
      if (!host.args.float && host.args.falling) {
        if (!host.args.standingOn || !host.args.standingOn.isVehicle) {
          host.args.standingOn = null;
          host.args.landed = false;
          host.lastAngles.splice(0, host.lastAngles.length, ...Array(host.angleAvg).fill(0));
          if (host.args.jumping && host.args.jumpedAt < host.args.y) {
            host.args.deepJump = true;
          } else if (host.args.jumping && host.args.jumpedAt > host.args.y + 160) {
            host.args.highJump = true;
          } else if (host.args.jumping) {
            host.args.deepJump = false;
            host.args.highJump = false;
          }
        }
      } else if (host.args.jumping && !host.args.falling) {
        host.args.jumping = false;
        host.args.deepJump = false;
        host.args.highJump = false;
        host.args.jumpedAt = null;
      }
      if (!host.args.falling && host.args.standingOn && host.args.rolling && host.args.modeTime < 3 && !host.args.dropDashCharge && host.args.standingOn.args.convey) {
        host.args.gSpeed = -host.args.standingOn.args.convey * 0.8;
      }
      const drag = host.getLocalDrag();
      let gSpeedMax = host.args.gSpeedMax;
      let regions = new Set();
      if (!host.isRegion) {
        if (!host.noClip) {
          regions = host.viewport.regionsAtPoint(host.args.x, host.args.y);
          for (const region of host.regions) {
            region.updateActor(host);
          }
        }
        for (const region of regions) {
          if (host.args.density) {
            if (region.args.density && host.args.density < region.args.density) {
              const densityRatio = region.args.density / host.args.density;
              let blocked = false;
              let blockers = host.getMapSolidAt(host.x, host.y - host.args.height);
              if (Array.isArray(blockers)) {
                blockers.filter(x => ![...regions].includes(x));
                if (blockers.length) {
                  blocked = true;
                }
              }
              if (!blocked) {
                const myTop = host.y - host.args.height;
                const regionTop = region.y - region.args.height;
                const depth = Math.min((myTop + -regionTop + 4) / host.args.height, 1);
                host.args.float = 1;
                const force = depth * drag;
                host.args.falling = true;
                if (depth > -1) {
                  host.args.ySpeed -= force;
                  host.args.ySpeed *= drag;
                } else if (depth < -1 && host.args.ySpeed < 0) {
                  if (Math.abs(depth) < 0.25 && Math.abs(host.args.ySpeed) < 1) {
                    host.args.ySpeed = 0;
                    host.args.y = -1 + regionTop + host.args.height;
                  }
                }
              }
            }
          }
          if (!host.regions.has(region)) {
            host.regions.add(region);
            host.crossRegionBoundary(region, true);
            region.enter(host);
          }
        }
        for (const region of host.regions) {
          if (!regions.has(region)) {
            host.regions.delete(region);
            host.crossRegionBoundary(region, false);
            region.leave(host);
          }
        }

        // if(!regions.size && host.def)
        // {
        // 	host.args.float = host.def.get('float') ?? host.args.float ?? 0;
        // }
      }

      if (host.willJump && !host.args.dontJump && (!host.args.falling || host.falltime < 2)) {
        host.willJump = false;
        const tileMap = host.viewport.tileMap;
        const height = Math.max(host.args.height, 32);
        const headPoint = host.rotatePoint(0, height + 1);
        let jumpBlock = host.getMapSolidAt(host.args.x + headPoint[0], host.args.y + headPoint[1]);
        if (Array.isArray(jumpBlock)) {
          jumpBlock = !!jumpBlock.filter(a => !a.args.platform && !a.isVehicle).length;
        }
        if (!jumpBlock) {
          let force = host.args.jumpForce * drag;
          if (host.running) {
            force = force * 1.5;
          } else if (host.crawling) {
            force = force * 0.5;
          }
          this.doJump(host, force);
        }
        return;
      }
      host.willJump = false;
      if (!host.viewport) {
        return;
      }
      if (host.noClip) {
        host.args.falling = true;
      }
      if (!host.args.static) {
        const groundPoint = host.groundPoint;
        const regionsBelow = host.controllable || host.args.pushed || host.isVehicle ? host.viewport.regionsAtPoint(groundPoint[0], groundPoint[1] + 1) : [];
        const standingOn = host.getMapSolidAt(...groundPoint) || (host.controllable && host.args.groundAngle ? host.getMapSolidAt(groundPoint[0], groundPoint[1] + 1) : false);
        if (!host.args.dead && !host.isRegion && host.args.mode === MODE_FLOOR && regionsBelow.size) {
          let falling = !standingOn;
          if (!host.args.falling || host.broad) for (const region of regionsBelow) {
            if (host.broad || !Math.round(host.args.ySpeed) && (Math.round(host.args.y) === region.args.y - region.args.height || Math.round(host.args.y + 1) === region.args.y - region.args.height || Math.round(host.args.y + 2) === region.args.y - region.args.height)) {
              if (region.skimSpeed < Infinity && (host.broad || Math.max(Math.abs(host.args.gSpeed), Math.abs(host.args.xSpeed)) >= region.skimSpeed)) {
                const speed = host.args.falling ? Math.abs(host.args.xSpeed) : Math.abs(host.args.gSpeed);
                host.args.gSpeed = speed * Math.sign(host.args.gSpeed || host.args.xSpeed);
                if (host.args.y - 32 < region.args.y - region.args.height) {
                  if (host.broad) {
                    host.args.falling = false;
                  }
                  host.args.skimming = true;
                  host.args.y = region.y - region.args.height + -1;
                  falling = false;
                  region.skim(host);
                } else if (host.broad) {
                  host.args.ySpeed--;
                }
                break;
              } else {
                host.args.xSpeed = host.args.gSpeed || host.args.xSpeed;
              }
            }
          }
          if (standingOn instanceof _Layer.Layer) {
            host.args.standingOn = standingOn;
          } else {
            host.args.falling = host.args.falling || falling;
          }

          // host.args.falling = falling || host.args.falling;
          // host.args.falling = host.args.ySpeed <= 0 ? falling : host.args.falling;

          if (host.args.falling) {
            // host.args.xSpeed = host.args.xSpeed || host.args.gSpeed;
            host.args.standingLayer = null;
          } else {
            host.args.gSpeed = host.args.gSpeed || host.args.xSpeed;
          }
        } else if (!host.noClip && !host.args.climbing && !host.args.xSpeed && !host.args.ySpeed && !host.args.float) {
          host.args.falling = !host.args.float && !this.checkBelow(host) || host.args.falling;
        }
        if (!host.args.static && !host.noClip && host.args.falling) {
          host.args.mode = MODE_FLOOR;
          host.args.gSpeed = 0;
        }
        if (!host.willStick && (host.args.falling && host.args.ySpeed >= 0 || host.args.standingOn) && !host.args.static && !host.noClip) {
          let popOut = 64;
          const radius = host.args.width * 0.5;
          while (host.getMapSolidAt(host.args.x - radius, host.args.y - host.args.height * 0.5) && !host.getMapSolidAt(host.args.x + radius + 1, host.args.y - host.args.height * 0.5) && popOut > 0) {
            host.args.x += 1;
            popOut--;
          }
          while (host.getMapSolidAt(host.args.x + radius + -1, host.args.y - host.args.height * 0.5) && !host.getMapSolidAt(host.args.x - radius, host.args.y - host.args.height * 0.5) && popOut > 0) {
            host.args.x -= 1;
            popOut--;
          }
        }
        if (!host.viewport) {
          return;
        }
        if (host.noClip || !host.isRegion && !host.isEffect && host.args.falling && host.viewport) {
          if (host.args.grinding) {
            host.args.grinding = false;
          }

          // host.args.mode    = MODE_FLOOR;
          // host.args.gSpeed  = 0;
          host.args.pushing = false;
          if (host.args.xSpeed || host.args.ySpeed) {
            if (!host.args.hangingFrom) {
              this.updateAirPosition(host);
              host.swing = false;
              host.args.airTimeTotal++;
            } else {
              host.args.groundTimeTotal++;
              host.args.flying = false;
            }
          }
          host.args.animationBias = Math.abs(host.args.airSpeed / host.args.flySpeedMax);
          if (host.args.animationBias > 1) {
            host.args.animationBias = 1;
          }
          if (!host.args.canHide && !host.noClip) {
            let popOut = 32;
            let stuckInside;
            while (!host.args.static && host.args.mode === 0 && !host.getMapSolidAt(host.args.x, host.args.y - host.args.height, host.args.layer, 0) && (stuckInside = host.getMapSolidAt(host.args.x, host.args.y - 1, host.args.layer, 0))) {
              if (stuckInside.find && !stuckInside.find(other => {
                const collisions = host.viewport.collisions.get(host);
                return collisions && collisions.has(other);
              })) {
                break;
              }
              if (--popOut <= 0) {
                return;
              }
              host.args.y--;
            }
          }
        } else if (!host.args.static && (!host.noClip || host.args.standingLayer || !host.isRegion && !host.isEffect && !host.args.falling)) {
          if (Math.abs(host.args.xSpeed) > Math.abs(host.args.gSpeed)) {
            host.args.gSpeed = host.args.xSpeed;
            if (host.args.standingLayer) {
              host.args.gSpeed -= host.args.standingLayer.layer.offsetXChanged;
            }
          }
          host.args.xSpeed = 0;
          host.args.ySpeed = 0;
          host.xLast = host.args.x;
          host.yLast = host.args.y;
          if (host.args.grinding && !host.args.gSpeed && host.args.modeTime > 4) {
            host.args.gSpeed = Math.sign(host.args.direction || host.axis || host.xSpeedLast || host.gSpeedLast || 0);
          }
          if (!host.args.canHide && !host.noClip) {
            let popOut = 32;
            let stuckInside;
            while (!host.args.static && host.args.mode === 0 && (stuckInside = host.getMapSolidAt(host.args.x, host.args.y - 1))) {
              if (stuckInside.find && !stuckInside.find(other => {
                const collisions = host.viewport.collisions.get(host);
                return collisions && collisions.has(other);
              })) {
                break;
              }
              if (--popOut <= 0) {
                return;
              }
              host.args.y--;
            }
          }
          this.updateGroundPosition(host);
          host.args.groundTimeTotal++;
          host.args.animationBias = Math.abs((host.args.hSpeed * 0.75 || host.args.gSpeed) / host.args.gSpeedMax);
          if (host.args.animationBias > 1) {
            host.args.animationBias = 1;
          }
        }
        if (host.args.rolling && host.args.pushing) {
          host.args.gSpeed = 0;
        }
        if (!host.viewport) {
          return;
        }
      }
      const halfWidth = Math.ceil(host.args.width / 2);
      const halfHeight = Math.floor(host.args.height / 2);

      // if(!host.isRegion && (host.args.pushed || ( !host.willStick && host.controllable )))
      if (!host.noClip && !host.isRegion && host.args.pushed) {
        let block;
        const testWallPoint = direction => {
          switch (host.args.mode) {
            case MODE_FLOOR:
              block = host.getMapSolidAt(host.x + halfWidth * direction + (direction === -1 ? 0 : -1), host.y - halfHeight);
              break;
            case MODE_CEILING:
              block = host.getMapSolidAt(host.x + halfWidth * direction + (direction === -1 ? 0 : -1), host.y + halfHeight);
              break;
            case MODE_LEFT:
              block = host.getMapSolidAt(host.x + halfHeight * (direction === -1 ? 0 : 2), host.y);
              break;
            case MODE_RIGHT:
              block = host.getMapSolidAt(host.x - halfHeight * (direction === -1 ? 0 : 2), host.y);
              break;
          }
          if (block && Array.isArray(block)) {
            return block.filter(a => !a.args.platform && !a.isVehicle);
          }
          return block;
        };
        const leftWall = testWallPoint(-1);
        const rightWall = testWallPoint(1);
        if (rightWall && !leftWall) {
          if (host.args.xSpeed > 0) {
            host.args.xSpeed = 0;
          }
          host.args.x--;
        }
        if (leftWall && !rightWall) {
          if (host.args.xSpeed > 0) {
            host.args.xSpeed = 0;
          }
          host.args.x++;
        }
      }
      if (!host.viewport || host.removed) {
        return;
      }
      const layerSwitch = host.viewport.objectPalette['layer-switch'];
      const regionClass = host.viewport.objectPalette['base-region'];
      const skipChecking = [regionClass];
      if (!host.isGhost && !host.isStatic && !host.isRegion && !skipChecking.some(x => host instanceof x)) {
        let collisions;
        switch (host.args.mode) {
          case MODE_CEILING:
            collisions = viewport.actorsAtPoint(host.args.x, host.args.y + host.args.height, host.args.width, host.args.height);
            break;
          case MODE_LEFT:
            collisions = viewport.actorsAtPoint(host.args.x + host.args.height / 2, host.args.y + host.args.width / 2, host.args.height, host.args.width);
            break;
          case MODE_RIGHT:
            collisions = viewport.actorsAtPoint(host.args.x - host.args.height / 2, host.args.y + host.args.width / 2, host.args.height, host.args.width);
            break;
          default:
          case MODE_FLOOR:
            collisions = viewport.actorsAtPoint(host.args.x, host.args.y, host.args.width, host.args.height);
            break;
        }
        collisions.forEach(x => x.args !== host.args && !(host.args.static && x.args.static) && !x.isPushable && x.callCollideHandler(host));
      }
      if (!host.viewport) {
        return;
      }
      const tileMap = host.viewport.tileMap;
      if ((host.args.pushing || Math.abs(host.args.gSpeed) < 2) && !host.args.falling) {
        let stayStuck = host.stayStuck;
        host.regions.forEach(region => {
          stayStuck = stayStuck || region.args.sticky;
        });
        if (!stayStuck && !host.args.climbing) {
          const half = Math.floor(host.args.width / 2) || 0;

          // if(!tileMap.getSolid(host.x, host.y+1, host.args.layer))
          const mode = host.args.mode;
          if (host.args.mode === MODE_FLOOR && host.args.groundAngle <= -(Math.PI / 4)) {
            host.args.gSpeed = 1;
          } else if (host.args.mode === MODE_FLOOR && host.args.groundAngle >= Math.PI / 4 && host.args.groundAngle < Math.PI) {
            host.args.gSpeed = -1;
          } else if (mode === MODE_LEFT && host.args.groundAngle < Math.PI * 0.05) {
            host.lastAngles.splice(0, host.lastAngles.length, ...Array(host.angleAvg).fill(0));

            // host.args.xSpeed = 2;

            host.args.mode = MODE_FLOOR;
            host.args.falling = true;
            if (host.args.rolling) {
              host.args.x += host.args.width;
              host.args.y += host.args.height;
              host.args.ySpeed = host.args.gSpeed;
              host.args.float = 1;
            } else {
              host.args.groundAngle = -Math.PI / 2;
              host.args.x++;
            }
            host.args.cameraIgnore = 30;
            host.args.ignore = -4;
          } else if (mode === MODE_RIGHT && host.args.groundAngle > -Math.PI * 0.05) {
            host.lastAngles.splice(0, host.lastAngles.length, ...Array(host.angleAvg).fill(0));

            // host.args.xSpeed = -2;

            host.args.mode = MODE_FLOOR;
            host.args.falling = true;
            if (host.args.rolling) {
              host.args.x -= host.args.width;
              host.args.y += host.args.height;
              host.args.ySpeed = -host.args.gSpeed;
              host.args.float = 1;
            } else {
              host.args.groundAngle = Math.PI / 2;
              host.args.x--;
            }
            host.args.cameraIgnore = 30;
            host.args.ignore = -4;
          } else if (mode === MODE_CEILING) {
            host.lastAngles.splice(0, host.lastAngles.length, ...Array(host.angleAvg).fill(0));
            host.args.xSpeed = 0;
            host.args.y++;
            host.args.falling = true;
            host.willJump = false;
            const gSpeed = host.args.gSpeed;
            host.args.groundAngle = Math.PI;
            host.args.mode = MODE_FLOOR;
            host.viewport.onFrameOut(1, () => {
              host.args.mode = MODE_FLOOR;
              host.willJump = false;
              host.args.xSpeed = -gSpeed;
            });
            if (!host.args.rolling) {
              if (Math.sign(host.xSpeedLast) === -1) {
                host.args.direction = -1;
                host.args.facing = 'left';
                // host.args.x++;
              } else if (Math.sign(host.xSpeedLast) === 1) {
                host.args.direction = 1;
                host.args.facing = 'right';
                // host.args.x--;
              }
            }

            host.args.cameraIgnore = 30;
            host.args.ignore = -2;
          }
        }
      }
      host.args.landed = true;
      if (host.controllable) {
        host.args.x = host.args.x;
        host.args.y = host.args.y;
      }
      host.controllable && host.processInput();
      if (host.args.falling || host.args.gSpeed) {
        host.args.stopped = 0;
      } else {
        host.args.stopped++;
      }
      if (host.args.falling) {
        host.lastAngles.splice(0, host.lastAngles.length, ...Array(host.angleAvg).fill(0));
      } else if (host.lastAngles.length > 0) {
        host.args.groundAngle = host.lastAngles.map(a => Number(a)).reduce((a, b) => a + b) / host.lastAngles.length;
      }
      if (isNaN(host.args.groundAngle)) {
        console.log(host.lastAngles, host.lastAngles.length);
      }
      if (!host.args.float && !host.args.static && !host.noClip) {
        const standingOn = host.getMapSolidAt(...host.groundPoint);
        if (Array.isArray(standingOn) && standingOn.length && !host.args.float) {
          host.args.standingLayer = false;
          const groundActors = standingOn.filter(a => a.args !== host.args && a.solid && a.callCollideHandler(host));
          if (groundActors.length) {
            for (const groundActor of groundActors) {
              if (!groundActor.isVehicle && host.args.y > 1 + groundActor.args.y + -groundActor.args.height) {
                continue;
              }
              host.args.groundAngle = groundActor.groundAngle || 0;
              host.args.standingOn = groundActor;

              // if(groundActor.args.standingLayer)
              // {
              // 	host.args.standingLayer = groundActor.args.standingLayer;
              // }
            }
          }
        } else if (standingOn) {
          host.args.standingOn = null;
          if (_typeof(standingOn) === 'object') {
            if (!Array.isArray(standingOn)) {
              host.args.standingLayer = standingOn;
            }
            if (host.args.modeTime < 1 && standingOn.xLayerSpeed) {
              // host.args.gSpeed = 0;
            }
          } else {
            host.args.standingLayer = null;
          }
        } else if (host.args.standingOn && !host.args.standingOn.isVehicle) {
          host.args.standingOn = null;
        }
      }
      if (!host.args.static && !host.isRegion && !host.noClip && !host.args.xSpeed && !host.args.ySpeed && this.checkBelow(host, host.args.x, host.args.y)) {
        host.args.falling = false;
      }
      if (host.args.falling && host.args.ySpeed < host.args.ySpeedMax) {
        if (!host.args.float) {
          let gravity = 1;
          for (const region of host.regions) {
            if (!region.args.gravity && region.args.gravity !== 1) {
              continue;
            }
            gravity *= region.args.gravity;
          }
          host.args.ySpeed += host.args.gravity * gravity;
        }
        host.args.landed = false;
      }
      if (!host.args.falling) {
        this.checkDropDash(host);
        host.args.jumping = false;
      }

      // for(const behavior of host.behaviors)
      // {
      // 	behavior.update(host);
      // }

      if (host.twister) {
        if (host.viewport && host.viewport.args.frameId % host.viewport.settings.frameSkip === 0) {
          host.twister.args.x = host.args.x;
          host.twister.args.y = host.args.y;
        }
        if (host.args.mode) {
          host.twister.args.xOff = host.args.xOff;
        } else {
          host.twister.args.xOff = host.args.xOff + -8 * host.args.direction;
        }
        host.twister.args.yOff = host.args.yOff + 16;
        host.twister.args.width = host.args.width;
        host.twister.args.height = host.args.height;
      }
      if (host.pincherBg) {
        if (host.viewport && host.viewport.args.frameId % host.viewport.settings.frameSkip === 0) {
          host.pincherBg.args.x = host.args.x;
          host.pincherBg.args.y = host.args.y;
        }
        host.pincherBg.args.xOff = host.args.xOff;
        host.pincherBg.args.yOff = host.args.yOff;
        host.pincherBg.args.width = host.args.width;
        host.pincherBg.args.height = host.args.height;
      }
      if (host.pincherFg) {
        if (host.viewport && host.viewport.args.frameId % host.viewport.settings.frameSkip === 0) {
          host.pincherFg.args.x = host.args.x;
          host.pincherFg.args.y = host.args.y;
        }
        host.pincherFg.args.xOff = host.args.xOff;
        host.pincherFg.args.yOff = host.args.yOff;
        host.pincherFg.args.width = host.args.width;
        host.pincherFg.args.height = host.args.height;
      }
      if (host.args.falling) {
        host.groundTime = 0;
        host.idleTime = 0;
        host.args.rolling = false;
        host.fallTime++;
      } else {
        host.groundTime++;
        host.idleTime++;
        if (host.yAxis || host.xAxis) {
          host.idleTime = 0;
        }
      }
      host.args.carrying = !!host.carrying.size;
      if (host.args.carrying) {
        if (Math.abs(host.args.gSpeed) > 8) {
          host.args.gSpeed = 8 * Math.sign(host.args.gSpeed);
        }
        host.idleTime = 0;
        host.args.rolling = false;
      }
    }
  }, {
    key: "applyImpulse",
    value: function applyImpulse(host) {
      if (host.args.dead) {
        return;
      }
      host.args.xSpeed += Number(Number(Math.cos(host.impulseDir) * host.impulseMag).toFixed(3));
      host.args.ySpeed += Number(Number(Math.sin(host.impulseDir) * host.impulseMag).toFixed(3));
      if (!host.impulseFal) {
        switch (host.args.mode) {
          case MODE_FLOOR:
            host.args.gSpeed = Math.cos(host.impulseDir) * host.impulseMag;
            break;
          case MODE_CEILING:
            host.args.gSpeed = -Math.cos(host.impulseDir) * host.impulseMag;
            break;
          case MODE_LEFT:
            host.args.gSpeed = -Math.sin(host.impulseDir) * host.impulseMag;
            break;
          case MODE_RIGHT:
            host.args.gSpeed = Math.sin(host.impulseDir) * host.impulseMag;
            break;
        }
      } else {
        host.args.falling = host.impulseFal || host.args.falling;
      }
      host.impulseMag = null;
      host.impulseDir = null;
      host.impulseFal = null;
    }
  }, {
    key: "updateGroundPosition",
    value: function updateGroundPosition(host) {
      if (host.args.mercy) {
        if (Math.abs(host.args.gSpeed) > 10) {
          host.args.gSpeed = 10 * Math.sign(host.args.gSpeed);
        }
      }
      const drag = host.getLocalDrag();
      let gSpeedMax = host.args.gSpeedMax;
      if (host.running) {
        gSpeedMax = RUNNING_SPEED;
      } else if (host.crawling) {
        gSpeedMax = CRAWLING_SPEED;
      }
      let nextPosition = [0, 0];
      const radius = Math.ceil(host.args.width / 2);
      const wasPaused = host.paused;
      if (host.args.gSpeed || host.args.rolling || host.canRoll && host.args.crouching) {
        // const scanDist  = radius + Math.abs(host.args.gSpeed);
        const direction = Math.sign(host.args.gSpeed || host.args.direction);
        const max = Math.abs(host.args.gSpeed);
        const step = 1;
        host.pause(true);
        let iter = 0;
        const dirs = [0, 0, Math.PI];
        const filterBlockers = x => x.args !== host.args && x.callCollideHandler(host) && x.solid;
        for (let s = 0; s < max; s += step) {
          if (host.args.height > 8 && host.args.modeTime > 1) {
            if (!host.args.gSpeed) {
              host.args.pushing = false;
            }
            const headPoint = host.rotatePoint(radius * -direction, host.args.height);
            let headBlock = host.getMapSolidAt(host.args.x + headPoint[0], host.args.y + headPoint[1]);
            if (Array.isArray(headBlock)) {
              headBlock = headBlock.filter(filterBlockers).length;
            }
            if (headBlock) {
              if (host.args.mode === MODE_CEILING) {
                host.args.x += radius * Math.sign(host.args.gSpeed);
                host.args.y += host.args.height;
                host.args.mode = MODE_FLOOR;
              }
              host.args.pushing = Math.sign(host.args.gSpeed);
              break;
            } else {
              host.args.pushing = false;
            }
            let waistBlock = false;
            if (!host.noClip && host.controllable && host.args.groundAngle === 0) {
              const waistPoint = host.rotatePoint(-radius * Math.sign(host.args.gSpeed), host.args.height * 0.5);
              waistBlock = host.getMapSolidAt(host.args.x + waistPoint[0], host.args.y + waistPoint[1]);
              if (Array.isArray(waistBlock)) {
                waistBlock = waistBlock.filter(filterBlockers).length || false;
              }
              if (waistBlock !== false && waistBlock <= radius) {
                if (host.args.mode === MODE_CEILING) {
                  host.args.x += radius * Math.sign(host.args.gSpeed);
                  host.args.y += host.args.rollingeight || host.args.height;
                  host.args.mode = MODE_FLOOR;
                  host.args.gSpeed = 0;
                } else if (host.args.mode === MODE_FLOOR) {
                  host.args.gSpeed = Math.min(1, waistBlock) * Math.sign(host.args.gSpeed);
                }
                host.args.gSpeed && (host.args.pushing = Math.sign(host.args.gSpeed));
                break;
              }
            }

            // if(!headBlock && !waistBlock)
            // {
            // 	host.args.pushing = 0;
            // }
          }

          for (const behavior of host.behaviors) {
            behavior.movedGround && behavior.movedGround(host);
          }
          if (host.args.falling || host.locked) {
            return;
          }
          nextPosition = this.findNextStep(host, step * direction);
          if (!nextPosition) {
            break;
          }
          if (nextPosition[3]) {
            host.args.moving = false;
            host.args.gSpeed = 0.15 * Math.sign(host.args.gSpeed);

            // if(host.args.mode === MODE_LEFT || host.args.mode === MODE_RIGHT)
            // {
            // 	host.args.mode = MODE_FLOOR;
            // 	host.lastAngles.splice(0, host.lastAngles.length, ...Array(host.angleAvg).fill(0));
            // }

            break;
          } else if (nextPosition[2] === true) {
            const gSpeed = host.args.gSpeed || 0;
            const gAngle = host.args.groundAngle || 0;
            host.args.standingLayer = null;
            let radius;
            let hRadius;
            switch (host.args.mode) {
              case MODE_FLOOR:
                radius = host.args.width / 2;

                // if(headBlock)
                // {
                // 	host.args.x += (headBlock - host.args.width) * Math.sign(gSpeed);
                // }
                // else

                const stepsLeft = Math.max(1, Math.abs(gSpeed) - Math.abs(this.stepsTaken)) || 1;
                const impulseLeft = stepsLeft * Math.sign(gSpeed || 0);
                if (0 && stepsLeft < radius) {
                  host.args.x += (radius - stepsLeft) * Math.sign(gSpeed);
                } else {
                  host.args.x += impulseLeft * Math.cos(gAngle);
                  host.args.y += -impulseLeft * Math.sin(gAngle);
                }
                host.args.xSpeed = gSpeed * Math.cos(gAngle);
                host.args.ySpeed = -gSpeed * Math.sin(gAngle);
                host.args.float = host.args.float < 0 ? host.args.float : 1;
                let falling = !!host.args.gSpeed;
                if (this.checkBelow(host, host.args.x, host.args.y)) {
                  host.args.gSpeed = gSpeed;
                  host.args.xSpeed = 0;
                  host.args.ySpeed = 0;
                  falling = false;
                  if (host.canRoll && host.yAxis > 0.55) {
                    host.args.rolling = true;
                  }
                }
                host.args.falling = falling;
                host.args.ignore = 2;
                break;
              case MODE_CEILING:
                host.args.y += host.args.height;
                host.args.y++;
                host.args.float = host.args.float < 0 ? host.args.float : 1;
                host.args.falling = true;

                // host.args.groundAngle  = Math.PI;
                // host.args.displayAngle = Math.PI;

                host.args.mode = MODE_FLOOR;
                host.args.xSpeed = -gSpeed * Math.cos(gAngle);
                host.args.ySpeed = gSpeed * Math.sin(gAngle);
                host.args.x += -gSpeed * Math.cos(gAngle);
                host.args.y += gSpeed * Math.sin(gAngle);
                host.lastAngles.splice(0, host.lastAngles.length, ...Array(host.angleAvg).fill(0));
                host.args.direction *= -1;
                if (!host.args.rolling && !host.args.grinding) {
                  host.args.facing = host.args.facing === 'left' ? 'right' : 'left';
                }
                host.args.ignore = 3;
                break;
              case MODE_LEFT:
                radius = host.args.width / 2;
                hRadius = host.args.height / 2;
                if (!host.args.climbing) {
                  if (Math.abs(host.args.gSpeed) < 2 && !host.args.rolling) {
                    if (host.args.gSpeed < 0) {
                      // host.args.x -= host.args.direction;
                      // host.args.y -= hRadius * Math.sign(host.args.gSpeed);
                      // host.args.y -= host.args.gSpeed + -2;
                      // host.args.groundAngle = 0;
                    } else {
                      host.args.x += radius;
                    }
                  } else {
                    host.args.ignore = -3;
                    host.args.x += host.controllable ? radius : 1;
                    // host.args.y += hRadius;
                  }

                  host.args.xSpeed = gSpeed * Math.sin(gAngle);
                  host.args.ySpeed = gSpeed * Math.cos(gAngle);
                  host.args.x += gSpeed * Math.sin(gAngle);
                  host.args.y += gSpeed * Math.cos(gAngle);
                  if (host.isVehicle || !host.args.rolling && !host.args.grinding) {
                    host.args.groundAngle = -Math.PI * 0.5;
                  } else {
                    host.args.x += radius;
                  }
                  host.args.mode = MODE_FLOOR;
                  host.args.cameraIgnore = 30;

                  // host.onNextFrame(() => {
                  // });
                }

                // host.args.mode = MODE_FLOOR;
                host.args.falling = true;
                break;
              case MODE_RIGHT:
                radius = host.args.width / 2;
                hRadius = host.args.height / 2;
                if (!host.args.climbing) {
                  if (Math.abs(host.args.gSpeed) < 3 && !host.args.rolling) {
                    if (host.args.gSpeed > 0) {
                      // host.args.x -= host.args.direction;
                      // host.args.y -= hRadius * Math.sign(host.args.gSpeed);
                      // host.args.y -= host.args.gSpeed + 2;
                      // host.args.groundAngle = 0;
                    } else {
                      host.args.x -= radius;
                    }
                  } else {
                    host.args.ignore = -3;
                    host.args.x -= host.controllable ? radius : 1;
                    // host.args.y += hRadius;
                  }

                  host.args.xSpeed = -gSpeed * Math.sin(gAngle);
                  host.args.ySpeed = -gSpeed * Math.cos(gAngle);
                  host.args.x += -gSpeed * Math.sin(gAngle);
                  host.args.y += -gSpeed * Math.cos(gAngle);
                  if (host.isVehicle || !host.args.rolling && !host.args.grinding) {
                    host.args.groundAngle = Math.PI * 0.5;
                  } else {
                    host.args.x -= radius;
                  }
                  host.args.mode = MODE_FLOOR;
                  host.args.cameraIgnore = 30;

                  // host.onNextFrame(() => {
                  // });
                }

                // host.args.mode = MODE_FLOOR;
                host.args.falling = true;
                break;
            }

            // host.args.gSpeed = 0;

            break;
          } else if (!nextPosition[0] && !nextPosition[1]) {
            host.args.moving = false;
            switch (host.args.mode) {
              case MODE_FLOOR:
              case MODE_CEILING:
                host.args.gSpeed = 0;
                break;
              case MODE_LEFT:
              case MODE_RIGHT:
                break;
            }
          } else if ((nextPosition[0] || nextPosition[1]) && !host.rotateLock) {
            host.args.moving = true;
            if (!host.keepAngle) {
              let newAngle = nextPosition[0] ? Math.atan(nextPosition[1] / nextPosition[0]) : Math.sign(nextPosition[1]) * Math.PI / 2;
              if (Math.abs(host.args.angle - newAngle) >= Math.PI * 0.38) {
                const sensorSpread = 6;
                const backPositionWide = this.findNextStep(host, -sensorSpread);
                const forePositionWide = this.findNextStep(host, sensorSpread);
                // console.log({mode: host.args.mode, nextPosition, forePositionWide, backPositionWide});
                if (backPositionWide[1] === nextPosition[1] || forePositionWide[1] === nextPosition[1]) {
                  newAngle = 0;
                }
              }
              host.args.angle = newAngle;
              host.lastAngles.unshift(host.args.angle);
              host.lastAngles.splice(host.angleAvg);

              // console.log(newAngle, host.args.angle / Math.PI, host.groundTime);
            }
          }

          if (!host.rotateLock) {
            switch (host.args.mode) {
              case MODE_FLOOR:
                host.args.x += nextPosition[0];
                host.args.y -= nextPosition[1];
                break;
              case MODE_CEILING:
                host.args.x -= nextPosition[0];
                host.args.y += nextPosition[1];
                break;
              case MODE_LEFT:
                host.args.x += nextPosition[1];
                host.args.y += nextPosition[0];
                break;
              case MODE_RIGHT:
                host.args.x -= nextPosition[1];
                host.args.y -= nextPosition[0];
                break;
            }
            if (host.args.angle > Math.PI / 4 && host.args.angle < Math.PI / 2) {
              const lastAngles = host.lastAngles.map(n => Number(n) - Math.PI / 2);
              Object.defineProperty(lastAngles, _Bindable.Bindable.NoGetters, {
                value: true
              });
              host.lastAngles = lastAngles;
              switch (host.args.mode) {
                case MODE_FLOOR:
                  host.args.mode = MODE_RIGHT;
                  break;
                case MODE_RIGHT:
                  host.args.mode = MODE_CEILING;
                  break;
                case MODE_CEILING:
                  host.args.mode = MODE_LEFT;
                  break;
                case MODE_LEFT:
                  host.args.mode = MODE_FLOOR;
                  break;
              }
              host.args.groundAngle -= Math.PI / 2;
            } else if (host.args.angle < -Math.PI / 4 && host.args.angle > -Math.PI / 2) {
              const orig = host.args.mode;
              const lastAngles = host.lastAngles.map(n => Number(n) + Math.PI / 2);
              Object.defineProperty(lastAngles, _Bindable.Bindable.NoGetters, {
                value: true
              });
              host.lastAngles = lastAngles;
              switch (host.args.mode) {
                case MODE_FLOOR:
                  host.args.mode = MODE_LEFT;
                  break;
                case MODE_RIGHT:
                  host.args.mode = MODE_FLOOR;
                  break;
                case MODE_CEILING:
                  host.args.mode = MODE_RIGHT;
                  break;
                case MODE_LEFT:
                  host.args.mode = MODE_CEILING;
                  break;
              }
              host.args.groundAngle = Number(host.args.groundAngle) + Math.PI / 2;
            }
          } else {
            host.args.x += nextPosition[0];
            host.args.y -= nextPosition[1];
          }
        }
        if (host.args.pushing) {
          host.args.gSpeed = Math.sign(host.args.gSpeed);
        }
        const hRadius = Math.round(host.args.height / 2);
        let popOut = 16;
        if (!host.args.static && host.args.mode === MODE_FLOOR) {
          while ((host.args.gSpeed <= 0 || host.args.modeTime < 3) && host.getMapSolidAt(host.args.x - radius, host.args.y - hRadius, false) && popOut > 0) {
            // host.args.direction = 0;
            // host.args.gSpeed = 0;
            host.args.x++;
            popOut--;
          }
          while ((host.args.gSpeed >= 0 || host.args.modeTime < 3) && host.getMapSolidAt(host.args.x + radius, host.args.y - hRadius, false) && popOut > 0) {
            // host.args.direction = 0;
            // host.args.gSpeed = 0;
            host.args.x--;
            popOut--;
          }
        }
        wasPaused || host.pause(false);
        const pushFoward = host.xAxis && Math.sign(host.xAxis) === Math.sign(host.args.gSpeed);
        const friction = host.getLocalFriction();
        if (host.args.mode === MODE_FLOOR || host.args.mode === MODE_CEILING || host.args.gSpeed < 0 && host.args.mode === MODE_LEFT || host.args.gSpeed > 0 && host.args.mode === MODE_RIGHT) {
          const pushBack = host.xAxis && Math.sign(host.xAxis) !== Math.sign(host.args.gSpeed);
          const decel = friction * host.args.decel * (host.args.rolling && pushBack ? 3 : 0.75);
          if (!host.args.climbing && host.args.gSpeed && (!pushFoward || host.args.rolling)) {
            if (host.args.sliding) {} else if (host.args.grinding) {
              if (Math.abs(host.yAxis) > 0.5) {
                // host.args.gSpeed -= decel * 1/drag * 0.06125 * Math.sign(host.args.gSpeed);
              } else {
                host.args.gSpeed -= decel * 1 / drag * 0.125 * Math.sign(host.args.gSpeed);
              }
              if (Math.abs(host.args.gSpeed) > 40) {
                host.args.gSpeed = 40 * direction;
              }
            } else if (host.args.rolling) {
              host.args.gSpeed -= decel * 1 / drag * 0.06125 * Math.sign(host.args.gSpeed);
            } else if (!host.args.grinding && !host.args.rolling && (!host.xAxis || pushBack && Math.abs(host.args.gSpeed) > 6)) {
              const step = decel * 1 / drag * Math.sign(host.args.gSpeed);
              if (Math.abs(host.args.gSpeed) > Math.abs(step)) {
                host.args.gSpeed -= step;
              } else {
                host.args.gSpeed = 0;
              }
            }
            if (Math.abs(host.args.gSpeed) < 0.1 || pushBack && Math.abs(host.args.gSpeed) < 1) {
              host.args.gSpeed = 0;
            }
          }
        }

        // if(!pushFoward && Math.abs(host.args.gSpeed) < 1)
        // {
        // 	if(!host.args.climbing && !host.args.wallSticking)
        // 	{
        // 		// host.args.gSpeed = 0;
        // 	}
        // }

        let slopeFactor = 0;
        if (!host.args.climbing) {
          switch (host.args.mode) {
            case MODE_FLOOR:
              slopeFactor = host.args.groundAngle / (Math.PI / 2);
              if (direction > 0) {
                slopeFactor *= -1;
              }
              break;
            case MODE_CEILING:
              slopeFactor = -host.args.groundAngle / (Math.PI / 2);
              if (direction > 0) {
                slopeFactor *= -1;
              }
              break;
              break;
            case MODE_RIGHT:
              if (direction > 0) {
                slopeFactor = -1;
                slopeFactor -= host.args.groundAngle / (Math.PI / 2);
              } else {
                slopeFactor = 1;
                slopeFactor += host.args.groundAngle / (Math.PI / 2);
              }
              break;
            case MODE_LEFT:
              if (direction > 0) {
                slopeFactor = 1;
                slopeFactor -= host.args.groundAngle / (Math.PI / 2);
              } else {
                slopeFactor = -1;
                slopeFactor += host.args.groundAngle / (Math.PI / 2);
              }
              break;
          }
          if (host.args.grinding) {
            const speed = Math.abs(host.args.gSpeed);

            // const direction = Math.sign(host.args.gSpeed || host.xSpeedLast || 1);
            const direction = Math.sign(host.args.gSpeed);
            host.args.direction = direction;

            // if(Math.sign(host.args.gSpeed) !== Math.sign(host.args.direction))
            // {
            // 	host.args.gSpeed = 0;
            // }

            if (speed < 6) {
              host.args.gSpeed = 6 * direction;
            } else if (speed > 40) {
              host.args.gSpeed = 40 * direction;
            } else if (slopeFactor < 0) {
              host.args.gSpeed *= 1.0000 - (0 - slopeFactor / 2 * 0.015);
            } else if (slopeFactor > 0) {
              host.args.gSpeed *= 1.0015 * (1 + slopeFactor / 2 * 0.045);
            } else {
              host.args.gSpeed += 0.1 * direction;
            }
          } else if (host.args.rolling || host.canRoll && host.args.crouching) {
            if (slopeFactor > 0 && host.args.modeTime > 3) {
              if (host.args.gSpeed || Math.abs(slopeFactor) > 0.25) {
                host.args.gSpeed += 0.60 * slopeFactor * direction;
              }
              if (Math.abs(host.args.gSpeed) < 1) {
                host.args.gSpeed = (1 + Math.pow(slopeFactor, 2)) * Math.sign(host.args.gSpeed);
              }
              const regions = host.controllable || host.args.pushed || host.isVehicle ? host.viewport.regionsAtPoint(host.args.x, host.args.y) : [];
              for (const region of regions) {
                if (!region.args.maxSpeed || region.args.maxSpeed < 0) {
                  continue;
                }
                if (region.args.maxSpeed < Math.abs(host.args.gSpeed)) {
                  host.args.gSpeed = region.args.maxSpeed * Math.sign(host.args.gSpeed);
                }
              }
              if (Math.abs(slopeFactor) > 0.25 && Math.abs(host.args.gSpeed) < 2 && Math.abs(Math.sign(host.args.gSpeed) - Math.sign(direction)) < 2) {
                host.args.gSpeed = 2 * direction;
              }
            } else if (slopeFactor < -0.30 || slopeFactor < 0 && host.args.gSpeed) {
              if (Math.abs(host.args.gSpeed) < 10) {
                const slopeVector = slopeFactor * direction;
                if (host.args.gSpeed || slopeFactor < -0.075) {
                  if (Math.sign(slopeVector) === Math.sign(host.args.gSpeed)) {
                    host.args.gSpeed += 1.65 * slopeFactor * direction;
                  } else {
                    host.args.gSpeed += 0.25 * slopeFactor * direction;
                  }
                }
              } else {
                host.args.gSpeed += 0.65 * slopeFactor * direction;
              }
            }
          } else if (!host.stayStuck) {
            if (slopeFactor > 0.25) {
              if (Math.abs(host.args.gSpeed) < host.args.gSpeedMax * 2) {
                host.args.gSpeed += 0.125 * slopeFactor * direction;
                if (Math.abs(host.args.gSpeed) < 2 && Math.abs(Math.sign(host.args.gSpeed) - Math.sign(direction)) < 2) {
                  host.args.gSpeed = 2 * direction;
                }
              }
            } else if (slopeFactor < -0.075) {
              const originalSign = Math.sign(host.args.gSpeed);
              if (Math.abs(host.args.gSpeed) < 10) {
                host.args.gSpeed += 0.30 * slopeFactor * direction;
              } else {
                // host.args.gSpeed += 0.15 * slopeFactor * direction;
              }
              if (Math.sign(host.args.gSpeed) !== originalSign) {
                host.args.ignore = host.args.ignore || 5;
                host.args.antiSkid = 10;
                host.args.gSpeed += Math.sign(host.args.gSpeed) * 0.5;
              }
            } else if (slopeFactor > 0 && friction < 0.75) {
              if (Math.abs(host.args.gSpeed) < 1) {
                host.args.gSpeed = direction;
              }
              host.args.gSpeed += direction * slopeFactor;
            }

            // let speedFactor = 1;

            // if(slopeFactor < 0 && Math.abs(host.args.gSpeed) < 2)
            // {
            // 	speedFactor = 0.99990 * (1 - (slopeFactor**2/4) / 2);
            // }
            // else if(slopeFactor > 1 && Math.abs(host.args.gSpeed) < host.args.gSpeedMax / 2)
            // {
            // 	speedFactor = 1.05000 * (1 + (slopeFactor**2/4) / 2);
            // }

            // if(host.args.mode === MODE_FLOOR && slopeFactor > 0.25)
            // {
            // 	if(Math.abs(host.args.gSpeed) < 1)
            // 	{
            // 		host.args.gSpeed = Math.sign(slopeFactor) * 4 * Math.sign(host.args.gSpeed);
            // 	}

            // 	host.args.gSpeed += slopeFactor * 1 * Math.sign(host.args.gSpeed);
            // }
            // else if(host.args.mode === MODE_FLOOR && slopeFactor < -0.25)
            // {
            // 	if(Math.abs(host.args.gSpeed) < 1)
            // 	{
            // 		host.args.gSpeed = Math.sign(-slopeFactor) * 4 * Math.sign(-host.args.gSpeed);
            // 	}

            // 	host.args.gSpeed += -slopeFactor * 1 * Math.sign(-host.args.gSpeed);
            // }

            // if(host.args.mode === MODE_LEFT && slopeFactor < 0.5)
            // {
            // 	if(Math.abs(host.args.gSpeed) < 1)
            // 	{
            // 		host.args.gSpeed = Math.sign(slopeFactor) * 4;
            // 	}

            // 	host.args.gSpeed += -slopeFactor * 1;
            // }

            // if(host.args.mode === MODE_RIGHT && slopeFactor < -0.5)
            // {
            // 	if(Math.abs(host.args.gSpeed) < 1)
            // 	{
            // 		host.args.gSpeed = Math.sign(slopeFactor) * 4;
            // 	}

            // 	host.args.gSpeed += slopeFactor * 1;
            // }

            if (Math.abs(host.args.gSpeed) < 1) {
              // if(slopeFactor <= -1)
              // {
              // 	host.args.gSpeed *= -0.5;
              // 	host.args.ignore = host.args.ignore || 8;
              // }
            }
          }
        }
      }
      if (nextPosition && (nextPosition[0] !== false || nextPosition[1] !== false)) {} else {
        host.args.ignore = host.args.ignore || 1;
        if (host.args.falling) {
          // host.args.gSpeed = 0;
        }
      }
      host.args.heading = Math.sign(host.args.gSpeed);

      // if(host.controllable)
      // {
      // 	const radius = 0.5 * host.args.width;
      // 	const direction = Math.sign(host.args.xSpeed);
      // 	const height = Math.max(host.args.height, 0);

      // 	const headPoint = host.rotatePoint(0, height * 0.75);
      // 	// const headPoint = host.rotatePoint(radius * -direction, host.args.height * 0.75);

      // 	let jumpBlock = host.getMapSolidAt(host.x + headPoint[0], host.y + headPoint[1]);

      // 	if(Array.isArray(jumpBlock))
      // 	{
      // 		jumpBlock = !!jumpBlock.filter(a => !a.args.platform && !a.isVehicle).length;
      // 	}

      // 	if(!host.args.falling && this.checkBelow(host, host.x, host.y) && jumpBlock)
      // 	{
      // 		console.log(host.realAngle, host.args.groundAngle, host.args.mode);
      // 		console.log([host.x + headPoint[0], host.y + headPoint[1]]);
      // 		console.log(headPoint);

      // 		host.die();

      // 		return;
      // 	}
      // }
    }
  }, {
    key: "updateAirPosition",
    value: function updateAirPosition(host) {
      const xSpeedOriginal = host.args.xSpeed;
      const ySpeedOriginal = host.args.ySpeed;
      const originalAngle = host.airAngle;
      host.args.standingLayer = null;
      const viewport = host.viewport;
      const radius = Math.ceil(host.args.width / 2);
      const direction = Math.sign(host.args.xSpeed);
      const tileMap = host.viewport.tileMap;
      const airSpeed = Math.hypot(host.args.xSpeed, host.args.ySpeed);
      host.args.airSpeed = airSpeed;
      if (!airSpeed) {
        return;
      }
      if (host.fallTime > 8 && (host.controllable || host.isVehicle)) {
        let spinBack = 20;
        if (host.springing) {
          spinBack = 125;
        }
        host.args.groundAngle += -Math.sign(host.args.groundAngle) * 0.001 * spinBack;
      }
      if (Math.abs(host.args.groundAngle) < 0.08) {
        host.args.groundAngle = 0;
      }
      if (host.noClip) {
        if (host.args.falling) {
          host.xLast = host.args.x;
          host.yLast = host.args.y;
          host.args.x += host.args.xSpeed;
          host.args.y += host.args.ySpeed;
        }
        return;
      }
      if (host.args.jumping && host.args.ySpeed < 0 && host.args.ySpeed > -4) {
        // host.args.xSpeed -= ((host.args.xSpeed / 0.125) / 256);
        host.args.xSpeed -= host.args.xSpeed * (host.args.decel * 0.078125);
      }
      const upMargin = (host.args.flying ? host.args.height + host.args.yMargin : host.args.height) || 1;
      host.upScan = true;
      const upScanDist = host.args.ySpeed < 0 ? -host.args.ySpeed + upMargin : 0;

      // const upDistanceL = host.castRay(
      // 	upScanDist
      // 	, -Math.PI / 2
      // 	, [-host.args.width/2 , 0]
      // 	, host.findSolid
      // );

      // const upDistanceR = host.castRay(
      // 	upScanDist
      // 	, -Math.PI / 2
      // 	, [host.args.width/2, 0]
      // 	, host.findSolid
      // );

      // window.logPoints = upScanDist && true;

      if (host.viewport && host.viewport.args.debugEnabled) {
        window.logPoints = (x, y, label) => host.viewport.args.plot.addPoint(x, y, 'up-l-scan ' + label);
      }
      const upDistanceL = host.castRayQuick(upScanDist, -Math.PI / 2, [host.args.width * -0.5 + 1, 0]);

      // if(host.viewport && host.viewport.args.debugEnabled)
      // {
      // 	window.logPoints = (x,y,label) => host.viewport.args.plot.addPoint(x,y,'up-r-scan '+label);
      // }

      const upDistanceR = host.castRayQuick(upScanDist, -Math.PI / 2, [host.args.width * 0.5 + -1, 0]);
      let upCollisionAngle = false;
      if (![upDistanceL, upDistanceR].some(x => x === false)) {
        upCollisionAngle = Math.atan2(upDistanceL - upDistanceR, host.args.width);
      }

      // if(host.viewport && host.viewport.args.debugEnabled)
      // {
      // 	window.logPoints = false;
      // }

      // if(upDistanceL !== upDistanceLQ || upDistanceR !== upDistanceRQ)
      // {
      // 	console.log(upDistanceL - upDistanceLQ, upDistanceR - upDistanceRQ);
      // 	console.log(321);
      // }

      const upDistance = upDistanceL || upDistanceR ? Math.min(...[upDistanceL, upDistanceR].filter(x => x !== false)) : false;
      host.upScan = false;
      let hits = [],
        distances = [];
      if (!host.args.hLock && !host.noClip) {
        const hScanDist = host.args.xSpeed;
        const rotScale = Math.abs(host.args.groundAngle) > Math.PI * 0.5 ? Math.cos(host.args.groundAngle) : 1;
        const foreDistanceHead = hScanDist ? this.scanForward(host, hScanDist, 0.9 * rotScale) : false;
        const foreDistanceWaist = hScanDist ? this.scanForward(host, hScanDist, 0.5 * rotScale) : false;
        const foreDistanceFoot = hScanDist ? this.scanForward(host, hScanDist, 0.1 * rotScale) : false;
        distances = [foreDistanceHead, foreDistanceWaist, foreDistanceFoot];

        // if(host.controllable && !host.args.falling && !host.args.rolling)
        // {
        // 	distances.push(foreDistanceFoot);
        // }

        hits = distances.filter(x => x !== false);
      }
      if (host.args.ySpeed && upDistance && host.lastLayer && host.lastLayer.offsetYChanged) {
        host.args.y += host.lastLayer.offsetYChanged + 1;
        host.args.ySpeed = host.lastLayer.offsetYChanged + 1;
        host.lastLayer = null;
        return;
      }
      const willStick = host.willStick || host.args.deepJump;
      // const xMove = host.xLast - host.args.x;

      if (upDistanceL && upDistanceR && upDistance <= upScanDist && (!host.args.flying || host.canStick)
      // && !host.args.flying
      && Math.abs(upCollisionAngle) < Math.PI / 4 && host.args.ySpeed <= 0) {
        host.args.y -= upDistance - host.args.height;
        if (host.args.ySpeed) {
          host.args.falling = true;
        }
        host.args.ySpeed = Math.max(0, host.args.ySpeed);
        return;
      }
      if (host.args.ySpeed >= 0 && distances[2] && distances[2] <= host.args.width * 0.5 && distances[1] === false && distances[0] === false) {
        const dir = Math.sign(xSpeedOriginal);
        if (!host.getMapSolidAt(host.args.x + host.args.width * 0.5 * dir, host.args.y + 4)) {
          host.args.x += dir * Math.abs(distances[2]);
          while (host.getMapSolidAt(host.args.x + host.args.width * 0.5 * dir, host.args.y)) {
            host.args.y--;
          }

          // host.args.falling = false;
          // host.args.gSpeed = host.args.xSpeed;
          return;
        }
      } else if (!host.willStick && (hits.length > 1 || distances[2])
      // && (upDistance === false || upDistance < (host.args.height + -host.args.ySpeed))
      ) {
        const xDirection = Math.sign(xSpeedOriginal);
        const minHit = -1 + Math.min(...hits);
        const width = host.args.width;
        const radius = 0.5 * width;
        // const shiftBy = width + -minHit;
        const shiftBy = radius + -minHit;
        const shift = shiftBy * -xDirection;

        // if(!isNaN(shift) && (!shift || Math.abs(shiftBy) < width || Math.sign(shift) !== Math.sign(host.args.xSpeed)))
        if (!isNaN(shift) && (!shift || Math.abs(shiftBy) < radius || Math.sign(shift) !== Math.sign(host.args.xSpeed))) {
          host.args.x += shift;
          host.args.flySpeed = 0;
          host.args.xSpeed = 0;
          host.args.gSpeed = 0;
          host.args.mode = MODE_FLOOR;
        }
        host.viewport && host.viewport.actorsAtPoint(host.x + (0 + radius) * xDirection, host.y, host.args.width, host.args.height).forEach(actor => {
          if (actor === host) {
            return;
          }
          actor.callCollideHandler(host, xDirection < 0 ? 1 : 3);
        });
      }

      // Object.assign(host.lastPointA, [host.args.x, host.args.y].map(Math.trunc));
      // Object.assign(host.lastPointB, [host.args.x, host.args.y].map(Math.trunc));

      const scanDist = airSpeed;

      // const airPointP = host.castRay(
      // 	scanDist
      // 	, host.airAngle
      // 	, this.findAirPointA
      // );

      // const airPointBP = host.rotateLock
      // 	? airPoint
      // 	: host.castRay(
      // 		scanDist
      // 		, host.airAngle
      // 		, [0, -3 * Math.sign(host.args.ySpeed || 1)]
      // 		, this.findAirPointB
      // 	);

      const tiny = 1;
      let airMag = host.castRayQuick(scanDist, originalAngle);
      if (host.viewport && host.viewport.args.debugEnabled) {
        window.logPoints = (x, y, label) => host.viewport.args.plot.addPoint(x, y, 'main-scan ' + label);
      }
      if (Math.abs(host.args.xSpeed) <= Math.abs(host.args.ySpeed)) {
        airMag = airMag !== false ? airMag : host.castRayQuick(scanDist, originalAngle, [-tiny, 0]);
        airMag = airMag !== false ? airMag : host.castRayQuick(scanDist, originalAngle, [+tiny, 0]);
      }

      // if(airMag && Math.abs(host.args.xSpeed) < Math.abs(host.args.ySpeed))
      // {
      // 	airMag -= Math.abs(Math.sin(originalAngle));
      // }
      // else if(airMag && Math.abs(host.args.xSpeed) > Math.abs(host.args.ySpeed))
      // {
      // 	airMag -= Math.abs(Math.cos(originalAngle));
      // }

      const airPointQ = airMag !== false && [Math.cos(originalAngle) * airMag + host.args.x, Math.sin(originalAngle) * airMag + host.args.y];
      let airPointBQ = airPointQ;
      if (!host.rotateLock) {
        if (host.viewport && host.viewport.args.debugEnabled) {
          window.logPoints = (x, y, label) => host.viewport.args.plot.addPoint(x, y, 'alt-scan ' + label);
          ;
        }
        const bOffset = -3 * Math.sign(host.args.ySpeed || 1);
        const airMag = host.castRayQuick(scanDist, originalAngle, [0, bOffset]);
        airPointBQ = airMag !== false ? [Math.cos(originalAngle) * airMag + host.args.x, Math.sin(originalAngle) * airMag + host.args.y + bOffset] : airPointBQ;
      }
      if (host.viewport && host.viewport.args.debugEnabled) {
        window.logPoints = false;
      }
      const airPoint = airPointQ;
      const airPointB = airPointBQ;
      host.willJump = false;
      let blockers = false;
      let collisionAngle = false;
      if (![airPoint, airPointB].some(x => x === false)) {
        collisionAngle = Math.atan2(airPoint[1] - airPointB[1], airPoint[0] - airPointB[0]);
      }
      if (host.xLast !== host.args.x) {
        host.xLast = host.args.x;
      }
      if (host.yLast !== host.args.y) {
        host.yLast = host.args.y;
      }
      if (airPoint !== false) {
        let angleIsWall = false;
        if (xSpeedOriginal < 0) {
          const angle = Math.abs(collisionAngle - Math.PI / 2) % Math.PI;
          angleIsWall = Math.abs(airPoint[1] - airPointB[1]) > 1 && airPoint[0] >= -1 + airPointB[0] && angle < Math.PI / 4;
        }
        if (xSpeedOriginal > 0) {
          const angle = Math.abs(collisionAngle - Math.PI / 2) % Math.PI;
          angleIsWall = Math.abs(airPoint[1] - airPointB[1]) > 1 && airPoint[0] <= +1 + airPointB[0] && angle < Math.PI / 4;
        }
        const isLeft = angleIsWall && xSpeedOriginal < 0;
        const isRight = angleIsWall && xSpeedOriginal > 0;
        const solid = this.checkBelow(host, airPoint[0], airPoint[1] + 1);
        if (!host.willStick && host.args.mode === 0 && !angleIsWall) {
          // host.args.gSpeed = xSpeedOriginal || host.args.gSpeed;
          host.args.gSpeed = host.args.xSpeed;
          if (solid && _typeof(solid) === 'object') {
            if (solid.args && solid.args.treadmill) {
              host.args.gSpeed = 0;
            } else if (solid.offsetXChanged) {
              host.args.gSpeed -= solid.offsetXChanged;
            }
          }
        } else {
          airPoint[0] = Math.round(airPoint[0]);
          airPoint[1] = Math.round(airPoint[1]);
        }
        if (host.willStick) {
          airPoint[0] = Math.round(airPoint[0]);
          airPoint[1] = Math.round(airPoint[1]);
        }
        const stickX = airPoint[0];
        const stickY = airPoint[1];

        // let away = false;

        // if(!host.args.ySpeed || Math.sign(stickY - host.args.y) === Math.sign(host.args.ySpeed))
        // {
        // 	// host.args.xSpeed = 0;
        // 	// host.args.ySpeed = 0;

        // 	// if(host.args.flying && !angleIsWall && collisionAngle)
        // 	// {
        // 	// 	host.args.mode = MODE_CEILING;
        // 	// 	host.args.xSpeed *= -1;
        // 	// }
        // }
        // else
        // {
        // 	// host.args.y++;
        // 	away = true;
        // }

        // if(!host.viewport.tileMap.getSolid(stickX, stickY))
        // {
        // }

        if (host.removed) {
          return;
        }
        host.args.x = Math.round(stickX);
        host.args.y = Math.round(stickY);
        if (angleIsWall && !host.willStick) {
          host.args.x -= host.args.width * 0.5 * Math.sign(xSpeedOriginal);
          host.args.falling = true;
          if (hits.length > 2) {
            host.args.xSpeed = 0;
          }
        }
        blockers = host.getMapSolidAt(host.args.x + direction, host.args.y);
        if (Array.isArray(blockers)) {
          blockers = blockers.filter(a => a.callCollideHandler(host) !== false);
          if (!blockers.length) {
            blockers = false;
          }
        }
        if (!host.rotateLock) {
          if (upCollisionAngle !== false && upCollisionAngle < 0) {
            host.args.gSpeed = 0;
            host.args.mode = MODE_LEFT;
            host.args.groundAngle = 0;
            host.args.direction = 1;
            host.args.facing = 'right';
          } else if (upCollisionAngle !== false && upCollisionAngle > 0) {
            host.args.gSpeed = 0;
            host.args.mode = MODE_RIGHT;
            host.args.groundAngle = 0;
            host.args.direction = -1;
            host.args.facing = 'left';
          } else if ((host.willStick || !isLeft && !isRight) && !host.getMapSolidAt(host.args.x - direction, host.args.y) && !host.getMapSolidAt(host.args.x - direction, host.args.y + 1)) {
            if (isLeft) {
              host.args.gSpeed = 0;
              host.args.mode = MODE_LEFT;
              host.args.direction = 1;
              host.args.facing = 'right';
            } else if (isRight) {
              host.args.gSpeed = 0;
              host.args.mode = MODE_RIGHT;
              host.args.direction = -1;
              host.args.facing = 'left';
            } else if (upCollisionAngle !== false) {
              host.args.mode = MODE_CEILING;
            }
          }
        }

        // if(host.args.ySpeed < 0 && Math.abs(upCollisionAngle - Math.PI/2) < Math.PI/8)
        // {
        // 	return;
        // }

        const halfWidth = Math.floor(host.args.width / 2);
        const sensorSpread = 6;
        const backPosition = this.findNextStep(host, -sensorSpread * 0.5);
        const forePosition = this.findNextStep(host, sensorSpread * 0.5);
        const xSpeed = Math.trunc(host.args.xSpeed);
        if (xSpeed > 0 && forePosition && forePosition[3]) {
          if (!host.willStick) {
            host.args.x -= host.args.width;
          }
        } else if (xSpeed < 0 && backPosition && backPosition[3]) {
          if (!host.willStick) {
            host.args.x += host.args.width;
          }
        } else if (!forePosition || forePosition[0] !== false && forePosition[1] !== false || !backPosition || backPosition[0] !== false && backPosition[1] !== false) {
          let newAngle = 0;
          if (forePosition && backPosition) {
            var _forePosition$, _backPosition$, _forePosition$2, _backPosition$2;
            newAngle = (ySpeedOriginal < 0 ? -1 : 1) * Number(Math.atan2(((_forePosition$ = forePosition[1]) !== null && _forePosition$ !== void 0 ? _forePosition$ : 0) - ((_backPosition$ = backPosition[1]) !== null && _backPosition$ !== void 0 ? _backPosition$ : 0), ((_forePosition$2 = forePosition[0]) !== null && _forePosition$2 !== void 0 ? _forePosition$2 : 0) - ((_backPosition$2 = backPosition[0]) !== null && _backPosition$2 !== void 0 ? _backPosition$2 : 0)));
            if (Math.abs(newAngle) >= Math.PI * 0.25) {
              const backPositionWide = this.findNextStep(host, -sensorSpread);
              const forePositionWide = this.findNextStep(host, sensorSpread);
              if ((backPositionWide[1] === backPosition[1] || forePositionWide[1] === forePosition[1]) && !(forePosition[3] && forePositionWide[3] && backPosition[3] && backPositionWide[3])) {
                // console.log({forePosition, backPosition, forePositionWide, backPositionWide});
                newAngle = 0;
              } else {
                // console.log({forePosition, backPosition, forePositionWide, backPositionWide});
              }
            }
            if (host.ySpeedLast < 0) {
              newAngle *= -1;
            }
          }
          if (isNaN(newAngle)) {
            console.log(newAngle);
            throw new Error('angle is NAN!');
          }

          // const shallowLedgePoint = host.findNextStep(backPosition[1] < forePosition[1] ? 3 : -3);

          // let shallowLedge = false;

          // if(shallowLedgePoint[1] === Math.max(backPosition[1], forePosition[1]))
          // {
          // 	shallowLedge = true;
          // }

          // if(shallowLedge && Math.abs(forePosition[1] - backPosition[1]) > 2 * host.maxStep)
          // {
          // 	host.args.x += backPosition[1] < forePosition[1] ? -1 : 1;

          // 	host.args.ySpeed = ySpeedOriginal;

          // 	host.args.groundAngle = 0;
          // }
          // else
          if (angleIsWall && !host.willStick) {} else if (Math.abs(newAngle) < Math.PI / 2 + -Math.PI / 16 && forePosition && backPosition && forePosition[0] !== false && backPosition[0] !== false && forePosition[1] !== false && backPosition[1] !== false && !forePosition[2] && !backPosition[2] && !(forePosition[3] && backPosition[3])) {
            if (host.canRoll && (host.yAxis > 0.55 || host.args.dropDashCharge) && !host.carrying.size) {
              host.args.rolling = true;
            }
            if (host.args.startled < 175) {
              host.args.falling = false;
              if (host.viewport.settings.rumble && !host.controller.willRumble) {
                host.controller.rumble && host.controller.rumble({
                  duration: 80,
                  strongMagnitude: 0,
                  weakMagnitude: Math.min(40, Math.max(Math.abs(host.args.ySpeed * 10), 10)) / 40
                });
              }
            }
            const qPi = Math.PI * 0.25;
            const landAngle = newAngle;
            if (newAngle < -qPi) {
              host.args.mode = MODE_LEFT;
              newAngle += qPi;
            } else if (newAngle > qPi) {
              host.args.mode = MODE_RIGHT;
              newAngle -= qPi;
            }
            host.args.groundAngle = newAngle;
            host.lastAngles.splice(0, host.lastAngles.length, ...Array(host.angleAvg).fill(newAngle));
            // host.args.ignore = host.args.ignore || 5;

            const slopeDir = -landAngle / (Math.PI * 0.4);
            let gSpeed = 0;
            gSpeed += xSpeedOriginal;
            gSpeed += ySpeedOriginal * slopeDir;
            if (blockers && blockers.length) {
              gSpeed = 0;
            }
            if (host.args.mode % 2 == 1) {
              // gSpeed *=-1;
            }

            // if(ySpeedOriginal)
            // {
            // 	gSpeed *= 0.75;
            // }

            if (_typeof(solid) === 'object') {
              if (!Array.isArray(solid)) {
                host.args.standingLayer = solid;
              }
              if (solid.offsetXChanged) {
                gSpeed -= solid.offsetXChanged;
                host.args.x += solid.offsetXChanged;
              }
            }
            if (gSpeed && !host.args.climbing && (!host.args.standingOn || !host.args.standingOn.args.treadmill)) {
              host.args.gSpeed = gSpeed;
              if (host.args.mode === 2) {
                host.args.gSpeed *= -1;
              }
            }

            // host.args.x += gSpeed < 0 ? backPosition[0] : forePosition[0];
            // host.args.y += gSpeed < 0 ? backPosition[1] : forePosition[1];

            // host.args.xSpeed = 0;
            // host.args.ySpeed = 0;
          } else if (!host.args.dead && host.args.startled < 175 && host.args.ySpeed > 0 && (forePosition && forePosition[2] && (!backPosition || !backPosition[3]) || (!forePosition || !forePosition[3]) && backPosition && backPosition[2])) {
            // const speed = xSpeedOriginal || host.xSpeedLast;
            const speed = xSpeedOriginal;
            host.args.falling = false;
            host.args.gSpeed = speed;

            // host.args.xSpeed = 0;
            // host.args.ySpeed = 0;

            host.args.float = host.args.float || 1;
            host.args.x += forePosition[0];
            host.args.y -= forePosition[1];
            if (host.viewport.settings.rumble && !host.controller.willRumble) {
              host.controller.rumble && host.controller.rumble({
                duration: 80,
                strongMagnitude: 0,
                weakMagnitude: Math.min(40, Math.max(Math.abs(host.args.ySpeed * 10), 10)) / 40
              });
            }
            return;
          }
          if (Math.abs(host.args.gSpeed) < 1) {
            // host.args.gSpeed = 0; //Math.sign(host.args.gSpeed);
          }
        }
      } else if (host.args.ySpeed > 0) {
        if (host.args.mode === MODE_LEFT || host.args.mode === MODE_RIGHT) {
          const direction = host.args.mode === MODE_LEFT ? -1 : 1;
          host.args.direction = direction;
          host.args.groundAngle = Math.PI / 2 * direction;
        }

        // host.args.mode = MODE_FLOOR;

        if (!host.args.falling && !host.args.gSpeed) {
          // host.args.gSpeed = Math.floor(xSpeedOriginal || host.xSpeedLast);
          host.args.gSpeed = Math.floor(xSpeedOriginal);
        }
        if (airPoint && (yPointDir === ySpeedDir || !yPointDir && ySpeedDir === 1)) {
          host.args.x = Number(airPoint[0]);
          host.args.y = Number(airPoint[1]);
          host.args.falling = false;
          if (host.viewport.settings.rumble) {
            host.controller.rumble && host.controller.rumble({
              duration: 80,
              strongMagnitude: 0,
              weakMagnitude: Math.min(40, Math.max(Math.abs(host.args.ySpeed * 10), 10)) / 40
            });
          }
        }
      }
      if (!tileMap.getSolid(host.args.x + host.args.width / 2 * Math.sign(host.args.xSpeed), host.args.y, host.getCollisionMap())) {
        if (Math.abs(host.args.xSpeed) > host.args.xSpeedMax) {
          host.args.xSpeed = host.args.xSpeedMax * Math.sign(host.args.xSpeed);
        }
        if (Math.abs(host.args.ySpeed) > host.args.ySpeedMax) {
          host.args.ySpeed = host.args.ySpeedMax * Math.sign(host.args.ySpeed);
        }
      }
      if (airPoint === false) {
        if (host.args.xSpeed) {
          const edgeTest = host.willStick ? false : host.getMapSolidAt(host.args.x + (1 + radius) * Math.sign(host.args.xSpeed), host.args.y - host.args.height / 2);
          const topTest = host.getMapSolidAt(host.args.x, host.args.y - host.args.height);
          if (!edgeTest) {
            host.args.x = Number(host.args.x) + Number(host.args.xSpeed);
          }
          if (topTest) {
            // host.args.ySpeed += topTest.yOffsetChanged;
            host.args.y += 1;
          }
        }
        if (host.args.ySpeed) {
          if (0) {
            host.args.y = Math.round(Number(host.args.y) + Number(host.args.ySpeed));
          } else {
            host.args.y = Number(host.args.y) + Number(host.args.ySpeed);
          }
          if (host.args.flying && host.args.ySpeed < 0 && upDistance > 0) {
            host.args.y += upMargin - upDistance + 4;
            host.args.ySpeed = 0;
          }
        }
      } else if (host.viewport && host.ySpeedLast > 0) {
        const collMap = host.getCollisionMap();
        if (host.viewport.tileMap.getSolid(host.args.x, host.args.y, collMap) && !host.viewport.tileMap.getSolid(host.args.x, host.args.y - 1, collMap)) {
          host.args.y--;
        }
      }
      if (host.args.standingOn instanceof _PointActor.PointActor) {
        const groundTop = host.args.standingOn.args.y + -host.args.standingOn.args.height + -1;
        if (host.args.y < groundTop || host.args.ySpeed < 0) {
          host.args.standingOn = null;
        }
      }
    }
  }, {
    key: "checkDropDash",
    value: function checkDropDash(host) {
      if (host.dropDashCharge && host.args.mode === MODE_FLOOR) {
        const dropBoost = host.dropDashCharge * Math.sign(host.args.direction);
        host.dropDashCharge = 0;
        host.viewport.onFrameOut(1, () => {
          host.args.gSpeed += dropBoost;
          host.args.rolling = true;
        });
        const viewport = host.viewport;
        const dustParticle = new _Tag.Tag('<div class = "particle-dust">');
        const dustPoint = host.rotatePoint(host.args.gSpeed, 0);
        dustParticle.style({
          '--x': dustPoint[0] + host.args.x,
          '--y': dustPoint[1] + host.args.y,
          'z-index': 0,
          opacity: Math.random() * 2
        });
        viewport.particles.add(dustParticle);
        setTimeout(() => {
          viewport.particles.remove(dustParticle);
        }, 350);
      }
    }
  }, {
    key: "findDownSolid",
    value: function findDownSolid(i, point, actor) {
      if (!actor.viewport) {
        return;
      }
      const viewport = actor.viewport;
      const tileMap = viewport.tileMap;
      if (actor.args.mode === MODE_FLOOR && actor.args.groundAngle === 0 && (actor.controllable || actor.args.pushed || actor.isVehicle)) {
        const regions = actor.viewport.regionsAtPoint(point[0], point[1]);
        for (const region of regions) {
          if (-1 + point[1] === region.args.y + -region.args.height && Math.abs(actor.args.gSpeed) >= region.skimSpeed) {
            return -1 + i;
          }
        }
      }
      if (tileMap.getSolid(point[0], point[1], actor.getCollisionMap())) {
        return i;
      }
      const actors = viewport.actorsAtPoint(point[0], point[1]).filter(x => x.args !== actor.args && x.callCollideHandler(actor) && x.solid);
      if (actors.length > 0) {
        return i;
      }
    }
  }, {
    key: "findUpSpace",
    value: function findUpSpace(i, point, actor) {
      if (!actor.viewport) {
        return;
      }
      const viewport = actor.viewport;
      const tileMap = viewport.tileMap;
      const pointSolid = tileMap.getSolid(point[0], point[1], actor.getCollisionMap());
      if (pointSolid) {
        return;
      }
      const actors = viewport.actorsAtPoint(point[0], point[1]).filter(x => x.args !== actor.args && x.callCollideHandler(actor) && x.solid);
      if (actor.args.groundAngle <= 0) {
        const regions = actor.controllable || actor.args.pushed || actor.isVehicle ? actor.viewport.regionsAtPoint(point[0], point[1]) : [];
        for (const region of regions) {
          if (actors.length === 0 && !pointSolid) {
            if (actor.args.mode !== MODE_FLOOR || point[1] !== 1 + region.args.y + -region.args.height || Math.abs(actor.args.gSpeed) <= region.skimSpeed) {
              return i;
            }
          }
        }
      }
      if (actors.length === 0) {
        if (!pointSolid) {
          return i;
        }
      }
    }
  }, {
    key: "findNextStep",
    value: function findNextStep(host, offset) {
      if (!host.viewport) {
        return;
      }

      // if(host.stepCache[offset] !== undefined)
      // {
      // 	return host.stepCache[offset];
      // }

      const viewport = host.viewport;
      const tileMap = viewport.tileMap;
      const maxStep = host.maxStep * (host.args.falling ? 2 : 1);
      const radius = Math.max(host.args.width / 2, 1);
      const sign = Math.sign(offset);
      let downFirstSolid = false;
      let upFirstSpace = false;
      let prevUp = 0,
        prevDown = 0;
      let col = 0;
      for (; col < Math.abs(offset); col += 1) {
        downFirstSolid = false;
        upFirstSpace = false;
        let offsetPoint;
        const columnNumber = (1 + col) * sign;
        switch (host.args.mode) {
          case MODE_FLOOR:
            offsetPoint = [columnNumber, 1];
            break;
          case MODE_RIGHT:
            offsetPoint = [1, -columnNumber];
            break;
          case MODE_CEILING:
            offsetPoint = [-columnNumber, -1];
            break;
          case MODE_LEFT:
            offsetPoint = [-1, columnNumber];
            break;
        }
        downFirstSolid = host.castRay(maxStep // * (1+col)
        , host.downAngle, offsetPoint, this.findDownSolid);
        if (downFirstSolid === false) {
          return [false, false, true];
        }
        const downDiff = prevDown - downFirstSolid;
        if (Math.abs(downDiff) >= maxStep) {
          return [false, false, downDiff < 0, downDiff > 0];
        }
        if (downFirstSolid === 0) {
          let offsetPoint;
          switch (host.args.mode) {
            case MODE_FLOOR:
              offsetPoint = [columnNumber, 0];
              break;
            case MODE_RIGHT:
              offsetPoint = [0, -columnNumber];
              break;
            case MODE_CEILING:
              offsetPoint = [-columnNumber, 0];
              break;
            case MODE_LEFT:
              offsetPoint = [0, columnNumber];
              break;
          }
          const upLength = +1 + maxStep;

          // window.logPoints = (x,y,label) => host.viewport.args.plot.addPoint(x,y,'up-walk-space ' + label);

          upFirstSpace = host.castRay(upLength, host.upAngle, offsetPoint, this.findUpSpace);

          // window.logPoints = null;

          const upDiff = Math.abs(prevUp - upFirstSpace);
          if (upFirstSpace === false) {
            return [false, false, false, true];
          }
          if (upDiff >= maxStep) {
            return [false, false, false, true];
          }
          prevUp = upFirstSpace;
        } else {
          prevDown = downFirstSolid;
        }
        this.stepsTaken++;

        // if(upFirstSpace !== false)
        // {
        // 	host.stepCache[col * sign] = [col * sign, upFirstSpace, false];
        // }
        // else
        // {
        // 	host.stepCache[col * sign] = [col * sign, -downFirstSolid, false];
        // }
      }

      if (upFirstSpace !== false) {
        return [col * sign, upFirstSpace, false];
      }
      return [col * sign, -downFirstSolid, false];
    }
  }, {
    key: "castRay",
    value: function castRay() {
      let length = 1;
      let callback = () => {};
      let angle = Math.PI / 2;
      let offset = [0, 0];
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      switch (args.length) {
        case 2:
          length = args[0];
          callback = args[1];
          break;
        case 3:
          length = args[0];
          angle = args[1];
          callback = args[2];
          break;
        case 4:
          length = args[0];
          angle = args[1];
          offset = args[2];
          callback = args[3];
          break;
      }
      let hit = false;
      for (let i = 0; i < Math.floor(length); i++) {
        const bottom = [host.args.x + offset[0] + i * Math.cos(angle), host.args.y + offset[1] + i * Math.sin(angle)];
        const retVal = callback(i, bottom, host);
        if (retVal !== undefined) {
          return retVal;
        }
      }
      return false;
    }
  }, {
    key: "doJump",
    value: function doJump(host, force) {
      var _host$args$gSpeed;
      if (host.args.climbing && host.getMapSolidAt(host.args.x, host.args.y - host.args.height)) {
        host.args.y += host.args.height;
      }
      if (host.args.ignore || host.args.falling || !host.args.landed || host.args.float) {
        return;
      }
      const jumpEvent = new CustomEvent('jump', {
        cancelable: true,
        detail: {
          host: host,
          force: force
        }
      });
      if (!host.dispatchEvent(jumpEvent)) {
        return;
      }
      if (host.args.standingOn && host.args.standingOn.args.yForce) {
        force += Math.max(0, host.args.standingOn.args.yForce * 0.25);
      } else if (host.args.standingOn && host.args.standingOn.yLast) {
        force += Math.max(0, host.args.standingOn.yLast - host.args.standingOn.args.y);
      }
      const radius = host.args.width / 2;
      const scanRadius = Math.min(radius, 4);
      const backPosition = this.findNextStep(host, -scanRadius);
      const forePosition = this.findNextStep(host, +scanRadius);
      const sensorSpread = scanRadius * 2;
      let groundAngle = Math.atan2(backPosition[1] - forePosition[1], Math.ceil(sensorSpread));

      // let groundAngle = host.args.angle;

      host.args.ignore = 6;
      host.args.pushing = false;
      host.args.landed = false;
      host.args.falling = true;
      const originalMode = host.args.mode;
      switch (host.args.mode) {
        case MODE_FLOOR:
          host.args.y -= 16;
          break;
        case MODE_RIGHT:
          groundAngle += -Math.PI / 2;
          host.args.x += -host.args.width / 2;
          break;
        case MODE_CEILING:
          groundAngle += Math.PI;
          host.args.y += host.args.normalHeight || host.args.height;
          break;
        case MODE_LEFT:
          groundAngle += Math.PI / 2;
          host.args.x += host.args.width / 2;
          break;
      }
      let floorX = 0;
      let gSpeedReal = (_host$args$gSpeed = host.args.gSpeed) !== null && _host$args$gSpeed !== void 0 ? _host$args$gSpeed : 0;
      if (host.args.standingOn && host.args.standingOn.args.convey) {
        gSpeedReal += host.args.standingOn.args.convey;
      }
      if (host.args.standingOn && host.args.standingOn.args.trackX) {
        floorX = host.args.standingOn.args.xSpeed || host.args.standingOn.args.gSpeed;
      }
      host.args.standingOn = null;
      host.args.xSpeed = gSpeedReal * Math.cos(groundAngle);
      host.args.ySpeed = gSpeedReal * Math.sin(groundAngle);
      const jumpAngle = groundAngle - Math.PI / 2;
      let xJump = force * Math.cos(jumpAngle);
      let yJump = force * Math.sin(jumpAngle);
      if (Math.abs(xJump) < 0.01) {
        xJump = 0;
      }
      if (Math.abs(yJump) < 0.01) {
        yJump = 0;
      }
      host.args.airAngle = jumpAngle;
      host.args.xSpeed += xJump;
      host.args.ySpeed += yJump;
      host.args.jumpedAt = host.args.y;
      host.args.jumping = true;
      const tileMap = host.viewport.tileMap;
      if (tileMap.getSolid(host.args.x + host.args.width / 2 * Math.sign(host.args.xSpeed), host.args.y, host.getCollisionMap())) {
        // if(tileMap.getSolid(host.x + (1 + host.args.width / 2) * Math.sign(host.args.xSpeed), host.y, host.args.layer))
        // {
        // 	host.args.x -= 2 * Math.sign(host.args.xSpeed);
        // }

        host.args.xSpeed = 0;
      }
      host.args.rolling = false;
      host.args.mode = MODE_FLOOR;
      host.args.groundAngle = 0;
      host.args.gSpeed = 0;
      host.args.xSpeed += floorX;
    }
  }, {
    key: "impulse",
    value: function impulse(host, magnitude, direction) {
      let willFall = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      if (host.args.dead) {
        return;
      }
      host.impulseMag = magnitude;
      host.impulseDir = direction;
      host.impulseFal = willFall;
    }
  }, {
    key: "scanForward",
    value: function scanForward(host, speed) {
      let height = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.5;
      let scanActors = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
      const dir = Math.sign(speed);
      const radius = host.args.width / 2;
      const scanDist = Math.abs(speed);
      const startPoint = host.args.falling ? [0, -host.args.height * height] : host.rotatePoint(0, host.args.height * height);
      // ? [radius * -dir, -host.args.height * height]
      // : host.rotatePoint(radius * -dir, host.args.height * height);

      const angle = host.args.falling ? [Math.PI, 0, 0][dir + 1] : host.realAngle + [0, 0, Math.PI][dir + 1];
      return host.castRayQuick(host.args.falling
      // ? scanDist + host.args.width + 1
      ? scanDist + radius + 1 : scanDist + 1, angle, startPoint);
    }
  }, {
    key: "scanBottomEdge",
    value: function scanBottomEdge() {
      let direction = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      const tileMap = host.viewport.tileMap;
      const radius = host.args.width / 2;
      const collMap = host.getCollisionMap();
      const leftCorner = tileMap.getSolid(host.x - radius, host.y - 1, collMap);
      const rightCorner = tileMap.getSolid(host.x + radius, host.y - 1, collMap);
      if (leftCorner && rightCorner) {
        return;
      }
      return host.castRay(host.args.width, direction < 0 ? Math.PI : 0, [-direction * radius, 0], (i, point) => {
        const actors = host.viewport.actorsAtPoint(point[0], point[1]).filter(a => a.args !== host.args);
        if (!actors.length && !tileMap.getSolid(point[0], point[1] + 1, collMap)) {
          return i;
        }
      });
    }
  }, {
    key: "checkBelow",
    value: function checkBelow(host) {
      var _testX, _testY;
      let testX = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      let testY = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      testX = (_testX = testX) !== null && _testX !== void 0 ? _testX : host.args.x;
      testY = (_testY = testY) !== null && _testY !== void 0 ? _testY : host.args.y;
      const lPoint = [];
      const rPoint = [];
      const spread = 0;
      switch (host.args.mode) {
        case MODE_FLOOR:
          lPoint[0] = testX + spread;
          lPoint[1] = testY + 1;
          rPoint[0] = testX - spread;
          rPoint[1] = testY + 1;
          break;
        case MODE_LEFT:
          lPoint[0] = testX - 1;
          lPoint[1] = testY + spread;
          rPoint[0] = testX - 1;
          rPoint[1] = testY - spread;
          break;
        case MODE_CEILING:
          lPoint[0] = testX - spread;
          lPoint[1] = testY - 1;
          rPoint[0] = testX + spread;
          rPoint[1] = testY - 1;
          break;
        case MODE_RIGHT:
          lPoint[0] = testX + 1;
          lPoint[1] = testY + spread;
          rPoint[0] = testX + 1;
          rPoint[1] = testY - spread;
          break;
      }
      let below = host.getMapSolidAt(...lPoint);

      // if(!below)
      // {
      // 	below = this.getMapSolidAt(...rPoint);
      // }

      if (Array.isArray(below)) {
        below = below.filter(x => x.callCollideHandler(host) !== false);
      }
      return below;
    }
  }, {
    key: "onSpawned",
    value: function onSpawned(host, viewport) {
      if (!host.args.onLayer) {
        return;
      }
      const layerName = host.args.onLayer;
      const layers = viewport.tileMap.tileLayers;
      for (const layer of layers) {
        if (layer.name !== layerName) {
          continue;
        }
        host.args.standingLayer = layer;
        break;
      }
    }
  }, {
    key: "command_0",
    value: function command_0(host, button)
    // jump
    {
      if (host.args.hangingFrom && host.args.hangingFrom.unhook) {
        const drag = host.getLocalDrag();
        host.args.ySpeed = -host.args.jumpForce * drag * 0.75;
        host.args.hangingFrom.unhook(host);
        host.swing = false;
        return;
      }
      if (host.args.falling || host.willJump || host.args.dontJump) {
        if (host.args.standingOn && !host.args.standingOn.isVehicle) {
          if (host.args.ignore && host.args.ignore !== -4) {
            return;
          }
          host.viewport.auras.delete(host.args.standingOn);
          host.willJump = true;
          return;
        }
      }
      if (!host.willJump) {
        if (host.args.standingOn && host.args.standingOn.quickDrop) {
          host.ignores.set(host.args.standingOn, 15);
          host.args.ignore = 0;
        }
        host.willJump = true;
      }
    }
  }, {
    key: "release_0",
    value: function release_0(host, button) {
      if (host.args.float) {
        return;
      }
      if (host.args.jumping && !host.lightDashed && !host.dashed && host.args.ySpeed < -8) {
        host.args.ySpeed *= 0.5;
        return;
      }
      if (host.args.jumping && !host.lightDashed && !host.dashed && host.args.ySpeed < -4) {
        host.args.ySpeed = -4;
        // host.args.ySpeed *= 0.5;
      }
    }
  }, {
    key: "command_1",
    value: function command_1(host, button) {
      if (host.canRoll && host.args.gSpeed) {
        host.args.rolling = true;
      }
    }
  }, {
    key: "command_11",
    value: function command_11(host, button) {
      if (host.args.currentSheild && !(host.args.currentSheild instanceof StarSheild)) {
        const item = host.args.currentSheild;
        item.unequip && item.unequip(host);
        host.args.currentSheild = null;
      }
    }
  }]);
  return Platformer;
}();
exports.Platformer = Platformer;
});

;require.register("behavior/SkidDust.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SkidDust = void 0;
var _Tag = require("curvature/base/Tag");
var _Behavior2 = require("./Behavior");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let SkidDust = /*#__PURE__*/function (_Behavior) {
  _inherits(SkidDust, _Behavior);
  var _super = _createSuper(SkidDust);
  function SkidDust(dustType) {
    var _this;
    _classCallCheck(this, SkidDust);
    _this = _super.call(this);
    _this.dustType = dustType || 'particle-dust';
    return _this;
  }
  _createClass(SkidDust, [{
    key: "update",
    value: function update(host) {
      if (host.args.falling || host.args.rolling || host.args.sliding || host.spindashCharge) {
        return;
      }
      if (host.args.wallSticking || host.args.climbing) {
        return;
      }
      const direction = host.args.direction;
      if (!Math.sign(host.args.gSpeed) || !Math.sign(direction)) {
        return;
      }
      if (Math.abs(host.args.gSpeed - direction) < 5) {
        return;
      }
      if (!host.alwaysSkidding) {
        if (Math.sign(host.args.gSpeed) === Math.sign(direction)) {
          return;
        }
        if (!host.skidding) {
          return;
        }
      }
      if (host.silentSkid) {
        return;
      }
      const viewport = host.viewport;
      const dustFreq = host.dustFreq || 3;
      if (viewport.args.frameId % dustFreq !== 0) {
        return;
      }
      const dustParticle = new _Tag.Tag(document.createElement('div'));
      dustParticle.classList.add(this.dustType);
      const dustDist = Math.sign(host.args.gSpeed) * host.dustDist || 0;

      // const dustPoint = host.rotatePoint(host.args.gSpeed, 0);
      const dustPoint = host.groundPoint;
      dustParticle.style({
        '--x': dustPoint[0] + dustDist,
        '--y': dustPoint[1],
        'z-index': 0,
        opacity: Math.random() * 0.25 + 0.5
      });
      viewport.particles.add(dustParticle);
      viewport.onFrameOut(20, () => {
        viewport.particles.remove(dustParticle);
      });
    }
  }]);
  return SkidDust;
}(_Behavior2.Behavior);
exports.SkidDust = SkidDust;
});

;require.register("behavior/Spindash.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Spindash = void 0;
var _Tag = require("curvature/base/Tag");
var _Behavior2 = require("./Behavior");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let Spindash = /*#__PURE__*/function (_Behavior) {
  _inherits(Spindash, _Behavior);
  var _super = _createSuper(Spindash);
  function Spindash() {
    _classCallCheck(this, Spindash);
    return _super.apply(this, arguments);
  }
  _createClass(Spindash, [{
    key: "command_0",
    value: function command_0(host, button) {
      if (host.args.falling || host.args.gSpeed) {
        return;
      }
      if (host.yAxis < 0.55 && !host.args.gSpeed || host.groundTime < 5) {
        return;
      }
      host.spindashCharge += 10;
      this.showDashDust(host);
      return false;
    }
  }, {
    key: "update",
    value: function update(host) {
      host.spindashCharge = host.spindashCharge || 0;
      if (host.spindashCharge) {
        if (host.spindashCharge < 1) {
          host.spindashCharge = 0;
        } else {
          host.args.animation = 'spindash';
          // host.args.animation = 'rolling';

          host.spindashCharge -= 0.2;
          if (this.dashDust) {
            this.dashDust.style({
              '--dashCharge': host.spindashCharge
            });
          }
          let dashCharge = host.spindashCharge / 20;
          if (dashCharge > 1) {
            dashCharge = 1;
          }

          // this.twist(120 * dashCharge * this.args.direction);
        }
      }

      if (!host.yAxis && host.spindashCharge) {
        if (host.spindashCharge < 5 && (host.args.modeTime < 45 || host.args.skidding)) {
          host.spindashCharge = 15;
        }
        const direction = host.args.facing === 'left' ? -1 : 1;
        let dashPower = host.spindashCharge / 40;
        if (dashPower > 1) {
          dashPower = 1;
        }
        host.args.rolling = true;
        const dashBoost = dashPower * 32;
        host.castRayQuick(dashBoost * Math.sign(direction), [Math.PI, 0, 0][1 + Math.sign(direction)], [0, host.args.height / 2]);
        if (Math.sign(direction) !== Math.sign(host.args.gSpeed)) {
          host.args.gSpeed = dashBoost * Math.sign(direction);
        } else {
          host.args.gSpeed += dashBoost * Math.sign(direction);
        }
        host.args.ignore = 1;
        host.args.rolling = true;
        host.spindashCharge = 0;
        if (this.dashDust) {
          this.dashDust.remove();
          this.dashDust = false;
        }
      }
    }
  }, {
    key: "showDashDust",
    value: function showDashDust(host) {
      const dustPoint = host.rotatePoint(0, 0);
      if (this.dashDust) {
        this.dashDust.style({
          '--x': dustPoint[0] + host.args.x,
          '--y': dustPoint[1] + host.args.y,
          '--direction': host.args.direction,
          '--dashCharge': host.spindashCharge
        });
        return;
      }
      const viewport = host.viewport;
      const dustParticle = new _Tag.Tag('<div class = "particle-spindash-dust">');
      dustParticle.style({
        '--x': dustPoint[0] + host.args.x,
        '--y': dustPoint[1] + host.args.y,
        '--direction': host.args.direction,
        '--dashCharge': host.spindashCharge
      });
      dustParticle.setAttribute('data-facing', host.args.facing);
      viewport.particles.add(dustParticle);
      this.dashDust = dustParticle;
    }
  }]);
  return Spindash;
}(_Behavior2.Behavior);
exports.Spindash = Spindash;
});

;require.register("behavior/SuperForm.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SuperForm = void 0;
var _Tag = require("curvature/base/Tag");
var _Behavior2 = require("./Behavior");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let SuperForm = /*#__PURE__*/function (_Behavior) {
  _inherits(SuperForm, _Behavior);
  var _super = _createSuper(SuperForm);
  function SuperForm() {
    _classCallCheck(this, SuperForm);
    return _super.apply(this, arguments);
  }
  _createClass(SuperForm, [{
    key: "command_3",
    value: function command_3(host, button) {
      var _host$args$minRingsSu, _host$args$minRingsHy;
      if (host.args.halted) {
        return;
      }
      const minRingsSuper = (_host$args$minRingsSu = host.args.minRingsSuper) !== null && _host$args$minRingsSu !== void 0 ? _host$args$minRingsSu : 50;
      const minRingsHyper = (_host$args$minRingsHy = host.args.minRingsHyper) !== null && _host$args$minRingsHy !== void 0 ? _host$args$minRingsHy : 75;
      if (host.isSuper && !host.isHyper && host.args.rings < minRingsHyper || !host.args.falling || !host.args.jumping || host.args.rings < minRingsSuper || host.args.ignore || host.isHyper) {
        host.isSuper = false;
        host.isHyper = false;
        host.setProfile();
        return;
      }
      if (!host.isHyper) {
        host.args.halted = 45;
        host.args.animation = 'transform';
        host.args.jumping = false;
        host.args.ySpeed = Math.min(host.args.ySpeed, 0);
        host.args.flying = false;
        host.args.dashed = false;
      }
      if (host.isSuper) {
        host.isHyper = !host.isHyper;
      } else {
        host.isSuper = !host.isSuper;
      }
      host.transformTime = 0;
      host.setProfile();
    }
  }, {
    key: "updateEnd",
    value: function updateEnd(host) {
      if (host.args.animation === 'transform') {
        host.transformTime++;
      } else if (host.transformTime > 0) {
        host.transformTime = 0;
      }
    }
  }]);
  return SuperForm;
}(_Behavior2.Behavior);
exports.SuperForm = SuperForm;
});

;require.register("cards/basic-controls.html", function(exports, require, module) {
module.exports = "<div class = \"control-card\">\n\t<span class = \"button-index\">\n\t\t<span class = \"arrow button arrow-west\"></span>\n\t\t/ <span class = \"arrow button arrow-east\"></span>\n\t\t/ <b>wasd</b>\n\t</span>\n\n\t<span class = \"button-index\">\n\t\t<span class = \"button ps ps-x\"></span>\n\t\t<span class = \"button xb xb-a\"></span>\n\t\t<b>space</b>\n\t</span>\n\n\t<span class = \"button-index\">\n\t\t<span class = \"button ps ps-o\"></span>\n\t\t<span class = \"button xb xb-b\"></span>\n\t\t<b>ctrl</b>\n\t</span>\n\n\t<span class = \"button-index\">\n\t\t<span class = \"button ps ps-s\"></span>\n\t\t<span class = \"button xb xb-x\"></span>\n\t\t<b>shift</b>\n\t</span>\n\n\t<span class = \"button-index\">\n\t\t<span class = \"button ps ps-t\"></span>\n\t\t<span class = \"button xb xb-y\"></span>\n\t\t<b>z</b>\n\t</span>\n\n\t<span class = \"button-index\">\n\t\t<span class = \"button ps ps-l1\"></span>\n\t\t<span class = \"button xb xb-lb\"></span>\n\t\t<b>q</b>\n\t</span>\n\n\t<span class = \"button-index\">\n\t\t<span class = \"button ps ps-r1\"></span>\n\t\t<span class = \"button xb xb-rb\"></span>\n\t\t<b>e</b>\n\t</span>\n</div>\n"
});

;require.register("cards/basic-moves.html", function(exports, require, module) {
module.exports = "<p><b>jump</b> + <b>jump</b> - fly / double jump action</p>\n\n<p><span class = \"arrow-button arrow-north\"></span> + <b>jump</b> - disengage vehicle</p>\n\n<!-- <p><span class = \"arrow-button arrow-south\"></span> + <b>jump</b> - spindash</p> -->\n"
});

;require.register("cards/plane-air-controls.html", function(exports, require, module) {
module.exports = "<div class = \"control-card\">\n\t<span class = \"button-index\">\n\t\t<span class = \"arrow button arrow-west\"></span>\n\t\t/ <span class = \"arrow button arrow-east\"></span>\n\t\t/ <b>wasd</b>\n\t\t- move\n\t</span>\n\n\t<span class = \"button-index\">\n\t\t<span class = \"button ps ps-x\"></span>\n\t\t<span class = \"button xb xb-a\"></span>\n\t\t<b>space</b>\n\t\t- double barrier\n\t</span>\n\n\t<span class = \"button-index\">\n\t\t<span class = \"button ps ps-o\"></span>\n\t\t<span class = \"button xb xb-b\"></span>\n\t\t<b>ctrl</b>\n\t\t- <span>no action</span>\n\t</span>\n\n\t<span class = \"button-index\">\n\t\t<span class = \"button ps ps-s\"></span>\n\t\t<span class = \"button xb xb-x\"></span>\n\t\t<b>shift</b>\n\t\t- <span>light dash</span>\n\t</span>\n\n\t<span class = \"button-index\">\n\t\t<span class = \"button ps ps-t\"></span>\n\t\t<span class = \"button xb xb-y\"></span>\n\t\t<b>z</b>\n\t\t- <span>no action</span>\n\t</span>\n\n\t<span class = \"button-index\">\n\t\t<span class = \"button ps ps-l1\"></span>\n\t\t<span class = \"button xb xb-lb\"></span>\n\t\t<b>q</b>\n\t\t- <span>air dash left</span>\n\t</span>\n\n\t<span class = \"button-index\">\n\t\t<span class = \"button ps ps-r1\"></span>\n\t\t<span class = \"button xb xb-rb\"></span>\n\t\t<b>e</b>\n\t\t- <span>air dash right</span>\n\t</span>\n\n</div>\n"
});

;require.register("cards/sonic-air-controls.html", function(exports, require, module) {
module.exports = "<div class = \"control-card\">\n\t<span class = \"button-index\">\n\t\t<span class = \"arrow button arrow-west\"></span>\n\t\t/ <span class = \"arrow button arrow-east\"></span>\n\t\t/ <b>wasd</b>\n\t\t- move\n\t</span>\n\n\t<span class = \"button-index\">\n\t\t<span class = \"button ps ps-x\"></span>\n\t\t<span class = \"button xb xb-a\"></span>\n\t\t<b>space</b>\n\t\t- double barrier\n\t</span>\n\n\t<span class = \"button-index\">\n\t\t<span class = \"button ps ps-o\"></span>\n\t\t<span class = \"button xb xb-b\"></span>\n\t\t<b>ctrl</b>\n\t\t- <span>no action</span>\n\t</span>\n\n\t<span class = \"button-index\">\n\t\t<span class = \"button ps ps-s\"></span>\n\t\t<span class = \"button xb xb-x\"></span>\n\t\t<b>shift</b>\n\t\t- <span>light dash</span>\n\t</span>\n\n\t<span class = \"button-index\">\n\t\t<span class = \"button ps ps-t\"></span>\n\t\t<span class = \"button xb xb-y\"></span>\n\t\t<b>z</b>\n\t\t- <span>no action</span>\n\t</span>\n\n\t<span class = \"button-index\">\n\t\t<span class = \"button ps ps-l1\"></span>\n\t\t<span class = \"button xb xb-lb\"></span>\n\t\t<b>q</b>\n\t\t- <span>air dash left</span>\n\t</span>\n\n\t<span class = \"button-index\">\n\t\t<span class = \"button ps ps-r1\"></span>\n\t\t<span class = \"button xb xb-rb\"></span>\n\t\t<b>e</b>\n\t\t- <span>air dash right</span>\n\t</span>\n\n</div>\n"
});

;require.register("cards/sonic-controls.html", function(exports, require, module) {
module.exports = "<div class = \"control-card\">\n\n\t<span class = \"button-index\">\n\t\t<span class = \"arrow button arrow-west\"></span>\n\t\t/ <span class = \"arrow button arrow-east\"></span>\n\t\t/ <b>wasd</b>\n\t\t- move\n\t</span>\n\n\t<span class = \"button-index\">\n\t\t<span class = \"button ps ps-x\"></span>\n\t\t<span class = \"button xb xb-a\"></span>\n\t\t<b>space</b>\n\t\t- jump\n\t</span>\n\n\t<span class = \"button-index\">\n\t\t<span class = \"button ps ps-o\"></span>\n\t\t<span class = \"button xb xb-b\"></span>\n\t\t<b>ctrl</b>\n\t\t- <span>spindash</span>\n\t</span>\n\n\t<span class = \"button-index\">\n\t\t<span class = \"button ps ps-s\"></span>\n\t\t<span class = \"button xb xb-x\"></span>\n\t\t<b>z</b>\n\t\t- <span>no action</span>\n\t</span>\n\n\t<span class = \"button-index\">\n\t\t<span class = \"button ps ps-t\"></span>\n\t\t<span class = \"button xb xb-y\"></span>\n\t\t<b>x</b>\n\t\t- <span>super</span>\n\t</span>\n\n\t<span class = \"button-index\">\n\t\t<span class = \"button ps ps-l1\"></span>\n\t\t<span class = \"button xb xb-lb\"></span>\n\t\t<b>q</b>\n\t\t- <span>no action</span>\n\t</span>\n\n\t<span class = \"button-index\">\n\t\t<span class = \"button ps ps-r1\"></span>\n\t\t<span class = \"button xb xb-rb\"></span>\n\t\t<b>e</b>\n\t\t- <span>no action</span>\n\t</span>\n\n</div>\n"
});

;require.register("console/task/Chao.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Chao = void 0;
var _Router = require("curvature/base/Router");
var _Task2 = require("subspace-console/Task");
var _Chao = require("../../actor/Chao");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let Chao = /*#__PURE__*/function (_Task) {
  _inherits(Chao, _Task);
  var _super = _createSuper(Chao);
  function Chao() {
    _classCallCheck(this, Chao);
    return _super.apply(this, arguments);
  }
  _createClass(Chao, [{
    key: "init",
    value: function init() {
      let command = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'list';
      if (typeof this['command_' + command] === 'function') {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
        this['command_' + command](...args);
      }
    }
  }, {
    key: "command_list",
    value: function command_list() {
      if (!Chao.viewport) {
        return;
      }
      const actors = Chao.viewport.actors;
      for (const actor of actors.items()) {
        if (!(actor instanceof _Chao.Chao)) {
          continue;
        }
        this.print(`${Number(actor.args.id)}) Chao "${actor.args.name}" is at ${actor.x}, ${actor.y}.`);
      }
    }
  }, {
    key: "command_name",
    value: function command_name(id, name) {
      if (!Chao.viewport) {
        return;
      }
      const chao = Chao.viewport.actorsById[id];
      if (!(chao instanceof _Chao.Chao)) {
        return;
      }
      chao.args.name = name;
    }
  }, {
    key: "command_color",
    value: function command_color(id) {
      if (!Chao.viewport) {
        return;
      }
      const chao = Chao.viewport.actorsById[id];
      if (!(chao instanceof _Chao.Chao)) {
        return;
      }
      for (var _len2 = arguments.length, pairs = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        pairs[_key2 - 1] = arguments[_key2];
      }
      this.recolor(chao, ...pairs);
    }
  }, {
    key: "recolor",
    value: function recolor(chao) {
      for (var _len3 = arguments.length, pairs = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
        pairs[_key3 - 1] = arguments[_key3];
      }
      while (pairs.length) {
        const colorId = pairs.shift();
        const color = pairs.shift();
        chao.customColors[colorId] = color;
      }
    }
  }, {
    key: "command_store",
    value: function command_store(id) {
      if (!Chao.viewport) {
        return;
      }
      const chao = Chao.viewport.actorsById[id];
      if (!(chao instanceof _Chao.Chao)) {
        return;
      }
      this.print(JSON.stringify(chao.store()));
    }
  }]);
  return Chao;
}(_Task2.Task);
exports.Chao = Chao;
_defineProperty(Chao, "viewport", null);
_defineProperty(Chao, "helpText", 'List the chao in the current map.');
});

;require.register("console/task/Impulse.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Impulse = void 0;
var _Task2 = require("subspace-console/Task");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let Impulse = /*#__PURE__*/function (_Task) {
  _inherits(Impulse, _Task);
  var _super = _createSuper(Impulse);
  function Impulse() {
    var _this;
    _classCallCheck(this, Impulse);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _defineProperty(_assertThisInitialized(_this), "title", 'Impulse task');
    _defineProperty(_assertThisInitialized(_this), "prompt", '..');
    return _this;
  }
  _createClass(Impulse, [{
    key: "init",
    value: function init(magnitude, angle) {
      if (!Impulse.viewport.controlActor) {
        return;
      }

      // this.print(`Pressing button ${buttonId} for ${ms} milliseconds...`);
      let actor = Impulse.viewport.controlActor;
      if (actor.standingOn && actor.standingOn.isVehicle) {
        actor = actor.standingOn;
      }
      actor.impulse(magnitude, angle, true);
    }
  }, {
    key: "write",
    value: function write(line) {
      this.print(line);
    }
  }]);
  return Impulse;
}(_Task2.Task);
exports.Impulse = Impulse;
_defineProperty(Impulse, "viewport", null);
_defineProperty(Impulse, "helpText", 'Apply an impulse to the player object.');
_defineProperty(Impulse, "useText", 'input magnitude angle');
});

;require.register("console/task/Input.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Input = void 0;
var _Task2 = require("subspace-console/Task");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let Input = /*#__PURE__*/function (_Task) {
  _inherits(Input, _Task);
  var _super = _createSuper(Input);
  function Input() {
    var _this;
    _classCallCheck(this, Input);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _defineProperty(_assertThisInitialized(_this), "title", 'Input task');
    _defineProperty(_assertThisInitialized(_this), "prompt", '..');
    return _this;
  }
  _createClass(Input, [{
    key: "init",
    value: function init(inputId) {
      let ms = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 500;
      let magnitude = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
      let frame,
        intervalId,
        onDone = () => {};
      if (!Input.viewport.controlActor) {
        return;
      }
      const actor = Input.viewport.controlActor;
      const controller = actor.controller;
      if (inputId[0] === 'a') {
        const axisId = inputId.substring(1);
        this.print(`Setting axis ${axisId} to ${magnitude} for ${ms} milliseconds...`);
        frame = {
          axes: _defineProperty({}, axisId, magnitude)
        };
        intervalId = setInterval(() => {
          controller.replay(frame);
          actor.readInput();
        }, 16);
        onDone = () => {
          frame.axes[axisId] = 0;
          controller.replay(frame);
          actor.readInput();
          clearInterval(intervalId);
        };
      }
      if (inputId[0] === 'b') {
        const buttonId = inputId.substring(1);
        this.print(`Pressing button ${buttonId} for ${ms} milliseconds...`);
        frame = {
          buttons: _defineProperty({}, buttonId, 1)
        };
        intervalId = setInterval(() => {
          frame.buttons[buttonId] = 1;
          controller.replay(frame);
          actor.readInput();
        }, 16);
        onDone = () => {
          frame.buttons[buttonId] = 0;
          controller.replay(frame);
          actor.readInput();
          clearInterval(intervalId);
        };
      }
      if (!frame) {
        return;
      }
      controller.replay(frame);
      actor.readInput();
      return new Promise(accept => {
        setTimeout(() => {
          onDone();
          accept();
        }, ms);
      });
    }
  }, {
    key: "write",
    value: function write(line) {
      this.print(line);
    }
  }]);
  return Input;
}(_Task2.Task);
exports.Input = Input;
_defineProperty(Input, "viewport", null);
_defineProperty(Input, "helpText", 'Press a button x for y milliseconds.');
_defineProperty(Input, "useText", 'input x y');
});

;require.register("console/task/Mark.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Mark = void 0;
var _Router = require("curvature/base/Router");
var _Task2 = require("subspace-console/Task");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let Mark = /*#__PURE__*/function (_Task) {
  _inherits(Mark, _Task);
  var _super = _createSuper(Mark);
  function Mark() {
    _classCallCheck(this, Mark);
    return _super.apply(this, arguments);
  }
  _createClass(Mark, [{
    key: "init",
    value: function init(x, y) {
      if (!Mark.viewport.controlActor) {
        return;
      }
      const actor = Mark.viewport.controlActor;
      this.print(`Character is at ${actor.x}, ${actor.y}.`);
      _Router.Router.setQuery('map', Mark.viewport.baseMap.replace(/^\/map\//, ''));
      _Router.Router.setQuery('start', `${Math.round(actor.x)},${Math.round(actor.y)}`);
    }
  }]);
  return Mark;
}(_Task2.Task);
exports.Mark = Mark;
_defineProperty(Mark, "viewport", null);
_defineProperty(Mark, "helpText", 'Mark the current actor\'s position in space as a start position.');
});

;require.register("console/task/Move.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Move = void 0;
var _Task2 = require("subspace-console/Task");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let Move = /*#__PURE__*/function (_Task) {
  _inherits(Move, _Task);
  var _super = _createSuper(Move);
  function Move() {
    var _this;
    _classCallCheck(this, Move);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _defineProperty(_assertThisInitialized(_this), "prompt", '..');
    return _this;
  }
  _createClass(Move, [{
    key: "init",
    value: function init(x, y) {
      if (!Move.viewport.controlActor) {
        return;
      }
      this.print(`Moving character to x, y...`);
      const actor = Move.viewport.controlActor;
      actor.args.x = parseFloat(x);
      actor.args.y = parseFloat(y);
      if (actor.viewport) {
        actor.viewport.setColCell(actor);
      }
    }
  }]);
  return Move;
}(_Task2.Task);
exports.Move = Move;
_defineProperty(Move, "viewport", null);
_defineProperty(Move, "helpText", 'Move the current actor to a position in space.');
_defineProperty(Move, "useText", 'move x y');
});

;require.register("console/task/Pos.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Pos = void 0;
var _Task2 = require("subspace-console/Task");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let Pos = /*#__PURE__*/function (_Task) {
  _inherits(Pos, _Task);
  var _super = _createSuper(Pos);
  function Pos() {
    _classCallCheck(this, Pos);
    return _super.apply(this, arguments);
  }
  _createClass(Pos, [{
    key: "init",
    value: function init(x, y) {
      if (!Pos.viewport.controlActor) {
        return;
      }
      const actor = Pos.viewport.controlActor;
      this.print(`Character is at ${actor.x}, ${actor.y}.`);
    }
  }]);
  return Pos;
}(_Task2.Task);
exports.Pos = Pos;
_defineProperty(Pos, "viewport", null);
_defineProperty(Pos, "helpText", 'Check the current actor\'s position in space.');
});

;require.register("console/task/Settings.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Settings = void 0;
var _Task2 = require("subspace-console/Task");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let Settings = /*#__PURE__*/function (_Task) {
  _inherits(Settings, _Task);
  var _super = _createSuper(Settings);
  function Settings() {
    var _this;
    _classCallCheck(this, Settings);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _defineProperty(_assertThisInitialized(_this), "prompt", '..');
    return _this;
  }
  _createClass(Settings, [{
    key: "init",
    value: function init(key, val) {
      const viewport = Settings.viewport;
      if (val !== undefined) {
        viewport.settings[key] = JSON.parse(val);
      }
      this.print(JSON.stringify(viewport.settings[key]));
    }
  }]);
  return Settings;
}(_Task2.Task);
exports.Settings = Settings;
_defineProperty(Settings, "viewport", null);
_defineProperty(Settings, "helpText", 'Get/set the values of settings variables.');
_defineProperty(Settings, "useText", 'set key val');
});

;require.register("console/task/Spawn.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Spawn = void 0;
var _Task2 = require("subspace-console/Task");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let Spawn = /*#__PURE__*/function (_Task) {
  _inherits(Spawn, _Task);
  var _super = _createSuper(Spawn);
  function Spawn() {
    _classCallCheck(this, Spawn);
    return _super.apply(this, arguments);
  }
  _createClass(Spawn, [{
    key: "init",
    value: function init(typeName) {
      if (!Spawn.viewport || !Spawn.viewport.controlActor) {
        return;
      }
      const palette = Spawn.viewport.objectPalette;
      const actor = Spawn.viewport.controlActor;
      if (!typeName) {
        this.print(Object.keys(palette).join(', '));
        return;
      }
      if (!(typeName in palette)) {
        this.print(`Type not found: "${typeName}".`);
        return;
      }
      const type = palette[typeName];
      const mouse = Spawn.viewport.mouse.position;
      Spawn.viewport.spawn.add({
        object: new type({
          x: mouse[0],
          y: mouse[1]
        })
      });
    }
  }]);
  return Spawn;
}(_Task2.Task);
exports.Spawn = Spawn;
_defineProperty(Spawn, "viewport", null);
_defineProperty(Spawn, "helpText", 'Spawn an object.');
});

;require.register("controller/Axis.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Axis = void 0;
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let Axis = /*#__PURE__*/function () {
  function Axis(_ref) {
    let _ref$deadZone = _ref.deadZone,
      deadZone = _ref$deadZone === void 0 ? 0 : _ref$deadZone,
      _ref$proportional = _ref.proportional,
      proportional = _ref$proportional === void 0 ? true : _ref$proportional;
    _classCallCheck(this, Axis);
    _defineProperty(this, "magnitude", 0);
    _defineProperty(this, "delta", 0);
    if (deadZone) {
      this.proportional = proportional;
      this.deadZone = deadZone;
    }
  }
  _createClass(Axis, [{
    key: "tilt",
    value: function tilt(magnitude) {
      if (this.deadZone && Math.abs(magnitude) >= this.deadZone) {
        magnitude = (Math.abs(magnitude) - this.deadZone) / (1 - this.deadZone) * Math.sign(magnitude);
      } else {
        magnitude = 0;
      }
      this.delta = Number(magnitude - this.magnitude).toFixed(3) - 0;
      this.magnitude = Number(magnitude).toFixed(3) - 0;
    }
  }, {
    key: "zero",
    value: function zero() {
      this.magnitude = this.delta = 0;
    }
  }]);
  return Axis;
}();
exports.Axis = Axis;
});

;require.register("controller/Button.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Button = void 0;
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let Button = /*#__PURE__*/function () {
  function Button() {
    _classCallCheck(this, Button);
    _defineProperty(this, "active", false);
    _defineProperty(this, "pressure", 0);
    _defineProperty(this, "delta", 0);
    _defineProperty(this, "time", 0);
  }
  _createClass(Button, [{
    key: "update",
    value: function update() {
      let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      if (this.pressure) {
        this.time++;
      } else if (!this.pressure && this.time > 0) {
        this.time = -1;
      } else if (!this.pressure && this.time < 0) {
        this.time--;
      }
      if (this.time < -1 && this.delta === -1) {
        this.delta = 0;
      }
    }
  }, {
    key: "press",
    value: function press(pressure) {
      this.delta = Number(pressure - this.pressure).toFixed(3) - 0;
      this.pressure = Number(pressure).toFixed(3) - 0;
      this.active = true;
      this.time = this.time > 0 ? this.time : 0;
    }
  }, {
    key: "release",
    value: function release() {
      // if(!this.active)
      // {
      // 	return;
      // }

      this.delta = Number(-this.pressure).toFixed(3) - 0;
      this.pressure = 0;
      this.active = false;
    }
  }, {
    key: "zero",
    value: function zero() {
      this.pressure = this.delta = 0;
      this.active = false;
    }
  }]);
  return Button;
}();
exports.Button = Button;
});

;require.register("controller/Controller.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Controller = void 0;
var _Axis = require("./Axis");
var _Button = require("./Button");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
const keys = {
  'Space': 0,
  'Enter': 0,
  'NumpadEnter': 0,
  'ControlLeft': 1,
  'ControlRight': 1,
  'ShiftLeft': 2,
  'ShiftRight': 2,
  'KeyZ': 3,
  'KeyQ': 4,
  'KeyE': 5,
  'Digit1': 6,
  'Digit3': 7,
  'KeyBackspace': 8,
  'KeyW': 12,
  'KeyA': 14,
  'KeyS': 13,
  'KeyD': 15,
  'KeyH': 112,
  'KeyJ': 113,
  'KeyK': 114,
  'KeyL': 115,
  'KeyP': 1020,
  'KeyO': 1209,
  'Pause': 1020,
  'Tab': 11,
  'ArrowUp': 12,
  'ArrowDown': 13,
  'ArrowLeft': 14,
  'ArrowRight': 15,
  'KeyMeta': 16,
  'Numpad4': 112,
  'Numpad2': 113,
  'Numpad8': 114,
  'Numpad6': 115,
  'Backquote': 1010,
  'NumpadAdd': 1011,
  'NumpadSubtract': 1012,
  'NumpadMultiply': 1013,
  'NumpadDivide': 1014,
  'PageUp': 1022,
  'PageDown': 1023,
  'Home': 1024,
  'End': 1025,
  'Escape': [1020, 1050],
  'KeyB': 1201
};
[...Array(12)].map((x, fn) => keys[`F${fn}`] = 2000 + fn);
const axisMap = {
  12: -1,
  13: +1,
  14: -0,
  15: +0,
  112: -2,
  113: +3,
  114: -3,
  115: +2
};
const buttonMap = {
  '-6': 14,
  '+6': 15,
  '-7': 12,
  '+7': 13
};
const buttonRemap = {
  0: 1200,
  1: 1201,
  9: 1209,
  4: 1022,
  5: 1023
};
let Controller = /*#__PURE__*/function () {
  function Controller(_ref) {
    let _ref$keys = _ref.keys,
      keys = _ref$keys === void 0 ? {} : _ref$keys,
      _ref$deadZone = _ref.deadZone,
      deadZone = _ref$deadZone === void 0 ? 0 : _ref$deadZone,
      _ref$gamepad = _ref.gamepad,
      gamepad = _ref$gamepad === void 0 ? null : _ref$gamepad,
      _ref$keyboard = _ref.keyboard,
      keyboard = _ref$keyboard === void 0 ? null : _ref$keyboard;
    _classCallCheck(this, Controller);
    this.deadZone = deadZone;
    Object.defineProperties(this, {
      buttons: {
        value: {}
      },
      pressure: {
        value: {}
      },
      axes: {
        value: {}
      },
      keys: {
        value: {}
      }
    });
  }
  _createClass(Controller, [{
    key: "update",
    value: function update() {
      let _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        gamepad = _ref2.gamepad;
      for (const i in this.buttons) {
        const button = this.buttons[i];
        button.update();
      }
      if (gamepad && this.willRumble) {
        if (_typeof(this.willRumble) !== 'object') {
          this.willRumble = {
            duration: 1000,
            strongMagnitude: 1.0,
            weakMagnitude: 1.0
          };
        }
        if (gamepad.vibrationActuator) {
          gamepad.vibrationActuator.playEffect("dual-rumble", this.willRumble);
        }
        this.willRumble = false;
      }
    }
  }, {
    key: "rumble",
    value: function rumble() {
      let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      this.willRumble = options;
    }
  }, {
    key: "readInput",
    value: function readInput(_ref3) {
      let keyboard = _ref3.keyboard,
        _ref3$gamepads = _ref3.gamepads,
        gamepads = _ref3$gamepads === void 0 ? [] : _ref3$gamepads;
      const tilted = {};
      const pressed = {};
      const released = {};
      for (let i = 0; i < gamepads.length; i++) {
        const gamepad = gamepads[i];
        if (!gamepad) {
          continue;
        }
        for (const i in gamepad.buttons) {
          const button = gamepad.buttons[i];
          if (button.pressed) {
            this.press(i, button.value);
            pressed[i] = true;
          }
        }
      }
      if (keyboard) {
        for (const i in [...Array(10)]) {
          if (pressed[i]) {
            continue;
          }
          if (keyboard.getKeyCode(i) > 0) {
            this.press(i, 1);
            pressed[i] = true;
          }
        }
        for (let keycode in keys) {
          if (pressed[keycode]) {
            continue;
          }
          let buttonIds = keys[keycode];
          if (!Array.isArray(buttonIds)) {
            buttonIds = keys[keycode] = [buttonIds];
          }
          for (const buttonId of buttonIds) {
            if (keyboard.getKeyCode(keycode) > 0) {
              this.press(buttonId, 1);
              pressed[buttonId] = true;
            }
          }
        }
      }
      for (let i = 0; i < gamepads.length; i++) {
        const gamepad = gamepads[i];
        if (!gamepad) {
          continue;
        }
        for (const i in gamepad.buttons) {
          if (released[i]) {
            continue;
          }
          if (pressed[i]) {
            continue;
          }
          const button = gamepad.buttons[i];
          if (!button.pressed) {
            this.release(i);
            released[i] = true;
          }
        }
      }
      if (keyboard) {
        for (const i in [...Array(10)]) {
          if (released[i]) {
            continue;
          }
          if (pressed[i]) {
            continue;
          }
          if (keyboard.getKeyCode(i) < 0) {
            this.release(i);
            released[i] = true;
          }
        }
        for (let keycode in keys) {
          let buttonIds = keys[keycode];
          if (!Array.isArray(buttonIds)) {
            buttonIds = keys[keycode] = [buttonIds];
          }
          for (const buttonId of buttonIds) {
            if (released[buttonId]) {
              continue;
            }
            if (pressed[buttonId]) {
              continue;
            }
            if (keyboard.getKeyCode(keycode) < 0) {
              this.release(buttonId);
              released[keycode] = true;
            }
          }
        }
      }
      for (let i = 0; i < gamepads.length; i++) {
        const gamepad = gamepads[i];
        if (!gamepad) {
          continue;
        }
        for (const i in gamepad.axes) {
          const axis = gamepad.axes[i];
          if (Math.abs(axis) < this.deadZone) {
            if (!tilted[i]) {
              this.tilt(i, 0);
            }
            continue;
          }
          tilted[i] = true;
          this.tilt(i, axis);
        }
      }
      for (let inputId in axisMap) {
        if (!this.buttons[inputId]) {
          this.buttons[inputId] = new _Button.Button();
        }
        const axis = axisMap[inputId];
        const value = Math.sign(1 / axis);
        const axisId = Math.abs(axis);
        if (tilted[axisId]) {
          continue;
        }
        if (this.buttons[inputId].active) {
          tilted[axisId] = true;
          this.tilt(axisId, value);
        } else if (!tilted[axisId]) {
          this.tilt(axisId, 0);
        }
      }
      for (let axisMove in buttonMap) {
        const buttonId = buttonMap[axisMove];
        if (released[buttonId]) {
          continue;
        }
        if (pressed[buttonId]) {
          continue;
        }
        const _ref4 = [axisMove.slice(0, 1), axisMove.slice(1)],
          move = _ref4[0],
          axisId = _ref4[1];
        if (!this.axes[axisId]) {
          this.axes[axisId] = new _Axis.Axis({
            deadZone: this.deadZone
          });
        }
        const axis = this.axes[axisId];
        if (axis.magnitude && Math.sign(axisMove) !== Math.sign(axis.magnitude)) {
          continue;
        }
        const pressure = Math.abs(axis.magnitude);
        if (pressure) {
          this.press(buttonId, pressure);
          pressed[buttonId] = true;
        } else {
          this.release(buttonId, pressure);
          released[buttonId] = true;
        }
      }
      for (const concreteId in buttonRemap) {
        const abstractId = buttonRemap[concreteId];
        if (released[abstractId]) {
          continue;
        }
        if (pressed[abstractId]) {
          continue;
        }
        if (!this.buttons[abstractId]) {
          this.buttons[abstractId] = new _Button.Button();
        }
        if (!this.buttons[concreteId]) {
          this.buttons[concreteId] = new _Button.Button();
        }
        if (this.buttons[concreteId].active) {
          this.press(abstractId, this.buttons[concreteId].pressure);
          pressed[abstractId] = true;
        } else if (!pressed[abstractId]) {
          this.release(abstractId, this.buttons[concreteId].pressure);
          released[abstractId] = true;
        }
      }
    }
  }, {
    key: "tilt",
    value: function tilt(axisId, magnitude) {
      if (!this.axes[axisId]) {
        this.axes[axisId] = new _Axis.Axis({
          deadZone: this.deadZone
        });
      }
      this.axes[axisId].tilt(magnitude);
    }
  }, {
    key: "press",
    value: function press(buttonId) {
      let pressure = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      if (!this.buttons[buttonId]) {
        this.buttons[buttonId] = new _Button.Button();
      }
      this.buttons[buttonId].press(pressure);
    }
  }, {
    key: "release",
    value: function release(buttonId) {
      if (!this.buttons[buttonId]) {
        this.buttons[buttonId] = new _Button.Button();
      }
      this.buttons[buttonId].release();
    }
  }, {
    key: "serialize",
    value: function serialize() {
      const buttons = {};
      for (const i in this.buttons) {
        buttons[i] = this.buttons[i].pressure;
      }
      const axes = {};
      for (const i in this.axes) {
        axes[i] = this.axes[i].magnitude;
      }
      return {
        axes: axes,
        buttons: buttons
      };
    }
  }, {
    key: "replay",
    value: function replay(input) {
      if (input.buttons) {
        for (const i in input.buttons) {
          if (input.buttons[i] > 0) {
            this.press(i, input.buttons[i]);
          } else {
            this.release(i);
          }
        }
      }
      if (input.axes) {
        for (const i in input.axes) {
          if (input.axes[i].magnitude !== input.axes[i]) {
            this.tilt(i, input.axes[i]);
          }
        }
      }
    }
  }, {
    key: "zero",
    value: function zero() {
      for (const i in this.axes) {
        this.axes[i].zero();
      }
      for (const i in this.buttons) {
        this.buttons[i].zero();
      }
    }
  }, {
    key: "buttonIsMapped",
    value: function buttonIsMapped(buttonId) {
      return buttonId in buttonRemap;
    }
  }, {
    key: "keyIsMapped",
    value: function keyIsMapped(keyCode) {
      return keyCode in keys;
    }
  }]);
  return Controller;
}();
exports.Controller = Controller;
});

;require.register("controller/GamepadConfig.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GamepadConfig = void 0;
var _View = require("curvature/base/View");
var _SkippableCard2 = require("../intro/SkippableCard");
var _KbInput = require("./KbInput");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let GamepadConfig = /*#__PURE__*/function (_SkippableCard) {
  _inherits(GamepadConfig, _SkippableCard);
  var _super = _createSuper(GamepadConfig);
  function GamepadConfig(args, parent) {
    var _this;
    _classCallCheck(this, GamepadConfig);
    _this = _super.call(this, args, parent);
    _this.template = require('./gamepad-config.html');
    _this.args.cardName = 'gamepad-config-card';
    _this.args.moves = {};
    _this.args.char = _this.args.char || 'Sonic';
    switch (args.char) {
      case 'Sonic':
        _this.args.moves = {
          start: 'Pause',
          dpad: 'Move',
          a: 'Jump',
          b: 'Spindash / Roll / Dropdash',
          x: 'Light Dash / Grab Object',
          y: 'Super Transform',
          l1: 'Air Dash',
          r1: 'Air Dash',
          la: 'Move',
          ra: 'Switch Sheilds'
        };
        break;
      case 'Tails':
        _this.args.moves = {
          start: 'Pause',
          dpad: 'Move',
          a: 'Jump',
          aa: 'Fly',
          ad: 'Use Shield / Spindash',
          d: 'Dive'
          // , x:    'Light Dash / Grab Object'
          ,
          y: 'Super Transform'
          // , l1:   'Air Dash'
          // , r1:   'Air Dash'
          ,
          la: 'Move',
          ra: 'Switch Sheilds'
        };
        break;
      case 'Knuckles':
        _this.args.moves = {
          start: 'Pause',
          dpad: 'Move',
          a: 'Jump',
          aa: 'Fly',
          b: 'Punch / Drop off wall',
          ad: 'Use Shield / Spindash',
          d: 'Dive'
          // , x:    'Light Dash / Grab Object'
          ,
          y: 'Super Transform'
          // , l1:   'Air Dash'
          // , r1:   'Air Dash'
          ,
          la: 'Move',
          ra: 'Switch Sheilds'
        };
        break;
    }

    // this.gamepads = {
    // 	xb: View.from(require('./xbox360-input.svg'), this.args.moves)
    // 	, dc: View.from(require('./dc-input.svg'), this.args.moves)
    // 	, gc: View.from(require('./gc-input.svg'), this.args.moves)
    // 	, ps: View.from(require('./ps3-input.svg'), this.args.moves)
    // };

    // this.gamepads = {kb: new KbInput(this.args.moves) }

    if (_this.args.inputType === 'input-xbox') {
      _this.gamepads = {
        xb: _View.View.from(require('./xbox360-input.svg'), _this.args.moves)
      };
    } else if (_this.args.inputType === 'input-playstation') {
      _this.gamepads = {
        ps: _View.View.from(require('./ps3-input.svg'), _this.args.moves)
      };
    } else if (_this.args.inputType === 'input-dreamcast') {
      _this.gamepads = {
        ps: _View.View.from(require('./dc-input.svg'), _this.args.moves)
      };
    } else if (_this.args.inputType === 'input-gamecube') {
      _this.gamepads = {
        ps: _View.View.from(require('./gc-input.svg'), _this.args.moves)
      };
    } else {
      _this.gamepads = {
        kb: new _KbInput.KbInput({
          char: _this.args.char,
          moves: _this.args.moves
        })
      };
    }
    _this.current = 0;
    _this.buttons = [];
    _this.sticks = {};
    return _this;
  }
  _createClass(GamepadConfig, [{
    key: "onAttached",
    value: function onAttached() {
      this.span = this.findTag('div');
      this.args.text = Object.values(this.gamepads)[this.current];
      this.args.type = Object.keys(this.gamepads)[this.current];
    }
  }, {
    key: "swap",
    value: function swap() {
      this.current++;
      const list = Object.values(this.gamepads);
      const type = Object.keys(this.gamepads);
      if (this.current >= list.length) {
        this.current = 0;
      }
      this.args.text = list[this.current];
      this.args.type = type[this.current];
    }
  }, {
    key: "exit",
    value: function exit() {
      this.remove();
    }
  }, {
    key: "input",
    value: function input(controller) {
      _get(_getPrototypeOf(GamepadConfig.prototype), "input", this).call(this, controller);
      if (!this.span) {
        return;
      }
      let x = 0,
        y = 0,
        a = 0,
        b = 0;
      if (controller.axes[0]) {
        x = controller.axes[0].magnitude;
      }
      if (controller.axes[1]) {
        y = controller.axes[1].magnitude;
      }
      if (controller.axes[2]) {
        a = controller.axes[2].magnitude;
      }
      if (controller.axes[3]) {
        b = controller.axes[3].magnitude;
      }
      this.span.style({
        '--x': x,
        '--y': y,
        '--a': a,
        '--b': b
      });
      for (const b in controller.buttons) {
        if (controller.buttons[b]) {
          this.span.style(_defineProperty({}, `--pressed-${b}`, controller.buttons[b].pressure));
        } else {
          this.span.style(_defineProperty({}, `--pressed-${b}`, 0));
        }
      }
    }
  }, {
    key: "play",
    value: function play(event) {
      // this.onTimeout(50, () => this.args.animation = 'opened');

      // const waitFor = this.args.waitFor || Promise.resolve();

      // return new Promise(accept => {
      // 	waitFor.then(() => {
      // 		const timeAcc = this.args.timeout;

      // 		if(timeAcc > 0)
      // 		{
      // 			this.onTimeout(timeAcc-500, () => this.args.animation = 'closing');
      // 			this.onTimeout(timeAcc, () => {
      // 				this.args.animation = 'closed';
      // 				const done = new Promise(acceptDone => this.onTimeout(timeAcc, acceptDone));
      // 				accept(this.accept([done]));
      // 			});
      // 		}
      // 	});
      // });
    }
  }]);
  return GamepadConfig;
}(_SkippableCard2.SkippableCard);
exports.GamepadConfig = GamepadConfig;
});

;require.register("controller/KbInput.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KbInput = void 0;
var _View2 = require("curvature/base/View");
var _CharacterString = require("../ui/CharacterString");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let KbInput = /*#__PURE__*/function (_View) {
  _inherits(KbInput, _View);
  var _super = _createSuper(KbInput);
  function KbInput(args, parent) {
    var _this;
    _classCallCheck(this, KbInput);
    _this = _super.call(this, args, parent);
    _defineProperty(_assertThisInitialized(_this), "template", require('./kb-input.html'));
    switch (_this.args.char) {
      case 'Sonic':
        _this.args.lines = [new _CharacterString.CharacterString({
          font: _this.font,
          value: `⬲ ✚ ${_this.args.moves.dpad}`
        }), new _CharacterString.CharacterString({
          font: _this.font,
          value: `⬚ ⓿ ${_this.args.moves.a}`
        }), new _CharacterString.CharacterString({
          font: _this.font,
          value: `⬚ ❶ ${_this.args.moves.b}`
        }), new _CharacterString.CharacterString({
          font: _this.font,
          value: `⬚ ❷ ${_this.args.moves.x}`
        }), new _CharacterString.CharacterString({
          font: _this.font,
          value: `⬚ ❸ ${_this.args.moves.y}`
        }), new _CharacterString.CharacterString({
          font: _this.font,
          value: `❹ ❺ ${_this.args.moves.r1}`
        }), new _CharacterString.CharacterString({
          font: _this.font,
          value: `⬚ ▦ ${_this.args.moves.ra}`
        }), new _CharacterString.CharacterString({
          font: _this.font,
          value: `⬚ ❾ ${_this.args.moves.start}`
        })];
        break;
      case 'Tails':
        _this.args.lines = [new _CharacterString.CharacterString({
          font: _this.font,
          value: `⬲ ✚ ${_this.args.moves.dpad}`
        }), new _CharacterString.CharacterString({
          font: _this.font,
          value: `⬚ ⓿ ${_this.args.moves.a}`
        }), new _CharacterString.CharacterString({
          font: _this.font,
          value: `⓿ ⓿ ${_this.args.moves.aa}`
        }), new _CharacterString.CharacterString({
          font: _this.font,
          value: `↓ ⓿ ${_this.args.moves.ad}`
        }), new _CharacterString.CharacterString({
          font: _this.font,
          value: `↓ ⬚ ${_this.args.moves.d}`
        })
        // , new CharacterString({font: this.font, value: `⬚ ❶ ${this.args.moves.b}`})
        // , new CharacterString({font: this.font, value: `⬚ ❷ ${this.args.moves.x}`})
        // , new CharacterString({font: this.font, value: `⬚ ❸ ${this.args.moves.y}`})
        // , new CharacterString({font: this.font, value: `❹ ❺ ${this.args.moves.r1}`})
        // , new CharacterString({font: this.font, value: `⬚ ▦ ${this.args.moves.ra}`})
        , new _CharacterString.CharacterString({
          font: _this.font,
          value: `⬚ ❾ ${_this.args.moves.start}`
        })];
        break;
      case 'Knuckles':
        _this.args.lines = [new _CharacterString.CharacterString({
          font: _this.font,
          value: `⬲ ✚ ${_this.args.moves.dpad}`
        }), new _CharacterString.CharacterString({
          font: _this.font,
          value: `⬚ ⓿ ${_this.args.moves.a}`
        }), new _CharacterString.CharacterString({
          font: _this.font,
          value: `⬚ ❶ ${_this.args.moves.b}`
        }), new _CharacterString.CharacterString({
          font: _this.font,
          value: `⓿ ⓿ ${_this.args.moves.aa}`
        }), new _CharacterString.CharacterString({
          font: _this.font,
          value: `↓ ⓿ ${_this.args.moves.ad}`
        }), new _CharacterString.CharacterString({
          font: _this.font,
          value: `↓ ⬚ ${_this.args.moves.d}`
        })
        // , new CharacterString({font: this.font, value: `⬚ ❷ ${this.args.moves.x}`})
        // , new CharacterString({font: this.font, value: `⬚ ❸ ${this.args.moves.y}`})
        // , new CharacterString({font: this.font, value: `❹ ❺ ${this.args.moves.r1}`})
        // , new CharacterString({font: this.font, value: `⬚ ▦ ${this.args.moves.ra}`})
        , new _CharacterString.CharacterString({
          font: _this.font,
          value: `⬚ ❾ ${_this.args.moves.start}`
        })];
        break;
    }
    return _this;
  }
  return _createClass(KbInput);
}(_View2.View);
exports.KbInput = KbInput;
});

;require.register("controller/dc-input.svg", function(exports, require, module) {
module.exports = "<svg version=\"1.0\" viewBox=\"0 0 512 288\" xmlns=\"http://www.w3.org/2000/svg\">\n <defs>\n  <clipPath id=\"a\">\n   <ellipse cx=\"296.69\" cy=\"214.12\" rx=\"206.77\" ry=\"205.42\" display=\"none\" fill=\"#4d4d4d\"/>\n   <path class=\"powerclip\" d=\"m8.0946 3.7805h575.41v590.04h-575.41zm495.36 210.34a206.77 205.42 0 0 0-206.77-205.42 206.77 205.42 0 0 0-206.77 205.42 206.77 205.42 0 0 0 206.77 205.42 206.77 205.42 0 0 0 206.77-205.42z\" display=\"block\" fill=\"#4d4d4d\"/>\n  </clipPath>\n </defs>\n <g transform=\"translate(-260.34 -473.69)\">\n  <path d=\"m437.18 546.97c0.0704-0.35215 1.3382-5.8456 1.479-6.7612 0.14086-0.91559 0.35215-1.4086 1.479-2.1833 10.576-7.2713 5.4994-7.4732 17.763-5.4952 2.1833 0.35214 5.0005 5.8456 5.0005 5.8456z\" fill=\"#d8d8d8\" fill-rule=\"evenodd\" stroke=\"#000\" stroke-width=\".96695\" data-button=\"button-6\"/>\n  <path d=\"m595.5 546.97c-0.0704-0.35215-1.3382-5.8456-1.479-6.7612-0.14086-0.91559-0.35215-1.4086-1.479-2.1833-10.576-7.2713-5.4994-7.4732-17.763-5.4952-2.1833 0.35214-5.0005 5.8456-5.0005 5.8456z\" fill=\"#d8d8d8\" fill-rule=\"evenodd\" stroke=\"#000\" stroke-width=\".96695\" data-button=\"button-7\"/>\n  <path d=\"m604.24 553.13c-0.0704-0.35215-1.3382-5.8456-1.479-6.7612-0.14086-0.91559-0.35215-1.4086-1.479-2.1833-10.576-7.2713-22.951-10.782-35.215-8.8037-2.1833 0.35214-5.0005 5.8456-5.0005 5.8456z\" fill=\"#d8d8d8\" fill-rule=\"evenodd\" stroke=\"#000\" stroke-width=\".96695\" data-button=\"button-5\"/>\n  <path d=\"m428.44 553.13c0.0704-0.35215 1.3382-5.8456 1.479-6.7612 0.14086-0.91559 0.35215-1.4086 1.479-2.1833 10.576-7.2713 22.951-10.782 35.215-8.8037 2.1833 0.35214 5.0005 5.8456 5.0005 5.8456z\" fill=\"#d8d8d8\" fill-rule=\"evenodd\" stroke=\"#000\" stroke-width=\".96695\" data-button=\"button-4\"/>\n  <g transform=\"matrix(.34401 0 0 .34401 414.97 503.95)\">\n   <ellipse cx=\"294.98\" cy=\"208.06\" rx=\"205.59\" ry=\"199.11\" fill=\"none\" stroke=\"#000\" stroke-width=\"7.4\"/>\n   <ellipse cx=\"295.57\" cy=\"214.12\" rx=\"206.77\" ry=\"205.42\" display=\"block\" fill=\"#e6e6e6\"/>\n   <rect x=\"255.55\" y=\"18.994\" width=\"93.05\" height=\"71.373\" fill=\"#d35f5f\" stroke-width=\".67124\"/>\n   <rect x=\"234.74\" y=\"140.67\" width=\"129.82\" height=\"113.54\" fill=\"#666\"/>\n   <g transform=\"translate(-1.12)\" fill=\"#1a1a1a\">\n    <g>\n     <path d=\"m243.78 111.34c0.838 0 1.818-0.043 2.687-0.135s1.481-0.397 2.167-0.636 1.377-0.643 2.02-1.261c0.637-0.618 1.157-1.316 1.548-2.099 0.392-0.784 0.673-1.659 0.845-2.632 0.171-0.967 0.239-1.952 0.196-2.95-0.042-1.12-0.343-1.953-0.648-2.907-0.306-0.955-0.881-2.154-1.671-2.803-0.869-0.716-1.493-1.224-2.387-1.481-0.894-0.251-2.154-0.637-3.599-0.637-0.881 0-2.05 0.062-2.62 0.128-0.593 0.074-1.138 0.147-1.885 0.159l0.196 17.228c1.162 0.038 2.154 0.026 3.151 0.026z\" fill=\"#1a1a1a\"/>\n     <path d=\"m278.33 102.96c-0.031-0.624 0-0.416-0.073-0.765-0.074-0.343-0.166-0.618-0.349-0.991-0.184-0.367-0.502-0.624-0.795-0.894-0.294-0.27-0.643-0.478-1.053-0.618-0.404-0.147-1.01-0.22-1.475-0.22-0.501 0-0.948 0.153-1.395 0.312s-0.838 0.374-1.175 0.649c-0.336 0.275-0.618 0.6-0.844 0.967-0.227 0.367-0.392 0.729-0.496 1.071-0.042 0.135-0.049 0.147-0.042 0.153 6e-3 6e-3 0.03-0.012-0.025 0.336z\" fill=\"#1a1a1a\"/>\n     <path d=\"m291.54 104.42c-0.3 0.27-0.441 0.343-0.587 0.453-0.147 0.11-0.361 0.171-0.551 0.269-0.19 0.092-0.447 0.116-0.68 0.202-0.226 0.085-1.022 0.11-1.346 0.153-0.691 0.086-1.15 0.159-1.426 0.27-0.6 0.214-0.955 0.275-1.298 0.496-0.342 0.22-0.612 0.551-0.838 0.808-0.227 0.257-0.312 0.49-0.404 0.747-0.104 0.318-0.092 0.655-0.073 0.998 0.018 0.538 0.434 1.132 0.734 1.523 0.293 0.398 0.3 0.257 0.679 0.526 0.379 0.263 0.918 0.404 1.518 0.404 0.374 0 0.759-0.031 1.157-0.092 0.306-0.043 0.637-0.239 1.096-0.392 0.146-0.049 0.489-0.361 0.655-0.422 0 0 0.422-0.342 0.844-1.077 0.422-0.734 0.508-1.952 0.508-1.952z\" fill=\"#1a1a1a\"/>\n     <path d=\"m341.81 104.23c-0.294 0.27-0.44 0.349-0.588 0.459-0.146 0.11-0.379 0.153-0.569 0.251-0.189 0.092-0.428 0.135-0.66 0.22-0.227 0.086-1.022 0.11-1.347 0.153-0.691 0.085-1.15 0.159-1.426 0.269-0.6 0.22-0.961 0.282-1.304 0.496-0.343 0.221-0.618 0.551-0.845 0.808s-0.318 0.489-0.404 0.747c-0.104 0.318-0.085 0.655-0.073 1.003 0.019 0.533 0.435 1.132 0.734 1.524 0.3 0.398 0.3 0.257 0.686 0.526 0.38 0.263 0.918 0.404 1.524 0.404 0.373 0 0.759-0.03 1.162-0.092 0.307-0.042 0.643-0.245 1.096-0.392 0.146-0.049 0.489-0.361 0.655-0.422 0 0 0.422-0.343 0.844-1.077 0.423-0.729 0.509-1.953 0.509-1.953z\" fill=\"#1a1a1a\"/>\n     <path d=\"m79.619 239.47c24.811 0 44.995-20.073 44.995-44.748s-20.184-44.748-44.995-44.748-44.997 20.073-44.997 44.748 20.192 44.748 44.997 44.748z\" fill=\"#ececec\"/>\n     <polygon transform=\"matrix(1.6291,0,0,1.6291,-178.01,-257.79)\" points=\"318.12 444.41 293.78 403.06 269.44 444.41\" fill=\"#fff\" stroke-width=\".61384\"/>\n     <path d=\"m119.14 577.38c12.815-43.023 10.985-43.023 17.393-58.582 6.408-15.562 19.223-16.475 35.698-20.135 15.404-3.42 80.508-11.378 123.02-12.431 6e-3 0.117 0 0 0 0l11.652-0.15207-0.013-0.092s75.652 4.8914 112.49 12.675c16.476 3.66 29.291 4.578 35.698 20.135 6.407 15.564 4.578 15.564 17.394 58.582 12.814 43.018 69.554-66.818 95.184-228.83 25.631-162.01-11.848-224.91-22.222-230.4-10.373-5.49-79.382-20.404-79.382-20.404-18.269-23.911-37.871-41.377-57.039-54.199v181.14c0 53.85-43.807 97.657-97.656 97.657h-21.524c-53.85 0-97.657-43.808-97.657-97.657v-187.17c-22.156 13.194-45.296 32.319-66.624 60.232 0 0-69.009 14.908-79.382 20.404-10.374 5.49-47.853 68.385-22.222 230.4 25.624 162.01 82.375 271.85 95.19 228.83zm373.77-258.73c-13.801 0-25.031-11.223-25.031-25.024s11.23-25.031 25.031-25.031c13.8 0 25.024 11.224 25.024 25.031 1e-3 13.802-11.224 25.024-25.024 25.024zm48.207-96.432c13.801 0 25.03 11.224 25.03 25.031 0 13.801-11.229 25.025-25.03 25.025s-25.031-11.224-25.031-25.025 11.23-25.031 25.031-25.031zm-47.601-46.989c13.801 0 25.031 11.224 25.031 25.031 0 13.8-11.23 25.024-25.031 25.024s-25.03-11.224-25.03-25.024c5e-3 -13.801 11.229-25.031 25.03-25.031zm-48.207 46.383c13.801 0 25.024 11.224 25.024 25.031 0 13.801-11.224 25.025-25.024 25.025s-25.031-11.224-25.031-25.025c6e-3 -13.807 11.236-25.031 25.031-25.031zm-176.43 232.05 28.458-48.342c1.408-2.418 5.056-2.441 6.5-6e-3l28.451 48.342c0.729 1.242 0.759 2.662 0.099 3.818-0.655 1.15-1.91 1.842-3.33 1.842h-56.928c-1.426 0-2.674-0.691-3.335-1.842-0.668-1.156-0.631-2.582 0.085-3.812zm-136.01-171.33c2.699 0 4.896 2.191 4.896 4.89v26.23h26.23c2.693 0 4.89 2.191 4.89 4.891v23.801c0 2.697-2.191 4.889-4.89 4.889h-26.23v26.23c0 2.693-2.191 4.891-4.896 4.891h-23.801c-2.692 0-4.89-2.191-4.89-4.891v-26.23h-26.23c-2.693 0-4.89-2.191-4.89-4.889v-23.801c0-2.693 2.191-4.891 4.89-4.891h26.23v-26.23c0-2.699 2.191-4.89 4.89-4.89zm-54.009-133.64c24.902 0 45.166 20.263 45.166 45.166s-20.263 45.166-45.166 45.166-45.166-20.263-45.166-45.166 20.264-45.166 45.166-45.166z\" clip-path=\"url(#b)\" fill=\"#e6e6e6\"/>\n     <path d=\"m371.79 133.6h-142.4v126.1h142.4zm-8.256 117.31c0 0.985-0.796 1.781-1.781 1.781h-122.33c-0.979 0-1.781-0.796-1.781-1.781v-108.51c0-0.985 0.795-1.781 1.781-1.781h122.33c0.985 0 1.781 0.795 1.781 1.781z\" fill=\"#1a1a1a\"/>\n     <path d=\"m289.82 316.22h21.523c50.558 0 91.537-40.985 91.537-91.536v-6.089l0.0627-180.67c-46.252-27.867-85.605-28.475-100.38-29.284-3.6348-0.19916-6.7928-0.03767-6.7928-0.03767s-2.9265-0.19568-6.6277-0.015294c-13.717 0.66851-50.54 2.3407-91.789 25.089l0.93221 184.88v6.12c0 50.552 40.986 91.537 91.537 91.537zm66.506-218.18 1.806-0.061c0.018-0.379-0.031-1.567-0.031-2.497 0-0.453-0.227-0.869-0.41-1.096 0.82-0.184 2.069-0.563 2.638-0.728-6e-3 1.469 0.099 3.556 0.117 4.321l3.684 0.055c-0.019 0.63 0.049 0.851 0.062 1.419l-1.016-0.122h-2.705l-0.05 8.103-0.024 0.679c0.024 0.723 0.123 1.641 0.282 2.001 0.159 0.361 0.385 0.496 0.679 0.655 0.3 0.159 0.637 0.196 0.949 0.196 0.22 0 0.551-6e-3 0.808-6e-3s0.435-0.019 1.071-0.202c-0.08 0.478-0.209 0.741-0.294 1.536-0.588 0.166-0.857 0.208-1.206 0.245-0.349 0.043-0.679-0.067-0.997-0.067-0.777 0-1.414-0.11-1.903-0.337-0.49-0.22-0.869-0.575-1.139-1.071-0.275-0.49-0.465-1.708-0.496-2.552-6e-3 -0.11-6e-3 -0.3-0.012-0.575 0-0.275-0.019-0.551 0-2.197l-0.056-6.402h-1.774c0.023-0.397 0.023-0.519 0.017-1.297zm-2.932 9.309c-0.135-0.184-0.643-0.618-0.899-0.838-0.257-0.227-0.937-0.557-1.824-0.924-0.899-0.379-2.044-0.74-2.46-1.089-0.416-0.355-1.175-0.759-1.475-1.132s-0.526-0.74-0.68-1.12c-0.153-0.374-0.043-0.943-0.055-1.328-0.024-0.618 0.36-1.254 0.728-1.836 0.361-0.575 0.992-0.9 1.714-1.188 0.723-0.281 1.579-0.428 2.564-0.428 1.102 0 2.166 0.214 3.501 0.471 0.073 0.753-0.099 1.273-7e-3 1.897-0.961-0.636-2.025-0.955-3.072-0.955-0.568 0-1.145 0.086-1.621 0.233-0.478 0.146-1.01 0.624-1.218 0.918-0.215 0.3-0.331 0.581-0.318 0.936 6e-3 0.233 0.079 0.618 0.165 0.833 0.086 0.214 0.648 0.808 0.942 0.937 0.404 0.177 0.245 0.153 0.612 0.232 0.416 0.092 1.444 0.618 2.423 1.083 1.017 0.483 1.946 1.089 2.265 1.408 0.324 0.318 0.637 0.759 0.931 1.438 0.165 0.38 0.257 0.826 0.257 1.145 0 0.551-0.146 0.625-0.129 0.967 0.031 0.673-0.141 0.924-0.514 1.5s-1.071 1.126-1.849 1.444c-0.777 0.318-1.604 0.582-2.576 0.582-0.416 0-1.377 0.049-1.934-6e-3 -0.558-0.049-1.035-0.239-1.427-0.312s-0.643-0.092-1.224-0.232l-0.202-0.985c-6e-3 -0.116-0.263-0.771-0.373-1.396 1.646 0.906 3.385 1.542 4.633 1.542 0.654 0 1.304-0.19 1.75-0.361 0.447-0.171 0.882-0.489 1.096-0.826 0.208-0.336 0.44-0.661 0.521-1.016 0.049-0.196 0.11-0.459 0.061-0.637-0.067-0.211-0.171-0.774-0.306-0.957zm-86.138-55.282c0.324-2.111 0.955-4.223 1.364-5.673 0.973-3.47 3.581-8.672 4.841-10.429s1.762-2.295 3.592-4.339 0.783-0.637 4.174-3.421c3.384-2.785 7.938-4.78 9.933-5.587 1.995-0.814 5.037-2.301 10.521-2.668s8.794 0.312 11.854 0.667c3.586 0.417 10.435 2.754 10.435 2.754s3.996 1.805 7.093 3.837c1.671 1.004 3.158 2.987 4.676 4.927 2.087 2.668 4.131 6.028 4.425 6.505 0.508 0.814 2.778 4.908 3.256 6.426s1.542 7.117 1.628 7.729 0.937 4.051-2.001 4.253c-3.22 0.22-3.55-3.066-3.758-4.002-0.214-0.942-2.387-8.158-3.14-9.517s-5.264-7.962-7.265-10.135-5.894-4.951-10.141-6.255c-4.063-1.254-10.961-2.479-15.6-2.276-4.076 0.177-5.416 0.459-7.191 1.022-3.629 1.157-6.812 2.993-9.015 4.382-2.203 1.383-5.899 4.357-7.515 6.383-1.916 2.405-5.166 8.354-5.888 11.64-1.334 6.114-0.502 12.014-0.502 12.014s1.506 11.579 9.015 17.521c2.938 2.332 5.336 3.562 12.02 5.379 0.937 0.257 3.978 0.471 7.778 0.496 3.801 0.019 4.957-0.11 7.124-0.869 2.16-0.759 2.852-0.894 4.504-1.75 1.659-0.857 4.505-1.799 7.559-4.811 1.707-1.689 3.837-5.006 4.719-8.329 0.514-1.946 0.189-2.552 0.122-5.104-0.019-0.783-0.092-1.493-0.153-2.167-0.146-1.524-0.397-2.938-0.93-5.178-0.771-3.231-0.539-2.387-1.292-4.449-0.52-1.42-1.107-2.577-1.523-3.25s-0.814-1.12-1.273-1.818c-3.17-4.841-9.431-8.011-15.232-8.201-1.934-0.067-4.314 0.135-6.714 0.894-1.628 0.514-3.268 1.346-4.786 2.271-0.63 0.379-1.23 0.673-1.812 1.132-0.587 0.471-0.942 0.606-1.462 1.157-0.471 0.501-1.114 1.628-1.5 2.136-4.725 6.065-3.629 11.689-3.629 11.689s-0.44 13.207 13.52 14.646c3.525 0.171 9.89-2.087 12.301-4.67 1.481-1.591 1.585-4.437 1.536-6.964-0.036-2.001-1.016-5.551-2.552-6.922-3.342-2.98-6.12-3.072-7.576-3.158-1.94-0.123-4.7 0.477-5.79 4.725-0.38 1.475 0.777 4.547 2.962 4.982 1.879 0.379 3.88 0 4.762 0.128 0.783 0.11 1.971-0.153 1.971 2.313-0.221 4.321-9.633 1.903-9.737 1.812-0.722-0.624-4.969-3.042-5.134-7.631-0.178-4.847 2.099-8.507 6.236-10.576 1.041-0.52 2.956-0.783 4.254-0.838 3.524 0.171 6.021 0.63 8.604 2.02 0.483 0.263 0.979 0.477 1.512 0.838 0.165 0.11 0.802 0.557 0.899 0.618 3.023 2.601 4.284 6.035 4.884 9.499 0.238 1.377 0.232 2.662 0.275 3.678 0.08 1.738-0.122 3.843-1.01 5.82-0.942 2.112-2.638 4.082-5 5.318-2.295 1.2-5.643 3.103-10.264 3.672-2.784 0.342-6.021 0.287-9.773-0.924-10.643-3.439-11.646-15.514-11.646-15.514s-2.173-8.898 3.69-16.916c0.618-0.844 1.322-1.928 2.129-2.735 2.644-2.644 5.012-4.015 7.185-5.166 3.99-2.111 6.916-2.595 7.779-2.595 0.618 0 2.093-0.085 3.824 0.043 1.983 0.141 4.309 0.526 6.065 0.955 1.928 0.471 3.537 0.851 4.792 1.383 1.188 0.508 2.038 1.175 2.968 1.744 1.922 1.169 4.982 3.488 6.017 5.055 1.07 1.628 2.589 3.715 3.77 7.387 0.691 2.154 1.273 5.232 1.983 8.703 1.064 5.196 0.679 10.447-0.502 13.764-0.129 0.355-1.451 4.566-5.637 8.513-4.187 3.954-9.455 6.193-11.016 6.817-1.567 0.625-3.795 2.521-12.332 2.381-7.387-0.123-12.987-2.081-14.651-2.754-1.665-0.673-6.059-2.068-10.833-7.319-4.773-5.257-5.814-8.648-6.573-10.949s-2.191-8.195-2.191-8.195 0.171-0.024-0.171-3.066c-0.129-1.359-0.111-3.133 0.159-4.908zm73.825 59.388c-0.465 0.386-0.937 0.673-1.236 0.857-0.637 0.134-1.021 0.281-1.426 0.312-0.404 0.037-0.783 0.049-1.15 0.049-1.212 0-2.1-0.367-2.791-0.686-0.691-0.318-1.261-0.875-1.622-1.523-0.36-0.649-0.44-1.243-0.471-2.008-0.019-0.446 0.11-0.905 0.22-1.279 0.104-0.379 0.251-0.716 0.447-1.022 0.189-0.306 0.33-0.539 0.691-0.851 0.361-0.306 0.575-0.478 0.979-0.673 0.403-0.202 0.777-0.288 1.315-0.483 0.539-0.196 1.524-0.263 2.785-0.441 0.385-0.098 0.71-0.073 0.979-0.177 0.27-0.104 0.509-0.208 0.717-0.306s0.385-0.214 0.538-0.349 0.294-0.3 0.416-0.49c0.129-0.196 0.215-0.141 0.27-0.336 0.055-0.196 0.024-0.294 0.019-0.496-0.019-0.489-0.043-0.765-0.337-1.107s-0.637-0.833-1.102-0.967c-0.459-0.141-1.23-0.361-1.849-0.361-0.575 0-1.046 0.073-1.646 0.178-0.6 0.104-1.114 0.232-1.549 0.373-0.429 0.147-0.918 0.361-1.561 0.649 0.062-0.435 0.013-1.065 0.062-1.922 1.053-0.306 1.609-0.453 2.387-0.563s1.928-0.178 2.674-0.178c0.796 0 1.292 0.171 1.995 0.337 0.698 0.165 1.586 0.777 1.91 1.261 0.336 0.496 0.648 0.856 0.819 1.334 0.172 0.478 0.404 1.42 0.429 1.958 0.024 0.679 0.062 0.239 0.037 1.842-0.024 1.609 0.073 4.547 0.061 5.912-6e-3 0.833 0.099 0.912 0.318 2.038-0.483-0.019-1.102 0.024-1.401 0.024-0.287 0-0.71-0.043-1.236-0.024v-1.53c7e-3 6e-3 -0.226 0.263-0.691 0.648zm-19.155-3.378c0.336 0.838 0.899 1.659 1.683 2.118s1.701 0.906 2.662 0.906c0.931 0 2.889-0.098 5.013-1.224-0.013 0.159-0.098 0.514-0.153 0.942-0.055 0.435-0.178 0.796-0.214 1.212-0.637 0.166-1.31 0.349-1.903 0.41-0.588 0.061-2.197 0.165-2.644 0.165-0.949 0-2.051-0.196-2.864-0.483-0.814-0.288-1.83-0.832-2.448-1.487-0.624-0.655-1.328-1.31-1.646-2.283s-0.545-1.909-0.581-2.993c-0.056-1.457 0.177-1.946 0.587-3.25 0.404-1.31 1.438-2.252 2.394-2.993 0.954-0.741 3.164-1.371 4.859-1.371 1.248 0 2.711 0.208 3.91 0.575 0.086 0.851 0.116 1.31 0.178 1.861-0.845-0.3-1.616-0.649-2.148-0.753s-1.199-0.202-1.652-0.202c-0.771 0-2.411 0.343-3.011 0.655-0.6 0.318-1.102 0.765-1.512 1.353-0.41 0.581-0.734 1.395-0.894 2.197s-0.221 0.869-0.189 1.702c0.04 1.125 0.23 2.104 0.573 2.943zm-6.898-5.263c-0.019-0.575-0.189-1.224-0.306-1.548-0.116-0.324-0.704-0.924-0.949-1.187-0.244-0.263-0.611-0.312-0.961-0.447-0.349-0.135-0.911-0.166-1.353-0.166-0.354 0-0.802 0.062-1.095 0.147-0.275 0.086-0.551 0.147-0.809 0.331-0.281 0.189-0.532 0.3-0.752 0.575-0.221 0.27-0.398 0.575-0.545 0.912-0.153 0.349-0.159 0.869-0.189 1.432-0.037 0.606 0.03 1.383 0.012 2.252-0.024 0.918-0.024 4.56 0 6.065l0.422 1.346c-0.514-0.018-1.272-0.03-1.529-0.03-0.239 0-0.894 6e-3 -1.457 0.03 0.043-1.224 0.19-0.11 0.196-1.407l0.024-5.594c0-1.108-0.013-2.057-0.043-2.833-0.019-0.508-0.079-0.686-0.184-1.041-0.098-0.355-0.275-0.802-0.532-1.096-0.251-0.293-0.808-0.765-1.15-0.918-0.35-0.153-0.839-0.269-1.268-0.269-0.452 0-0.746 0.049-1.138 0.22s-0.734 0.251-1.059 0.594c-0.318 0.336-0.588 0.373-0.796 0.869-0.208 0.489-0.367 0.385-0.459 1.181-0.098 0.795-0.141 3.69-0.135 5.667 6e-3 1.169 0.019 2.228 0.037 3.183 0.012 0.654 0.281 0.887 0.306 1.444-0.569-0.018-1.212-0.03-1.42-0.03-0.232 0-1.01 6e-3 -1.585 0.03l0.318-1.028c0.012-0.453 0.019-1.922 0.024-2.901l-0.147-8.292c-0.018-0.741-0.416-1.628-0.435-2.014 0.41 0.012 1.335-0.135 1.763-0.294 0.343-0.128 0.729-0.128 1.09-0.141l-6e-3 1.928c0.275-0.557 0.776-0.612 1.01-0.942 0.232-0.324 0.471-0.312 0.856-0.587s0.624-0.288 1.139-0.361c0.63-0.092 1.027-0.123 1.572-0.123 0.38 0 0.753 0.049 1.126 0.147 0.374 0.098 0.717 0.239 1.041 0.417 0.318 0.177 0.594 0.379 0.826 0.605 0.232 0.227 0.483 0.349 0.691 0.741 0.073 0.128 0.637-0.624 1.426-1.083 0.79-0.453 1.72-0.802 2.711-0.802 0.637 0 2.057 0.085 2.662 0.312 0.606 0.227 1.463 0.557 1.836 0.979 0.367 0.429 0.478 0.618 0.809 0.967 0.41 0.435 0.538 1.53 0.562 1.995 0.019 0.477 0.067 1.199 0.067 2.16l6e-3 6.818c0 0.655 0.19 0.734 0.312 1.481-0.471-0.019-1.083-0.031-1.353-0.031-0.281 0-0.955 6e-3 -1.506 0.031 0.367-1.169 0.294-0.771 0.325-1.487l0.024-6.181c-2e-3 -0.87-7e-3 -1.384-0.032-2.026zm-24.217 8.831c-0.459 0.386-0.937 0.667-1.23 0.857-0.637 0.135-1.016 0.282-1.42 0.312-0.404 0.031-0.79 0.049-1.151 0.049-1.206 0-2.093-0.367-2.784-0.686-0.692-0.318-1.255-0.875-1.616-1.524-0.361-0.648-0.441-1.242-0.471-2.007-0.019-0.447 0.116-0.906 0.22-1.279 0.104-0.374 0.251-0.716 0.44-1.022 0.19-0.306 0.331-0.539 0.692-0.844 0.361-0.306 0.575-0.478 0.979-0.673s0.771-0.288 1.31-0.483c0.539-0.19 1.524-0.263 2.778-0.441 0.38-0.098 0.71-0.073 0.979-0.177s0.508-0.208 0.716-0.306 0.386-0.214 0.539-0.349 0.294-0.3 0.417-0.49c0.128-0.196 0.214-0.263 0.269-0.459s0.024-0.294 0.019-0.496c-0.019-0.49-0.043-0.637-0.337-0.985-0.293-0.349-0.636-0.833-1.095-0.967s-1.224-0.361-1.842-0.361c-0.575 0-1.046 0.074-1.646 0.177-0.6 0.104-1.114 0.233-1.548 0.374-0.429 0.147-0.918 0.361-1.561 0.649 0.062-0.441 0.012-1.065 0.062-1.928 1.046-0.3 1.604-0.453 2.38-0.563 0.777-0.11 1.928-0.177 2.668-0.177 0.795 0 1.292 0.171 1.989 0.336 0.704 0.166 1.579 0.777 1.904 1.261 0.336 0.496 0.648 0.851 0.82 1.328 0.165 0.478 0.404 1.42 0.428 1.958 0.025 0.686 0.062 0.239 0.037 1.842-0.025 1.609 0.073 4.547 0.061 5.912-6e-3 0.826 0.098 0.912 0.318 2.038-0.478-0.019-1.096 0.024-1.402 0.024-0.281 0-0.709-0.043-1.236-0.024v-1.53c6e-3 0.011-0.227 0.268-0.686 0.654zm-19.975-3.109c0.422 0.875 0.991 1.438 1.769 1.891 0.777 0.447 1.805 0.839 2.791 0.839 1.139 0 3.213-0.478 4.915-1.328-0.085 0.539-0.263 1.242-0.336 2.075-0.838 0.238-2.222 0.771-2.84 0.856-0.618 0.086-1.23 0.104-1.848 0.104-1.102 0-2.197-0.275-3.084-0.569-0.888-0.3-1.775-0.912-2.424-1.652-0.655-0.735-1.297-1.536-1.603-2.491-0.312-0.948-0.386-1.909-0.429-2.968-0.055-1.475 0.184-2.025 0.637-3.286s1.401-2.179 2.387-2.901c0.979-0.722 2.246-1.083 3.794-1.083 0.802 0 1.713 0.062 2.454 0.325 0.74 0.263 1.365 0.539 1.867 1.071 0.508 0.539 0.93 1.071 1.224 1.86 0.294 0.79 0.361 0.802 0.526 1.72 0.074 0.429 0.129 1.102 0.092 1.438l-10.49 0.061c-0.012 0.545-0.049 0.814-0.037 1.096 0.029 1.045 0.212 2.067 0.635 2.942zm-11.12-10.288c0.318-0.067 1.102-0.177 1.518-0.189l6e-3 2.644c0.3-0.612 0.318-0.575 0.563-0.881 0.239-0.312 0.624-0.667 0.93-0.869 0.312-0.202 0.649-0.49 1.046-0.606 0.392-0.117 0.753-0.282 1.188-0.3 0.343-0.012 0.667-0.061 1.548 0.031 0.887 0.092 1.353 0.294 1.548 0.349 0.019 0.355-0.649 1.989-0.649 1.989s-0.636-0.055-1.211-0.293c-0.551-0.166-0.924-0.166-1.359-0.166-0.514 0-1.12 0.116-1.524 0.312-0.404 0.19-0.79 0.422-1.102 0.814s-0.52 0.796-0.71 1.34c-0.159 0.441-0.104 0.073-0.165 0.765-0.067 0.691-6e-3 7.326 0.049 8.819l0.263 0.857c-0.483-0.019-1.169 0-1.462 0-0.27 0-0.924 0.012-1.469 0.03 0-0.281 0.282-0.673 0.288-0.942 0.067-4.633-0.03-8.213-0.141-11.206l-0.049-1.261-0.44-1.071c0.446-0.05 1.052-0.111 1.334-0.166zm-18.654-6.224c0.533 0 1.322 0.086 2.436 0.062 1.114-0.025 2.105 0 2.546 0.042 1.585 0.147 1.989 0.233 3.078 0.502 0.826 0.196 2.393 1.034 3.091 1.53 0.704 0.496 1.401 1.064 1.97 1.866 0.563 0.802 0.845 1.059 1.224 1.989 0.508 1.261 0.802 2.625 0.851 3.892 0.067 1.732-0.116 3.06-0.618 4.651-0.496 1.591-1.603 2.772-2.668 3.837s-2.234 1.708-3.593 2.044c-1.365 0.336-2.901 0.667-4.596 0.667l-3.991-0.03-3.8-0.092 0.539-1.42-0.043-17.528c-0.012-0.508-0.251-1.034-0.501-1.922 1.198 0.027 3.224-0.09 4.075-0.09zm-17.797 168.64v-128.02c0-2.846 2.313-5.159 5.159-5.159h144.32c2.846 0 5.159 2.313 5.159 5.159v128.02c0 2.846-2.313 5.159-5.159 5.159h-144.32c-2.846 1e-3 -5.159-2.312-5.159-5.158z\" fill=\"#1a1a1a\"/>\n     <ellipse cx=\"493.55\" cy=\"200.22\" rx=\"25.204\" ry=\"25.115\" fill=\"#fff\"/>\n     <circle cx=\"493.51\" cy=\"200.26\" r=\"18.911\" fill=\"#1a1a1a\"/>\n     <ellipse cx=\"444.94\" cy=\"246.54\" rx=\"25.204\" ry=\"25.115\" fill=\"#fff\"/>\n     <path d=\"m445.3 265.55c10.422 0 18.904-8.482 18.904-18.905s-8.482-18.911-18.904-18.911c-10.429 0-18.911 8.482-18.911 18.911s8.482 18.905 18.911 18.905z\" fill=\"#1a1a1a\"/>\n     <ellipse cx=\"492.88\" cy=\"293.45\" rx=\"25.204\" ry=\"25.115\" fill=\"#fff\"/>\n     <path d=\"m492.9 274.71c-10.429 0-18.911 8.482-18.911 18.911 0 10.428 8.482 18.905 18.911 18.905 10.422 0 18.904-8.482 18.904-18.905s-8.482-18.911-18.904-18.911z\" fill=\"#1a1a1a\"/>\n     <ellipse cx=\"541.23\" cy=\"247.25\" rx=\"25.204\" ry=\"25.115\" fill=\"#fff\"/>\n     <circle cx=\"541.11\" cy=\"247.25\" r=\"18.911\" fill=\"#1a1a1a\"/>\n     <path d=\"m78.855 232.89c21.53 0 39.045-17.515 39.045-39.045s-17.515-39.045-39.045-39.045-39.046 17.515-39.046 39.045 17.522 39.045 39.046 39.045z\" fill=\"#1a1a1a\"/>\n     <polygon transform=\"translate(6.8088,8.7805)\" points=\"124.82 332.13 155.94 332.13 155.94 310.78 124.82 310.78 124.82 279.67 103.48 279.67 103.48 310.78 72.364 310.78 72.364 332.13 103.48 332.13 103.48 363.25 124.82 363.25\" fill=\"#1a1a1a\"/>\n     <polygon transform=\"translate(6.8088,8.7805)\" points=\"269.44 444.41 318.12 444.41 293.78 403.06\" fill=\"#1a1a1a\"/>\n    </g>\n   </g>\n   <g transform=\"translate(-1.12)\" clip-path=\"url(#a)\" fill=\"#1a1a1a\">\n    <g clip-path=\"none\">\n     <path d=\"m243.78 111.34c0.838 0 1.818-0.043 2.687-0.135s1.481-0.397 2.167-0.636 1.377-0.643 2.02-1.261c0.637-0.618 1.157-1.316 1.548-2.099 0.392-0.784 0.673-1.659 0.845-2.632 0.171-0.967 0.239-1.952 0.196-2.95-0.042-1.12-0.343-1.953-0.648-2.907-0.306-0.955-0.881-2.154-1.671-2.803-0.869-0.716-1.493-1.224-2.387-1.481-0.894-0.251-2.154-0.637-3.599-0.637-0.881 0-2.05 0.062-2.62 0.128-0.593 0.074-1.138 0.147-1.885 0.159l0.196 17.228c1.162 0.038 2.154 0.026 3.151 0.026z\" fill=\"#1a1a1a\"/>\n     <path d=\"m278.33 102.96c-0.031-0.624 0-0.416-0.073-0.765-0.074-0.343-0.166-0.618-0.349-0.991-0.184-0.367-0.502-0.624-0.795-0.894-0.294-0.27-0.643-0.478-1.053-0.618-0.404-0.147-1.01-0.22-1.475-0.22-0.501 0-0.948 0.153-1.395 0.312s-0.838 0.374-1.175 0.649c-0.336 0.275-0.618 0.6-0.844 0.967-0.227 0.367-0.392 0.729-0.496 1.071-0.042 0.135-0.049 0.147-0.042 0.153 6e-3 6e-3 0.03-0.012-0.025 0.336z\" fill=\"#1a1a1a\"/>\n     <path d=\"m291.54 104.42c-0.3 0.27-0.441 0.343-0.587 0.453-0.147 0.11-0.361 0.171-0.551 0.269-0.19 0.092-0.447 0.116-0.68 0.202-0.226 0.085-1.022 0.11-1.346 0.153-0.691 0.086-1.15 0.159-1.426 0.27-0.6 0.214-0.955 0.275-1.298 0.496-0.342 0.22-0.612 0.551-0.838 0.808-0.227 0.257-0.312 0.49-0.404 0.747-0.104 0.318-0.092 0.655-0.073 0.998 0.018 0.538 0.434 1.132 0.734 1.523 0.293 0.398 0.3 0.257 0.679 0.526 0.379 0.263 0.918 0.404 1.518 0.404 0.374 0 0.759-0.031 1.157-0.092 0.306-0.043 0.637-0.239 1.096-0.392 0.146-0.049 0.489-0.361 0.655-0.422 0 0 0.422-0.342 0.844-1.077 0.422-0.734 0.508-1.952 0.508-1.952z\" fill=\"#1a1a1a\"/>\n     <path d=\"m341.81 104.23c-0.294 0.27-0.44 0.349-0.588 0.459-0.146 0.11-0.379 0.153-0.569 0.251-0.189 0.092-0.428 0.135-0.66 0.22-0.227 0.086-1.022 0.11-1.347 0.153-0.691 0.085-1.15 0.159-1.426 0.269-0.6 0.22-0.961 0.282-1.304 0.496-0.343 0.221-0.618 0.551-0.845 0.808s-0.318 0.489-0.404 0.747c-0.104 0.318-0.085 0.655-0.073 1.003 0.019 0.533 0.435 1.132 0.734 1.524 0.3 0.398 0.3 0.257 0.686 0.526 0.38 0.263 0.918 0.404 1.524 0.404 0.373 0 0.759-0.03 1.162-0.092 0.307-0.042 0.643-0.245 1.096-0.392 0.146-0.049 0.489-0.361 0.655-0.422 0 0 0.422-0.343 0.844-1.077 0.423-0.729 0.509-1.953 0.509-1.953z\" fill=\"#1a1a1a\"/>\n     <path d=\"m119.14 577.38c12.815-43.023 10.985-43.023 17.393-58.582 6.408-15.562 19.223-16.475 35.698-20.135 82.805-10.454 167.09-15.742 247.15-7e-5 16.476 3.66 29.291 4.578 35.698 20.135 6.407 15.564 4.578 15.564 17.394 58.582 12.814 43.018 69.554-66.818 95.184-228.83 25.631-162.01-11.848-224.91-22.222-230.4-10.373-5.49-79.382-20.404-79.382-20.404-18.269-23.911-37.871-41.377-57.039-54.199v181.14c0 53.85-43.807 97.657-97.656 97.657h-21.524c-53.85 0-97.657-43.808-97.657-97.657v-187.17c-22.156 13.194-45.296 32.319-66.624 60.232 0 0-69.009 14.908-79.382 20.404-10.374 5.49-47.853 68.385-22.222 230.4 25.624 162.01 82.375 271.85 95.19 228.83zm373.77-258.73c-13.801 0-25.031-11.223-25.031-25.024s11.23-25.031 25.031-25.031c13.8 0 25.024 11.224 25.024 25.031 1e-3 13.802-11.224 25.024-25.024 25.024zm48.207-96.432c13.801 0 25.03 11.224 25.03 25.031 0 13.801-11.229 25.025-25.03 25.025s-25.031-11.224-25.031-25.025 11.23-25.031 25.031-25.031zm-47.601-46.989c13.801 0 25.031 11.224 25.031 25.031 0 13.8-11.23 25.024-25.031 25.024s-25.03-11.224-25.03-25.024c5e-3 -13.801 11.229-25.031 25.03-25.031zm-48.207 46.383c13.801 0 25.024 11.224 25.024 25.031 0 13.801-11.224 25.025-25.024 25.025s-25.031-11.224-25.031-25.025c6e-3 -13.807 11.236-25.031 25.031-25.031zm-176.43 232.05 28.458-48.342c1.408-2.418 5.056-2.441 6.5-6e-3l28.451 48.342c0.729 1.242 0.759 2.662 0.099 3.818-0.655 1.15-1.91 1.842-3.33 1.842h-56.928c-1.426 0-2.674-0.691-3.335-1.842-0.668-1.156-0.631-2.582 0.085-3.812zm-136.01-171.33c0.12593-2.6961 5.1037 2.1992 4.895 4.8902v26.23l26.231-1.6e-4c2.693-2e-5 4.89 2.191 4.89 4.891v23.801c0 2.697-2.191 4.889-4.89 4.889l-26.231 1.6e-4v26.23c0 2.693-2.19 4.8908-4.895 4.8908h-23.801c-2.692 0-4.89-2.191-4.89-4.891v-26.23h-26.23c-2.693 0-4.89-2.191-4.89-4.889v-23.801c0-2.693 2.191-4.891 4.89-4.891h26.23v-26.23c0-2.699 2.191-4.89 4.89-4.89 7.9337 0 15.867 169.86 23.801 0zm-54.009-133.64c24.902 0 45.166 20.263 45.166 45.166s-20.263 45.166-45.166 45.166-45.166-20.263-45.166-45.166 20.264-45.166 45.166-45.166z\" fill=\"#f2f2f2\" stroke=\"#000\" stroke-width=\"3.2267\"/>\n     <path d=\"m371.79 133.6h-142.4v126.1h142.4zm-8.256 117.31c0 0.985-0.796 1.781-1.781 1.781h-122.33c-0.979 0-1.781-0.796-1.781-1.781v-108.51c0-0.985 0.795-1.781 1.781-1.781h122.33c0.985 0 1.781 0.795 1.781 1.781z\" fill=\"#1a1a1a\"/>\n     <path d=\"m126.54 95.719a205.64 206.43 0 0 0-36.058 116.76 205.64 206.43 0 0 0 205.64 206.43 205.64 206.43 0 0 0 205.64-206.43 205.64 206.43 0 0 0-36.06-116.76z\" clip-path=\"none\" fill=\"none\" stroke=\"#000\" stroke-width=\"7.4\"/>\n     <path d=\"m289.82 316.22h21.523c50.558 0 91.537-40.985 91.537-91.536v-185.14c-45.018-27.974-86.578-30.765-101.38-30.765-3.69 0-5.71 0.171-5.71 0.171s-2.026-0.171-5.71-0.171c-13.733 0-50.551 2.405-91.8 25.153v190.75c0 50.552 40.986 91.537 91.537 91.537zm66.506-218.18 1.806-0.061c0.018-0.379-0.031-1.567-0.031-2.497 0-0.453-0.227-0.869-0.41-1.096 0.82-0.184 2.069-0.563 2.638-0.728-6e-3 1.469 0.099 3.556 0.117 4.321l3.684 0.055c-0.019 0.63 0.049 0.851 0.062 1.419l-1.016-0.122h-2.705l-0.05 8.103-0.024 0.679c0.024 0.723 0.123 1.641 0.282 2.001 0.159 0.361 0.385 0.496 0.679 0.655 0.3 0.159 0.637 0.196 0.949 0.196 0.22 0 0.551-6e-3 0.808-6e-3s0.435-0.019 1.071-0.202c-0.08 0.478-0.209 0.741-0.294 1.536-0.588 0.166-0.857 0.208-1.206 0.245-0.349 0.043-0.679-0.067-0.997-0.067-0.777 0-1.414-0.11-1.903-0.337-0.49-0.22-0.869-0.575-1.139-1.071-0.275-0.49-0.465-1.708-0.496-2.552-6e-3 -0.11-6e-3 -0.3-0.012-0.575 0-0.275-0.019-0.551 0-2.197l-0.056-6.402h-1.774c0.023-0.397 0.023-0.519 0.017-1.297zm-2.932 9.309c-0.135-0.184-0.643-0.618-0.899-0.838-0.257-0.227-0.937-0.557-1.824-0.924-0.899-0.379-2.044-0.74-2.46-1.089-0.416-0.355-1.175-0.759-1.475-1.132s-0.526-0.74-0.68-1.12c-0.153-0.374-0.043-0.943-0.055-1.328-0.024-0.618 0.36-1.254 0.728-1.836 0.361-0.575 0.992-0.9 1.714-1.188 0.723-0.281 1.579-0.428 2.564-0.428 1.102 0 2.166 0.214 3.501 0.471 0.073 0.753-0.099 1.273-7e-3 1.897-0.961-0.636-2.025-0.955-3.072-0.955-0.568 0-1.145 0.086-1.621 0.233-0.478 0.146-1.01 0.624-1.218 0.918-0.215 0.3-0.331 0.581-0.318 0.936 6e-3 0.233 0.079 0.618 0.165 0.833 0.086 0.214 0.648 0.808 0.942 0.937 0.404 0.177 0.245 0.153 0.612 0.232 0.416 0.092 1.444 0.618 2.423 1.083 1.017 0.483 1.946 1.089 2.265 1.408 0.324 0.318 0.637 0.759 0.931 1.438 0.165 0.38 0.257 0.826 0.257 1.145 0 0.551-0.146 0.625-0.129 0.967 0.031 0.673-0.141 0.924-0.514 1.5s-1.071 1.126-1.849 1.444c-0.777 0.318-1.604 0.582-2.576 0.582-0.416 0-1.377 0.049-1.934-6e-3 -0.558-0.049-1.035-0.239-1.427-0.312s-0.643-0.092-1.224-0.232l-0.202-0.985c-6e-3 -0.116-0.263-0.771-0.373-1.396 1.646 0.906 3.385 1.542 4.633 1.542 0.654 0 1.304-0.19 1.75-0.361 0.447-0.171 0.882-0.489 1.096-0.826 0.208-0.336 0.44-0.661 0.521-1.016 0.049-0.196 0.11-0.459 0.061-0.637-0.067-0.211-0.171-0.774-0.306-0.957zm-86.138-55.282c0.324-2.111 0.955-4.223 1.364-5.673 0.973-3.47 3.581-8.672 4.841-10.429s1.762-2.295 3.592-4.339 0.783-0.637 4.174-3.421c3.384-2.785 7.938-4.78 9.933-5.587 1.995-0.814 5.037-2.301 10.521-2.668s8.794 0.312 11.854 0.667c3.586 0.417 10.435 2.754 10.435 2.754s3.996 1.805 7.093 3.837c1.671 1.004 3.158 2.987 4.676 4.927 2.087 2.668 4.131 6.028 4.425 6.505 0.508 0.814 2.778 4.908 3.256 6.426s1.542 7.117 1.628 7.729 0.937 4.051-2.001 4.253c-3.22 0.22-3.55-3.066-3.758-4.002-0.214-0.942-2.387-8.158-3.14-9.517s-5.264-7.962-7.265-10.135-5.894-4.951-10.141-6.255c-4.063-1.254-10.961-2.479-15.6-2.276-4.076 0.177-5.416 0.459-7.191 1.022-3.629 1.157-6.812 2.993-9.015 4.382-2.203 1.383-5.899 4.357-7.515 6.383-1.916 2.405-5.166 8.354-5.888 11.64-1.334 6.114-0.502 12.014-0.502 12.014s1.506 11.579 9.015 17.521c2.938 2.332 5.336 3.562 12.02 5.379 0.937 0.257 3.978 0.471 7.778 0.496 3.801 0.019 4.957-0.11 7.124-0.869 2.16-0.759 2.852-0.894 4.504-1.75 1.659-0.857 4.505-1.799 7.559-4.811 1.707-1.689 3.837-5.006 4.719-8.329 0.514-1.946 0.189-2.552 0.122-5.104-0.019-0.783-0.092-1.493-0.153-2.167-0.146-1.524-0.397-2.938-0.93-5.178-0.771-3.231-0.539-2.387-1.292-4.449-0.52-1.42-1.107-2.577-1.523-3.25s-0.814-1.12-1.273-1.818c-3.17-4.841-9.431-8.011-15.232-8.201-1.934-0.067-4.314 0.135-6.714 0.894-1.628 0.514-3.268 1.346-4.786 2.271-0.63 0.379-1.23 0.673-1.812 1.132-0.587 0.471-0.942 0.606-1.462 1.157-0.471 0.501-1.114 1.628-1.5 2.136-4.725 6.065-3.629 11.689-3.629 11.689s-0.44 13.207 13.52 14.646c3.525 0.171 9.89-2.087 12.301-4.67 1.481-1.591 1.585-4.437 1.536-6.964-0.036-2.001-1.016-5.551-2.552-6.922-3.342-2.98-6.12-3.072-7.576-3.158-1.94-0.123-4.7 0.477-5.79 4.725-0.38 1.475 0.777 4.547 2.962 4.982 1.879 0.379 3.88 0 4.762 0.128 0.783 0.11 1.971-0.153 1.971 2.313-0.221 4.321-9.633 1.903-9.737 1.812-0.722-0.624-4.969-3.042-5.134-7.631-0.178-4.847 2.099-8.507 6.236-10.576 1.041-0.52 2.956-0.783 4.254-0.838 3.524 0.171 6.021 0.63 8.604 2.02 0.483 0.263 0.979 0.477 1.512 0.838 0.165 0.11 0.802 0.557 0.899 0.618 3.023 2.601 4.284 6.035 4.884 9.499 0.238 1.377 0.232 2.662 0.275 3.678 0.08 1.738-0.122 3.843-1.01 5.82-0.942 2.112-2.638 4.082-5 5.318-2.295 1.2-5.643 3.103-10.264 3.672-2.784 0.342-6.021 0.287-9.773-0.924-10.643-3.439-11.646-15.514-11.646-15.514s-2.173-8.898 3.69-16.916c0.618-0.844 1.322-1.928 2.129-2.735 2.644-2.644 5.012-4.015 7.185-5.166 3.99-2.111 6.916-2.595 7.779-2.595 0.618 0 2.093-0.085 3.824 0.043 1.983 0.141 4.309 0.526 6.065 0.955 1.928 0.471 3.537 0.851 4.792 1.383 1.188 0.508 2.038 1.175 2.968 1.744 1.922 1.169 4.982 3.488 6.017 5.055 1.07 1.628 2.589 3.715 3.77 7.387 0.691 2.154 1.273 5.232 1.983 8.703 1.064 5.196 0.679 10.447-0.502 13.764-0.129 0.355-1.451 4.566-5.637 8.513-4.187 3.954-9.455 6.193-11.016 6.817-1.567 0.625-3.795 2.521-12.332 2.381-7.387-0.123-12.987-2.081-14.651-2.754-1.665-0.673-6.059-2.068-10.833-7.319-4.773-5.257-5.814-8.648-6.573-10.949s-2.191-8.195-2.191-8.195 0.171-0.024-0.171-3.066c-0.129-1.359-0.111-3.133 0.159-4.908zm73.825 59.388c-0.465 0.386-0.937 0.673-1.236 0.857-0.637 0.134-1.021 0.281-1.426 0.312-0.404 0.037-0.783 0.049-1.15 0.049-1.212 0-2.1-0.367-2.791-0.686-0.691-0.318-1.261-0.875-1.622-1.523-0.36-0.649-0.44-1.243-0.471-2.008-0.019-0.446 0.11-0.905 0.22-1.279 0.104-0.379 0.251-0.716 0.447-1.022 0.189-0.306 0.33-0.539 0.691-0.851 0.361-0.306 0.575-0.478 0.979-0.673 0.403-0.202 0.777-0.288 1.315-0.483 0.539-0.196 1.524-0.263 2.785-0.441 0.385-0.098 0.71-0.073 0.979-0.177 0.27-0.104 0.509-0.208 0.717-0.306s0.385-0.214 0.538-0.349 0.294-0.3 0.416-0.49c0.129-0.196 0.215-0.141 0.27-0.336 0.055-0.196 0.024-0.294 0.019-0.496-0.019-0.489-0.043-0.765-0.337-1.107s-0.637-0.833-1.102-0.967c-0.459-0.141-1.23-0.361-1.849-0.361-0.575 0-1.046 0.073-1.646 0.178-0.6 0.104-1.114 0.232-1.549 0.373-0.429 0.147-0.918 0.361-1.561 0.649 0.062-0.435 0.013-1.065 0.062-1.922 1.053-0.306 1.609-0.453 2.387-0.563s1.928-0.178 2.674-0.178c0.796 0 1.292 0.171 1.995 0.337 0.698 0.165 1.586 0.777 1.91 1.261 0.336 0.496 0.648 0.856 0.819 1.334 0.172 0.478 0.404 1.42 0.429 1.958 0.024 0.679 0.062 0.239 0.037 1.842-0.024 1.609 0.073 4.547 0.061 5.912-6e-3 0.833 0.099 0.912 0.318 2.038-0.483-0.019-1.102 0.024-1.401 0.024-0.287 0-0.71-0.043-1.236-0.024v-1.53c7e-3 6e-3 -0.226 0.263-0.691 0.648zm-19.155-3.378c0.336 0.838 0.899 1.659 1.683 2.118s1.701 0.906 2.662 0.906c0.931 0 2.889-0.098 5.013-1.224-0.013 0.159-0.098 0.514-0.153 0.942-0.055 0.435-0.178 0.796-0.214 1.212-0.637 0.166-1.31 0.349-1.903 0.41-0.588 0.061-2.197 0.165-2.644 0.165-0.949 0-2.051-0.196-2.864-0.483-0.814-0.288-1.83-0.832-2.448-1.487-0.624-0.655-1.328-1.31-1.646-2.283s-0.545-1.909-0.581-2.993c-0.056-1.457 0.177-1.946 0.587-3.25 0.404-1.31 1.438-2.252 2.394-2.993 0.954-0.741 3.164-1.371 4.859-1.371 1.248 0 2.711 0.208 3.91 0.575 0.086 0.851 0.116 1.31 0.178 1.861-0.845-0.3-1.616-0.649-2.148-0.753s-1.199-0.202-1.652-0.202c-0.771 0-2.411 0.343-3.011 0.655-0.6 0.318-1.102 0.765-1.512 1.353-0.41 0.581-0.734 1.395-0.894 2.197s-0.221 0.869-0.189 1.702c0.04 1.125 0.23 2.104 0.573 2.943zm-6.898-5.263c-0.019-0.575-0.189-1.224-0.306-1.548-0.116-0.324-0.704-0.924-0.949-1.187-0.244-0.263-0.611-0.312-0.961-0.447-0.349-0.135-0.911-0.166-1.353-0.166-0.354 0-0.802 0.062-1.095 0.147-0.275 0.086-0.551 0.147-0.809 0.331-0.281 0.189-0.532 0.3-0.752 0.575-0.221 0.27-0.398 0.575-0.545 0.912-0.153 0.349-0.159 0.869-0.189 1.432-0.037 0.606 0.03 1.383 0.012 2.252-0.024 0.918-0.024 4.56 0 6.065l0.422 1.346c-0.514-0.018-1.272-0.03-1.529-0.03-0.239 0-0.894 6e-3 -1.457 0.03 0.043-1.224 0.19-0.11 0.196-1.407l0.024-5.594c0-1.108-0.013-2.057-0.043-2.833-0.019-0.508-0.079-0.686-0.184-1.041-0.098-0.355-0.275-0.802-0.532-1.096-0.251-0.293-0.808-0.765-1.15-0.918-0.35-0.153-0.839-0.269-1.268-0.269-0.452 0-0.746 0.049-1.138 0.22s-0.734 0.251-1.059 0.594c-0.318 0.336-0.588 0.373-0.796 0.869-0.208 0.489-0.367 0.385-0.459 1.181-0.098 0.795-0.141 3.69-0.135 5.667 6e-3 1.169 0.019 2.228 0.037 3.183 0.012 0.654 0.281 0.887 0.306 1.444-0.569-0.018-1.212-0.03-1.42-0.03-0.232 0-1.01 6e-3 -1.585 0.03l0.318-1.028c0.012-0.453 0.019-1.922 0.024-2.901l-0.147-8.292c-0.018-0.741-0.416-1.628-0.435-2.014 0.41 0.012 1.335-0.135 1.763-0.294 0.343-0.128 0.729-0.128 1.09-0.141l-6e-3 1.928c0.275-0.557 0.776-0.612 1.01-0.942 0.232-0.324 0.471-0.312 0.856-0.587s0.624-0.288 1.139-0.361c0.63-0.092 1.027-0.123 1.572-0.123 0.38 0 0.753 0.049 1.126 0.147 0.374 0.098 0.717 0.239 1.041 0.417 0.318 0.177 0.594 0.379 0.826 0.605 0.232 0.227 0.483 0.349 0.691 0.741 0.073 0.128 0.637-0.624 1.426-1.083 0.79-0.453 1.72-0.802 2.711-0.802 0.637 0 2.057 0.085 2.662 0.312 0.606 0.227 1.463 0.557 1.836 0.979 0.367 0.429 0.478 0.618 0.809 0.967 0.41 0.435 0.538 1.53 0.562 1.995 0.019 0.477 0.067 1.199 0.067 2.16l6e-3 6.818c0 0.655 0.19 0.734 0.312 1.481-0.471-0.019-1.083-0.031-1.353-0.031-0.281 0-0.955 6e-3 -1.506 0.031 0.367-1.169 0.294-0.771 0.325-1.487l0.024-6.181c-2e-3 -0.87-7e-3 -1.384-0.032-2.026zm-24.217 8.831c-0.459 0.386-0.937 0.667-1.23 0.857-0.637 0.135-1.016 0.282-1.42 0.312-0.404 0.031-0.79 0.049-1.151 0.049-1.206 0-2.093-0.367-2.784-0.686-0.692-0.318-1.255-0.875-1.616-1.524-0.361-0.648-0.441-1.242-0.471-2.007-0.019-0.447 0.116-0.906 0.22-1.279 0.104-0.374 0.251-0.716 0.44-1.022 0.19-0.306 0.331-0.539 0.692-0.844 0.361-0.306 0.575-0.478 0.979-0.673s0.771-0.288 1.31-0.483c0.539-0.19 1.524-0.263 2.778-0.441 0.38-0.098 0.71-0.073 0.979-0.177s0.508-0.208 0.716-0.306 0.386-0.214 0.539-0.349 0.294-0.3 0.417-0.49c0.128-0.196 0.214-0.263 0.269-0.459s0.024-0.294 0.019-0.496c-0.019-0.49-0.043-0.637-0.337-0.985-0.293-0.349-0.636-0.833-1.095-0.967s-1.224-0.361-1.842-0.361c-0.575 0-1.046 0.074-1.646 0.177-0.6 0.104-1.114 0.233-1.548 0.374-0.429 0.147-0.918 0.361-1.561 0.649 0.062-0.441 0.012-1.065 0.062-1.928 1.046-0.3 1.604-0.453 2.38-0.563 0.777-0.11 1.928-0.177 2.668-0.177 0.795 0 1.292 0.171 1.989 0.336 0.704 0.166 1.579 0.777 1.904 1.261 0.336 0.496 0.648 0.851 0.82 1.328 0.165 0.478 0.404 1.42 0.428 1.958 0.025 0.686 0.062 0.239 0.037 1.842-0.025 1.609 0.073 4.547 0.061 5.912-6e-3 0.826 0.098 0.912 0.318 2.038-0.478-0.019-1.096 0.024-1.402 0.024-0.281 0-0.709-0.043-1.236-0.024v-1.53c6e-3 0.011-0.227 0.268-0.686 0.654zm-19.975-3.109c0.422 0.875 0.991 1.438 1.769 1.891 0.777 0.447 1.805 0.839 2.791 0.839 1.139 0 3.213-0.478 4.915-1.328-0.085 0.539-0.263 1.242-0.336 2.075-0.838 0.238-2.222 0.771-2.84 0.856-0.618 0.086-1.23 0.104-1.848 0.104-1.102 0-2.197-0.275-3.084-0.569-0.888-0.3-1.775-0.912-2.424-1.652-0.655-0.735-1.297-1.536-1.603-2.491-0.312-0.948-0.386-1.909-0.429-2.968-0.055-1.475 0.184-2.025 0.637-3.286s1.401-2.179 2.387-2.901c0.979-0.722 2.246-1.083 3.794-1.083 0.802 0 1.713 0.062 2.454 0.325 0.74 0.263 1.365 0.539 1.867 1.071 0.508 0.539 0.93 1.071 1.224 1.86 0.294 0.79 0.361 0.802 0.526 1.72 0.074 0.429 0.129 1.102 0.092 1.438l-10.49 0.061c-0.012 0.545-0.049 0.814-0.037 1.096 0.029 1.045 0.212 2.067 0.635 2.942zm-11.12-10.288c0.318-0.067 1.102-0.177 1.518-0.189l6e-3 2.644c0.3-0.612 0.318-0.575 0.563-0.881 0.239-0.312 0.624-0.667 0.93-0.869 0.312-0.202 0.649-0.49 1.046-0.606 0.392-0.117 0.753-0.282 1.188-0.3 0.343-0.012 0.667-0.061 1.548 0.031 0.887 0.092 1.353 0.294 1.548 0.349 0.019 0.355-0.649 1.989-0.649 1.989s-0.636-0.055-1.211-0.293c-0.551-0.166-0.924-0.166-1.359-0.166-0.514 0-1.12 0.116-1.524 0.312-0.404 0.19-0.79 0.422-1.102 0.814s-0.52 0.796-0.71 1.34c-0.159 0.441-0.104 0.073-0.165 0.765-0.067 0.691-6e-3 7.326 0.049 8.819l0.263 0.857c-0.483-0.019-1.169 0-1.462 0-0.27 0-0.924 0.012-1.469 0.03 0-0.281 0.282-0.673 0.288-0.942 0.067-4.633-0.03-8.213-0.141-11.206l-0.049-1.261-0.44-1.071c0.446-0.05 1.052-0.111 1.334-0.166zm-18.654-6.224c0.533 0 1.322 0.086 2.436 0.062 1.114-0.025 2.105 0 2.546 0.042 1.585 0.147 1.989 0.233 3.078 0.502 0.826 0.196 2.393 1.034 3.091 1.53 0.704 0.496 1.401 1.064 1.97 1.866 0.563 0.802 0.845 1.059 1.224 1.989 0.508 1.261 0.802 2.625 0.851 3.892 0.067 1.732-0.116 3.06-0.618 4.651-0.496 1.591-1.603 2.772-2.668 3.837s-2.234 1.708-3.593 2.044c-1.365 0.336-2.901 0.667-4.596 0.667l-3.991-0.03-3.8-0.092 0.539-1.42-0.043-17.528c-0.012-0.508-0.251-1.034-0.501-1.922 1.198 0.027 3.224-0.09 4.075-0.09zm-17.797 168.64v-128.02c0-2.846 2.313-5.159 5.159-5.159h144.32c2.846 0 5.159 2.313 5.159 5.159v128.02c0 2.846-2.313 5.159-5.159 5.159h-144.32c-2.846 1e-3 -5.159-2.312-5.159-5.158z\" fill=\"#1a1a1a\"/>\n     <ellipse cx=\"444.94\" cy=\"246.54\" rx=\"25.204\" ry=\"25.115\" fill=\"#fff\"/>\n     <path d=\"m445.3 265.55c10.422 0 18.904-8.482 18.904-18.905s-8.482-18.911-18.904-18.911c-10.429 0-18.911 8.482-18.911 18.911s8.482 18.905 18.911 18.905z\" fill=\"#1a1a1a\"/>\n     <ellipse cx=\"492.88\" cy=\"293.45\" rx=\"25.204\" ry=\"25.115\" fill=\"#fff\"/>\n     <path d=\"m492.9 274.71c-10.429 0-18.911 8.482-18.911 18.911 0 10.428 8.482 18.905 18.911 18.905 10.422 0 18.904-8.482 18.904-18.905s-8.482-18.911-18.904-18.911z\" fill=\"#1a1a1a\"/>\n     <ellipse cx=\"541.23\" cy=\"247.25\" rx=\"25.204\" ry=\"25.115\" fill=\"#fff\"/>\n     <circle cx=\"541.11\" cy=\"247.25\" r=\"18.911\" fill=\"#1a1a1a\"/>\n     <path d=\"m78.855 232.89c21.53 0 39.045-17.515 39.045-39.045s-17.515-39.045-39.045-39.045-39.046 17.515-39.046 39.045 17.522 39.045 39.046 39.045z\" fill=\"#1a1a1a\"/>\n     <polygon transform=\"translate(6.8088,8.7805)\" points=\"124.82 279.67 103.48 279.67 103.48 310.78 72.364 310.78 72.364 332.13 103.48 332.13 103.48 363.25 124.82 363.25 124.82 332.13 155.94 332.13 155.94 310.78 124.82 310.78\" fill=\"#1a1a1a\"/>\n     <polygon transform=\"translate(6.8088,8.7805)\" points=\"318.12 444.41 293.78 403.06 269.44 444.41\" fill=\"#1a1a1a\"/>\n     <polygon transform=\"translate(6.8088,8.7805)\" points=\"124.82 332.13 155.94 332.13 155.94 310.78 124.82 310.78 124.82 279.67 103.48 279.67 103.48 310.78 72.364 310.78 72.364 332.13 103.48 332.13 103.48 363.25 124.82 363.25\" fill=\"#1a1a1a\"/>\n     <ellipse cx=\"409.18\" cy=\"244.08\" rx=\"25.204\" ry=\"25.115\" fill=\"#fff\"/>\n    </g>\n   </g>\n   <path d=\"m444.19 415.9c23.103 0 41.897-18.795 41.897-41.897s-18.794-41.897-41.897-41.897c-23.103 0-41.898 18.795-41.898 41.897s18.802 41.897 41.898 41.897z\" stroke-width=\".86172\"/>\n   <path d=\"m444.19 412.57c21.38 0 38.773-17.297 38.773-38.56 0-21.263-17.393-38.56-38.773-38.56-21.38 0-38.775 17.297-38.775 38.56 0 21.263 17.4 38.56 38.775 38.56z\" fill=\"#ececec\" stroke-width=\".86172\"/>\n   <path d=\"m444.19 407.65c18.553 0 33.646-15.093 33.646-33.646 0-18.553-15.093-33.646-33.646-33.646-18.553 0-33.647 15.093-33.647 33.646 0 18.553 15.099 33.646 33.647 33.646z\" fill=\"#333\" stroke=\"#000\" stroke-width=\"2.9069\" data-button=\"button-11\"/>\n   <path d=\"m78.499 243.34c26.81 0 48.62-21.811 48.62-48.621s-21.81-48.621-48.62-48.621-48.622 21.811-48.622 48.621 21.819 48.621 48.622 48.621z\"/>\n   <path d=\"m78.499 239.47c24.811 0 44.995-20.073 44.995-44.748s-20.184-44.748-44.995-44.748-44.997 20.073-44.997 44.748 20.192 44.748 44.997 44.748z\" fill=\"#ececec\"/>\n   <path d=\"m78.499 233.76c21.53 0 39.045-17.515 39.045-39.045s-17.515-39.045-39.045-39.045-39.046 17.515-39.046 39.045 17.522 39.045 39.046 39.045z\" fill=\"#333\" stroke=\"#000\" stroke-width=\"2.9069\" data-button=\"button-10\"/>\n   <path d=\"m491.78 320.33c14.996 0 27.196-12.2 27.196-27.196s-12.199-27.196-27.196-27.196c-14.996 0-27.197 12.2-27.197 27.196s12.204 27.196 27.197 27.196z\"/>\n   <path d=\"m491.78 317.32c13.408 0 24.317-10.848 24.317-24.183s-10.908-24.183-24.317-24.183c-13.409 0-24.317 10.848-24.317 24.183s10.912 24.183 24.317 24.183z\" fill=\"#ececec\"/>\n   <path d=\"m491.78 314.23c11.635 0 21.101-9.4653 21.101-21.101 0-11.635-9.4653-21.101-21.101-21.101-11.635 0-21.101 9.4653-21.101 21.101 0 11.635 9.4692 21.101 21.101 21.101z\" fill=\"#a02c2c\" data-button=\"button-0\"/>\n   <path d=\"m539.97 273.92c14.738 0 26.727-11.99 26.727-26.728s-11.989-26.728-26.727-26.728c-14.738 0-26.728 11.99-26.728 26.728s11.994 26.728 26.728 26.728z\"/>\n   <path d=\"m539.97 270.95c13.177 0 23.898-10.661 23.898-23.767 0-13.105-10.72-23.767-23.898-23.767s-23.899 10.661-23.899 23.767c0 13.105 10.724 23.767 23.899 23.767z\" fill=\"#ececec\"/>\n   <path d=\"m539.97 267.92c11.435 0 20.738-9.3024 20.738-20.738 0-11.435-9.3024-20.738-20.738-20.738-11.435 0-20.738 9.3024-20.738 20.738 0 11.435 9.3062 20.738 20.738 20.738z\" fill=\"#06f\" data-button=\"button-1\"/>\n   <path d=\"m493.22 227.32c14.738 0 26.727-11.99 26.727-26.728s-11.989-26.728-26.727-26.728c-14.738 0-26.728 11.99-26.728 26.728s11.994 26.728 26.728 26.728z\"/>\n   <path d=\"m493.22 224.36c13.177 0 23.898-10.661 23.898-23.767 0-13.105-10.72-23.767-23.898-23.767s-23.899 10.661-23.899 23.767c0 13.105 10.724 23.767 23.899 23.767z\" fill=\"#ececec\"/>\n   <path d=\"m493.22 221.33c11.435 0 20.738-9.3024 20.738-20.738 0-11.435-9.3024-20.738-20.738-20.738-11.435 0-20.738 9.3024-20.738 20.738 0 11.435 9.3062 20.738 20.738 20.738z\" fill=\"#1ccb1c\" data-button=\"button-3\"/>\n   <path d=\"m444.79 268.33c14.738 0 26.727-11.99 26.727-26.728s-11.989-26.728-26.727-26.728c-14.738 0-26.728 11.99-26.728 26.728s11.994 26.728 26.728 26.728z\"/>\n   <path d=\"m444.79 265.37c13.177 0 23.898-10.661 23.898-23.767 0-13.105-10.72-23.767-23.898-23.767s-23.899 10.661-23.899 23.767c0 13.105 10.724 23.767 23.899 23.767z\" fill=\"#fff\"/>\n   <path d=\"m444.79 262.34c11.435 0 20.738-9.3024 20.738-20.738 0-11.435-9.3024-20.738-20.738-20.738-11.435 0-20.738 9.3024-20.738 20.738 0 11.435 9.3062 20.738 20.738 20.738z\" fill=\"#fa9900\" data-button=\"button-2\"/>\n   <polygon transform=\"matrix(1.7101,0,0,1.7148,-202.93,-294.51)\" points=\"269.44 444.41 318.12 444.41 293.78 403.06\" fill=\"#fff\" stroke=\"#000\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2.0439\"/>\n   <g transform=\"matrix(1.2116 0 0 1.2405 -56.477 -89.866)\" fill=\"#333\" stroke=\"#000\" stroke-width=\"2.3711\">\n    <polygon points=\"269.44 444.41 318.12 444.41 293.78 403.06\" fill=\"#333\" stroke=\"#000\" stroke-width=\"2.3711\" data-button=\"button-9\"/>\n   </g>\n   <text x=\"484.67032\" y=\"210.79993\" fill=\"#000000\" fill-opacity=\".75\" font-family=\"sans-serif\" font-size=\"40px\" letter-spacing=\"0px\" stroke-width=\"1.8197\" word-spacing=\"0px\" style=\"line-height:1.25\" xml:space=\"preserve\"><tspan x=\"484.67032\" y=\"210.79993\" fill=\"#000000\" fill-opacity=\".75\" font-family=\"sans-serif\" font-size=\"28px\" stroke-width=\"1.8197\" style=\"font-variant-caps:normal;font-variant-east-asian:normal;font-variant-ligatures:normal;font-variant-numeric:normal\">Y</tspan></text>\n   <text x=\"435.22971\" y=\"251.80605\" fill=\"#000000\" fill-opacity=\".75\" font-family=\"sans-serif\" font-size=\"40px\" letter-spacing=\"0px\" stroke-width=\"1.8197\" word-spacing=\"0px\" style=\"line-height:1.25\" xml:space=\"preserve\"><tspan x=\"435.22971\" y=\"251.80605\" fill=\"#000000\" fill-opacity=\".75\" font-family=\"sans-serif\" font-size=\"28px\" stroke-width=\"1.8197\" style=\"font-variant-caps:normal;font-variant-east-asian:normal;font-variant-ligatures:normal;font-variant-numeric:normal\">X</tspan></text>\n   <text x=\"531.4353\" y=\"257.39502\" fill=\"#000000\" fill-opacity=\".75\" font-family=\"sans-serif\" font-size=\"40px\" letter-spacing=\"0px\" stroke-width=\"1.8197\" word-spacing=\"0px\" style=\"line-height:1.25\" xml:space=\"preserve\"><tspan x=\"531.4353\" y=\"257.39502\" fill=\"#000000\" fill-opacity=\".75\" font-family=\"sans-serif\" font-size=\"28px\" stroke-width=\"1.8197\" style=\"font-variant-caps:normal;font-variant-east-asian:normal;font-variant-ligatures:normal;font-variant-numeric:normal\">B</tspan></text>\n   <text x=\"482.2132\" y=\"303.34509\" fill=\"#000000\" fill-opacity=\".75\" font-family=\"sans-serif\" font-size=\"40px\" letter-spacing=\"0px\" stroke-width=\"1.8197\" word-spacing=\"0px\" style=\"line-height:1.25\" xml:space=\"preserve\"><tspan x=\"482.2132\" y=\"303.34509\" fill=\"#000000\" fill-opacity=\".75\" font-family=\"sans-serif\" font-size=\"28px\" stroke-width=\"1.8197\" style=\"font-variant-caps:normal;font-variant-east-asian:normal;font-variant-ligatures:normal;font-variant-numeric:normal\">A</tspan></text>\n   <path d=\"m173.25 347.86v-35.975h-35.335v-35.719h-36.421v35.719h-35.602v35.975h35.602v35.944h36.421v-35.944z\" fill=\"#fff\" stroke=\"#000\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-miterlimit=\"6.6\" stroke-width=\"3.1826\"/>\n   <g fill=\"#333\" stroke=\"#000\" stroke-width=\"2.0348\" data-button=\"dpad-0\">\n    <polygon transform=\"matrix(1.1296 0 0 1.1296 -9.6574 -33.438)\" points=\"103.48 363.25 124.82 363.25 124.82 332.13 155.94 332.13 155.94 310.78 124.82 310.78 124.82 279.67 103.48 279.67 103.48 310.78 72.364 310.78 72.364 332.13 103.48 332.13\" fill=\"#333\" stroke=\"#000\" stroke-width=\"1.8014\"/>\n   </g>\n   <path d=\"m246.43 423.18c9.522 0 17.268-7.7465 17.268-17.268 0-9.522-7.7461-17.268-17.268-17.268-9.522 0-17.269 7.7465-17.269 17.268 0 9.522 7.7493 17.268 17.269 17.268z\" stroke-width=\".63497\"/>\n   <path d=\"m246.43 420.5c8.0934 0 14.678-6.5481 14.678-14.597 0-8.0492-6.5842-14.597-14.678-14.597-8.0937 0-14.678 6.5481-14.678 14.597 0 8.0492 6.5869 14.597 14.678 14.597z\" fill=\"#ececec\" stroke-width=\".60362\"/>\n   <path d=\"m246.43 418.33c6.8504 0 12.424-5.5729 12.424-12.424 0-6.8504-5.5729-12.424-12.424-12.424-6.8504 0-12.424 5.5729-12.424 12.424 0 6.8504 5.5752 12.424 12.424 12.424z\" fill=\"#333\" stroke=\"#000\" stroke-width=\"1.4535\" data-button=\"button-8\"/>\n   <path d=\"m352.5 423.18c9.522 0 17.268-7.7465 17.268-17.268 0-9.522-7.7461-17.268-17.268-17.268-9.522 0-17.269 7.7465-17.269 17.268 0 9.522 7.7493 17.268 17.269 17.268z\" stroke-width=\".63497\"/>\n   <path d=\"m352.5 420.5c8.0934 0 14.678-6.5481 14.678-14.597 0-8.0492-6.5842-14.597-14.678-14.597-8.0937 0-14.678 6.5481-14.678 14.597 0 8.0492 6.5869 14.597 14.678 14.597z\" fill=\"#ececec\" stroke-width=\".60362\"/>\n   <path d=\"m352.5 418.33c6.8504 0 12.424-5.5729 12.424-12.424 0-6.8504-5.5729-12.424-12.424-12.424-6.8504 0-12.424 5.5729-12.424 12.424 0 6.8504 5.5752 12.424 12.424 12.424z\" fill=\"#333\" stroke=\"#000\" stroke-width=\"1.4535\" data-button=\"button-16\"/>\n   <text x=\"281.13306\" y=\"481.78577\" fill=\"#000000\" font-family=\"sans-serif\" font-size=\"40px\" letter-spacing=\"0px\" stroke-width=\"1.8191\" word-spacing=\"0px\" style=\"line-height:1.25\" xml:space=\"preserve\"><tspan x=\"281.13306\" y=\"481.78577\" fill=\"#000000\" font-family=\"sans-serif\" font-size=\"11.628px\" stroke-width=\"1.8191\" style=\"font-variant-caps:normal;font-variant-east-asian:normal;font-variant-ligatures:normal;font-variant-numeric:normal\">START</tspan></text>\n   <text x=\"224.14134\" y=\"384.38974\" fill=\"#000000\" font-family=\"sans-serif\" font-size=\"40px\" letter-spacing=\"0px\" stroke-width=\"1.8191\" word-spacing=\"0px\" style=\"line-height:1.25\" xml:space=\"preserve\"><tspan x=\"224.14134\" y=\"384.38974\" fill=\"#000000\" font-family=\"sans-serif\" font-size=\"11.628px\" stroke-width=\"1.8191\" style=\"font-variant-caps:normal;font-variant-east-asian:normal;font-variant-ligatures:normal;font-variant-numeric:normal\">SELECT</tspan></text>\n   <text x=\"334.6618\" y=\"384.38974\" fill=\"#000000\" font-family=\"sans-serif\" font-size=\"40px\" letter-spacing=\"0px\" stroke-width=\"1.8191\" word-spacing=\"0px\" style=\"line-height:1.25\" xml:space=\"preserve\"><tspan x=\"334.6618\" y=\"384.38974\" fill=\"#000000\" font-family=\"sans-serif\" font-size=\"11.628px\" stroke-width=\"1.8191\" style=\"font-variant-caps:normal;font-variant-east-asian:normal;font-variant-ligatures:normal;font-variant-numeric:normal\">HOME</tspan></text>\n  </g>\n </g>\n <g transform=\"translate(-260.34 -473.69)\">\n  <g cv-if = \"a\">\n  \t<path d=\"m591.98 611.79 68.946 20.079\" fill=\"none\" stroke=\"#000\" stroke-width=\".5\"/>\n  </g>\n  <g cv-if = \"x\">\n  \t<path d=\"m576.4 592.1 84.526 24.701\" fill=\"none\" stroke=\"#000\" stroke-width=\".5\"/>\n  </g>\n  <g cv-if = \"y\">\n  \t<path d=\"m595.33 575.12 65.6 18.183\" fill=\"none\" stroke=\"#000\" stroke-width=\".5\"/>\n  </g>\n  <g cv-if = \"b\">\n  \t<path d=\"m609.93 591.65 50.998 15.219\" fill=\"none\" stroke=\"#000\" stroke-width=\".5\"/>\n  </g>\n  <text x=\"662.21619\" y=\"608.90283\" fill=\"#000000\" font-family=\"sans-serif\" font-size=\"40px\" letter-spacing=\"0px\" word-spacing=\"0px\" style=\"line-height:1.25\" xml:space=\"preserve\"><tspan x=\"662.21619\" y=\"608.90283\" font-family=\"sans-serif\" font-size=\"6px\" style=\"font-variant-caps:normal;font-variant-east-asian:normal;font-variant-ligatures:normal;font-variant-numeric:normal\">[[b]]</tspan></text>\n  <text x=\"662.5141\" y=\"634.3454\" fill=\"#000000\" font-family=\"sans-serif\" font-size=\"40px\" letter-spacing=\"0px\" word-spacing=\"0px\" style=\"line-height:1.25\" xml:space=\"preserve\"><tspan x=\"662.5141\" y=\"634.3454\" font-family=\"sans-serif\" font-size=\"6px\" style=\"font-variant-caps:normal;font-variant-east-asian:normal;font-variant-ligatures:normal;font-variant-numeric:normal\">[[a]]</tspan></text>\n  <text x=\"662.27887\" y=\"619.60553\" fill=\"#000000\" font-family=\"sans-serif\" font-size=\"40px\" letter-spacing=\"0px\" word-spacing=\"0px\" style=\"line-height:1.25\" xml:space=\"preserve\"><tspan x=\"662.27887\" y=\"619.60553\" font-family=\"sans-serif\" font-size=\"6px\" style=\"font-variant-caps:normal;font-variant-east-asian:normal;font-variant-ligatures:normal;font-variant-numeric:normal\">[[x]]</tspan></text>\n  <text x=\"661.63348\" y=\"595.76831\" fill=\"#000000\" font-family=\"sans-serif\" font-size=\"40px\" letter-spacing=\"0px\" word-spacing=\"0px\" style=\"line-height:1.25\" xml:space=\"preserve\"><tspan x=\"661.63348\" y=\"595.76831\" font-family=\"sans-serif\" font-size=\"6px\" style=\"font-variant-caps:normal;font-variant-east-asian:normal;font-variant-ligatures:normal;font-variant-numeric:normal\">[[y]]</tspan></text>\n  <g cv-if = \"r1\">\n  \t<path d=\"m605.15 544.5 53.163 13.403\" fill=\"none\" stroke=\"#000\" stroke-width=\".5\"/>\n  </g>\n  <text x=\"659.01825\" y=\"560.35986\" fill=\"#000000\" font-family=\"sans-serif\" font-size=\"40px\" letter-spacing=\"0px\" word-spacing=\"0px\" style=\"line-height:1.25\" xml:space=\"preserve\"><tspan x=\"659.01825\" y=\"560.35986\" font-family=\"sans-serif\" font-size=\"6px\" style=\"font-variant-caps:normal;font-variant-east-asian:normal;font-variant-ligatures:normal;font-variant-numeric:normal\">[[r1]]</tspan></text>\n  <g cv-if = \"ra\">\n  <path d=\"m582.92 636.21 78.008 22.519\" fill=\"none\" stroke=\"#000\" stroke-width=\".5\"/>\n  </g>\n  <text x=\"664.28082\" y=\"661.3197\" fill=\"#000000\" font-family=\"sans-serif\" font-size=\"40px\" letter-spacing=\"0px\" word-spacing=\"0px\" style=\"line-height:1.25\" xml:space=\"preserve\"><tspan x=\"664.28082\" y=\"661.3197\" font-family=\"sans-serif\" font-size=\"6px\" style=\"font-variant-caps:normal;font-variant-east-asian:normal;font-variant-ligatures:normal;font-variant-numeric:normal\">[[ra]]</tspan></text>\n  <g cv-if = \"l1\">\n  \t<path d=\"m426.92 544.08-53.163 13.403\" fill=\"none\" stroke=\"#000\" stroke-width=\".5\"/>\n  </g>\n  <text x=\"347.5455\" y=\"559.51819\" fill=\"#000000\" font-family=\"sans-serif\" font-size=\"40px\" letter-spacing=\"0px\" word-spacing=\"0px\" style=\"line-height:1.25\" xml:space=\"preserve\"><tspan x=\"347.5455\" y=\"559.51819\" font-family=\"sans-serif\" font-size=\"6px\" style=\"font-variant-caps:normal;font-variant-east-asian:normal;font-variant-ligatures:normal;font-variant-numeric:normal\">[[l1]]</tspan></text>\n  <g cv-if = \"dpad\">\n\t<path d=\"m438.09 626.74-67.043 18.472\" fill=\"none\" stroke=\"#000\" stroke-width=\".5\"/>\n  </g>\n  <text x=\"352.86777\" y=\"647.30273\" fill=\"#000000\" font-family=\"sans-serif\" font-size=\"40px\" letter-spacing=\"0px\" word-spacing=\"0px\" style=\"line-height:1.25\" xml:space=\"preserve\"><tspan x=\"352.86777\" y=\"647.30273\" font-family=\"sans-serif\" font-size=\"6px\" style=\"font-variant-caps:normal;font-variant-east-asian:normal;font-variant-ligatures:normal;font-variant-numeric:normal\">[[dpad]]</tspan></text>\n  <g cv-if = \"start\">\n  \t<path d=\"m507.06 652.49-115.69 44.146\" fill=\"none\" stroke=\"#000\" stroke-width=\".5\"/>\n  </g>\n  <text x=\"371.43689\" y=\"698.36121\" fill=\"#000000\" font-family=\"sans-serif\" font-size=\"40px\" letter-spacing=\"0px\" word-spacing=\"0px\" style=\"line-height:1.25\" xml:space=\"preserve\"><tspan x=\"371.43689\" y=\"698.36121\" font-family=\"sans-serif\" font-size=\"6px\" style=\"font-variant-caps:normal;font-variant-east-asian:normal;font-variant-ligatures:normal;font-variant-numeric:normal\">[[start]]</tspan></text>\n </g>\n</svg>\n"
});

;require.register("controller/gamepad-config.html", function(exports, require, module) {
module.exports = "<div class = \"gamepad-config [[animation]] input-[[type]]\">\n\t<span>[[text]]</span>\n\t<div>[[caption]]</div>\n\t<!-- <div class = \"buttons\">\n\t\t<button cv-on = \"click:swap\">next</button>\n\t\t<button cv-on = \"click:exit\">exit</button>\n\t</div> -->\n</div>\n"
});

;require.register("controller/gc-input.svg", function(exports, require, module) {
module.exports = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<svg width=\"512\" height=\"288\" version=\"1.0\" xmlns=\"http://www.w3.org/2000/svg\"><g transform=\"translate(-260.34 -473.69)\"><g transform=\"translate(134.82 68.294)\"><g transform=\"matrix(.06485 0 0 .06485 172.41 452.75)\" stroke-width=\"15.42\"><g stroke-width=\"15.42\" data-button=\"button-6\"><g id=\"Shape_13_copy_1_\" enable-background=\"new    \" fill=\"#2d1650\"><g id=\"Shape_13_copy\" fill=\"#2d1650\" stroke-width=\"15.42\"><g fill=\"#2d1650\" stroke-width=\"15.42\"><ellipse cx=\"2016\" cy=\"596\" rx=\"394.32\" ry=\"416.56\" fill=\"#2d1650\" stroke-width=\"15.42\"/></g></g></g><g id=\"Shape_13_1_\" enable-background=\"new    \"><g stroke-width=\"15.42\"><g stroke-width=\"15.42\"><ellipse cx=\"2016\" cy=\"600\" rx=\"381.55\" ry=\"410.27\" fill=\"#eee\" stroke-width=\"207.68\"/></g></g></g></g><g stroke-width=\"15.42\" data-button=\"button-7\"><g id=\"Shape_13_copy_2_1_\" enable-background=\"new    \" fill=\"#2d1650\"><g fill=\"#2d1650\" stroke-width=\"15.42\"><g fill=\"#2d1650\" stroke-width=\"15.42\"><ellipse cx=\"4444\" cy=\"597\" rx=\"394.32\" ry=\"416.56\" fill=\"#2d1650\" stroke-width=\"15.42\"/></g></g></g><g id=\"Shape_13_copy_3_1_\" enable-background=\"new    \"><g stroke-width=\"15.42\"><g stroke-width=\"15.42\"><ellipse cx=\"4444\" cy=\"601\" rx=\"381.55\" ry=\"410.27\" fill=\"#eee\" stroke-width=\"207.68\"/></g></g></g></g><text transform=\"matrix(.68482 0 0 .68587 845.52 -545.07)\" fill=\"#000000\" fill-opacity=\".75\" font-family=\"sans-serif\" font-size=\"144px\" letter-spacing=\"0px\" stroke-width=\"22.5\" word-spacing=\"0px\" style=\"line-height:1.25;shape-inside:url(#rect1879-3-6-5-2);white-space:pre\" xml:space=\"preserve\"><tspan x=\"5247.6191\" y=\"1275.3691\"><tspan stroke-width=\"22.5\">R</tspan></tspan></text><g stroke-width=\"15.42\" data-button=\"button-5\"><g id=\"Shape_14_copy_1_\" transform=\"translate(63.785 -10.951)\" enable-background=\"new    \"><g id=\"Shape_14_copy\" stroke-width=\"15.42\"><g stroke-width=\"15.42\"><path d=\"m4875.8 533.15c-9.153-20.295-141.3-109.76-312.96-156.14-171.66-46.381-446.05-75.91-470.47-66.579-24.426 9.331-20.68 96.067-20.68 96.067l755.06 236.36c0 1e-3 58.209-89.412 49.057-109.71z\" fill=\"#490094\" stroke-width=\"207.68\"/></g></g></g><g id=\"Shape_14_1_\" transform=\"translate(63.785 -10.951)\" enable-background=\"new    \"><g stroke-width=\"15.42\"><g stroke-width=\"15.42\"><path d=\"m4862.8 543.29c-8.855-19.636-136.71-106.2-302.8-151.08s-431.57-73.446-455.2-64.418-20.008 92.95-20.008 92.95l730.55 228.69s56.319-86.51 47.464-106.15z\" fill=\"#5600ae\" stroke-width=\"207.68\"/></g></g></g></g><g stroke-width=\"15.42\" data-button=\"button-4\"><g transform=\"matrix(-1 0 0 1 6378.1 -10.674)\" enable-background=\"new    \"><g stroke-width=\"15.42\"><g stroke-width=\"15.42\"><path d=\"m4875.8 533.15c-9.153-20.295-141.3-109.76-312.96-156.14-171.66-46.381-446.05-75.91-470.47-66.579-24.426 9.331-20.68 96.067-20.68 96.067l755.06 236.36c0 1e-3 58.209-89.412 49.057-109.71z\" fill=\"#490094\" stroke-width=\"207.68\"/></g></g></g><g transform=\"matrix(-1 0 0 1 6378.1 -10.674)\" enable-background=\"new    \"><g stroke-width=\"15.42\"><g stroke-width=\"15.42\"><path d=\"m4862.8 543.29c-8.855-19.636-136.71-106.2-302.8-151.08s-431.57-73.446-455.2-64.418-20.008 92.95-20.008 92.95l730.55 228.69s56.319-86.51 47.464-106.15z\" fill=\"#5600ae\" stroke-width=\"207.68\"/></g></g></g></g><g id=\"Shape_15_copy_2_1_\" enable-background=\"new    \" stroke-width=\"15.42\"><g fill=\"#2d1650\" stroke-width=\"15.42\"><g fill=\"#2d1650\" stroke-width=\"15.42\"><path d=\"m3227.9 120.17c-783.43 0-1504.4 382.76-1504.4 382.76l447.27 1463.6s200.02-494.06 1045-494.06c807.36 0 1061.2 473.81 1061.2 473.81l423.57-1451.3s-688.92-374.76-1472.6-374.76z\" fill=\"#2d1650\" stroke-width=\"15.42\"/></g></g></g><g id=\"Shape_15_copy_3_1_\" enable-background=\"new    \" fill=\"#442178\" stroke-width=\"15.42\"><g fill=\"#442178\" stroke-width=\"15.42\"><g fill=\"#442178\" stroke-width=\"15.42\"><path d=\"m3228 136c-767.99 0-1504 388-1504 388l460 1390s194.99-457.37 1044-457.37c779.87 0 1036 437.37 1036 437.37l436-1378s-719.98-380-1472-380z\" fill=\"#442178\" stroke-width=\"15.42\"/></g></g></g><text transform=\"matrix(.49661 0 0 .49737 -1067.6 -73.788)\" fill=\"#000000\" fill-opacity=\".75\" font-family=\"sans-serif\" font-size=\"144px\" letter-spacing=\"0px\" stroke-width=\"31.027\" word-spacing=\"0px\" style=\"line-height:1.25;shape-inside:url(#rect1879-3-6-5-2-3-7);white-space:pre\" xml:space=\"preserve\"><tspan x=\"5247.6191\" y=\"1275.3691\"><tspan stroke-width=\"31.027\">ZL</tspan></tspan></text><g id=\"Shape_12_1_\" enable-background=\"new    \" fill=\"#2d1650\" stroke-width=\"15.42\"><g fill=\"#2d1650\" stroke-width=\"15.42\"><g fill=\"#2d1650\" stroke-width=\"15.42\"><path d=\"m1376.2 941.81c-30.5 123.8-80.063 786.99-61.001 1136.3 19.063 349.28 53.376 702.99 282.13 725.09s244-265.28 270.69-371.39c26.688-106.11 163.94-711.83 163.94-711.83s-625.25-901.94-655.75-778.15z\" fill=\"#2d1650\" stroke-width=\"15.42\"/></g></g></g><g id=\"Shape_12_copy_5_1_\" enable-background=\"new    \" fill=\"#442178\" stroke-width=\"15.42\"><g fill=\"#442178\" stroke-width=\"15.42\"><g fill=\"#442178\" stroke-width=\"15.42\"><path d=\"m1387.9 966.73c-28.94 121.04-75.969 769.48-57.881 1111s50.646 687.34 267.7 708.96c217.06 21.614 231.52-259.38 256.85-363.12 25.322-103.75 155.56-695.99 155.56-695.99s-593.28-881.87-622.22-760.83z\" fill=\"#442178\" stroke-width=\"15.42\"/></g></g></g><g id=\"Shape_12_copy_6_1_\" enable-background=\"new    \" fill=\"#2d1650\" stroke-width=\"15.42\"><g fill=\"#2d1650\" stroke-width=\"15.42\"><g fill=\"#2d1650\" stroke-width=\"15.42\"><path d=\"m5071.2 945.81c-31.246-123.8-671.8 778.15-671.8 778.15s140.61 605.72 167.95 711.83c27.34 106.11 42.963 393.5 277.31 371.39s269.5-375.81 289.03-725.09-31.246-1012.5-62.493-1136.3z\" fill=\"#2d1650\" stroke-width=\"15.42\"/></g></g></g><g id=\"Shape_12_copy_7_1_\" enable-background=\"new    \" fill=\"#442178\" stroke-width=\"15.42\"><g fill=\"#442178\" stroke-width=\"15.42\"><g fill=\"#442178\" stroke-width=\"15.42\"><path d=\"m5059.2 970.73c-29.648-121.04-637.45 760.83-637.45 760.83s133.42 592.24 159.36 695.99c25.942 103.75 40.768 384.74 263.13 363.12 222.36-21.615 255.72-367.45 274.25-708.96 18.531-341.51-29.649-989.94-59.297-1111z\" fill=\"#442178\" stroke-width=\"15.42\"/></g></g></g><g id=\"Shape_12_copy_3_1_\" enable-background=\"new    \" fill=\"#2d1650\" stroke-width=\"15.42\"><g fill=\"#2d1650\" stroke-width=\"15.42\"><g fill=\"#2d1650\" stroke-width=\"15.42\"><path d=\"m3049.2 1753.4c-122.76-188.31-176.88-182.53-252.72-305.76-97.796-158.92 14.472-476-199.59-766.22-174.59-236.7-591.61-384.65-941.21-138.62-373.08 262.56-355.83 699.77-175.22 973.89 189.64 287.82 445.08 264.06 582.85 407.41 85.999 89.487 101.86 265.09 203.89 370.36 143.79 148.36 380.24 225.33 639.15 61.496 215.72-136.5 255.61-429.57 142.84-602.55z\" fill=\"#2d1650\" stroke-width=\"15.42\"/></g></g></g><g id=\"Shape_12_copy_1_\" enable-background=\"new    \" fill=\"#442178\" stroke-width=\"15.42\"><g id=\"Shape_12_copy\" fill=\"#442178\" stroke-width=\"15.42\"><g fill=\"#442178\" stroke-width=\"15.42\"><path d=\"m3044 1772c-111.08-187.17-185.56-195.03-260-316-96-156-1.5-502.6-192-760-171.76-232.08-571.05-373.11-920-140-362.3 242.03-364 668-172 956 188.32 282.48 434.64 257.5 568 400 108.42 115.84 111.85 264.14 196 356 154.8 168.97 400.25 242.11 644 68 224-160 208.51-441.82 136-564z\" fill=\"#442178\" stroke-width=\"15.42\"/></g></g></g><g id=\"Shape_12_copy_4_1_\" enable-background=\"new    \" fill=\"#2d1650\" stroke-width=\"15.42\"><g fill=\"#2d1650\" stroke-width=\"15.42\"><g fill=\"#2d1650\" stroke-width=\"15.42\"><path d=\"m4789.3 542.8c-349.6-246.03-766.62-98.079-941.21 138.62-214.06 290.21-101.8 607.3-199.59 766.22-75.836 123.24-129.96 117.45-252.72 305.76-112.77 172.98-72.872 466.05 142.84 602.55 258.9 163.84 495.36 86.859 639.15-61.496 102.03-105.28 117.89-280.87 203.89-370.36 137.77-143.35 393.21-119.59 582.85-407.41 180.61-274.12 197.86-711.33-175.22-973.89z\" fill=\"#2d1650\" stroke-width=\"15.42\"/></g></g></g><g id=\"Shape_12_copy_2_1_\" enable-background=\"new    \" fill=\"#442178\" stroke-width=\"15.42\"><g fill=\"#442178\" stroke-width=\"15.42\"><g fill=\"#442178\" stroke-width=\"15.42\"><path d=\"m4773 556c-348.95-233.11-748.24-92.075-920 140-190.5 257.4-96 604-192 760-74.444 120.97-148.92 128.83-260 316-72.508 122.18-88 404 136 564 243.75 174.11 489.2 100.97 644-68 84.154-91.858 87.58-240.16 196-356 133.36-142.5 379.68-117.52 568-400 192-288 190.3-713.97-172-956z\" fill=\"#442178\" stroke-width=\"15.42\"/></g></g></g><g fill=\"#2d1650\" stroke-width=\"15.42\"><g fill=\"#2d1650\" stroke-width=\"15.42\"><ellipse cx=\"2064\" cy=\"1112\" rx=\"475.27\" ry=\"470.42\" fill=\"#2d1650\" stroke-width=\"15.42\"/></g></g><g id=\"Shape_2_copy\" fill=\"#442178\" stroke-width=\"15.42\"><g fill=\"#442178\" stroke-width=\"15.42\"><ellipse cx=\"2064\" cy=\"1112\" rx=\"463.16\" ry=\"458.44\" fill=\"#442178\" stroke-width=\"15.42\"/></g></g><g stroke-width=\"15.42\"><g stroke-width=\"15.42\"><path d=\"m2277.5 911.54c-16.518-16.517-171.99-88.264-210.78-88.264-38.798 0-189.87 67.706-210.24 88.074-21.36 21.361-87.389 180.22-88.395 211.24-0.982 30.301 63.237 186.73 87.045 210.53 26.177 26.177 171.71 85.496 210.51 86.467 38.797 0.97 184.9-64.136 209.77-86.1 25.23-22.284 89.316-181.15 89.316-211.28-1e-3 -30.067-68.831-192.28-87.223-210.68z\" stroke-width=\"15.42\"/></g></g><g stroke-width=\"15.42\"><g stroke-width=\"15.42\"><path d=\"m2271 917.95c-16.014-16.014-166.74-85.57-204.35-85.57s-184.07 65.64-203.82 85.386c-20.709 20.709-84.722 174.72-85.696 204.8-0.952 29.376 61.307 181.03 84.389 204.11 25.377 25.377 166.47 82.886 204.08 83.827 37.613 0.939 179.26-62.179 203.36-83.472 24.46-21.604 86.591-175.62 86.591-204.83 0-29.15-66.729-186.42-84.561-204.25z\" fill=\"#d1d1d1\" stroke-width=\"207.68\"/></g></g><g stroke-width=\"15.42\" data-button=\"button-10\"><g><g stroke-width=\"15.42\"><ellipse cx=\"2065.6\" cy=\"1124.9\" rx=\"248.44\" ry=\"238.77\" stroke-width=\"15.42\"/></g></g><g id=\"Shape_1_copy\"><g stroke-width=\"15.42\"><ellipse cx=\"2065.6\" cy=\"1124.9\" rx=\"234.29\" ry=\"225.17\" fill=\"#eee\" stroke-width=\"207.68\"/></g></g><g><g stroke-width=\"15.42\"><ellipse cx=\"2064.1\" cy=\"1125.8\" rx=\"211.47\" ry=\"199.69\" fill=\"#acacac\" stroke-width=\"207.68\"/></g></g><g><g stroke-width=\"15.42\"><ellipse cx=\"2064.1\" cy=\"1125.8\" rx=\"199.43\" ry=\"188.32\" fill=\"#eee\" stroke-width=\"207.68\"/></g></g><g><g stroke-width=\"15.42\"><ellipse cx=\"2063.9\" cy=\"1131.1\" rx=\"135.66\" ry=\"128.1\" fill=\"#acacac\" stroke-width=\"207.68\"/></g></g><g><g stroke-width=\"15.42\"><ellipse cx=\"2063.9\" cy=\"1131.1\" rx=\"123.95\" ry=\"117.04\" fill=\"#eee\" stroke-width=\"207.68\"/></g></g><g><g stroke-width=\"15.42\"><ellipse cx=\"2066\" cy=\"1131\" rx=\"53.975\" ry=\"50.966\" fill=\"#acacac\" stroke-width=\"207.68\"/></g></g><g><g stroke-width=\"15.42\"><ellipse cx=\"2066\" cy=\"1131\" rx=\"42.118\" ry=\"39.771\" fill=\"#eee\" stroke-width=\"207.68\"/></g></g></g><g stroke-width=\"15.42\"><g stroke-width=\"15.42\"><path d=\"m4035.5 1760.5c-16.518-16.517-171.99-88.264-210.78-88.264-38.798 0-189.87 67.706-210.24 88.074-21.361 21.361-87.389 180.22-88.395 211.24-0.982 30.301 63.237 186.73 87.045 210.53 26.177 26.177 171.71 85.496 210.51 86.466 38.798 0.971 184.9-64.135 209.77-86.099 25.229-22.284 89.316-181.15 89.316-211.28 0-30.067-68.831-192.28-87.223-210.68z\" stroke-width=\"15.42\"/></g></g><g stroke-width=\"15.42\"><g stroke-width=\"15.42\"><path d=\"m4029 1767c-16.014-16.014-166.74-85.57-204.35-85.57s-184.07 65.64-203.82 85.386c-20.709 20.709-84.722 174.72-85.696 204.8-0.952 29.376 61.307 181.03 84.389 204.11 25.377 25.377 166.47 82.886 204.08 83.827 37.613 0.939 179.26-62.179 203.36-83.472 24.46-21.604 86.591-175.62 86.591-204.83 0-29.15-66.729-186.42-84.561-204.25z\" fill=\"#ffe400\" stroke-width=\"207.68\"/></g></g><g data-button=\"button-11\"><g stroke-width=\"15.42\"><g stroke-width=\"15.42\"><circle cx=\"3824\" cy=\"1976\" r=\"144\" fill=\"#5f5500\" stroke-width=\"207.68\"/></g></g><g id=\"Shape_9_copy\" stroke-width=\"15.42\"><g stroke-width=\"15.42\"><circle cx=\"3824\" cy=\"1976\" r=\"128\" fill=\"#ffe400\" stroke-width=\"207.68\"/></g></g><text transform=\"matrix(.68482 0 0 .68587 195.81 1137.2)\" fill=\"#000000\" fill-opacity=\".75\" font-family=\"sans-serif\" font-size=\"144px\" letter-spacing=\"0px\" stroke-width=\"22.5\" word-spacing=\"0px\" style=\"line-height:1.25;shape-inside:url(#rect1879-3-6-5-2-7);white-space:pre\" xml:space=\"preserve\"><tspan x=\"5247.6191\" y=\"1275.3691\"><tspan stroke-width=\"22.5\">C</tspan></tspan></text></g><text x=\"3826.5161\" y=\"1970.2391\" fill=\"#000000\" font-family=\"sans-serif\" font-size=\"40px\" letter-spacing=\"0px\" stroke-width=\"15.42\" word-spacing=\"0px\" style=\"line-height:1.25\" xml:space=\"preserve\"><tspan x=\"3826.5161\" y=\"1970.2391\" stroke-width=\"15.42\"/></text><g fill=\"#2d1650\" stroke-width=\"15.42\"><g fill=\"#2d1650\" stroke-width=\"15.42\"><ellipse cx=\"2626.5\" cy=\"1976.9\" rx=\"320.41\" ry=\"317.14\" fill=\"#2d1650\" stroke-width=\"15.42\"/></g></g><g fill=\"#442178\" stroke-width=\"15.42\"><g fill=\"#442178\" stroke-width=\"15.42\"><ellipse cx=\"2626.5\" cy=\"1976.9\" rx=\"312.25\" ry=\"309.06\" fill=\"#442178\" stroke-width=\"15.42\"/></g></g><g stroke-width=\"15.42\"><g stroke-width=\"15.42\"><polygon points=\"2870.6 1901.9 2709.5 1901.9 2709.5 1737.1 2545.8 1737.1 2545.9 1899.5 2387.3 1899.5 2387.3 2055.9 2544.8 2057.1 2544.8 2221.9 2707.3 2221.9 2708.5 2054.7 2870.6 2053.5\" stroke-width=\"15.42\"/></g></g><g stroke-width=\"15.42\" data-button=\"dpad-0\"><g id=\"Shape_4_copy\"><g stroke-width=\"15.42\"><polygon points=\"2860.2 1911 2700.8 1911 2700.8 1747.6 2554.2 1747.6 2554.4 1908.7 2396.1 1908.7 2396.1 2047.5 2554.1 2048.7 2554.3 2211.4 2698.2 2211.4 2699.6 2046.4 2860.2 2045.3\" fill=\"#eaeaea\" stroke-width=\"207.68\"/></g></g><g><g stroke-width=\"15.42\"><polygon points=\"2674.2 1862 2627.3 1780.1 2578.7 1862\" fill=\"#c7c7c7\" stroke-width=\"207.68\"/></g></g><g id=\"Shape_5_copy\"><g stroke-width=\"15.42\"><polygon points=\"2674.2 2103 2578.7 2103 2627.3 2184.9\" fill=\"#c7c7c7\" stroke-width=\"207.68\"/></g></g><g><g stroke-width=\"15.42\"><polygon points=\"2506 1934.7 2424 1981.7 2506 2030.3\" fill=\"#c7c7c7\" stroke-width=\"207.68\"/></g></g><g><g stroke-width=\"15.42\"><polygon points=\"2828.9 1981.7 2747 1934.7 2747 2030.3\" fill=\"#c7c7c7\" stroke-width=\"207.68\"/></g></g><g><g stroke-width=\"15.42\"><circle cx=\"2626.9\" cy=\"1979.4\" r=\"48.647\" fill=\"#c7c7c7\" stroke-width=\"207.68\"/></g></g></g><g id=\"Shape_6_copy_1_\" enable-background=\"new    \" stroke-width=\"15.42\"><g id=\"Shape_6_copy\" stroke-width=\"15.42\"></g></g><g id=\"START_x2F_PAUSE\" transform=\"matrix(1.4379 0 0 1.1683 -1075.9 -163.29)\" enable-background=\"new    \" stroke-width=\"11.898\"><text transform=\"matrix(.7382 0 0 1 3021.6 1148)\" font-family=\"KhmerUI-Bold\" font-size=\"86.409px\" stroke-width=\"160.24\">START</text></g><g fill=\"#2d1650\" stroke-width=\"15.42\"><g fill=\"#2d1650\" stroke-width=\"15.42\"><ellipse cx=\"4403.4\" cy=\"1112\" rx=\"475.27\" ry=\"470.42\" fill=\"#2d1650\" stroke-width=\"15.42\"/></g></g><g fill=\"#442178\" stroke-width=\"15.42\"><g fill=\"#442178\" stroke-width=\"15.42\"><ellipse cx=\"4403.4\" cy=\"1112\" rx=\"463.16\" ry=\"458.44\" fill=\"#442178\" stroke-width=\"15.42\"/></g></g><g stroke-width=\"15.42\" data-button=\"button-0\"><g id=\"Shape_7_copy\"><g stroke-width=\"15.42\"><circle cx=\"4408\" cy=\"1104\" r=\"240\" stroke-width=\"15.42\"/></g></g><g><g stroke-width=\"15.42\"><circle cx=\"4408\" cy=\"1104\" r=\"224\" fill=\"#00bc8e\" stroke-width=\"207.68\"/></g></g></g><g stroke-width=\"15.42\" data-button=\"button-2\"><g><g stroke-width=\"15.42\"><circle cx=\"3968\" cy=\"1336\" r=\"148\" stroke-width=\"15.42\"/></g></g><g id=\"Shape_8_copy\"><g stroke-width=\"15.42\"><circle cx=\"3968\" cy=\"1336\" r=\"130\" fill=\"#f00\" stroke-width=\"207.68\"/></g></g></g><g stroke-width=\"15.42\" data-button=\"button-3\"><g><g stroke-width=\"15.42\"><path d=\"m4206 614c-40 18-216 108-140 216 94 100 146-2 226-40 104-40 210 18 210-118-8-128-256-76-296-58z\" stroke-width=\"15.42\"/></g></g><g id=\"Shape_10_copy\"><g stroke-width=\"15.42\"><path d=\"m4487.3 672.68c-8.889-112.4-236.65-62.308-273.91-45.485s-207.07 96.898-134.67 194.16c83.202 86.025 136.64-11.178 211.14-46.641 96.962-37.559 200.88 15.784 197.44-102.04z\" fill=\"#eaeaea\" stroke-width=\"207.68\"/></g></g></g><g stroke-width=\"15.42\" data-button=\"button-1\"><g><g stroke-width=\"15.42\"><path d=\"m4910.5 905.72c-18-40-108-216-216-140-100 94 2 146 40 226 40 104-18 210 118 210 128-8 76-256 58-296z\" stroke-width=\"15.42\"/></g></g><g><g stroke-width=\"15.42\"><path d=\"m4897.3 913.11c-16.822-37.264-96.897-207.07-194.16-134.67-86.025 83.202 11.178 136.64 46.641 211.14 37.56 96.962-15.783 200.88 102.04 197.44 112.4-8.888 62.308-236.64 45.485-273.91z\" fill=\"#eaeaea\" stroke-width=\"207.68\"/></g></g></g><text transform=\"translate(-888.84 -118.88)\" fill=\"#000000\" fill-opacity=\".75\" font-family=\"sans-serif\" font-size=\"144px\" letter-spacing=\"0px\" stroke-width=\"15.42\" word-spacing=\"0px\" style=\"line-height:1.25;shape-inside:url(#rect1879-3);white-space:pre\" xml:space=\"preserve\"><tspan x=\"5247.6191\" y=\"1275.3691\"><tspan fill=\"#000000\" fill-opacity=\".75\" stroke-width=\"15.42\" style=\"shape-inside:url(#rect1879-3)\">A</tspan></tspan></text><text transform=\"translate(-1331 113.12)\" fill=\"#000000\" fill-opacity=\".75\" font-family=\"sans-serif\" font-size=\"144px\" letter-spacing=\"0px\" stroke-width=\"15.42\" word-spacing=\"0px\" style=\"line-height:1.25;shape-inside:url(#rect1879-3-6);white-space:pre\" xml:space=\"preserve\"><tspan x=\"5247.6191\" y=\"1275.3691\"><tspan stroke-width=\"15.42\">B</tspan></tspan></text><text transform=\"matrix(.88915 0 0 .88915 -425.56 -389.36)\" fill=\"#000000\" fill-opacity=\".75\" font-family=\"sans-serif\" font-size=\"144px\" letter-spacing=\"0px\" stroke-width=\"17.343\" word-spacing=\"0px\" style=\"line-height:1.25;shape-inside:url(#rect1879-3-6-5);white-space:pre\" xml:space=\"preserve\"><tspan x=\"5247.6191\" y=\"1275.3691\"><tspan stroke-width=\"17.343\">Y</tspan></tspan></text><text transform=\"translate(-479.38 -261.09)\" fill=\"#000000\" fill-opacity=\".75\" font-family=\"sans-serif\" font-size=\"144px\" letter-spacing=\"0px\" stroke-width=\"15.42\" word-spacing=\"0px\" style=\"line-height:1.25;shape-inside:url(#rect1879-3-6-5-5);white-space:pre\" xml:space=\"preserve\"><tspan x=\"5247.6191\" y=\"1275.3691\"><tspan stroke-width=\"15.42\">X</tspan></tspan></text><text transform=\"matrix(.68482 0 0 .68587 -1678.4 -545.07)\" fill=\"#000000\" fill-opacity=\".75\" font-family=\"sans-serif\" font-size=\"144px\" letter-spacing=\"0px\" stroke-width=\"22.5\" word-spacing=\"0px\" style=\"line-height:1.25;shape-inside:url(#rect1879-3-6-5-2-1);white-space:pre\" xml:space=\"preserve\"><tspan x=\"5247.6191\" y=\"1275.3691\"><tspan stroke-width=\"22.5\">L</tspan></tspan></text><text transform=\"matrix(.49661 0 0 .49737 2207.6 -73.254)\" fill=\"#000000\" fill-opacity=\".75\" font-family=\"sans-serif\" font-size=\"144px\" letter-spacing=\"0px\" stroke-width=\"31.027\" word-spacing=\"0px\" style=\"line-height:1.25;shape-inside:url(#rect1879-3-6-5-2-3);white-space:pre\" xml:space=\"preserve\"><tspan x=\"5247.6191\" y=\"1275.3691\"><tspan stroke-width=\"31.027\">ZR</tspan></tspan></text><g stroke-width=\"15.42\" data-button=\"button-16\"><g transform=\"translate(-1196 -395.27)\"><g stroke-width=\"15.42\"><circle cx=\"4408\" cy=\"1104\" r=\"240\" stroke-width=\"15.42\"/></g></g><g><g transform=\"translate(-1196 -395.27)\" stroke-width=\"15.42\"><circle cx=\"4408\" cy=\"1104\" r=\"224\" fill=\"#ebebeb\" stroke-width=\"207.68\"/></g></g></g><path d=\"m3170.6 561.51c-21.814 12.496-54.583 31.25-72.82 41.674l-33.157 18.954-0.026 170.4 72.068 42.783c39.638 23.53 73.022 43.032 74.185 43.336 1.3821 0.36118 17.016-8.291 45.019-24.916 23.596-14.009 56.552-33.525 73.235-43.371l30.335-17.901v-85.002c0-79.864-0.1179-84.957-1.9466-84.255-1.0711 0.41057-18.804 11.009-39.407 23.553-20.603 12.543-37.97 22.797-38.594 22.787-0.6235-0.0103-16.148-9.5256-34.499-21.145l-33.366-21.125-5.2696 3.0995c-2.8975 1.7042-17.847 10.754-33.219 20.109l-27.95 17.01 0.016 41.958 0.017 41.959 32.606 18.428c17.933 10.135 33.345 18.407 34.249 18.382 0.9044-0.025 16.698-8.3971 35.096-18.605l33.454-18.56 0.317-14.198 0.3162-14.199 14.426-8.7472c7.9335-4.8111 14.808-8.961 15.276-9.2219 0.4673-0.26094 0.8397 13.971 0.827 31.628l-0.023 32.102-50.01 29.247-50.01 29.246-26.228-15.523c-14.425-8.5379-37.327-22.118-50.893-30.176l-24.665-14.654v-116.2l50.068-28.856c27.537-15.871 50.482-29.02 50.988-29.22 0.5064-0.19976 15.973 8.6028 34.372 19.562 18.398 10.959 33.999 19.925 34.668 19.925 1.8597 0 46.5-27.347 46.5-28.486 0-0.54913-0.5337-0.99804-1.186-0.99804s-26.117-14.289-56.588-31.752c-30.471-17.464-56.103-31.752-56.96-31.752-0.8573 0-19.406 10.224-41.22 22.721\" fill-opacity=\".75\" fill-rule=\"evenodd\" stroke-width=\"237.78\"/><g transform=\"translate(9.424)\" data-button=\"button-8\"><g transform=\"matrix(.58703 0 0 .58703 695.18 537.14)\" stroke-width=\"26.268\"><g stroke-width=\"26.268\"><circle cx=\"3968\" cy=\"1336\" r=\"148\" stroke-width=\"26.268\"/></g></g><g transform=\"translate(-943.5 -14.586)\" stroke-width=\"15.42\"><g stroke-width=\"15.42\"><circle cx=\"3968\" cy=\"1336\" r=\"76.314\" fill=\"#ebebeb\" stroke-width=\"207.68\"/></g></g></g><g transform=\"matrix(1.4379 0 0 1.1683 -1486.6 -163.29)\" enable-background=\"new    \" stroke-width=\"11.898\"><text transform=\"matrix(.7382 0 0 1 3021.6 1148)\" font-family=\"KhmerUI-Bold\" font-size=\"86.409px\" stroke-width=\"160.24\">SELECT</text></g><g data-button=\"button-9\"><g transform=\"matrix(.58703 0 0 .58703 1084.2 537.14)\" stroke-width=\"26.268\"><g stroke-width=\"26.268\"><circle cx=\"3968\" cy=\"1336\" r=\"148\" stroke-width=\"26.268\"/></g></g><g transform=\"translate(-554.5 -14.586)\" stroke-width=\"15.42\"><g stroke-width=\"15.42\"><circle cx=\"3968\" cy=\"1336\" r=\"76.314\" fill=\"#ebebeb\" stroke-width=\"207.68\"/></g></g></g></g></g></g><g transform=\"translate(-260.34 -473.69)\"><g cv-if = \"ra\"><path d=\"m567.54 648.99h103.15\" fill=\"none\" stroke=\"#000\" stroke-width=\".5\"/></g><g cv-if = \"dpad\"><path d=\"m374.56 649.32h103.15\" fill=\"none\" stroke=\"#000\" stroke-width=\".5\"/></g><g cv-if = \"a\"><path d=\"m596.71 592.91h91.882\" fill=\"none\" stroke=\"#000\" stroke-width=\".5\"/></g><g cv-if = \"b\"><path d=\"m568.05 607.66h103.15\" fill=\"none\" stroke=\"#000\" stroke-width=\".5\"/></g><g><g cv-if = \"y\"><path d=\"m589.13 565.7h99.459\" fill=\"none\" stroke=\"#000\" stroke-width=\".5\"/></g><g cv-if = \"x\"><path d=\"m622.99 583.02h65.606\" fill=\"none\" stroke=\"#000\" stroke-width=\".5\"/></g><g cv-if = \"r1\"><path d=\"m628.97 554.91h59.627\" fill=\"none\" stroke=\"#000\" stroke-width=\".5\"/></g><g cv-if = \"start\"><path d=\"m528.6 591.28v-82.736\" fill=\"none\" stroke=\"#000\" stroke-width=\".5\"/></g><text x=\"519.64154\" y=\"506.8317\" fill=\"#000000\" font-family=\"sans-serif\" font-size=\"40px\" letter-spacing=\"0px\" word-spacing=\"0px\" style=\"line-height:1.25\" xml:space=\"preserve\"><tspan x=\"519.64154\" y=\"506.8317\" font-family=\"sans-serif\" font-size=\"6px\" style=\"font-variant-caps:normal;font-variant-east-asian:normal;font-variant-ligatures:normal;font-variant-numeric:normal\">[[start]]</tspan></text><text x=\"674.04346\" y=\"651.5755\" fill=\"#000000\" font-family=\"sans-serif\" font-size=\"40px\" letter-spacing=\"0px\" word-spacing=\"0px\" style=\"line-height:1.25\" xml:space=\"preserve\"><tspan x=\"674.04346\" y=\"651.5755\" font-family=\"sans-serif\" font-size=\"6px\" style=\"font-variant-caps:normal;font-variant-east-asian:normal;font-variant-ligatures:normal;font-variant-numeric:normal\">[[ra]]</tspan></text><text x=\"673.08386\" y=\"609.31451\" fill=\"#000000\" font-family=\"sans-serif\" font-size=\"40px\" letter-spacing=\"0px\" word-spacing=\"0px\" style=\"line-height:1.25\" xml:space=\"preserve\"><tspan x=\"673.08386\" y=\"609.31451\" font-family=\"sans-serif\" font-size=\"6px\" style=\"font-variant-caps:normal;font-variant-east-asian:normal;font-variant-ligatures:normal;font-variant-numeric:normal\">[[b]]</tspan></text><text x=\"691.40167\" y=\"594.74054\" fill=\"#000000\" font-family=\"sans-serif\" font-size=\"40px\" letter-spacing=\"0px\" word-spacing=\"0px\" style=\"line-height:1.25\" xml:space=\"preserve\"><tspan x=\"691.40167\" y=\"594.74054\" font-family=\"sans-serif\" font-size=\"6px\" style=\"font-variant-caps:normal;font-variant-east-asian:normal;font-variant-ligatures:normal;font-variant-numeric:normal\">[[a]]</tspan></text><text x=\"690.66138\" y=\"584.66785\" fill=\"#000000\" font-family=\"sans-serif\" font-size=\"40px\" letter-spacing=\"0px\" word-spacing=\"0px\" style=\"line-height:1.25\" xml:space=\"preserve\"><tspan x=\"690.66138\" y=\"584.66785\" font-family=\"sans-serif\" font-size=\"6px\" style=\"font-variant-caps:normal;font-variant-east-asian:normal;font-variant-ligatures:normal;font-variant-numeric:normal\">[[x]]</tspan></text><text x=\"691.40601\" y=\"567.63531\" fill=\"#000000\" font-family=\"sans-serif\" font-size=\"40px\" letter-spacing=\"0px\" word-spacing=\"0px\" style=\"line-height:1.25\" xml:space=\"preserve\"><tspan x=\"691.40601\" y=\"567.63531\" font-family=\"sans-serif\" font-size=\"6px\" style=\"font-variant-caps:normal;font-variant-east-asian:normal;font-variant-ligatures:normal;font-variant-numeric:normal\">[[y]]</tspan></text><text x=\"690.68622\" y=\"557.03937\" fill=\"#000000\" font-family=\"sans-serif\" font-size=\"40px\" letter-spacing=\"0px\" word-spacing=\"0px\" style=\"line-height:1.25\" xml:space=\"preserve\"><tspan x=\"690.68622\" y=\"557.03937\" font-family=\"sans-serif\" font-size=\"6px\" style=\"font-variant-caps:normal;font-variant-east-asian:normal;font-variant-ligatures:normal;font-variant-numeric:normal\">[[r1]]</tspan></text><g cv-if = \"l1\"><path d=\"m342.83 555.19h59.627\" fill=\"none\" stroke=\"#000\" stroke-width=\".5\"/></g><text x=\"315.89267\" y=\"557.19037\" fill=\"#000000\" font-family=\"sans-serif\" font-size=\"40px\" letter-spacing=\"0px\" word-spacing=\"0px\" style=\"line-height:1.25\" xml:space=\"preserve\"><tspan x=\"315.89267\" y=\"557.19037\" font-family=\"sans-serif\" font-size=\"6px\" style=\"font-variant-caps:normal;font-variant-east-asian:normal;font-variant-ligatures:normal;font-variant-numeric:normal\">[[l1]]</tspan></text><text x=\"354.72061\" y=\"651.14825\" fill=\"#000000\" font-family=\"sans-serif\" font-size=\"40px\" letter-spacing=\"0px\" word-spacing=\"0px\" style=\"line-height:1.25\" xml:space=\"preserve\"><tspan x=\"354.72061\" y=\"651.14825\" font-family=\"sans-serif\" font-size=\"6px\" style=\"font-variant-caps:normal;font-variant-east-asian:normal;font-variant-ligatures:normal;font-variant-numeric:normal\">[[dpad]]</tspan></text></g></svg>\n"
});

;require.register("controller/kb-input.html", function(exports, require, module) {
module.exports = "<section cv-each = \"lines:line\">[[line]]</section>\n"
});

;require.register("controller/ps3-input.svg", function(exports, require, module) {
module.exports = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<svg width=\"512\" height=\"288\" version=\"1.0\"\n\txmlns=\"http://www.w3.org/2000/svg\">\n\t<g transform=\"translate(-260.34 -473.69)\">\n\t\t<g transform=\"translate(134.82 68.294)\">\n\t\t\t<path d=\"m435.57 481.84h33.046l-2.5898-4.9919c-1.698-3.2729-6.1119-5.7018-13.933-5.7018-7.8212 0-12.235 2.4289-13.933 5.7018z\" fill=\"#7a7a7a\" fill-rule=\"evenodd\" stroke=\"#000\" stroke-width=\"1.0793\" data-button=\"button-7\"/>\n\t\t\t<path d=\"m293.22 481.84h33.046l-2.5898-4.9919c-1.698-3.2729-6.1119-5.7018-13.933-5.7018-7.8212 0-12.235 2.4289-13.933 5.7018z\" fill=\"#7a7a7a\" fill-rule=\"evenodd\" stroke=\"#000\" stroke-width=\"1.0793\" data-button=\"button-6\"/>\n\t\t\t<path d=\"m320.62 497.85c-1.5358 0-2.75 1.2454-2.75 2.7812v73.156c0 1.5358 1.2142 2.75 2.75 2.75h121.78c1.5358 0 2.7812-1.2142 2.7812-2.75v-73.156c0-1.5358-1.2454-2.7812-2.7812-2.7812h-52.808c-0.2723 0.44907-0.77809 0.75-1.3438 0.75h-14.312c-0.56415 0-1.0398-0.30294-1.3125-0.75z\" fill=\"#3f3f3f\" fill-rule=\"evenodd\" stroke=\"#000\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/>\n\t\t\t<rect x=\"324.17\" y=\"504.14\" width=\"114.69\" height=\"68.484\" rx=\"2.7723\" ry=\"2.6797\" fill=\"#262626\" fill-rule=\"evenodd\"/>\n\t\t\t<path d=\"m272.94 520.34c-5.4902 30.065-9.0709 62.226-11.765 76.34-4.2253 22.138 32.77 40.747 46.797 15.163 10.649-19.422 22.745-44.183 22.745-44.183z\" fill=\"#262626\" fill-rule=\"evenodd\" stroke=\"#000\"/>\n\t\t\t<path d=\"m435.52 483.74h33.15l-2.598-4.2714c-1.7033-2.8005-6.1312-4.8789-13.977-4.8789-7.8459 0-12.274 2.0784-13.977 4.8789z\" fill=\"#7a7a7a\" fill-rule=\"evenodd\" stroke=\"#000\" data-button=\"button-5\"/>\n\t\t\t<path d=\"m293.16 483.74h33.15l-2.598-4.2714c-1.7033-2.8005-6.1312-4.8789-13.977-4.8789-7.8459 0-12.274 2.0784-13.977 4.8789z\" fill=\"#7a7a7a\" fill-rule=\"evenodd\" stroke=\"#000\" data-button=\"button-4\"/>\n\t\t\t<path d=\"m330.59 504.54c-1.6994-10.98-2.4837-16.471-3.268-20.523-0.78432-4.0523-7.7124-6.1438-17.582-6.1438s-16.797 2.0915-17.582 6.1438c-0.78431 4.0523-1.5686 9.5425-3.268 20.523\" fill=\"#262626\" fill-rule=\"evenodd\" stroke=\"#000\"/>\n\t\t\t<circle cx=\"309.8\" cy=\"529.75\" r=\"37.909\" fill=\"#333\" fill-rule=\"evenodd\" stroke=\"#000\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/>\n\t\t\t<path d=\"m472.94 504.54c-1.6994-10.98-2.4837-16.471-3.268-20.523-0.78432-4.0523-7.7124-6.1438-17.582-6.1438s-16.797 2.0915-17.582 6.1438c-0.78431 4.0523-1.5686 9.5425-3.268 20.523\" fill=\"#262626\" fill-rule=\"evenodd\" stroke=\"#000\"/>\n\t\t\t<circle cx=\"346.14\" cy=\"566.61\" r=\"24.052\" fill=\"#333\" fill-rule=\"evenodd\" stroke=\"#000\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/>\n\t\t\t<circle cx=\"346.14\" cy=\"566.61\" r=\"18.562\" fill-opacity=\".51852\" fill-rule=\"evenodd\" stroke=\"#000\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/>\n\t\t\t<circle cx=\"346.14\" cy=\"566.61\" r=\"16.209\" fill=\"#3b3b3b\" fill-rule=\"evenodd\" stroke=\"#000\" stroke-linecap=\"round\" stroke-linejoin=\"round\" data-button=\"left-stick button-10\"/>\n\t\t\t<path d=\"m490.08 520.34c5.4902 30.065 9.0709 62.749 11.765 76.34 4.3818 22.107-32.77 40.747-46.797 15.163-10.649-19.422-22.745-44.183-22.745-44.183z\" fill=\"#262626\" fill-rule=\"evenodd\" stroke=\"#000\"/>\n\t\t\t<circle transform=\"scale(-1,1)\" cx=\"-453.21\" cy=\"529.75\" r=\"37.909\" fill=\"#333\" fill-rule=\"evenodd\" stroke=\"#000\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/>\n\t\t\t<path d=\"m445.43 501.73c-1.5358 0-2.7812 1.2454-2.7812 2.7812v14.656h-14.688c-1.5358 0-2.75 1.2454-2.75 2.7812v15.594c0 1.5358 1.2142 2.7812 2.75 2.7812h14.688v14.656c0 1.5358 1.2454 2.7812 2.7812 2.7812h15.594c1.5358 0 2.75-1.2454 2.75-2.7812v-14.656h14.688c1.5358 0 2.75-1.2454 2.75-2.7812v-15.594c0-1.5358-1.2142-2.7812-2.75-2.7812h-14.688v-14.656c0-1.5358-1.2142-2.7812-2.75-2.7812z\" fill=\"#262626\" fill-rule=\"evenodd\"/>\n\t\t\t<rect x=\"353.46\" y=\"530.28\" width=\"11.634\" height=\"6.6667\" rx=\"1.5686\" ry=\"1.5686\" fill=\"#595959\" fill-rule=\"evenodd\" stroke=\"#000\" stroke-linecap=\"round\" stroke-linejoin=\"round\" data-button=\"button-8\"/>\n\t\t\t<path d=\"m407.19 533.61-8.4967 3.3333c-0.80899 0.31737-1.5686-0.69961-1.5686-1.5686v-3.5294c0-0.86902 0.75963-1.886 1.5686-1.5686z\" fill=\"#595959\" fill-rule=\"evenodd\" stroke=\"#000\" stroke-linecap=\"round\" stroke-linejoin=\"round\" data-button=\"button-9\"/>\n\t\t\t<circle cx=\"382.48\" cy=\"551.32\" r=\"7.9347\" fill=\"#595959\" fill-rule=\"evenodd\" stroke=\"#000\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"1.3796\" data-button=\"button-16\"/>\n\t\t\t<circle cx=\"453.21\" cy=\"512.1\" r=\"8.2353\" fill=\"#5a5a5a\" fill-rule=\"evenodd\" stroke=\"#454545\" stroke-linecap=\"round\" stroke-linejoin=\"round\" data-button=\"button-3\"/>\n\t\t\t<circle cx=\"453.21\" cy=\"547.53\" r=\"8.2353\" fill=\"#5a5a5a\" fill-rule=\"evenodd\" stroke=\"#454545\" stroke-linecap=\"round\" stroke-linejoin=\"round\" data-button=\"button-0\"/>\n\t\t\t<circle cx=\"470.93\" cy=\"529.81\" r=\"8.2353\" fill=\"#5a5a5a\" fill-rule=\"evenodd\" stroke=\"#454545\" stroke-linecap=\"round\" stroke-linejoin=\"round\" data-button=\"button-1\"/>\n\t\t\t<circle cx=\"435.5\" cy=\"529.81\" r=\"8.2353\" fill=\"#5a5a5a\" fill-rule=\"evenodd\" stroke=\"#454545\" stroke-linecap=\"round\" stroke-linejoin=\"round\" data-button=\"button-2\"/>\n\t\t\t<path d=\"m301.84 501.25c-1.5358 0-2.7812 1.2454-2.7812 2.7812v14.656h-14.688c-1.5358 0-2.75 1.2454-2.75 2.7812v15.594c0 1.5358 1.2142 2.7812 2.75 2.7812h14.688v14.656c0 1.5358 1.2454 2.7812 2.7812 2.7812h15.594c1.5358 0 2.75-1.2454 2.75-2.7812v-14.656h14.688c1.5358 0 2.75-1.2454 2.75-2.7812v-15.594c0-1.5358-1.2142-2.7812-2.75-2.7812h-14.688v-14.656c0-1.5358-1.2142-2.7812-2.75-2.7812z\" fill=\"#262626\" fill-rule=\"evenodd\"/>\n\t\t\t<circle cx=\"416.21\" cy=\"566.61\" r=\"24.052\" fill=\"#333\" fill-rule=\"evenodd\" stroke=\"#000\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/>\n\t\t\t<circle cx=\"416.21\" cy=\"566.61\" r=\"18.562\" fill-opacity=\".51852\" fill-rule=\"evenodd\" stroke=\"#000\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/>\n\t\t\t<circle cx=\"416.21\" cy=\"566.61\" r=\"16.209\" fill=\"#3b3b3b\" fill-rule=\"evenodd\" stroke=\"#000\" stroke-linecap=\"round\" stroke-linejoin=\"round\" data-button=\"right-stick button-11\"/>\n\t\t\t<g fill=\"#3f3f3f\" fill-rule=\"evenodd\">\n\t\t\t\t<path transform=\"matrix(0 -.28374 -.51741 0 575.79 583.64)\" d=\"m279.97 514.41-12.665 7.3123v-14.625z\"/>\n\t\t\t\t<path transform=\"matrix(0 .28374 -.51741 0 575.79 474.89)\" d=\"m279.97 514.41-12.665 7.3123v-14.625z\"/>\n\t\t\t\t<path transform=\"matrix(.28374 0 0 -.51741 255.25 795.43)\" d=\"m279.97 514.41-12.665 7.3123v-14.625z\"/>\n\t\t\t\t<path transform=\"matrix(-.28374 0 0 -.51741 364 795.43)\" d=\"m279.97 514.41-12.665 7.3123v-14.625z\"/>\n\t\t\t</g>\n\t\t\t<rect x=\"430.79\" y=\"525.1\" width=\"9.4281\" height=\"9.4281\" rx=\"0\" ry=\"0\" fill=\"none\" stroke=\"#ff01db\"/>\n\t\t\t<path transform=\"matrix(.87668 0 0 .87521 59.31 61.955)\" d=\"m455.3 518.14h-11.974l5.9871-10.37z\" fill=\"none\" stroke=\"#00ff83\" stroke-width=\"1.1416\"/>\n\t\t\t<circle transform=\"scale(-1)\" cx=\"-470.93\" cy=\"-529.81\" r=\"5.6472\" fill=\"none\" stroke=\"#f00\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/>\n\t\t\t<path d=\"m449.04 543.43 8.5038 8.5038m0-8.5038-8.5038 8.5038\" fill=\"none\" stroke=\"#8243fb\"/>\n\t\t\t<g fill=\"#5a5a5a\" stroke=\"#454545\">\n\t\t\t\t<path transform=\"translate(.35102 .37335)\" d=\"m318.62 523.29a1.1789 1.1789 0 0 0-0.85742 0.44726l-3.5 4.4375a1.1789 1.1789 0 0 0-2e-3 1.457l3.5 4.4688a1.1789 1.1789 0 0 0 0.92382 0.45313l8.125 0.0312a1.1789 1.1789 0 0 0 1.1836-1.1797v-8.7812a1.1789 1.1789 0 0 0-1.1562-1.1777l-8.125-0.15625a1.1789 1.1789 0 0 0-0.0918 0z\" fill=\"#5a5a5a\" fill-rule=\"evenodd\" stroke=\"#454545\" stroke-linecap=\"round\" stroke-linejoin=\"round\" data-button=\"button-15\"/>\n\t\t\t\t<g data-button=\"button-14\">\n\t\t\t\t\t<path transform=\"matrix(-1 0 0 1 618.9 .2845)\" d=\"m318.62 523.29a1.1789 1.1789 0 0 0-0.85742 0.44726l-3.5 4.4375a1.1789 1.1789 0 0 0-2e-3 1.457l3.5 4.4688a1.1789 1.1789 0 0 0 0.92382 0.45313l8.125 0.0312a1.1789 1.1789 0 0 0 1.1836-1.1797v-8.7812a1.1789 1.1789 0 0 0-1.1562-1.1777l-8.125-0.15625a1.1789 1.1789 0 0 0-0.0918 0z\" fill=\"#5a5a5a\" fill-rule=\"evenodd\" stroke=\"#454545\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/>\n\t\t\t\t</g>\n\t\t\t\t<g data-button=\"button-13\">\n\t\t\t\t\t<path transform=\"rotate(90 309.26 529.25)\" d=\"m318.62 523.29a1.1789 1.1789 0 0 0-0.85742 0.44726l-3.5 4.4375a1.1789 1.1789 0 0 0-2e-3 1.457l3.5 4.4688a1.1789 1.1789 0 0 0 0.92382 0.45313l8.125 0.0312a1.1789 1.1789 0 0 0 1.1836-1.1797v-8.7812a1.1789 1.1789 0 0 0-1.1562-1.1777l-8.125-0.15625a1.1789 1.1789 0 0 0-0.0918 0z\" fill=\"#5a5a5a\" fill-rule=\"evenodd\" stroke=\"#454545\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/>\n\t\t\t\t</g>\n\t\t\t\t<g data-button=\"button-12\">\n\t\t\t\t\t<path transform=\"matrix(0 -1 -1 0 838.61 838.54)\" d=\"m318.62 523.29a1.1789 1.1789 0 0 0-0.85742 0.44726l-3.5 4.4375a1.1789 1.1789 0 0 0-2e-3 1.457l3.5 4.4688a1.1789 1.1789 0 0 0 0.92382 0.45313l8.125 0.0312a1.1789 1.1789 0 0 0 1.1836-1.1797v-8.7812a1.1789 1.1789 0 0 0-1.1562-1.1777l-8.125-0.15625a1.1789 1.1789 0 0 0-0.0918 0z\" fill=\"#5a5a5a\" fill-rule=\"evenodd\" stroke=\"#454545\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/>\n\t\t\t\t</g>\n\t\t\t</g>\n\t\t\t<path d=\"m307.47 481.42h1.038v6.7985h3.7358v0.87358h-4.7738v-7.6721\"/>\n\t\t\t<path d=\"m454.02 485.5c0.22267 0.0754 0.43849 0.23638 0.64747 0.48303 0.2124 0.24666 0.4248 0.58582 0.6372 1.0175l1.0534 2.0966h-1.1151l-0.98149-1.9681c-0.25352-0.51387-0.50017-0.85473-0.73998-1.0226-0.23638-0.16786-0.56012-0.25179-0.97121-0.25179h-1.1305v3.2425h-1.038v-7.6721h2.3432c0.877 1e-5 1.5313 0.18329 1.963 0.54984 0.43164 0.36657 0.64747 0.91983 0.64747 1.6598 0 0.48304-0.11305 0.88386-0.33915 1.2024-0.22268 0.31861-0.54813 0.53957-0.97635 0.6629m-2.6002-3.222v2.7235h1.3052c0.50016 1e-5 0.877-0.11476 1.1305-0.34429 0.25693-0.23295 0.3854-0.57382 0.3854-1.0226 0-0.44877-0.12847-0.78622-0.3854-1.0123-0.25351-0.22953-0.63035-0.34429-1.1305-0.3443h-1.3052\"/>\n\t\t\t<path d=\"m353.63 524.56v0.43917c-0.17091-0.0817-0.33216-0.14267-0.48375-0.1828-0.15159-0.0401-0.29798-0.0602-0.43917-0.0602-0.24522 0-0.43471 0.0476-0.56846 0.14267-0.13227 0.0951-0.19841 0.23036-0.19841 0.40573 0 0.14713 0.0438 0.2586 0.13153 0.33439 0.0892 0.0743 0.25711 0.1345 0.50382 0.18057l0.27197 0.0557c0.33587 0.0639 0.58332 0.17686 0.74234 0.33885 0.16051 0.16051 0.24076 0.37601 0.24077 0.64649-1e-5 0.3225-0.1085 0.56698-0.32548 0.73343-0.2155 0.16646-0.53205 0.24968-0.94967 0.24968-0.15753 0-0.32547-0.0178-0.50381-0.0535-0.17686-0.0357-0.3604-0.0884-0.55063-0.15828v-0.46369c0.1828 0.10255 0.36188 0.17983 0.53725 0.23185 0.17537 0.052 0.34777 0.078 0.51719 0.078 0.25711 0 0.45551-0.0505 0.59522-0.15159 0.1397-0.10106 0.20955-0.24522 0.20955-0.43248 0-0.16348-0.0505-0.29129-0.15159-0.38343-0.0996-0.0921-0.2638-0.16125-0.49267-0.20733l-0.2742-0.0535c-0.33588-0.0669-0.57887-0.17165-0.72897-0.31433-0.15011-0.14267-0.22516-0.34107-0.22516-0.59521 0-0.29426 0.10329-0.52611 0.30987-0.69553 0.20806-0.16943 0.49415-0.25414 0.85827-0.25414 0.15605 0 0.31507 0.0141 0.47706 0.0423 0.162 0.0283 0.3277 0.0706 0.49713 0.12707m0.90286-0.10923h2.1044v0.37898h-1.6541v0.98533h1.585v0.37898h-1.585v1.206h1.6942v0.37897h-2.1446v-3.3283m2.8891 0h0.45032v2.9493h1.6207v0.37897h-2.071v-3.3283m2.5414 0h2.1044v0.37898h-1.6541v0.98533h1.585v0.37898h-1.585v1.206h1.6942v0.37897h-2.1446v-3.3283m5.3815 0.25637v0.47483c-0.15159-0.14118-0.31359-0.2467-0.48598-0.31656-0.17092-0.0698-0.35297-0.10477-0.54617-0.10477-0.38047 0-0.67176 0.11667-0.87388 0.34999-0.20212 0.23185-0.30318 0.56773-0.30318 1.0076 0 0.43843 0.10106 0.77431 0.30318 1.0076 0.20212 0.23184 0.49341 0.34776 0.87388 0.34776 0.1932 0 0.37525-0.0349 0.54617-0.10477 0.17239-0.0698 0.33439-0.17537 0.48598-0.31656v0.47038c-0.15754 0.107-0.32473 0.18726-0.50159 0.24076-0.17537 0.0535-0.36114 0.0802-0.55732 0.0802-0.50381 0-0.90062-0.15382-1.1904-0.46146-0.2898-0.30912-0.43471-0.73045-0.43471-1.264 0-0.53502 0.14491-0.95635 0.43471-1.264 0.28981-0.30913 0.68662-0.46369 1.1904-0.46369 0.19915 0 0.38641 0.0267 0.56178 0.0802 0.17685 0.052 0.34256 0.13079 0.49713 0.23631m0.23853-0.25637h2.8156v0.37898h-1.1815v2.9493h-0.45254v-2.9493h-1.1815v-0.37898\" fill=\"#e6e6e6\"/>\n\t\t\t<path d=\"m396.51 524.56v0.43917c-0.17092-0.0817-0.33217-0.14267-0.48376-0.1828-0.15159-0.0401-0.29798-0.0602-0.43916-0.0602-0.24522 0-0.43471 0.0476-0.56847 0.14267-0.13227 0.0951-0.1984 0.23036-0.1984 0.40573 0 0.14713 0.0438 0.2586 0.13152 0.33439 0.0892 0.0743 0.25711 0.1345 0.50382 0.18057l0.27197 0.0557c0.33588 0.0639 0.58333 0.17686 0.74235 0.33885 0.1605 0.16051 0.24076 0.37601 0.24076 0.64649 0 0.3225-0.10849 0.56698-0.32547 0.73343-0.2155 0.16646-0.53206 0.24968-0.94967 0.24968-0.15754 0-0.32548-0.0178-0.50382-0.0535-0.17686-0.0357-0.3604-0.0884-0.55063-0.15828v-0.46369c0.1828 0.10255 0.36189 0.17983 0.53726 0.23185 0.17536 0.052 0.34776 0.078 0.51719 0.078 0.2571 0 0.45551-0.0505 0.59521-0.15159 0.1397-0.10106 0.20955-0.24522 0.20955-0.43248 0-0.16348-0.0505-0.29129-0.15159-0.38343-0.0996-0.0921-0.2638-0.16125-0.49267-0.20733l-0.2742-0.0535c-0.33587-0.0669-0.57886-0.17165-0.72897-0.31433-0.1501-0.14267-0.22516-0.34107-0.22515-0.59521-1e-5 -0.29426 0.10328-0.52611 0.30986-0.69553 0.20807-0.16943 0.49416-0.25414 0.85827-0.25414 0.15605 0 0.31507 0.0141 0.47707 0.0423 0.16199 0.0283 0.3277 0.0706 0.49713 0.12707m0.44139-0.10923h2.8156v0.37898h-1.1815v2.9493h-0.45254v-2.9493h-1.1815v-0.37898m4.0082 0.44362-0.61082 1.6564h1.2239l-0.61305-1.6564m-0.25413-0.44362h0.5105l1.2685 3.3283h-0.46815l-0.30318-0.85381h-1.5003l-0.30318 0.85381h-0.47484l1.2707-3.3283m3.841 1.7678c0.0966 0.0327 0.19023 0.10255 0.28089 0.20955 0.0921 0.10701 0.18429 0.25414 0.27643 0.4414l0.457 0.90954h-0.48375l-0.42579-0.85381c-0.10998-0.22292-0.21698-0.3708-0.32102-0.44362-0.10254-0.0728-0.24299-0.10924-0.42133-0.10924h-0.49044v1.4067h-0.45031v-3.3283h1.0166c0.38046 0 0.66432 0.0795 0.85158 0.23853s0.28088 0.39904 0.28089 0.72006c-1e-5 0.20955-0.0491 0.38343-0.14713 0.52165-0.0966 0.13821-0.2378 0.23407-0.42357 0.28757m-1.128-1.3978v1.1815h0.56624c0.21698 0 0.38046-0.0498 0.49044-0.14936 0.11146-0.10106 0.16719-0.24893 0.16719-0.44362s-0.0557-0.34108-0.16719-0.43917c-0.10998-0.0996-0.27346-0.14936-0.49044-0.14936h-0.56624m1.9328-0.37006h2.8156v0.37898h-1.1815v2.9493h-0.45254v-2.9493h-1.1815v-0.37898\" fill=\"#e6e6e6\"/>\n\t\t\t<text transform=\"scale(-1.6252 -.6153)\" x=\"-223.68372\" y=\"-815.48474\" fill=\"#b3b3b3\" font-family=\"Arial\" stroke-width=\"1px\" style=\"line-height:0%\" xml:space=\"preserve\">\n\t\t\t\t<tspan x=\"-223.68372\" y=\"-815.48474\" font-size=\"3.0753px\" style=\"line-height:1.25\">1</tspan>\n\t\t\t</text>\n\t\t\t<text transform=\"scale(-1.6252 -.6153)\" x=\"-220.45108\" y=\"-815.48474\" fill=\"#b3b3b3\" font-family=\"Arial\" stroke-width=\"1px\" style=\"line-height:0%\" xml:space=\"preserve\">\n\t\t\t\t<tspan x=\"-220.45108\" y=\"-815.48474\" font-size=\"3.0753px\" style=\"line-height:1.25\">2</tspan>\n\t\t\t</text>\n\t\t\t<text transform=\"scale(-1.6252 -.6153)\" x=\"-216.92226\" y=\"-815.5238\" fill=\"#b3b3b3\" font-family=\"Arial\" stroke-width=\"1px\" style=\"line-height:0%\" xml:space=\"preserve\">\n\t\t\t\t<tspan x=\"-216.92226\" y=\"-815.5238\" font-size=\"3.0753px\" style=\"line-height:1.25\">3</tspan>\n\t\t\t</text>\n\t\t\t<text transform=\"scale(-1.6252 -.6153)\" x=\"-212.86066\" y=\"-815.49377\" fill=\"#b3b3b3\" font-family=\"Arial\" stroke-width=\"1px\" style=\"line-height:0%\" xml:space=\"preserve\">\n\t\t\t\t<tspan x=\"-212.86066\" y=\"-815.49377\" font-size=\"3.0753px\" style=\"line-height:1.25\">4</tspan>\n\t\t\t</text>\n\t\t\t<rect x=\"343.44\" y=\"498.32\" width=\"2.0832\" height=\"2.7005\" rx=\"0\" ry=\"1.5686\" fill=\"#1a1a1a\"/>\n\t\t\t<rect x=\"350\" y=\"498.32\" width=\"2.0832\" height=\"2.7005\" rx=\"0\" ry=\"1.5686\" fill=\"#1a1a1a\"/>\n\t\t\t<rect x=\"355.86\" y=\"498.32\" width=\"2.0832\" height=\"2.7005\" rx=\"0\" ry=\"1.5686\" fill=\"#1a1a1a\"/>\n\t\t\t<rect x=\"360.96\" y=\"498.32\" width=\"2.0832\" height=\"2.7005\" rx=\"0\" ry=\"1.5686\" fill=\"#f00\"/>\n\t\t\t<g transform=\"matrix(.080659 0 0 .080659 351.05 512.47)\" clip-rule=\"evenodd\" fill-rule=\"evenodd\" stroke-width=\"2.256\">\n\t\t\t\t<path d=\"m394.88 444.14-0.0851 78.095-20.924-6.8051v-91.793l26.708 7.0613c17.096 4.5948 27.559 13.526 27.388 29.18-0.17 18.206-8.5908 25.521-25.007 20.757v-35.901c0-4.3389-8.0805-4.593-8.0805-0.59435z\" fill=\"#de0029\"/>\n\t\t\t\t<path d=\"m364.26 500.28-9.867 3.3186c-6.3802 2.2124-11.823-2.9768-5.9543-5.1048l4.763-1.7003-17.947-5.701c-5.5292 1.8724-10.718 5.8707-10.377 11.486 0.34027 5.6992 13.354 7.061 23.392 8.6775 9.3559 1.5306 17.862 0.68001 25.603-2.0424v-5.8705zm30.706 21.95 18.288-6.381-18.458-5.8692v11.824z\" fill=\"#f3c202\"/>\n\t\t\t\t<path d=\"m443.62 505.13 0.34-0.0857c7.9956-2.8065 11.398-6.7213 10.548-10.378-1.3611-6.1248-11.143-9.4434-26.199-10.55-10.802-0.76514-21.434 1.6162-31.811 5.1889l-1.7013 0.5962 18.628 5.7848 10.887-3.6586c11.398-2.1262 15.992 1.6165 5.0189 5.1048l-5.444 1.8705zm-69.748-27.052-8.2516 2.8065 8.2516 2.5524z\" fill=\"#326db3\"/>\n\t\t\t\t<path d=\"m413.25 515.85 30.366-10.718-19.734-6.1267-29.09 9.9534v1.0221zm-39.382-18.801-9.6118 3.2327 9.6118 3.0627zm20.924 5.0207v-12.166l18.628 5.7848zm-41.594-5.2748 20.67-7.4013v-5.9551l-8.2513-2.5524-29.941 10.124c-0.0851 0-0.25513 0.0841-0.42513 0.0841z\" fill=\"#00aa9e\"/>\n\t\t\t</g>\n\t\t</g>\n\t</g>\n\t<g transform=\"translate(-260.34 -473.69)\">\n\t\t<g class = \"a\" class = \"a\" cv-if = \"a\">\n\t\t\t<path transform=\"translate(134.82 68.294)\" d=\"m456.39 552.34 69.71 17.901\" fill=\"none\" stroke=\"#000\" stroke-width=\".5\"/>\n\t\t</g>\n\t\t<g class = \"x\" class = \"x\" cv-if = \"x\">\n\t\t\t<path transform=\"translate(134.82 68.294)\" d=\"m439.07 532.57 87.033 22.593\" fill=\"none\" stroke=\"#000\" stroke-width=\".5\"/>\n\t\t</g>\n\t\t<g class = \"y\" class = \"y\" cv-if = \"y\">\n\t\t\t<path transform=\"translate(134.82 68.294)\" d=\"m457.95 515.41 68.155 16.266\" fill=\"none\" stroke=\"#000\" stroke-width=\".5\"/>\n\t\t</g>\n\t\t<g class = \"b\" class = \"b\" cv-if = \"b\">\n\t\t\t<path transform=\"translate(134.82 68.294)\" d=\"m474.2 532.63 51.904 12.605\" fill=\"none\" stroke=\"#000\" stroke-width=\".5\"/>\n\t\t</g>\n\t\t<text transform=\"translate(134.82 68.294)\" x=\"527.39423\" y=\"547.27045\" fill=\"#000000\" font-family=\"sans-serif\" font-size=\"40px\" letter-spacing=\"0px\" word-spacing=\"0px\" style=\"line-height:1.25\" xml:space=\"preserve\">\n\t\t\t<tspan class = \"b\" x=\"527.39423\" y=\"547.27045\" font-family=\"sans-serif\" font-size=\"6px\" style=\"font-variant-caps:normal;font-variant-east-asian:normal;font-variant-ligatures:normal;font-variant-numeric:normal\">[[b]]</tspan>\n\t\t</text>\n\t\t<text transform=\"translate(134.82 68.294)\" x=\"527.69214\" y=\"572.71301\" fill=\"#000000\" font-family=\"sans-serif\" font-size=\"40px\" letter-spacing=\"0px\" word-spacing=\"0px\" style=\"line-height:1.25\" xml:space=\"preserve\">\n\t\t\t<tspan class = \"a\" x=\"527.69214\" y=\"572.71301\" font-family=\"sans-serif\" font-size=\"6px\" style=\"font-variant-caps:normal;font-variant-east-asian:normal;font-variant-ligatures:normal;font-variant-numeric:normal\">[[a]]</tspan>\n\t\t</text>\n\t\t<text transform=\"translate(134.82 68.294)\" x=\"527.45691\" y=\"557.97314\" fill=\"#000000\" font-family=\"sans-serif\" font-size=\"40px\" letter-spacing=\"0px\" word-spacing=\"0px\" style=\"line-height:1.25\" xml:space=\"preserve\">\n\t\t\t<tspan class = \"x\" x=\"527.45691\" y=\"557.97314\" font-family=\"sans-serif\" font-size=\"6px\" style=\"font-variant-caps:normal;font-variant-east-asian:normal;font-variant-ligatures:normal;font-variant-numeric:normal\">[[x]]</tspan>\n\t\t</text>\n\t\t<text transform=\"translate(134.82 68.294)\" x=\"526.81152\" y=\"534.13593\" fill=\"#000000\" font-family=\"sans-serif\" font-size=\"40px\" letter-spacing=\"0px\" word-spacing=\"0px\" style=\"line-height:1.25\" xml:space=\"preserve\">\n\t\t\t<tspan class = \"y\" x=\"526.81152\" y=\"534.13593\" font-family=\"sans-serif\" font-size=\"6px\" style=\"font-variant-caps:normal;font-variant-east-asian:normal;font-variant-ligatures:normal;font-variant-numeric:normal\">[[y]]</tspan>\n\t\t</text>\n\t\t<g cv-if =\"r1\" class = \"r1\">\n\t\t\t<path transform=\"translate(134.82 68.294)\" d=\"m470.33 481.76 53.163 13.403\" fill=\"none\" stroke=\"#000\" stroke-width=\".5\"/>\n\t\t\t<text transform=\"translate(134.82 68.294)\" x=\"524.19629\" y=\"497.62772\" fill=\"#000000\" font-family=\"sans-serif\" font-size=\"40px\" letter-spacing=\"0px\" word-spacing=\"0px\" style=\"line-height:1.25\" xml:space=\"preserve\">\n\t\t\t\t<tspan class = \"r1\" x=\"524.19629\" y=\"497.62772\" font-family=\"sans-serif\" font-size=\"6px\" style=\"font-variant-caps:normal;font-variant-east-asian:normal;font-variant-ligatures:normal;font-variant-numeric:normal\">[[r1]]</tspan>\n\t\t\t</text>\n\t\t</g>\n\t\t<g cv-if =\"ra\">\n\t\t\t<path transform=\"translate(134.82 68.294)\" d=\"m435.96 571.55 90.146 25.55\" fill=\"none\" stroke=\"#000\" stroke-width=\".5\"/>\n\t\t\t<text transform=\"translate(134.82 68.294)\" x=\"529.45886\" y=\"599.68732\" fill=\"#000000\" font-family=\"sans-serif\" font-size=\"40px\" letter-spacing=\"0px\" word-spacing=\"0px\" style=\"line-height:1.25\" xml:space=\"preserve\">\n\t\t\t\t<tspan x=\"529.45886\" y=\"599.68732\" font-family=\"sans-serif\" font-size=\"6px\" style=\"font-variant-caps:normal;font-variant-east-asian:normal;font-variant-ligatures:normal;font-variant-numeric:normal\">[[ra]]</tspan>\n\t\t\t</text>\n\t\t</g>\n\t\t<g class = \"l1\" class = \"l1\">\n\t\t\t<path transform=\"translate(134.82 68.294)\" d=\"m292.1 481.01-53.163 13.403\" fill=\"none\" stroke=\"#000\" stroke-width=\".5\"/>\n\t\t\t<text transform=\"translate(134.82 68.294)\" x=\"212.72356\" y=\"496.87265\" fill=\"#000000\" font-family=\"sans-serif\" font-size=\"40px\" letter-spacing=\"0px\" word-spacing=\"0px\" style=\"line-height:1.25\" xml:space=\"preserve\">\n\t\t\t\t<tspan class = \"l1\" x=\"212.72356\" y=\"496.87265\" font-family=\"sans-serif\" font-size=\"6px\" style=\"font-variant-caps:normal;font-variant-east-asian:normal;font-variant-ligatures:normal;font-variant-numeric:normal\">[[l1]]</tspan>\n\t\t\t</text>\n\t\t</g>\n\t\t<g cv-if = \"dpad\">\n\t\t\t<path transform=\"translate(134.82 68.294)\" d=\"m294.23 543.48-55.024 27.964\" fill=\"none\" stroke=\"#000\" stroke-width=\".5\"/>\n\t\t\t<text transform=\"translate(134.82 68.294)\" x=\"220.96754\" y=\"573.75909\" fill=\"#000000\" font-family=\"sans-serif\" font-size=\"40px\" letter-spacing=\"0px\" word-spacing=\"0px\" style=\"line-height:1.25\" xml:space=\"preserve\">\n\t\t\t\t<tspan x=\"220.96754\" y=\"573.75909\" font-family=\"sans-serif\" font-size=\"6px\" style=\"font-variant-caps:normal;font-variant-east-asian:normal;font-variant-ligatures:normal;font-variant-numeric:normal\">[[dpad]]</tspan>\n\t\t\t</text>\n\t\t</g>\n\t\t<g cv-if = \"start\" class = \"start\">\n\t\t\t<path transform=\"translate(134.82 68.294)\" d=\"m401.03 523.14v-50.774\" fill=\"none\" stroke=\"#000\" stroke-width=\".5\"/>\n\t\t\t<text transform=\"translate(134.82 68.294)\" x=\"392.06915\" y=\"470.65366\" fill=\"#000000\" font-family=\"sans-serif\" font-size=\"40px\" letter-spacing=\"0px\" word-spacing=\"0px\" style=\"line-height:1.25\" xml:space=\"preserve\">\n\t\t\t\t<tspan class = \"start\" x=\"392.06915\" y=\"470.65366\" font-family=\"sans-serif\" font-size=\"6px\" style=\"font-variant-caps:normal;font-variant-east-asian:normal;font-variant-ligatures:normal;font-variant-numeric:normal\">[[start]]</tspan>\n\t\t\t</text>\n\t\t</g>\n\t</g>\n</svg>\n"
});

;require.register("controller/xbox360-input.svg", function(exports, require, module) {
module.exports = "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n<svg\n   xmlns:dc=\"http://purl.org/dc/elements/1.1/\"\n   xmlns:cc=\"http://creativecommons.org/ns#\"\n   xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\"\n   xmlns:svg=\"http://www.w3.org/2000/svg\"\n   xmlns=\"http://www.w3.org/2000/svg\"\n   xmlns:sodipodi=\"http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd\"\n   xmlns:inkscape=\"http://www.inkscape.org/namespaces/inkscape\"\n   width=\"512\"\n   height=\"288\"\n   id=\"svg2\"\n   sodipodi:version=\"0.32\"\n   inkscape:version=\"1.0.2 (e86c870879, 2021-01-15)\"\n   sodipodi:docname=\"xbox360-input.svg\"\n   inkscape:output_extension=\"org.inkscape.output.svg.inkscape\"\n   version=\"1.0\">\n  <defs\n     id=\"defs4\">\n    <inkscape:perspective\n       sodipodi:type=\"inkscape:persp3d\"\n       inkscape:vp_x=\"0 : 663.1653 : 1\"\n       inkscape:vp_y=\"0 : 1000 : 0\"\n       inkscape:vp_z=\"744.09448 : 663.1653 : 1\"\n       inkscape:persp3d-origin=\"372.04724 : 487.7716 : 1\"\n       id=\"perspective10\" />\n    <inkscape:perspective\n       id=\"perspective2390\"\n       inkscape:persp3d-origin=\"372.04724 : 487.7716 : 1\"\n       inkscape:vp_z=\"744.09448 : 663.1653 : 1\"\n       inkscape:vp_y=\"0 : 1000 : 0\"\n       inkscape:vp_x=\"0 : 663.1653 : 1\"\n       sodipodi:type=\"inkscape:persp3d\" />\n    <inkscape:perspective\n       id=\"perspective12\"\n       inkscape:persp3d-origin=\"886.50018 : 236.98421 : 1\"\n       inkscape:vp_z=\"1773.0004 : 286.98421 : 1\"\n       inkscape:vp_y=\"0 : 1000 : 0\"\n       inkscape:vp_x=\"0 : 286.98421 : 1\"\n       sodipodi:type=\"inkscape:persp3d\" />\n    <inkscape:perspective\n       id=\"perspective3355\"\n       inkscape:persp3d-origin=\"67.123741 : 170.98342 : 1\"\n       inkscape:vp_z=\"134.24748 : 187.98302 : 1\"\n       inkscape:vp_y=\"0 : 1000 : 0\"\n       inkscape:vp_x=\"0 : 187.98302 : 1\"\n       sodipodi:type=\"inkscape:persp3d\" />\n    <inkscape:perspective\n       id=\"perspective3443\"\n       inkscape:persp3d-origin=\"177.16534 : 255.09444 : 1\"\n       inkscape:vp_z=\"354.33069 : 314.14955 : 1\"\n       inkscape:vp_y=\"0 : 1000 : 0\"\n       inkscape:vp_x=\"0 : 314.14955 : 1\"\n       sodipodi:type=\"inkscape:persp3d\" />\n  </defs>\n  <sodipodi:namedview\n     id=\"base\"\n     pagecolor=\"#ffffff\"\n     bordercolor=\"#666666\"\n     borderopacity=\"1.0\"\n     gridtolerance=\"10000\"\n     guidetolerance=\"10\"\n     objecttolerance=\"10\"\n     inkscape:pageopacity=\"0.0\"\n     inkscape:pageshadow=\"2\"\n     inkscape:zoom=\"1.7956884\"\n     inkscape:cx=\"145.53463\"\n     inkscape:cy=\"120.12192\"\n     inkscape:document-units=\"px\"\n     inkscape:current-layer=\"layer4\"\n     showgrid=\"false\"\n     inkscape:window-width=\"1920\"\n     inkscape:window-height=\"1026\"\n     inkscape:window-x=\"1050\"\n     inkscape:window-y=\"31\"\n     showguides=\"true\"\n     inkscape:guide-bbox=\"true\"\n     inkscape:document-rotation=\"0\"\n     inkscape:window-maximized=\"1\">\n    <sodipodi:guide\n       position=\"399.98588,184.41855\"\n       orientation=\"1,0\"\n       id=\"guide4464\" />\n    <sodipodi:guide\n       position=\"113.8839,194.16412\"\n       orientation=\"1,0\"\n       id=\"guide5621\" />\n  </sodipodi:namedview>\n  <metadata\n     id=\"metadata7\">\n    <rdf:RDF>\n      <cc:Work\n         rdf:about=\"\">\n        <dc:format>image/svg+xml</dc:format>\n        <dc:type\n           rdf:resource=\"http://purl.org/dc/dcmitype/StillImage\" />\n        <dc:title></dc:title>\n      </cc:Work>\n    </rdf:RDF>\n  </metadata>\n  <g\n     inkscape:label=\"Layer 1\"\n     inkscape:groupmode=\"layer\"\n     id=\"layer1\"\n     transform=\"translate(-260.34243,-473.69226)\">\n    <g\n       id=\"g237\"\n       transform=\"translate(134.82195,68.29447)\">\n      <g\n         id=\"g817\"\n         transform=\"matrix(0.32231801,0,0,0.32231801,260.60086,378.95899)\">\n        <path\n           style=\"fill:#d8d8d8;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:3;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n           d=\"m 628.39816,299.51068 c -0.21851,-1.09254 -4.15168,-18.13627 -4.58869,-20.97689 -0.43702,-2.84062 -1.09255,-4.37019 -4.5887,-6.77379 -32.81359,-22.55933 -17.06203,-23.18579 -55.11042,-17.04898 -6.77379,1.09254 -15.51417,18.13627 -15.51417,18.13627 z\"\n           id=\"path3352-3-3\"\n           sodipodi:nodetypes=\"cssscc\"\n           data-button=\"button-7\" />\n        <path\n           style=\"fill:#d8d8d8;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:3;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n           d=\"m 124.78295,299.51068 c 0.21851,-1.09254 4.15168,-18.13627 4.58869,-20.97689 0.43702,-2.84062 1.09255,-4.37019 4.5887,-6.77379 32.81359,-22.55933 17.06203,-23.18579 55.11042,-17.04898 6.77379,1.09254 15.51417,18.13627 15.51417,18.13627 z\"\n           id=\"path3352-3\"\n           sodipodi:nodetypes=\"cssscc\"\n           data-button=\"button-6\" />\n        <g\n           id=\"g4442\"\n           transform=\"matrix(0.5752286,0,0,0.5752286,161.90411,275.5957)\"\n           style=\"stroke:#000000;stroke-width:2;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\">\n          <rect\n             style=\"fill:#4d4d4d;fill-opacity:1;stroke:#000000;stroke-width:2;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n             id=\"rect4436\"\n             width=\"45.344299\"\n             height=\"27.532085\"\n             x=\"390.84552\"\n             y=\"630.43866\"\n             ry=\"4.973381\"\n             rx=\"4.973381\" />\n          <rect\n             rx=\"4.973381\"\n             ry=\"4.973381\"\n             y=\"630.43866\"\n             x=\"305.26193\"\n             height=\"27.532085\"\n             width=\"45.344299\"\n             id=\"rect4438\"\n             style=\"fill:#4d4d4d;fill-opacity:1;stroke:#000000;stroke-width:2;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\" />\n          <rect\n             style=\"fill:#4d4d4d;fill-opacity:1;stroke:#000000;stroke-width:2;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n             id=\"rect4440\"\n             width=\"32.910625\"\n             height=\"27.325605\"\n             x=\"354.27057\"\n             y=\"630.23145\"\n             ry=\"4.973381\"\n             rx=\"4.973381\" />\n        </g>\n        <path\n           sodipodi:nodetypes=\"cssscc\"\n           id=\"path3365\"\n           d=\"m 655.50745,318.60794 c -0.21851,-1.09254 -4.15168,-18.13627 -4.58869,-20.97689 -0.43702,-2.84062 -1.09255,-4.37019 -4.5887,-6.77379 -32.81359,-22.55933 -71.20626,-33.45047 -109.25465,-27.31366 -6.77379,1.09254 -15.51417,18.13627 -15.51417,18.13627 z\"\n           style=\"fill:#d8d8d8;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:3;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n           data-button=\"button-5\" />\n        <path\n           style=\"fill:#d8d8d8;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:3;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n           d=\"m 97.673659,318.60794 c 0.218509,-1.09254 4.151681,-18.13627 4.588691,-20.97689 0.43702,-2.84062 1.09255,-4.37019 4.5887,-6.77379 32.81359,-22.55933 71.20626,-33.45047 109.25465,-27.31366 6.77379,1.09254 15.51417,18.13627 15.51417,18.13627 z\"\n           id=\"path3352\"\n           sodipodi:nodetypes=\"cssscc\"\n           data-button=\"button-4\" />\n        <path\n           style=\"fill:#cccccc;fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:3;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n           d=\"m 692.40625,795.6875 c 36.84007,1.09337 52.80772,-18.83796 56.40625,-117.4375 3.77124,-103.33202 -63.29854,-299.68945 -82.96875,-349.21875 -19.67025,-49.52929 -118.71329,-75.82532 -163.65625,-47.5 -36.98649,23.31075 -77.50632,26.375 -127.03125,26.375 -49.52492,0 -90.0135,-3.06425 -127,-26.375 -12.6402,-7.9665 -29.58112,-11.63473 -47.8125,-11.65625 C 153.75246,269.82 98.606739,293.43208 84.46875,329.03125 64.798509,378.56054 -2.2712417,574.91797 1.5,678.25 c 3.5785642,98.05266 19.406856,118.31763 55.8125,117.45312 84.47581,-9.05099 93.14578,-56.86454 150.09375,-101.60937 52.79739,-41.48369 89.78117,-45.2585 167.46875,-43.75 77.68757,-1.50848 114.64011,2.26634 167.4375,43.75 56.94798,44.7448 65.61794,92.54276 150.09375,101.59375 z\"\n           id=\"path3354\"\n           sodipodi:nodetypes=\"cssssscsscscsc\" />\n        <path\n           style=\"fill:#808080;fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:3;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n           d=\"m 376.55538,626.9578 c -70.07127,10e-6 -105.56406,1.53631 -141.34375,21.125 -74.56634,40.82366 -89.5368,105.33263 -168.59376,147.59375 77.18929,-11.18226 87.06449,-58.28282 142.1875,-101.59375 52.7974,-41.48366 89.78118,-45.2585 167.46876,-43.75 77.68757,-1.50851 114.64011,2.26634 167.4375,43.75 55.31458,43.46144 65.07175,90.74856 143,101.71875 -79.25058,-42.25894 -94.17658,-106.857 -168.8125,-147.71875 -35.77969,-19.58869 -71.27248,-21.125 -141.34375,-21.125 z\"\n           id=\"path3191\" />\n        <ellipse\n           style=\"opacity:1;fill:#d4d4d4;fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:1.24301;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n           id=\"path3339\"\n           cx=\"485.73596\"\n           cy=\"515.71448\"\n           rx=\"90.509804\"\n           ry=\"93.149673\" />\n        <ellipse\n           style=\"opacity:1;fill:#d4d4d4;fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:1;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n           id=\"path3335\"\n           cx=\"162.54053\"\n           cy=\"382.21249\"\n           rx=\"76.556213\"\n           ry=\"71.276474\" />\n        <ellipse\n           id=\"path3337\"\n           style=\"opacity:1;fill:#d4d4d4;fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:1.24301;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n           cx=\"264.74118\"\n           cy=\"515.71448\"\n           rx=\"90.509804\"\n           ry=\"93.149673\" />\n        <circle\n           style=\"opacity:1;fill:#333333;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:3;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n           id=\"path3249\"\n           cx=\"265.90213\"\n           cy=\"501.4498\"\n           r=\"60.547413\" />\n        <path\n           id=\"path3253\"\n           style=\"fill:#3a3a3a;fill-opacity:1;fill-rule:evenodd;stroke:#515151;stroke-width:3;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-opacity:1\"\n           d=\"m 249.60884,556.05516 c 0,5.37504 32.58658,4.96298 32.58658,0 0,-20.05425 16.27567,-36.33015 36.32964,-36.33015 5.24879,1.15665 7.27598,-35.55207 0,-36.55035 -20.05397,0 -36.32964,-16.2759 -36.32964,-36.33015 0,-5.39506 -32.58658,-5.80591 -32.58658,0 0,20.05425 -16.27567,36.33015 -36.32964,36.33015 -5.88003,-0.22498 -7.05562,36.34403 0,36.55035 20.05397,0 36.32964,16.2759 36.32964,36.33015 z\"\n           sodipodi:nodetypes=\"ccccssccc\"\n           data-button=\"dpad-0\" />\n        <g\n           id=\"g3292\"\n           data-button=\"button-9\">\n          <rect\n             ry=\"16.450199\"\n             rx=\"16.450203\"\n             y=\"372.24924\"\n             x=\"437.39334\"\n             height=\"29.558952\"\n             width=\"37.428303\"\n             id=\"rect3288\"\n             style=\"opacity:1;fill:#d1d1d1;fill-opacity:1;fill-rule:evenodd;stroke:#6d6d6d;stroke-width:1;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\" />\n          <path\n             transform=\"matrix(0,1.1259413,1.1259413,0,20.719223,57.395722)\"\n             inkscape:randomized=\"0\"\n             inkscape:rounded=\"0\"\n             inkscape:flatsided=\"true\"\n             sodipodi:arg2=\"0.52359878\"\n             sodipodi:arg1=\"-0.52359878\"\n             sodipodi:r2=\"4.7132702\"\n             sodipodi:r1=\"9.4265404\"\n             sodipodi:cy=\"386.38617\"\n             sodipodi:cx=\"292.76215\"\n             sodipodi:sides=\"3\"\n             id=\"path3290\"\n             style=\"opacity:1;fill:#717171;fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:3;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n             sodipodi:type=\"star\"\n             d=\"m 300.92577,381.6729 -8.16362,14.13981 -8.16363,-14.13981 z\" />\n        </g>\n        <g\n           id=\"g3296-7\"\n           data-button=\"button-8\">\n          <rect\n             style=\"opacity:1;fill:#d1d1d1;fill-opacity:1;fill-rule:evenodd;stroke:#6d6d6d;stroke-width:1;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n             id=\"rect3298-5\"\n             width=\"37.428303\"\n             height=\"29.558952\"\n             x=\"282.40161\"\n             y=\"372.24924\"\n             rx=\"16.450203\"\n             ry=\"16.450199\" />\n          <path\n             sodipodi:type=\"star\"\n             style=\"opacity:1;fill:#717171;fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:3;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n             id=\"path3300-6\"\n             sodipodi:sides=\"3\"\n             sodipodi:cx=\"292.76215\"\n             sodipodi:cy=\"386.38617\"\n             sodipodi:r1=\"9.4265404\"\n             sodipodi:r2=\"4.7132702\"\n             sodipodi:arg1=\"-0.52359878\"\n             sodipodi:arg2=\"0.52359878\"\n             inkscape:flatsided=\"true\"\n             inkscape:rounded=\"0\"\n             inkscape:randomized=\"0\"\n             transform=\"matrix(0,1.1259413,-1.1259413,0,738.02813,57.395722)\"\n             d=\"m 300.92577,381.6729 -8.16362,14.13981 -8.16363,-14.13981 z\" />\n        </g>\n        <circle\n           id=\"path3310\"\n           style=\"opacity:1;fill:#a7a7a7;fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:1.07159;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n           cx=\"379.25415\"\n           cy=\"382.24289\"\n           r=\"27.00733\" />\n        <g\n           id=\"g4372\"\n           data-button=\"button-16\">\n          <circle\n             id=\"path3304\"\n             style=\"opacity:1;fill:#007800;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:1;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n             cx=\"379.25418\"\n             cy=\"387.28577\"\n             r=\"42.671013\" />\n          <circle\n             style=\"opacity:1;fill:#979797;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:1;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n             id=\"path3302\"\n             cx=\"379.25418\"\n             cy=\"387.28577\"\n             r=\"36.252529\" />\n          <path\n             style=\"fill:#007800;fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:0.25pt;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1\"\n             d=\"m 344.94011,404.6356 c 11.61506,-28.78785 27.87652,-46.26619 54.74832,-50.37874 l 3.08442,2.57034 c -21.94963,7.88995 -42.83002,29.43216 -53.72019,53.46315 z\"\n             id=\"path3306\"\n             sodipodi:nodetypes=\"ccccc\" />\n          <path\n             sodipodi:nodetypes=\"ccccc\"\n             id=\"path3308\"\n             d=\"M 412.64636,405.10615 C 401.90402,378.48134 383.44171,358.47214 358.58899,354.6686 l -2.85267,2.37721 c 20.3004,7.29712 43.03458,31.06484 53.1065,53.29021 z\"\n             style=\"fill:#007800;fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:0.25pt;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1\" />\n        </g>\n        <text\n           xml:space=\"preserve\"\n           style=\"font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;line-height:0%;font-family:'DejaVu Sans Mono';-inkscape-font-specification:'DejaVu Sans Mono';text-align:center;writing-mode:lr-tb;text-anchor:middle;fill:#000000;fill-opacity:1;stroke:none;stroke-width:3pt;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1\"\n           x=\"472.78644\"\n           y=\"364.41809\"\n           id=\"text3312\"><tspan\n             sodipodi:role=\"line\"\n             id=\"tspan3314\"\n             x=\"472.78644\"\n             y=\"364.41809\"\n             style=\"font-size:10.9335px;line-height:-2\">START</tspan></text>\n        <path\n           d=\"m 542.19462,503.98223 c 0,31.40573 -25.48873,56.89446 -56.89447,56.89446 -31.40574,0 -56.89447,-25.48873 -56.89447,-56.89446 0,-31.40575 25.48873,-56.89448 56.89447,-56.89448 31.40574,0 56.89447,25.48873 56.89447,56.89448 z m -8.30373,-1e-5 c 0,26.82209 -21.76866,48.59074 -48.59074,48.59074 -26.82209,0 -48.59075,-21.76865 -48.59075,-48.59074 0,-26.82209 21.76866,-48.59074 48.59075,-48.59074 26.82208,0 48.59074,21.76865 48.59074,48.59074 z\"\n           style=\"fill:#dfdfdf;fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:2.06703;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-opacity:1\"\n           id=\"path3348\" />\n        <text\n           xml:space=\"preserve\"\n           style=\"font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;line-height:0%;font-family:'DejaVu Sans Mono';-inkscape-font-specification:'DejaVu Sans Mono';text-align:center;writing-mode:lr-tb;text-anchor:middle;fill:#000000;fill-opacity:1;stroke:none;stroke-width:3pt;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1\"\n           x=\"284.78766\"\n           y=\"362.92157\"\n           id=\"text3316\"><tspan\n             sodipodi:role=\"line\"\n             id=\"tspan3318\"\n             x=\"284.78766\"\n             y=\"362.92157\"\n             style=\"font-size:10.9335px;line-height:1\">BACK</tspan></text>\n        <path\n           id=\"path3350\"\n           style=\"fill:#dfdfdf;fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:2.06703;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-opacity:1\"\n           d=\"m 218.67656,375.05998 c 0,30.22813 -24.533,54.76113 -54.76114,54.76113 -30.22814,0 -54.76114,-24.533 -54.76114,-54.76113 0,-30.22815 24.533,-54.76115 54.76114,-54.76115 30.22814,0 54.76114,24.533 54.76114,54.76115 z m -7.99237,-10e-6 c 0,25.81636 -20.95242,46.76877 -46.76877,46.76877 -25.81636,0 -46.76878,-20.95241 -46.76878,-46.76877 0,-25.81636 20.95242,-46.76877 46.76878,-46.76877 25.81635,0 46.76877,20.95241 46.76877,46.76877 z\" />\n        <path\n           id=\"path3320\"\n           style=\"fill:none;fill-opacity:1;fill-rule:evenodd;stroke:#969696;stroke-width:0.81337;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-opacity:1\"\n           d=\"m 379.23104,433.61031 c 12.61575,0 24.35251,-4.77192 32.3309,-13.285 7.1145,-7.5913 15.68671,-13.9149 22.63475,-13.9149 6.94804,0 -0.53333,0 -0.53333,0 0,0 27.94422,0 27.94422,0 10.45366,0 18.93778,-8.48412 18.93778,-19.03121 0,-10.54708 -8.48412,-19.0312 -18.93778,-19.0312 0,0 -27.94422,0 -27.94422,0 0,0 7.48137,0 0.53333,0 -6.94804,0 -15.52025,-6.3236 -22.63475,-13.9149 -7.97839,-8.51308 -19.73829,-13.285 -32.3309,-13.285 -12.5926,0 -24.3525,4.77192 -32.33089,13.285 -7.1145,7.5913 -15.68671,13.9149 -22.63475,13.9149 -6.94804,0 0.53333,0 0.53333,0 0,0 -27.94422,0 -27.94422,0 -10.45366,0 -18.93778,8.48412 -18.93778,19.0312 0,10.54709 8.48412,19.03121 18.93778,19.03121 0,0 27.94422,0 27.94422,0 0,0 -7.48137,0 -0.53333,0 6.94804,0 15.52025,6.3236 22.63475,13.9149 7.97839,8.51308 19.71515,13.285 32.33089,13.285 z\"\n           sodipodi:nodetypes=\"cssccsccsscssccsccssc\" />\n        <path\n           id=\"path3341\"\n           style=\"fill:#dfdfdf;fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:2.06703;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-opacity:1\"\n           d=\"m 338.14038,501.44979 c 0,39.8755 -32.36275,72.23825 -72.23826,72.23825 -39.87552,0 -72.23826,-32.36275 -72.23826,-72.23825 0,-39.87552 32.36274,-72.23827 72.23826,-72.23827 39.87551,0 72.23826,32.36275 72.23826,72.23827 z m -10.54315,-1e-5 c 0,34.0557 -27.63942,61.69511 -61.69511,61.69511 -34.0557,0 -61.69512,-27.63941 -61.69512,-61.69511 0,-34.0557 27.63942,-61.69511 61.69512,-61.69511 34.05569,0 61.69511,27.63941 61.69511,61.69511 z\" />\n        <g\n           id=\"g3233-5\"\n           data-button=\"button-10\">\n          <circle\n             style=\"opacity:1;fill:#4d4d4d;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:3;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n             id=\"path3235-6\"\n             cx=\"163.84641\"\n             cy=\"375.03775\"\n             r=\"49.266716\" />\n          <circle\n             id=\"path3237-6\"\n             style=\"opacity:1;fill:#333333;fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:3;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n             cx=\"163.84641\"\n             cy=\"375.03778\"\n             r=\"34.993183\" />\n          <g\n             id=\"g3239-4\"\n             transform=\"matrix(1.0746269,0,0,1.0746269,-358.16498,-156.16434)\">\n            <circle\n               transform=\"matrix(0.08411222,0,0,0.08411222,471.14277,452.73529)\"\n               id=\"path3241-0\"\n               style=\"fill:#9b9b9b;fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:26.75;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n               cx=\"491.28583\"\n               cy=\"494.31305\"\n               r=\"49.266716\" />\n            <circle\n               style=\"fill:#9b9b9b;fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:26.75;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n               id=\"path3243-0\"\n               transform=\"matrix(0.08411222,0,0,0.08411222,417.73213,452.73529)\"\n               cx=\"491.28583\"\n               cy=\"494.31305\"\n               r=\"49.266716\" />\n            <circle\n               style=\"fill:#9b9b9b;fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:26.75;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n               id=\"path3245-4\"\n               transform=\"matrix(0,0.08411222,-0.08411222,0,527.33836,479.69524)\"\n               cx=\"491.28583\"\n               cy=\"494.31305\"\n               r=\"49.266716\" />\n            <circle\n               transform=\"matrix(0,0.08411222,-0.08411222,0,527.33836,426.2846)\"\n               id=\"path3247-6\"\n               style=\"fill:#9b9b9b;fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:26.75;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n               cx=\"491.28583\"\n               cy=\"494.31305\"\n               r=\"49.266716\" />\n          </g>\n        </g>\n        <g\n           id=\"g3224\"\n           data-button=\"button-11\">\n          <circle\n             id=\"path3196\"\n             style=\"opacity:1;fill:#4d4d4d;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:3;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n             cx=\"491.28583\"\n             cy=\"494.31305\"\n             r=\"49.266716\"\n             transform=\"translate(-5.525239)\" />\n          <circle\n             style=\"opacity:1;fill:#333333;fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:4.22368;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n             id=\"path3198\"\n             transform=\"matrix(0.7102804,0,0,0.7102804,136.8099,143.21219)\"\n             cx=\"491.28583\"\n             cy=\"494.31305\"\n             r=\"49.266716\" />\n          <g\n             transform=\"matrix(1.0746269,0,0,1.0746269,-36.250788,-36.889032)\"\n             id=\"g3218\">\n            <circle\n               style=\"fill:#9b9b9b;fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:26.75;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n               id=\"path3200\"\n               transform=\"matrix(0.08411222,0,0,0.08411222,471.14277,452.73529)\"\n               cx=\"491.28583\"\n               cy=\"494.31305\"\n               r=\"49.266716\" />\n            <circle\n               transform=\"matrix(0.08411222,0,0,0.08411222,417.73213,452.73529)\"\n               id=\"path3202\"\n               style=\"fill:#9b9b9b;fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:26.75;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n               cx=\"491.28583\"\n               cy=\"494.31305\"\n               r=\"49.266716\" />\n            <circle\n               transform=\"matrix(0,0.08411222,-0.08411222,0,527.33836,479.69524)\"\n               id=\"path3210-6\"\n               style=\"fill:#9b9b9b;fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:26.75;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n               cx=\"491.28583\"\n               cy=\"494.31305\"\n               r=\"49.266716\" />\n            <circle\n               style=\"fill:#9b9b9b;fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:26.75;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n               id=\"path3212-9\"\n               transform=\"matrix(0,0.08411222,-0.08411222,0,527.33836,426.2846)\"\n               cx=\"491.28583\"\n               cy=\"494.31305\"\n               r=\"49.266716\" />\n          </g>\n        </g>\n        <circle\n           id=\"path3405\"\n           style=\"opacity:1;fill:#dadada;fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:1.26316;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n           cx=\"645.6366\"\n           cy=\"385.60663\"\n           r=\"36.203922\" />\n        <path\n           sodipodi:nodetypes=\"cssssscsscscsc\"\n           id=\"path3363\"\n           d=\"m 692.40625,795.6875 c 36.84007,1.09337 52.80772,-18.83796 56.40625,-117.4375 3.77124,-103.33202 -63.29854,-299.68945 -82.96875,-349.21875 -19.67025,-49.52929 -118.71329,-75.82532 -163.65625,-47.5 -36.98649,23.31075 -77.50632,26.375 -127.03125,26.375 -49.52492,0 -90.0135,-3.06425 -127,-26.375 -12.6402,-7.9665 -29.58112,-11.63473 -47.8125,-11.65625 C 153.75246,269.82 98.606739,293.43208 84.46875,329.03125 64.798509,378.56054 -2.2712417,574.91797 1.5,678.25 c 3.5785642,98.05266 19.406856,118.31763 55.8125,117.45312 84.47581,-9.05099 93.14578,-56.86454 150.09375,-101.60937 52.79739,-41.48369 89.78117,-45.2585 167.46875,-43.75 77.68757,-1.50848 114.64011,2.26634 167.4375,43.75 56.94798,44.7448 65.61794,92.54276 150.09375,101.59375 z\"\n           style=\"fill:none;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:3;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\" />\n        <circle\n           style=\"opacity:1;fill:#dadada;fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:1.26316;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n           id=\"path3403\"\n           cx=\"536.64771\"\n           cy=\"385.60663\"\n           r=\"36.203922\" />\n        <circle\n           style=\"opacity:1;fill:#dadada;fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:1.26316;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n           id=\"path3407\"\n           cx=\"590.95355\"\n           cy=\"333.56348\"\n           r=\"36.203922\" />\n        <circle\n           id=\"path3409\"\n           style=\"opacity:1;fill:#dadada;fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:1.26316;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n           cx=\"590.95355\"\n           cy=\"441.04388\"\n           r=\"36.203922\" />\n        <g\n           id=\"g4272\"\n           data-button=\"button-2\">\n          <circle\n             style=\"opacity:1;fill:#004cca;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:1;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n             id=\"path3367\"\n             cx=\"536.64771\"\n             cy=\"382.96677\"\n             r=\"25.267321\" />\n          <path\n             style=\"fill:#ffffff;fill-opacity:0.486772;fill-rule:evenodd;stroke:none;stroke-width:1;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-opacity:1\"\n             d=\"m 553.83094,369.19255 c 0,5.88801 -7.72084,1.63138 -17.23402,1.63138 -9.51318,0 -17.23402,4.25663 -17.23402,-1.63138 0,-5.888 7.72084,-10.66668 17.23402,-10.66668 9.51318,0 17.23402,4.77868 17.23402,10.66668 z\"\n             id=\"path3433\"\n             sodipodi:nodetypes=\"csssc\" />\n          <path\n             sodipodi:nodetypes=\"csssc\"\n             id=\"path3462\"\n             d=\"m 557.61978,396.01861 c 0,-6.53475 -10.46192,4.49228 -21.02005,4.49228 -10.55813,0 -21.02005,-10.71153 -21.02005,-4.17678 0,6.53475 10.46192,11.52283 21.02005,11.52283 10.55813,0 21.02005,-5.30358 21.02005,-11.83833 z\"\n             style=\"fill:#000000;fill-opacity:0.26455;fill-rule:evenodd;stroke:none;stroke-width:1;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-opacity:1\" />\n        </g>\n        <text\n           xml:space=\"preserve\"\n           style=\"font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;line-height:0%;font-family:'DejaVu Sans Mono';-inkscape-font-specification:'DejaVu Sans Mono Bold';text-align:center;writing-mode:lr-tb;text-anchor:middle;fill:#000000;fill-opacity:0.70356804;stroke:none;stroke-width:3pt;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1;\"\n           x=\"491.71802\"\n           y=\"429.30984\"\n           id=\"text3381\"\n           transform=\"scale(1.0913562,0.91629113)\"><tspan\n             sodipodi:role=\"line\"\n             id=\"tspan3383\"\n             x=\"491.71802\"\n             y=\"429.30984\"\n             style=\"font-size:31.1568px;line-height:-2;fill:#000000;fill-opacity:0.70356804;\">X</tspan></text>\n        <g\n           id=\"g4267\"\n           data-button=\"button-3\">\n          <circle\n             id=\"path3371\"\n             style=\"fill:#ffaa00;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:1;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n             transform=\"scale(-1)\"\n             cx=\"-591.33069\"\n             cy=\"-328.28375\"\n             r=\"25.267321\" />\n          <path\n             sodipodi:nodetypes=\"csssc\"\n             id=\"path3436\"\n             d=\"m 609.04671,315.31534 c 0,5.88801 -7.72084,1.63138 -17.23402,1.63138 -9.51318,0 -17.23402,4.25663 -17.23402,-1.63138 0,-5.888 7.72084,-10.66668 17.23402,-10.66668 9.51318,0 17.23402,4.77868 17.23402,10.66668 z\"\n             style=\"fill:#ffffff;fill-opacity:0.486772;fill-rule:evenodd;stroke:none;stroke-width:1;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-opacity:1\" />\n          <path\n             sodipodi:nodetypes=\"csssc\"\n             id=\"path3456\"\n             d=\"m 612.51723,341.12116 c 0,-6.53475 -10.46192,4.49228 -21.02005,4.49228 -10.55813,0 -21.02005,-10.71153 -21.02005,-4.17678 0,6.53475 10.46192,11.52283 21.02005,11.52283 10.55813,0 21.02005,-5.30358 21.02005,-11.83833 z\"\n             style=\"fill:#000000;fill-opacity:0.26455;fill-rule:evenodd;stroke:none;stroke-width:1;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-opacity:1\" />\n        </g>\n        <text\n           xml:space=\"preserve\"\n           style=\"font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;line-height:0%;font-family:'DejaVu Sans Mono';-inkscape-font-specification:'DejaVu Sans Mono Bold';text-align:center;writing-mode:lr-tb;text-anchor:middle;fill:#000000;fill-opacity:0.70356804;stroke:none;stroke-width:3pt;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1;\"\n           x=\"541.82349\"\n           y=\"369.6312\"\n           id=\"text3385\"\n           transform=\"scale(1.0913562,0.91629113)\"><tspan\n             sodipodi:role=\"line\"\n             id=\"tspan3387\"\n             x=\"541.82349\"\n             y=\"369.6312\"\n             style=\"font-size:31.1568px;line-height:-2;fill:#000000;fill-opacity:0.70356804;\">Y</tspan></text>\n        <g\n           id=\"g4257\"\n           data-button=\"button-0\">\n          <circle\n             transform=\"scale(-1)\"\n             style=\"fill:#009a00;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:1;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n             id=\"path3373\"\n             cx=\"-591.33069\"\n             cy=\"-437.64978\"\n             r=\"25.267321\" />\n          <path\n             style=\"fill:#ffffff;fill-opacity:0.486772;fill-rule:evenodd;stroke:none;stroke-width:1;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-opacity:1\"\n             d=\"m 609.04671,423.73903 c 0,5.88801 -7.72084,1.63138 -17.23402,1.63138 -9.51318,0 -17.23402,4.25663 -17.23402,-1.63138 0,-5.888 7.72084,-10.66668 17.23402,-10.66668 9.51318,0 17.23402,4.77868 17.23402,10.66668 z\"\n             id=\"path3438\"\n             sodipodi:nodetypes=\"csssc\" />\n          <path\n             style=\"fill:#000000;fill-opacity:0.26455;fill-rule:evenodd;stroke:none;stroke-width:1;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-opacity:1\"\n             d=\"m 612.51723,450.91606 c 0,-6.53475 -10.46192,4.49228 -21.02005,4.49228 -10.55813,0 -21.02005,-10.71153 -21.02005,-4.17678 0,6.53475 10.46192,11.52283 21.02005,11.52283 10.55813,0 21.02005,-5.30358 21.02005,-11.83833 z\"\n             id=\"path3460\"\n             sodipodi:nodetypes=\"csssc\" />\n        </g>\n        <text\n           xml:space=\"preserve\"\n           style=\"font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;line-height:0%;font-family:'DejaVu Sans Mono';-inkscape-font-specification:'DejaVu Sans Mono Bold';text-align:center;writing-mode:lr-tb;text-anchor:middle;fill:#000000;fill-opacity:0.70356804;stroke:none;stroke-width:3pt;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1;\"\n           x=\"541.82349\"\n           y=\"488.98853\"\n           id=\"text3389\"\n           transform=\"scale(1.0913562,0.91629113)\"><tspan\n             sodipodi:role=\"line\"\n             id=\"tspan3391\"\n             x=\"541.82349\"\n             y=\"488.98853\"\n             style=\"font-size:31.1568px;line-height:-2;fill:#000000;fill-opacity:0.70356804;\">A</tspan></text>\n        <g\n           id=\"g4262\"\n           data-button=\"button-1\">\n          <circle\n             id=\"path3369\"\n             style=\"opacity:1;fill:#740000;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:1;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n             cx=\"646.01373\"\n             cy=\"382.96677\"\n             r=\"25.267321\" />\n          <path\n             sodipodi:nodetypes=\"csssc\"\n             id=\"path3440\"\n             d=\"m 663.92784,369.52718 c 0,5.88801 -7.72084,1.63138 -17.23402,1.63138 -9.51318,0 -17.23402,4.25663 -17.23402,-1.63138 0,-5.888 7.72084,-10.66668 17.23402,-10.66668 9.51318,0 17.23402,4.77868 17.23402,10.66668 z\"\n             style=\"fill:#ffffff;fill-opacity:0.486772;fill-rule:evenodd;stroke:none;stroke-width:1;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-opacity:1\" />\n          <path\n             style=\"fill:#000000;fill-opacity:0.26455;fill-rule:evenodd;stroke:none;stroke-width:1;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-opacity:1\"\n             d=\"m 667.73018,396.01861 c 0,-6.53475 -10.46192,4.49228 -21.02005,4.49228 -10.55813,0 -21.02005,-10.71153 -21.02005,-4.17678 0,6.53475 10.46192,11.52283 21.02005,11.52283 10.55813,0 21.02005,-5.30358 21.02005,-11.83833 z\"\n             id=\"path3464\"\n             sodipodi:nodetypes=\"csssc\" />\n        </g>\n        <text\n           xml:space=\"preserve\"\n           style=\"font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;line-height:0%;font-family:'DejaVu Sans Mono';-inkscape-font-specification:'DejaVu Sans Mono Bold';text-align:center;writing-mode:lr-tb;text-anchor:middle;fill:#000000;fill-opacity:0.70356804;stroke:none;stroke-width:3pt;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1;\"\n           x=\"591.54114\"\n           y=\"429.32504\"\n           id=\"text3393\"\n           transform=\"scale(1.0913562,0.91629113)\"><tspan\n             sodipodi:role=\"line\"\n             id=\"tspan3395\"\n             x=\"591.54114\"\n             y=\"429.32504\"\n             style=\"font-size:31.1568px;line-height:-2;fill:#000000;fill-opacity:0.70356804;\">B</tspan></text>\n        <text\n           xml:space=\"preserve\"\n           style=\"font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;line-height:0%;font-family:Arial;-inkscape-font-specification:Arial;text-align:start;writing-mode:lr-tb;text-anchor:start;fill:#808080;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1\"\n           x=\"334.25269\"\n           y=\"350.16708\"\n           id=\"text4416\"><tspan\n             sodipodi:role=\"line\"\n             id=\"tspan4418\"\n             x=\"334.25269\"\n             y=\"350.16708\"\n             style=\"font-size:19.0724px;line-height:1.25\">1</tspan></text>\n        <text\n           id=\"text4420\"\n           y=\"350.16708\"\n           x=\"412.03046\"\n           style=\"font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;line-height:0%;font-family:Arial;-inkscape-font-specification:Arial;text-align:start;writing-mode:lr-tb;text-anchor:start;fill:#808080;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1\"\n           xml:space=\"preserve\"><tspan\n             y=\"350.16708\"\n             x=\"412.03046\"\n             id=\"tspan4422\"\n             sodipodi:role=\"line\"\n             style=\"font-size:19.0724px;line-height:1.25\">2</tspan></text>\n        <text\n           xml:space=\"preserve\"\n           style=\"font-style:normal;font-weight:normal;line-height:0%;font-family:'Bitstream Vera Sans';fill:#007800;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1;\"\n           x=\"337.12454\"\n           y=\"424.88486\"\n           id=\"text4424\"><tspan\n             sodipodi:role=\"line\"\n             id=\"tspan4426\"\n             x=\"337.12454\"\n             y=\"424.88486\"\n             style=\"font-size:40px;line-height:1.25;fill:#007800;fill-opacity:1;\"> </tspan></text>\n        <text\n           id=\"text4428\"\n           y=\"436.35324\"\n           x=\"334.25269\"\n           style=\"font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;line-height:0%;font-family:Arial;-inkscape-font-specification:Arial;text-align:start;writing-mode:lr-tb;text-anchor:start;fill:#808080;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1\"\n           xml:space=\"preserve\"><tspan\n             y=\"436.35324\"\n             x=\"334.25269\"\n             id=\"tspan4430\"\n             sodipodi:role=\"line\"\n             style=\"font-size:19.0724px;line-height:1.25\">3</tspan></text>\n        <text\n           xml:space=\"preserve\"\n           style=\"font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;line-height:0%;font-family:Arial;-inkscape-font-specification:Arial;text-align:start;writing-mode:lr-tb;text-anchor:start;fill:#808080;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1\"\n           x=\"412.03046\"\n           y=\"436.35324\"\n           id=\"text4432\"><tspan\n             sodipodi:role=\"line\"\n             id=\"tspan4434\"\n             x=\"412.03046\"\n             y=\"436.35324\"\n             style=\"font-size:19.0724px;line-height:1.25\">4</tspan></text>\n      </g>\n    </g>\n  </g>\n  <g\n     inkscape:groupmode=\"layer\"\n     id=\"layer4\"\n     inkscape:label=\"Layer 2\"\n     transform=\"translate(-125.52048,-405.39779)\">\n\t<g cv-if = \"a\" class = \"a\">\n    <path\n       style=\"fill:none;stroke:#000000;stroke-width:0.499999;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n       d=\"m 455.79635,519.99047 69.71001,17.90083\"\n       id=\"path4466-5-6\"\n       sodipodi:nodetypes=\"cc\" /></g>\n\t<g cv-if = \"x\" class = \"x\">\n    <path\n       style=\"fill:none;stroke:#000000;stroke-width:0.499999;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n       d=\"m 438.47373,504.22466 87.03273,22.59255\"\n       id=\"path4466-6\"\n       sodipodi:nodetypes=\"cc\" /></g>\n\t<g cv-if = \"y\" class = \"y\">\n    <path\n       style=\"fill:none;stroke:#000000;stroke-width:0.499999;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n       d=\"m 457.35152,487.45952 68.15505,16.26615\"\n       id=\"path4466-5-6-4\"\n       sodipodi:nodetypes=\"cc\" /></g>\n\t<g cv-if = \"b\" class = \"b\">\n    <path\n       style=\"fill:none;stroke:#000000;stroke-width:0.499999;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n       d=\"m 473.60248,502.87892 51.90361,12.60482\"\n       id=\"path4466-6-0\"\n       sodipodi:nodetypes=\"cc\" /></g>\n    <text\n       xml:space=\"preserve\"\n       style=\"font-style:normal;font-weight:normal;font-size:40px;line-height:1.25;font-family:sans-serif;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;stroke-width:1\"\n       x=\"526.79633\"\n       y=\"517.52081\"\n       id=\"text3125-3-3-9-9\"><tspan\n\t     class = \"b\"\n         sodipodi:role=\"line\"\n         id=\"tspan3123-1-4-1-6\"\n         x=\"526.79633\"\n         y=\"517.52081\"\n         style=\"font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:6.00001px;font-family:sans-serif;-inkscape-font-specification:'sans-serif, Normal';font-variant-ligatures:normal;font-variant-caps:normal;font-variant-numeric:normal;font-variant-east-asian:normal;stroke-width:1\">[[b]]</tspan></text>\n    <text\n       xml:space=\"preserve\"\n       style=\"font-style:normal;font-weight:normal;font-size:40px;line-height:1.25;font-family:sans-serif;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;stroke-width:1\"\n       x=\"527.09454\"\n       y=\"540.36304\"\n       id=\"text3125-3-3-9-9-0\"><tspan\n\t     class = \"a\"\n         sodipodi:role=\"line\"\n         id=\"tspan3123-1-4-1-6-4\"\n         x=\"527.09454\"\n         y=\"540.36304\"\n         style=\"font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:6.00001px;font-family:sans-serif;-inkscape-font-specification:'sans-serif, Normal';font-variant-ligatures:normal;font-variant-caps:normal;font-variant-numeric:normal;font-variant-east-asian:normal;stroke-width:1\">[[a]]</tspan></text>\n    <text\n       xml:space=\"preserve\"\n       style=\"font-style:normal;font-weight:normal;font-size:40px;line-height:1.25;font-family:sans-serif;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;stroke-width:1\"\n       x=\"526.85919\"\n       y=\"529.62354\"\n       id=\"text3125-3-3-9-9-6\"><tspan\n\t     class = \"x\"\n         sodipodi:role=\"line\"\n         id=\"tspan3123-1-4-1-6-2\"\n         x=\"526.85919\"\n         y=\"529.62354\"\n         style=\"font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:6.00001px;font-family:sans-serif;-inkscape-font-specification:'sans-serif, Normal';font-variant-ligatures:normal;font-variant-caps:normal;font-variant-numeric:normal;font-variant-east-asian:normal;stroke-width:1\">[[x]]</tspan></text>\n    <text\n       xml:space=\"preserve\"\n       style=\"font-style:normal;font-weight:normal;font-size:40px;line-height:1.25;font-family:sans-serif;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;stroke-width:1\"\n       x=\"526.21417\"\n       y=\"506.18649\"\n       id=\"text3125-3-3-9-9-67\"><tspan\n\t     class = \"y\"\n         sodipodi:role=\"line\"\n         id=\"tspan3123-1-4-1-6-5\"\n         x=\"526.21417\"\n         y=\"506.18649\"\n         style=\"font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:6.00001px;font-family:sans-serif;-inkscape-font-specification:'sans-serif, Normal';font-variant-ligatures:normal;font-variant-caps:normal;font-variant-numeric:normal;font-variant-east-asian:normal;stroke-width:1\">[[y]]</tspan></text>\n\t<g cv-if = \"r1\" class = \"r1\">\n    <path\n       style=\"fill:none;stroke:#000000;stroke-width:1.55126;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n       d=\"M 656.93727,296.09185 821.8762,337.67559\"\n       id=\"path4466-5-6-4-6\"\n       sodipodi:nodetypes=\"cc\"\n       transform=\"matrix(0.32231801,0,0,0.32231801,260.60086,378.95899)\" />\n\t</g>\n    <text\n       xml:space=\"preserve\"\n       style=\"font-style:normal;font-weight:normal;font-size:124.101px;line-height:1.25;font-family:sans-serif;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;stroke-width:3.10253\"\n       x=\"824.07147\"\n       y=\"345.30997\"\n       id=\"text3125-3-3-9-9-67-9\"\n       transform=\"matrix(0.32231801,0,0,0.32231801,260.60086,378.95899)\"><tspan\n\t     class = \"r1\"\n         sodipodi:role=\"line\"\n         id=\"tspan3123-1-4-1-6-5-8\"\n         x=\"824.07147\"\n         y=\"345.30997\"\n         style=\"font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:18.6152px;font-family:sans-serif;-inkscape-font-specification:'sans-serif, Normal';font-variant-ligatures:normal;font-variant-caps:normal;font-variant-numeric:normal;font-variant-east-asian:normal;stroke-width:3.10253\">[[r1]]</tspan></text>\n\t<g cv-if = \"l1\" class = \"l1\">\n    <path\n       style=\"fill:none;stroke:#000000;stroke-width:1.55126;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n       d=\"M 98.337471,294.83145 -66.601455,336.41519\"\n       id=\"path4466-5-6-4-6-7\"\n       sodipodi:nodetypes=\"cc\"\n       transform=\"matrix(0.32231801,0,0,0.32231801,260.60086,378.95899)\" /></g>\n    <text\n       xml:space=\"preserve\"\n       style=\"font-style:normal;font-weight:normal;font-size:124.101px;line-height:1.25;font-family:sans-serif;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;stroke-width:3.10253\"\n       x=\"-147.9368\"\n       y=\"344.04959\"\n       id=\"text3125-3-3-9-9-67-9-2\"\n       transform=\"matrix(0.32231801,0,0,0.32231801,260.60086,378.95899)\"><tspan\n\t     class = \"l1\"\n         sodipodi:role=\"line\"\n         id=\"tspan3123-1-4-1-6-5-8-8\"\n         x=\"-147.9368\"\n         y=\"344.04959\"\n         style=\"font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:18.6152px;font-family:sans-serif;-inkscape-font-specification:'sans-serif, Normal';font-variant-ligatures:normal;font-variant-caps:normal;font-variant-numeric:normal;font-variant-east-asian:normal;stroke-width:3.10253\">[[l1]]</tspan></text>\n\t<g cv-if = \"dpad\">\n    <path\n       style=\"fill:none;stroke:#000000;stroke-width:1.55126;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n       d=\"M 195.45,507.2765 -65.76263,575.40558\"\n       id=\"path4466-5-6-4-6-7-2\"\n       sodipodi:nodetypes=\"cc\"\n       transform=\"matrix(0.32231801,0,0,0.32231801,260.60086,378.95899)\" />\n    <text\n       xml:space=\"preserve\"\n       style=\"font-style:normal;font-weight:normal;font-size:124.101px;line-height:1.25;font-family:sans-serif;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;stroke-width:3.10253\"\n       x=\"-122.35963\"\n       y=\"582.59192\"\n       id=\"text3125-3-3-9-9-67-9-2-9\"\n       transform=\"matrix(0.32231801,0,0,0.32231801,260.60086,378.95899)\"><tspan\n         sodipodi:role=\"line\"\n         id=\"tspan3123-1-4-1-6-5-8-8-9\"\n         x=\"-122.35963\"\n         y=\"582.59192\"\n         style=\"font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:18.6152px;font-family:sans-serif;-inkscape-font-specification:'sans-serif, Normal';font-variant-ligatures:normal;font-variant-caps:normal;font-variant-numeric:normal;font-variant-east-asian:normal;stroke-width:3.10253\">[[dpad]]</tspan></text></g>\n\t<g cv-if = \"start\">\n    <path\n       style=\"fill:none;stroke:#000000;stroke-width:1.55126;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n       d=\"M 455.73274,349.69679 V 192.16781\"\n       id=\"path3121\"\n       sodipodi:nodetypes=\"cc\"\n       transform=\"matrix(0.32231801,0,0,0.32231801,260.60086,378.95899)\" />\n    <text\n       xml:space=\"preserve\"\n       style=\"font-style:normal;font-weight:normal;font-size:124.101px;line-height:1.25;font-family:sans-serif;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;stroke-width:3.10253\"\n       x=\"427.94226\"\n       y=\"186.86783\"\n       id=\"text3125\"\n       transform=\"matrix(0.32231801,0,0,0.32231801,260.60086,378.95899)\"><tspan\n\t     class = \"start\"\n         sodipodi:role=\"line\"\n         id=\"tspan3123\"\n         x=\"427.94226\"\n         y=\"186.86783\"\n         style=\"font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:18.6152px;font-family:sans-serif;-inkscape-font-specification:'sans-serif, Normal';font-variant-ligatures:normal;font-variant-caps:normal;font-variant-numeric:normal;font-variant-east-asian:normal;stroke-width:3.10253\">[[start]]</tspan></text></g>\n\t<g cv-if = \"ra\" class = \"ra\">\n    <path\n       style=\"fill:none;stroke:#000000;stroke-width:1.55126;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n       d=\"M 542.19462,503.98223 821.8762,583.25165\"\n       id=\"path2959\"\n       sodipodi:nodetypes=\"cc\"\n       transform=\"matrix(0.32231801,0,0,0.32231801,260.60086,378.95899)\" /></g>\n    <text\n       xml:space=\"preserve\"\n       style=\"font-style:normal;font-weight:normal;font-size:124.101px;line-height:1.25;font-family:sans-serif;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;stroke-width:3.10253\"\n       x=\"832.28497\"\n       y=\"591.27563\"\n       id=\"text3125-3\"\n       transform=\"matrix(0.32231801,0,0,0.32231801,260.60086,378.95899)\"><tspan\n         sodipodi:role=\"line\"\n         id=\"tspan3123-1\"\n         x=\"832.28497\"\n         y=\"591.27563\"\n         style=\"font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:18.6152px;font-family:sans-serif;-inkscape-font-specification:'sans-serif, Normal';font-variant-ligatures:normal;font-variant-caps:normal;font-variant-numeric:normal;font-variant-east-asian:normal;stroke-width:3.10253\">[[ra]]</tspan></text>\n  </g>\n</svg>\n"
});

;require.register("debug/LineDump.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LineDump = void 0;
var _View2 = require("curvature/base/View");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let LineDump = /*#__PURE__*/function (_View) {
  _inherits(LineDump, _View);
  var _super = _createSuper(LineDump);
  function LineDump() {
    var _this;
    _classCallCheck(this, LineDump);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _defineProperty(_assertThisInitialized(_this), "template", `<div class = "line-dump" style = "--x:[[x]];--y:[[y]];--length:[[len]];--angle:[[angle]]">
		<div class = "line" style = "border-color:[[color]]"></div>
	</div>`);
    _this.args.x = _this.args.x || 0;
    _this.args.y = _this.args.y || 0;
    return _this;
  }
  return _createClass(LineDump);
}(_View2.View);
exports.LineDump = LineDump;
});

;require.register("debug/PointDump.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PointDump = void 0;
var _View2 = require("curvature/base/View");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let PointDump = /*#__PURE__*/function (_View) {
  _inherits(PointDump, _View);
  var _super = _createSuper(PointDump);
  function PointDump() {
    var _this;
    _classCallCheck(this, PointDump);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _defineProperty(_assertThisInitialized(_this), "template", `<div class = "point-dump">
		<div class = "point" style = "--color:[[color]]">[[x]], [[y]]</div>
	</div>`);
    _this.args.x = _this.args.x || 0;
    _this.args.y = _this.args.y || 0;
    return _this;
  }
  return _createClass(PointDump);
}(_View2.View);
exports.PointDump = PointDump;
});

;require.register("debug/arrow-east.svg", function(exports, require, module) {
module.exports = "<svg width=\"497.81px\" height=\"497.81px\" enable-background=\"new 0 0 497.812 497.812\" version=\"1.1\" viewBox=\"0 0 497.81 497.81\" xmlns=\"http://www.w3.org/2000/svg\">\n\t<g transform=\"matrix(-1 0 0 1 497.81 0)\">\n\t\t<path d=\"m203.66 312.91 117.03 117.03-67.906 67.875-248.91-248.91 248.91-248.91 67.906 67.875-117.06 117.06 290.28-0.031 0.031 127.97z\"/>\n\t</g>\n</svg>\n"
});

;require.register("effects/Cylinder.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Cylinder = void 0;
var _View2 = require("curvature/base/View");
var _Tag = require("curvature/base/Tag");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let Cylinder = /*#__PURE__*/function (_View) {
  _inherits(Cylinder, _View);
  var _super = _createSuper(Cylinder);
  function Cylinder(args, parent) {
    var _this;
    _classCallCheck(this, Cylinder);
    _this = _super.call(this, args, parent);
    _defineProperty(_assertThisInitialized(_this), "template", require('./twist.svg'));
    _this.args.scale = _this.args.scale || 0;
    _this.args.id = _this.args.id || 'cylinder';
    _this.args.width = _this.args.width || 64;
    _this.args.height = _this.args.height || 64;
    return _this;
  }
  _createClass(Cylinder, [{
    key: "onRendered",
    value: function onRendered() {
      const displacer = new _Tag.Tag(`<canvas width = "${this.args.width}" height = "${this.args.height}">`);
      const context = displacer.getContext('2d');
      context.imageSmoothingEnabled = false;
      const image = context.getImageData(0, 0, this.args.width, this.args.height);
      const pixels = image.data;
      for (let i = 0; i < pixels.length; i += 4) {
        var _r, _g, _b;
        let r,
          g,
          b,
          a,
          c,
          d = 0;
        const w = i / 4;
        const y = Math.floor(w / this.args.width);
        const x = w % this.args.width;
        const ox = x - this.args.width / 2;
        const oy = y - this.args.height / 2;
        const p = Math.hypot(ox, oy);
        const s = Math.min(this.args.width, this.args.height) / 2;
        c = Math.abs(ox / this.args.width) / 2;
        // d = p / s;

        r = 128 + ox * 4 * c;
        g = 128; // + (oy * 4) * d;
        b = 0;
        pixels[i + 0] = (_r = r) !== null && _r !== void 0 ? _r : 128;
        pixels[i + 1] = (_g = g) !== null && _g !== void 0 ? _g : 128;
        pixels[i + 2] = (_b = b) !== null && _b !== void 0 ? _b : 128;
        pixels[i + 3] = a !== null && a !== void 0 ? a : 255;
      }
      context.putImageData(image, 0, 0);
      displacer.toBlob(png => this.args.blob = URL.createObjectURL(png), 'image/png');
    }
  }, {
    key: "name",
    get: function get() {
      return `${this.args.id}`;
      // return `filter_${this.args.id}`;
    }
  }]);
  return Cylinder;
}(_View2.View);
exports.Cylinder = Cylinder;
});

;require.register("effects/Droop.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Droop = void 0;
var _View2 = require("curvature/base/View");
var _Tag = require("curvature/base/Tag");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let Droop = /*#__PURE__*/function (_View) {
  _inherits(Droop, _View);
  var _super = _createSuper(Droop);
  function Droop(args, parent) {
    var _this;
    _classCallCheck(this, Droop);
    _this = _super.call(this, args, parent);
    _defineProperty(_assertThisInitialized(_this), "template", require('./droop.svg'));
    _this.args.scale = _this.args.scale || 0;
    _this.args.id = _this.args.id || 'droop';
    _this.args.width = (args.width || 64) * 2;
    _this.args.height = args.height || 64;
    _this.args.intensity = 1.0;
    _this.args.droopWidth = '102%';
    return _this;
  }
  _createClass(Droop, [{
    key: "onRendered",
    value: function onRendered() {
      this.constructor.generateMap(this.args.width, this.args.height).then(image => {
        this.args.blob = image;
      });
    }
  }, {
    key: "name",
    get: function get() {
      return `${this.args.id}`;
      // return `filter_${this.args.id}`;
    }
  }], [{
    key: "generateMap",
    value: function generateMap(width, height) {
      const memoKey = `${width}::${height}`;
      const memoMap = this.memoMaps;
      if (memoMap.has(memoKey)) {
        return Promise.resolve(memoMap.get(memoKey));
      }
      const displacer = new _Tag.Tag(`<canvas width = "${width}" height = "${height}">`);
      const context = displacer.getContext('2d');
      context.imageSmoothingEnabled = false;
      const image = context.getImageData(0, 0, width, height);
      const pixels = image.data;
      for (let i = 0; i < pixels.length; i += 4) {
        var _r, _g, _b, _a;
        let r,
          g,
          b,
          a,
          c,
          d = 0;
        const w = i / 4;
        const y = Math.floor(w / width);
        const x = w % width;
        const ux = x / width;
        const uy = y / height;
        const input = -Math.PI + ux * Math.PI;
        r = 128;
        g = 128 + Math.round(128 * (Math.cos(input) * 0.5 + 0.5));
        b = 0;
        a = 255;
        pixels[i + 0] = (_r = r) !== null && _r !== void 0 ? _r : 128;
        pixels[i + 1] = (_g = g) !== null && _g !== void 0 ? _g : 128;
        pixels[i + 2] = (_b = b) !== null && _b !== void 0 ? _b : 128;
        pixels[i + 3] = (_a = a) !== null && _a !== void 0 ? _a : 255;
      }
      context.putImageData(image, 0, 0);
      return new Promise(accept => {
        displacer.toBlob(png => {
          const blob = URL.createObjectURL(png, 'image/png');
          memoMap.set(memoKey, blob);
          accept(blob);
        });
      });
    }
  }]);
  return Droop;
}(_View2.View);
exports.Droop = Droop;
_defineProperty(Droop, "memoMaps", new Map());
});

;require.register("effects/Pinch.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Pinch = void 0;
var _View2 = require("curvature/base/View");
var _Tag = require("curvature/base/Tag");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let Pinch = /*#__PURE__*/function (_View) {
  _inherits(Pinch, _View);
  var _super = _createSuper(Pinch);
  function Pinch(args, parent) {
    var _this;
    _classCallCheck(this, Pinch);
    _this = _super.call(this, args, parent);
    _defineProperty(_assertThisInitialized(_this), "template", require('./twist.svg'));
    _this.args.scale = _this.args.scale || 0;
    _this.args.id = _this.args.id || 'pinch';
    _this.args.width = _this.args.width || 64;
    _this.args.height = _this.args.height || 64;
    return _this;
  }
  _createClass(Pinch, [{
    key: "onRendered",
    value: function onRendered() {
      const displacer = new _Tag.Tag(`<canvas width = "${this.args.width}" height = "${this.args.height}">`);
      const context = displacer.getContext('2d');
      context.imageSmoothingEnabled = false;
      const image = context.getImageData(0, 0, this.args.width, this.args.height);
      const pixels = image.data;
      for (let i = 0; i < pixels.length; i += 4) {
        var _r, _g, _b;
        let r,
          g,
          b,
          a,
          c,
          d = 0;
        const w = i / 4;
        const y = Math.floor(w / this.args.width);
        const x = w % this.args.width;
        const ox = x - this.args.width / 2;
        const oy = y - this.args.height / 2;
        const p = Math.hypot(ox, oy);
        const ss = Math.min(this.args.width, this.args.height);
        const s = ss / 2;
        if (p < s) {
          c = Math.pow(1 - p / s, 2);
          d = Math.pow(1 - p / s, 2);
        } else {
          c = 0;
          d = 0;
        }
        r = 128 + ox * 4 * c;
        g = 128 + oy * 4 * d;
        b = 0;
        pixels[i + 0] = (_r = r) !== null && _r !== void 0 ? _r : 128;
        pixels[i + 1] = (_g = g) !== null && _g !== void 0 ? _g : 128;
        pixels[i + 2] = (_b = b) !== null && _b !== void 0 ? _b : 128;
        pixels[i + 3] = a !== null && a !== void 0 ? a : 255;
      }
      context.putImageData(image, 0, 0);
      displacer.toBlob(png => this.args.blob = URL.createObjectURL(png), 'image/png');
    }
  }, {
    key: "name",
    get: function get() {
      return `${this.args.id}`;
      // return `filter_${this.args.id}`;
    }
  }]);
  return Pinch;
}(_View2.View);
exports.Pinch = Pinch;
});

;require.register("effects/ScreenFire.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ScreenFire = void 0;
var _View2 = require("curvature/base/View");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let ScreenFire = /*#__PURE__*/function (_View) {
  _inherits(ScreenFire, _View);
  var _super = _createSuper(ScreenFire);
  function ScreenFire() {
    var _this;
    _classCallCheck(this, ScreenFire);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _defineProperty(_assertThisInitialized(_this), "template", require('./screen-fire'));
    return _this;
  }
  _createClass(ScreenFire, [{
    key: "onAttach",
    value: function onAttach(event) {
      this.args.animation = 'playing';
    }
  }]);
  return ScreenFire;
}(_View2.View);
exports.ScreenFire = ScreenFire;
});

;require.register("effects/ScreenWarp.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ScreenWarp = void 0;
var _View2 = require("curvature/base/View");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let ScreenWarp = /*#__PURE__*/function (_View) {
  _inherits(ScreenWarp, _View);
  var _super = _createSuper(ScreenWarp);
  function ScreenWarp() {
    var _this;
    _classCallCheck(this, ScreenWarp);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _defineProperty(_assertThisInitialized(_this), "template", require('./screen-fire'));
    return _this;
  }
  _createClass(ScreenWarp, [{
    key: "onAttach",
    value: function onAttach(event) {
      this.args.animation = 'playing';
      this.onTimeout(5000, () => this.remove());
    }
  }]);
  return ScreenWarp;
}(_View2.View);
exports.ScreenWarp = ScreenWarp;
});

;require.register("effects/Twist.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Twist = void 0;
var _View2 = require("curvature/base/View");
var _Tag = require("curvature/base/Tag");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let Twist = /*#__PURE__*/function (_View) {
  _inherits(Twist, _View);
  var _super = _createSuper(Twist);
  function Twist(args, parent) {
    var _this;
    _classCallCheck(this, Twist);
    _this = _super.call(this, args, parent);
    _defineProperty(_assertThisInitialized(_this), "template", require('./twist.svg'));
    _this.args.scale = _this.args.scale || 0;
    _this.args.id = _this.args.id || 'twist';
    _this.args.width = _this.args.width || 64;
    _this.args.height = _this.args.height || 64;
    _this.args.dx = 0;
    _this.args.dy = 0;
    return _this;
  }
  _createClass(Twist, [{
    key: "onRendered",
    value: function onRendered() {
      const displacer = new _Tag.Tag('<canvas width = "64" height = "64">');
      const context = displacer.getContext('2d');
      context.imageSmoothingEnabled = false;
      const image = context.getImageData(0, 0, 64, 64);
      const pixels = image.data;
      for (let i = 0; i < pixels.length; i += 4) {
        var _r, _g;
        let r,
          g,
          b,
          a,
          c = 1;
        const w = i / 4;
        const y = Math.floor(w / 64);
        const x = w % 64;
        const ox = x - 31.5;
        const oy = y - 31.5;
        const p = Math.hypot(ox, oy);
        if (p > 32) {
          c = 0;
        } else {
          c = Math.pow(1 - p / 32, 3);
        }
        r = 128 + oy * 4 * c;
        g = 128 - ox * 4 * c;
        pixels[i + 0] = (_r = r) !== null && _r !== void 0 ? _r : 0;
        pixels[i + 1] = (_g = g) !== null && _g !== void 0 ? _g : 0;
        pixels[i + 2] = b !== null && b !== void 0 ? b : 0;
        pixels[i + 3] = a !== null && a !== void 0 ? a : 255;
      }
      context.putImageData(image, 0, 0);
      displacer.toBlob(png => this.args.blob = URL.createObjectURL(png), 'image/png');
    }
  }, {
    key: "name",
    get: function get() {
      return `${this.args.id}`;
      // return `filter_${this.args.id}`;
    }
  }]);
  return Twist;
}(_View2.View);
exports.Twist = Twist;
});

;require.register("effects/droop.svg", function(exports, require, module) {
module.exports = "<svg\n\twidth  =\"100%\"\n\theight =\"100%\"\n>\n\t<defs>\n\n\t\t<filter\n\t\t\tcv-ref = \"filter\"\n\t\t\tcolor-interpolation-filters=\"sRGB\"\n\t\t\tid = \"[[id]]\"\n\t\t\twidth  =\"102%\"\n\t\t\theight =\"1204%\"\n\t\t\tx  = \"-1%\"\n\t\t\ty  = \"-2%\"\n\n\t\t>\n\t\t\t<feImage\n\t\t\t\tpreserveAspectRatio = \"none\"\n\t\t\t\tresult  = \"DisplacementSourceLeft\"\n\t\t\t\tcv-attr = \"width:droopWidthLeft,href:blob\"\n\t\t\t/>\n\n\t\t\t<feImage\n\t\t\t\tpreserveAspectRatio = \"none\"\n\t\t\t\tresult  = \"DisplacementSourceRightInvert\"\n\t\t\t\tcv-attr = \"x:droopRightStart,width:droopWidthRight,href:blob\"\n\t\t\t/>\n\n\t\t\t<feColorMatrix\n\t\t\t\tin     = \"DisplacementSourceRightInvert\"\n\t\t\t\tresult = \"DisplacementSourceRight\"\n\t\t\t\ttype   = \"matrix\"\n\t\t\t\tvalues=\"\n\t\t\t\t\t1 0 0 0 0\n\t\t\t\t\t0 -1 0 0 1.5\n\t\t\t\t\t0 0 1 0 0\n\t\t\t\t\t0 0 0 1 0\"\n\t\t\t/>\n\n\t\t\t<feComposite\n\t\t\t\toperator=\"over\"\n\t\t\t\tin     = \"DisplacementSourceLeft\"\n\t\t\t\tin2    = \"DisplacementSourceRight\"\n\t\t\t\tresult = \"DisplacementSource\"\n\t\t\t\twidth  =\"102%\"\n\t\t\t/>\n\n\t\t\t<feFlood flood-color=\"#808000\" result = \"OffsetNeutral\" />\n\n\t\t\t<feComposite\n\t\t\t\toperator=\"over\"\n\t\t\t\tin     = \"DisplacementSource\"\n\t\t\t\tin2    = \"OffsetNeutral\"\n\t\t\t\tresult = \"DisplacementResult\"\n\t\t\t\twidth  =\"102%\"\n\t\t\t/>\n\n\t\t\t<feComposite\n\t\t\t\toperator=\"over\"\n\t\t\t\tin     = \"DisplacementSource\"\n\t\t\t\tin2    = \"OffsetNeutral\"\n\t\t\t\tresult = \"DisplacementResult\"\n\t\t\t\twidth  =\"102%\"\n\t\t\t/>\n\n\t\t\t<feDisplacementMap\n\t\t\t\txChannelSelector = \"R\"\n\t\t\t\tyChannelSelector = \"G\"\n\t\t\t\tin      = \"SourceGraphic\"\n\t\t\t\tin2     = \"DisplacementResult\"\n\t\t\t\tcv-ref  = \"displace\"\n\t\t\t\tcv-attr = \"scale:scale\"\n\t\t\t\twidth  =\"102%\"\n\t\t\t/>\n\n\t\t</filter>\n\n\t</defs>\n</svg>\n"
});

;require.register("effects/screen-fire.html", function(exports, require, module) {
module.exports = "<div class = \"screen-fire [[animation]]\">\n\t<div class = \"fire-strip\" style = \"--index:0\"><div></div></div>\n\t<div class = \"fire-strip\" style = \"--index:1\"><div></div></div>\n\t<div class = \"fire-strip\" style = \"--index:2\"><div></div></div>\n\t<div class = \"fire-strip\" style = \"--index:3\"><div></div></div>\n\t<div class = \"fire-strip\" style = \"--index:4\"><div></div></div>\n\t<div class = \"fire-strip\" style = \"--index:5\"><div></div></div>\n\t<div class = \"fire-strip\" style = \"--index:6\"><div></div></div>\n\t<div class = \"fire-strip\" style = \"--index:7\"><div></div></div>\n\t<div class = \"fire-strip\" style = \"--index:8\"><div></div></div>\n\t<div class = \"fire-strip\" style = \"--index:9\"><div></div></div>\n\t<div class = \"fire-strip\" style = \"--index:10\"><div></div></div>\n\t<div class = \"fire-strip\" style = \"--index:11\"><div></div></div>\n\t<div class = \"fire-strip\" style = \"--index:12\"><div></div></div>\n\t<div class = \"fire-strip\" style = \"--index:13\"><div></div></div>\n\t<div class = \"fire-strip\" style = \"--index:14\"><div></div></div>\n\t<div class = \"fire-strip\" style = \"--index:15\"><div></div></div>\n\t<div class = \"fire-strip\" style = \"--index:16\"><div></div></div>\n</div>\n"
});

;require.register("effects/twist.svg", function(exports, require, module) {
module.exports = "<svg\n\theight =\"100%\"\n\twidth  =\"100%\"\n>\n\t<defs>\n\n\t\t<filter\n\t\t\tcv-ref = \"filter\"\n\t\t\tcolor-interpolation-filters=\"sRGB\"\n\t\t\theight = \"100%\"\n\t\t\twidth  = \"100%\"\n\t\t\tid     = \"[[id]]\"\n\t\t\tx      = \"0%\"\n\t\t\ty      = \"0%\"\n\n\t\t>\n\t\t\t<feFlood\n\t\t\t\tflood-color=\"#808000\"\n\t\t\t\theight = \"100%\"\n\t\t\t\twidth  = \"100%\"\n\t\t\t\tresult = \"OffsetNeutral\"\n\t\t\t\tx=\"0\"\n\t\t\t\ty=\"0\"\n\t\t\t/>\n\n\t\t\t<feImage\n\t\t\t\txlink:href=\"[[blob]]\"\n\t\t\t\tresult = \"DisplacementSource\"\n\t\t\t\theight = \"100%\"\n\t\t\t\twidth  = \"100%\"\n\t\t\t/>\n\n\t\t\t<feOffset\n\t\t\t\tin      = \"DisplacementSource\"\n\t\t\t\tresult  = \"OffsetSource\"\n\t\t\t\tcv-attr =  \"dx:dx,dy:dy\"\n\t\t\t/>\n\n\t\t\t<feComposite\n\t\t\t\toperator=\"over\"\n\t\t\t\tin2    = \"OffsetNeutral\"\n\t\t\t\tin     = \"OffsetSource\"\n\t\t\t\tresult = \"DisplacementResult\"\n\t\t\t/>\n\n\t\t\t<feDisplacementMap\n\t\t\t\txChannelSelector = \"R\"\n\t\t\t\tyChannelSelector = \"G\"\n\t\t\t\tin      = \"SourceGraphic\"\n\t\t\t\tin2     = \"DisplacementResult\"\n\t\t\t\tcv-ref  = \"displace\"\n\t\t\t\tcv-attr = \"scale:scale\"\n\t\t\t/>\n\n\t\t</filter>\n\n\t</defs>\n</svg>\n"
});

;require.register("initialize.js", function(exports, require, module) {
"use strict";

var _Bgm = require("./audio/Bgm");
var _Sfx = require("./audio/Sfx");
var _Viewport = require("./viewport/Viewport");
var _Tag = require("curvature/base/Tag");
var _TileMap = require("./tileMap/TileMap");
var _Matrix = require("matrix-api/Matrix");
if (location.pathname === '/accept-sso') {
  const baseUrl = 'https://matrix.org/_matrix';
  const matrix = new _Matrix.Matrix(baseUrl);

  // Get the loginToken from the query string.
  const query = new URLSearchParams(location.search);
  const token = query.get('loginToken');

  // Complete the SSO and close the window.
  matrix.completeSso(token);
} else {
  const viewportA = new _Viewport.Viewport();
  document.addEventListener('DOMContentLoaded', function () {
    const getFPS = () => new Promise(accept => requestAnimationFrame(t1 => requestAnimationFrame(t2 => accept(1000 / (t2 - t1)))));
    console.log('Starting...');
    if (navigator.serviceWorker) {
      navigator.serviceWorker.register('/worker-cache.js');
    }
    let lastTime = 0;
    const frameTimes = [];
    const update = now => {
      const frameTime = now - lastTime;
      const frameAgeMin = 1000 / (viewportA.args.maxFps || 61);
      if (frameTime < frameAgeMin) {
        requestAnimationFrame(update);
        return;
      }
      viewportA.update();
      viewportA.args.fps = 1000 / frameTime;
      lastTime = now;
      requestAnimationFrame(update);
    };
    viewportA.render(document.body);
    update();
  });

  /*** BGM ***/

  _Bgm.Bgm.register('STAR_SHIELD', '/audio/leslie-wai/feel-the-sunshine.mp3');
  _Bgm.Bgm.register('RADICAL_CITY', '/audio/colbreakz/848482_ColBreakz---My-Universe.mp3');
  _Bgm.Bgm.register('WEST_SIDE', '/audio/akselmcbossmcgee123/1066486_Blammed-By-Pico.mp3');
  _Bgm.Bgm.register('UNDERGROUND_ZONE', '/audio/tee-lopes/under-ground-zone-remix.mp3');
  _Bgm.Bgm.register('MISTY_RUINS', 'audio/neil-voss/extol.mp3');
  _Bgm.Bgm.register('MANIC_HARBOR', '/audio/bobenshibobsled/1024371_Curse-Ska-Version.mp3');
  _Bgm.Bgm.register('TITLE_THEME', '/Sonic/carnival-night-zone-act-2-beta.mp3');
  _Bgm.Bgm.register('MENU_THEME', '/Sonic/s3k-competition.mp3');
  _Bgm.Bgm.register('TUTORIAL_THEME', '/audio/teravex/1083419_Lowbeat.mp3');
  _Bgm.Bgm.register('CITY_ESCAPE', '/audio/senoue-jun/city-escape.mp3');
  _Bgm.Bgm.register('AGORAPOLIS', '/audio/AetheR/1063556_Forest.mp3');
  _Bgm.Bgm.register('ACT-BOSS', '/audio/F-777/Double-Cross.mp3');
  _Bgm.Bgm.register('ZONE-BOSS', '/audio/dex-arson/rampage.mp3');
  _Bgm.Bgm.register('ACT_CLEAR', '/audio/gta-sa/mission-passed.mp3', {
    volume: 1
  });
  _Bgm.Bgm.register('NO_WAY', '/audio/sonic/no-way.mp3');

  /*** SFX ***/

  _Sfx.Sfx.register('WTF_BOOM', '/audio/meme/wtf-boom.mp3');
  _Sfx.Sfx.register('PLAYER_DAMAGED', '/Sonic/S3K_35.wav');
  _Sfx.Sfx.register('RINGS_SCATTERED', '/Sonic/ring-loss.wav', {
    maxConcurrent: 3,
    volume: 0.75,
    fudgeFactor: 0
  });
  _Sfx.Sfx.register('BUMPER_BOUNCE', '/Sonic/S3K_AA.wav');
  _Sfx.Sfx.register('BOOST_RING', '/Sonic/S3K_CA.wav', {
    maxConcurrent: 1,
    volume: 0.75,
    fudgeFactor: 0.2
  });
  _Sfx.Sfx.register('RING_COLLECTED', '/Sonic/ring-collect.wav', {
    maxConcurrent: 3,
    volume: 0.25,
    fudgeFactor: 0.1
  });
  _Sfx.Sfx.register('SPIKE_DAMAGE', '/Sonic/S2_26.wav', {
    maxConcurrent: 1,
    volume: 0.5,
    fudgeFactor: 0.1
  });
  _Sfx.Sfx.register('EMBLEM_COLLECTED', '/custom/emblem-collect.wav', {
    maxConcurrent: 3,
    volume: 0.25,
    fudgeFactor: 0.1
  });
  _Sfx.Sfx.register('EMERALD_COLLECTED', '/Sonic/S3K_9C.wav');
  _Sfx.Sfx.register('OBJECT_DESTROYED', '/Sonic/object-destroyed.wav', {
    maxConcurrent: 8,
    volume: 0.75,
    fudgeFactor: 0.3
  });
  _Sfx.Sfx.register('BOX_DESTROYED', '/Sonic/S3K_B4.wav', {
    maxConcurrent: 4,
    volume: 1,
    fudgeFactor: 0,
    startTime: 0.0
  });
  _Sfx.Sfx.register('BLOCK_DESTROYED', '/Sonic/0A3H.wav', {
    maxConcurrent: 4,
    volume: 1,
    fudgeFactor: 0,
    startTime: 0.2
  });
  _Sfx.Sfx.register('WORM_BLOCK_DESTROYED', '/Sonic/0A3H.wav', {
    maxConcurrent: 4,
    volume: 0.8,
    fudgeFactor: 0.2,
    startTime: 0.2
  });
  _Sfx.Sfx.register('ROCKS_DESTROYED', '/Sonic/rock-smash.wav');
  _Sfx.Sfx.register('ROCK_BREAK_1', '/Sonic/S1_B9.wav', {
    maxConcurrent: 1,
    volume: 0.75,
    fudgeFactor: 0.3
  });
  _Sfx.Sfx.register('ROCK_BREAK_2', '/Sonic/S1_CB.wav', {
    maxConcurrent: 1,
    volume: 0.50,
    fudgeFactor: 0.1
  });
  _Sfx.Sfx.register('SPEEDPAD_HIT', '/Sonic/S2_2B.wav', {
    maxConcurrent: 3,
    volume: 0.75,
    fudgeFactor: 0.1
  });
  _Sfx.Sfx.register('HALLBOOSTER_HIT', '/Sonic/S3K_74.wav', {
    maxConcurrent: 1,
    volume: 0.75,
    fudgeFactor: 0.1
  });
  _Sfx.Sfx.register('SPRING_HIT', '/Sonic/spring-activated.wav', {
    maxConcurrent: 2,
    volume: 0.5,
    fudgeFactor: 0.1
  });
  _Sfx.Sfx.register('NOTCH_SPRING_HIT', '/Sonic/S3K_7B.wav', {
    maxConcurrent: 1,
    volume: 0.5,
    fudgeFactor: 0.2
  });
  _Sfx.Sfx.register('SWITCH_HIT', '/Sonic/switch-activated.wav', {
    maxConcurrent: 3,
    volume: 0.3,
    fudgeFactor: 0.2
  });
  _Sfx.Sfx.register('ALT_BEEP', '/Sonic/S2_28.wav', {
    maxConcurrent: 8,
    volume: 0.5,
    fudgeFactor: 0.2
  });
  _Sfx.Sfx.register('KNOCK_PLATFORM', '/Sonic/S2_57.wav', {
    maxConcurrent: 3,
    volume: 0.8,
    fudgeFactor: 0.2
  });
  _Sfx.Sfx.register('STAR_TWINKLE', '/Sonic/S2_27.wav', {
    maxConcurrent: 3,
    volume: 0.8,
    fudgeFactor: 0.2
  });
  _Sfx.Sfx.register('PAD_BOUNCE', '/Sonic/S2_58.wav', {
    maxConcurrent: 3,
    volume: 0.8,
    fudgeFactor: 0.2
  });
  _Sfx.Sfx.register('SPRING_SHOT', '/Sonic/S2_62.wav', {
    maxConcurrent: 3,
    volume: 0.8,
    fudgeFactor: 0.2
  });
  _Sfx.Sfx.register('QUICK_SLIDE', '/Sonic/S2_5B.wav', {
    maxConcurrent: 1,
    volume: 0.3,
    fudgeFactor: 0.2
  });
  _Sfx.Sfx.register('SS_BWIP', '/Sonic/S1_A9.wav', {
    maxConcurrent: 1,
    volume: 0.7,
    fudgeFactor: 0.2
  });
  _Sfx.Sfx.register('SS_BWIP_HIGH', '/Sonic/S2_29.wav', {
    maxConcurrent: 8,
    volume: 0.85,
    fudgeFactor: 0.2
  });
  _Sfx.Sfx.register('WAIT_TONE', '/Sonic/S3K_A7.wav', {
    maxConcurrent: 8,
    volume: 0.5,
    fudgeFactor: 0.2
  });
  _Sfx.Sfx.register('READY_TONE', '/Sonic/S3K_AD.wav', {
    maxConcurrent: 8,
    volume: 0.5,
    fudgeFactor: 0.2
  });
  _Sfx.Sfx.register('STARPOST_HIT', '/Sonic/starpost-active.wav', {
    volume: 0.5
  });
  _Sfx.Sfx.register('SHOT_FIRED', '/Sonic/shot-fired.wav', {
    volume: 0.5
  });
  _Sfx.Sfx.register('THRUSTER_FIRED', '/Sonic/mecha-sonic-thruster.wav');
  _Sfx.Sfx.register('BOSS_DAMAGED', '/Sonic/S3K_6E.wav');
  _Sfx.Sfx.register('BOSS_DUDHIT', '/Sonic/S2_59.wav');
  _Sfx.Sfx.register('FAIL', '/Sonic/S2_6D.wav');
  _Sfx.Sfx.register('HEAVY_THUD', '/Sonic/S3K_96.wav', {
    maxConcurrent: 3,
    volume: 1,
    fudgeFactor: 0.2,
    startTime: 0.00
  });
  _Sfx.Sfx.register('WOOD_THUD', '/Sonic/S3K_5F_smoother.wav', {
    maxConcurrent: 3,
    volume: 1,
    fudgeFactor: 0.2,
    startTime: 0.04
  });
  _Sfx.Sfx.register('WATER_ACQUIRE', '/Sonic/S3K_3F.wav', {
    volume: 0.75,
    fudgeFactor: 0.1
  });
  _Sfx.Sfx.register('WATER_BOUNCE', '/Sonic/S3K_44.wav', {
    volume: 0.5,
    fudgeFactor: 0.1
  });
  _Sfx.Sfx.register('ELECTRIC_ACQUIRE', '/Sonic/S3K_41.wav', {
    volume: 0.75,
    fudgeFactor: 0.1
  });
  _Sfx.Sfx.register('ELECTRIC_JUMP', '/Sonic/S3K_45.wav', {
    maxConcurrent: 3,
    volume: 0.5,
    fudgeFactor: 0.1
  });
  _Sfx.Sfx.register('FIRE_ACQUIRE', '/Sonic/S3K_3E.wav', {
    volume: 0.75,
    fudgeFactor: 0.1
  });
  _Sfx.Sfx.register('FIRE_DASH', '/Sonic/S3K_43.wav', {
    volume: 0.5,
    fudgeFactor: 0.1
  });
  _Sfx.Sfx.register('CHOPPER_DRONE', '/Sonic/drill-car-copter.wav');
  _Sfx.Sfx.register('CHOPPER_GUN', '/Sonic/010.Synth_MLT_se_ac_bf_ricochet.wav', {
    maxConcurrent: 4,
    volume: 0.5,
    fudgeFactor: 0.25
  });
  _Sfx.Sfx.register('MECHASONIC_TAKEOFF', '/Sonic/mecha-sonic-takeoff.wav');
  _Sfx.Sfx.register('MECHASONIC_SCRAPE', '/Sonic/mecha-sonic-scrape.wav');
  _Sfx.Sfx.register('MECHASONIC_SLAP', '/Sonic/mecha-sonic-thruster-close.wav');
  _Sfx.Sfx.register('TAILS_FLY', '/Sonic/tails-flying.wav');
  _Sfx.Sfx.register('DOOT_DOOT', '/audio/meme/doot-doot.mp3');
  _Sfx.Sfx.register('HOOK_GRABBED', '/Sonic/S3K_4A.wav');
  // Sfx.register('ROCKET_THRUST', '/Sonic/S3K_47.wav');

  _Sfx.Sfx.register('LIGTNING_STRIKE', '/Sonic/S3K_4E.wav', {
    maxConcurrent: 1,
    volume: 1,
    fudgeFactor: 0
  });
  _Sfx.Sfx.register('SECRET_FOUND', '/doom/dssecret.wav');
  _Sfx.Sfx.register('SICK_TRICK', '/Sonic/S2_6C.wav', {
    volume: 1,
    fudgeFactor: 0,
    maxConcurrent: 6
  });
  _Sfx.Sfx.register('GRINDING', '/Sonic/S3K_DB_sus.wav');
  _Sfx.Sfx.register('SPIKES_OUT', '/Sonic/S3K_A6.wav');
  _Sfx.Sfx.register('SPIKES_IN', '/Sonic/S3K_52.wav');
  _Sfx.Sfx.register('LID_POP', '/Sonic/S2_54.wav', {
    maxConcurrent: 1,
    volume: 0.5,
    fudgeFactor: 0.25
  });
  _Sfx.Sfx.register('PROP_PLAT', '/Sonic/S3K_PropPlat.wav', {
    maxConcurrent: 1,
    volume: 0.5,
    fudgeFactor: 0.25
  });
  _Sfx.Sfx.register('POGO_BOUNCE', '/Sonic/0A8H.wav', {
    maxConcurrent: 3,
    volume: 0.5,
    fudgeFactor: 0.25
  });
  _Sfx.Sfx.register('COPTER_SPIN', '/Sonic/drill-car-copter.wav', {
    maxConcurrent: 1,
    volume: 0.5,
    fudgeFactor: 0
  });
  _Sfx.Sfx.register('TOTAL_SCORE', '/Sonic/S3K_B0.wav', {
    maxConcurrent: 1,
    volume: 1,
    fudgeFactor: 0
  });
  _Sfx.Sfx.register('TALLY_SCORE', '/Sonic/B00_00_05.WAV', {
    maxConcurrent: 1,
    volume: 0.5,
    fudgeFactor: 0
  });
  _Sfx.Sfx.register('TALLY_SCORE', '/Sonic/027.Synth_MLT_menu_score menu text appear.wav', {
    maxConcurrent: 1,
    volume: 0.5,
    fudgeFactor: 0
  });
  _Sfx.Sfx.register('RADIO_CHATTER_1', '/thps2/CD_00171.wav', {
    maxConcurrent: 1,
    volume: 1,
    fudgeFactor: 0
  });
  _Sfx.Sfx.register('BARREL_EXPLODE', '/audio/doom/DSBAREXP.wav', {
    maxConcurrent: 1,
    volume: 1,
    fudgeFactor: 0
  });
}
});

;require.register("intro/BootCard.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BootCard = void 0;
var _Card2 = require("./Card");
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let BootCard = /*#__PURE__*/function (_Card) {
  _inherits(BootCard, _Card);
  var _super = _createSuper(BootCard);
  function BootCard(args, parent) {
    var _this;
    _classCallCheck(this, BootCard);
    _this = _super.call(this, args, parent);
    _this.args.cardName = 'boot-card';
    _this.args.text = `PRODUCED BY
SEAN MORRIS UNDER
THE APACHE 2.0 LICENSE`;
    return _this;
  }
  return _createClass(BootCard);
}(_Card2.Card);
exports.BootCard = BootCard;
});

;require.register("intro/Card.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Card = void 0;
var _View2 = require("curvature/base/View");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let Card = /*#__PURE__*/function (_View) {
  _inherits(Card, _View);
  var _super = _createSuper(Card);
  function Card() {
    var _this;
    let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let parent = arguments.length > 1 ? arguments[1] : undefined;
    _classCallCheck(this, Card);
    _this = _super.call(this, args, parent);
    _defineProperty(_assertThisInitialized(_this), "template", require('./card.html'));
    args.text = args.text || 'this is an intro card.';
    _this.args.timeout = _this.args.timeout || 1000;
    _this.args.animation = 'opening';
    _this.done = new Promise(accept => _this.accept = accept);
    return _this;
  }
  _createClass(Card, [{
    key: "play",
    value: function play(event) {
      this.onTimeout(50, () => this.args.animation = 'opened');
      const waitFor = this.args.waitFor || Promise.resolve();
      return new Promise(accept => {
        waitFor.then(() => {
          const timeAcc = this.args.timeout;
          if (timeAcc > 0) {
            this.onTimeout(timeAcc - 500, () => this.args.animation = 'closing');
            this.onTimeout(timeAcc, () => {
              this.args.animation = 'closed';
              const done = new Promise(acceptDone => this.onTimeout(timeAcc, acceptDone));
              accept(this.accept([done]));
            });
          }
        });
      });
    }
  }]);
  return Card;
}(_View2.View);
exports.Card = Card;
});

;require.register("intro/DebianCard.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DebianCard = void 0;
var _SkippableCard2 = require("./SkippableCard");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let DebianCard = /*#__PURE__*/function (_SkippableCard) {
  _inherits(DebianCard, _SkippableCard);
  var _super = _createSuper(DebianCard);
  function DebianCard(args, parent) {
    var _this;
    _classCallCheck(this, DebianCard);
    _this = _super.call(this, args, parent);
    _defineProperty(_assertThisInitialized(_this), "template", require('./debian-card.html'));
    _this.args.cardName = 'debian-card';
    _this.args.text = ``;
    return _this;
  }
  return _createClass(DebianCard);
}(_SkippableCard2.SkippableCard);
exports.DebianCard = DebianCard;
});

;require.register("intro/GamepadCard.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GamepadCard = void 0;
var _SkippableCard2 = require("./SkippableCard");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let GamepadCard = /*#__PURE__*/function (_SkippableCard) {
  _inherits(GamepadCard, _SkippableCard);
  var _super = _createSuper(GamepadCard);
  function GamepadCard(args, parent) {
    var _this;
    _classCallCheck(this, GamepadCard);
    _this = _super.call(this, args, parent);
    _defineProperty(_assertThisInitialized(_this), "template", require('./gamepad-card.html'));
    _this.args.timeout = 2500;
    _this.args.cardName = 'gamepad-card';
    _this.args.text = ``;
    return _this;
  }
  return _createClass(GamepadCard);
}(_SkippableCard2.SkippableCard);
exports.GamepadCard = GamepadCard;
});

;require.register("intro/LoadingCard.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LoadingCard = void 0;
var _Card2 = require("./Card");
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let LoadingCard = /*#__PURE__*/function (_Card) {
  _inherits(LoadingCard, _Card);
  var _super = _createSuper(LoadingCard);
  function LoadingCard(args, parent) {
    var _this;
    _classCallCheck(this, LoadingCard);
    _this = _super.call(this, args, parent);
    _this.args.cardName = 'loading-card';
    return _this;
  }
  return _createClass(LoadingCard);
}(_Card2.Card);
exports.LoadingCard = LoadingCard;
});

;require.register("intro/LogoSplash.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LogoSplash = void 0;
var _View2 = require("curvature/base/View");
var _Sfx = require("../audio/Sfx");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let LogoSplash = /*#__PURE__*/function (_View) {
  _inherits(LogoSplash, _View);
  var _super = _createSuper(LogoSplash);
  function LogoSplash() {
    var _this;
    let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let parent = arguments.length > 1 ? arguments[1] : undefined;
    _classCallCheck(this, LogoSplash);
    _this = _super.call(this, args, parent);
    _this.template = `
		<div class = "player-waving"></div>
		<div class = "splash [[animation]]" style = "
			pointer-events: [[pointerEvents]]
		">
			<div class = "center">SEAN<span class = "min">MORRIS</span><div class = "sm">SM</div></div>
			<div class = "center">SEAN<span class = "min">MORRIS</span><div class = "sm">SM</div></div>
			<div class = "center">SEAN<span class = "min">MORRIS</span><div class = "sm">SM</div></div>
		</div>`;
    return _this;
  }
  _createClass(LogoSplash, [{
    key: "onAttached",
    value: function onAttached() {
      if (this.alreadyAttached) {
        return;
      }
      this.alreadyAttached = true;
      this.args.left = 0;
      this.args.right = 0;
      this.args.fade = 1;
      this.args.frame = 0;
      this.args.fullFade = 1;
      this.args.pointerEvents = 'all';
      this.args.animation = 'hide';
      this.onTimeout(500, () => this.args.animation = 'slide');
      this.onTimeout(1250, () => this.args.animation = 'show');
      this.onTimeout(5000, () => this.args.animation = 'done');
      this.onTimeout(1250, () => _Sfx.Sfx.play('RING_COLLECTED'));
    }
  }]);
  return LogoSplash;
}(_View2.View);
exports.LogoSplash = LogoSplash;
});

;require.register("intro/NoWayCard.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NoWayCard = void 0;
var _Card2 = require("./Card");
var _Bgm = require("../audio/Bgm");
var _CharacterString = require("../ui/CharacterString");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let NoWayCard = /*#__PURE__*/function (_Card) {
  _inherits(NoWayCard, _Card);
  var _super = _createSuper(NoWayCard);
  function NoWayCard(args, parent) {
    var _this;
    _classCallCheck(this, NoWayCard);
    _this = _super.call(this, args, parent);
    _defineProperty(_assertThisInitialized(_this), "template", require('./no-way.html'));
    _this.args.cardName = 'no-way-card';
    _this.args.text = new _CharacterString.CharacterString({
      value: 'Error: ' + _this.args.errorString
    });
    _this.args.backdrop = '...';
    return _this;
  }
  _createClass(NoWayCard, [{
    key: "onAttached",
    value: function onAttached() {
      _Bgm.Bgm.play('NO_WAY', {
        loop: true
      });
    }
  }]);
  return NoWayCard;
}(_Card2.Card);
exports.NoWayCard = NoWayCard;
});

;require.register("intro/SaneCard.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SaneCard = void 0;
var _SkippableCard2 = require("./SkippableCard");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let SaneCard = /*#__PURE__*/function (_SkippableCard) {
  _inherits(SaneCard, _SkippableCard);
  var _super = _createSuper(SaneCard);
  function SaneCard(args, parent) {
    var _this;
    _classCallCheck(this, SaneCard);
    _this = _super.call(this, args, parent);
    _defineProperty(_assertThisInitialized(_this), "template", require('./sane-card.html'));
    _this.args.cardName = 'sane-card';
    _this.args.text = ``;
    return _this;
  }
  return _createClass(SaneCard);
}(_SkippableCard2.SkippableCard);
exports.SaneCard = SaneCard;
});

;require.register("intro/SeanCard.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SeanCard = void 0;
var _Card2 = require("./Card");
var _LogoSplash = require("./LogoSplash");
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let SeanCard = /*#__PURE__*/function (_Card) {
  _inherits(SeanCard, _Card);
  var _super = _createSuper(SeanCard);
  function SeanCard(args, parent) {
    var _this;
    _classCallCheck(this, SeanCard);
    _this = _super.call(this, args, parent);
    _this.args.cardName = 'sean-card';
    _this.args.text = new _LogoSplash.LogoSplash({}, parent);
    return _this;
  }
  return _createClass(SeanCard);
}(_Card2.Card);
exports.SeanCard = SeanCard;
});

;require.register("intro/Series.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Series = void 0;
var _View2 = require("curvature/base/View");
var _Card = require("./Card");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let Series = /*#__PURE__*/function (_View) {
  _inherits(Series, _View);
  var _super = _createSuper(Series);
  function Series() {
    var _this;
    let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let parent = arguments.length > 1 ? arguments[1] : undefined;
    _classCallCheck(this, Series);
    _this = _super.call(this, args, parent);
    _defineProperty(_assertThisInitialized(_this), "template", `<div class = "intro-cards" cv-each = "cards:card:c">[[card]]</div>`);
    _this.cards = _this.args.cards;
    _this.args.cards = [];
    _this.args.card = null;
    _this.startTime = false;
    return _this;
  }
  _createClass(Series, [{
    key: "play",
    value: function play() {
      if (!this.cards.length) {
        return;
      }
      const card = this.cards.shift();
      const early = new Promise(accept => card.onRemove(accept));
      const play = card.play();
      this.args.cards.push(card);
      this.startTime = Date.now();
      const racers = [early, card.done];
      if (play) {
        racers.push(play);
      }
      return Promise.race(racers).then(done => {
        if (done) {
          this.parent.onFrameOut(10, () => card.remove());
        }
        if (this.cards.length) {
          return this.play();
        } else {
          return play;
        }
      });
    }
  }, {
    key: "input",
    value: function input(controller) {
      const card = this.args.cards[this.args.cards.length - 1];
      if (card && card.input) {
        card.input(controller);
      }
    }
  }]);
  return Series;
}(_View2.View);
exports.Series = Series;
});

;require.register("intro/SkippableCard.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SkippableCard = void 0;
var _Card2 = require("./Card");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let SkippableCard = /*#__PURE__*/function (_Card) {
  _inherits(SkippableCard, _Card);
  var _super = _createSuper(SkippableCard);
  // template = require('./debian-card.html');

  function SkippableCard(args, parent) {
    var _this;
    _classCallCheck(this, SkippableCard);
    _this = _super.call(this, args, parent);
    _this.args.cardName = 'skippable-card';
    _this.args.text = ``;
    return _this;
  }
  _createClass(SkippableCard, [{
    key: "input",
    value: function input(controller) {
      if (!this.started || Date.now() + -this.started < 500) {
        return;
      }
      if (controller.buttons[9] && controller.buttons[9].time === 1 || controller.buttons[0] && controller.buttons[0].time === 1) {
        this.onTimeout(200, () => this.startPressed = true);
        this.args.animation = 'closing';
      }
    }
  }, {
    key: "play",
    value: function play() {
      this.started = Date.now();
      return Promise.race([_get(_getPrototypeOf(SkippableCard.prototype), "play", this).call(this), new Promise(accept => this.onFrame(() => {
        if (this.startPressed) {
          accept();
        }
      }))]);
    }
  }]);
  return SkippableCard;
}(_Card2.Card);
exports.SkippableCard = SkippableCard;
});

;require.register("intro/ThankYouCard.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ThankYouCard = void 0;
var _Card2 = require("./Card");
var _CharacterString = require("../ui/CharacterString");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let ThankYouCard = /*#__PURE__*/function (_Card) {
  _inherits(ThankYouCard, _Card);
  var _super = _createSuper(ThankYouCard);
  function ThankYouCard(args, parent) {
    var _this;
    _classCallCheck(this, ThankYouCard);
    _this = _super.call(this, args, parent);
    _defineProperty(_assertThisInitialized(_this), "template", require('./thank-you.html'));
    _this.args.cardName = 'thank-you-card';
    _this.args.text = new _CharacterString.CharacterString({
      value: 'Thank you for playing!'
    });
    _this.args.backdrop = '...';
    return _this;
  }
  return _createClass(ThankYouCard);
}(_Card2.Card);
exports.ThankYouCard = ThankYouCard;
});

;require.register("intro/TitleScreenCard.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TitleScreenCard = void 0;
var _Card2 = require("./Card");
var _CharacterString = require("../ui/CharacterString");
var _Bgm = require("../audio/Bgm");
var _MarbleGarden = require("../backdrop/MarbleGarden");
var _Keyboard = require("curvature/input/Keyboard");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let TitleScreenCard = /*#__PURE__*/function (_Card) {
  _inherits(TitleScreenCard, _Card);
  var _super = _createSuper(TitleScreenCard);
  function TitleScreenCard(args, parent) {
    var _this;
    _classCallCheck(this, TitleScreenCard);
    _this = _super.call(this, args, parent);
    _defineProperty(_assertThisInitialized(_this), "template", require('./titlescreen.html'));
    _this.args.cardName = 'title-screen-card';
    _this.args.text = '';
    _this.args.backdrop = '...';
    _this.startPressed = false;
    const backdrop = new _MarbleGarden.MarbleGarden();
    backdrop.args.frame = 0;
    backdrop.args.x = 0;
    backdrop.args.y = 140;
    backdrop.args.xMax = 10000;
    backdrop.args.yMax = 800;
    _this.started = 0;
    _Keyboard.Keyboard.get().reset();
    const keyBinding = _Keyboard.Keyboard.get().codes.bindTo('Enter', v => {
      if (!_this.started || Date.now() - _this.started < 2000) {
        return;
      }
      if (v <= 0 || v === undefined) {
        return;
      }
      _this.onTimeout(200, () => _this.startPressed = true);
      _this.args.animation = 'closing';
    });
    _this.onRemove(keyBinding);
    backdrop.args.xPan = 0;
    _this.start = new Promise(accept => _this.onFrame(() => {
      if (!_this.started || Date.now() - _this.started < 0) {
        return;
      }

      // backdrop.args.x -= 24;
      backdrop.args.xPan -= 24;
      backdrop.args.frame++;
      if (_this.startPressed) {
        const done = new Promise(acceptDone => _this.onTimeout(200, acceptDone));
        accept([done]);
      }
    }));
    _this.args.backdrop = backdrop;
    _this.args.pressStart = new _CharacterString.CharacterString({
      value: 'press start/enter'
    });
    return _this;
  }
  _createClass(TitleScreenCard, [{
    key: "input",
    value: function input(controller) {
      if (!this.started || Date.now() - this.started < 2000) {
        controller.zero();
        return;
      }
      const startButton = 9;
      if (controller.buttons[startButton] && controller.buttons[startButton].time === 1) {
        this.onTimeout(200, () => this.startPressed = true);
        this.args.animation = 'closing';
      }
    }
  }, {
    key: "play",
    value: function play() {
      this.onTimeout(1000, () => {
        this.onRemove(() => _Bgm.Bgm.stop('TITLE_THEME'));
        _Bgm.Bgm.play('TITLE_THEME');
      });
      this.onTimeout(2000, () => this.args.aurora = 'aurora');
      this.started = Date.now();
      const play = _get(_getPrototypeOf(TitleScreenCard.prototype), "play", this).call(this);
      return Promise.race([this.start, play]);
    }
  }]);
  return TitleScreenCard;
}(_Card2.Card);
exports.TitleScreenCard = TitleScreenCard;
});

;require.register("intro/WarningCard.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WarningCard = void 0;
var _SkippableCard2 = require("./SkippableCard");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let WarningCard = /*#__PURE__*/function (_SkippableCard) {
  _inherits(WarningCard, _SkippableCard);
  var _super = _createSuper(WarningCard);
  function WarningCard(args, parent) {
    var _this;
    _classCallCheck(this, WarningCard);
    _this = _super.call(this, args, parent);
    _defineProperty(_assertThisInitialized(_this), "template", require('./warning-card.html'));
    _this.args.cardName = 'warning-card';
    _this.args.text = ``;
    return _this;
  }
  return _createClass(WarningCard);
}(_SkippableCard2.SkippableCard);
exports.WarningCard = WarningCard;
});

;require.register("intro/WebkitCard.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WebkitCard = void 0;
var _SkippableCard2 = require("./SkippableCard");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let WebkitCard = /*#__PURE__*/function (_SkippableCard) {
  _inherits(WebkitCard, _SkippableCard);
  var _super = _createSuper(WebkitCard);
  function WebkitCard(args, parent) {
    var _this;
    _classCallCheck(this, WebkitCard);
    _this = _super.call(this, args, parent);
    _defineProperty(_assertThisInitialized(_this), "template", require('./webkit-card.html'));
    _this.args.cardName = 'webkit-card';
    _this.args.text = ``;
    return _this;
  }
  _createClass(WebkitCard, [{
    key: "play",
    value: function play(event) {
      this.onTimeout(1500, () => this.args.animation = 'spindash-charge');
      this.onTimeout(3000, () => this.args.animation = 'spindash');
      return _get(_getPrototypeOf(WebkitCard.prototype), "play", this).call(this, event);
    }
  }]);
  return WebkitCard;
}(_SkippableCard2.SkippableCard);
exports.WebkitCard = WebkitCard;
});

;require.register("intro/card.html", function(exports, require, module) {
module.exports = "<div class = \"screen-card screen-card-[[cardName]] [[animation]]\">\n\t<span>[[text]]</span>\n</div>\n"
});

;require.register("intro/debian-card.html", function(exports, require, module) {
module.exports = "<div class = \"screen-card screen-card-[[cardName]] [[animation]] [[aurora]]\">\n\t<div class = \"main-elements-container\">\n\t\t<div class = \"debian-logo\"></div>\n\t\t<div class = \"caption\">Built on Debian</div>\n\t</div>\n</div>\n"
});

;require.register("intro/gamepad-card.html", function(exports, require, module) {
module.exports = "<div class = \"screen-card screen-card-[[cardName]] [[animation]] [[aurora]]\">\n\t<div class = \"main-elements-container\">\n\t\t<div class = \"gamepad-svg\"></div>\n\t\t<div class = \"caption\">Supports HTML5 Gamepad API.</div>\n\t\t<div class = \"button-callout\">Toggle audio and fullscreen<div class = \"arrow\"></div></div>\n\t</div>\n</div>\n\n"
});

;require.register("intro/no-way.html", function(exports, require, module) {
module.exports = "<div class = \"screen-card screen-card-[[cardName]] [[animation]] [[aurora]]\">\n\t<div class = \"player-waving\"></div>\n\t<div class = \"no-way\"></div>\n\t<div class = \"main-elements-container\">\n\t\t[[text]]\n\t</div>\n</div>\n"
});

;require.register("intro/sane-card.html", function(exports, require, module) {
module.exports = "<div class = \"screen-card screen-card-[[cardName]] [[animation]] [[aurora]]\">\n\t<div class = \"main-elements-container\">\n\t\t<div><img src = \"/icons/chaosean.svg\" /></div>\n\t\t<div><img src = \"/icons/sane-engine.svg\" /></div>\n\t</div>\n</div>\n\n"
});

;require.register("intro/thank-you.html", function(exports, require, module) {
module.exports = "<div class = \"screen-card screen-card-[[cardName]] [[animation]] [[aurora]]\">\n\t<div class = \"player-waving\"></div>\n\t<div class = \"main-elements-container\">\n\t\t<div class = \"title-emblem\"></div>\n\t\t[[text]]\n\t</div>\n</div>\n"
});

;require.register("intro/titlescreen.html", function(exports, require, module) {
module.exports = "<div class = \"screen-card screen-card-[[cardName]] [[animation]] [[aurora]]\">\n\t[[backdrop]]\n\n\t<div class = \"main-elements-container\">\n\n\t\t<div class = \"title-emblem\"></div>\n\t\t<div class = \"press-start\">[[pressStart]]</div>\n\n\t</div>\n\n</div>\n"
});

;require.register("intro/warning-card.html", function(exports, require, module) {
module.exports = "<div class = \"screen-card screen-card-[[cardName]] [[animation]] [[aurora]]\">\n\t<div class = \"main-elements-container\">\n\t\t<div class = \"warning-svg\"></div>\n\t</div>\n</div>\n\n"
});

;require.register("intro/webkit-card.html", function(exports, require, module) {
module.exports = "<div class = \"screen-card screen-card-[[cardName]] [[animation]] [[aurora]]\">\n\t<div class = \"main-elements-container\">\n\t\t<div class = \"chromium-logo\"></div>\n\t\t<div class = \"caption\">WebKit recommended for best experience.</div>\n\t</div>\n</div>\n"
});

;require.register("legacy/Actor.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Actor = void 0;
var _View2 = require("curvature/base/View");
var _PointDump = require("../debug/PointDump");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let Actor = /*#__PURE__*/function (_View) {
  _inherits(Actor, _View);
  var _super = _createSuper(Actor);
  function Actor() {
    var _this;
    _classCallCheck(this, Actor);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _defineProperty(_assertThisInitialized(_this), "speed", 15);
    _defineProperty(_assertThisInitialized(_this), "template", require('./actor.html'));
    _this.world = null;
    _this.x = 92;
    _this.y = 1024;
    _this.width = 64;
    _this.height = 64;
    _this.boxWidth = 64;
    _this.boxHeight = 64;
    _this.directions = 16;
    _this.state = 'standing';
    _this.gSpeed = 0;
    // this.gSpeedMax = 48;
    _this.gSpeedMax = 40;
    _this.xSpeed = 0;
    _this.ySpeed = 0;
    _this.angle = 0;
    _this.maxGravity = 48;
    _this.gravity = 0;
    _this.slopeFactor = 0.01;
    _this.falling = true;
    _this.sensors = {
      top: false,
      bottom: false,
      left: false,
      right: false
    };
    _this.mode = _this.args.mode = 0;
    _this.modes = {
      floor: 0,
      leftWall: 1,
      ceiling: 2,
      rightWall: 3
    };
    _this.animationClasses = {};
    _this.currentClasses = null;
    _this.pdL = new _PointDump.PointDump({
      color: 'red'
    });
    _this.pdR = new _PointDump.PointDump({
      color: 'green'
    });
    _this.args.debugs = [_this.pdL, _this.pdR];
    return _this;
  }
  _createClass(Actor, [{
    key: "destroy",
    value: function destroy() {}
  }, {
    key: "update",
    value: function update() {
      if (!this.tags.actor) {
        return;
      }
      let g = this.gSpeed;
      this.args.animspeed = Math.floor((this.gSpeedMax - Math.abs(g)) / 12);
      if (this.args.animspeed < 1) {
        this.args.animspeed = 1;
      }
      const angle = Math.round(this.angle * 1000) / 1000;
      if (!this.falling) {
        if (angle > Math.PI / 4 && angle < 2 * Math.PI / 4) {
          if (this.mode === this.modes.floor) {
            this.args.mode = this.mode = this.modes.leftWall;
          } else if (this.mode === this.modes.leftWall) {
            this.args.mode = this.mode = this.modes.ceiling;
          } else if (this.mode === this.modes.ceiling) {
            this.args.mode = this.mode = this.modes.rightWall;
          } else if (this.mode === this.modes.rightWall) {
            this.args.mode = this.mode = this.modes.floor;
          }
        }
        if (angle < -Math.PI / 4 && angle > -2 * Math.PI / 4) {
          if (this.mode === this.modes.floor) {
            this.args.mode = this.mode = this.modes.rightWall;
          } else if (this.mode === this.modes.rightWall) {
            this.args.mode = this.mode = this.modes.ceiling;
          } else if (this.mode === this.modes.ceiling) {
            this.args.mode = this.mode = this.modes.leftWall;
          } else if (this.mode === this.modes.leftWall) {
            this.args.mode = this.mode = this.modes.floor;
          }
        }
        if (Math.abs(g) > this.gSpeedMax / 2) {
          this.args.state = 'running';
        } else if (Math.abs(g) > 0) {
          this.args.state = 'walking';
        } else {
          this.args.state = 'standing';
        }
        if (g > 0) {
          this.args.facing = 'facing-right';
        } else {
          this.args.facing = 'facing-left';
        }
      } else if (this.falling || this.jumped) {
        this.args.state = 'jumping';
      }
      if (this.falling) {
        if (this.mode == this.modes.floor) {
          this.ySpeed++;
        } else if (this.mode == this.modes.ceiling) {
          this.ySpeed--;
        } else if (this.mode == this.modes.leftWall) {
          this.xSpeed--;
        } else if (this.mode == this.modes.rightWall) {
          this.xSpeed++;
        }
      } else if (!this.jumped) {
        this.xSpeed = 0;
        this.ySpeed = 0;
      }
      this.x += this.xSpeed;
      this.ySpeed && (this.y += this.ySpeed > 0 ? 1 : -1);
      if (g) {
        const max = 8;
        const abG = Math.abs(g);
        const div = abG > max ? max : abG;
        for (let i = 0; i < div; i++) {
          this.iteratePosition(Math.floor(g / div));
        }
      } else {
        this.iteratePosition(0);
      }
      if (this.ySpeed > 32) {
        this.ySpeed = 32;
      }
      if (this.ySpeed < -32) {
        this.ySpeed = -32;
      }
      if (this.xSpeed > 32) {
        this.xSpeed = 32;
      }
      if (this.xSpeed < -32) {
        this.xSpeed = -32;
      }
      this.tags.actor.style({
        '--x': Math.floor(this.x),
        '--y': Math.floor(this.y)
      });
      if (this.mode === this.modes.floor) {
        this.tags.actor.style({
          '--angle': this.angle
        });
      } else if (this.mode === this.modes.leftWall) {
        this.tags.actor.style({
          '--angle': this.angle + 1 * (Math.PI / 2)
        });
      } else if (this.mode === this.modes.ceiling) {
        this.tags.actor.style({
          '--angle': this.angle + 2 * (Math.PI / 2)
        });
      } else if (this.mode === this.modes.rightWall) {
        this.tags.actor.style({
          '--angle': this.angle + 3 * (Math.PI / 2)
        });
      }
      if (this.jumped) {
        this.jumped = false;
      }
    }
  }, {
    key: "iteratePosition",
    value: function iteratePosition(speed) {
      let sin = Math.sin(this.angle);
      let cos = Math.cos(this.angle);
      const center = this.center;
      const top = this.top;
      const bottom = this.bottom;
      const left = this.left;
      const right = this.right;
      let arm, leg, sensorLeft, sensorRight, sensorSpread;
      if (this.mode == this.modes.floor || this.mode == this.modes.ceiling) {
        arm = right - center[0];
        leg = bottom - center[1];
      } else if (this.mode == this.modes.leftWall || this.mode == this.modes.rightWall) {
        arm = right - center[1];
        leg = bottom - center[0];
      }
      sensorLeft = this.left - arm * sin + arm * 0.5;
      sensorRight = this.right - arm * sin - arm * 0.5;
      sensorSpread = Math.abs(sensorRight - sensorLeft);
      const map = this.viewport.tileMap;
      let leftScan = 0;
      let rightScan = 0;
      let scanLX, scanLY, scanRX, scanRY;
      let leftSolid = false,
        rightSolid = false;
      const height = this.falling ? this.height : this.height;
      const scans = [[-height, 0], [-height, height]];
      regress: for (let i in scans) {
        leftScan = scans[i][0];
        while (leftScan < scans[i][1]) {
          if (this.mode == this.modes.floor) {
            scanLX = sensorLeft;
            scanLY = bottom + leftScan;
          } else if (this.mode == this.modes.ceiling) {
            scanLX = sensorLeft;
            scanLY = bottom - leftScan;
          } else if (this.mode == this.modes.leftWall) {
            scanLX = bottom - leftScan;
            scanLY = sensorLeft;
          } else if (this.mode == this.modes.rightWall) {
            scanLX = bottom + leftScan;
            scanLY = sensorLeft;
          }
          leftSolid = map.getSolid(scanLX, scanLY);
          if (leftSolid) {
            if (leftScan !== 0) {
              break regress;
            }
            break;
          }
          leftScan++;
        }
      }
      regress: for (let i in scans) {
        rightScan = scans[i][0];
        while (rightScan < scans[i][1]) {
          if (this.mode == this.modes.floor) {
            scanRX = sensorRight;
            scanRY = bottom + rightScan;
          } else if (this.mode == this.modes.ceiling) {
            scanRX = sensorRight;
            scanRY = bottom - rightScan;
          } else if (this.mode == this.modes.leftWall) {
            scanRX = bottom - rightScan;
            scanRY = sensorRight;
          } else if (this.mode == this.modes.rightWall) {
            scanRX = bottom + rightScan;
            scanRY = sensorRight;
          }
          rightSolid = map.getSolid(scanRX, scanRY);
          if (rightSolid) {
            break;
          }
          rightScan++;
        }
      }
      this.pdL.args.x = scanLX;
      this.pdL.args.y = scanLY;
      this.pdR.args.x = scanRX;
      this.pdR.args.y = scanRY;
      this.angle = Math.atan((rightScan - leftScan) / sensorSpread);
      if (!this.falling) {
        let offset = (leftScan + rightScan) / 2;
        if (this.mode === this.modes.floor) {
          this.x += speed * cos;
          this.y += speed * sin;
        } else if (this.mode === this.modes.rightWall) {
          this.x += speed * sin;
          this.y -= speed * cos;
        } else if (this.mode === this.modes.ceiling) {
          this.x -= speed * cos;
          this.y -= speed * sin;
        } else if (this.mode === this.modes.leftWall) {
          this.x -= speed * sin;
          this.y += speed * cos;
        }
        if (leftSolid && rightSolid && leftScan <= 0 && rightScan <= 0) {
          if (this.mode == this.modes.floor) {
            this.y += Math.ceil(offset);
          } else if (this.mode == this.modes.ceiling) {
            this.y -= Math.ceil(offset);
          } else if (this.mode == this.modes.leftWall) {
            this.x -= offset;
          } else if (this.mode == this.modes.rightWall) {
            this.x += offset;
          }
        }
      }
      if (leftScan > 0 && rightScan > 0) {
        this.falling = true;
      } else {
        this.falling = false;
      }
    }
  }, {
    key: "isColliding",
    value: function isColliding(actor) {}
  }, {
    key: "animate",
    value: function animate() {
      if (!this.animationClasses[animation]) {
        return;
      }
      if (this.currentClasses == this.animationClasses[animation]) {
        return;
      }
      this.currentClasses.map(function (remClass) {
        this.tags.sprite.removeClass(remClass);
      });
      this.animationClasses[animation].map(function (newClass) {
        this.tags.sprite.addClass(newClass);
      });
      this.currentClasses = this.animationClasses[animation];
    }
  }, {
    key: "roundAngle",
    value: function roundAngle(angle, segments) {
      angle = Math.round(angle * (180 / Math.PI));
      var rAngle = `Math.round`(angle / (360 / segments)) * 360 / segments;
      return rAngle * (Math.PI / 180);
    }
  }, {
    key: "goLeft",
    value: function goLeft() {
      if (this.gSpeed > 0) {
        this.gSpeed = 0;
      }
      if (this.gSpeed > -this.gSpeedMax) {
        this.gSpeed--;
      }
    }
  }, {
    key: "goRight",
    value: function goRight() {
      if (this.gSpeed < 0) {
        this.gSpeed = 0;
      }
      if (this.gSpeed < this.gSpeedMax) {
        this.gSpeed++;
      }
    }
  }, {
    key: "slowDown",
    value: function slowDown() {
      if (Math.abs(this.gSpeed) > 32) {
        this.gSpeed = this.gSpeed * 0.95;
      } else {
        this.gSpeed = this.gSpeed * 0.75;
      }
      if (Math.abs(this.gSpeed) <= 0.1) {
        this.gSpeed = 0;
      }
    }
  }, {
    key: "jump",
    value: function jump() {
      if (this.falling) {
        return;
      }
      this.falling = true;
      this.jumped = true;
      this.mode = this.args.mode = this.modes.floor;
      let angle;
      if (this.mode === this.modes.floor) {
        angle = this.angle;
      } else if (this.mode === this.modes.leftWall) {
        angle = this.angle + 1 * (Math.PI / 2);
      } else if (this.mode === this.modes.ceiling) {
        angle = this.angle + 2 * (Math.PI / 2);
      } else if (this.mode === this.modes.rightWall) {
        angle = this.angle + 3 * (Math.PI / 2);
      }
      this.angle = 0;
      this.ySpeed = -Math.cos(angle) * 20;
      this.xSpeed = Math.sin(angle) * 20;
      if (this.mode === this.modes.leftWall || this.mode === this.modes.rightWall) {
        this.gSpeed = 0;
      }
    }
  }, {
    key: "center",
    get: function get() {
      return [this.x + this.boxWidth / 2, this.y + this.boxHeight / 2];
    }
  }, {
    key: "left",
    get: function get() {
      if (this.mode == this.modes.floor) {
        return this.center[0] - this.width / 2;
      } else if (this.mode == this.modes.ceiling) {
        return this.center[0] + this.width / 2;
      } else if (this.mode == this.modes.leftWall) {
        return this.center[1] - this.width / 2;
      } else if (this.mode == this.modes.rightWall) {
        return this.center[1] + this.width / 2;
      }
    }
  }, {
    key: "right",
    get: function get() {
      if (this.mode == this.modes.floor) {
        return this.center[0] + this.width / 2;
      } else if (this.mode == this.modes.ceiling) {
        return this.center[0] - this.width / 2;
      } else if (this.mode == this.modes.leftWall) {
        return this.center[1] + this.width / 2;
      } else if (this.mode == this.modes.rightWall) {
        return this.center[1] - this.width / 2;
      }
    }
  }, {
    key: "top",
    get: function get() {
      if (this.mode == this.modes.floor) {
        return this.center[1] - Math.floor(this.height / 2);
      } else if (this.mode == this.modes.ceiling) {
        return this.center[1] + Math.floor(this.height / 2);
      } else if (this.mode == this.modes.leftWall) {
        return this.center[0] + Math.floor(this.height / 2);
      } else if (this.mode == this.modes.rightWall) {
        return this.center[0] - Math.floor(this.height / 2);
      }
    }
  }, {
    key: "bottom",
    get: function get() {
      if (this.mode == this.modes.floor) {
        return this.center[1] + Math.floor(this.height / 2);
      } else if (this.mode == this.modes.ceiling) {
        return this.center[1] - Math.floor(this.height / 2);
      } else if (this.mode == this.modes.leftWall) {
        return this.center[0] - Math.floor(this.height / 2);
      } else if (this.mode == this.modes.rightWall) {
        return this.center[0] + Math.floor(this.height / 2);
      }
    }
  }]);
  return Actor;
}(_View2.View);
exports.Actor = Actor;
});

;require.register("legacy/Walker.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Walker = void 0;
var _Actor2 = require("./Actor");
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let Walker = /*#__PURE__*/function (_Actor) {
  _inherits(Walker, _Actor);
  var _super = _createSuper(Walker);
  function Walker() {
    _classCallCheck(this, Walker);
    return _super.apply(this, arguments);
  }
  return _createClass(Walker);
}(_Actor2.Actor);
exports.Walker = Walker;
});

;require.register("legacy/actor.html", function(exports, require, module) {
module.exports = "<div class = \"actor knuckles [[state]] [[facing]]\" cv-ref = \"actor\" data-mode = \"[[mode]]\" style = \"--animspeed:[[animspeed]]\">\n\t<div class = \"sprite\" cv-ref = \"sprite\" ></div>\n</div>\n<div cv-each = \"debugs:debug\">[[debug]]</div>\n"
});

;require.register("lib/Color.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Color = void 0;
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }
function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct.bind(); } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let Color = /*#__PURE__*/function (_Uint8Array) {
  _inherits(Color, _Uint8Array);
  var _super = _createSuper(Color);
  function Color(value) {
    var _this;
    _classCallCheck(this, Color);
    _this = _super.call(this, 3);
    if (typeof value === 'string') {
      if (value[0] === '#') {
        value = value.substr(1);
      }
      if (value[0] !== '0' && (value[1] !== 'x' || value[1] !== 'X')) {
        value = '0x' + value;
      }
      value = parseInt(value);
    }
    if (typeof value === 'number') {
      if (value > 0xFFFFFF) {
        value = value % 0xFFFFFF;
      }
      _this[0] = value >> 16 & 0xFF;
      _this[1] = value >> 8 & 0xFF;
      _this[2] = value >> 0 & 0xFF;
    } else if (Array.isArray(value) && value.length <= 3) {
      _this[0] = value[0];
      _this[1] = value[1];
      _this[2] = value[2];
    }
    return _this;
  }
  _createClass(Color, [{
    key: "r",
    get: function get() {
      return this[0];
    }
  }, {
    key: "g",
    get: function get() {
      return this[1];
    }
  }, {
    key: "b",
    get: function get() {
      return this[2];
    }
  }, {
    key: "rf",
    get: function get() {
      return this[0] / 0xFF;
    }
  }, {
    key: "gf",
    get: function get() {
      return this[1] / 0xFF;
    }
  }, {
    key: "bf",
    get: function get() {
      return this[2] / 0xFF;
    }
  }, {
    key: "rotate",
    value: function rotate(h, s, v) {
      const normalized = [this.rf, this.gf, this.bf];
      const cMax = Math.max(...normalized);
      const cMin = Math.min(...normalized);
      const delta = cMax - cMin;
      let hInit = 0;
      if (delta && cMax === this.rf) {
        hInit = 60 * ((normalized[1] - normalized[2]) / delta % 6);
      } else if (delta && cMax === this.gf) {
        hInit = 60 * ((normalized[2] - normalized[0]) / delta + 2);
      } else if (delta && cMax === this.bf) {
        hInit = 60 * ((normalized[0] - normalized[1]) / delta + 4);
      }
      const sInit = delta === 0 ? 0 : delta / cMax;
      const vInit = cMax;
      let hOut = (hInit + h) % 360;
      const sOut = Math.max(0, Math.min(sInit * s, 1));
      const vOut = Math.max(0, Math.min(vInit * v, 1));
      if (hOut < 0) {
        hOut += 360;
      }
      const c = vOut * sOut;
      const x = c * (1 - Math.abs(hOut / 60 % 2 - 1));
      const m = vOut - c;
      let ri, gi, bi;
      if (0 <= hOut && hOut < 60) {
        ri = c + m;
        gi = x + m;
        bi = 0 + m;
      } else if (60 <= hOut && hOut < 120) {
        ri = x + m;
        gi = c + m;
        bi = 0 + m;
      } else if (120 <= hOut && hOut < 180) {
        ri = 0 + m;
        gi = c + m;
        bi = x + m;
      } else if (180 <= hOut && hOut < 240) {
        ri = 0 + m;
        gi = x + m;
        bi = c + m;
      } else if (240 <= hOut && hOut < 300) {
        ri = x + m;
        gi = 0 + m;
        bi = c + m;
      } else if (300 <= hOut && hOut < 360) {
        ri = c + m;
        gi = 0 + m;
        bi = x + m;
      }
      const rotated = new this.constructor([ri * 0xFF, gi * 0xFF, bi * 0xFF].map(Math.round));
      return rotated;
    }
  }, {
    key: "toString",
    value: function toString() {
      return String(Math.round(this[0]).toString(16).padStart(2, '0') + Math.round(this[1]).toString(16).padStart(2, '0') + Math.round(this[2]).toString(16).padStart(2, '0'));
    }
  }, {
    key: "toPrimitive",
    value: function toPrimitive() {
      return (this[0] << 16) + (this[1] << 8);
      +(this[2] << 0);
    }
  }]);
  return Color;
}( /*#__PURE__*/_wrapNativeSuper(Uint8Array));
exports.Color = Color;
});

;require.register("mixin/CanPop.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CanPop = void 0;
var _Tag = require("curvature/base/Tag");
var _Explosion = require("../actor/Explosion");
var _Projectile = require("../actor/Projectile");
var _Sfx = require("../audio/Sfx");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let CanPop = /*#__PURE__*/function () {
  function CanPop() {
    _classCallCheck(this, CanPop);
  }
  _createClass(CanPop, [{
    key: "collideA",
    value: function collideA(other, type) {
      if (this.knocked && other.pop) {
        this.pop(this.knocked);
      }
      const viewport = this.viewport;
      if (this.args.invincible) {
        other.damage(this);
        return;
      }
      if (other.knocked) {
        other.pop && other.pop(other.knocked);
        this.pop(other.knocked);
        return;
      }
      if (other.punching && !this.knocked) {
        // this.viewport.args.frozen = 1;

        this.args.falling = true;
        if (Math.abs(other.args.gSpeed || other.gSpeedLast) < 5) {
          this.pop(other);
          return;
        }
        if (other.args.falling && other.args.ySpeed < 0) {
          // this.args.xSpeed = other.args.xSpeed + 10 * Math.sign(other.args.xSpeed);
          this.args.ySpeed = -10 + other.args.ySpeed;
          this.args.y -= 18;
        } else {
          this.args.xSpeed = 1.2 * (other.args.gSpeed || other.gSpeedLast);
          this.args.ySpeed = -5;
          this.args.y -= 18;
        }
        this.args.x = other.args.x + 24 * other.args.direction + other.args.gSpeed;

        // this.args.float = 15;
        this.knocked = other;
        // this.noClip = true;
        this.static = false;
        this.viewport.onFrameOut(60, () => this.pop(other));
        return false;
      }
      const shield = this.args.currentSheild;
      const immune = other.immune(this, shield ? shield.type : 'normal');
      if ((!shield || immune) && !this.args.gone && this.viewport && (immune || other.dashed || other.args.jumping || other.args.bellySliding || other.args.spinning || other instanceof _Projectile.Projectile && other.args.owner && other.args.owner.controllable)) {
        const otherShield = other.args.currentSheild;
        this.damage(other, otherShield ? otherShield.type : other.args.damageType || 'normal');
        return;
      }
      if (!this.knocked && other && other.controllable && !other.punching) {
        if (viewport && typeof ga === 'function') {
          ga('send', 'event', {
            eventCategory: 'badnik',
            eventAction: 'damaged-player',
            eventLabel: `${viewport.args.actName}::${this.args.name}::${this.args.id}::${other.args.id}`
          });
        }
        if (!other.args.mercy) {
          other.damage(this, shield ? shield.type : 'normal');
          this.ignores.set(other, 10);
        }
      }
      return false;
    }
  }, {
    key: "damage",
    value: function damage(other, type) {
      if (this.args.invincible) {
        return;
      }
      if (!other) {
        this.pop();
        return;
      }
      const shield = this.args.currentSheild;
      const immune = other.immune(this, shield ? shield.type : 'normal');
      if ((!shield || immune) && !this.args.gone && this.viewport && (immune || other.dashed || other.args.jumping || other.args.bellySliding || other.args.spinning || other instanceof _Projectile.Projectile)) {
        this.pop(other);
      }
    }
  }, {
    key: "pop",
    value: function pop(other) {
      const viewport = this.viewport;
      if (!viewport || this.args.gone || this.args.invincible || other && other.args.owner === this) {
        return;
      }
      this.args.gone = true;
      const explosionTag = document.createElement('div');
      explosionTag.classList.add('particle-explosion');
      const explosion = new _Tag.Tag(explosionTag);
      explosion.style({
        '--x': this.args.x,
        '--y': this.args.y - 16
      });
      viewport.particles.add(explosion);
      viewport.onFrameOut(30, () => viewport.particles.remove(explosion));
      viewport.onFrameOut(90, () => this.screen && this.screen.remove());
      this.box && this.box.setAttribute('data-animation', 'broken');
      if (other && other.dashed) {
        if (Math.abs(other.args.xSpeed) > Math.abs(other.args.ySpeed)) {
          other.args.gSpeed = 0;
          other.args.xSpeed = -1.5 * Math.sign(other.args.xSpeed);
          other.args.ySpeed = -10;
        }
        other.dashed = false;
      }
      if (other) {
        if (other.args.doubleSpin) {
          other.args.doubleSpin = 2;
        }
        if (other.occupant) {
          other = other.occupant;
        }
        if (other.args.owner) {
          other = other.args.owner;
        }
        if (other.controllable && typeof this.effect === 'function') {
          let points = 100;
          if (this.args.gold) {
            points = 10000;
          }
          const reward = {
            label: this.name || this.args.name,
            points: points,
            multiplier: 1
          };
          if (this.args.gold) {
            reward.label = 'Gold ' + reward.label;
            reward.color = 'orange';
            reward.special = true;
          }
          if (!other.isVehicle && other.args.ySpeed > 5 && other.args.ySpeed < 25 && Math.abs(other.args.ySpeed) > Math.abs(other.args.xSpeed)) {
            other.args.cameraMode = 'popping';
          }
          other.args.popCombo += 1;
          other.args.popChain.push(reward);
          if (other.args.ySpeed > 25 && !other.args.bouncing) {
            const reward = {
              label: 'BIG AIR!!!',
              points: 1000,
              multiplier: 2
            };
            other.args.popChain.push(reward);
            other.args.popCombo += 1;
            if (!other.airReward && Math.abs(other.args.xSpeed) > 10) {
              other.args.x = this.args.x;
              other.args.y = this.args.y + -8;
              viewport.onFrameOut(1, () => viewport.args.frozen = 25);
              viewport.args.invert = 'invert';
              viewport.onFrameOut(25, () => viewport.args.invert = '');
              _Sfx.Sfx.play('SICK_TRICK');
              _Sfx.Sfx.play('SICK_TRICK');
            }
            other.airReward = reward;
          }
          const scoreNode = document.createElement('div');
          scoreNode.classList.add('particle-score');
          const scoreTag = new _Tag.Tag(scoreNode);
          scoreTag.style({
            '--x': this.args.x,
            '--y': this.args.y - 16
          });
          switch (true) {
            case this.args.gold:
              // scoreNode.classList.add('score-10000');
              points = 10000;
              break;
            case other.args.popCombo === 1:
              // scoreNode.classList.add('score-100');
              points = 100;
              break;
            case other.args.popCombo === 2:
              // scoreNode.classList.add('score-200');
              points = 200;
              break;
            case other.args.popCombo === 3:
              // scoreNode.classList.add('score-300');
              points = 300;
              break;
            case other.args.popCombo === 4:
              // scoreNode.classList.add('score-400');
              points = 400;
              break;
            case other.args.popCombo === 5:
              // scoreNode.classList.add('score-500');
              points = 500;
              break;
            case other.args.popCombo === 6:
              // scoreNode.classList.add('score-600');
              points = 600;
              break;
            case other.args.popCombo === 7:
              // scoreNode.classList.add('score-700');
              points = 700;
              break;
            case other.args.popCombo === 8:
              // scoreNode.classList.add('score-800');
              points = 800;
              break;
            case other.args.popCombo === 9:
              // scoreNode.classList.add('score-900');
              points = 900;
              break;
            case other.args.popCombo >= 10:
              // scoreNode.classList.add('score-1000');
              points = 1000;
              break;
          }

          // viewport.particles.add(scoreTag);

          // viewport.onFrameOut(80, () => viewport.particles.remove(scoreTag));

          // other.args.score += points;

          this.effect(other);
        }
        const ySpeed = Math.min(other.args.ySpeed, other.ySpeedLast);
        if (other.args.falling && !other.punching) {
          const spinning = other.args.spinning;
          const jumping = other.args.jumping;
          const flying = other.args.flying;
          const xSpeed = other.args.xSpeed || other.args.gSpeed;
          viewport.onFrameOut(1, () => {
            if (ySpeed >= 0) {
              if (other.flyTime < 5) {
                other.args.ySpeed = Math.min(-ySpeed, -7);
              } else {
                other.args.ySpeed = Math.min(-ySpeed, -2);
              }
            } else {
              other.args.ySpeed += 8;
            }
            other.args.spinning = other.args.spinning || spinning;
            other.args.jumping = other.args.jumping || jumping;
            other.args.flying = other.args.flying || flying;
            other.args.xSpeed = xSpeed;
            other.args.falling = true;
          });
        }
        other.dashed = false;
        if (this.viewport.settings.rumble) {
          if (other && other.controller && other.controller.rumble) {
            other.controller.rumble({
              duration: 40,
              strongMagnitude: 0.0,
              weakMagnitude: 1.0
            });
            this.viewport.onTimeout(40, () => {
              other.controller.rumble({
                duration: 110,
                strongMagnitude: 0.75,
                weakMagnitude: 1.0
              });
            });
          }
        }
      }
      if (this.args.target && this.viewport.actorsById[this.args.target]) {
        const target = this.viewport.actorsById[this.args.target];
        if (target) {
          this.viewport.auras.add(target);
          target.activate(other, this);
        }
      }
      _Sfx.Sfx.play('OBJECT_DESTROYED');
      if (typeof ga === 'function') {
        ga('send', 'event', {
          eventCategory: 'badnik',
          eventAction: 'defeated',
          eventLabel: `${viewport.args.actName}::${this.args.name}::${this.args.id}`
        });
      }
      this.viewport.actors.remove(this);
    }
  }]);
  return CanPop;
}();
exports.CanPop = CanPop;
});

;require.register("mixin/Constrainable.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Constrainable = void 0;
var _Tag = require("curvature/base/Tag");
const Constrainable = {
  initialize: function initialize() {
    if (!this.others.tiedTo) {
      return;
    }
    const _tiedTo = this.others.tiedTo;
    if (_tiedTo && !_tiedTo.hanging.has(this.constructor)) {
      _tiedTo.hanging.set(this.constructor, new Set());
      const hangList = _tiedTo.hanging.get(this.constructor);
      hangList.add(this);
      this.chain = new _Tag.Tag('<div class = "chain">');
      this.sprite.appendChild(this.chain.node);
      this.onRemove(() => hangList.delete(this));
    }
    this.setPos();
  },
  wakeUp: function wakeUp() {},
  sleep: function sleep() {
    if (!this.viewport || this.args.stay) {
      return;
    }
    if (this.def) {
      this.viewport.onFrameOut(5, () => {
        this.args.x = this.def.get('x');
        this.args.y = this.def.get('y');
        this.args.xSpeed = 0;
        this.args.ySpeed = 0;
        this.viewport.setColCell(this);
      });
    }
  }

  // , findNextStep: function() {
  // 	return false;
  // }
  ,

  setPos: function setPos() {
    let blockers = null;
    blockers = this.getMapSolidAt(this.args.x, this.args.y);
    if (this.hooked && Array.isArray(blockers)) {
      blockers = blockers.filter(b => !this.hooked.has(b)).length;
    }
    if (blockers && !this.getMapSolidAt(this.args.x, this.args.y + 1)) {
      this.args.y++;
    }
    if (!this.others.tiedTo) {
      return;
    }
    const tiedTo = this.others.tiedTo;
    if (!tiedTo) {
      return false;
    }
    this.args.ropeLength = this.args.ropeLength || tiedTo.args.ropeLength;
    this.args.falling = true;
    const xTarget = tiedTo.args.x;
    const yTarget = tiedTo.args.y;
    const xDist = xTarget - this.args.x;
    const yDist = yTarget - this.args.y;
    const angle = Math.atan2(yDist, xDist);
    const dist = Math.hypot(yDist, xDist);
    const maxDist = this.args.ropeLength || 64;
    if (this.chain) {
      this.chain.style({
        '--distance': Math.min(dist, maxDist)
      });
    }
    this.args.groundAngle = -(angle + Math.PI / 2);
    const gravityAngle = angle;
    if (dist > maxDist) {
      const overshot = dist - maxDist;
      const xMove = Math.cos(angle) * maxDist;
      const yMove = Math.sin(angle) * maxDist;
      const xNext = xTarget - xMove;
      const yNext = yTarget - yMove;
      this.args.xSpeed += Math.cos(gravityAngle) * overshot;
      this.args.ySpeed += Math.sin(gravityAngle) * overshot;
      if (this.args.xSpeedMax < Math.abs(this.args.xSpeed)) {
        this.args.xSpeed = this.args.xSpeedMax * Math.sign(this.args.xSpeed);
      }
      if (this.args.ySpeedMax < Math.abs(this.args.ySpeed)) {
        this.args.ySpeed = this.args.ySpeedMax * Math.sign(this.args.ySpeed);
      }
      this.args.gSpeed = this.args.xSpeed;
      this.args.x = xNext;
      this.args.y = yNext;
      if (this.viewport) {
        this.viewport.setColCell(this);
      }
      if (this.args.x === xTarget && !tiedTo.args.xSpeed && !tiedTo.args.gSpeed) {
        this.args.ySpeed = 0;
      }
    }
    if (tiedTo.args.ySpeed > 0 && !tiedTo.args.xSpeed && !this.args.xSpeed) {
      this.args.x = xTarget;
      this.args.y = yTarget + this.args.ropeLength;
    }
  }
};
exports.Constrainable = Constrainable;
});

require.register("mixin/Pushable.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Pushable = void 0;
var _Ring = require("../actor/Ring");
const Pushable = {
  collideA: function collideA(other, type) {
    if (other instanceof _Ring.Ring) {
      return false;
    }
    if (type === -1 || other.isEffect) {
      return false;
    }
    const otherMag = Math.ceil(Math.abs(other.args.gSpeed || other.args.xSpeed));
    const otherDir = Math.sign(other.args.gSpeed || other.args.xSpeed);
    let otherSpeed = otherMag * otherDir;
    if (Math.abs(other.args.ySpeed) > Math.abs(other.args.xSpeed)) {
      return true;
    }
    if (!this.args.falling && type === 1 && otherSpeed <= 0) {
      return false;
    }
    if (!this.args.falling && type === 3 && otherSpeed >= 0) {
      return false;
    }
    const blockTop = this.y - this.args.height;
    if ((type === 1 || type === 3) && (other.y >= this.y || other.y > blockTop)) {
      if (!otherSpeed) {
        return true;
      }
      this.args.gSpeed = otherSpeed;
      this.args.pushed = Math.sign(otherSpeed) || this.args.pushed;
      const tileMap = this.viewport.tileMap;
      const moveBy = type === 1 && 1 || type === 3 && -1;
      const scan = this.scanBottomEdge(moveBy);
      const blockers = tileMap.getSolid(this.x + Math.ceil(this.args.width / 2) * moveBy, this.y);
      if (blockers) {
        return true;
      }
      const radius = this.args.width / 2;
      if (moveBy > 0 && scan === 0) {
        this.args.falling = true;
      } else if (moveBy < 0 && scan === 0) {
        this.args.falling = true;
      } else if (!this.args.falling || scan > 0) {
        const nextCenter = this.bMap('findNextStep', moveBy).get(Platformer);
        const nextWall = this.bMap('findNextStep', moveBy + radius * Math.sign(moveBy)).get(Platformer);
        if ((!nextCenter[1] || nextCenter[2]) && !nextWall[3]) {
          // this.args.x += nextPosition[0] || moveBy;

          const otherRadius = other.args.width;
          const myRadius = this.args.width / 2;
          this.args.x = other.args.x + moveBy * (myRadius + otherRadius);
          return scan === 0;
        }
        return true;
      }
    }
    return true;
  }
};
exports.Pushable = Pushable;
});

;require.register("network/ChatBox.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ChatBox = void 0;
var _View2 = require("curvature/base/View");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let ChatBox = /*#__PURE__*/function (_View) {
  _inherits(ChatBox, _View);
  var _super = _createSuper(ChatBox);
  function ChatBox(args, parent) {
    var _this;
    _classCallCheck(this, ChatBox);
    _this = _super.call(this, args, parent);
    _defineProperty(_assertThisInitialized(_this), "template", require('./chat-box.html'));
    _this.args.outputLines = [];
    const onOpen = event => _this.args.outputLines = ['You joined the chat.'];
    const onMessage = event => {
      const packet = JSON.parse(event.detail);
      if (packet.message) {
        _this.args.outputLines.push(_View2.View.from(`> <span class = "incoming">[[message]]</span>`, {
          message: packet.message
        }));
        _this.onNextFrame(() => {
          const chatOutput = _this.tags.chatOutput;
          chatOutput && chatOutput.scrollTo(0, chatOutput.scrollHeight);
        });
      }
    };
    _this.listen(args.pipe, 'open', onOpen);
    _this.listen(args.pipe, 'message', onMessage);
    return _this;
  }
  _createClass(ChatBox, [{
    key: "send",
    value: function send(event) {
      if (event && event.key && event.key !== 'Enter') {
        return;
      }
      const message = this.args.chatInput;
      if (!message) {
        return;
      }
      this.args.outputLines.push(`< ${message}`);
      this.args.chatInput = '';
      this.onNextFrame(() => {
        const tag = this.tags.chatOutput;
        tag.scrollTo(0, tag.scrollHeight);
        tag.focus();
      });
      this.args.pipe.send(JSON.stringify({
        message: message
      }));
    }
  }]);
  return ChatBox;
}(_View2.View);
exports.ChatBox = ChatBox;
});

;require.register("network/CryptoMessage.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CryptoMessage = void 0;
var _Uuid = require("curvature/base/Uuid");
var _CryptoReply = require("./CryptoReply");
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let CryptoMessage = /*#__PURE__*/function () {
  function CryptoMessage(_ref) {
    let content = _ref.content,
      sender = _ref.sender,
      uuid = _ref.uuid,
      re = _ref.re,
      foreignKey = _ref.foreignKey,
      publicKey = _ref.publicKey;
    _classCallCheck(this, CryptoMessage);
    _defineProperty(this, "content", void 0);
    _defineProperty(this, "sender", void 0);
    _defineProperty(this, "uuid", void 0);
    _defineProperty(this, "re", void 0);
    _defineProperty(this, "encryptedSymmetricKey", void 0);
    _defineProperty(this, "foreignKey", void 0);
    _defineProperty(this, "publicKey", void 0);
    this.uuid = uuid || String(new _Uuid.Uuid());
    Object.assign(this, {
      content: content,
      sender: sender,
      re: re,
      foreignKey: foreignKey,
      publicKey: publicKey
    });
  }
  _createClass(CryptoMessage, [{
    key: "createReply",
    value: function createReply(content) {
      const getSymmetricKey = window.crypto.subtle.generateKey({
        name: "AES-GCM",
        length: 256
      }, true, ["encrypt", "decrypt"]);
      const exportSymmetricKey = getSymmetricKey.then(symmetricKey => window.crypto.subtle.exportKey('raw', symmetricKey));
      const iv = window.crypto.getRandomValues(new Uint8Array(12));
      const encryptSymmetricKey = exportSymmetricKey.then(rawSymmetricKey => {
        const fullKey = new Uint8Array([...iv, ...new Uint8Array(rawSymmetricKey)]);
        return window.crypto.subtle.encrypt({
          name: 'RSA-OAEP'
        }, this.foreignKey, fullKey);
      });
      if (_typeof(content) === 'object') {
        console.warn('Encoding non-string value with JSON.stringify().');
        content = JSON.stringify(content);
      }
      const getContent = fetch('data:text/plain,' + content).then(r => r.arrayBuffer());
      const encryptContent = Promise.all([getSymmetricKey, getContent]).then(_ref2 => {
        let _ref3 = _slicedToArray(_ref2, 2),
          symmetricKey = _ref3[0],
          contentBuffer = _ref3[1];
        return window.crypto.subtle.encrypt({
          name: 'AES-GCM',
          iv: iv
        }, symmetricKey, contentBuffer);
      });
      const exportPublicKey = window.crypto.subtle.exportKey('spki', this.publicKey);
      return Promise.all([encryptContent, encryptSymmetricKey, exportPublicKey]).then(_ref4 => {
        let _ref5 = _slicedToArray(_ref4, 3),
          encryptedContent = _ref5[0],
          encryptedSymmetricKey = _ref5[1],
          publicKey = _ref5[2];
        return new _CryptoReply.CryptoReply({
          packet: btoa(String.fromCharCode(...new Uint8Array(encryptedContent))),
          key: btoa(String.fromCharCode(...new Uint8Array(encryptedSymmetricKey))),
          pub: btoa(String.fromCharCode(...new Uint8Array(publicKey))),
          uuid: this.uuid,
          to: this.sender,
          re: this.re
        });
      });
    }
  }]);
  return CryptoMessage;
}();
exports.CryptoMessage = CryptoMessage;
});

;require.register("network/CryptoMessageService.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CryptoMessageService = void 0;
var _CryptoMessage = require("./CryptoMessage");
var _Uuid = require("curvature/base/Uuid");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let CryptoMessageService = /*#__PURE__*/function () {
  function CryptoMessageService() {
    _classCallCheck(this, CryptoMessageService);
    _defineProperty(this, "requests", new Map());
  }
  _createClass(CryptoMessageService, [{
    key: "invite",
    value: function invite(to) {
      const uuid = String(new _Uuid.Uuid());
      const generateKeyPair = window.crypto.subtle.generateKey({
        name: 'RSA-OAEP',
        modulusLength: 2048,
        publicExponent: new Uint8Array([1, 0, 1]),
        hash: 'SHA-256'
      }, true, ['encrypt', 'decrypt']);
      generateKeyPair.then(keyPair => this.requests.set(uuid, {
        keyPair: keyPair
      }));
      return generateKeyPair.then(keyPair => window.crypto.subtle.exportKey('spki', keyPair.publicKey)).then(publicKey => ({
        pub: btoa(String.fromCharCode(...new Uint8Array(publicKey))),
        uuid: uuid,
        to: to
      }));
    }
  }, {
    key: "accept",
    value: function accept(message) {
      const rawForeignKey = message.content.pub;
      const messageUuid = message.content.uuid;
      const replyToUuid = message.content.re;
      const sender = message.sender;
      const uuid = String(new _Uuid.Uuid());
      const importForeignKey = fetch('data:text/plain;base64,' + rawForeignKey).then(response => response.arrayBuffer()).then(foreignKey => {
        return window.crypto.subtle.importKey("spki", foreignKey, {
          name: "RSA-OAEP",
          hash: "SHA-256"
        }, true, ["encrypt"]);
      });
      const generateKeyPair = window.crypto.subtle.generateKey({
        name: 'RSA-OAEP',
        modulusLength: 2048,
        publicExponent: new Uint8Array([1, 0, 1]),
        hash: 'SHA-256'
      }, true, ['encrypt', 'decrypt']);
      generateKeyPair.then(keyPair => this.requests.set(uuid, {
        keyPair: keyPair
      }));
      let decryptContent = Promise.resolve();
      if (message.content.key && this.requests.has(replyToUuid)) {
        const request = this.requests.get(replyToUuid);
        const rawForeignSymmetricKey = message.content.key;
        const rawForeignIv = message.content.iv;
        const rawContent = message.content.packet;
        this.requests.delete(replyToUuid);
        const decryptForeignSymmetricKey = fetch('data:text/plain;base64,' + rawForeignSymmetricKey).then(response => response.arrayBuffer()).then(foreignSymmetricKey => {
          return window.crypto.subtle.decrypt({
            name: "RSA-OAEP"
          }, request.keyPair.privateKey, foreignSymmetricKey);
        }).then(buffer => {
          const fullKey = new Uint8Array(buffer);
          const iv = fullKey.slice(0, 12);
          const key = fullKey.slice(12);
          const importForeignSymmetricKey = window.crypto.subtle.importKey('raw', key, {
            name: "AES-GCM",
            length: 256
          }, true, ["decrypt"]);
          return Promise.all([importForeignSymmetricKey, iv]);
        });
        const fetchContent = fetch('data:text/plain;base64,' + rawContent).then(response => response.arrayBuffer());
        decryptContent = Promise.all([decryptForeignSymmetricKey, fetchContent]).then(_ref => {
          let _ref2 = _slicedToArray(_ref, 2),
            foreignSymmetricKey = _ref2[0],
            content = _ref2[1];
          return window.crypto.subtle.decrypt({
            name: "AES-GCM",
            iv: foreignSymmetricKey[1]
          }, foreignSymmetricKey[0], content);
        }).then(contentBuffer => {
          const blob = new Blob([contentBuffer], {
            type: 'text/plain; charset=utf-8'
          });
          return blob.text();
        });
      }
      return Promise.all([generateKeyPair, importForeignKey, decryptContent]).then(_ref3 => {
        let _ref4 = _slicedToArray(_ref3, 3),
          publicKey = _ref4[0].publicKey,
          foreignKey = _ref4[1],
          content = _ref4[2];
        return new _CryptoMessage.CryptoMessage({
          uuid: uuid,
          foreignKey: foreignKey,
          publicKey: publicKey,
          content: content,
          sender: sender,
          re: messageUuid
        });
      });
    }
  }]);
  return CryptoMessageService;
}();
exports.CryptoMessageService = CryptoMessageService;
});

;require.register("network/CryptoReply.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CryptoReply = void 0;
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let CryptoReply = /*#__PURE__*/_createClass(function CryptoReply(_ref) {
  let packet = _ref.packet,
    label = _ref.label,
    uuid = _ref.uuid,
    key = _ref.key,
    pub = _ref.pub,
    re = _ref.re,
    to = _ref.to;
  _classCallCheck(this, CryptoReply);
  _defineProperty(this, "packet", void 0);
  _defineProperty(this, "label", void 0);
  _defineProperty(this, "uuid", void 0);
  _defineProperty(this, "key", void 0);
  _defineProperty(this, "pub", void 0);
  _defineProperty(this, "re", void 0);
  _defineProperty(this, "to", void 0);
  Object.assign(this, {
    packet: packet,
    label: label,
    uuid: uuid,
    key: key,
    pub: pub,
    re: re,
    to: to
  });
});
exports.CryptoReply = CryptoReply;
});

;require.register("network/Lobby.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Lobby = void 0;
var _View2 = require("curvature/base/View");
var _Uuid = require("curvature/base/Uuid");
var _Bag = require("curvature/base/Bag");
var _LobbyMessage = require("./LobbyMessage");
var _LobbyStatus = require("./LobbyStatus");
var _CryptoMessageService = require("./CryptoMessageService");
var _Bgm = require("../audio/Bgm");
var _Sfx = require("../audio/Sfx");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let Lobby = /*#__PURE__*/function (_View) {
  _inherits(Lobby, _View);
  var _super = _createSuper(Lobby);
  function Lobby(args, parent) {
    var _this;
    _classCallCheck(this, Lobby);
    _this = _super.call(this, args, parent);
    _defineProperty(_assertThisInitialized(_this), "template", require('./lobby.html'));
    _defineProperty(_assertThisInitialized(_this), "messageService", new _CryptoMessageService.CryptoMessageService());
    _defineProperty(_assertThisInitialized(_this), "floodControl", new Map());
    _defineProperty(_assertThisInitialized(_this), "requests", new Map());
    _defineProperty(_assertThisInitialized(_this), "users", new Map());
    _defineProperty(_assertThisInitialized(_this), "serverCandidates", new Set());
    _defineProperty(_assertThisInitialized(_this), "clientCandidates", new Set());
    _defineProperty(_assertThisInitialized(_this), "isClient", null);
    _defineProperty(_assertThisInitialized(_this), "sortByName", (a, b) => a.username.localeCompare(b.username));
    _defineProperty(_assertThisInitialized(_this), "sortByTime", (a, b) => b.lastSeen - a.lastSeen);
    _defineProperty(_assertThisInitialized(_this), "sorting", false);
    _this.refreshRtc();
    _this.args.roomId = _this.args.roomId || '!hJzXrccruagKGXTFUQ:matrix.org';
    _this.args.invites = new _Bag.Bag();
    _this.args.loading = true;
    _this.args.userList = [];
    ;
    _this.args.users = new _Bag.Bag((i, a, s) => {
      _this.sortUsers();
    });
    _this.args.motd = 'Welcome to the Sonic 3000 test lobby! We\'re still building and testing, so check back soon for updates. Click a user\'s name on the left to send an invite.';
    _this.args.messages = [];
    parent.matrixConnect().then(matrix => {
      _this.matrix = matrix;
      _this.matrix.putEvent(_this.args.roomId, 'sonic-3000.lobby.step-in', {});
      matrix.whoAmI().then(userId => {
        _this.user = userId;
        _this.args.username = userId.user_id;
      });
      const controller = matrix.listenForRoomEvents(_this.args.roomId);
      _this.onRemove(() => controller.cancelled = true);
      matrix.joinRoom(_this.args.roomId);

      // this.listen(matrix, 'matrix-event', event => console.log(event.detail.type, event));
      _this.listen(matrix, 'sonic-3000.lobby.message', event => _this.handleLobbyMessage(event));
      _this.listen(matrix, 'sonic-3000.lobby.step-out', event => _this.handleLobbyStepOut(event));
      _this.listen(matrix, 'sonic-3000.lobby.step-in', event => _this.handleLobbyStepIn(event));
      _this.listen(matrix, 'sonic-3000.lobby.crypto-game-invite', event => _this.handleCryptoGameInvite(event));
      _this.listen(matrix, 'sonic-3000.lobby.crypto-game-offer', event => _this.handleCryptoGameOffer(event));
      _this.listen(matrix, 'sonic-3000.lobby.crypto-game-accept', event => _this.handleCryptoGameAccept(event));
      _this.listen(matrix, 'sonic-3000.lobby.crypto-game-reject', event => _this.handleCryptoGameReject(event));
      _this.listen(matrix, 'sonic-3000.lobby.crypto-candidate-invite', event => _this.handleCryptoCandidateInvite(event));
      _this.listen(matrix, 'sonic-3000.lobby.crypto-candidate-present', event => _this.handleCryptoCandidatePresent(event));
      _this.listen(matrix, 'sonic-3000.lobby.crypto-candidate-ack', event => _this.handleCryptoCandidateAck(event));
      _this.listen(window, 'unload', event => {
        _this.matrix.putEvent(_this.args.roomId, 'sonic-3000.lobby.step-out', {});
      });
      _this.listen(matrix, 'matrix-event', event => {
        if (!event.detail.sender) {
          return;
        }
        _this.checkEventSender(event.detail);
        _this.sortUsers();
      });
      const sync = matrix.syncRoomHistory(_this.args.roomId, message => {
        if (_this.removed) {
          return false;
        }
        if (!message.sender) {
          return;
        }
        if (message.type !== 'sonic-3000.lobby.message') {
          return;
        }
        if (message.origin_server_ts < 1664651274000) {
          _this.args.loading = false;
          return;
        }
        if (!message.content.body) {
          return;
        }
        if (_this.args.messages.length <= 3) {
          _Sfx.Sfx.play('READY_TONE');
        }
        _this.handleLobbyMessage({
          detail: message
        }, _assertThisInitialized(_this));
      }, Date.now() - 7 * 24 * 60 * 60 * 1000, null, {
        types: ['sonic-3000.lobby.message']
        // types: ['sonic-3000.lobby.*']
        // types: ['sonic-3000.*']
        // types: ['*']
        // , not_types: [
        // 	'sonic-3000.lobby.step-out'
        // 	, 'sonic-3000.lobby.step-in'
        // 	, 'sonic-3000.lobby.crypto-game-invite'
        // 	, 'sonic-3000.lobby.crypto-game-offer'
        // 	, 'sonic-3000.lobby.crypto-game-accept'
        // 	, 'sonic-3000.lobby.crypto-game-reject'
        // 	, 'sonic-3000.lobby.crypto-candidate-invite'
        // 	, 'sonic-3000.lobby.crypto-candidate-present'
        // 	, 'sonic-3000.lobby.crypto-candidate-ack'
        // ]
      });

      const syncUsers = matrix.syncRoomHistory(_this.args.roomId, message => {
        if (_this.removed) {
          return false;
        }
        if (!message.sender) {
          return;
        }
        _this.checkEventSender(message);
      }, Date.now() - 7 * 24 * 60 * 60 * 1000, null
      // , {
      // 	// types: ['sonic-3000.lobby.message']
      // 	// types: ['sonic-3000.lobby.*']
      // 	// types: ['sonic-3000.*']
      // 	// types: ['*']
      // 	types: [
      // 		'sonic-3000.lobby.step-out'
      // 		, 'sonic-3000.lobby.step-in'
      // 		, 'sonic-3000.lobby.crypto-game-invite'
      // 		, 'sonic-3000.lobby.crypto-game-offer'
      // 		, 'sonic-3000.lobby.crypto-game-accept'
      // 		, 'sonic-3000.lobby.crypto-game-reject'
      // 		, 'sonic-3000.lobby.crypto-candidate-invite'
      // 		, 'sonic-3000.lobby.crypto-candidate-present'
      // 		, 'sonic-3000.lobby.crypto-candidate-ack'
      // 	]
      // }
      );

      Promise.all([sync, syncUsers]).then(() => _this.args.loading = false);
    });
    _this.args.input = '';
    return _this;
  }
  _createClass(Lobby, [{
    key: "input",
    value: function input() {}
  }, {
    key: "onAttached",
    value: function onAttached() {
      _Bgm.Bgm.fadeOut(250);
      this.onTimeout(250, () => _Bgm.Bgm.stop());
    }
  }, {
    key: "checkEventSender",
    value: function checkEventSender(message) {
      const sender = message.sender;
      const _sender$slice$split = sender.slice(1).split(':'),
        _sender$slice$split2 = _slicedToArray(_sender$slice$split, 2),
        username = _sender$slice$split2[0],
        host = _sender$slice$split2[1];
      if (!this.users.has(sender)) {
        const user = {
          id: sender,
          lastSeen: 0,
          username: username,
          host: host
        };
        this.users.set(sender, user);
        this.args.users.add(user);
        this.sortUsers();
      }
      const user = this.users.get(sender);
      user.lastSeen = Math.max(user.lastSeen, message.origin_server_ts);
    }
  }, {
    key: "sendMessage",
    value: function sendMessage(event) {
      if (!this.args.input) {
        return;
      }
      if (!this.args.input.trim()) {
        return;
      }
      this.matrix.putEvent(this.args.roomId, 'sonic-3000.lobby.message', {
        msgtype: 'm.text',
        body: this.args.input
      }).then(response => this.args.input = '').catch(error => console.error(error)).finally(() => {
        this.tags.input.focus();
        _Sfx.Sfx.play('WAIT_TONE');
      });
    }
  }, {
    key: "logOut",
    value: function logOut(event) {
      this.matrix.putEvent(this.args.roomId, 'sonic-3000.lobby.step-out', {});
      this.matrix.logOut();
      this.remove();
    }
  }, {
    key: "keyup",
    value: function keyup(event) {
      if (event.key !== 'Enter') {
        return;
      }
      this.sendMessage(event);
    }
  }, {
    key: "sendCryptoGameInvite",
    value: function sendCryptoGameInvite(event, _ref) {
      let to = _ref.id;
      this.refreshRtc();
      this.messageService.invite(to).then(invitation => this.matrix.putEvent(this.args.roomId, 'sonic-3000.lobby.crypto-game-invite', invitation)).then(response => {
        this.args.messages.push(new _LobbyStatus.LobbyStatus({
          message: `You invited ${to} to play!`,
          time: String(new Date(event.detail.origin_server_ts))
        }));
        this.onNextFrame(() => this.tags.scroller.scrollTop = this.tags.scroller.scrollHeight);
      }).catch(error => console.error(error)).finally(() => this.tags.input.focus());
    }
  }, {
    key: "handleCryptoGameInvite",
    value: function handleCryptoGameInvite(event) {
      if (!this.user || event.detail.content.to !== this.user.user_id) {
        return;
      }
      if (!this.floodControl.has(event.detail.sender)) {
        this.floodControl.set(event.detail.sender, {});
      }
      const floodControl = this.floodControl.get(event.detail.sender);
      if (floodControl.invite && Date.now() - floodControl.invite < 15000) {
        this.rejectCryptoGameInvite(event, event.detail, 'flood_control', true);
        return;
      }
      _Sfx.Sfx.play('KNOCK_PLATFORM');
      this.args.messages.push(new _LobbyStatus.LobbyStatus({
        message: `${event.detail.sender} invited you to play!`,
        time: String(new Date(event.detail.origin_server_ts))
      }));
      this.onNextFrame(() => this.tags.scroller.scrollTop = this.tags.scroller.scrollHeight);
      this.args.invites.add(event.detail);
      floodControl.invite = Date.now();
    }
  }, {
    key: "acceptCryptoGameInvite",
    value: function acceptCryptoGameInvite(event, invite) {
      this.args.invites.delete(invite);
      const replyToUuid = invite.content.uuid;
      const replyToUser = invite.sender;
      this.args.messages.push(new _LobbyStatus.LobbyStatus({
        message: `You accepted the invite from ${invite.sender}!`
      }));
      this.onNextFrame(() => this.tags.scroller.scrollTop = this.tags.scroller.scrollHeight);
      this.isClient = true;
      const getIceCandidates = this.client.getIceCandidates();

      // getIceCandidates.then(candidates => console.log(candidates));

      this.messageService.accept(invite).then(cryptoMessage => {
        Promise.all([getIceCandidates, this.client.offer()]).then(_ref2 => {
          let _ref3 = _slicedToArray(_ref2, 2),
            candidates = _ref3[0],
            token = _ref3[1];
          return cryptoMessage.createReply(JSON.stringify({
            candidates: candidates,
            token: token
          }));
        }).then(reply => this.matrix.putEvent(this.args.roomId, 'sonic-3000.lobby.crypto-game-offer', reply));
      });
      this.onTimeout(200, () => this.args.showInvites = 'hide-invites');
      this.args.showInvites = 'hiding-invites';
      _Sfx.Sfx.play('STAR_TWINKLE');
    }
  }, {
    key: "rejectCryptoGameInvite",
    value: function rejectCryptoGameInvite(event, invite) {
      let reason = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
      let silent = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      this.args.invites.delete(invite);
      const replyToUuid = invite.content.uuid;
      const replyToUser = invite.sender;
      if (!silent) {
        this.args.messages.push(new _LobbyStatus.LobbyStatus({
          message: `You rejected the invite from ${invite.sender}.`,
          time: String(new Date(event.detail.origin_server_ts))
        }));
        this.onNextFrame(() => this.tags.scroller.scrollTop = this.tags.scroller.scrollHeight);
      }
      this.messageService.accept(invite).then(cryptoMessage => {
        cryptoMessage.createReply(reason).then(reply => this.matrix.putEvent(this.args.roomId, 'sonic-3000.lobby.crypto-game-reject', reply));
      });
      if (!silent) {
        this.onTimeout(200, () => this.args.showInvites = 'hide-invites');
        this.args.showInvites = 'hiding-invites';
        _Sfx.Sfx.play('OBJECT_DESTROYED');
      }
    }
  }, {
    key: "handleCryptoGameOffer",
    value: function handleCryptoGameOffer(event) {
      if (!this.user || event.detail.content.to !== this.user.user_id) {
        return;
      }
      const message = event.detail;
      const replyToUuid = message.content.uuid;
      const replyToUser = message.sender;
      this.messageService.accept(message).then(cryptoMessage => {
        this.args.messages.push(new _LobbyStatus.LobbyStatus({
          message: `Initializing RTC handshake...`,
          time: String(new Date(event.detail.origin_server_ts))
        }));
        this.onNextFrame(() => this.tags.scroller.scrollTop = this.tags.scroller.scrollHeight);
        let offerString = cryptoMessage.content;
        const isEncoded = /^s3ktp:\/\/request\/(.+)/.exec(offerString);
        if (isEncoded) {
          offerString = atob(isEncoded[1]);
        }
        const _JSON$parse = JSON.parse(offerString),
          offer = _JSON$parse.token,
          remoteCandidates = _JSON$parse.candidates;
        const answer = this.server.answer(offer);
        answer.then(() => {
          remoteCandidates.map(c => this.server.addIceCandidate(c));
        });
        Promise.all([this.server.getIceCandidates(), answer]).then(_ref4 => {
          let _ref5 = _slicedToArray(_ref4, 2),
            candidates = _ref5[0],
            offer = _ref5[1];
          // console.log(candidates);
          cryptoMessage.createReply(JSON.stringify({
            candidates: candidates,
            token: offer
          })).then(reply => this.matrix.putEvent(this.args.roomId, 'sonic-3000.lobby.crypto-game-accept', reply));
        });
        this.args.messages.push(new _LobbyStatus.LobbyStatus({
          message: `${message.sender} accepted your invite!`,
          time: String(new Date(message.origin_server_ts))
        }));
        _Sfx.Sfx.play('STAR_TWINKLE');
        this.onNextFrame(() => this.tags.scroller.scrollTop = this.tags.scroller.scrollHeight);
      });
    }
  }, {
    key: "handleCryptoGameAccept",
    value: function handleCryptoGameAccept(event) {
      if (!this.user || event.detail.content.to !== this.user.user_id) {
        return;
      }
      const message = event.detail;
      const replyToUuid = message.content.uuid;
      const replyToUser = message.sender;
      this.messageService.accept(message).then(cryptoMessage => {
        const _JSON$parse2 = JSON.parse(cryptoMessage.content),
          token = _JSON$parse2.token,
          candidates = _JSON$parse2.candidates;
        this.client.accept(token).then(() => candidates.map(c => this.client.addIceCandidate(c)));
      });

      // this.args.messages.push(new LobbyStatus({message: `Completing RTC handshake...`}));
    }
  }, {
    key: "handleCryptoGameReject",
    value: function handleCryptoGameReject(event) {
      if (!this.user || event.detail.content.to !== this.user.user_id) {
        return;
      }
      const message = event.detail;
      const replyToUuid = message.content.uuid;
      const replyToUser = message.sender;
      this.messageService.accept(message).then(cryptoMessage => {
        let message = `${event.detail.sender} rejected your invite.`;
        if (cryptoMessage.content) {
          message = `${event.detail.sender} rejected your invite: (${cryptoMessage.content})`;
        }
        this.args.messages.push(new _LobbyStatus.LobbyStatus({
          message: message
        }));
        this.onNextFrame(() => this.tags.scroller.scrollTop = this.tags.scroller.scrollHeight);
      });
    }
  }, {
    key: "handleLobbyMessage",
    value: function handleLobbyMessage(_ref6) {
      let message = _ref6.detail;
      let fromSync = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      if (message.room_id !== this.args.roomId || !message.content.body) {
        return;
      }
      this.checkEventSender(message);
      const user = this.users.get(message.sender);
      this.args.messages[fromSync ? 'unshift' : 'push'](new _LobbyMessage.LobbyMessage({
        message: message.content.body,
        time: String(new Date(message.origin_server_ts)),
        user: user
      }));
      this.onNextFrame(() => this.tags.scroller.scrollTop = this.tags.scroller.scrollHeight);
      if (message.sender !== this.args.username) {
        if (!fromSync || this.args.messages.length <= 3) {
          _Sfx.Sfx.play('READY_TONE');
        }
      }
    }
  }, {
    key: "refreshRtc",
    value: function refreshRtc() {
      const newServer = !this.server; // || this.server.peerServer.connectionState === 'closed';
      const newClient = !this.client; // || this.client.peerClient.connectionState === 'closed';

      this.server = this.server || this.parent.getServer();
      this.client = this.client || this.parent.getClient();
      const server = this.server;
      const client = this.client;
      const onOpen = event => {
        console.log('Connection Opened!');
        this.parent.loadMap({
          mapUrl: '/map/emerald-isle.json',
          networked: true
        });
        this.remove();
      };
      const onClose = event => this.disconnect();
      if (newServer) {
        server.addEventListener('open', onOpen, {
          once: true
        });
        server.addEventListener('close', onClose, {
          once: true
        });
      }
      if (newClient) {
        client.addEventListener('open', onOpen, {
          once: true
        });
        client.addEventListener('close', onClose, {
          once: true
        });
      }

      // server.addEventListener('icecandidate', event => console.log(event.originalEvent.candidate));
      // client.addEventListener('icecandidate', event => console.log(event.originalEvent.candidate));
    }
  }, {
    key: "toggleMenu",
    value: function toggleMenu() {
      if (!this.args.showMenu || this.args.showMenu == 'hide-menu') {
        this.onTimeout(200, () => this.args.showMenu = 'show-menu');
        this.args.showMenu = 'showing-menu';
      } else {
        this.onTimeout(200, () => this.args.showMenu = 'hide-menu');
        this.args.showMenu = 'hiding-menu';
      }
    }
  }, {
    key: "toggleInvites",
    value: function toggleInvites() {
      if (!this.args.showInvites || this.args.showInvites == 'hide-invites') {
        this.onTimeout(200, () => this.args.showInvites = 'show-invites');
        this.args.showInvites = 'showing-invites';
      } else {
        this.onTimeout(200, () => this.args.showInvites = 'hide-invites');
        this.args.showInvites = 'hiding-invites';
      }
    }
  }, {
    key: "disconnect",
    value: function disconnect() {
      this.server.close();
      this.client.close();
      this.refreshRtc();
      if (this.parent.args.started) {
        this.parent.quit(2);
      }
      this.parent.args.networked = false;
      this.parent.args.chatBox = null;
    }
  }, {
    key: "sortUsers",
    value: function sortUsers() {
      let type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      switch (type) {
        case 'abc':
          this.userSorter = this.sortByName;
          break;
        case 'time':
          this.userSorter = this.sortByTime;
          break;
      }
      if (this.sorting) {
        return;
      }
      this.sorting = true;
      this.onTimeout(100, () => {
        const userList = this.args.users.items();
        userList.sort(this.userSorter || this.sortByTime);
        this.args.userList = userList;
        this.sorting = false;
      });
    }
  }, {
    key: "closeMotd",
    value: function closeMotd(event) {
      this.args.motdClosed = 'closed';
    }
  }, {
    key: "handleLobbyStepOut",
    value: function handleLobbyStepOut(event) {
      this.args.messages.push(new _LobbyStatus.LobbyStatus({
        message: `${event.detail.sender} stepped out.`,
        time: String(new Date(event.detail.origin_server_ts))
      }));
      this.onNextFrame(() => this.tags.scroller.scrollTop = this.tags.scroller.scrollHeight);
      _Sfx.Sfx.play('MECHASONIC_SLAP');
    }
  }, {
    key: "handleLobbyStepIn",
    value: function handleLobbyStepIn(event) {
      this.args.messages.push(new _LobbyStatus.LobbyStatus({
        message: `${event.detail.sender} stepped in.`,
        time: String(new Date(event.detail.origin_server_ts))
      }));
      this.onNextFrame(() => this.tags.scroller.scrollTop = this.tags.scroller.scrollHeight);
      _Sfx.Sfx.play('SS_BWIP_HIGH');
    }
  }]);
  return Lobby;
}(_View2.View);
exports.Lobby = Lobby;
});

;require.register("network/LobbyInvite.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LobbyInvite = void 0;
var _View2 = require("curvature/base/View");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let LobbyInvite = /*#__PURE__*/function (_View) {
  _inherits(LobbyInvite, _View);
  var _super = _createSuper(LobbyInvite);
  function LobbyInvite() {
    var _this;
    _classCallCheck(this, LobbyInvite);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _defineProperty(_assertThisInitialized(_this), "template", '<div class = "lobby-invite">invite!</div>');
    return _this;
  }
  return _createClass(LobbyInvite);
}(_View2.View);
exports.LobbyInvite = LobbyInvite;
});

;require.register("network/LobbyMessage.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LobbyMessage = void 0;
var _View2 = require("curvature/base/View");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let LobbyMessage = /*#__PURE__*/function (_View) {
  _inherits(LobbyMessage, _View);
  var _super = _createSuper(LobbyMessage);
  function LobbyMessage() {
    var _this;
    _classCallCheck(this, LobbyMessage);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _defineProperty(_assertThisInitialized(_this), "template", `<span title = "[[user.id]] [[time]]" class = "username">&lt;<b>[[user.username]]</b>&gt;</span>:&nbsp;<span class = "message" cv-bind = "message"></span>`);
    _defineProperty(_assertThisInitialized(_this), "preserve", true);
    return _this;
  }
  return _createClass(LobbyMessage);
}(_View2.View);
exports.LobbyMessage = LobbyMessage;
});

;require.register("network/LobbyStatus.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LobbyStatus = void 0;
var _View2 = require("curvature/base/View");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let LobbyStatus = /*#__PURE__*/function (_View) {
  _inherits(LobbyStatus, _View);
  var _super = _createSuper(LobbyStatus);
  function LobbyStatus() {
    var _this;
    _classCallCheck(this, LobbyStatus);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _defineProperty(_assertThisInitialized(_this), "template", '<span class = "lobby-status-message" title = [[time]] cv-bind = "message"></span>');
    _defineProperty(_assertThisInitialized(_this), "preserve", true);
    return _this;
  }
  return _createClass(LobbyStatus);
}(_View2.View);
exports.LobbyStatus = LobbyStatus;
});

;require.register("network/Rtc.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Rtc = void 0;
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
let Rtc = /*#__PURE__*/_createClass(function Rtc() {
  _classCallCheck(this, Rtc);
});
exports.Rtc = Rtc;
});

;require.register("network/RtcClient.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RtcClient = void 0;
var _Mixin = require("curvature/base/Mixin");
var _EventTargetMixin = require("curvature/mixin/EventTargetMixin");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let RtcClient = /*#__PURE__*/function (_Mixin$with) {
  _inherits(RtcClient, _Mixin$with);
  var _super = _createSuper(RtcClient);
  function RtcClient(rtcConfig) {
    var _this;
    _classCallCheck(this, RtcClient);
    _this = _super.call(this);
    _defineProperty(_assertThisInitialized(_this), "candidateTimeout", 500);
    _this.peerClient = new RTCPeerConnection(rtcConfig);
    _this.peerClientChannel = _this.peerClient.createDataChannel("chat");
    _this.peerClientChannel.addEventListener('open', event => {
      const openEvent = new CustomEvent('open', {
        detail: event.data
      });
      openEvent.originalEvent = event;
      _this.dispatchEvent(openEvent);
      _this.connected = true;
    });
    _this.peerClientChannel.addEventListener('close', event => {
      const closeEvent = new CustomEvent('close', {
        detail: event.data
      });
      closeEvent.originalEvent = event;
      _this.dispatchEvent(closeEvent);
      _this.connected = false;
    });
    _this.peerClientChannel.addEventListener('message', event => {
      const messageEvent = new CustomEvent('message', {
        detail: event.data
      });
      messageEvent.originalEvent = event;
      _this.dispatchEvent(messageEvent);
    });
    _this.peerClient.addEventListener('icecandidate', event => {
      const messageEvent = new CustomEvent('icecandidate', {
        detail: event.data
      });
      messageEvent.originalEvent = event;
      _this.dispatchEvent(messageEvent);
    });
    return _this;
  }
  _createClass(RtcClient, [{
    key: "send",
    value: function send(input) {
      if (!this.peerClientChannel) {
        return;
      }
      if (this.peerClientChannel.readyState !== 'open') {
        return;
      }
      this.peerClientChannel.send(input);
    }
  }, {
    key: "close",
    value: function close() {
      return this.peerClient.close();
    }
  }, {
    key: "getIceCandidates",
    value: function getIceCandidates() {
      const candidates = new Set();
      return new Promise(accept => this.peerClient.addEventListener('icecandidate', event => {
        candidates.add(event.candidate);
        if (!event.candidate) {
          accept([...candidates]);
          return;
        }
      }));
    }
  }, {
    key: "addIceCandidate",
    value: function addIceCandidate(candidate) {
      this.peerClient.addIceCandidate(candidate);
    }
  }, {
    key: "offer",
    value: function offer() {
      return this.peerClient.createOffer().then(offer => this.peerClient.setLocalDescription(offer)).then(() => this.peerClient.localDescription);
    }
  }, {
    key: "fullOffer",
    value: function fullOffer() {
      return this.offer().then(offer => this.getIceCandidates().then(candidates => ({
        offer: offer,
        candidates: candidates
      })));
    }
  }, {
    key: "accept",
    value: function accept(answer) {
      const session = new RTCSessionDescription(answer);
      return this.peerClient.setRemoteDescription(session);
    }
  }, {
    key: "fullAccept",
    value: function fullAccept(_ref) {
      let answer = _ref.answer,
        candidates = _ref.candidates;
      return this.accept(answer).then(() => candidates.map(c => this.addIceCandidate(c)));
    }
  }]);
  return RtcClient;
}(_Mixin.Mixin.with(_EventTargetMixin.EventTargetMixin));
exports.RtcClient = RtcClient;
});

;require.register("network/RtcClientTask.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RtcClientTask = void 0;
var _Task2 = require("subspace-console/Task");
var _Tag = require("curvature/base/Tag");
var _RtcClient = require("./RtcClient");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
const Accept = Symbol('accept');
let RtcClientTask = /*#__PURE__*/function (_Task) {
  _inherits(RtcClientTask, _Task);
  var _super = _createSuper(RtcClientTask);
  function RtcClientTask() {
    var _this;
    _classCallCheck(this, RtcClientTask);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _defineProperty(_assertThisInitialized(_this), "title", 'RTC Client Task');
    _defineProperty(_assertThisInitialized(_this), "connected", false);
    return _this;
  }
  _createClass(RtcClientTask, [{
    key: "init",
    value: function init() {
      this.client = new _RtcClient.RtcClient({
        iceServers: [{
          urls: 'stun:stun1.l.google.com:19302'
        }, {
          urls: 'stun:stun2.l.google.com:19302'
        }]
      });
      this.finally(() => {
        console.log('Terminating connection...');
        this.client.close();
      });
      this.client.addEventListener('open', () => {
        this.print('Remote peer client accepted!');
      });
      this.client.addEventListener('close', () => {
        this.print('Peer reset connection.');
      });
      this.client.addEventListener('message', event => {
        this.print(`> ${event.detail}`);
      });
      this.client.offerToken.then(token => {
        const tokenString = JSON.stringify(token);
        const encodedToken = `s3ktp://request/${btoa(tokenString)}`;
        this.print(`Client request code: ${encodedToken}`);
        const offerTag = new _Tag.Tag('<textarea style = "display:none">');
        offerTag.innerText = encodedToken;
        document.body.append(offerTag.node);
        offerTag.select();
        document.execCommand("copy");
        offerTag.node.remove();
      });
      return new Promise(accept => {
        this[Accept] = accept;
      });
    }
  }, {
    key: "main",
    value: function main(input) {
      if (!input) {
        return;
      }
      if (!this.client.connected) {
        this.accept(input);
        return;
      }
      this.print(`< ${input}`);
      this.client.send(input);
    }
  }, {
    key: "accept",
    value: function accept(answerString) {
      if (!answerString) {
        this.print(`Please supply server's accept string.`);
        return;
      }
      const isEncoded = /^s3ktp:\/\/accept\/(.+)/.exec(answerString);
      if (isEncoded) {
        answerString = atob(isEncoded[1]);
      }
      const answer = JSON.parse(answerString);
      this.client.accept(answer);
    }
  }]);
  return RtcClientTask;
}(_Task2.Task);
exports.RtcClientTask = RtcClientTask;
_defineProperty(RtcClientTask, "helpText", 'RTC Client.');
_defineProperty(RtcClientTask, "useText", '');
});

;require.register("network/RtcServer.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RtcServer = void 0;
var _Mixin = require("curvature/base/Mixin");
var _EventTargetMixin = require("curvature/mixin/EventTargetMixin");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let RtcServer = /*#__PURE__*/function (_Mixin$with) {
  _inherits(RtcServer, _Mixin$with);
  var _super = _createSuper(RtcServer);
  function RtcServer(rtcConfig) {
    var _this;
    _classCallCheck(this, RtcServer);
    _this = _super.call(this);
    _defineProperty(_assertThisInitialized(_this), "candidateTimeout", 500);
    _this.peerServer = new RTCPeerConnection(rtcConfig);
    _this.peerServer.addEventListener('datachannel', event => {
      _this.peerServerChannel = event.channel;
      _this.peerServerChannel.addEventListener('open', event => {
        const openEvent = new CustomEvent('open', {
          detail: event.data
        });
        openEvent.originalEvent = event;
        _this.dispatchEvent(openEvent);
        _this.connected = true;
      });
      _this.peerServerChannel.addEventListener('close', event => {
        const closeEvent = new CustomEvent('close', {
          detail: event.data
        });
        closeEvent.originalEvent = event;
        _this.dispatchEvent(closeEvent);
        _this.connected = false;
      });
      _this.peerServerChannel.addEventListener('message', event => {
        const messageEvent = new CustomEvent('message', {
          detail: event.data
        });
        messageEvent.originalEvent = event;
        _this.dispatchEvent(messageEvent);
      });
      _this.peerServerChannel.addEventListener('icecandidate', event => {
        const messageEvent = new CustomEvent('icecandidate', {
          detail: event.data
        });
        messageEvent.originalEvent = event;
        _this.dispatchEvent(messageEvent);
      });
    });
    return _this;
  }
  _createClass(RtcServer, [{
    key: "send",
    value: function send(input) {
      if (!this.peerServerChannel) {
        return;
      }
      if (this.peerServerChannel.readyState !== 'open') {
        return;
      }
      this.peerServerChannel.send(input);
    }
  }, {
    key: "close",
    value: function close() {
      return this.peerServer.close();
    }
  }, {
    key: "getIceCandidates",
    value: function getIceCandidates() {
      const candidates = new Set();
      return new Promise(accept => this.peerServer.addEventListener('icecandidate', event => {
        candidates.add(event.candidate);
        if (!event.candidate) {
          accept([...candidates]);
          return;
        }
      }));
    }
  }, {
    key: "addIceCandidate",
    value: function addIceCandidate(candidate) {
      this.peerServer.addIceCandidate(candidate);
    }
  }, {
    key: "answer",
    value: function answer(offer) {
      return this.peerServer.setRemoteDescription(offer).then(() => this.peerServer.createAnswer()).then(answer => this.peerServer.setLocalDescription(answer)).then(() => this.peerServer.localDescription);
    }
  }, {
    key: "fullAnswer",
    value: function fullAnswer(_ref) {
      let offer = _ref.offer,
        candidates = _ref.candidates;
      return this.answer(offer).then(answer => {
        return Promise.all(candidates.map(c => this.addIceCandidate(c))).then(() => {
          return this.getIceCandidates().then(candidates => {
            return {
              answer: answer,
              candidates: candidates
            };
          });
        });
      });
    }
  }]);
  return RtcServer;
}(_Mixin.Mixin.with(_EventTargetMixin.EventTargetMixin));
exports.RtcServer = RtcServer;
});

;require.register("network/RtcServerTask.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RtcServerTask = void 0;
var _Task2 = require("subspace-console/Task");
var _Tag = require("curvature/base/Tag");
var _RtcServer = require("./RtcServer");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
const Accept = Symbol('accept');
let RtcServerTask = /*#__PURE__*/function (_Task) {
  _inherits(RtcServerTask, _Task);
  var _super = _createSuper(RtcServerTask);
  function RtcServerTask() {
    var _this;
    _classCallCheck(this, RtcServerTask);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _defineProperty(_assertThisInitialized(_this), "title", 'RTC Server Task');
    _defineProperty(_assertThisInitialized(_this), "connected", false);
    return _this;
  }
  _createClass(RtcServerTask, [{
    key: "init",
    value: function init() {
      this.server = new _RtcServer.RtcServer({
        iceServers: [{
          urls: 'stun:stun1.l.google.com:19302'
        }, {
          urls: 'stun:stun2.l.google.com:19302'
        }]
      });
      this.finally(() => {
        this.print('Terminating connection...');
        this.server.close();
      });
      this.server.addEventListener('open', () => {
        this.print('Remote peer client accepted!');
      });
      this.server.addEventListener('close', () => {
        this.print('Peer reset connection.');
      });
      this.server.addEventListener('message', event => {
        this.print(`> ${event.detail}`);
      });
      this.server.answerToken.then(token => {
        const tokenString = JSON.stringify(token);
        const encodedToken = `s3ktp://accept/${btoa(tokenString)}`;
        this.print(`Server accept code: ${encodedToken}`);
        const answerTag = new _Tag.Tag('<textarea style = "display:none">');
        answerTag.innerText = encodedToken;
        document.body.append(answerTag.node);
        answerTag.select();
        document.execCommand("copy");
        answerTag.node.remove();
      });
      this.printErr(`Please supply client's request code.`);
      return new Promise(accept => {
        this[Accept] = accept;
      });
    }
  }, {
    key: "main",
    value: function main(input) {
      if (!input) {
        return;
      }
      if (!this.server.connected) {
        this.answer(input);
        return;
      }
      this.print(`< ${input}`);
      this.server.send(input);
    }
  }, {
    key: "answer",
    value: function answer(offerString) {
      const isEncoded = /^s3ktp:\/\/request\/(.+)/.exec(offerString);
      console.log(isEncoded);
      if (isEncoded) {
        offerString = atob(isEncoded[1]);
      }
      const offer = JSON.parse(offerString);
      this.server.answer(offer);
    }
  }, {
    key: "done",
    value: function done() {}
  }]);
  return RtcServerTask;
}(_Task2.Task);
exports.RtcServerTask = RtcServerTask;
_defineProperty(RtcServerTask, "helpText", 'RTC Server.');
_defineProperty(RtcServerTask, "useText", '');
});

;require.register("network/chat-box.html", function(exports, require, module) {
module.exports = "<div class = \"chatbox\" data-click-barrier>\n\n\t<div class = \"chat-output\" cv-each = \"outputLines:line\" cv-ref = \"chatOutput\">\n\t\t<p>[[line]]</p>\n\t</div>\n\n\t<div class = \"chat-input\">\n\t\t<input cv-bind = \"chatInput\" cv-ref = \"chatInput\" cv-on = \"keydown:send(event)\">\n\t\t<button cv-on = \"click:send\">send</button>\n\t</div>\n\n</div>\n"
});

;require.register("network/lobby.html", function(exports, require, module) {
module.exports = "<div class = \"lobby [[showMenu]] [[showInvites]]\" data-click-barrier>\n\n\t<div class = \"main column\">\n\t\t<div class = \"left-menu\">\n\t\t\t<div>[[username]]</div>\n\t\t\t<button cv-on = \"click:logOut\">Log Out</button>\n\t\t</div>\n\n\t\t<div class = \"topbar row\">\n\t\t\t<div class = \"row\">\n\t\t\t\t<div class = \"burger-button\" cv-on = \"click:toggleMenu\">\n\t\t\t\t\t<div class = \"stripe\"></div>\n\t\t\t\t\t<div class = \"stripe\"></div>\n\t\t\t\t\t<div class = \"stripe\"></div>\n\t\t\t\t</div>\n\t\t\t\t<div class = \"title\">\n\t\t\t\t\t#sonic-3000-test-lobby\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t\t<div>\n\t\t\t\t<div cv-on = \"click:toggleInvites\" class = \"invite button\">\n\t\t\t\t\t<div class = \"amount\" cv-if = \"invites.length\">[[invites.length]]</div>\n\t\t\t\t\t<img class = \"icon\" src = \"/icons/mail.svg\" />\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</div>\n\n\t\t<div class = \"row wide\">\n\n\t\t\t<div class = \"users frame column\">\n\t\t\t\t<div class = \"sort-buttons\">\n\t\t\t\t\t<button class = \"sort-abc\"  cv-on = 'click:sortUsers(\"abc\")'></button>\n\t\t\t\t\t<button class = \"sort-time\" cv-on = 'click:sortUsers(\"time\")'></button>\n\t\t\t\t</div>\n\t\t\t\t<div class = \"scroller\" cv-each = \"userList:user\">\n\t\t\t\t\t<div title = \"[[user.id]]\" class = \"user\" tabindex = \"0\">\n\t\t\t\t\t\t[[user.username]]\n\t\t\t\t\t\t<div class = \"user-list-buttons\">\n\t\t\t\t\t\t\t<button cv-on   = \"click:sendCryptoGameInvite(event, user)\">invite</button>\n<!-- \t\t\t\t\t\t\t<button>message</button>\n\t\t\t\t\t\t\t<button>ignore</button> -->\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t</div>\n\n\t\t\t<div class = \"messages wide column\">\n\t\t\t\t<div class = \"row motd [[motdClosed]]\">\n\t\t\t\t\t<button class=\"close-button\" cv-on = \"click:closeMotd\"></button>\n\t\t\t\t\t<span>&lt;motd&gt;: [[motd]]</span>\n\t\t\t\t</div>\n\t\t\t\t<div class = \"row wide frame\">\n\t\t\t\t\t<div class = \"scroller\" cv-ref = \"scroller\">\n\t\t\t\t\t\t<div cv-if = \"loading\">\n\t\t\t\t\t\t\t<img class = \"loader icon\" src = \"/icons/loader.svg\" />\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<div class = \"column\" cv-each = \"messages:message\">\n\t\t\t\t\t\t\t<span class = \"message\">[[message]]</span>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t\t<div class = \"row\">\n\t\t\t\t\t<input\n\t\t\t\t\t\ttype    = \"text\"\n\t\t\t\t\t\tcv-bind = \"input\"\n\t\t\t\t\t\tcv-on   = \"keyup\"\n\t\t\t\t\t\tcv-ref  = \"input\"\n\t\t\t\t\t/>\n\t\t\t\t\t<button cv-on   = \"click:sendMessage\">send</button>\n\t\t\t\t</div>\n\t\t\t</div>\n\n\t\t\t<div class = \"invites\">\n\t\t\t\t<div cv-if = \"!invites.length\">No pending invites.</div>\n\t\t\t\t<div class = \"column\" cv-each = \"invites:invite:i\">\n\t\t\t\t\t<div class = \"column\">\n\t\t\t\t\t\t<div>[[invite.sender]] invited you to play!</div>\n\t\t\t\t\t\t<div class = \"row\">\n\t\t\t\t\t\t\t<button cv-on = \"click:acceptCryptoGameInvite(event, invite)\">accept</button>\n\t\t\t\t\t\t\t<button cv-on = 'click:rejectCryptoGameInvite(event, invite, \"button_clicked\")'>reject</button>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t</div>\n\n\t\t</div>\n\t</div>\n</div>\n"
});

;require.register("particle/Particle3d.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Particle3d = void 0;
var _Tag2 = require("curvature/base/Tag");
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let Particle3d = /*#__PURE__*/function (_Tag) {
  _inherits(Particle3d, _Tag);
  var _super = _createSuper(Particle3d);
  function Particle3d() {
    var _this;
    _classCallCheck(this, Particle3d);
    _this = _super.call(this, '<div class = "particle-3d">');
    const front = new _Tag2.Tag('<div class = "front-3d">');
    const back = new _Tag2.Tag('<div class = "back-3d">');
    const left = new _Tag2.Tag('<div class = "right-3d">');
    const right = new _Tag2.Tag('<div class = "left-3d">');
    const top = new _Tag2.Tag('<div class = "top-3d">');
    const bottom = new _Tag2.Tag('<div class = "bottom-3d">');
    _this.append(back.node);
    _this.append(left.node);
    _this.append(right.node);
    _this.append(front.node);
    _this.append(top.node);
    _this.append(bottom.node);
    return _this;
  }
  return _createClass(Particle3d);
}(_Tag2.Tag);
exports.Particle3d = Particle3d;
});

;require.register("powerups/BubbleSheild.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BubbleSheild = void 0;
var _Bindable = require("curvature/base/Bindable");
var _Sheild2 = require("./Sheild");
var _Sfx = require("../audio/Sfx");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let BubbleSheild = /*#__PURE__*/function (_Sheild) {
  _inherits(BubbleSheild, _Sheild);
  var _super = _createSuper(BubbleSheild);
  function BubbleSheild() {
    var _this;
    _classCallCheck(this, BubbleSheild);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _defineProperty(_assertThisInitialized(_this), "template", `<div class = "sheild bubble-sheild [[bouncing]]"><div class = "bubble-sheild-shine"></div></div>`);
    _defineProperty(_assertThisInitialized(_this), "protect", true);
    _defineProperty(_assertThisInitialized(_this), "type", 'water');
    return _this;
  }
  _createClass(BubbleSheild, [{
    key: "unequip",
    value: function unequip(host) {
      _get(_getPrototypeOf(BubbleSheild.prototype), "unequip", this).call(this, host);
      host.args.bouncing = false;
      this.args.bouncing = false;
      this.args.force = 0;
    }
  }, {
    key: "acquire",
    value: function acquire(host) {
      const viewport = host.viewport;
      if (!viewport) {
        return;
      }
      if (host.controllable) {
        _Sfx.Sfx.play('WATER_ACQUIRE');
      }
      const invertDamage = event => {
        if (host.args.currentSheild !== _Bindable.Bindable.make(this)) {
          return;
        }
        event.preventDefault();
        const other = event.detail.other;
        other && other.pop && other.pop(host);
        this.onNextFrame(() => {
          host.args.currentSheild = null;
          host.inventory.remove(this);
        });
        host.removeEventListener('damage', invertDamage);
        host.startle(other);
      };
      host.addEventListener('damage', invertDamage);
    }
  }, {
    key: "immune",
    value: function immune(host, other) {
      let type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'normal';
      if (type === 'water' || type === 'projectile') {
        return true;
      }
      return false;
    }
  }, {
    key: "command_0",
    value: function command_0(host, button) {
      if (host.canFly && host.yAxis < 0.55) {
        return;
      }
      if (host.dashed) {
        return;
      }
      if (host.args.standingOn && host.args.standingOn.isVehicle) {
        return;
      }
      this.args.force = 10;
      if (host.args.jumping) {
        host.impulse(14, Math.PI / 2);
        this.args.bouncing = 'bouncing';
        host.args.bouncing = true;
      }
      if (host.args.falling && host.yAxis) {
        return false;
      }
    }
  }, {
    key: "hold_0",
    value: function hold_0() {
      if (this.args.bouncing && this.args.force < 25) {
        this.args.force++;
      }
    }
  }, {
    key: "update",
    value: function update(host) {
      if (host.args.ySpeed < -5) {
        this.onNextFrame(() => {
          host.args.bouncing = false;
          this.args.bouncing = false;
          this.args.force = 0;
        });
      }

      // if(host.canFly)
      // {
      // 	return;
      // }

      if (!host.args.falling) {
        if (this.args.bouncing && this.args.force) {
          // host.args.gSpeed = 0;
          // host.args.xSpeed = 0;

          this.onNextFrame(() => {
            host.args.standingOn = null;
            host.args.bouncing = false;
            host.args.falling = true;
            host.args.jumping = true;
            host.impulse(this.args.force, -Math.PI / 2, true);
          });
          this.args.bouncing = '';
          _Sfx.Sfx.play('WATER_BOUNCE');
          if (host.viewport.settings.rumble) {
            host.controller.rumble({
              duration: 200,
              strongMagnitude: 1.0,
              weakMagnitude: 1.0
            });
          }
        }
      }
    }
  }]);
  return BubbleSheild;
}(_Sheild2.Sheild);
exports.BubbleSheild = BubbleSheild;
});

;require.register("powerups/ElectricSheild.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ElectricSheild = void 0;
var _Bindable = require("curvature/base/Bindable");
var _Sheild2 = require("./Sheild");
var _Sfx = require("../audio/Sfx");
var _Tag = require("curvature/base/Tag");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let ElectricSheild = /*#__PURE__*/function (_Sheild) {
  _inherits(ElectricSheild, _Sheild);
  var _super = _createSuper(ElectricSheild);
  function ElectricSheild() {
    var _this;
    _classCallCheck(this, ElectricSheild);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _defineProperty(_assertThisInitialized(_this), "template", `<div class = "sheild electric-sheild [[boosted]]"></div>`);
    _defineProperty(_assertThisInitialized(_this), "protect", true);
    _defineProperty(_assertThisInitialized(_this), "type", 'electric');
    _defineProperty(_assertThisInitialized(_this), "jumps", 3);
    _defineProperty(_assertThisInitialized(_this), "attract", new Set());
    _defineProperty(_assertThisInitialized(_this), "magnetism", 0.25);
    _defineProperty(_assertThisInitialized(_this), "magnetTimeout", false);
    _defineProperty(_assertThisInitialized(_this), "particles", new Set());
    return _this;
  }
  _createClass(ElectricSheild, [{
    key: "acquire",
    value: function acquire(host) {
      const viewport = host.viewport;
      if (!viewport) {
        return;
      }
      if (host.controllable) {
        _Sfx.Sfx.play('ELECTRIC_ACQUIRE');
      }
      const invertDamage = event => {
        if (host.args.currentSheild !== _Bindable.Bindable.make(this)) {
          return;
        }
        event.preventDefault();
        const other = event.detail.other;
        if (this.immune(host, other, event.detail.type)) {
          event.detail.immune = true;
          return;
        }
        other && other.damage && other.damage(host, 'electric');
        this.onNextFrame(() => {
          host.args.currentSheild = null;
          host.inventory.remove(this);
        });
        host.removeEventListener('damage', invertDamage);
        host.startle(other);
      };
      host.addEventListener('damage', invertDamage);
    }
  }, {
    key: "immune",
    value: function immune(host, other) {
      let type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'normal';
      if (type === 'electric' || type === 'projectile') {
        return true;
      }
      return false;
    }
  }, {
    key: "command_0",
    value: function command_0(host, button) {
      if (!host.args.falling) {
        return;
      }
      if (host.canFly && (Math.abs(host.yAxis) < 0.55 || host.args.flying)) {
        return;
      }
      if (this.jumps > 0 && host.args.jumping) {
        host.args.ySpeed = 0;
        host.impulse(10, -Math.PI / 2);
        this.jumps--;

        // this.args.boosted = 'boosted';

        this.onTimeout(250, () => this.args.boosted = '');
        _Sfx.Sfx.play('ELECTRIC_JUMP');
        if (host.xAxis && Math.sign(host.xAxis) !== Math.sign(host.args.xSpeed)) {
          host.args.xSpeed = 1 * host.xAxis;
        }
        viewport = host.viewport;
        if (!viewport) {
          return;
        }
        const sparkParticleL = new _Tag.Tag(document.createElement('div'));
        const sparkParticleR = new _Tag.Tag(document.createElement('div'));
        sparkParticleL.classList.add('particle-electric-jump-spark');
        sparkParticleR.classList.add('particle-electric-jump-spark');
        sparkParticleL.style({
          '--x': host.args.x,
          '--y': host.args.y - 30,
          'z-index': 0
        });
        sparkParticleR.style({
          '--x': host.args.x,
          '--y': host.args.y - 30,
          'z-index': 0
        });
        sparkParticleL.age = 0;
        sparkParticleL.y = host.args.y - 30;
        sparkParticleL.x = host.args.x;
        sparkParticleL.d = -1;
        sparkParticleR.age = 0;
        sparkParticleR.y = host.args.y - 30;
        sparkParticleR.x = host.args.x;
        sparkParticleR.d = 1;
        viewport.particles.add(sparkParticleL);
        viewport.particles.add(sparkParticleR);
        viewport.onFrameOut(200, () => viewport.particles.remove(sparkParticleL));
        viewport.onFrameOut(200, () => viewport.particles.remove(sparkParticleR));
        this.particles.add(sparkParticleL);
        this.particles.add(sparkParticleR);
      }
      if (host.canFly && Math.abs(host.yAxis) > 0.55) {
        return false;
      }
    }
  }, {
    key: "release_6",
    value: function release_6(host, button) {
      // this.magnetism = 0;

      // for(const ring of this.attract)
      // {
      // 	this.onTimeout(3000, () => {
      // 		ring.args.x = ring.def.get('x');
      // 		ring.args.y = ring.def.get('y');
      // 		host.viewport.auras.delete(ring);
      // 		host.viewport.setColCell(ring);
      // 		ring.restore = true;
      // 		ring.args.float = -1;
      // 		ring.noClip = false;
      // 		ring.args.xSpeed  = 0;
      // 		ring.args.ySpeed  = 0;
      // 	});

      // 	this.attract.delete(ring);
      // }
    }

    // hold_6(host, button)
    // {
    // 	const pressure = button.pressure;

    // 	this.magnetize(host,pressure);
    // }
  }, {
    key: "magnetize",
    value: function magnetize(host, pressure) {
      if (!host.controllable) {
        return;
      }
      host.args.xOff = 0;
      host.args.yOff = 32;

      // this.args.boosted = 'boosted';

      this.magnetism = Math.max(0.25, pressure);

      // host.pinch(260 * this.magnetism, 0);

      const Ring = host.viewport.objectPalette.ring;
      const findRing = actor => {
        if (this.attract.has(actor)) {
          return false;
        }
        if (!(actor instanceof Ring)) {
          return false;
        }
        if (actor.args.gone) {
          return false;
        }
        if (actor.restore) {
          return false;
        }
        return true;
      };
      const ring = host.findNearestActor(findRing, 256);
      if (ring) {
        host.viewport.auras.add(ring);
        this.attract.add(ring);
      }
    }
  }, {
    key: "update",
    value: function update(host) {
      for (const sparkParticle of this.particles) {
        sparkParticle.age && sparkParticle.style({
          '--x': sparkParticle.x - (40 - 40 / Math.pow(sparkParticle.age * 0.35, 2)) * sparkParticle.d,
          '--y': sparkParticle.y + Math.pow(sparkParticle.age * 0.35, 2)
        });
        sparkParticle.age++;
      }
      this.magnetize(host, 2.5);
      if (!host.args.falling && !this.magnetTimeout) {
        this.magnetTimeout = this.onTimeout(100, () => {
          this.magnetTimeout = false;
          this.args.boosted = '';
        });
      }
      if (host.canFly) {
        // return;
      }
      if (!host.args.falling) {
        this.jumps = 3;
      }
      let ringsMoved = 0;
      for (const ring of this.attract) {
        if (ring.args.gone) {
          this.attract.delete(ring);
          ring.attract = null;
          const viewport = host.viewport;
          viewport.onFrameOut(30, () => {
            if (!ring.def) {
              return;
            }
            ring.args.static = false;
            ring.args.xSpeed = 0;
            ring.args.ySpeed = 0;
            ring.args.x = ring.def.get('x');
            ring.args.y = ring.def.get('y');
            viewport.setColCell(ring);
            viewport.onFrameOut(5 * 60, () => {
              viewport.auras.delete(ring);
              ring.args.float = -1;
              ring.noClip = false;
              ring.restore = true;
            });
          });
          continue;
        }
        ring.args.static = false;
        ring.attract = host;
        ring.noClip = true;
        const xDiff = host.x - ring.x;
        const yDiff = host.y - host.args.height / 2 - ring.y;
        const angle = Math.atan2(yDiff, xDiff);
        const distance = Math.hypot(yDiff, xDiff);
        const maxDistance = 512;
        const xDir = Math.sign(xDiff);
        const yDir = Math.sign(yDiff);
        const xSame = Math.sign(ring.args.xSpeed || 0) === xDir;
        const ySame = Math.sign(ring.args.ySpeed || 0) === yDir;
        if (distance > maxDistance) {
          if (ringsMoved > 45) {
            continue;
          }
          ring.args.x = host.x - Math.cos(angle) * maxDistance;
          ring.args.y = host.y - Math.sin(angle) * maxDistance;
        }
        host.viewport.setColCell(ring);
        ringsMoved++;
        const force = (this.magnetism || 0.75) * 2;
        const xMag = Math.max(force, xSame ? 0.45 : 0.55);
        const yMag = Math.max(force, ySame ? 0.45 : 0.45);

        // const xMag = Math.max(this.magnetism, xDiff === xDir ? 0.35 : 0.35);
        // const yMag = Math.max(this.magnetism, yDiff === yDir ? 0.125 : 0.135);

        ring.args.groundAngle = 0;
        const fudge = this.magnetism ? Math.random() : 1;
        if (!xSame || Math.abs(ring.args.xSpeed) < 8 || distance > maxDistance) {
          ring.args.xSpeed += Math.max(0.1, xMag * fudge) * xDir;
        }
        if (!ySame || Math.abs(ring.args.ySpeed) < 8 || distance > maxDistance) {
          ring.args.ySpeed += Math.max(0.1, yMag * fudge) * yDir;
        }
        ring.args.falling = true;
      }
    }
  }]);
  return ElectricSheild;
}(_Sheild2.Sheild);
exports.ElectricSheild = ElectricSheild;
});

;require.register("powerups/FireSheild.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FireSheild = void 0;
var _Bindable = require("curvature/base/Bindable");
var _Sheild2 = require("./Sheild");
var _Sfx = require("../audio/Sfx");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let FireSheild = /*#__PURE__*/function (_Sheild) {
  _inherits(FireSheild, _Sheild);
  var _super = _createSuper(FireSheild);
  function FireSheild() {
    var _this;
    _classCallCheck(this, FireSheild);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _defineProperty(_assertThisInitialized(_this), "template", `<div class = "sheild fire-sheild [[boosted]]"></div>`);
    _defineProperty(_assertThisInitialized(_this), "protect", true);
    _defineProperty(_assertThisInitialized(_this), "type", 'fire');
    _defineProperty(_assertThisInitialized(_this), "power", 15);
    return _this;
  }
  _createClass(FireSheild, [{
    key: "acquire",
    value: function acquire(host) {
      const viewport = host.viewport;
      if (!viewport) {
        return;
      }
      if (host.controllable) {
        _Sfx.Sfx.play('FIRE_ACQUIRE');
      }
      const invertDamage = event => {
        if (host.args.currentSheild !== _Bindable.Bindable.make(this)) {
          return;
        }
        event.preventDefault();
        const other = event.detail.other;
        other && other.pop && other.pop(host);
        this.onNextFrame(() => {
          host.args.currentSheild = null;
          host.inventory.remove(this);
        });
        host.removeEventListener('damage', invertDamage);
        host.startle(other);
      };
      host.addEventListener('damage', invertDamage);
    }
  }, {
    key: "immune",
    value: function immune(host, other) {
      let type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'normal';
      if (type === 'fire' || type === 'projectile') {
        return true;
      }
      return false;
    }
  }, {
    key: "update",
    value: function update(host) {
      if (!host.args.falling) {
        this.didBoost = false;
        this.power = 15;
      }
    }
  }, {
    key: "hold_4",
    value: function hold_4(host, button) {
      if (this.power <= 0) {
        return;
      }
      this.power--;
      if (host.canFly) {
        // return;
      }
      if (host.args.falling) {
        host.impulse(1, Math.PI);
        if (!this.args.boosted) {
          this.args.boosted = 'boosted';
          host.args.didBoost = true;
          _Sfx.Sfx.play('FIRE_DASH');
          host.viewport.onFrameOut(15, () => this.args.boosted = '');
        }
      } else {
        this.args.boosted = '';
      }
    }
  }, {
    key: "hold_5",
    value: function hold_5(host, button) {
      if (this.power <= 0) {
        return;
      }
      this.power--;
      if (host.canFly) {
        // return;
      }
      if (host.args.falling) {
        host.impulse(1, 0);
        if (!this.args.boosted) {
          this.args.boosted = 'boosted';
          host.args.didBoost = true;
          _Sfx.Sfx.play('FIRE_DASH');
          host.viewport.onFrameOut(15, () => this.args.boosted = '');
        }
      } else {
        this.args.boosted = '';
      }
    }
  }]);
  return FireSheild;
}(_Sheild2.Sheild);
exports.FireSheild = FireSheild;
});

;require.register("powerups/NormalSheild.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NormalSheild = void 0;
var _Bindable = require("curvature/base/Bindable");
var _Sheild2 = require("./Sheild");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let NormalSheild = /*#__PURE__*/function (_Sheild) {
  _inherits(NormalSheild, _Sheild);
  var _super = _createSuper(NormalSheild);
  function NormalSheild() {
    var _this;
    _classCallCheck(this, NormalSheild);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _defineProperty(_assertThisInitialized(_this), "template", `<div class = "sheild normal-sheild"></div>`);
    _defineProperty(_assertThisInitialized(_this), "protect", true);
    _defineProperty(_assertThisInitialized(_this), "type", 'normal');
    return _this;
  }
  _createClass(NormalSheild, [{
    key: "acquire",
    value: function acquire(host) {
      const viewport = host.viewport;
      if (!viewport) {
        return;
      }
      const invertDamage = event => {
        if (host.args.currentSheild !== _Bindable.Bindable.make(this)) {
          return;
        }
        event.preventDefault();
        const other = event.detail.other;
        other && other.damage && other.damage(host);
        this.onNextFrame(() => {
          host.args.currentSheild = null;
          host.inventory.remove(this);
        });
        host.removeEventListener('damage', invertDamage);
        host.startle(other);
      };
      host.addEventListener('damage', invertDamage);
    }
  }, {
    key: "immune",
    value: function immune(host, other) {
      let type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'normal';
      return false;
    }
  }]);
  return NormalSheild;
}(_Sheild2.Sheild);
exports.NormalSheild = NormalSheild;
});

;require.register("powerups/Powerup.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Powerup = void 0;
var _Bindable = require("curvature/base/Bindable");
var _View2 = require("curvature/base/View");
let _Bindable$NoGetters;
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
_Bindable$NoGetters = _Bindable.Bindable.NoGetters;
let Powerup = /*#__PURE__*/function (_View) {
  _inherits(Powerup, _View);
  var _super = _createSuper(Powerup);
  function Powerup() {
    var _this;
    _classCallCheck(this, Powerup);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _defineProperty(_assertThisInitialized(_this), _Bindable$NoGetters, true);
    return _this;
  }
  _createClass(Powerup, [{
    key: "equip",
    value: function equip() {}
  }, {
    key: "unequip",
    value: function unequip() {}
  }, {
    key: "acquire",
    value: function acquire() {}
  }, {
    key: "drop",
    value: function drop() {}
  }]);
  return Powerup;
}(_View2.View);
exports.Powerup = Powerup;
});

;require.register("powerups/Sheild.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Sheild = void 0;
var _Powerup2 = require("./Powerup");
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let Sheild = /*#__PURE__*/function (_Powerup) {
  _inherits(Sheild, _Powerup);
  var _super = _createSuper(Sheild);
  function Sheild() {
    _classCallCheck(this, Sheild);
    return _super.apply(this, arguments);
  }
  return _createClass(Sheild);
}(_Powerup2.Powerup);
exports.Sheild = Sheild;
});

;require.register("powerups/StarSheild.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.StarSheild = void 0;
var _Sheild2 = require("./Sheild");
var _Bgm = require("../audio/Bgm");
var _Tag = require("curvature/base/Tag");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let StarSheild = /*#__PURE__*/function (_Sheild) {
  _inherits(StarSheild, _Sheild);
  var _super = _createSuper(StarSheild);
  function StarSheild() {
    var _this;
    _classCallCheck(this, StarSheild);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _defineProperty(_assertThisInitialized(_this), "type", 'star');
    _defineProperty(_assertThisInitialized(_this), "protect", true);
    _defineProperty(_assertThisInitialized(_this), "template", `<div class = "sheild star-sheild">
		<div class = "star-sheild-stars"></div>
	</div>`);
    _defineProperty(_assertThisInitialized(_this), "frame", 0);
    return _this;
  }
  _createClass(StarSheild, [{
    key: "acquire",
    value: function acquire(host) {
      const viewport = host.viewport;
      if (!viewport) {
        return;
      }
      const previous = host.args.currentSheild;
      const invertDamage = event => {
        event.preventDefault();
        const other = event.detail.other;
        other && other.pop && other.pop(host);
      };
      host.addEventListener('damage', invertDamage);
      viewport.onFrameOut(1560, () => {
        _Bgm.Bgm.stop('STAR_SHIELD');
        host.inventory.remove(this);
        host.removeEventListener('damage', invertDamage);
        host.args.currentSheild = previous;
        this.debindPaused && this.debindPaused();
        delete this.debindPaused;
      });
      host.onRemove(() => _Bgm.Bgm.stop('STAR_SHIELD'));
      _Bgm.Bgm.play('STAR_SHIELD', {
        interlude: true
      });
      if (!viewport.args.audio) {
        _Bgm.Bgm.pause();
      }
    }
  }, {
    key: "immune",
    value: function immune() {
      return true;
    }
  }, {
    key: "drop",
    value: function drop(host) {
      console.log(this, host);
      this.debindPaused && this.debindPaused();
      delete this.debindPaused;
    }
  }, {
    key: "update",
    value: function update(host) {
      const viewport = host.viewport;
      if (!viewport) {
        return;
      }
      const particle = new _Tag.Tag('<div class = "particle-stars">');
      const point = host.rotatePoint(0, host.args.height / 2);
      const dashed = host.dashed || host.args.animation === 'springdash';
      if (host.args.falling) {}
      let yOffset = -3;
      if (host.args.rolling) {
        yOffset = 3;
      }
      if (dashed) {
        yOffset = -16;
      }
      particle.style({
        '--frame': this.frame++,
        '--x': point[0] + host.x + -3 + host.args.xSpeed,
        '--y': point[1] + host.y + host.args.ySpeed + yOffset,
        'z-index': -1,
        opacity: Math.random() * 2
      });
      viewport.particles.add(particle);
      viewport.onFrameOut(15, () => viewport.particles.remove(particle));
    }
  }]);
  return StarSheild;
}(_Sheild2.Sheild);
exports.StarSheild = StarSheild;
});

;require.register("powerups/SuperSheild.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SuperSheild = void 0;
var _Sheild2 = require("./Sheild");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let SuperSheild = /*#__PURE__*/function (_Sheild) {
  _inherits(SuperSheild, _Sheild);
  var _super = _createSuper(SuperSheild);
  function SuperSheild() {
    var _this;
    _classCallCheck(this, SuperSheild);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _defineProperty(_assertThisInitialized(_this), "template", `<div class = "sheild super-sheild">
		<div class = "super-sheild-shine"></div>
		<div class = "super-sheild-spark"></div>
		<div class = "super-sheild-flare"></div>
	</div>`);
    _defineProperty(_assertThisInitialized(_this), "type", 'super');
    return _this;
  }
  _createClass(SuperSheild, [{
    key: "immune",
    value: function immune(host, other) {
      let type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'normal';
      if (host.isSuper || host.isHyper) {
        return true;
      }
      return false;
    }
  }]);
  return SuperSheild;
}(_Sheild2.Sheild);
exports.SuperSheild = SuperSheild;
});

;require.register("region/BgShadeRegion.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BgShadeRegion = void 0;
var _ShadeRegion2 = require("./ShadeRegion");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let BgShadeRegion = /*#__PURE__*/function (_ShadeRegion) {
  _inherits(BgShadeRegion, _ShadeRegion);
  var _super = _createSuper(BgShadeRegion);
  function BgShadeRegion() {
    var _this;
    _classCallCheck(this, BgShadeRegion);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _defineProperty(_assertThisInitialized(_this), "currentFilter", -1);
    _defineProperty(_assertThisInitialized(_this), "filters", ['studio', 'western', 'heat', 'hydro', 'lava', 'frost', 'eight-bit', 'corruption', 'black-hole', 'normal']);
    _this.args.type = 'region region-shade bg-region-shade';
    return _this;
  }
  return _createClass(BgShadeRegion);
}(_ShadeRegion2.ShadeRegion);
exports.BgShadeRegion = BgShadeRegion;
});

;require.register("region/BossRegion.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BossRegion = void 0;
var _Region2 = require("./Region");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let BossRegion = /*#__PURE__*/function (_Region) {
  _inherits(BossRegion, _Region);
  var _super = _createSuper(BossRegion);
  function BossRegion() {
    var _this;
    _classCallCheck(this, BossRegion);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.type = 'region boss';
    _this.args.hidden = true;
    return _this;
  }
  _createClass(BossRegion, [{
    key: "updateActor",
    value: function updateActor(other) {
      if (other.args.falling) {
        return;
      }
      if (!this.args._boss) {
        const boss = this.viewport.actorsById[this.args.boss];
        if (!boss) {
          other.args.bossMode = false;
          return;
        }
        if (!boss.args.hitPoints) {
          other.args.bossMode = false;
        } else {
          other.args.bossMode = true;
        }
      }
    }
  }]);
  return BossRegion;
}(_Region2.Region);
exports.BossRegion = BossRegion;
});

;require.register("region/CorkscrewRegion.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CorkscrewRegion = void 0;
var _Region2 = require("./Region");
var _Tag = require("curvature/base/Tag");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let CorkscrewRegion = /*#__PURE__*/function (_Region) {
  _inherits(CorkscrewRegion, _Region);
  var _super = _createSuper(CorkscrewRegion);
  function CorkscrewRegion() {
    var _this;
    _classCallCheck(this, CorkscrewRegion);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.type = 'region corkscrew';
    _this.args.hidden = true;
    return _this;
  }
  _createClass(CorkscrewRegion, [{
    key: "updateActor",
    value: function updateActor(other) {
      if (!other.canRoll || other.args.falling && other.args.ySpeed < 0) {
        return;
      }
      if (Math.abs(other.args.xSpeed) < 1 || Math.abs(other.args.ySpeed) > 5) {
        if (other.args.animation === 'corkscrew') {
          other.args.animation = 'walking';
        }
        return;
      }
      other.args.groundAngle = 0;
      const xDist = (other.x - this.x) / this.args.width;
      const shiftFactor = 1 + Math.cos(-Math.PI + xDist * Math.PI * 2);
      const yShift = shiftFactor * this.args.height * 0.5;
      other.args.y = this.y - yShift + -1;
      other.args.ySpeed = 0;
      other.args.xSpeed = Math.max(Math.abs(other.args.xSpeed) || other.args.width) * Math.sign(other.args.xSpeed);
      other.args.mode = 0;
      other.args.ignore = -2;
      other.args.cameraMode = 'corkscrew';
      other.args.xSpeed += Math.sign(other.args.xSpeed) * (-1 + Math.abs(shiftFactor)) * 0.25;
      other.args.gSpeed = other.args.xSpeed;
      if (xDist > 1 || xDist < 0) {
        other.args.animation = 'walking';
        // other.args.falling = false;
        other.args.y = this.y - 1;
        other.args.corkscrew = 0;
      } else {
        other.args.animation = 'corkscrew';
        other.args.corkscrew = xDist;
      }
    }
  }, {
    key: "collideA",
    value: function collideA(other) {
      return false;
    }
  }, {
    key: "solid",
    get: function get() {
      return false;
    }
  }, {
    key: "isEffect",
    get: function get() {
      return true;
    }
  }], [{
    key: "fromDef",
    value: function fromDef(objDef) {
      const width = objDef.width;
      const height = objDef.height;
      const x = objDef.x;
      const y = objDef.y;
      const obj = _get(_getPrototypeOf(CorkscrewRegion), "fromDef", this).call(this, objDef);
      obj.args.width = width;
      obj.args.height = height;

      // obj.args.x = x - width  / 2;
      obj.args.y = y + height;
      return obj;
    }
  }]);
  return CorkscrewRegion;
}(_Region2.Region);
exports.CorkscrewRegion = CorkscrewRegion;
});

;require.register("region/DarkRegion.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DarkRegion = void 0;
var _Region2 = require("./Region");
var _Tag = require("curvature/base/Tag");
var _View = require("curvature/base/View");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let DarkRegion = /*#__PURE__*/function (_Region) {
  _inherits(DarkRegion, _Region);
  var _super = _createSuper(DarkRegion);
  function DarkRegion() {
    var _this;
    _classCallCheck(this, DarkRegion);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.type = 'region region-shade region-dark';
    _this.paths = new Map();
    _this.actors = new Set();
    return _this;
  }
  _createClass(DarkRegion, [{
    key: "onRendered",
    value: function onRendered(event) {
      _get(_getPrototypeOf(DarkRegion.prototype), "onRendered", this).call(this, event);
      this.basePath = `M 0 0
    					L 0 ${32 * 17 + 1}
    					L ${32 * 17} ${32 * 17 + 1}
    					L ${32 * 17} 0
    					Z`;
      this.mask = _View.View.from(`<svg style = "position:absolute; width: calc(100vw + 2px); height: calc(100vh + 2px); top: -1px; left: -1px">
			<defs>
				<clipPath id = "mask-${this.args.id}" clipPathUnits="userSpaceOnUse">
					<path data-lights />
				</clipPath>
			</defs>
		<svg>`);
      this.mask.render(this.tags.sprite);
      this.path = this.mask.findTag('path[data-lights]');
      this.path.attr({
        d: `${this.basePath} ${this.lightPath}`
      });
      this.tags.sprite.style({
        '--maskImage': `url(#mask-${this.args.id})`
      });
    }
  }, {
    key: "update",
    value: function update() {
      _get(_getPrototypeOf(DarkRegion.prototype), "update", this).call(this);
      if (!this.filterWrapper && this.tags.sprite) {
        this.filterWrapper = new _Tag.Tag('<div class = "region-filter-wrapper">');
        this.colorWrapper = new _Tag.Tag('<div class = "region-color-wrapper">');
        this.filter = new _Tag.Tag('<div class = "region-filter">');
        this.color = new _Tag.Tag('<div class = "region-color">');
        this.filterWrapper.appendChild(this.filter.node);
        this.colorWrapper.appendChild(this.color.node);
        this.tags.sprite.appendChild(this.filterWrapper.node);
        this.tags.sprite.appendChild(this.colorWrapper.node);
      }
    }
  }, {
    key: "updateEnd",
    value: function updateEnd() {
      _get(_getPrototypeOf(DarkRegion.prototype), "updateEnd", this).call(this);
      for (const actor of this.actors) {
        const lightSize = 128;
        const topBoundry = -this.viewport.args.y - (this.args.y - this.args.height);
        const x = actor.x + actor.viewport.args.x;
        const y = actor.y + actor.viewport.args.y - actor.args.height * 0.5 + (topBoundry < 0 ? topBoundry : 0);
        if (!actor.args.polygon) {
          continue;
          this.paths.set(actor, `M ${x} ${y + lightSize * 0.5}
					 A ${lightSize * 0.5} ${lightSize * 0.5}, 0, 1 1, ${x} ${y + -lightSize * 0.5}
					 A ${lightSize * 0.5} ${lightSize * 0.5}, 0, 0 1, ${x} ${y + lightSize * 0.5}
	        		 Z`);
        } else {
          const polygon = Object.assign([], actor.args.polygon);
          const first = polygon.shift();
          const polyPath = polygon.map(p => `L ${x + p.x} ${y + p.y}`).join(' ');
          this.paths.set(actor, `M ${x + first.x} ${y + first.y}
					 ${polyPath}
					 Z`);
        }
      }
      this.path.attr({
        d: this.basePath + ' ' + [...this.paths.values()].join(' ')
      });
      this.actors.clear();
      this.paths.clear();
    }
  }, {
    key: "updateActor",
    value: function updateActor(actor) {
      if (!actor.controllable) {
        // return;
      }
      this.actors.add(actor);
    }
  }, {
    key: "solid",
    get: function get() {
      return false;
    }
  }, {
    key: "isEffect",
    get: function get() {
      return true;
    }
  }]);
  return DarkRegion;
}(_Region2.Region);
exports.DarkRegion = DarkRegion;
});

;require.register("region/DebrisRegion.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DebrisRegion = void 0;
var _Region2 = require("./Region");
var _Tag = require("curvature/base/Tag");
var _View = require("curvature/base/View");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let DebrisRegion = /*#__PURE__*/function (_Region) {
  _inherits(DebrisRegion, _Region);
  var _super = _createSuper(DebrisRegion);
  function DebrisRegion() {
    var _this$args$active;
    var _this;
    _classCallCheck(this, DebrisRegion);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.type = 'region region-shade region-debris';
    _this.args.active = (_this$args$active = _this.args.active) !== null && _this$args$active !== void 0 ? _this$args$active : true;
    return _this;
  }
  _createClass(DebrisRegion, [{
    key: "update",
    value: function update() {
      if (this.others.switch) {
        this.args.active = this.others.switch.args.active;
      }

      // this.args.hidden = !this.args.active;

      _get(_getPrototypeOf(DebrisRegion.prototype), "update", this).call(this);
      if (!this.filterWrapper && this.tags.sprite) {
        this.filterWrapper = new _Tag.Tag('<div class = "region-filter-wrapper">');
        this.colorWrapper = new _Tag.Tag('<div class = "region-color-wrapper">');
        this.filter = new _Tag.Tag('<div class = "region-filter">');
        this.color = new _Tag.Tag('<div class = "region-color">');
        this.filterWrapper.appendChild(this.filter.node);
        this.colorWrapper.appendChild(this.color.node);
        this.tags.sprite.appendChild(this.filterWrapper.node);
        this.tags.sprite.appendChild(this.colorWrapper.node);
      }
    }
  }, {
    key: "solid",
    get: function get() {
      return false;
    }
  }, {
    key: "isEffect",
    get: function get() {
      return true;
    }
  }]);
  return DebrisRegion;
}(_Region2.Region);
exports.DebrisRegion = DebrisRegion;
});

;require.register("region/DropVehicleRegion.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DropVehicleRegion = void 0;
var _Region2 = require("./Region");
var _ObjectPalette = require("../ObjectPalette");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let DropVehicleRegion = /*#__PURE__*/function (_Region) {
  _inherits(DropVehicleRegion, _Region);
  var _super = _createSuper(DropVehicleRegion);
  function DropVehicleRegion() {
    var _this;
    _classCallCheck(this, DropVehicleRegion);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.type = 'region drop-vehicle';
    return _this;
  }
  _createClass(DropVehicleRegion, [{
    key: "updateActor",
    value: function updateActor(other) {
      if (!other.controllable) {
        return;
      }
      if (other.isVehicle) {
        return;
      }
      if (!other.args.standingOn) {
        return;
      }
      other.args.standingOn = null;
    }
  }]);
  return DropVehicleRegion;
}(_Region2.Region);
exports.DropVehicleRegion = DropVehicleRegion;
});

;require.register("region/ExitRegion.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ExitRegion = void 0;
var _Region2 = require("./Region");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let ExitRegion = /*#__PURE__*/function (_Region) {
  _inherits(ExitRegion, _Region);
  var _super = _createSuper(ExitRegion);
  function ExitRegion() {
    var _this;
    _classCallCheck(this, ExitRegion);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.type = 'region exit';
    _this.args.hidden = true;
    _this.triggered = false;
    return _this;
  }
  _createClass(ExitRegion, [{
    key: "updateActor",
    value: function updateActor(other) {
      if (!this.viewport) {
        return;
      }

      // if(this.args.signpost)
      // {
      // 	const signpost = this.viewport.actorsById[ this.args.signpost ];

      // 	if(signpost.args.activeTime < 30)
      // 	{
      // 		other.args.bossMode = true;

      // 		return;
      // 	}
      // }

      if (this.others.boss && this.others.boss.args.hitPoints > 0) {
        return;
      }
      if (other.occupant) {
        other = other.occupant;
      }
      if (!other.controllable) {
        return;
      }
      const viewport = this.viewport;

      // viewport.args.fade = true;

      viewport.clearCheckpoints();
      if (this.triggered) {
        return;
      }
      viewport.onFrameOut(30, () => {
        if (this.triggered) {
          return;
        }

        // viewport.actors.remove(this);

        this.triggered = true;

        // viewport.finishLevel();

        const tally = this.others.signpost && this.others.signpost.tally;
        if (viewport.replay) {
          viewport.quit(2);
        } else if (this.args.nextStage) {
          const t = tally || viewport.clearAct(`${other.args.name} GOT THROUGH\n${viewport.args.actName}`, false);
          t.addEventListener('done', event => viewport.quit(2, () => viewport.loadMap({
            mapUrl: '/map/' + this.args.nextStage
          })));
        } else {
          const t = tally || viewport.clearAct(`${other.args.name} GOT THROUGH\n${viewport.args.actName}`, false);
          t.addEventListener('done', event => viewport.quit(2));
        }
      });
    }
  }, {
    key: "solid",
    get: function get() {
      return false;
    }
  }, {
    key: "isEffect",
    get: function get() {
      return true;
    }
  }]);
  return ExitRegion;
}(_Region2.Region);
exports.ExitRegion = ExitRegion;
});

;require.register("region/ExplodingRegion.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ExplodingRegion = void 0;
var _Region2 = require("./Region");
var _Sfx = require("../audio/Sfx");
var _Tag = require("curvature/base/Tag");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let ExplodingRegion = /*#__PURE__*/function (_Region) {
  _inherits(ExplodingRegion, _Region);
  var _super = _createSuper(ExplodingRegion);
  function ExplodingRegion() {
    var _this;
    _classCallCheck(this, ExplodingRegion);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.type = 'region region-exploding';
    return _this;
  }
  _createClass(ExplodingRegion, [{
    key: "updateActor",
    value: function updateActor(actor) {
      if (!this.args.active) {
        return;
      }
      if (actor.controllable) {
        return;
      }
      if (actor.break) {
        actor.break();
        if (!this.viewport.actorIsOnScreen(actor)) {
          this.viewport.actors.remove(actor);
        }
      }
      if (actor.pop) {
        actor.pop();
        if (!this.viewport.actorIsOnScreen(actor)) {
          this.viewport.actors.remove(actor);
        }
      }
    }
  }, {
    key: "update",
    value: function update() {
      _get(_getPrototypeOf(ExplodingRegion.prototype), "update", this).call(this);
      const viewport = this.viewport;
      if (!viewport) {
        return;
      }
      if (!this.args.active) {
        if (this.args.target && viewport.actorsById[this.args.target]) {
          const target = viewport.actorsById[this.args.target];
          viewport.auras.delete(target);
        }
        viewport.auras.delete(this);
        return;
      }
      if (!viewport) {
        return;
      }
      if (Math.random() > 0.85) {
        _Sfx.Sfx.play('BOSS_DAMAGED');
      }
      for (let i = 0; i < 1; i++) {
        const explosionTag = document.createElement('div');
        explosionTag.classList.add('particle-explosion');
        const explosion = new _Tag.Tag(explosionTag);
        const xOff = this.args.width * Math.random();
        const yOff = this.args.height * Math.random();
        const left = Math.max(this.x, -this.viewport.args.x);
        const bottom = Math.max(this.y, -this.viewport.args.y);
        const right = Math.min(this.x + this.args.width, -this.viewport.args.x + this.viewport.args.width);
        const top = Math.min(this.y - this.args.height, -this.viewport.args.y - this.viewport.args.height / 2);
        const xRange = right - left;
        const yRange = bottom - top;
        explosion.style({
          '--x': left + xRange * Math.random(),
          '--y': top + yRange * Math.random()
        });
        viewport.particles.add(explosion);
        setTimeout(() => viewport.particles.remove(explosion), 512);
      }
    }
  }, {
    key: "activate",
    value: function activate() {
      _Sfx.Sfx.play('BOSS_DAMAGED');
      this.args.active = true;
      this.viewport.onFrameOut(250, () => this.args.active = false);
      if (this.args.target && this.viewport.actorsById[this.args.target]) {
        this.viewport.onFrameOut(60, () => {
          const target = this.viewport.actorsById[this.args.target];
          this.viewport.auras.add(target);
          target.activate(other, this);
        });
      }
    }
  }]);
  return ExplodingRegion;
}(_Region2.Region);
exports.ExplodingRegion = ExplodingRegion;
});

;require.register("region/FgShadeRegion.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FgShadeRegion = void 0;
var _ShadeRegion2 = require("./ShadeRegion");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let FgShadeRegion = /*#__PURE__*/function (_ShadeRegion) {
  _inherits(FgShadeRegion, _ShadeRegion);
  var _super = _createSuper(FgShadeRegion);
  function FgShadeRegion() {
    var _this;
    _classCallCheck(this, FgShadeRegion);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _defineProperty(_assertThisInitialized(_this), "currentFilter", -1);
    _defineProperty(_assertThisInitialized(_this), "filters", ['studio', 'western', 'heat', 'hydro', 'lava', 'frost', 'eight-bit', 'corruption', 'black-hole', 'normal']);
    _this.args.type = 'fg-region-shade region region-shade';
    return _this;
  }
  return _createClass(FgShadeRegion);
}(_ShadeRegion2.ShadeRegion);
exports.FgShadeRegion = FgShadeRegion;
});

;require.register("region/ForceRegion.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ForceRegion = void 0;
var _Region2 = require("./Region");
var _Tag = require("curvature/base/Tag");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let ForceRegion = /*#__PURE__*/function (_Region) {
  _inherits(ForceRegion, _Region);
  var _super = _createSuper(ForceRegion);
  function ForceRegion(args, parent) {
    var _this$args$xForce, _this$args$yForce, _this$args$active;
    var _this;
    _classCallCheck(this, ForceRegion);
    _this = _super.call(this, args, parent);
    _this.args.type = 'region region-force';
    _this.args.xForce = (_this$args$xForce = _this.args.xForce) !== null && _this$args$xForce !== void 0 ? _this$args$xForce : 0;
    _this.args.yForce = (_this$args$yForce = _this.args.yForce) !== null && _this$args$yForce !== void 0 ? _this$args$yForce : -5;
    _this.args.active = (_this$args$active = _this.args.active) !== null && _this$args$active !== void 0 ? _this$args$active : 1;
    return _this;
  }
  _createClass(ForceRegion, [{
    key: "update",
    value: function update() {
      if (!this.originalHeight) {
        this.originalHeight = this.args.height;
      }
      if (this.switch && this.switch.args.active > 0 && !this.args.active) {
        this.args.active = true;
      }
      _get(_getPrototypeOf(ForceRegion.prototype), "update", this).call(this);
    }
  }, {
    key: "onAttach",
    value: function onAttach() {
      if (!this.viewport || !this.args.switch) {
        return;
      }
    }
  }, {
    key: "wakeUp",
    value: function wakeUp() {
      this.switch = this.viewport.actorsById[this.args.switch];
    }
  }, {
    key: "activate",
    value: function activate() {
      this.args.active = 1;
    }
  }, {
    key: "updateActor",
    value: function updateActor(other) {
      if (other instanceof _Region2.Region || other.args.static) {
        return;
      }
      if (this.args.active <= 0) {
        return;
      }
      if (other.args.falling) {
        const xProjected = other.args.xSpeed + Number(this.args.xForce);
        if (Math.abs(xProjected) > Math.abs(this.args.xForceMax) && Math.sign(this.args.xForceMax) === Math.sign(xProjected)) {
          other.args.xSpeed = this.args.xForceMax;
        } else {
          other.args.xSpeed = xProjected;
        }
        const yProjected = other.args.ySpeed + Number(this.args.yForce);
        if (Math.abs(yProjected) > Math.abs(this.args.yForceMax) && Math.sign(this.args.yForceMax) === Math.sign(yProjected)) {
          if (Math.abs(yProjected) >= other.args.gravity || other.args.falling) {
            other.args.ySpeed = this.args.yForceMax;
          }
        } else {
          other.args.ySpeed = yProjected;
        }

        // other.args.animation = 'springdash';
        other.args.groundAngle = 0;
        return;
      }
      let projected;
      switch (other.args.mode) {
        case 0:
          projected = other.args.gSpeed + this.args.xForce;
          if (Math.abs(projected) > Math.abs(this.args.xForceMax) && Math.sign(this.args.xForceMax) === Math.sign(projected)) {
            other.args.gSpeed = this.args.xForceMax;
          } else {
            other.args.gSpeed = projected;
          }
          break;
        case 1:
          other.args.gSpeed += Math.sign(this.args.yForce);
          break;
        case 2:
          other.args.gSpeed -= Math.sign(this.args.xForce);
          break;
        case 3:
          other.args.gSpeed -= Math.sign(this.args.yForce);
          break;
      }
    }
  }, {
    key: "solid",
    get: function get() {
      return false;
    }
  }, {
    key: "isEffect",
    get: function get() {
      return true;
    }
  }]);
  return ForceRegion;
}(_Region2.Region);
exports.ForceRegion = ForceRegion;
});

;require.register("region/FrictionRegion.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FrictionRegion = void 0;
var _Region2 = require("./Region");
var _Tag = require("curvature/base/Tag");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let FrictionRegion = /*#__PURE__*/function (_Region) {
  _inherits(FrictionRegion, _Region);
  var _super = _createSuper(FrictionRegion);
  function FrictionRegion() {
    var _args$friction;
    var _this;
    let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let parent = arguments.length > 1 ? arguments[1] : undefined;
    _classCallCheck(this, FrictionRegion);
    _this = _super.call(this, args, parent);
    _this.args.type = 'region region-friction';
    _this.args.friction = (_args$friction = args.friction) !== null && _args$friction !== void 0 ? _args$friction : 1;
    return _this;
  }
  _createClass(FrictionRegion, [{
    key: "solid",
    get: function get() {
      return false;
    }
  }, {
    key: "isEffect",
    get: function get() {
      return true;
    }
  }]);
  return FrictionRegion;
}(_Region2.Region);
exports.FrictionRegion = FrictionRegion;
});

;require.register("region/GrindingRegion.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GrindingRegion = void 0;
var _Region2 = require("./Region");
var _Tag = require("curvature/base/Tag");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let GrindingRegion = /*#__PURE__*/function (_Region) {
  _inherits(GrindingRegion, _Region);
  var _super = _createSuper(GrindingRegion);
  function GrindingRegion() {
    var _this;
    _classCallCheck(this, GrindingRegion);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _defineProperty(_assertThisInitialized(_this), "grind", true);
    _this.args.type = 'region grinding';
    _this.args.hidden = true;
    return _this;
  }
  _createClass(GrindingRegion, [{
    key: "update",
    value: function update() {
      if (!this.originalHeight) {
        this.originalHeight = this.args.height;
      }
      _get(_getPrototypeOf(GrindingRegion.prototype), "update", this).call(this);
    }
  }, {
    key: "updateActor",
    value: function updateActor(other) {
      if (other.args.falling) {
        return;
      }
      other.args.grinding = true;
    }
  }, {
    key: "collideA",
    value: function collideA(other, type) {
      _get(_getPrototypeOf(GrindingRegion.prototype), "collideA", this).call(this, other, type);
    }
  }, {
    key: "collideB",
    value: function collideB(other, type) {
      _get(_getPrototypeOf(GrindingRegion.prototype), "collideA", this).call(this, other, type);
    }
  }, {
    key: "solid",
    get: function get() {
      return false;
    }
  }, {
    key: "isEffect",
    get: function get() {
      return true;
    }
  }]);
  return GrindingRegion;
}(_Region2.Region);
exports.GrindingRegion = GrindingRegion;
});

;require.register("region/KillRegion.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KillRegion = void 0;
var _Region2 = require("./Region");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let KillRegion = /*#__PURE__*/function (_Region) {
  _inherits(KillRegion, _Region);
  var _super = _createSuper(KillRegion);
  function KillRegion() {
    var _this;
    _classCallCheck(this, KillRegion);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.type = 'region kill';
    _this.args.hidden = true;
    return _this;
  }
  _createClass(KillRegion, [{
    key: "updateActor",
    value: function updateActor(other) {
      if (other.controllable) {
        other.die();
      }
    }
  }]);
  return KillRegion;
}(_Region2.Region);
exports.KillRegion = KillRegion;
});

;require.register("region/LavaRegion.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LavaRegion = void 0;
var _Region2 = require("./Region");
var _Ring = require("../actor/Ring");
var _MarbleBlock = require("../actor/MarbleBlock");
var _Tag = require("curvature/base/Tag");
var _Bindable = require("curvature/base/Bindable");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let LavaRegion = /*#__PURE__*/function (_Region) {
  _inherits(LavaRegion, _Region);
  var _super = _createSuper(LavaRegion);
  function LavaRegion() {
    var _this;
    _classCallCheck(this, LavaRegion);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _defineProperty(_assertThisInitialized(_this), "isWater", true);
    _this.args.type = 'region region-lava';
    _this.args.gravity = 0.5;
    _this.args.drag = 0.85;
    _this.args.density = 15;
    _this.skimSpeed = Infinity;
    return _this;
  }
  _createClass(LavaRegion, [{
    key: "update",
    value: function update() {
      if (!this.filterWrapper && this.tags.sprite) {
        this.filterWrapper = new _Tag.Tag('<div class = "region-filter-wrapper">');
        this.colorWrapper = new _Tag.Tag('<div class = "region-color-wrapper">');
        this.filter = new _Tag.Tag('<div class = "region-filter">');
        this.color = new _Tag.Tag('<div class = "region-color">');
        this.filterWrapper.appendChild(this.filter.node);
        this.colorWrapper.appendChild(this.color.node);
        this.tags.sprite.appendChild(this.filterWrapper.node);
        this.tags.sprite.appendChild(this.colorWrapper.node);
      }
      if (!this.originalHeight) {
        this.originalHeight = this.args.height;
      }
      _get(_getPrototypeOf(LavaRegion.prototype), "update", this).call(this);
    }
  }, {
    key: "updateActor",
    value: function updateActor(other) {
      if (other instanceof _Ring.Ring) {
        other.args.ySpeed = -Math.abs(other.args.ySpeed || -6);
        return;
      }
      if (other.noClip) {
        return;
      }
      if (!other.controllable && !(other instanceof _Ring.Ring)) {
        return;
      }
      if (other.y < this.y + -this.args.height + 8) {
        return;
      }
      if (other.args.ySpeed < 0 || other.args.ignore) {
        return;
      }
      if (other.args.mercy || other.immune(this, 'fire')) {
        return;
      }
      other.damage(this, 'fire');
    }
  }, {
    key: "collideA",
    value: function collideA(other, type) {
      if (other.noClip) {
        return;
      }
      if (other instanceof _MarbleBlock.MarbleBlock) {
        return false;
      }
      if (other.args.standingOn && other.args.standingOn !== _Bindable.Bindable.make(this)) {
        return false;
      }
      _get(_getPrototypeOf(LavaRegion.prototype), "collideA", this).call(this, other, type);
      if (other.args.mercy || other.immune(this, 'fire')) {
        return true;
      }

      // // other.args.ySpeed = Math.min(-8, -(other.args.ySpeed || other.ySpeedLast) * 1.1);
      // // other.args.xSpeed = (other.args.xSpeed || other.xSpeedLast || other.args.gSpeed) * -1.1;
      // // other.args.falling = true;

      // // other.args.y = this.y + -this.args.height + -32;

      other.damage(this, 'fire');
      return true;
    }
  }, {
    key: "solid",
    get: function get() {
      return true;
    }
  }, {
    key: "isEffect",
    get: function get() {
      return true;
    }
  }]);
  return LavaRegion;
}(_Region2.Region);
exports.LavaRegion = LavaRegion;
});

;require.register("region/LoadingRegion.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LoadingRegion = void 0;
var _Region2 = require("./Region");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let LoadingRegion = /*#__PURE__*/function (_Region) {
  _inherits(LoadingRegion, _Region);
  var _super = _createSuper(LoadingRegion);
  function LoadingRegion() {
    var _this$args$xOffset;
    var _this;
    _classCallCheck(this, LoadingRegion);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.hidden = true;
    _this.loading = _this.loaded = false;
    _this.args.xOffset = (_this$args$xOffset = _this.args.xOffset) !== null && _this$args$xOffset !== void 0 ? _this$args$xOffset : 0;
    return _this;
  }
  _createClass(LoadingRegion, [{
    key: "updateActor",
    value: function updateActor(other) {
      if (this.others.signpost && !this.others.signpost.args.active) {
        if (this.others.signpostAlt && !this.others.signpostAlt.args.active) {
          return;
        }
      }
      if (!other.controllable) {
        return;
      }
      if (this.loaded || this.loading) {
        return;
      }
      if (!this.loading) {
        this.loading = true;
      }
    }
  }, {
    key: "updateEnd",
    value: function updateEnd() {
      _get(_getPrototypeOf(LoadingRegion.prototype), "updateStart", this).call(this);
      if (this.loaded || !this.loading) {
        return;
      }
      const viewport = this.viewport;
      const tileMap = viewport.tileMap;
      const width = tileMap.mapData.width;
      const height = tileMap.mapData.height;
      const xAppend = this.args.x / 32 + this.args.xOffset;
      const yAppend = 0;

      // tileMap.resize(width + 9, height);

      if (this.others.signpost && this.others.signpost.willActivate) {
        viewport.args.frozen = 30;
        viewport.appendMap(this.args.map, xAppend, yAppend);
        // this.others.signpost.waitFor =
        this.loaded = true;
      } else if (this.others.signpostAlt && this.others.signpostAlt.willActivate) {
        viewport.args.frozen = 30;
        viewport.appendMap(this.args.map, xAppend, yAppend);
        // this.others.signpost.waitFor =
        this.loaded = true;
      }

      // viewport.args.zonecard.replay({});

      // this.loaded = true;
    }
  }, {
    key: "solid",
    get: function get() {
      return false;
    }
  }, {
    key: "isEffect",
    get: function get() {
      return true;
    }
  }]);
  return LoadingRegion;
}(_Region2.Region);
exports.LoadingRegion = LoadingRegion;
});

;require.register("region/PerspectiveRegion.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PerspectiveRegion = void 0;
var _Region2 = require("./Region");
var _Tag = require("curvature/base/Tag");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let PerspectiveRegion = /*#__PURE__*/function (_Region) {
  _inherits(PerspectiveRegion, _Region);
  var _super = _createSuper(PerspectiveRegion);
  function PerspectiveRegion(args, parent) {
    var _this$args$destroyTru, _this$args$maxSpeed, _this$args$minSpeed, _this$args$canJump;
    var _this;
    _classCallCheck(this, PerspectiveRegion);
    _this = _super.call(this, args, parent);
    _this.args.sticky = true;
    _this.args.type = 'region rolling';
    _this.args.destroyTruck = (_this$args$destroyTru = _this.args.destroyTruck) !== null && _this$args$destroyTru !== void 0 ? _this$args$destroyTru : false;
    _this.args.maxSpeed = (_this$args$maxSpeed = _this.args.maxSpeed) !== null && _this$args$maxSpeed !== void 0 ? _this$args$maxSpeed : -1;
    _this.args.minSpeed = (_this$args$minSpeed = _this.args.minSpeed) !== null && _this$args$minSpeed !== void 0 ? _this$args$minSpeed : -1;
    _this.args.canJump = (_this$args$canJump = _this.args.canJump) !== null && _this$args$canJump !== void 0 ? _this$args$canJump : false;
    _this.args.hidden = true;
    _this.args.perspective = true;
    _this.args.shift = _this.args.shift || 600;
    return _this;
  }
  _createClass(PerspectiveRegion, [{
    key: "update",
    value: function update() {
      if (!this.originalHeight) {
        this.originalHeight = this.args.height;
      }
      _get(_getPrototypeOf(PerspectiveRegion.prototype), "update", this).call(this);
    }
  }, {
    key: "updateActor",
    value: function updateActor(other) {
      if (other !== this.viewport.controlActor) {
        return;
      }
      let i = (Math.abs(other.realAngle) + -Math.PI) / (Math.PI * 0.5);
      i = -1 + Math.abs(i);
      if (i < 0) {
        i++;
        i = 1 - i;
      }
      i = 1 - i;
      this.viewport.args.xPerspective = this.args.shift * i;
    }
  }, {
    key: "solid",
    get: function get() {
      return false;
    }
  }, {
    key: "isEffect",
    get: function get() {
      return true;
    }
  }]);
  return PerspectiveRegion;
}(_Region2.Region);
exports.PerspectiveRegion = PerspectiveRegion;
});

;require.register("region/PhazonRegion.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PhazonRegion = void 0;
var _Region2 = require("./Region");
var _Ring = require("../actor/Ring");
var _MarbleBlock = require("../actor/MarbleBlock");
var _Tag = require("curvature/base/Tag");
var _Bindable = require("curvature/base/Bindable");
var _LavaBall = require("../actor/LavaBall");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let PhazonRegion = /*#__PURE__*/function (_Region) {
  _inherits(PhazonRegion, _Region);
  var _super = _createSuper(PhazonRegion);
  function PhazonRegion() {
    var _this;
    _classCallCheck(this, PhazonRegion);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _defineProperty(_assertThisInitialized(_this), "isWater", true);
    _this.args.type = 'region region-phazon';

    // this.entryParticle = '<div class = "particle-splash">';

    _this.args.gravity = 0.5;
    _this.args.drag = 0.85;
    _this.args.density = 15;
    _this.skimSpeed = Infinity;
    _this.sapped = new Set();
    _this.timings = new WeakMap();
    _this.onRemove(() => _this.sapped.clear());
    return _this;
  }
  _createClass(PhazonRegion, [{
    key: "update",
    value: function update() {
      this.sapped.clear();
      if (!this.filterWrapper && this.tags.sprite) {
        this.filterWrapper = new _Tag.Tag('<div class = "region-filter-wrapper">');
        this.colorWrapper = new _Tag.Tag('<div class = "region-color-wrapper">');
        this.filter = new _Tag.Tag('<div class = "region-filter">');
        this.color = new _Tag.Tag('<div class = "region-color">');
        this.filterWrapper.appendChild(this.filter.node);
        this.colorWrapper.appendChild(this.color.node);
        this.tags.sprite.appendChild(this.filterWrapper.node);
        this.tags.sprite.appendChild(this.colorWrapper.node);
      }
      if (!this.originalHeight) {
        this.originalHeight = this.args.height;
      }
      _get(_getPrototypeOf(PhazonRegion.prototype), "update", this).call(this);
    }
  }, {
    key: "updateActor",
    value: function updateActor(other) {
      if (other instanceof _Ring.Ring) {
        other.args.ySpeed = -Math.abs(other.args.ySpeed || -6);
        return;
      }
      if (other.noClip) {
        return;
      }
      if (!other.controllable && !(other instanceof _Ring.Ring)) {
        return;
      }
      if (other.y < this.y + -this.args.height + 8) {
        return;
      }
      if (other.args.ySpeed < 0 || other.args.ignore) {
        return;
      }
      if (other.args.mercy || other.immune(this, 'fire')) {
        return;
      }
    }
  }, {
    key: "collideA",
    value: function collideA(other, type) {
      if (other.noClip) {
        return;
      }
      if (other instanceof _MarbleBlock.MarbleBlock || other instanceof _LavaBall.LavaBall) {
        return false;
      }
      if (other.args.standingOn && other.args.standingOn !== _Bindable.Bindable.make(this)) {
        return false;
      }
      other.args.y = Math.round(other.args.y);
      _get(_getPrototypeOf(PhazonRegion.prototype), "collideA", this).call(this, other, type);

      // if(!other.controllable && !other.pushed)
      // {
      // 	return false;
      // }

      if (other.args.mercy || other.immune(this, 'phazon')) {
        return true;
      }
      if (other.args.rings) {
        if (!this.sapped.has(other)) {
          let time = 0;
          if (!this.timings.has(other)) {
            this.timings.set(other, time);
          }
          time = this.timings.get(other);
          time++;
          this.timings.set(other, time);
          if (time % 9 === 0) {
            other.args.rings--;
          }
        }
        this.sapped.add(other);
      } else {
        other.damage(this, 'phazon');
      }
      return true;
    }
  }, {
    key: "solid",
    get: function get() {
      return true;
    }
  }, {
    key: "isEffect",
    get: function get() {
      return true;
    }
  }]);
  return PhazonRegion;
}(_Region2.Region);
exports.PhazonRegion = PhazonRegion;
});

;require.register("region/RainRegion.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RainRegion = void 0;
var _Region2 = require("./Region");
var _Tag = require("curvature/base/Tag");
var _View = require("curvature/base/View");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let RainRegion = /*#__PURE__*/function (_Region) {
  _inherits(RainRegion, _Region);
  var _super = _createSuper(RainRegion);
  function RainRegion() {
    var _this;
    _classCallCheck(this, RainRegion);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.type = 'region region-shade region-rain';
    return _this;
  }
  _createClass(RainRegion, [{
    key: "update",
    value: function update() {
      _get(_getPrototypeOf(RainRegion.prototype), "update", this).call(this);
      if (!this.filterWrapper && this.tags.sprite) {
        this.filterWrapper = new _Tag.Tag('<div class = "region-filter-wrapper">');
        this.colorWrapper = new _Tag.Tag('<div class = "region-color-wrapper">');
        this.filter = new _Tag.Tag('<div class = "region-filter">');
        this.color = new _Tag.Tag('<div class = "region-color">');
        this.filterWrapper.appendChild(this.filter.node);
        this.colorWrapper.appendChild(this.color.node);
        this.tags.sprite.appendChild(this.filterWrapper.node);
        this.tags.sprite.appendChild(this.colorWrapper.node);
      }
    }
  }, {
    key: "solid",
    get: function get() {
      return false;
    }
  }, {
    key: "isEffect",
    get: function get() {
      return true;
    }
  }]);
  return RainRegion;
}(_Region2.Region);
exports.RainRegion = RainRegion;
});

;require.register("region/Region.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Region = void 0;
var _Tag = require("curvature/base/Tag");
var _PointActor2 = require("../actor/PointActor");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let Region = /*#__PURE__*/function (_PointActor) {
  _inherits(Region, _PointActor);
  var _super = _createSuper(Region);
  function Region() {
    var _this;
    _classCallCheck(this, Region);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.type = 'region';
    _this.args.width = _this.args.width || 32;
    _this.args.height = _this.args.height || 32;
    _this.args.density = 0;
    _this.args.gravity = 1;
    _this.args.drag = 1;
    _this.skimSpeed = Infinity;
    _this.args.float = -1;
    _this.isRegion = true;
    _this.skimmers = new WeakSet();
    return _this;
  }
  _createClass(Region, [{
    key: "onRendered",
    value: function onRendered() {
      this.mainElem = new _Tag.Tag(this.tags.sprite.parentNode);
      _get(_getPrototypeOf(Region.prototype), "onRendered", this).call(this);
    }
  }, {
    key: "skim",
    value: function skim(actor) {
      this.skimmers.add(actor);
    }
  }, {
    key: "updateStart",
    value: function updateStart() {
      this.skimmers = new WeakSet();
      _get(_getPrototypeOf(Region.prototype), "updateStart", this).call(this);
    }
  }, {
    key: "update",
    value: function update() {
      if (!this.viewport) {
        return;
      }
      if (!this.focus && this.args.focus) {
        this.focus = this.viewport.actorsById[this.args.focus];
      }
      _get(_getPrototypeOf(Region.prototype), "update", this).call(this);
      if (this.viewport.args.frameId % this.viewport.settings.frameSkip === 0) {
        var _this$args$color;
        const topBoundry = -this.viewport.args.y - (this.args.y - this.args.height);
        const leftBoundry = -this.viewport.args.x - this.args.x;
        this.mainElem && this.mainElem.style({
          '--viewportWidth': this.viewport.args.width + 'px',
          '--viewportHeight': this.viewport.args.height + 'px',
          '--leftBoundry': leftBoundry + 'px',
          '--topBoundry': topBoundry + 'px',
          '--vpX': this.viewport.args.x + 'px',
          '--vpY': this.viewport.args.y + 'px',
          '--color': (_this$args$color = this.args.color) !== null && _this$args$color !== void 0 ? _this$args$color : 'rgba(0,128,255,0.33)'
        });
      }
    }
  }, {
    key: "updateActor",
    value: function updateActor(other) {}
  }, {
    key: "solid",
    get: function get() {
      return false;
    }
  }, {
    key: "isEffect",
    get: function get() {
      return true;
    }
  }, {
    key: "enter",
    value: function enter(other) {}
  }, {
    key: "leave",
    value: function leave(other) {}
  }], [{
    key: "fromDef",
    value: function fromDef(objDef) {
      const obj = _get(_getPrototypeOf(Region), "fromDef", this).call(this, objDef);
      obj.args.width = objDef.width;
      obj.args.height = objDef.height;
      obj.args.x = obj.originalX = -0 + Math.floor(objDef.x);
      obj.args.y = obj.originalY = -0 + Math.floor(objDef.y);
      obj.args.static = true;
      return obj;
    }
  }]);
  return Region;
}(_PointActor2.PointActor);
exports.Region = Region;
});

;require.register("region/RollingRegion.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RollingRegion = void 0;
var _Region2 = require("./Region");
var _Tag = require("curvature/base/Tag");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let RollingRegion = /*#__PURE__*/function (_Region) {
  _inherits(RollingRegion, _Region);
  var _super = _createSuper(RollingRegion);
  function RollingRegion(args, parent) {
    var _this$args$destroyTru, _this$args$maxSpeed, _this$args$minSpeed, _this$args$canJump;
    var _this;
    _classCallCheck(this, RollingRegion);
    _this = _super.call(this, args, parent);
    _this.args.sticky = true;
    _this.args.type = 'region rolling';
    _this.args.destroyTruck = (_this$args$destroyTru = _this.args.destroyTruck) !== null && _this$args$destroyTru !== void 0 ? _this$args$destroyTru : false;
    _this.args.maxSpeed = (_this$args$maxSpeed = _this.args.maxSpeed) !== null && _this$args$maxSpeed !== void 0 ? _this$args$maxSpeed : -1;
    _this.args.minSpeed = (_this$args$minSpeed = _this.args.minSpeed) !== null && _this$args$minSpeed !== void 0 ? _this$args$minSpeed : -1;
    _this.args.canJump = (_this$args$canJump = _this.args.canJump) !== null && _this$args$canJump !== void 0 ? _this$args$canJump : false;
    _this.args.hidden = true;
    return _this;
  }
  _createClass(RollingRegion, [{
    key: "update",
    value: function update() {
      if (!this.originalHeight) {
        this.originalHeight = this.args.height;
      }
      _get(_getPrototypeOf(RollingRegion.prototype), "update", this).call(this);
    }
  }, {
    key: "updateActor",
    value: function updateActor(other) {
      if (!other.controllable) {
        return;
      }
      if (other.args.falling) {
        return;
      }
      other.willStick = false;
      const gSpeedLast = other.args.modeTime > 5 ? other.gSpeedLast : 0;
      if (Math.abs(other.args.gSpeed) < this.args.minSpeed) {
        other.args.gSpeed = this.args.minSpeed * Math.sign(other.args.gSpeed || gSpeedLast || other.args.direction);
      }
      if (this.args.maxSpeed > 0 && Math.abs(other.args.gSpeed) > this.args.maxSpeed) {
        other.args.gSpeed = this.args.maxSpeed * Math.sign(other.args.gSpeed || gSpeedLast || other.args.direction);
        if (other.args.mode === 1) {
          other.args.gSpeed = other.ySpeedLast;
        }
        if (other.args.mode === 3) {
          other.args.gSpeed = -other.ySpeedLast;
        }
      }
      if (!other.args.gSpeed) {
        other.args.gSpeed = 2 * Math.sign(gSpeedLast || other.args.direction);
      }
      if (!other.args.rolling) {
        other.args.rolling = true;
      }
      if (other.willJump) {
        if (!this.args.canJump) {
          other.willJump = false;
        }
      }
    }
  }, {
    key: "solid",
    get: function get() {
      return false;
    }
  }, {
    key: "isEffect",
    get: function get() {
      return true;
    }
  }]);
  return RollingRegion;
}(_Region2.Region);
exports.RollingRegion = RollingRegion;
});

;require.register("region/ShadeRegion.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ShadeRegion = void 0;
var _CharacterString = require("../ui/CharacterString");
var _Cylinder = require("../effects/Cylinder");
var _Pinch = require("../effects/Pinch");
var _Region2 = require("./Region");
var _Tag = require("curvature/base/Tag");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let ShadeRegion = /*#__PURE__*/function (_Region) {
  _inherits(ShadeRegion, _Region);
  var _super = _createSuper(ShadeRegion);
  function ShadeRegion() {
    var _this;
    _classCallCheck(this, ShadeRegion);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _defineProperty(_assertThisInitialized(_this), "currentFilter", -1);
    _defineProperty(_assertThisInitialized(_this), "filters", ['western', 'heat', 'hydro', 'lava', 'black-hole', 'normal']);
    _this.args.type = 'region region-shade';
    return _this;
  }
  _createClass(ShadeRegion, [{
    key: "onRendered",
    value: function onRendered() {
      _get(_getPrototypeOf(ShadeRegion.prototype), "onRendered", this).call(this);
      this.actorFilterWrapper = new _Tag.Tag('<div class = "region-filter-wrapper">');
      this.actorColorWrapper = new _Tag.Tag('<div class = "region-color-wrapper">');
      this.filterWrapper = new _Tag.Tag('<div class = "region-filter-wrapper">');
      this.colorWrapper = new _Tag.Tag('<div class = "region-color-wrapper">');
      this.actorFilter = new _Tag.Tag('<div class = "region-filter">');
      this.actorColor = new _Tag.Tag('<div class = "region-color">');
      this.filter = new _Tag.Tag('<div class = "region-filter">');
      this.color = new _Tag.Tag('<div class = "region-color">');
      this.filterWrapper.appendChild(this.filter.node);
      this.colorWrapper.appendChild(this.color.node);

      // this.actorFilterWrapper.appendChild(this.actorFilter.node);
      // this.actorColorWrapper.appendChild(this.actorColor.node);

      // this.actorLayer = new Tag('<div class = "actor-layer">');

      // this.actorLayer.appendChild(this.actorFilterWrapper.node);
      // this.actorLayer.appendChild(this.actorColorWrapper.node);

      // this.mainElem.appendChild(this.actorLayer.node);

      this.tags.sprite.appendChild(this.filterWrapper.node);
      this.tags.sprite.appendChild(this.colorWrapper.node);
      this.text = new _CharacterString.CharacterString({
        value: ''
      });
      this.text.render(this.tags.sprite);
      this.cylinder = new _Cylinder.Cylinder({
        id: 'shade-cylinder',
        width: this.args.width,
        height: this.args.height
      });
      this.cylinder.render(this.tags.sprite);
      this.pinch = new _Pinch.Pinch({
        id: 'shade-pinch',
        width: this.args.width,
        height: this.args.height,
        scale: 150
      });
      this.pinch.render(this.tags.sprite);

      // this.args.bindTo('scale', v => {
      // 	this.pinch.args.scale = v;
      // 	this.cylinder.args.scale = v;
      // });

      if (this.args.filter) {
        this.filters = [this.args.filter];
      }
      this.rotateFilter();
    }
  }, {
    key: "update",
    value: function update() {
      _get(_getPrototypeOf(ShadeRegion.prototype), "update", this).call(this);
      this.args.scale = 175 - Math.abs(Math.sin(Date.now() / 200) * 25);
      if (!this.switch && this.args.switch) {
        this.switch = this.viewport.actorsById[this.args.switch];
        if (this.switch) {
          this.switch.args.bindTo('active', v => {
            if (v) {
              this.rotateFilter();
            }
          });
        }
      }
    }
  }, {
    key: "rotateFilter",
    value: function rotateFilter() {
      if (this.mainElem && this.args.filter) {
        this.mainElem.classList.remove(this.args.filter);
      }
      if (this.mainElem) {
        this.args.filter = this.filters[this.currentFilter++];
        if (this.currentFilter >= this.filters.length) {
          this.currentFilter = 0;
        }
        this.args.filter && this.mainElem.classList.add(this.args.filter);
        if (this.args.filter) {
          this.text.remove();
          this.text = new _CharacterString.CharacterString({
            value: `${this.currentFilter}: ${this.args.filter}`
          });
          this.text.render(this.tags.sprite);
        }
      }
    }
  }, {
    key: "solid",
    get: function get() {
      return false;
    }
  }, {
    key: "isEffect",
    get: function get() {
      return true;
    }
  }]);
  return ShadeRegion;
}(_Region2.Region);
exports.ShadeRegion = ShadeRegion;
});

;require.register("region/SlidingRegion.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SlidingRegion = void 0;
var _Region2 = require("./Region");
var _Tag = require("curvature/base/Tag");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let SlidingRegion = /*#__PURE__*/function (_Region) {
  _inherits(SlidingRegion, _Region);
  var _super = _createSuper(SlidingRegion);
  function SlidingRegion(args, parent) {
    var _this$args$canJump, _this$args$toSpeed;
    var _this;
    _classCallCheck(this, SlidingRegion);
    _this = _super.call(this, args, parent);
    _this.args.sticky = true;
    _this.args.hidden = true;
    _this.args.canJump = (_this$args$canJump = _this.args.canJump) !== null && _this$args$canJump !== void 0 ? _this$args$canJump : true;
    _this.args.type = 'region sliding';
    _this.args.toSpeed = (_this$args$toSpeed = _this.args.toSpeed) !== null && _this$args$toSpeed !== void 0 ? _this$args$toSpeed : 8;
    return _this;
  }
  _createClass(SlidingRegion, [{
    key: "updateActor",
    value: function updateActor(other) {
      if (other.args.static) {
        return;
      }
      if (other.args.falling) {
        return;
      }
      if (!other.controllable) {
        return;
      }
      other.willStick = false;
      if (Math.abs(this.args.toSpeed - other.args.gSpeed) > 1) {
        other.args.gSpeed += Math.sign(this.args.toSpeed - other.args.gSpeed);
      } else {
        other.args.gSpeed = this.args.toSpeed;
      }
      other.args.rolling = false;
      other.args.sliding = true;
      if (other.willJump) {
        if (!this.args.canJump) {
          other.willJump = false;
        }
      }
    }
  }, {
    key: "solid",
    get: function get() {
      return false;
    }
  }, {
    key: "isEffect",
    get: function get() {
      return true;
    }
  }]);
  return SlidingRegion;
}(_Region2.Region);
exports.SlidingRegion = SlidingRegion;
});

;require.register("region/SwitchRegion.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SwitchRegion = void 0;
var _Region2 = require("./Region");
var _Rocket = require("../actor/Rocket");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let SwitchRegion = /*#__PURE__*/function (_Region) {
  _inherits(SwitchRegion, _Region);
  var _super = _createSuper(SwitchRegion);
  function SwitchRegion() {
    var _args$latch;
    var _this;
    _classCallCheck(this, SwitchRegion);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.type = 'region region-switch';
    _this.args.latch = (_args$latch = args.latch) !== null && _args$latch !== void 0 ? _args$latch : _this.args.latch;
    _this.args.hidden = true;
    _this.activated = false;
    return _this;
  }
  _createClass(SwitchRegion, [{
    key: "onAttach",
    value: function onAttach(event) {
      event && event.preventDefault();
      return false;
    }
  }, {
    key: "activate",
    value: function activate(actor) {
      if (!this.viewport) {
        return;
      }
      if (this.args.latch && this.activated) {
        return;
      }
      if (this.args.latch) {
        this.args.active = this.activated = true;
      }
      const target = this.viewport.actorsById[this.args.target];
      if (!target || !target.activate) {
        return;
      }
      target.activate(actor, this);
    }
  }, {
    key: "updateActor",
    value: function updateActor(actor) {
      if (this.args.rocket) {
        if (actor instanceof _Rocket.Rocket) {
          const target = this.viewport.actorsById[this.args.target];
          if (!target || !target.activate) {
            return;
          }
          this.viewport.onFrameOut(this.args.delay || 1, () => target.activate(actor, this));
          actor.explode();
        }
        return;
      }
      if (actor.isVehicle && actor.occupant) {
        actor = actor.occupant;
      }
      if (!actor.controllable) {
        return;
      }

      // const target = this.viewport.actorsById[ this.args.target ];

      // if(!target || !target.activate)
      // {
      // 	return;
      // }

      this.viewport.onFrameOut(this.args.delay || 1, () => this.activate(actor));
    }
  }]);
  return SwitchRegion;
}(_Region2.Region);
exports.SwitchRegion = SwitchRegion;
});

;require.register("region/ToxicRegion.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ToxicRegion = void 0;
var _Region2 = require("./Region");
var _Ring = require("../actor/Ring");
var _MarbleBlock = require("../actor/MarbleBlock");
var _Tag = require("curvature/base/Tag");
var _Bindable = require("curvature/base/Bindable");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let ToxicRegion = /*#__PURE__*/function (_Region) {
  _inherits(ToxicRegion, _Region);
  var _super = _createSuper(ToxicRegion);
  function ToxicRegion() {
    var _this;
    _classCallCheck(this, ToxicRegion);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _defineProperty(_assertThisInitialized(_this), "isWater", true);
    _this.args.type = 'region region-toxic';

    // this.entryParticle = '<div class = "particle-splash">';

    _this.args.gravity = 0.5;
    _this.args.drag = 0.85;
    _this.args.density = 15;
    _this.skimSpeed = 0;
    _this.sapped = new Set();
    _this.timings = new WeakMap();
    _this.onRemove(() => _this.sapped.clear());
    return _this;
  }
  _createClass(ToxicRegion, [{
    key: "update",
    value: function update() {
      this.sapped.clear();
      if (!this.filterWrapper && this.tags.sprite) {
        this.filterWrapper = new _Tag.Tag('<div class = "region-filter-wrapper">');
        this.colorWrapper = new _Tag.Tag('<div class = "region-color-wrapper">');
        this.filter = new _Tag.Tag('<div class = "region-filter">');
        this.color = new _Tag.Tag('<div class = "region-color">');
        this.filterWrapper.appendChild(this.filter.node);
        this.colorWrapper.appendChild(this.color.node);
        this.tags.sprite.appendChild(this.filterWrapper.node);
        this.tags.sprite.appendChild(this.colorWrapper.node);
      }
      if (!this.originalHeight) {
        this.originalHeight = this.args.height;
      }
      _get(_getPrototypeOf(ToxicRegion.prototype), "update", this).call(this);
    }
  }, {
    key: "updateActor",
    value: function updateActor(other) {
      if (other instanceof _Ring.Ring) {
        other.args.ySpeed = -Math.abs(other.args.ySpeed || -6);
        return;
      }
      if (other.noClip) {
        return;
      }
      if (!other.controllable && !(other instanceof _Ring.Ring)) {
        return;
      }
      if (other.y < this.y + -this.args.height + 8) {
        return;
      }
      if (other.args.ySpeed < 0 || other.args.ignore) {
        return;
      }
      if (other.args.mercy || other.immune(this, 'fire')) {
        return;
      }
    }
  }, {
    key: "collideA",
    value: function collideA(other, type) {
      if (other.noClip) {
        return;
      }
      if (other instanceof _MarbleBlock.MarbleBlock) {
        return false;
      }
      if (other.args.standingOn && other.args.standingOn !== _Bindable.Bindable.make(this)) {
        return false;
      }
      other.args.y = Math.round(other.args.y);
      _get(_getPrototypeOf(ToxicRegion.prototype), "collideA", this).call(this, other, type);

      // if(!other.controllable && !other.pushed)
      // {
      // 	return false;
      // }

      if (other.args.mercy || other.immune(this, 'toxic')) {
        return true;
      }
      if (other.args.rings) {
        if (!this.sapped.has(other)) {
          let time = 0;
          if (!this.timings.has(other)) {
            this.timings.set(other, time);
          }
          time = this.timings.get(other);
          time++;
          this.timings.set(other, time);
          if (time % 27 === 0) {
            other.args.rings--;
          }
        }
        this.sapped.add(other);
      } else {
        other.damage(this, 'toxic');
      }
      return true;
    }
  }, {
    key: "solid",
    get: function get() {
      return true;
    }
  }, {
    key: "isEffect",
    get: function get() {
      return true;
    }
  }]);
  return ToxicRegion;
}(_Region2.Region);
exports.ToxicRegion = ToxicRegion;
});

;require.register("region/VehicleRegion.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VehicleRegion = void 0;
var _Region2 = require("./Region");
var _ObjectPalette = require("../ObjectPalette");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let VehicleRegion = /*#__PURE__*/function (_Region) {
  _inherits(VehicleRegion, _Region);
  var _super = _createSuper(VehicleRegion);
  function VehicleRegion() {
    var _this;
    _classCallCheck(this, VehicleRegion);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _defineProperty(_assertThisInitialized(_this), "SpawnedFor", Symbol('SpawnedFor'));
    _this.args.type = 'region vehicle';
    return _this;
  }
  _createClass(VehicleRegion, [{
    key: "updateActor",
    value: function updateActor(other) {
      if (other[this.SpawnedFor] === false) {
        return;
      }
      if (other[this.SpawnedFor]) {
        const spawned = other[this.SpawnedFor];
        spawned.args.x = other.args.x;
        spawned.args.y = other.args.y;
        spawned.args.xSpeed = other.args.xSpeed;
        spawned.args.ySpeed = other.args.ySpeed;
        spawned.args.gSpeed = other.args.gSpeed;
        other.args.standingOn = spawned;
      }
      if (!other.controllable) {
        return;
      }
      if (other.isVehicle) {
        return;
      }
      if (!other.args.standingOn) {
        const vehicleType = _ObjectPalette.ObjectPalette[this.args.vehicle];
        if (!vehicleType) {
          return;
        }
        const newVehicle = new vehicleType({
          x: other.x,
          y: other.y,
          xSpeed: other.args.xSpeed,
          ySpeed: other.args.ySpeed,
          gSpeed: other.args.gSpeed,
          falling: other.args.falling,
          lockedIn: true
        });
        this.viewport.spawn.add({
          object: newVehicle
        });
        other.args.standingOn = newVehicle;
        other[this.SpawnedFor] = newVehicle;
      }
    }
  }, {
    key: "leave",
    value: function leave(other) {
      if (other.occupant) {
        other = other.occupant;
      }
      if (!this.args.restricted) {
        return;
      }
      if (!other.args.standingOn) {
        return;
      }
      if (!other.args.standingOn.isVehicle) {
        return;
      }
      other[this.SpawnedFor] = false;
      const vehicle = other.args.standingOn;
      vehicle.args.lockedIn = false;
      vehicle.dead = true;
      other.args.standingOn = null;
      other.args.x = vehicle.args.x;
      other.args.y = vehicle.args.y;
      other.args.gSpeed = vehicle.args.gSpeed;
      other.args.xSpeed = vehicle.args.xSpeed;
      other.args.ySpeed = vehicle.args.ySpeed;
      other.args.falling = vehicle.args.falling;
    }
  }]);
  return VehicleRegion;
}(_Region2.Region);
exports.VehicleRegion = VehicleRegion;
});

;require.register("region/VerticalRegion.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VerticalRegion = void 0;
var _Region2 = require("./Region");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let VerticalRegion = /*#__PURE__*/function (_Region) {
  _inherits(VerticalRegion, _Region);
  var _super = _createSuper(VerticalRegion);
  function VerticalRegion() {
    var _this;
    _classCallCheck(this, VerticalRegion);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.type = 'region vertical';
    _this.args.hidden = true;
    return _this;
  }
  _createClass(VerticalRegion, [{
    key: "updateActor",
    value: function updateActor(other) {
      if (other.args.falling) {
        other.args.xSpeed = 0;
      }
    }
  }]);
  return VerticalRegion;
}(_Region2.Region);
exports.VerticalRegion = VerticalRegion;
});

;require.register("region/WaterRegion.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WaterRegion = void 0;
var _Region2 = require("./Region");
var _Tag = require("curvature/base/Tag");
var _View = require("curvature/base/View");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let WaterRegion = /*#__PURE__*/function (_Region) {
  _inherits(WaterRegion, _Region);
  var _super = _createSuper(WaterRegion);
  function WaterRegion() {
    var _this;
    _classCallCheck(this, WaterRegion);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _defineProperty(_assertThisInitialized(_this), "isWater", true);
    _this.args.type = 'region region-water';
    _this.entryParticle = '<div class = "particle-splash">';
    _this.args.gravity = 0.40;
    _this.args.drag = 0.85;
    _this.args.density = 1;
    _this.skimSpeed = 15;
    _this.draining = 0;
    _this.skimParticles = new Map();
    return _this;
  }
  _createClass(WaterRegion, [{
    key: "skim",
    value: function skim(actor) {
      _get(_getPrototypeOf(WaterRegion.prototype), "skim", this).call(this, actor);
      if (this.viewport.args.frameId % this.viewport.settings.frameSkip !== 0) {
        return;
      }
      const splashPoint = actor.rotatePoint(actor.args.gSpeed, 3);
      if (this.skimParticles.has(actor)) {
        const stuff = this.skimParticles.get(actor);
        const skimParticle = stuff.skimParticle,
          timeout = stuff.timeout;
        timeout();
        const newTimeout = this.viewport.onFrameOut(2, () => {
          this.viewport.particles.remove(skimParticle);
          this.skimParticles.delete(actor);
        });
        stuff.timeout = newTimeout;
        skimParticle.style({
          '--x': splashPoint[0] + actor.x,
          '--y': splashPoint[1] + actor.y,
          'z-index': 0,
          '--flip': `${Math.sign(actor.args.gSpeed)}`
        });
        return;
      }
      if (this.viewport) {
        const skimParticle = new _Tag.Tag(`<div class = "particle-skim">`);
        this.viewport.particles.add(skimParticle);
        const timeout = this.viewport.onFrameOut(2, () => {
          this.viewport.particles.remove(skimParticle);
          this.skimParticles.delete(actor);
        });
        this.skimParticles.set(actor, {
          skimParticle: skimParticle,
          timeout: timeout
        });
      }
    }
  }, {
    key: "update",
    value: function update() {
      if (!this.viewport) {
        return;
      }
      if (!this.filterWrapper && this.tags.sprite) {
        this.filterWrapper = new _Tag.Tag('<div class = "region-filter-wrapper">');
        this.colorWrapper = new _Tag.Tag('<div class = "region-color-wrapper">');
        this.filter = new _Tag.Tag('<div class = "region-filter">');
        this.color = new _Tag.Tag('<div class = "region-color">');
        this.colorWrapper.appendChild(this.color.node);
        this.filterWrapper.appendChild(this.filter.node);
        this.tags.sprite.appendChild(this.colorWrapper.node);
        this.tags.sprite.appendChild(this.filterWrapper.node);
      }
      if (this.args.controller) {
        const controller = this.viewport.actorsById[this.args.controller];
        if (controller) {
          this.args.height = controller.args.level;
        }
      }
      if (!this.switch && this.args.switch) {
        this.switch = this.viewport.actorsById[this.args.switch];
        if (this.switch) {
          this.switch.args.bindTo('active', v => {
            if (!v && this.draining > 0) {
              // this.draining = -1;
            }
            if (v) {
              this.draining = 1;
            } else {
              this.draining = -1;
            }
          });
        }
      }
      if (!this.originalHeight) {
        this.originalHeight = this.args.height;
      }
      if (this.draining) {
        if (this.draining > 0 && this.args.height >= 32) {
          this.args.height -= 3.5;
        } else if (this.draining < 0 && this.args.height < this.originalHeight) {
          this.args.height += 3.5;
        }
        if (this.args.height <= 0) {
          this.args.display = 'none';
          if (this.draining > 0) {
            this.draining = 0;
          }
        } else {
          this.args.display = 'initial';
        }
      }
      if (this.target && this.args.height !== this.target) {
        var _this$args$drainSpeed, _this$args$fillSpeed;
        const space = this.args.height - this.target;
        const drainSpeed = (_this$args$drainSpeed = this.args.drainSpeed) !== null && _this$args$drainSpeed !== void 0 ? _this$args$drainSpeed : 1;
        const fillSpeed = (_this$args$fillSpeed = this.args.fillSpeed) !== null && _this$args$fillSpeed !== void 0 ? _this$args$fillSpeed : 1;
        const speed = space > 0 ? drainSpeed : fillSpeed;
        if (Math.abs(this.args.height - this.target) > speed) {
          this.args.height -= Math.abs(speed) * Math.sign(space);
        } else {
          this.args.height = this.target;
        }
      }
      _get(_getPrototypeOf(WaterRegion.prototype), "update", this).call(this);
    }
  }, {
    key: "updateEnd",
    value: function updateEnd() {
      _get(_getPrototypeOf(WaterRegion.prototype), "updateEnd", this).call(this);
      if (this.viewport.args.frameId % this.viewport.settings.frameSkip !== 0) {
        return;
      }
      for (const _ref of this.skimParticles) {
        var _ref2 = _slicedToArray(_ref, 2);
        const actor = _ref2[0];
        const skimParticle = _ref2[1].skimParticle;
        const splashPoint = actor.rotatePoint(0, 3);
        skimParticle.style({
          '--x': splashPoint[0] + actor.x + -32 * Math.sign(actor.args.gSpeed),
          '--y': splashPoint[1] + actor.y,
          'z-index': 0,
          '--flip': `${Math.sign(actor.args.gSpeed)}`
        });
      }
    }
  }, {
    key: "updateActor",
    value: function updateActor(other) {
      if (!other.controllable) {
        return;
      }
      if (other.args.y - other.args.height < this.args.y - this.args.height) {
        return;
      }
      if (this.viewport.args.frameId % 5 === 0 && Math.random() > 0.9) {
        const viewport = this.viewport;
        const bubble = new _Tag.Tag('<div class = "particle-bubble">');
        const attach = other.rotatePoint(...other.facePoint);
        const x = other.args.x + attach[0];
        const y = other.args.y + attach[1];
        bubble.style({
          '--startY': y,
          '--size': Math.random()
        });
        const stopHoldingBubble = viewport.onFrameInterval(1, () => {
          const point = other.facePoint;
          const x = other.args.x + point[0];
          const y = other.args.y + point[1];
          if (other.args.y < this.args.y - this.args.height) {
            bubble.style({
              display: 'none'
            });
          }
          if (y < this.args.y - this.args.height) {
            bubble.style({
              display: 'none'
            });
          }
          bubble.style({
            '--x': x,
            '--y': y
          });
        });
        const stopWatchingBubble = viewport.onFrameInterval(1, () => {
          bubble.style({
            '--maxY': this.args.y - this.args.height
          });
        });
        viewport.particles.add(bubble);
        viewport.onTimeout(350, () => {
          bubble.classList.add('float');
          stopHoldingBubble();
        });
        viewport.onTimeout(1000, () => {
          bubble.classList.add('floating');
        });
        setTimeout(() => {
          viewport.particles.remove(bubble);
          stopWatchingBubble();
        }, 1500);
      }
    }
  }, {
    key: "solid",
    get: function get() {
      return false;
    }
  }, {
    key: "isEffect",
    get: function get() {
      return true;
    }
  }]);
  return WaterRegion;
}(_Region2.Region);
exports.WaterRegion = WaterRegion;
});

;require.register("region/WaterfallRegion.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WaterfallRegion = void 0;
var _Region2 = require("./Region");
var _Tag = require("curvature/base/Tag");
var _View = require("curvature/base/View");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let WaterfallRegion = /*#__PURE__*/function (_Region) {
  _inherits(WaterfallRegion, _Region);
  var _super = _createSuper(WaterfallRegion);
  function WaterfallRegion() {
    var _this;
    _classCallCheck(this, WaterfallRegion);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.args.type = 'region region-shade region-waterfall';
    _this.args.density = 0;
    return _this;
  }
  _createClass(WaterfallRegion, [{
    key: "update",
    value: function update() {
      _get(_getPrototypeOf(WaterfallRegion.prototype), "update", this).call(this);
      if (!this.filterWrapper && this.tags.sprite) {
        this.filterWrapper = new _Tag.Tag('<div class = "region-filter-wrapper">');
        this.colorWrapper = new _Tag.Tag('<div class = "region-color-wrapper">');
        this.filter = new _Tag.Tag('<div class = "region-filter">');
        this.color = new _Tag.Tag('<div class = "region-color">');
        this.filterWrapper.appendChild(this.filter.node);
        this.colorWrapper.appendChild(this.color.node);
        this.tags.sprite.appendChild(this.filterWrapper.node);
        this.tags.sprite.appendChild(this.colorWrapper.node);
        this.tags.sprite.style({
          '--maskImage': `url(#mask-${this.args.id})`
        });
      }
    }
  }, {
    key: "solid",
    get: function get() {
      return false;
    }
  }, {
    key: "isEffect",
    get: function get() {
      return true;
    }
  }]);
  return WaterfallRegion;
}(_Region2.Region);
exports.WaterfallRegion = WaterfallRegion;
});

;require.register("replay/Replay.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Replay = void 0;
var _Uuid = require("curvature/base/Uuid");
var _Model2 = require("curvature/model/Model");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
const buildTag = document.head.querySelector('meta[name="x-build-time"]');
const buildTime = buildTag ? buildTag.getAttribute('content') : null;
let Replay = /*#__PURE__*/function (_Model) {
  _inherits(Replay, _Model);
  var _super = _createSuper(Replay);
  function Replay() {
    var _this;
    _classCallCheck(this, Replay);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _defineProperty(_assertThisInitialized(_this), "class", 'Replay');
    _defineProperty(_assertThisInitialized(_this), "uuid", String(new _Uuid.Uuid()));
    _defineProperty(_assertThisInitialized(_this), "created", Date.now());
    _defineProperty(_assertThisInitialized(_this), "local", String(new Date()));
    _defineProperty(_assertThisInitialized(_this), "tz", Intl.DateTimeFormat().resolvedOptions().timeZone);
    _defineProperty(_assertThisInitialized(_this), "buildTime", buildTime);
    _defineProperty(_assertThisInitialized(_this), "map", '');
    _defineProperty(_assertThisInitialized(_this), "frames", []);
    _defineProperty(_assertThisInitialized(_this), "keyFrames", []);
    _defineProperty(_assertThisInitialized(_this), "name", '');
    _defineProperty(_assertThisInitialized(_this), "lastFrame", 0);
    _defineProperty(_assertThisInitialized(_this), "firstFrame", 0);
    return _this;
  }
  _createClass(Replay, [{
    key: "consume",
    value: function consume(skeleton) {
      let override = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      const _skeleton = Object.assign(Object.create(null), skeleton);
      _skeleton.keyFrames = Object.assign([], _skeleton.keyFrames);
      _skeleton.frames = Object.assign([], _skeleton.frames);
      _skeleton.frames = _skeleton.frames.map(f => Object.assign([], f));
      _skeleton.uuid = _skeleton.uuid || this.uuid || String(new _Uuid.Uuid());
      _get(_getPrototypeOf(Replay.prototype), "consume", this).call(this, _skeleton, override = false);
      if (_skeleton.frames) {
        this.keyFrames = _skeleton.frames.filter(f => Object.keys(f[2]).length).map(f => f[0]);
        const frameIds = this.frames.map(f => f[0]);
        this.firstFrame = frameIds.length ? Math.min(...frameIds) : 0;
        this.lastFrame = frameIds.length ? Math.max(...frameIds) : 0;
      }
    }
  }, {
    key: "getIndexedFrames",
    value: function getIndexedFrames() {
      const indexed = new Map();
      for (const frame of this.frames) {
        indexed.set(frame[0], frame);
      }
      return indexed;
    }
  }]);
  return Replay;
}(_Model2.Model);
exports.Replay = Replay;
});

;require.register("replay/ReplayDatabase.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ReplayDatabase = void 0;
var _Database2 = require("curvature/model/Database");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let ReplayDatabase = /*#__PURE__*/function (_Database) {
  _inherits(ReplayDatabase, _Database);
  var _super = _createSuper(ReplayDatabase);
  function ReplayDatabase() {
    _classCallCheck(this, ReplayDatabase);
    return _super.apply(this, arguments);
  }
  _createClass(ReplayDatabase, [{
    key: "_version_1",
    value: function _version_1(connection) {
      const replayStore = this.createObjectStore('replays', {
        keyPath: 'id',
        autoIncrement: true
      });
      replayStore.createIndex('buildTime', 'buildTime', {
        unique: false
      });
      replayStore.createIndex('created', 'created', {
        unique: false
      });
      replayStore.createIndex('uuid', 'uuid', {
        unique: true
      });
      replayStore.createIndex('id', 'id', {
        unique: true
      });
    }
  }, {
    key: "_version_2",
    value: function _version_2(connection, instance, event) {
      const transaction = event.target.transaction;
      const replayStore = transaction.objectStore('replays');
      replayStore.createIndex('name', 'name', {
        unique: false
      });
      replayStore.createIndex('map', 'map', {
        unique: false
      });
    }
  }, {
    key: "_version_3",
    value: function _version_3(connection, instance, event) {
      const transaction = event.target.transaction;
      const replayStore = transaction.objectStore('replays');
      replayStore.createIndex('map-id', ['map', 'id'], {
        unique: true
      });
      console.log('existing index names in store', replayStore.indexNames);
    }
  }]);
  return ReplayDatabase;
}(_Database2.Database);
exports.ReplayDatabase = ReplayDatabase;
});

;require.register("replay/ReplayService.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ReplayService = void 0;
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let ReplayService = /*#__PURE__*/function () {
  function ReplayService(viewport) {
    _classCallCheck(this, ReplayService);
    this.viewport = viewport;
  }
  _createClass(ReplayService, [{
    key: "startDemo",
    value: function startDemo(replay) {
      let offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      const parent = this.viewport;
      parent.reset();
      parent.replayFrames = replay.getIndexedFrames();
      parent.replayStart = parent.replayFrames.get(offset || replay.firstFrame) || {};
      parent.replay = replay;
      parent.maxReplayFrame = replay.lastFrame;
      parent.replayOffset = -1 + replay.firstFrame + offset;
      Router.setQuery('demo', replay.uuid);
      parent.loadMap({
        mapUrl: replay.map
      }).then(() => {
        parent.args.paused = true;
        parent.playback();
      });
    }
  }]);
  return ReplayService;
}();
exports.ReplayService = ReplayService;
});

;require.register("save/Save.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Save = void 0;
var _Uuid = require("curvature/base/Uuid");
var _Model2 = require("curvature/model/Model");
var _SaveDatabase = require("./SaveDatabase");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let ProgressState = /*#__PURE__*/_createClass(function ProgressState() {
  _classCallCheck(this, ProgressState);
  _defineProperty(this, "lastCheckpoint", null);
  _defineProperty(this, "lastZone", null);
  _defineProperty(this, "zonesComplete", {});
  _defineProperty(this, "characters", {});
} // Object.preventExtensions(this);
);

const openDb = _SaveDatabase.SaveDatabase.open('saves', 1);
let Save = /*#__PURE__*/function (_Model) {
  _inherits(Save, _Model);
  var _super = _createSuper(Save);
  function Save() {
    var _this;
    _classCallCheck(this, Save);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    // emblems    = {};
    // characters = {};
    _defineProperty(_assertThisInitialized(_this), "id", null);
    _defineProperty(_assertThisInitialized(_this), "created", Date.now());
    _defineProperty(_assertThisInitialized(_this), "emeralds", []);
    _defineProperty(_assertThisInitialized(_this), "characters", {});
    _defineProperty(_assertThisInitialized(_this), "zones", {
      // '/map/empty-zone-2.json': {
      // 	emeralds: ['red']
      // 	, emblems: []
      // 	, lastCheckpoint: null
      // }
      // , '/map/emblem-test.json': {
      // 	emeralds: []
      // 	, emblems: []
      // 	, lastCheckpoint: null
      // }
    });
    return _this;
  }
  _createClass(Save, [{
    key: "getCharacterState",
    value: function getCharacterState(name) {
      const save = this.characters[name] || {
        cleared: {}
      };
      return this.characters[name] = save;
    }
  }, {
    key: "getZoneState",
    value: function getZoneState(zone) {
      const save = this.zones[zone] || {
        lastCheckpoint: null,
        emblems: [],
        chao: [],
        rings: 0,
        score: 0,
        time: 0
      };
      return this.zones[zone] = save;
    }
  }, {
    key: "save",
    value: function save() {
      openDb.then(database => {
        if (this.id) {
          database.update('saves', this);
        } else {
          this.id = String(new _Uuid.Uuid());
          database.insert('saves', this);
        }
      });
    }
  }, {
    key: "load",
    value: function load() {}
  }], [{
    key: "from",
    value: function from(skeleton) {
      const save = _get(_getPrototypeOf(Save), "from", this).call(this, skeleton);
      save.emeralds = Object.assign([], save.emeralds);
      for (const zone of Object.values(save.zones)) {
        zone.emblems = Object.assign([], zone.emblems);
        zone.chao = Object.assign([], zone.chao);
      }
      return save;
    }
  }, {
    key: "index",
    value: function index() {
      return openDb.then(database => {
        const query = {
          direction: 'next',
          index: 'created',
          store: 'saves'
        };
        const saves = [];
        return database.select(query).each(save => saves.push(save)).then(() => saves);
      });
    }
  }]);
  return Save;
}(_Model2.Model);
exports.Save = Save;
});

;require.register("save/SaveDatabase.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SaveDatabase = void 0;
var _Database2 = require("curvature/model/Database");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let SaveDatabase = /*#__PURE__*/function (_Database) {
  _inherits(SaveDatabase, _Database);
  var _super = _createSuper(SaveDatabase);
  function SaveDatabase() {
    _classCallCheck(this, SaveDatabase);
    return _super.apply(this, arguments);
  }
  _createClass(SaveDatabase, [{
    key: "_version_1",
    value: function _version_1(database) {
      this.createObjectStore('saves', {
        keyPath: 'id'
      }).createIndex('created', 'created', {
        unique: false
      });
    }
  }]);
  return SaveDatabase;
}(_Database2.Database);
exports.SaveDatabase = SaveDatabase;
});

;require.register("sprite/Png.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Png = void 0;
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
const header = [0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A];
let Pixel = /*#__PURE__*/function () {
  function Pixel() {
    let r = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    let g = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    let b = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    let a = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
    _classCallCheck(this, Pixel);
    _defineProperty(this, "r", 0);
    _defineProperty(this, "g", 0);
    _defineProperty(this, "b", 0);
    _defineProperty(this, "a", 1);
    this.r = r;
    this.g = g;
    this.b = b;
    this.a = a;
  }
  _createClass(Pixel, [{
    key: "mean",
    value: function mean() {
      return (this.r + this.g + this.b) / 3;
    }
  }, {
    key: "hex",
    value: function hex() {
      let length = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 3;
      if (length === 3) {
        return `${this.r.toString(16).padStart(2, '0')}${this.g.toString(16).padStart(2, '0')}${this.b.toString(16).padStart(2, '0')}`;
      }
      if (length === 4) {
        return `${this.r.toString(16).padStart(2, '0')}${this.g.toString(16).padStart(2, '0')}${this.b.toString(16).padStart(2, '0')}${this.a.toString(16).padStart(2, '0')}`;
      }
    }
  }, {
    key: "valueOf",
    value: function valueOf() {
      return `rgba(${this.r}, ${this.g}, ${this.b}, ${this.a})`;
    }
  }]);
  return Pixel;
}();
let Chunk = /*#__PURE__*/function () {
  function Chunk() {
    _classCallCheck(this, Chunk);
    _defineProperty(this, "previous", null);
    _defineProperty(this, "content", null);
    _defineProperty(this, "length", 0);
    _defineProperty(this, "start", 0);
    _defineProperty(this, "type", '');
    _defineProperty(this, "crc", 0);
  }
  _createClass(Chunk, [{
    key: "text",
    get: function get() {
      return this.bytes.map(b => String.fromCharCode(b)).join('');
    }
  }, {
    key: "bytes",
    get: function get() {
      const bytes = [];
      for (let i = 0; i < this.length; i++) {
        bytes.push(this.content.getUint8(i));
      }
      return bytes;
    }
  }]);
  return Chunk;
}();
let Png = /*#__PURE__*/function () {
  function Png(source) {
    _classCallCheck(this, Png);
    _defineProperty(this, "buffer", null);
    _defineProperty(this, "width", 0);
    _defineProperty(this, "height", 0);
    _defineProperty(this, "depth", 0);
    _defineProperty(this, "colorType", 0);
    _defineProperty(this, "compression", 0);
    _defineProperty(this, "filter", 0);
    _defineProperty(this, "interlace", 0);
    if (typeof source === 'string') {
      this.ready = fetch(source).then(response => response.arrayBuffer()).then(buffer => {
        this.buffer = buffer;
        this.checkHeader();
        this.indexChunks();
      });
    } else if (_typeof(source) === 'object') {
      if (source instanceof Png) {
        this.ready = Promise.resolve();
        this.buffer = source.buffer.slice(0);
        this.chunks = source.chunks.slice(0);

        // this.checkHeader();
        // this.indexChunks();
      }
    }
  }
  _createClass(Png, [{
    key: "checkHeader",
    value: function checkHeader() {
      const bytes = new Uint8Array(this.buffer);
      for (const i in header) {
        if (header[i] !== bytes[i]) {
          throw new Error('Png is not valid.');
        }
      }
    }
  }, {
    key: "readIhdr",
    value: function readIhdr() {
      const ihdr = this.chunks[0];
      this.width = ihdr.content.getUint32(0);
      this.height = ihdr.content.getUint32(4);
      this.depth = ihdr.content.getUint8(8);
      this.colorType = ihdr.content.getUint8(9);
      this.compression = ihdr.content.getUint8(10);
      this.filter = ihdr.content.getUint8(11);
      this.interlace = ihdr.content.getUint8(12);
    }
  }, {
    key: "palette",
    get: function get() {
      const palette = [];
      for (const i in this.chunks) {
        const chunk = this.chunks[i];
        if (chunk.type !== 'PLTE') {
          continue;
        }
        for (let ii = 0; ii < chunk.bytes.length; ii += 3) {
          const color = new Pixel(chunk.bytes[ii + 0], chunk.bytes[ii + 1], chunk.bytes[ii + 2]);
          palette.push(color);
        }
        return palette;
      }
    }
  }, {
    key: "recolor",
    value: function recolor() {
      let colorMap = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      const palette = this.palette;
      const newPalette = [];
      for (const i in palette) {
        const color = palette[i];
        const hex = color.hex();
        if (colorMap[hex]) {
          const newColor = colorMap[hex];
          const newR = newColor.substring(0, 2);
          const newG = newColor.substring(2, 4);
          const newB = newColor.substring(4, 6);
          const triplet = [newR, newG, newB].map(x => parseInt(x, 16));
          newPalette.push(...triplet);
        } else {
          newPalette.push(color.r, color.g, color.b);
        }
      }
      const newPng = new Png(this);
      for (const i in newPng.chunks) {
        const chunk = newPng.chunks[i];
        if (chunk.type !== 'PLTE') {
          continue;
        }
        const newBytes = new Uint8Array(newPng.buffer);
        const crcPointer = new DataView(newPng.buffer, chunk.start + chunk.length, 4);
        newBytes.set(newPalette, chunk.start);
        crcPointer.setUint32(0, newPng.runCrc(chunk));
      }
      return newPng;
    }
  }, {
    key: "runCrc",
    value: function runCrc(chunk) {
      if (!Png.crcTable) {
        Png.crcTable = new Uint32Array(256);
        for (let n = 0; n < 256; n++) {
          let c = n;
          for (let k = 0; k < 8; k++) {
            if ((c & 1) == 1) {
              c = 0xEDB88320 ^ c >>> 1;
            } else {
              c = c >>> 1;
            }
          }
          Png.crcTable[n] = c;
        }
      }
      let crc = 0xFFFFFFFF;
      const bytes = new Uint8Array(this.buffer);
      const chunkBytes = bytes.slice(chunk.start - 4, chunk.start + chunk.length);
      for (const i in chunkBytes) {
        const byte = chunkBytes[i];
        crc = Png.crcTable[(crc ^ byte) & 0xFF] ^ crc >>> 8;
      }
      crc = (crc ^ 0xFFFFFFFF) >>> 0;
      return crc;
    }
  }, {
    key: "indexChunks",
    value: function indexChunks() {
      const chunks = [];
      let pos = 8;
      while (pos < this.buffer.byteLength) {
        const lengthView = new DataView(this.buffer, pos, 4);
        pos += 4;
        const typeView = new DataView(this.buffer, pos, 4);
        pos += 4;
        const chunk = new Chunk();
        chunk.start = pos;
        chunk.length = lengthView.getUint32();
        for (let i = 0; i < 4; i++) {
          const byte = typeView.getUint8(i);
          const char = String.fromCharCode(byte);
          chunk.type += char;
        }
        chunk.content = new DataView(this.buffer, pos, chunk.length);
        pos += chunk.length;
        const crcView = new DataView(this.buffer, pos, 4);
        chunk.crc = crcView.getUint32();
        chunk.previous = chunks[chunks.length - 1];
        chunks.push(chunk);
        pos += 4;
      }
      this.chunks = chunks;
    }
  }, {
    key: "toBlob",
    value: function toBlob() {
      return new Blob([new Uint8Array(this.buffer)], {
        type: 'image/png'
      });
    }
  }, {
    key: "toUrl",
    value: function toUrl() {
      return URL.createObjectURL(this.toBlob());
    }
  }, {
    key: "toDataUri",
    value: function toDataUri() {
      if (this.getDataUri) {
        return this.getDataUri;
      }
      const reader = new FileReader();
      reader.readAsDataURL(this.toBlob());
      this.getDataUri = new Promise(accept => reader.addEventListener('load', event => accept(event.target.result)));
      return this.getDataUri;
    }
  }]);
  return Png;
}();
exports.Png = Png;
Png.Pixel = Pixel;
Png.Chunk = Chunk;
});

require.register("tally/TallyBoard.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TallyBoard = void 0;
var _Bindable = require("curvature/base/Bindable");
var _Mixin = require("curvature/base/Mixin");
var _EventTargetMixin = require("curvature/mixin/EventTargetMixin");
var _View = require("curvature/base/View");
var _Sfx = require("../audio/Sfx");
var _Bgm = require("../audio/Bgm");
var _TallyCounter = require("./TallyCounter");
var _CharacterString = require("../ui/CharacterString");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let TallyBoard = /*#__PURE__*/function (_Mixin$with) {
  _inherits(TallyBoard, _Mixin$with);
  var _super = _createSuper(TallyBoard);
  function TallyBoard() {
    var _this;
    _classCallCheck(this, TallyBoard);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _defineProperty(_assertThisInitialized(_this), "totalLabel", new _CharacterString.CharacterString({
      value: 'Total:',
      color: 'yellow'
    }));
    _defineProperty(_assertThisInitialized(_this), "totalValue", new _CharacterString.CharacterString({
      value: '0'
    }));
    _defineProperty(_assertThisInitialized(_this), "inventoryCounter", new _CharacterString.CharacterString({
      value: '-'
    }));
    _defineProperty(_assertThisInitialized(_this), "inventoryBump", '');
    _defineProperty(_assertThisInitialized(_this), "inventory", _Bindable.Bindable.make([]));
    _defineProperty(_assertThisInitialized(_this), "hasInventory", false);
    _defineProperty(_assertThisInitialized(_this), "counters", _Bindable.Bindable.make([]));
    _defineProperty(_assertThisInitialized(_this), "totaling", false);
    _defineProperty(_assertThisInitialized(_this), "totaled", false);
    _defineProperty(_assertThisInitialized(_this), "total", 0);
    _defineProperty(_assertThisInitialized(_this), "step", 200);
    _defineProperty(_assertThisInitialized(_this), "age", 0);
    _defineProperty(_assertThisInitialized(_this), "almostDone", false);
    _defineProperty(_assertThisInitialized(_this), "done", false);
    _defineProperty(_assertThisInitialized(_this), "doneAge", 0);
    return _this;
  }
  _createClass(TallyBoard, [{
    key: "update",
    value:
    // constructor(){}

    function update(viewport) {
      let totaled = true;
      let totaling = false;
      this.hasInventory = !!viewport.args.inventory.length;
      let beat = 15;
      let delay = 30;
      for (const counter of this.counters) {
        if (delay + beat + counter.index * beat === this.age) {
          _Sfx.Sfx.play('TALLY_SCORE');
          if (!counter.started) {
            counter.started = true;
            counter.display.args.value = counter.points;
            counter.display.args.color = 'white';
            counter.bump = 'bump';
          }
        }
        if (delay + 2 * beat + beat * (this.counters.length + viewport.args.inventory.length) + beat * counter.index > this.age) {
          totaled = false;
          continue;
        }
        counter.started = true;
        if (counter.display.args.value > 0) {
          const inc = Math.min(this.step, counter.display.args.value);
          this.total += inc;
          viewport.controlActor.args.score += inc;
          counter.display.args.value = Math.max(0, counter.display.args.value - this.step);
          totaling = true;
          totaled = false;
        }
      }
      let i = 0;
      for (const item of viewport.args.inventory) {
        i++;
        if (delay + (this.counters.length + i) * beat > this.age) {
          totaled = false;
          continue;
        }
        if (!item.tallied) {
          this.inventoryBump = '';
          viewport.onFrameOut(1, () => {
            _Sfx.Sfx.play('TALLY_SCORE');
            this.inventoryBump = 'bump';
          });
          this.inventory.push(item);
          this.inventoryCounter.args.value = (Number(this.inventoryCounter.args.value) || 0) + item.points;
          item.tallied = true;
        }
      }
      if (Number(this.inventoryCounter.args.value) > 0) {
        if (delay + (this.counters.length + i + 2) * beat + beat * 2 < this.age) {
          const inc = Math.min(this.step, Number(this.inventoryCounter.args.value) || 0);
          this.total += inc;
          viewport.controlActor.args.score += inc;
          this.inventoryCounter.args.value = Math.max(0, (Number(this.inventoryCounter.args.value) || 0) - this.step);
          totaling = true;
        }
        totaled = false;
      }
      if (totaling) {
        if (!this.totaling) {
          this.dispatchEvent('totalingstarted');
          this.totaling = true;
        }
      }
      if (!totaling) {
        if (this.totaling) {
          this.dispatchEvent('totalingdone');
          // this.totaling = false;
        }
      }

      this.totaled = totaled;
      if (this.totaled && this.totaling) {
        _Sfx.Sfx.play('TOTAL_SCORE');
        this.doneAge = this.age;
      }
      if (this.doneAge && this.age == this.doneAge + 60) {
        if (!this.almostDone) {
          this.almostDone = true;
          this.dispatchEvent('almostdone');
        }
      }
      if (this.doneAge && this.age > this.doneAge + 120) {
        if (!this.done) {
          this.done = true;
          this.dispatchEvent('done');
        }
      }
      this.totalValue.args.value = this.total;
      if (totaled) {
        this.totaling = false;
      }
      if (this.totaling && !this.totaled) {
        _Sfx.Sfx.play('SWITCH_HIT');
      }
      this.age++;
    }
  }, {
    key: "view",
    value: function view() {
      return _View.View.from(require('./tally-board.html'), this);
    }
  }, {
    key: "addCounter",
    value: function addCounter(_ref) {
      let _ref$type = _ref.type,
        type = _ref$type === void 0 ? 'label' : _ref$type,
        _ref$label = _ref.label,
        label = _ref$label === void 0 ? 'counter' : _ref$label,
        _ref$value = _ref.value,
        value = _ref$value === void 0 ? 0 : _ref$value,
        _ref$required = _ref.required,
        required = _ref$required === void 0 ? true : _ref$required;
      if (!value && !required) {
        return;
      }
      const counter = new _TallyCounter.TallyCounter();
      counter.display = new _CharacterString.CharacterString({
        value: '-',
        color: 'grey'
      });
      counter.points = value;
      counter.label = new _CharacterString.CharacterString({
        value: label,
        color: 'yellow'
      });
      counter.index = this.counters.length;
      this.counters.push(counter);

      // console.log(counter);
    }
  }]);
  return TallyBoard;
}(_Mixin.Mixin.with( /*#__PURE__*/function () {
  function _class() {
    _classCallCheck(this, _class);
  }
  return _createClass(_class);
}(), _EventTargetMixin.EventTargetMixin));
exports.TallyBoard = TallyBoard;
});

;require.register("tally/TallyCounter.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TallyCounter = void 0;
var _Bindable = require("curvature/base/Bindable");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let TallyCounter = /*#__PURE__*/_createClass(function TallyCounter() {
  _classCallCheck(this, TallyCounter);
  _defineProperty(this, "multiplier", 1);
  _defineProperty(this, "points", 0);
  _defineProperty(this, "value", 0);
  _defineProperty(this, "type", TallyCounter.TYPE_LABEL);
  _defineProperty(this, "label", '');
  _defineProperty(this, "icon", '');
  _defineProperty(this, "items", []);
  _defineProperty(this, "started", 0);
  _defineProperty(this, "display", 0);
  _defineProperty(this, "visible", 0);
  _defineProperty(this, "index", 0);
  return _Bindable.Bindable.make(this);
});
exports.TallyCounter = TallyCounter;
TallyCounter.TYPE_LABEL = 0;
TallyCounter.TYPE_ICONS = 1;
TallyCounter.TYPE_ITEMS = 2;
});

require.register("tally/tally-board.html", function(exports, require, module) {
module.exports = "<div class = \"tally-board\">\n\t<div class = \"tally-board-content\" cv-each = \"counters:counter\">\n\t\t<div class = \"tally-board-row\">\n\t\t\t<div>[[counter.label]]</div>\n\t\t\t<div class = \"tally-item [[counter.bump]]\">[[counter.display]]</div>\n\t\t</div>\n\t</div>\n\t<div class = \"tally-board-content tally-board-inventory\" cv-if = \"hasInventory\">\n\t\t<div class = \"tally-board-row\">\n\t\t\t<div cv-each = \"inventory:item\"><img loading=\"lazy\" src = \"[[item.tallyIcon]]\" class = \"inventory-icon\" /></div>\n\t\t\t<div class = \"tally-item [[inventoryBump]]\">[[inventoryCounter]]</div>\n\t\t</div>\n\t</div>\n\t</div>\n\t<div class = \"tally-board-row tally-board-total\">\n\t\t<div>[[totalLabel]]</div>\n\t\t<div>[[totalValue]]</div>\n\t</div>\n</div>\n"
});

;require.register("tileMap/Elicit.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Elicit = void 0;
var _Mixin = require("curvature/base/Mixin");
var _EventTargetMixin = require("curvature/mixin/EventTargetMixin");
var _PromiseMixin = require("curvature/mixin/PromiseMixin");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let Elicit = /*#__PURE__*/function (_Mixin$with) {
  _inherits(Elicit, _Mixin$with);
  var _super = _createSuper(Elicit);
  function Elicit(url) {
    var _this;
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    _classCallCheck(this, Elicit);
    _this = _super.call(this);
    _this.fetch = fetch(url, options).then(response => _this.handleFetch(response));
    return _this;
  }
  _createClass(Elicit, [{
    key: "headers",
    value: function headers() {
      return this.fetch.then(_ref => {
        let response = _ref.response,
          stream = _ref.stream;
        return response.headers;
      });
    }
  }, {
    key: "stream",
    value: function stream(url) {
      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return this.fetch.then(_ref2 => {
        let response = _ref2.response,
          stream = _ref2.stream;
        return new Response(stream, {
          headers: response.headers
        });
      });
    }
  }, {
    key: "objectUrl",
    value: function objectUrl(url) {
      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return this.stream(url, options).then(response => response.blob()).then(blob => URL.createObjectURL(blob));
    }
  }, {
    key: "emitProgressEvent",
    value: function emitProgressEvent(length, received) {
      const done = length ? received / length : 0;
      this.dispatchEvent(new CustomEvent('progress', {
        detail: {
          length: length,
          received: received,
          done: done
        }
      }));
    }
  }, {
    key: "iterateDownload",
    value: function iterateDownload(reader, controller, length) {
      this.emitProgressEvent(length, 0);
      let received = 0;
      const iterate = () => {
        reader.read().then(_ref3 => {
          let done = _ref3.done,
            value = _ref3.value;
          if (done) {
            this[_PromiseMixin.PromiseMixin.Accept]();
            controller.close();
            return;
          }
          controller.enqueue(value);
          received += value.length;
          this.emitProgressEvent(length, received);
          return iterate();
        });
      };
      return iterate();
    }
  }, {
    key: "handleFetch",
    value: function handleFetch(response) {
      const reader = response.body.getReader();
      const length = response.headers.get('Content-Length');
      const elicit = this;
      const stream = new ReadableStream({
        start: function start(controller) {
          elicit.iterateDownload(reader, controller, length);
        }
      });
      return {
        response: response,
        stream: stream
      };
    }
  }]);
  return Elicit;
}(_Mixin.Mixin.with(_EventTargetMixin.EventTargetMixin, _PromiseMixin.PromiseMixin));
exports.Elicit = Elicit;
});

;require.register("tileMap/TileMap.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TileMap = void 0;
var _Tag = require("curvature/base/Tag");
var _Mixin = require("curvature/base/Mixin");
var _Bindable = require("curvature/base/Bindable");
var _EventTargetMixin = require("curvature/mixin/EventTargetMixin");
var _Elicit = require("./Elicit");
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let TileMap = /*#__PURE__*/function (_Mixin$with) {
  _inherits(TileMap, _Mixin$with);
  var _super = _createSuper(TileMap);
  function TileMap(args, parent) {
    var _this;
    _classCallCheck(this, TileMap);
    _this = _super.call(this);
    _this.preloaders = new Map();
    _this.meta = new Map();
    _this.heightMask = null;
    _this.tileImages = new Map();
    _this.tileNumberCache = new Map();
    _this.tileSetCache = new Map();
    _this.tileCache = new Map();
    _this.heightMasks = new Map();
    _this.heightMaskCache = new Map();
    _this.prefixed = new Map();
    _this.mapDirectory = '/map';
    _this.tileLayers = [];
    _this.destructibleLayers = [];
    _this.collisionLayers = [];
    _this.objectLayers = [];
    _this.mapVars = new Map();
    const url = args.mapUrl;
    _this.mapData = null;
    _this.mapUrl = url;
    _this.maps = new Map();
    _this.replacements = new Map();
    _this.loaded = new Map();
    _this.emptyCache = new Map();
    if (String(url).substr(-4) === 'json') {
      const elicit = new _Elicit.Elicit(url);
      elicit.addEventListener('progress', event => {
        const _event$detail = event.detail,
          received = _event$detail.received,
          length = _event$detail.length,
          done = _event$detail.done;
        const type = 'map';
        _this.dispatchEvent(new CustomEvent('level-progress', {
          detail: {
            length: length,
            received: received,
            done: done,
            url: url
          }
        }));
      });
      _this.ready = elicit.stream().then(response => response.json()).then(tilemapData => {
        _this.mapData = tilemapData;
        if (tilemapData && tilemapData.properties) {
          for (const property of tilemapData.properties) {
            const name = property.name.replace(/-/g, '_');
            _this.meta.set(name, property.value);
          }
        }
        _this.desparseLayers(tilemapData);
        _this.loadLayers(tilemapData);
        return _this.loadTilesets(tilemapData);
      });
    } else if (String(url).substr(-3) === 'png') {
      _this.ready = _this.fromImage(url, 32);
    }
    Object.preventExtensions(_assertThisInitialized(_this));
    return _this;
  }
  _createClass(TileMap, [{
    key: "desparseLayers",
    value: function desparseLayers(tilemapData) {
      // console.time('desparse');

      for (const layer of tilemapData.layers) {
        if (layer.type !== 'tilelayer' || !layer.sparsed || layer.data) {
          continue;
        }
        const desparsed = layer.data = Object.create(null);
        while (layer.sparsed.length) {
          const tileNo = Number(layer.sparsed.pop());
          const tileId = Number(layer.sparsed.pop());
          desparsed[tileId] = tileNo;
        }

        // layer.data = layer.data ? [...Object.assign(Array(layer.width * layer.height), layer.data)] : undefined;
        // layer.data = layer.data.map(t => t || 0);

        // console.log(layer.data);
      }

      // console.log(tilemapData);
      // console.log(JSON.stringify(tilemapData));

      // console.timeEnd('desparse');
    }
  }, {
    key: "preloadMap",
    value: function preloadMap(url) {
      if (this.preloaders.has(url)) {
        return this.preloaders.get(url);
      }
      const elicit = new _Elicit.Elicit(url);

      // elicit.addEventListener('progress', event => {
      // const {received, length, done} = event.detail;
      // const type = 'map';
      // this.dispatchEvent(new CustomEvent(
      // 	'level-progress', {detail: {length, received, done, url}}
      // ));
      // });

      const res = elicit.stream().then(response => response.json());
      this.preloaders.set(url, res);
      return res;
    }
  }, {
    key: "append",
    value: function append(url, xOffset, yOffset) {
      let maxObjectId = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      return this.preloadMap(url).then(data => {
        const width = this.mapData.width;
        const overlap = -width + xOffset;
        const newWidth = width + data.width + overlap;

        // console.log({width, dw:data.width, newWidth, overlap, xOffset});

        const height = this.mapData.height;
        const newHeight = Math.max(height, height + data.height + -Math.round(yOffset / 32));
        this.resize(newWidth, height);
        this.desparseLayers(data);
        let lastGid = 0;
        for (const tileset of this.mapData.tilesets) {
          lastGid += tileset.tilecount;
        }
        for (const tileset of data.tilesets) {
          tileset.firstgid += lastGid;
        }
        for (const newLayer of data.layers) {
          const newData = Object.create(null);
          const sizeOffset = this.mapData.width - newLayer.width;
          const offset = xOffset + yOffset * this.mapData.width;
          if (!newLayer.data) {
            continue;
          }
          for (let i of Object.keys(newLayer.data)) {
            const tileId = Number(i);
            const tileNo = Number(newLayer.data[i]);
            const row = Math.floor(tileId / newLayer.width);
            delete newLayer.data[i];
            newData[row * sizeOffset + offset + tileId] = tileNo + lastGid;
          }
          for (let i in newData) {
            newLayer.data[i] = newData[i];
          }
          for (const existingLayer of this.mapData.layers) {
            if (newLayer.name !== existingLayer.name) {
              continue;
            }
            for (const i in newLayer.data) {
              existingLayer.data[i] = newLayer.data[i];
            }
            existingLayer.layer.setMeta(newLayer, maxObjectId);
          }
        }
        for (const newTileset of data.tilesets) {
          this.mapData.tilesets.push(newTileset);
        }
        this.tileNumberCache.clear();
        return this.loadTilesets(data).then(() => {
          return {
            defs: this.getObjectDefs(data, lastGid),
            data: data
          };
        });
      });
    }
  }, {
    key: "resize",
    value: function resize(newWidth, newHeight) {
      let tileLayers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.tileLayers;
      const mapData = this.mapData;
      const originalWidth = mapData.width;
      const originalHeight = mapData.height;
      mapData.width = newWidth;
      mapData.height = newHeight;
      const offset = newWidth - originalWidth;
      for (const layer of tileLayers) {
        const newData = Object.create(null);
        for (let i of Object.keys(layer.data)) {
          const tileId = Number(i);
          const tileNo = Number(layer.data[i]);
          const row = Math.floor(tileId / originalWidth);
          layer.data[i] = undefined;
          newData[row * offset + tileId] = tileNo;
        }
        for (let i in newData) {
          layer.data[i] = newData[i];
        }
      }
      this.tileNumberCache.clear();
    }
  }, {
    key: "offset",
    value: function offset(xOffset, yOffset) {
      let tileLayers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.tileLayers;
      const offset = xOffset + yOffset * this.mapData.width;
      for (const layer of tileLayers) {
        const newData = Object.create(null);
        for (let i in layer.data) {
          const name = Number(layer.name);
          const tileId = Number(i);
          const tileNo = Number(layer.data[i]);
          layer.data[i] = 0;
          newData[offset + tileId] = tileNo;
        }
        for (let i in newData) {
          layer.data[i] = newData[i];
        }
      }
      this.tileNumberCache.clear();
    }
  }, {
    key: "loadTilesets",
    value: function loadTilesets(mapData) {
      const setHeightMasks = [];
      const imageProgress = new Map();
      const imageSize = new Map();
      this.emptyCache.clear();
      for (const tileset of mapData.tilesets) {
        const image = new Image();
        this.tileImages.set(tileset, image);
        if (!this.prefixed.has(tileset)) {
          this.prefixed.set(tileset, String(this.mapDirectory + '/' + tileset.image).replace(/\/\/+/g, '/'));
        }
        const imageUrl = this.prefixed.get(tileset);
        tileset.original = tileset.image = imageUrl;
        const fetchImage = new _Elicit.Elicit(imageUrl);
        fetchImage.addEventListener('progress', event => {
          const _event$detail2 = event.detail,
            received = _event$detail2.received,
            length = _event$detail2.length,
            done = _event$detail2.done;
          imageProgress.set(fetchImage, received);
          imageSize.set(fetchImage, length);
          const imagesProgress = [...imageProgress.values()].reduce((a, b) => Number(a) + Number(b));
          const imagesLength = [...imageSize.values()].reduce((a, b) => Number(a) + Number(b));
          const imagesDone = imagesProgress / imagesLength;
          this.dispatchEvent(new CustomEvent('texture-progress', {
            detail: {
              length: imagesLength,
              received: imagesProgress,
              done: imagesDone,
              url: imageUrl
            }
          }));
        });
        const heightMask = fetchImage.objectUrl().then(url => new Promise(accept => {
          tileset.cachedImage = url;
          image.addEventListener('load', event => {
            if (!this.replacements.has(imageUrl)) {
              this.replacements.set(imageUrl, url);
            }
            this.loaded.set(imageUrl, url);
            const heightMask = document.createElement('canvas');
            heightMask.width = image.width;
            heightMask.height = image.height;
            heightMask.getContext('2d').drawImage(image, 0, 0, image.width, image.height);
            this.heightMasks.set(tileset, heightMask.getContext('2d').getImageData(0, 0, heightMask.width, heightMask.height));
            accept(heightMask);
          }, {
            once: true
          });
          image.src = url;
        }));
        setHeightMasks.push(heightMask);
      }
      return Promise.all(setHeightMasks);
    }
  }, {
    key: "loadLayers",
    value: function loadLayers(tilemapData) {
      const layerGroup = Object.create(null);
      const layers = tilemapData.layers || [];
      tilemapData.layers.forEach((layer, index) => {
        layer.offsetX = false;
        layer.offsetY = false;
        layer.offsetXChanged = false;
        layer.offsetYChanged = false;
        layer.destroyed = false;
        layer.layer = null;
        layer.index = null;
        Object.preventExtensions(layer);
      });
      this.objectLayers = tilemapData.layers.filter(l => l.type === 'objectLayers');
      this.tileLayers = tilemapData.layers.filter(l => l.type === 'tilelayer');
      this.tileLayers.forEach((layer, index) => layer.index = index);

      // layerGroup.objectLayers = this.objectLayers;
      layerGroup.tileLayers = this.tileLayers;
      this.collisionLayers = this.tileLayers.filter(l => {
        if (!l.name.match(/^Collision\s\d+/)) {
          return false;
        }
        return true;
      });
      this.destructibleLayers = this.tileLayers.filter(l => {
        if (!l.name.match(/^Destructible\s\d+/)) {
          return false;
        }
        return true;
      });
      layerGroup.destructibleLayers = this.destructibleLayers;
      layerGroup.collisionLayers = this.collisionLayers;
    }
  }, {
    key: "addMap",
    value: function addMap(url) {
      let xOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      let yOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      const elicit = new _Elicit.Elicit(url);
      elicit.stream().then(response => response.json()).then(data => {
        // console.log(data);
      });
      elicit.addEventListener('progress', event => {
        const _event$detail3 = event.detail,
          received = _event$detail3.received,
          length = _event$detail3.length,
          done = _event$detail3.done;

        // const type = 'map';

        // this.dispatchEvent(new CustomEvent(
        // 	'level-progress', {detail: {length, received, done, url}}
        // ));
      });

      this.objectLayers = tilemapData.layers.filter(l => l.type === 'objectLayers');
      this.tileLayers = tilemapData.layers.filter(l => l.type === 'tilelayer');
      this.tileLayers.forEach((layer, index) => layer.index = index);

      // layerGroup.objectLayers = this.objectLayers;
      layerGroup.tileLayers = this.tileLayers;
      this.collisionLayers = this.tileLayers.filter(l => {
        if (!l.name.match(/^Collision\s\d+/)) {
          return false;
        }
        return true;
      });
      this.destructibleLayers = this.tileLayers.filter(l => {
        if (!l.name.match(/^Destructible\s\d+/)) {
          return false;
        }
        return true;
      });
      layerGroup.destructibleLayers = this.destructibleLayers;
      layerGroup.collisionLayers = this.collisionLayers;
    }
  }, {
    key: "coordsToTile",
    value: function coordsToTile(x, y, layerId) {
      const blockSize = this.blockSize;
      let offsetX = 0;
      let offsetY = 0;
      if (this.tileLayers[layerId]) {
        var _this$tileLayers$laye, _this$tileLayers$laye2;
        offsetX = (_this$tileLayers$laye = this.tileLayers[layerId].offsetX) !== null && _this$tileLayers$laye !== void 0 ? _this$tileLayers$laye : 0;
        offsetY = (_this$tileLayers$laye2 = this.tileLayers[layerId].offsetY) !== null && _this$tileLayers$laye2 !== void 0 ? _this$tileLayers$laye2 : 0;
      }
      return [Math.floor((x - offsetX) / blockSize), Math.floor((y - offsetY) / blockSize)];
    }
  }, {
    key: "getTileNumber",
    value: function getTileNumber(x, y) {
      let layerId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      // const tileKey = x + ',' + y + ',' + layerId;
      // const cached  = this.tileNumberCache.get(tileKey);

      // if(cached !== undefined)
      // {
      // 	return cached;
      // }

      const tileLayers = this.tileLayers;
      if (!tileLayers[layerId]) {
        // this.tileNumberCache.set(tileKey, false);
        return false;
      }
      const mapData = this.mapData;
      const mapWidth = mapData.width;
      const mapHeight = mapData.height;
      if (x >= mapWidth || x < 0) {
        if (x < 0 || !this.meta.get('wrapX')) {
          if (layerId !== 0) {
            // this.tileNumberCache.set(tileKey, false);
            return false;
          }

          // this.tileNumberCache.set(tileKey, 1);

          return 1;
        } else {
          if (x < 0 && x % mapWidth !== 0) {
            y++;
          }
          x = x % mapWidth;
        }
      }
      if (y >= mapHeight || y < 0) {
        if (y < 0 || !this.meta.get('wrapY')) {
          if (layerId !== 0) {
            // this.tileNumberCache.set(tileKey, false);

            return false;
          }

          // this.tileNumberCache.set(tileKey, 1);

          return 1;
        } else {
          y = y % mapHeight;
        }
      }
      const tileIndex = y * mapWidth + x;
      if (tileIndex in tileLayers[layerId].data) {
        const layer = tileLayers[layerId];
        const tile = layer.data[tileIndex];
        const tileNumber = tile > 0 ? tile - 1 : 0;
        if (this.checkEmpty(tileNumber)) {
          // this.tileNumberCache.set(tileKey, false);
          return false;
        }

        // this.tileNumberCache.set(tileKey, tileNumber);

        return tileNumber;
      }

      // this.tileNumberCache.set(tileKey, false);

      return false;
    }
  }, {
    key: "getObjectDefs",
    value: function getObjectDefs() {
      let mapData = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.mapData;
      let startGid = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      if (!mapData) {
        return;
      }
      return mapData.layers.filter(layer => layer.type === 'objectgroup').map(layer => layer.objects).flat().map(o => {
        if (typeof o.gid !== 'undefined') {
          o.gid += startGid;
        }
        return o;
      });
    }
  }, {
    key: "getTile",
    value: function getTile(tileNumber) {
      const cached = this.tileCache.get(tileNumber);
      if (cached !== undefined) {
        if (this.replacements.has(cached[3])) {
          cached[2] = this.replacements.get(cached[3]);
        } else if (this.loaded.has(cached[3])) {
          cached[2] = this.loaded.get(cached[3]);
        }
        return cached;
      }
      const blockSize = this.blockSize;
      let x = 0;
      let y = 0;
      let src = '';
      let original = '';
      const tileset = this.getTileset(tileNumber);
      const image = this.tileImages.get(tileset);
      if (!tileset.meta && tileset.properties) {
        tileset.meta = Object.create(null);
        for (const property of tileset.properties) {
          tileset.meta[property.name] = property.value;
        }
      }
      if (tileNumber) {
        const localTileNumber = tileNumber + -tileset.firstgid + 1;
        const blocksWide = Math.ceil(image.width / blockSize);
        x = localTileNumber % blocksWide;
        y = Math.floor(localTileNumber / blocksWide);
        src = tileset.image;
        original = tileset.original;
      }
      const result = [x, y, src, original, tileset];
      Object.preventExtensions(result);
      this.tileCache.set(tileNumber, result);
      return result;
    }
  }, {
    key: "getSolid",
    value: function getSolid(xInput, yInput) {
      let layerInput = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      xInput = Math.trunc(xInput);
      yInput = Math.trunc(yInput);
      let offsetX = 0;
      let offsetY = 0;
      let tileNumber;
      let checkLayers;
      if (!(layerInput instanceof Map)) {
        checkLayers = new Map();
        checkLayers.set(this.tileLayers[0], true);
        checkLayers.set(this.tileLayers[layerInput], true);
      } else {
        checkLayers = layerInput;
      }
      for (const _ref of checkLayers) {
        var _ref2 = _slicedToArray(_ref, 2);
        const layer = _ref2[0];
        const willCheck = _ref2[1];
        if (!willCheck) {
          continue;
        }
        const layerId = layer.index;

        // if(layerId !== 0)
        // {
        // 	if(this.getSolid(xInput, yInput, 0))
        // 	{
        // 		return this.tileLayers[0];
        // 	}
        // }

        if (this.tileLayers[layerId]) {
          var _this$tileLayers$laye3, _this$tileLayers$laye4;
          offsetX = (_this$tileLayers$laye3 = this.tileLayers[layerId].offsetX) !== null && _this$tileLayers$laye3 !== void 0 ? _this$tileLayers$laye3 : 0;
          offsetY = (_this$tileLayers$laye4 = this.tileLayers[layerId].offsetY) !== null && _this$tileLayers$laye4 !== void 0 ? _this$tileLayers$laye4 : 0;
        }
        tileNumber = this.getTileNumber(Math.floor((xInput - offsetX) / this.blockSize), Math.floor((yInput - offsetY) / this.blockSize), layerId);
        const solidLayerCount = this.collisionLayers.length;
        if (layerId <= 3) {
          if (tileNumber === 0) {
            continue;
            // return false;
          }

          if (tileNumber === 1) {
            return this.tileLayers[layerId];
          }
        }

        // if(this.getSolid(xInput, yInput, layerInput))
        // {
        // 	return this.tileLayers[i];
        // }

        // if(layerId > 0  && layerId < solidLayerCount)
        // {
        // 	for(let i = 0 + solidLayerCount; i < this.tileLayers.length; i++)
        // 	{
        // 		const layer = this.tileLayers[i];

        // 		if(layer.name.substring(0, 3) === 'Art')
        // 		{
        // 			continue;
        // 		}

        // 		// if(layer.name.substring(0, 8) === 'Platform')
        // 		// {
        // 		// 	continue;
        // 		// }

        // 		if(layer.name.substring(0, 10) === 'Moving Art')
        // 		{
        // 			continue;
        // 		}

        // 		if(layer.name.substring(0, 10) === 'Foreground')
        // 		{
        // 			continue;
        // 		}

        // 		if(layer.name.substring(0, 12) === 'Destructible')
        // 		{
        // 			if(layer.destroyed)
        // 			{
        // 				continue;
        // 			}
        // 		}

        // 		if(this.getSolid(xInput, yInput, i))
        // 		{
        // 			return this.tileLayers[i];
        // 		}
        // 	}
        // }

        const tileSet = this.getTileset(tileNumber);
        const mapData = this.mapData;
        const blockSize = mapData.tilewidth;
        const tileCoords = this.getTile(tileNumber);
        const tilePosX = tileCoords[0] * blockSize;
        const tilePosY = tileCoords[1] * blockSize;
        const x = Number(xInput) % blockSize;
        const y = Number(yInput) % blockSize;
        const xPixel = tilePosX + x;
        const yPixel = tilePosY + y;
        const heightMask = this.heightMasks.get(tileSet);
        const iPixel = (xPixel + yPixel * heightMask.width) * 4;
        let result = false;
        if (heightMask.data[iPixel + 3] === 255) {
          return this.tileLayers[layerId];
        }
        // else
        // {
        // 	result = false;
        // }

        // if(result)
        // {
        // 	return result;
        // }
      }
    }
  }, {
    key: "getColor",
    value: function getColor(xInput, yInput, layerInput) {
      let offsetX = 0;
      let offsetY = 0;
      if (this.tileLayers[layerInput]) {
        var _this$tileLayers$laye5, _this$tileLayers$laye6;
        offsetX = (_this$tileLayers$laye5 = this.tileLayers[layerInput].offsetX) !== null && _this$tileLayers$laye5 !== void 0 ? _this$tileLayers$laye5 : 0;
        offsetY = (_this$tileLayers$laye6 = this.tileLayers[layerInput].offsetY) !== null && _this$tileLayers$laye6 !== void 0 ? _this$tileLayers$laye6 : 0;
      }
      const tileNumber = this.getTileNumber(Math.floor((xInput - offsetX) / this.blockSize), Math.floor((yInput - offsetY) / this.blockSize), layerInput);
      const tileSet = this.getTileset(tileNumber);
      const mapData = this.mapData;
      const blockSize = mapData.tilewidth;
      const tileCoords = this.getTile(tileNumber);
      const tilePos = [tileCoords[0] * blockSize, tileCoords[1] * blockSize];
      const x = Number(xInput) % blockSize;
      const y = Number(yInput) % blockSize;
      const xPixel = tilePos[0] + x;
      const yPixel = tilePos[1] + y;
      const heightMask = this.heightMasks.get(tileSet);
      const iPixel = (xPixel + yPixel * heightMask.width) * 4;
      return (heightMask.data[iPixel + 0] << 24) + (heightMask.data[iPixel + 1] << 16) + (heightMask.data[iPixel + 2] << 8) + (heightMask.data[iPixel + 3] << 0);
    }
  }, {
    key: "checkEmpty",
    value: function checkEmpty(tileNumber) {
      if (this.emptyCache.has(tileNumber)) {
        return this.emptyCache.get(tileNumber);
      }
      const tile = this.getTile(tileNumber);
      const tileSet = this.getTileset(tileNumber);
      const mapData = this.mapData;
      const blockSize = mapData.tilewidth;
      const tileCoords = this.getTile(tileNumber);
      const tilePos = [tileCoords[0] * blockSize, tileCoords[1] * blockSize];
      for (let x = 0; x < blockSize; x++) for (let y = 0; y < blockSize; y++) {
        const xPixel = tilePos[0] + x;
        const yPixel = tilePos[1] + y;
        const heightMask = this.heightMasks.get(tileSet);
        const iPixel = (xPixel + yPixel * heightMask.width) * 4;
        if (heightMask.data[iPixel + 3] > 0) {
          this.emptyCache.set(tileNumber, false);
          return false;
        }
      }
      this.emptyCache.set(tileNumber, true);
      return true;
    }
  }, {
    key: "getTileset",
    value: function getTileset(tileNumber) {
      tileNumber = Number(tileNumber);
      const cache = this.tileSetCache;
      if (cache.has(tileNumber)) {
        const cached = cache.get(tileNumber);
        if (this.replacements.has(cached.original)) {
          cached.image = this.replacements.get(cached.original);
        }
        return cached;
      }
      if (!this.mapData) {
        return;
      }
      for (const i in this.mapData.tilesets) {
        const tileset = this.mapData.tilesets[i];
        if (tileNumber + 1 >= tileset.firstgid) {
          const nextTileset = this.mapData.tilesets[Number(i) + 1];
          if (nextTileset) {
            if (tileNumber + 1 < nextTileset.firstgid) {
              cache.set(tileNumber, tileset);
              if (this.replacements.has(tileset.original)) {
                tileset.image = this.replacements.get(tileset.original);
              }
              return tileset;
            }
          } else {
            cache.set(tileNumber, tileset);
            if (this.replacements.has(tileset.original)) {
              tileset.image = this.replacements.get(tileset.original);
            }
            return tileset;
          }
        }
      }
    }
  }, {
    key: "unreplace",
    value: function unreplace() {
      this.replacements.clear();
      this.tileCache.clear();
    }
  }, {
    key: "reset",
    value: function reset() {
      this.tileSetCache.clear();
      this.replacements.clear();
      this.tileCache.clear();
      for (let i = 0; i < this.tileLayers.length; i++) {
        const layer = this.tileLayers[i];
        layer.destroyed = false;
      }
      for (const tileset of this.mapData.tilesets) {
        tileset.image = tileset.original;
      }
      this.loadTilesets(this.mapData);
    }
  }, {
    key: "castRay",
    value: function castRay(startX, startY, angle) {
      let maxDistance = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 320;
      let layerId = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
      const checkLayers = layerId instanceof Map ? new Map([...layerId.entries()].filter(x => x[1]))
      // : new Map([[this.tileLayers[0], true], [this.tileLayers[layerId], true]]);
      : new Map();
      const xOffDir = new Map();
      const yOffDir = new Map();
      if (!(layerId instanceof Map)) for (const layer of this.tileLayers) {
        if (!layer.layer || !layer.layer.meta || !layer.layer.meta.solid) {
          continue;
        }
        if (layer.layer.meta.switchable && layer.index !== layerId) {
          continue;
        }

        // if(layer.layer.meta.platform)
        // {
        // 	if(angle < 0 || angle > Math.PI)
        // 	{
        // 		continue;
        // 	}
        // }

        checkLayers.set(layer, true);
        xOffDir.set(layer.index, Math.sign(layer.layer.args.offsetX));
        yOffDir.set(layer.index, Math.sign(layer.layer.args.offsetY));
      }

      // startX = Math.trunc(startX);
      // startY = Math.trunc(startY);

      maxDistance = Math.ceil(maxDistance);
      const cos = Math.cos(angle);
      const sin = Math.sin(angle);
      const endX = startX + (Math.abs(cos) > Number.EPSILON ? cos : 0) * maxDistance;
      const endY = startY + (Math.abs(sin) > Number.EPSILON ? sin : 0) * maxDistance;
      const bs = this.blockSize;
      const dx = endX - startX;
      const dy = endY - startY;
      const ox = Math.sign(dx);
      const oy = Math.sign(dy);
      const sx = dx ? Math.hypot(1, dy / dx) : 0;
      const sy = dy ? Math.hypot(1, dx / dy) : 0;
      let currentDistance = 0;
      if (this.getSolid(startX, startY, layerId)) {
        return [startX, startY];
      }
      let initMode;
      const txy = this.coordsToTile(startX, startY, layerId) || this.coordsToTile(startX, startY, 0);
      for (const _ref3 of checkLayers) {
        var _ref4 = _slicedToArray(_ref3, 2);
        const layer = _ref4[0];
        const willCheck = _ref4[1];
        if (!willCheck) {
          continue;
        }
        if (initMode = this.getTileNumber(txy[0], txy[1], layer.index)) {
          break;
        }
      }
      let modeX = initMode;
      let modeY = initMode;
      let oldModeX = false;
      let oldModeY = false;
      let bf = initMode ? 1 : 1;
      const ax = ox > 0 ? bs - startX % bs : startX % bs + 1;
      const ay = oy > 0 ? bs - startY % bs : startY % bs + 1;
      let checkX = initMode ? 0 : ax;
      let checkY = initMode ? 0 : ay;
      let rayX = checkX * sx * ox;
      let rayY = checkY * sy * oy;
      const magX = Math.abs(rayX);
      const magY = Math.abs(rayY);
      const pa = new Set();
      const pb = new Set();
      const solidsX = new Set();
      const solidsY = new Set();
      window.logPoints && console.time('rayCast');
      let iterations = 0;
      while (Math.abs(currentDistance) < maxDistance && !solidsX.size && !solidsY.size) {
        if (ox && (!oy || Math.abs(rayX) < Math.abs(rayY))) {
          const mag = Math.abs(rayX);
          let px = startX + mag * Math.cos(angle);
          let py = startY + mag * Math.sin(angle);
          if (ox > 0 && px % 1 > 0.99999) px = Math.round(px);
          if (oy > 0 && py % 1 > 0.99999) py = Math.round(py);
          if (ox < 0 && px % 1 < 0.00001) px = Math.round(px);
          if (oy < 0 && py % 1 < 0.00001) py = Math.round(py);
          const _this$coordsToTile = this.coordsToTile(px, py, layerId),
            _this$coordsToTile2 = _slicedToArray(_this$coordsToTile, 2),
            tx = _this$coordsToTile2[0],
            ty = _this$coordsToTile2[1];
          oldModeX = modeX;
          for (const _ref5 of checkLayers) {
            var _ref6 = _slicedToArray(_ref5, 2);
            const layer = _ref6[0];
            const willCheck = _ref6[1];
            {
              const layerId = layer.index;
              if (!willCheck) {
                continue;
              }
              if (modeX = this.getTileNumber(tx, ty, layerId)) {
                break;
              }
              if (!modeX && (xOffDir.has(layerId) || yOffDir.has(layerId))) {
                if (modeX = this.getTileNumber(tx + -xOffDir.get(layerId), ty, layerId)) {
                  break;
                }
                if (modeX = this.getTileNumber(tx, ty + -yOffDir.get(layerId), layerId)) {
                  break;
                }
                if (modeX = this.getTileNumber(tx + -xOffDir.get(layerId), ty + -yOffDir.get(layerId), layerId)) {
                  break;
                }
              }
            }
          }
          bf = modeX ? 1 : bs;
          if (!modeX && oldModeX) {
            bf = ox < 0 ? (startX + -checkX + 1) % bs : bs - (startX + checkX) % bs;
          }
          window.logPoints && pa.add([px, py, `rayX tile-${tx}-${ty} mode-${modeX} bf-${bf} layer-${layerId} `]);

          // for(const layerId of checkLayers)
          // {
          // }
          if (this.getSolid(px, py, checkLayers)) {
            solidsX.add([px, py]);
            break;
          }
          currentDistance = Math.abs(rayX);
          checkX += bf;
          rayX = checkX * sx * ox;
        } else {
          const mag = Math.abs(rayY);
          let px = startX + mag * Math.cos(angle);
          let py = startY + mag * Math.sin(angle);
          if (ox > 0 && px % 1 > 0.99999) px = Math.round(px);
          if (ox < 0 && px % 1 < 0.00001) px = Math.round(px);
          if (oy > 0 && py % 1 > 0.99999) py = Math.round(py);
          if (oy < 0 && py % 1 < 0.00001) py = Math.round(py);
          const _this$coordsToTile3 = this.coordsToTile(px, py, layerId),
            _this$coordsToTile4 = _slicedToArray(_this$coordsToTile3, 2),
            tx = _this$coordsToTile4[0],
            ty = _this$coordsToTile4[1];
          oldModeY = modeY;
          for (const _ref7 of checkLayers) {
            var _ref8 = _slicedToArray(_ref7, 2);
            const layer = _ref8[0];
            const willCheck = _ref8[1];
            {
              const layerId = layer.index;
              if (!willCheck) {
                continue;
              }
              if (modeY = this.getTileNumber(tx, ty, layerId)) {
                break;
              }
              if (!modeY && (xOffDir.has(layerId) || yOffDir.has(layerId))) {
                if (modeY = this.getTileNumber(tx, ty + -yOffDir.get(layerId), layerId)) {
                  break;
                }
                if (modeY = this.getTileNumber(tx + -xOffDir.get(layerId), ty, layerId)) {
                  break;
                }
                if (modeY = this.getTileNumber(tx + -xOffDir.get(layerId), ty + -yOffDir.get(layerId), layerId)) {
                  break;
                }
              }
            }
          }
          bf = modeY ? 1 : bs;
          if (!modeY && oldModeY) {
            bf = oy < 0 ? (startY + -checkY + 1) % bs : bs - (startY + checkY) % bs;
          }
          window.logPoints && pb.add([px, py, `rayY tile-${tx}-${ty} mode-${modeY} bf-${bf} layer-${layerId} `]);

          // for(const layerId of checkLayers)
          // {
          // 	if(this.getSolid(px, py, layerId))
          // 	{
          // 		solidsY.add([px, py]);
          // 		break;
          // 	}
          // }
          if (this.getSolid(px, py, checkLayers)) {
            solidsY.add([px, py]);
            break;
          }
          currentDistance = Math.abs(rayY);
          checkY += bf;
          rayY = checkY * sy * oy;
        }
        iterations++;
      }
      const points = [...solidsX, ...solidsY];
      const distSquares = points.map(s => Math.pow(s[0] - startX, 2) + Math.pow(s[1] - startY, 2));
      const minDistSq = Math.min(...distSquares);
      const nearest = points[distSquares.indexOf(minDistSq)];
      if (nearest) {
        if (ox > 0 && nearest[0] % 1 > 0.99999) nearest[0] = Math.round(nearest[0]);
        if (ox < 0 && nearest[0] % 1 < 0.00001) nearest[0] = Math.round(nearest[0]);
        if (oy > 0 && nearest[1] % 1 > 0.99999) nearest[1] = Math.round(nearest[1]);
        if (oy < 0 && nearest[1] % 1 < 0.00001) nearest[1] = Math.round(nearest[1]);
      }
      window.logPoints && console.timeEnd('rayCast');
      window.logPoints && console.log({
        iterations: iterations
      });
      if (window.logPoints) {
        window.logPoints(startX, startY, 'start');
        window.logPoints(endX, endY, 'end');
        [...pa].map(p => window.logPoints(p[0], p[1], p[2]));
        [...pb].map(p => window.logPoints(p[0], p[1], p[2]));

        // [...solidsX].map(p => window.logPoints(p[0],p[1],p[2]));
        // [...solidsY].map(p => window.logPoints(p[0],p[1],p[2]));

        nearest && window.logPoints(nearest[0], nearest[1], 'nearest');
      }
      if (Math.sqrt(minDistSq) > maxDistance) {
        return;
      }
      return nearest;
    }
  }, {
    key: "getCollisionMap",
    value: function getCollisionMap() {
      const collisionMap = new Map();
      for (const layer of this.tileLayers) {
        let solid = false;
        if (layer.name.substr(0, 9) === 'Collision') {
          solid = true;
        } else if (layer.name.substr(0, 6) === 'Moving') {
          solid = true;
        }
        collisionMap.set(layer, solid);
      }
      return collisionMap;
    }
  }, {
    key: "negSafeMod",
    value: function negSafeMod(a, b) {
      if (a >= 0) return a % b;
      return (b + a % b) % b;
    }
  }, {
    key: "blockSize",
    get: function get() {
      return this.mapData.tilewidth;
    }
  }, {
    key: "fromImage",
    value: function fromImage(url, blockSize) {
      return new Promise(accept => {
        const image = new Image();
        image.addEventListener('load', event => {
          // const heightMask = new Tag('<canvas>');

          // heightMask.width  = image.width;
          // heightMask.height = image.height;

          const tilecount = Math.floor(image.width * image.height / Math.pow(32, 2));
          const tileset = {
            columns: Math.floor(image.width / blockSize),
            firstgid: 1,
            image: url.substr(4),
            original: url.substr(4),
            imageheight: image.height,
            imagewidth: image.width,
            margin: 0,
            name: "image-map",
            spacing: 0,
            tileheight: blockSize,
            tilewidth: blockSize,
            tilecount: tilecount
          };
          const layer = {
            "data": Object.assign(Object.create(null), [...Array(tilecount)].map((_, k) => k)),
            "width": Math.floor(image.width / blockSize),
            "height": Math.floor(image.height / blockSize),
            "id": 1,
            "name": "Tile Layer 1",
            "opacity": 1,
            "properties": [{
              "name": "solid",
              "type": "bool",
              "value": true
            }],
            "type": "tilelayer",
            "visible": true,
            "x": 0,
            "y": 0
          };
          const mapData = {
            tilewidth: blockSize,
            tileheight: blockSize,
            layers: [layer],
            tilesets: [tileset],
            width: Math.floor(image.width / blockSize),
            height: Math.floor(image.height / blockSize)
          };
          this.mapData = mapData;
          console.log(mapData);
          this.loadLayers(mapData);
          this.loadTilesets(mapData).then(accept);

          // this.tileImages.set(tileset, image);

          // console.log(tileset, layer);

          // heightMask.getContext('2d').drawImage(
          // 	image, 0, 0, image.width, image.height
          // );

          // this.heightMasks.set(tileset, heightMask.getContext('2d').getImageData(0, 0, heightMask.width, heightMask.height));

          // new Elicit(url).objectUrl().then(url => tileset.image = tileset.cachedImage = url);
        }, {
          once: true
        });
        image.src = url;
      });
    }
  }]);
  return TileMap;
}(_Mixin.Mixin.with(_EventTargetMixin.EventTargetMixin));
exports.TileMap = TileMap;
});

;require.register("timer/Countdown.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Countdown = void 0;
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let Countdown = /*#__PURE__*/function () {
  function Countdown(time, callback) {
    _classCallCheck(this, Countdown);
    _defineProperty(this, "time", 0);
    _defineProperty(this, "callback", () => console.warn('No callback set!'));
    this.time = time;
    this.callback = callback;
  }
  _createClass(Countdown, [{
    key: "extend",
    value: function extend(time) {
      this.time += time;
    }
  }, {
    key: "extendTo",
    value: function extendTo(time) {
      this.time = Math.max(time, this.time);
    }
  }, {
    key: "update",
    value: function update() {
      if (this.time > 0) {
        this.time--;
      }
      if (this.time <= 0) {
        this.callback();
        this.time = 0;
      }
    }
  }]);
  return Countdown;
}();
exports.Countdown = Countdown;
});

;require.register("titlecard/Titlecard.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Titlecard = void 0;
var _View2 = require("curvature/base/View");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
const Accept = Symbol('Accept');
let Titlecard = /*#__PURE__*/function (_View) {
  _inherits(Titlecard, _View);
  var _super = _createSuper(Titlecard);
  function Titlecard() {
    var _this;
    let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let parent = arguments.length > 1 ? arguments[1] : undefined;
    _classCallCheck(this, Titlecard);
    _this = _super.call(this, args, parent);
    _defineProperty(_assertThisInitialized(_this), "template", require('./titlecard.html'));
    _this.args.firstLine = args.firstLine || 'First Line';
    _this.args.secondLine = args.secondLine || 'Second Line';
    _this.args.creditLine = args.creditLine || 'Credit Line';
    _this.args.actNumber = args.actNumber || 1;
    _this.args.animation = 'start';
    _this.played = new Promise(accept => _this[Accept] = accept);
    return _this;
  }
  _createClass(Titlecard, [{
    key: "replay",
    value: function replay(updates) {
      Object.assign(this.args, updates);
      this.args.replay = 'replay';
      const playing = new Promise(accept => {
        const waitFor = this.args.waitFor || Promise.resolve();
        let timeAcc = 75;
        this.onTimeout(timeAcc, () => this.onNextFrame(() => this.args.animation = ''));
        timeAcc += 75;
        this.onTimeout(timeAcc, () => this.onNextFrame(() => this.args.animation = 'opening'));
        timeAcc += 500;
        waitFor.finally(() => {
          this.onTimeout(timeAcc, () => this.onNextFrame(() => this.args.animation = 'opening2'));
          timeAcc += 750;
          this.onTimeout(timeAcc, () => this.onNextFrame(() => this.args.animation = 'closing'));
          this.onTimeout(timeAcc, () => {
            accept([new Promise(acceptDone => this.onTimeout(timeAcc + 750, acceptDone))]);
            this[Accept]();
          });
          timeAcc += 1000;
          this.onTimeout(timeAcc, () => this.onNextFrame(() => this.args.animation = 'closed'));
          timeAcc += 2500;
          this.onTimeout(timeAcc, () => this.onNextFrame(() => {
            this.args.animation = 'done';
            this.playing = false;
          }));
        });
      });
      this.playing = playing;
    }
  }, {
    key: "play",
    value: function play(event) {
      if (this.playing) {
        return this.playing;
      }
      const playing = new Promise(accept => {
        const waitFor = this.args.waitFor || Promise.resolve();
        let timeAcc = 750;
        this.onTimeout(timeAcc, () => this.onNextFrame(() => this.args.animation = ''));
        timeAcc += 750;
        this.onTimeout(timeAcc, () => this.onNextFrame(() => this.args.animation = 'opening'));
        timeAcc += 500;
        waitFor.finally(() => {
          this.onTimeout(timeAcc, () => this.onNextFrame(() => this.args.animation = 'opening2'));
          timeAcc += 750;
          this.onTimeout(timeAcc, () => this.onNextFrame(() => this.args.animation = 'closing'));
          this.onTimeout(timeAcc, () => {
            accept([new Promise(acceptDone => this.onTimeout(timeAcc + 750, acceptDone))]);
            this[Accept]();
          });
          timeAcc += 1000;
          this.onTimeout(timeAcc, () => this.onNextFrame(() => this.args.animation = 'closed'));
          timeAcc += 2500;
          this.onTimeout(timeAcc, () => this.onNextFrame(() => {
            this.args.animation = 'done';
            this.playing = false;
          }));
        });
      });
      this.playing = playing;

      // return playing;
    }
  }]);
  return Titlecard;
}(_View2.View);
exports.Titlecard = Titlecard;
});

;require.register("titlecard/titlecard.html", function(exports, require, module) {
module.exports = "<div class = \"titlecard [[replay]] [[animation]]\">\n\n\t<div class = \"titlecard-field\"></div>\n\n\t<div class = \"titlecard-bottom-border\">\n\t\t<div class = \"titlecard-border-text\">[[creditLine]]</div>\n\t</div>\n\n\t<div class = \"titlecard-left-border\">\n\t\t<div class = \"titlecard-border-shadow\"></div>\n\t\t<div class = \"titlecard-border-color\"></div>\n\t</div>\n\n\t<div class = \"titlecard-title\">\n\n\t\t<div class = \"titlecard-title-box\">\n\n\t\t\t<div class = \"titlecard-title-line-1\">[[firstLine]]</div>\n\n\t\t\t<div class = \"titlecard-title-line-2\">\n\t\t\t\t[[secondLine]]<div class = \"titlecard-title-number\">[[actNumber]]</div>\n\t\t\t</div>\n\n\t\t</div>\n\n\t</div>\n\n</div>\n"
});

;require.register("trace/Trace.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Trace = void 0;
var _Uuid = require("curvature/base/Uuid");
var _Model2 = require("curvature/model/Model");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
const buildTag = document.head.querySelector('meta[name="x-build-time"]');
const buildTime = buildTag ? buildTag.getAttribute('content') : null;
let Trace = /*#__PURE__*/function (_Model) {
  _inherits(Trace, _Model);
  var _super = _createSuper(Trace);
  function Trace() {
    var _this;
    _classCallCheck(this, Trace);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _defineProperty(_assertThisInitialized(_this), "class", 'Trace');
    _defineProperty(_assertThisInitialized(_this), "uuid", String(new _Uuid.Uuid()));
    _defineProperty(_assertThisInitialized(_this), "created", Date.now());
    _defineProperty(_assertThisInitialized(_this), "local", String(new Date()));
    _defineProperty(_assertThisInitialized(_this), "tz", Intl.DateTimeFormat().resolvedOptions().timeZone);
    _defineProperty(_assertThisInitialized(_this), "stack", '');
    _defineProperty(_assertThisInitialized(_this), "message", '');
    _defineProperty(_assertThisInitialized(_this), "timeStamp", null);
    _defineProperty(_assertThisInitialized(_this), "filename", null);
    _defineProperty(_assertThisInitialized(_this), "lineno", null);
    _defineProperty(_assertThisInitialized(_this), "colno", null);
    _defineProperty(_assertThisInitialized(_this), "buildTime", buildTime);
    _defineProperty(_assertThisInitialized(_this), "replay", null);
    return _this;
  }
  _createClass(Trace, [{
    key: "consume",
    value: function consume(skeleton) {
      let override = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      _get(_getPrototypeOf(Trace.prototype), "consume", this).call(this, skeleton, override);
      this.uuid = skeleton.uuid || this.uuid || String(new _Uuid.Uuid());
    }
  }]);
  return Trace;
}(_Model2.Model);
exports.Trace = Trace;
});

;require.register("trace/TraceDatabase.js", function(exports, require, module) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TraceDatabase = void 0;
var _Database2 = require("curvature/model/Database");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
let TraceDatabase = /*#__PURE__*/function (_Database) {
  _inherits(TraceDatabase, _Database);
  var _super = _createSuper(TraceDatabase);
  function TraceDatabase() {
    _classCallCheck(this, TraceDatabase);
    return _super.apply(this, arguments);
  }
  _createClass(TraceDatabase, [{
    key: "_version_1",
    value: function _version_1(database) {
      const errorStore = this.createObjectStore('traces', {
        keyPath: 'id',
        autoIncrement: true
      });
      errorStore.createIndex('position', ['filename', 'lineno', 'colno'], {
        unique: false
      });
      errorStore.createIndex('filename', 'uuid', {
        unique: false
      });
      errorStore.createIndex('lineno', 'lineno', {
        unique: false
      });
      errorStore.createIndex('colno', 'colno', {
        unique: false
      });
      errorStore.createIndex('created', 'created', {
        unique: false
      });
      errorStore.createIndex('uuid', 'uuid', {
        unique: true
      });
      errorStore.createIndex('id', 'id', {
        unique: true
      });
    }
  }]);
  return TraceDatabase;
}(_Database2.Database);
exports.TraceDatabase = TraceDatabase;
});

;require.register("ui/CharacterString.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CharacterString = void 0;
var _View2 = require("curvature/base/View");
var _Bindable = require("curvature/base/Bindable");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let CharacterString = /*#__PURE__*/function (_View) {
  _inherits(CharacterString, _View);
  var _super = _createSuper(CharacterString);
  function CharacterString() {
    var _this;
    let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let parent = arguments.length > 1 ? arguments[1] : undefined;
    _classCallCheck(this, CharacterString);
    args[_Bindable.Bindable.NoGetters] = true;
    _this = _super.call(this, args, parent);
    _defineProperty(_assertThisInitialized(_this), "template", `<div cv-ref = "main" class = "hud-character-string [[hide]] [[color]] [[font]] [[classes]]" cv-each = "chars:char:c"><span
				class = "hud-character"
				data-type  = "[[char.type]]"
				data-value = "[[char.pos]]"
				data-index = "[[c]]"
				style      = "--value:[[char.pos]];--index:[[c]];"
			>[[char.original]]</span></div>`);
    _this[_Bindable.Bindable.NoGetters] = true;
    const chars = [];
    chars[_Bindable.Bindable.NoGetters] = true;
    _this.args.chars = chars;
    _this.args.classes = _this.args.classes || '';
    _this.args.scale = _this.args.scale || 1;
    const high = _this.args.high;
    const med = _this.args.med;
    const low = _this.args.low;
    _this.args.bindTo('value', v => {
      // if(Math.abs(v) < low)
      // {
      // 	this.args.color = '';
      // }
      // else if(Math.abs(v) > low)
      // {
      // 	this.args.color = 'yellow';
      // }
      // else if(Math.abs(v) > med)
      // {
      // 	this.args.color = 'orange';
      // }
      // else if(Math.abs(v) > high)
      // {
      // 	this.args.color = 'red';
      // }
      // else if(this.args.flash > 0)
      // {
      // 	this.args.color = this.args.flashColor;
      // }
      // else
      // {
      // 	this.args.color = '';
      // }

      const chars = String(v).split('').map(_this.characterToModel.bind(_assertThisInitialized(_this)));
      if (chars.length < _this.args.chars.length) {
        for (let i = chars.length; i < _this.args.chars.length; i++) {
          _this.characterToModel(-2, i);
        }

        // this.args.chars.splice(chars.length);
      }

      Object.assign(_this.args.chars, chars);
    });
    return _this;
  }
  _createClass(CharacterString, [{
    key: "characterToModel",
    value: function characterToModel(pos, i) {
      let original = pos;
      let type = 'number';
      if (pos === ' ' || Number(pos) != pos) {
        switch (pos) {
          case ' ':
            pos = -1;
            type = 'number';
            break;
          case '-':
            pos = 11;
            type = 'number';
            break;
          case ':':
            pos = 10;
            type = 'number';
            break;
          case '.':
            pos = 12;
            type = 'number';
            break;
          case '/':
            pos = 13;
            type = 'number';
            break;
          case ',':
            pos = 14;
            type = 'number';
            break;
          case '?':
            pos = 15;
            type = 'number';
            break;
          case '!':
            pos = 16;
            type = 'number';
            break;
          case '@':
            pos = 17;
            type = 'number';
            break;
          case '#':
            pos = 18;
            type = 'number';
            break;
          case '$':
            pos = 19;
            type = 'number';
            break;
          case '%':
            pos = 20;
            type = 'number';
            break;
          case '^':
            pos = 21;
            type = 'number';
            break;
          case '&':
            pos = 22;
            type = 'number';
            break;
          case '*':
            pos = 23;
            type = 'number';
            break;
          case '(':
            pos = 24;
            type = 'number';
            break;
          case ')':
            pos = 25;
            type = 'number';
            break;
          case '⏺':
            pos = 0;
            type = 'symbol2';
            break;
          case '▶':
            pos = 1;
            type = 'symbol2';
            break;
          case '⏸':
            pos = 2;
            type = 'symbol2';
            break;
          case '⏹':
            pos = 3;
            type = 'symbol2';
            break;
          case '⏮':
            pos = 4;
            type = 'symbol2';
            break;
          case '⏭':
            pos = 5;
            type = 'symbol2';
            break;
          case '\'':
            pos = 6;
            type = 'symbol2';
            break;
          case '"':
            pos = 7;
            type = 'symbol2';
            break;
          case '"':
            pos = 8;
            type = 'symbol2';
            break;
          case '=':
            pos = 9;
            type = 'symbol2';
            break;
          case '+':
            pos = 10;
            type = 'symbol2';
            break;
          case '[':
            pos = 11;
            type = 'symbol2';
            break;
          case ']':
            pos = 12;
            type = 'symbol2';
            break;
          case '{':
            pos = 13;
            type = 'symbol2';
            break;
          case '}':
            pos = 14;
            type = 'symbol2';
            break;
          case '\\':
            pos = 15;
            type = 'symbol2';
            break;
          case ';':
            pos = 16;
            type = 'symbol2';
            break;
          case '~':
            pos = 17;
            type = 'symbol2';
            break;
          case '|':
            pos = 18;
            type = 'symbol2';
            break;
          case '_':
            pos = 19;
            type = 'symbol2';
            break;
          case '>':
            pos = 20;
            type = 'symbol2';
            break;
          case '<':
            pos = 21;
            type = 'symbol2';
            break;
          case '⯇':
            pos = 22;
            type = 'symbol2';
            break;
          case '⯅':
            pos = 23;
            type = 'symbol2';
            break;
          case '⯆':
            pos = 24;
            type = 'symbol2';
            break;

          // ⯈

          case '`':
            pos = 25;
            type = 'symbol2';
            break;
          default:
            pos = String(pos).toLowerCase().charCodeAt(0) - 97;
            type = 'letter';
            break;
        }
      }
      if (this.args.chars[i]) {
        this.args.chars[i].original = original;
        this.args.chars[i].type = type;
        this.args.chars[i].pos = pos;
        return this.args.chars[i];
      }
      return {
        pos: pos,
        type: type,
        original: original
      };
    }
  }]);
  return CharacterString;
}(_View2.View);
exports.CharacterString = CharacterString;
});

;require.register("ui/ClickSwitch.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ClickSwitch = void 0;
var _View2 = require("curvature/base/View");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let ClickSwitch = /*#__PURE__*/function (_View) {
  _inherits(ClickSwitch, _View);
  var _super = _createSuper(ClickSwitch);
  function ClickSwitch() {
    var _this;
    _classCallCheck(this, ClickSwitch);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _defineProperty(_assertThisInitialized(_this), "template", require('./click-switch.html'));
    return _this;
  }
  _createClass(ClickSwitch, [{
    key: "toggle",
    value: function toggle() {
      this.args.active = !this.args.active;
    }
  }]);
  return ClickSwitch;
}(_View2.View);
exports.ClickSwitch = ClickSwitch;
});

;require.register("ui/HudFrame.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.HudFrame = void 0;
var _View2 = require("curvature/base/View");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let HudFrame = /*#__PURE__*/function (_View) {
  _inherits(HudFrame, _View);
  var _super = _createSuper(HudFrame);
  function HudFrame() {
    var _this;
    _classCallCheck(this, HudFrame);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _defineProperty(_assertThisInitialized(_this), "template", `<div class = "hud-frame [[type]] [[alert]]">
		<div class = "hud-value">[[value]]</div>
	</div>`);
    return _this;
  }
  return _createClass(HudFrame);
}(_View2.View);
exports.HudFrame = HudFrame;
});

;require.register("ui/click-switch.html", function(exports, require, module) {
module.exports = "<div class = \"switch\" data-active = \"[[active]]\"  cv-on = \"click:toggle(event)\">\n\n\t<div class = \"label labelOff\">\n\t\t<img src = \"/ui/mute.svg\" />\n\t</div>\n\n\t<div class = \"slide\">\n\t\t<div class = \"head\"></div>\n\t</div>\n\n\t<div class = \"label labelOn\">\n\t\t<img src = \"/ui/unmute.svg\" />\n\t</div>\n\n</div>\n"
});

;require.register("viewport/Layer.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Layer = void 0;
var _Bindable = require("curvature/base/Bindable");
var _View2 = require("curvature/base/View");
var _Tag = require("curvature/base/Tag");
var _Bag = require("curvature/base/Bag");
var _TitleScreenCard = require("../intro/TitleScreenCard");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let Layer = /*#__PURE__*/function (_View) {
  _inherits(Layer, _View);
  var _super = _createSuper(Layer);
  function Layer(args, parent) {
    var _this;
    _classCallCheck(this, Layer);
    args[_Bindable.Bindable.NoGetters] = true;
    _this = _super.call(this, args, parent);
    _defineProperty(_assertThisInitialized(_this), "template", require('./layer.html'));
    _this[_Bindable.Bindable.NoGetters] = true;
    _this.args.width = args.width || 320;
    _this.args.height = args.height || 200;
    _this.args.blockSize = args.blockSize || 32;
    _this.x = 0;
    _this.y = 0;
    _this.viewport = args.viewport;
    _this.hidden = false;
    _this.args.offsetX = 0;
    _this.args.offsetY = 0;
    _this.args.parallax = _this.args.parallax || 0;
    _this.args.layerId = 0 || _this.args.layerId;
    Object.defineProperty(_assertThisInitialized(_this), 'blocksXY', {
      value: new Map()
    });
    Object.defineProperty(_assertThisInitialized(_this), 'blocks', {
      value: new _Bag.Bag()
    });
    Object.defineProperty(_assertThisInitialized(_this), 'blockMeta', {
      value: new Map()
    });
    Object.defineProperty(_assertThisInitialized(_this), 'blockSrcs', {
      value: new Map()
    });
    _this.args.blocks = _this.blocks.list;
    _this.meta = Object.create(null);
    const viewport = _this.args.viewport;
    const layers = viewport.tileMap.tileLayers;
    const layerDef = layers[_this.args.layerId];
    _this.setMeta(layerDef);
    if (_this.meta.offsetX) {
      _this.args.offsetX = _this.meta.offsetX;
    }
    if (_this.meta.offsetY) {
      _this.args.offsetY = _this.meta.offsetY;
    }
    layerDef['offsetX'] = _this.args.offsetX;
    layerDef['offsetY'] = _this.args.offsetY;
    layerDef.layer = _assertThisInitialized(_this);

    // if(this.args.name.match(/^(Collision|Grinding)\s\d+/))
    // {
    // 	if(this.args.name.match(/[12]$/))
    // 	{
    // 		this.meta.switchable = true;
    // 	}

    // 	this.meta.solid = true;
    // }

    if (_this.args.name.match(/^(Grinding)\s\d+/)) {
      _this.meta.grinding = true;
    }
    _this.offsetXChanged = 0;
    _this.offsetYChanged = 0;
    _this.fallSpeed = 0;
    Object.preventExtensions(_assertThisInitialized(_this));
    const resetBlocks = () => [..._this.blockMeta.values()].forEach(b => b.reset = true);
    _this.args.bindTo('width', resetBlocks, {
      wait: 0
    });
    _this.args.bindTo('height', resetBlocks, {
      wait: 0
    });
    return _this;
  }
  _createClass(Layer, [{
    key: "setMeta",
    value: function setMeta(layerDef) {
      let maxObjectId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      if (layerDef.properties) {
        for (const property of layerDef.properties) {
          this.meta[property.name] = property.value;
          if (property.type === 'object') {
            this.meta[property.name] += maxObjectId;
          }
        }
      }
    }
  }, {
    key: "move",
    value: function move() {
      if (this.meta.controller === undefined) {
        return;
      }
      const viewport = this.args.viewport;
      const layers = viewport.tileMap.tileLayers;
      const layerDef = layers[this.args.layerId];
      const controller = viewport.actorsById[this.meta.controller];
      this.offsetXChanged = 0;
      this.offsetYChanged = 0;
      if (layerDef) {
        layerDef.offsetXChanged = 0;
        layerDef.offsetYChanged = 0;
      }
      if (controller) {
        if (layerDef) {
          layerDef['offsetX'] = this.args.offsetX;
          layerDef['offsetY'] = this.args.offsetY;
        }
        const changedX = (controller.args.xLayer || 0) - this.args.offsetX;
        const changedY = (controller.args.yLayer || 0) - this.args.offsetY;
        this.args.offsetX = controller.args.xLayer || 0;
        this.args.offsetY = controller.args.yLayer || 0;
        if (layerDef) {
          layerDef[`offsetXChanged`] = changedX;
          layerDef[`offsetYChanged`] = changedY;
        }
        this[`offsetXChanged`] = changedX;
        this[`offsetYChanged`] = changedY;
      } else {
        this.args.offsetX = 0;
        this.args.offsetY = 0;
      }
      this.fallSpeed = this.fallSpeed || 0;
    }
  }, {
    key: "onAttach",
    value: function onAttach(event) {
      const viewport = this.args.viewport;
      const layers = viewport.tileMap.tileLayers;
      const layerDef = layers[this.args.layerId];
      const controller = viewport.actorsById[this.meta.controller];
      if (!layerDef) {
        return;
      }
      this.args.bindTo('destroyed', v => {
        const viewport = this.args.viewport;
        const layers = viewport.tileMap.tileLayers;
        const layerDef = layers[this.args.layerId];
        layerDef.destroyed = !!v;
        if (controller) {
          controller.args.destroyed = !!v;
        }
      });
    }
  }, {
    key: "update",
    value: function update(tileMap) {
      const viewport = this.args.viewport;
      if (viewport.args.frameId % viewport.settings.frameSkip !== 0) {
        return;
      }
      if (this.args.hidden) {
        if (!this.hidden) {
          this.blocks.list.forEach(b => {
            b.style({
              display: 'none'
            });
            b.remove();
          });
          this.hidden = true;
        }
        return;
      }
      if (this.args.destroyed && this.tags.background) {
        const tileMap = viewport.tileMap;
        const layerId = this.args.layerId;
        const layers = tileMap.tileLayers;
        const layerDef = layers[layerId];
        layerDef.destroyed = true;
        this.tags.background.style({
          display: 'none'
        });
        this.args.hidden = true;
        return;
      }
      const blockSize = this.args.blockSize;
      const blocksWide = Math.ceil(this.args.width / blockSize) + 1;
      const blocksHigh = Math.ceil(this.args.height / blockSize) + 1;
      const blocksXY = this.blocksXY;
      const centerX = blocksWide / 2;
      const centerY = blocksHigh / 2;
      const blocks = this.blocks;
      const blockMetas = this.blockMeta;
      const blockSrcs = this.blockSrcs;
      const offsetX = this.args.offsetX;
      const offsetY = this.args.offsetY;
      const layerId = this.args.layerId;
      let startColumn = -1;
      let endColumn = +1 + blocksWide;
      let ii = 0;
      let willDisable = true;
      for (let i = startColumn; i < endColumn; i += Math.sign(blocksWide)) {
        const tileX = i + -Math.ceil(this.x / blockSize) + -Math.ceil(offsetX / blockSize) + (offsetX > 0 ? 1 : 0);
        for (let j = 0; j < blocksHigh; j += Math.sign(blocksHigh)) {
          const tileY = j + Math.floor(-this.y / blockSize) + (this.offsetYChange < 0 ? -Math.ceil(offsetY / blockSize) : -Math.floor(offsetY / blockSize)) + (offsetY < 0 ? -1 : 0);
          const blockId = tileMap.getTileNumber(tileX, tileY, layerId);
          const xy = `${i},${j}`;
          let block, reset;
          if (!blocksXY.has(xy) || (reset = blockMetas.get(xy).reset)) {
            if (!reset) {
              block = new _Tag.Tag(document.createElement('div'));
              const meta = Object.create(null, {
                visible: {
                  value: false,
                  writable: true
                },
                reset: {
                  value: false,
                  writable: true
                },
                src: {
                  value: null,
                  writable: true
                },
                x: {
                  value: null,
                  writable: true
                },
                y: {
                  value: null,
                  writable: true
                }
              });
              Object.preventExtensions(meta);
              blocksXY.set(xy, block);
              blockMetas.set(xy, meta);
            } else {
              const meta = blockMetas.get(xy);
              block = blocksXY.get(xy);
              meta.reset = false;
              meta.visible = false;
              meta.src = null;
              block.style({
                'background-image': `none`,
                display: 'none'
              });
            }
            const transX = blockSize * i;
            const transY = blockSize * j;
            const scale = '1.016';
            block.style({
              transform: `translate(${transX}px, ${transY}px) scale(${scale}, ${scale})`,
              display: 'none',
              width: blockSize + 'px',
              height: blockSize + 'px',
              position: 'absolute',
              left: 0,
              top: 0
            });
            blocks.add(block);
          } else {
            block = blocksXY.get(xy);
          }
          const tileXY = [];
          if (layerId && blockId === false) {
            tileXY[0] = -1;
            tileXY[1] = -1;
          } else {
            Object.assign(tileXY, tileMap.getTile(blockId));
          }
          const tileset = tileXY[4];
          const blockMeta = blockMetas.get(xy);
          const existingOffsetX = blockMeta.x;
          const existingOffsetY = blockMeta.y;
          const existingSrc = blockMeta.src;
          if (tileset && tileset.meta && tileset.meta.animated) {
            var _tileset$meta$speed;
            const frames = tileset.meta.frames;
            const oneFrame = viewport.args.frameId;
            const speed = (_tileset$meta$speed = tileset.meta.speed) !== null && _tileset$meta$speed !== void 0 ? _tileset$meta$speed : 1;
            const speedFrame = Math.floor(oneFrame / speed);
            const frameIndex = speedFrame % frames;
            tileXY[1] += tileset.meta.frameSize * frameIndex;
          }
          const blockX = -1 * (tileXY[0] * blockSize);
          const blockY = -1 * (tileXY[1] * blockSize);
          const blockSrc = tileXY[2];
          if (blockId !== false && blockId !== 0) {
            willDisable = false;
          }
          if (existingOffsetX !== blockX || existingOffsetY !== blockY || existingSrc !== blockSrc) {
            if (blockId !== false && blockId !== 0) {
              const blockOffset = blockX + 'px ' + blockY + 'px';
              block.style({
                display: 'initial',
                'background-position': blockOffset,
                'background-image': `url(${blockSrc})`
                // , '--screenX': (centerX - ii) / centerX
                // , '--screenY': (j - centerY) / centerY
              });

              blockMeta.visible = true;
              Layer.updateCount++;
            } else if (blockMeta.visible) {
              block.style({
                display: 'none'
              });
              blockMeta.visible = false;
            }
            blockMeta.src = blockSrc;
            blockMeta.x = blockX;
            blockMeta.y = blockY;
          }
        }
        ii++;
      }
      if (this.tags.background) {
        const background = this.tags.background;
        if (willDisable) {
          background.style({
            display: 'none'
          });
        } else if (this.tags.background) {
          background.style({
            display: 'initial',
            '--offsetX': -offsetX % blockSize,
            '--offsetY': -offsetY % blockSize,
            '--xPerspective': this.viewport.args.xPerspective,
            '--parallax': this.args.parallax
          });
        }
      }
    }
  }]);
  return Layer;
}(_View2.View);
exports.Layer = Layer;
Layer.updateCount = 0;
});

require.register("viewport/Plot.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Plot = void 0;
var _View2 = require("curvature/base/View");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let Plot = /*#__PURE__*/function (_View) {
  _inherits(Plot, _View);
  var _super = _createSuper(Plot);
  function Plot(args, parent) {
    var _this;
    _classCallCheck(this, Plot);
    _this = _super.call(this, args, parent);
    _defineProperty(_assertThisInitialized(_this), "template", `<svg style = "--x:[[x]];--y:[[y]]" cv-each = "points:point" class = "plot">
		<circle cx="[[point.x]]" cy="[[point.y]]" r="2" class="[[point.color]]" />
	</svg>`);
    _this.args.points = [];
    _this.points = new Set();
    _this.count = 0;
    _this.max = 2048;

    // this.addPoint('50%', '50%', 'red');
    return _this;
  }
  _createClass(Plot, [{
    key: "clearPoints",
    value: function clearPoints() {
      for (const point of this.args.points) {
        Object.assign(point, {
          x: 0,
          y: 0,
          color: 'hidden'
        });
      }
      this.count = 0;
    }
  }, {
    key: "addPoint",
    value: function addPoint(x, y, color) {
      color += ` point-${this.count}`;
      const index = this.count++ % this.max;
      if (this.args.points.length >= this.max) {
        Object.assign(this.args.points[index], {
          x: x,
          y: y,
          color: color
        });
        return;
      }
      this.args.points.push({
        x: x,
        y: y,
        color: color
      });
    }
  }]);
  return Plot;
}(_View2.View);
exports.Plot = Plot;
});

;require.register("viewport/Viewport.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Viewport = void 0;
var _Bindable = require("curvature/base/Bindable");
var _Bag = require("curvature/base/Bag");
var _Tag = require("curvature/base/Tag");
var _Uuid = require("curvature/base/Uuid");
var _View2 = require("curvature/base/View");
var _Router = require("curvature/base/Router");
var _Keyboard = require("curvature/input/Keyboard");
var _Sequence = require("curvature/input/Sequence");
var _Elicit = require("curvature/net/Elicit");
var _QuadCell = require("../QuadCell");
var _Countdown = require("../timer/Countdown");
var _Bgm = require("../audio/Bgm");
var _Sfx = require("../audio/Sfx");
var _TileMap = require("../tileMap/TileMap");
var _Titlecard = require("../titlecard/Titlecard");
var _Particle3d = require("../particle/Particle3d");
var _MarbleGarden = require("../backdrop/MarbleGarden");
var _ProtoLabrynth = require("../backdrop/ProtoLabrynth");
var _MysticCave = require("../backdrop/MysticCave");
var _Series = require("../intro/Series");
var _Card = require("../intro/Card");
var _TitleScreenCard = require("../intro/TitleScreenCard");
var _ThankYouCard = require("../intro/ThankYouCard");
var _LoadingCard = require("../intro/LoadingCard");
var _BootCard = require("../intro/BootCard");
var _DebianCard = require("../intro/DebianCard");
var _WebkitCard = require("../intro/WebkitCard");
var _GamepadCard = require("../intro/GamepadCard");
var _WarningCard = require("../intro/WarningCard");
var _SaneCard = require("../intro/SaneCard");
var _NoWayCard = require("../intro/NoWayCard");
var _SeanCard = require("../intro/SeanCard");
var _PauseMenu = require("../Menu/PauseMenu.js");
var _MainMenu = require("../Menu/MainMenu.js");
var _LayerSwitch = require("../actor/LayerSwitch");
var _Region = require("../region/Region");
var _CharacterString = require("../ui/CharacterString");
var _HudFrame = require("../ui/HudFrame");
var _Layer = require("./Layer");
var _Plot = require("./Plot");
var _Controller = require("../controller/Controller");
var _BackdropPalette = require("../BackdropPalette");
var _ObjectPalette = require("../ObjectPalette");
var _ScriptPalette = require("../ScriptPalette");
var _ClickSwitch = require("../ui/ClickSwitch");
var _Console = require("subspace-console/Console");
var _Input = require("../console/task/Input");
var _Impulse = require("../console/task/Impulse");
var _Mark = require("../console/task/Mark");
var _Settings = require("../console/task/Settings");
var _Move = require("../console/task/Move");
var _Pos = require("../console/task/Pos");
var _Spawn = require("../console/task/Spawn");
var _Chao = require("../console/task/Chao");
var _Socket = require("subspace-client/Socket");
var _RtcClient = require("../network/RtcClient");
var _RtcServer = require("../network/RtcServer");
var _Classifier = require("../Classifier");
var _ChatBox = require("../network/ChatBox");
var _Platformer = require("../actor/Platformer");
var _Sonic = require("../actor/Sonic");
var _Tails = require("../actor/Tails");
var _Knuckles = require("../actor/Knuckles");
var _Seymour = require("../actor/Seymour");
var _Chalmers = require("../actor/Chalmers");
var _SaveDatabase = require("../save/SaveDatabase");
var _Save = require("../save/Save");
var _TraceDatabase = require("../trace/TraceDatabase");
var _Trace = require("../trace/Trace");
var _ReplayDatabase = require("../replay/ReplayDatabase");
var _Replay = require("../replay/Replay");
var _Platformer2 = require("../behavior/Platformer");
var _Matrix = require("matrix-api/Matrix");
var _GamepadConfig = require("../controller/GamepadConfig");
var _TallyBoard = require("../tally/TallyBoard");
var _Emblem = require("../actor/Emblem");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
const ActorPointCache = Symbol('actor-point-cache');
const ColCellNear = Symbol('collision-cells-near');
const ColCells = Symbol('collision-cells');
const ColCell = Symbol('collision-cell');
const Run = Symbol('run');
let Viewport = /*#__PURE__*/function (_View) {
  _inherits(Viewport, _View);
  var _super = _createSuper(Viewport);
  function Viewport() {
    var _this;
    let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let parent = arguments.length > 1 ? arguments[1] : undefined;
    _classCallCheck(this, Viewport);
    args[_Bindable.Bindable.NoGetters] = true;
    _this = _super.call(this, args, parent);
    _defineProperty(_assertThisInitialized(_this), "secretsFound", new Set());
    _defineProperty(_assertThisInitialized(_this), "template", require('./viewport.html'));
    _this.listen(window, 'error', event => _this.handleUncaughtException(event));
    window.viewport = _assertThisInitialized(_this);
    _this.listen(window, 'focus', event => {
      if (_this.focusDelay) {
        _this.focusDelay();
      }
      _this.focusDelay = _this.onFrameOut(45, () => _this.args.focusMe.args.hide = 'hide hidden');
      _this.args.focusMe.args.hide = 'hide';
      _this.args.windowFocused = 'window-focused';
    });
    _this.listen(window, 'blur', event => {
      if (_this.focusDelay) {
        _this.focusDelay();
      }
      if (_this.gamepad) {
        _this.args.focusMe.args.hide = 'hide hidden';
        return;
      }
      _this.focusDelay = _this.onFrameOut(1, () => _this.args.focusMe.args.hide = '');
      _this.args.focusMe.args.hide = 'hide';
      _this.args.windowFocused = 'window-blurred';
    });
    _this.args.windowFocused = document.hasFocus() ? 'window-focused' : 'window-blurred';
    _this[_Bindable.Bindable.NoGetters] = true;
    _Router.Router.listen(_assertThisInitialized(_this), {
      '': () => ''
    });
    _this.args.screenEffects = new _Bag.Bag();
    _this.meta = {};
    _this.customColor = _Bindable.Bindable.make({
      h: 0,
      s: 1,
      v: 1
    });

    // this.args.bindTo('emblems', console.trace);

    _this.args.combo = [];
    _this.args.invert = '';

    // this.args.plot = new Plot;

    _this.args.publishTime = 0;
    _this.netId = String(new _Uuid.Uuid());

    // this.subspaceConnect();

    _this.netPlayers = new Map();
    _this.args.controlCardShown = false;
    _this.bytesReceived = 0;
    _this.args.mainPallet = '';
    _this.args.customColor = {
      h: 0,
      s: 1,
      v: 1
    };
    _this.args.inventory = [];
    _this.loadSaves().then(saves => {
      if (saves.length) {
        _this.currentSave = _Save.Save.from(saves[0]);
      } else {
        _this.currentSave = new _Save.Save();
      }
    });
    _this.characters = {
      'Sonic': _Sonic.Sonic,
      'Tails': _Tails.Tails,
      'Knuckles': _Knuckles.Knuckles,
      'platformer': _Platformer.PlatformActor
    };
    _this.objectPalette = _ObjectPalette.ObjectPalette;
    _this.scriptPalette = _ScriptPalette.ScriptPalette;
    _this.zoneScript = null;
    _this.timers = new Map();
    _this.args.paused = false;
    _this.args.freeze = false;
    _this.quadCell = null;
    _this.visible = new Set();
    _this.callIntervals = new Map();
    _this.callFrames = new Map();
    _this.callRenderedFrames = new Map();
    _this.willDetach = new Map();
    _this.backdrops = new Map();
    _this.checkpoints = new Map();
    _this.zeroFrame = false;
    _this.spawnedDefs = new Map();
    _this.defsByMap = new Map();
    _this.actorsByMap = new Map();

    // this.actorPointCache = new Map;

    _this.args.replayQuickExit = false;
    _this.args.replayBanners = true;
    _this.maxObjectId = 0;
    _this.maxGid = 0;
    _this.args.loadingMap = false;
    _this.maps = new Map();
    _this.server = null;
    _this.client = null;
    _this.args.networked = false;
    _this.args.tallyBoard = null;
    _this.args.mouse = 'moved';
    _this.settings = _Bindable.Bindable.make({
      audio: true,
      blur: true,
      smoothing: false,
      displace: true,
      scaling: true,
      rumble: true,
      showHud: true,
      shortcuts: true,
      showFps: true,
      debugOsd: false,
      outline: 1,
      frameSkip: 1,
      musicVol: 50,
      sfxVol: 75,
      username: 'player',
      graphicsLevel: 'High',
      matrixUrl: 'https://matrix.org/_matrix',
      matrixRoom: '!hJzXrccruagKGXTFUQ:matrix.org',
      iceServer1: 'stun:stun1.l.google.com:19302',
      iceServer2: 'stun:stun2.l.google.com:19302'
    });
    _this.defaults = Object.assign({}, _this.settings);
    _this.args.shakeX = 0;
    _this.args.shakeY = 0;
    _this.args.level = '';
    let mapUrl = '';
    const inputMapUrl = _Router.Router.query.map;
    let noMenu = false;
    if (inputMapUrl && inputMapUrl.match(/^\w/)) {
      mapUrl = '/map/' + inputMapUrl;
      noMenu = true;
    }
    _this.args.startFrameId = 0;
    _this.args.actStartFrameId = 0;
    _this.args.lastFrameId = -1;
    if (mapUrl) {
      _this.loadMap({
        mapUrl: mapUrl
      }).catch(error => {
        console.warn(error);
        _this.args.titlecard = new _Series.Series({
          cards: [new _NoWayCard.NoWayCard({
            errorString: `Cannot load map "${inputMapUrl}"!`,
            timeout: -1
          })]
        }, _assertThisInitialized(_this));
        _this.args.titlecard.play();
      });
    }
    _this.sprites = new _Bag.Bag();
    _this.world = null;
    let noIntro = _Router.Router.query.nointro;
    const cards = [];
    if (noMenu) {
      noIntro = true;
    }
    if (!noIntro) {
      cards.push(..._this.introCards());
    } else {
      cards.push(new _MainMenu.MainMenu({
        timeout: -1
      }, _assertThisInitialized(_this)));
    }
    _this.args.titlecard = new _Series.Series({
      cards: cards
    }, _assertThisInitialized(_this));
    if (!mapUrl) {
      _this.args.titlecard.play();
    }
    _this.args.noIntro = noIntro ? 'no-intro' : '';

    // const debugKeys = [
    // 	'ArrowUp'
    // 	, 'ArrowUp'
    // 	, 'ArrowDown'
    // 	, 'ArrowDown'
    // 	, 'ArrowUp'
    // 	, 'ArrowUp'
    // 	, 'ArrowUp'
    // 	, 'ArrowUp'
    // ];

    const debugKeys = ['Button12', 'Button12', 'Button13', 'Button13', 'Button12', 'Button12', 'Button12', 'Button12'];
    const debugSeq = new _Sequence.Sequence({
      keys: debugKeys,
      timing: 750
    });

    // const konamiKeys = [
    // 	'ArrowUp'
    // 	, 'ArrowUp'
    // 	, 'ArrowDown'
    // 	, 'ArrowDown'
    // 	, 'ArrowLeft'
    // 	, 'ArrowRight'
    // 	, 'ArrowLeft'
    // 	, 'ArrowRight'
    // 	, 'KeyB'
    // 	, 'KeyA'
    // 	, 'Enter'
    // ];

    const konamiKeysA = ['Button12', 'Button12', 'Button13', 'Button13', 'Button14', 'Button15', 'Button14', 'Button15', 'Button1201', 'Button14', 'Button1200'];
    const konamiKeysB = ['Button12', 'Button12', 'Button13', 'Button13', 'Button14', 'Button15', 'Button14', 'Button15', 'Button1201', 'Button1200', 'Button1209'];
    const konamiSeqA = new _Sequence.Sequence({
      keys: konamiKeysA,
      timing: 750
    });
    const konamiSeqB = new _Sequence.Sequence({
      keys: konamiKeysB,
      timing: 750
    });
    _this.konamiSeqA = konamiSeqA;
    _this.konamiSeqB = konamiSeqB;
    _this.debugSeq = debugSeq;
    const gravityKeys = ['KeyS', 'KeyV', 'KeyG', 'KeyR', 'KeyA', 'KeyV'];
    const gravitySeq = new _Sequence.Sequence({
      keys: gravityKeys,
      timing: 750
    });
    _this.sequences = [debugSeq, konamiSeqA, konamiSeqB, gravitySeq];
    _this.args.debugEnabled = _Router.Router.query.debugEnabled;
    _this.args.debugEditMode = false;
    _this.args.debugObjectCursor = 0;
    _this.args.debugObjectName = new _CharacterString.CharacterString({
      value: ''
    });
    _this.debugBank = {};
    _this.args.interacted = false;
    debugSeq.addEventListener('complete', event => {
      if (_this.args.debugEnabled) {
        return;
      }
      _this.args.debugEnabled = true;
      console.log('Debug variable set.');
      _this.args.topLine.args.value = '';
      _this.args.topLine.args.hide = 'hide hidden';
      _this.onTimeout(1, () => {
        _this.args.topLine.args.value = ' Debug variable set! ';
        _this.args.topLine.args.hide = '';
      });
      _this.onTimeout(1500, () => {
        _this.args.topLine.args.hide = 'hide';
      });
      _this.onTimeout(1750, () => {
        _this.args.topLine.args.hide = 'hide hidden';
      });
    });

    // konamiSeq.addEventListener('advance', event => {
    // 	console.log(event);
    // });

    // konamiSeqA.addEventListener('cancel', event => {
    // 	console.log(event);
    // 	console.log(this.controlActor.controller);
    // });

    const konamiComplete = event => {
      if (_this.args.masterCheat) {
        return;
      }
      _this.args.masterCheat = true;
      _this.args.topLine.args.value = '';
      _this.args.topLine.args.hide = 'hide hidden';
      _this.onTimeout(1, () => {
        _this.args.topLine.args.value = ' Master cheat detected. ';
        _this.args.topLine.args.hide = '';
      });
      console.log('Master cheat detected.');
      _this.args.paused = false;
      _this.onTimeout(1500, () => {
        _this.args.topLine.args.value = '';
        _this.args.status.args.hide = 'hide';
      });
      _this.onTimeout(1750, () => {
        _this.args.topLine.args.hide = 'hide hidden';
      });
    };
    konamiSeqA.addEventListener('complete', konamiComplete);
    konamiSeqB.addEventListener('complete', konamiComplete);
    gravitySeq.addEventListener('complete', event => {
      if (!_this.controlActor) {
        return;
      }
      _this.controlActor.gravityCheat = !_this.controlActor.gravityCheat;
      _this.args.topLine.args.value = '';
      _this.args.topLine.args.hide = 'hide hidden';
      _this.onTimeout(1, () => {
        _this.args.topLine.args.value = ` Gravity cheat ${_this.controlActor.gravityCheat ? 'on' : 'off'}. `;
        _this.args.topLine.args.hide = '';
      });
      _this.onTimeout(1500, () => {
        _this.args.topLine.args.value = '';
        _this.args.status.args.hide = 'hide';
      });
      _this.onTimeout(1750, () => {
        _this.args.topLine.args.hide = 'hide hidden';
      });
      if (_this.controlActor.gravityCheat) {
        _this.controlActor.args.gravity *= 0.5;
      } else {
        _this.controlActor.args.gravity *= 2;
      }
    });
    _this.args.pauseMenu = new _PauseMenu.PauseMenu({}, _assertThisInitialized(_this));
    _this.particleObserver = new IntersectionObserver((entries, observer) => {
      for (const entry of entries) {
        if (entry.intersectionRation === 0) {
          entry.target.style.display = 'none';
          entry.target.remove();
        } else {
          delete entry.target.style.display;
        }
      }
    }, {
      threshold: 0
    });
    _this.particles = new _Bag.Bag((i, s, a) => {
      if (a === _Bag.Bag.ITEM_ADDED) {
        i.node && _this.particleObserver.observe(i.node);
        i.node && _this.tags.particles.appendChild(i.node);
      } else if (a === _Bag.Bag.ITEM_REMOVED) {
        i.remove();
      }
    });
    _this[Run] = 0;
    _this.effects = new _Bag.Bag();
    _this.maxCameraBound = 64;
    _this.cameraBound = 64;
    _this.args.particles = _this.particles.list;
    _this.args.effects = _this.effects.list;
    _this.args.maxFps = 69;
    _this.args.currentActor = '';
    _this.args.xMouse = 0;
    _this.args.YMouse = 0;
    _this.args.xMouseOffset = 0;
    _this.args.YMouseOffset = 0;
    _this.mouseState = {
      position: [0, 0],
      buttons: []
    };
    _this.args.xOffset = 0.5;
    _this.args.yOffset = 0.5;
    _this.args.xOffsetTarget = 0.5;
    _this.args.yOffsetTarget = 0.75;
    _this.args.topLine = new _CharacterString.CharacterString({
      value: ''
    });
    _this.args.status = new _CharacterString.CharacterString({
      value: ''
    });
    _this.args.focusMe = new _CharacterString.CharacterString({
      value: ''
    });
    _this.args.topLine.args.hide = 'hide hidden';
    _this.args.status.args.hide = 'hide hidden';
    _this.args.focusMe.args.hide = 'hide hidden';
    _this.args.labelChar = new _CharacterString.CharacterString({
      value: 'Char: '
    });
    _this.args.labelX = new _CharacterString.CharacterString({
      value: 'x pos: '
    });
    _this.args.labelY = new _CharacterString.CharacterString({
      value: 'y pos: '
    });
    _this.args.demoIndicator = null;
    _this.args.labelGround = new _CharacterString.CharacterString({
      value: 'Grounded: '
    });
    _this.args.labelCamera = new _CharacterString.CharacterString({
      value: 'Camera: '
    });
    _this.args.labelAngle = new _CharacterString.CharacterString({
      value: 'Gnd theta: '
    });
    _this.args.labelGSpeed = new _CharacterString.CharacterString({
      value: 'Gnd spd: '
    });
    _this.args.labelXSpeed = new _CharacterString.CharacterString({
      value: 'X air spd: '
    });
    _this.args.labelYSpeed = new _CharacterString.CharacterString({
      value: 'Y air spd: '
    });
    _this.args.labelLayer = new _CharacterString.CharacterString({
      value: 'Layer: '
    });
    _this.args.labelMode = new _CharacterString.CharacterString({
      value: 'Mode: '
    });
    _this.args.labelActors = new _CharacterString.CharacterString({
      value: 'Actors: '
    });
    _this.args.labelRegions = new _CharacterString.CharacterString({
      value: 'Regions: '
    });
    _this.args.labelFrame = new _CharacterString.CharacterString({
      value: 'Frame ID: '
    });
    _this.args.labelIgnore = new _CharacterString.CharacterString({
      value: 'Ignore: '
    });
    _this.args.labelFps = new _CharacterString.CharacterString({
      value: 'FPS: '
    });
    _this.args.labelAirAngle = new _CharacterString.CharacterString({
      value: 'Air theta: '
    });
    _this.args.char = new _CharacterString.CharacterString({
      value: '...'
    });
    _this.args.xPos = new _CharacterString.CharacterString({
      value: 0
    });
    _this.args.yPos = new _CharacterString.CharacterString({
      value: 0
    });
    _this.args.layer = new _CharacterString.CharacterString({
      value: 0
    });
    _this.args.gSpeed = new _CharacterString.CharacterString({
      value: 0,
      high: 199,
      med: 99,
      low: 49
    });
    _this.args.ground = new _CharacterString.CharacterString({
      value: ''
    });
    _this.args.xSpeed = new _CharacterString.CharacterString({
      value: 0
    });
    _this.args.ySpeed = new _CharacterString.CharacterString({
      value: 0
    });
    _this.args.mode = new _CharacterString.CharacterString({
      value: 0
    });
    _this.args.angle = new _CharacterString.CharacterString({
      value: 0
    });
    _this.args.ignore = new _CharacterString.CharacterString({
      value: 0
    });
    _this.args.actorCount = new _CharacterString.CharacterString({
      value: 0
    });
    _this.args.regionCount = new _CharacterString.CharacterString({
      value: 0
    });
    _this.args.xPerspective = 0;
    _this.args.cameraMode = new _CharacterString.CharacterString({
      value: 0
    });
    _this.args.airAngle = new _CharacterString.CharacterString({
      value: 0
    });
    _this.args.nowPlaying = new _CharacterString.CharacterString({
      value: 'Now playing'
    });
    _this.args.trackName = new _CharacterString.CharacterString({
      value: ''
    });
    _this.args.hideNowPlaying = 'hide-now-playing';
    _this.args.hiddenNowPlaying = 'hidden-now-playing';
    _Sfx.Sfx.addEventListener('play', event => {
      if (!_this.args.audio) {
        event.preventDefault();
      }
    });
    _Bgm.Bgm.addEventListener('play', event => {
      _this.bgm = _this.meta.bgm;
      if (!_this.args.audio) {
        event.preventDefault();
        _this.args.hideNowPlaying = 'hide-now-playing';
        _this.onFrameOut(60, () => {
          if (_this.args.hideNowPlaying) _this.args.hiddenNowPlaying = 'hidden-now-playing';
        });
        return;
      }
      if (!event.detail) {
        _this.args.trackName.args.value = '';
        _this.args.audioComment = '';
        _this.args.hideNowPlaying = 'hide-now-playing';
        _this.args.hiddenNowPlaying = 'hidden-now-playing';
        return;
      } else {
        _this.args.trackName.args.value = event.detail.TIT2 + ' by ' + event.detail.TPE1;
        _this.args.audioComment = event.detail.COMM;
      }
      if (_this.args.trackName.args.value) {
        let played = Promise.resolve();
        if (_this.args.zonecard) {
          played = _this.args.zonecard.played;
        }
        played.then(() => {
          if (!_this.args.started) {
            return;
          }
          _this.args.hiddenNowPlaying = '';
          _this.onFrameOut(60, () => _this.args.hideNowPlaying = '');
          if (!_this.timers.has(_Bgm.Bgm)) {
            _this.timers.set(_Bgm.Bgm, new _Countdown.Countdown(600, () => {
              _this.args.hideNowPlaying = 'hide-now-playing';
            }));
          } else {
            _this.timers.get(_Bgm.Bgm).extendTo(600);
          }
        });
      }
    });
    _Bgm.Bgm.addEventListener('stop', event => {});
    _Bgm.Bgm.addEventListener('pause', event => {});
    _Bgm.Bgm.addEventListener('unpause', event => {
      _this.args.audio || event.preventDefault();
    });
    _this.args.fpsSprite = new _CharacterString.CharacterString({
      value: 0
    });
    _this.args.frame = new _CharacterString.CharacterString({
      value: 0
    });
    _this.args.scoreLabel = new _CharacterString.CharacterString({
      value: 'SCORE:',
      color: 'yellow'
    });
    _this.args.timerLabel = new _CharacterString.CharacterString({
      value: 'TIME: ',
      color: 'yellow'
    });
    _this.args.ringLabel = new _CharacterString.CharacterString({
      value: 'RINGS: ',
      color: 'yellow'
    });
    _this.args.actClearLabel = new _CharacterString.CharacterString({
      value: '',
      color: 'yellow'
    });
    _this.args.dialogLines = [];
    _this.args.perfectBonusLabel = new _CharacterString.CharacterString({
      value: 'PERFECT BONUS: ',
      color: 'yellow'
    });
    _this.args.perfectBonus = new _CharacterString.CharacterString({
      value: 0
    });
    _this.args.speedBonusLabel = new _CharacterString.CharacterString({
      value: 'SPEED BONUS: ',
      color: 'yellow'
    });
    _this.args.speedBonus = new _CharacterString.CharacterString({
      value: 0
    });
    _this.args.skidBonusLabel = new _CharacterString.CharacterString({
      value: 'SKID BONUS: ',
      color: 'yellow'
    });
    _this.args.skidBonus = new _CharacterString.CharacterString({
      value: 0
    });
    _this.args.ringBonusLabel = new _CharacterString.CharacterString({
      value: 'RING BONUS: ',
      color: 'yellow'
    });
    _this.args.ringBonus = new _CharacterString.CharacterString({
      value: 0
    });
    _this.args.timeBonusLabel = new _CharacterString.CharacterString({
      value: 'TIME BONUS: ',
      color: 'yellow'
    });
    _this.args.timeBonus = new _CharacterString.CharacterString({
      value: 0
    });
    _this.args.airBonusLabel = new _CharacterString.CharacterString({
      value: 'AIR TIME: ',
      color: 'yellow'
    });
    _this.args.airBonus = new _CharacterString.CharacterString({
      value: '0%'
    });
    _this.args.totalBonusLabel = new _CharacterString.CharacterString({
      value: 'TOTAL: ',
      color: 'yellow'
    });
    _this.args.totalBonus = new _CharacterString.CharacterString({
      value: 0
    });
    _this.args.rings = new _CharacterString.CharacterString({
      value: 0
    });
    _this.args.score = new _CharacterString.CharacterString({
      value: 0
    });
    _this.args.timer = new _CharacterString.CharacterString({
      value: '00:00'
    });
    _this.args.ntsc = 'ntsc';
    _this.args.frameId = -1;
    _this.settings.bindTo('scaling', v => _this.fitScale(false), {
      wait: 0
    });
    _this.settings.bindTo('graphicsLevel', v => {
      switch (v) {
        case 'High':
          _this.settings.displace = true;
          _this.settings.scaling = true;
          _this.settings.blur = true;
          break;
        case 'Medium':
          _this.settings.scaling = true;
          _this.settings.displace = true;
          _this.settings.blur = false;
          break;
        case 'Low':
          _this.settings.scaling = true;
          _this.settings.displace = false;
          _this.settings.blur = false;
          break;
        case 'Very Low':
          _this.settings.displace = false;
          _this.settings.scaling = false;
          _this.settings.blur = false;
          break;
      }
    });
    _this.settings.bindTo('displace', v => _this.args.displacement = v ? 'on' : 'off');
    _this.settings.bindTo('outline', v => _this.args.outline = v);
    _this.settings.bindTo('debugOsd', v => _this.args.debugOsd = v);
    _this.settings.bindTo('showHud', v => _this.args.showHud = v);
    _this.settings.bindTo('shortcuts', v => _this.args.shortcuts = v);
    _this.settings.bindTo('showFps', v => _this.args.showFps = v);
    _this.settings.bindTo('smoothing', v => _this.args.smoothing = v);
    _this.settings.bindTo('musicVol', v => _Bgm.Bgm.setVolume(v / 100));
    _this.settings.bindTo('sfxVol', v => _Sfx.Sfx.setVolume(v / 100));
    _this.args.emeralds = [
      // 'green'
      // , 'cyan'
      // , 'white'
      // , 'orangered'
      // , 'yellow'
      // , 'purple'
    ];
    for (const setting in _this.settings) {
      const val = localStorage.getItem('sonic-3000-setting-v0.0.0=' + setting);
      try {
        var _JSON$parse;
        _this.settings[setting] = (_JSON$parse = JSON.parse(val)) !== null && _JSON$parse !== void 0 ? _JSON$parse : _this.settings[setting];
      } catch (e) {
        console.warn(e);
      }
    }
    _this.settings.bindTo((v, k) => {
      localStorage.setItem('sonic-3000-setting-v0.0.0=' + k, JSON.stringify(v));
    });
    _this.args.blockSize = 32;
    _this.args.populated = false;
    _this.args.willStick = false;
    _this.args.stayStuck = false;
    _this.args.willStick = true;
    _this.args.stayStuck = true;
    _this.args.scale = 1;
    _this.args.tileScale = 1;
    _this.args.width = 32 * 16;
    _this.args.height = 32 * 9;
    _this.args.bindTo('tileScale', v => {
      _this.args.width = 32 * 16 * v;
      _this.args.height = 32 * 9 * v;
      if (_this.args.layers) for (const layer of _this.args.layers) {
        layer.args.width = 32 * 16 * v;
        layer.args.height = 32 * 9 * v;
      }
      if (_this.args.fgLayers) for (const layer of _this.args.fgLayers) {
        layer.args.width = 32 * 16 * v;
        layer.args.height = 32 * 9 * v;
      }
      _this.fitScale();
    }, {
      wait: 1
    });

    // if(Router.query.tinyScale)
    // {
    // 	this.args.width  = 32 * 8;
    // 	this.args.height = 32 * 4.5;
    // 	this.args.scale  = 4;
    // }

    // if(Router.query.noScale)
    // {
    // 	this.args.width  = 32 * 14 * 2;
    // 	this.args.height = 32 * 8  * 2;
    // 	this.args.scale  = 2;
    // }

    // if(Router.query.bigScale)
    // {
    // 	this.args.width  = 32 * 60;
    // 	this.args.height = 32 * 34;
    // 	this.args.scale  = 1;
    // }

    _this.collisions = new Map();
    _this.args.x = _this.args.x || 0;
    _this.args.y = _this.args.y || 0;

    // this.args.bindTo(['x','y'], (v, k, t) => isNaN(v) && console.trace(k, v));
    // this.args.bindTo(['xOffset', 'xOffsetTarget'], (v, k, t) => isNaN(v) && console.trace(k, v));

    _this.args.fgLayers = [];
    _this.args.layers = [];
    _this.args.animation = '';
    _this.regions = new Set();
    _this.spawn = new Set();
    _this.auras = new Set();
    _this.recent = new Set();
    _this.actorsByName = {};
    _this.actorsById = {};
    window.actors = _this.actorsById;
    _this.playable = new Set();
    _this.actors = new _Bag.Bag((i, s, a) => {
      if (a == _Bag.Bag.ITEM_ADDED) {
        i.viewport = _assertThisInitialized(_this);

        // this.quadCell.insert(i, i.args);
        // this.quadCell.insert(i, {x: i.args.x - i.args.width / 2, y: i.args.y});
        // this.quadCell.insert(i, {x: i.args.x + i.args.width / 2, y: i.args.y});

        _this.setColCell(i);
        if (i instanceof _Region.Region) {
          _this.regions.add(i);
        }
        if (i.controllable) {
          _this.playable.add(i);
        }
        _this.actorsByName[i.args.name] = i;
        _this.actorsById[i.args.id] = i;
        _this.objectDb.add(i);
        i.onSpawned && i.onSpawned(_assertThisInitialized(_this));
      } else if (a == _Bag.Bag.ITEM_REMOVED) {
        i.viewport = null;
        _this.playable.delete(i);
        if (i instanceof _Region.Region) {
          _this.regions.delete(i);
        }
        delete _this.actorsByName[i.args.name];
        delete _this.actorsById[i.args.name];
        delete _this.actorsById[i.args.id];
        for (const _ref of _this.actorsByMap) {
          var _ref2 = _slicedToArray(_ref, 2);
          const actors = _ref2[1];
          delete actors[i.oid];
        }
        _this.recent.delete(i);
        _this.auras.delete(i);
        _this.updateStarted.delete(i);
        _this.updateEnded.delete(i);
        _this.updated.delete(i);

        // this.quadCell.remove(i);
        _this.objectDb.remove(i);

        // console.log(i, i[ColCell].has(i), i[ColCell]);

        const cell = _this.getColCell(i);
        if (i[ColCell]) {
          i[ColCell].delete(i);
        }
        if (i[ColCells]) {
          i[ColCells].forEach(c => c.delete(i));
        }
        if (cell) {
          cell.delete(i);
        }

        // console.log(i[ColCell].has(i));

        delete i[ColCell];
        i.remove();
        i.onDespawned && i.onDespawned(_assertThisInitialized(_this));
      }
    });
    const critiera = [/^Art\s+$/, /^Collision\s+$/, /^Destructible\s+$/];
    const comparator = () => {};
    _this.layerDb = new _Classifier.Classifier(critiera, comparator);
    _this.objectDb = new _Classifier.Classifier(Object.values(_ObjectPalette.ObjectPalette));
    _this.blocks = new _Bag.Bag();
    _this.args.blocks = _this.blocks.list;
    _this.args.actors = _this.actors.list;
    _this.listen(window, 'gamepadconnected', event => _this.padConnected(event));
    _this.listen(window, 'gamepaddisconnected', event => _this.padRemoved(event));
    _this.colCellDiv = 0.75 * Math.max(_this.args.width, _this.args.height);
    _this.colCellCache = new Map();
    _this.colCells = new Map();
    _this[ActorPointCache] = new Map();
    _this.startTime = null;
    _this.args.audio = false;
    _this.nextControl = false;
    _this.updateStarted = new Set();
    _this.updateEnded = new Set();
    _this.updated = new Set();
    _this.args.xBlur = 0;
    _this.args.yBlur = 0;
    _this.args.isReplaying = false;
    _this.args.isRecording = false;
    _this.args._isRecording = false;
    _this.replayFrames = new Map();
    _this.replayOffset = 0;
    _this.replayStart = null;
    _this.replay = null;
    _this.maxReplayFrame = 0;
    _this.lastFrame = {
      input: {},
      args: {}
    };
    _this.args.standalone = '';
    _this.args.fullscreen = '';
    _this.args.initializing = 'initializing';
    _this.args.muteSwitch = new _ClickSwitch.ClickSwitch();
    _this.args.muteSwitch.args.active = false;
    _this.args.bindTo('interacted', v => {
      if (!v) return;
      _this.args.muteSwitch.args.active = _this.getAudioSetting();
      _this.args.muteSwitch.args.bindTo('active', v => _this.args.audio = v);
      _this.args.bindTo('audio', v => {
        var _this$meta$bgm_delay;
        localStorage.setItem('sonic-3000-audio-enabled', v);
        const frameId = _this.args.frameId - _this.args.startFrameId;
        _this.onNextFrame(() => v ? _Sfx.Sfx.unpause() : _Sfx.Sfx.pause());
        if (frameId > ((_this$meta$bgm_delay = _this.meta.bgm_delay) !== null && _this$meta$bgm_delay !== void 0 ? _this$meta$bgm_delay : 0)) {
          _this.onNextFrame(() => v ? _Bgm.Bgm.unpause() : _Bgm.Bgm.pause());
        }
        _this.args.muteSwitch.args.active = v;
      });
    });
    _this.args.showConsole = null;
    _this.listen(document, 'keydown', event => {
      if (event.key === 'Escape') {
        _this.args.showConsole = false;
      }
      if (event.key === 'F10' || event.key === '`') {
        if (!_this.args.subspace) {
          _this.args.subspace = new _Console.Console({
            scroller: _this.tags.subspace,
            path: {
              'input': _Input.Input,
              'mark': _Mark.Mark,
              'impulse': _Impulse.Impulse,
              'move': _Move.Move,
              'pos': _Pos.Pos,
              'set': _Settings.Settings,
              'spawn': _Spawn.Spawn,
              'chao': _Chao.Chao
            }
          });
        }
        if (_this.args.networked) {
          _this.args.showConsole = false;
        } else {
          _this.args.showConsole = _this.args.showConsole ? null : 'showConsole';
        }
        event.preventDefault();
      }
    });
    _this.args.bindTo('shakeY', (v, k, t, d, p) => {
      if (!_this.controlActor || !_this.controlActor.controller || !_this.controlActor.controller.rumble) {
        return;
      }
      if (Math.abs(v) > 40 && Math.abs(v) > Math.abs(p)) {
        _this.controlActor.controller && _this.controlActor.controller.rumble({
          duration: 4 * v,
          strongMagnitude: 1.0,
          weakMagnitude: 1.0
        });
      } else if (Math.abs(v) > 20 && Math.abs(v) > Math.abs(p)) {
        _this.controlActor.controller && _this.controlActor.controller.rumble({
          duration: 8 * v,
          strongMagnitude: v / 20,
          weakMagnitude: 1.0
        });
      } else if (Math.abs(v) > 1) {
        _this.controlActor.controller && _this.controlActor.controller.rumble({
          duration: 16 * v,
          strongMagnitude: 0.1,
          weakMagnitude: 1.0
        });
      }
    });
    _this.args.bindTo('showConsole', v => {
      if (!_this.args.subspace) {
        return;
      }
      if (v) {
        _this.onNextFrame(() => _this.args.subspace.focus());
        _this.args.showConsole = 'showConsole';
      } else {
        _this.onNextFrame(() => _this.tags.viewport.focus());
        _this.args.showConsole = null;
      }
    });
    _this.controller = new _Controller.Controller({
      deadZone: 0.2
    });
    _this.controller.zero();
    _this.matrix = new _Matrix.Matrix(_this.settings.matrixUrl, {
      interval: 0
      // , storage: localStorage
    });
    return _this;
  }
  _createClass(Viewport, [{
    key: "loadWorld",
    value: function loadWorld(_ref3) {
      let worldUrl = _ref3.worldUrl,
        _ref3$networked = _ref3.networked,
        networked = _ref3$networked === void 0 ? false : _ref3$networked;
      let firstMapLoaded = false;
      const loader = new _Elicit.Elicit(worldUrl);
      loader.json().then(world => {
        const maps = world.maps.sort((a, b) => {
          if (a.x === b.x) {
            return a.y - b.y;
          }
          return a.x - b.x;
        });
        let xMin = Math.min(...maps.map(m => m.x));
        let yMin = Math.min(...maps.map(m => m.y));
        let xMax = Math.max(...maps.map(m => m.x + m.width));
        let yMax = Math.max(...maps.map(m => m.y + m.height));
        for (const map of maps) {
          map.x -= xMin;
          map.y -= yMin;
        }
        const firstMap = maps.shift();
        this.loadMap({
          mapUrl: '/map/' + firstMap.fileName,
          networked: networked
        }).then(() => {
          const blockSize = this.tileMap.mapData.tilewidth;

          // this.tileMap.offset(0, );

          // console.log(-xMin / blockSize, -yMin / blockSize);

          this.tileMap.resize(xMax, yMax);
          for (const map of maps) {
            console.log(map);
            const mapUrl = '/map/' + map.fileName;
            this.appendMap(mapUrl, map.x / blockSize, map.y / blockSize);
          }
        });
      });
    }
  }, {
    key: "loadSaves",
    value: function loadSaves() {
      let reload = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      if (reload || !this.getSaveIndex) {
        return this.getSaveIndex = _Save.Save.index();
      }
      return this.getSaveIndex;
    }
  }, {
    key: "getZoneState",
    value: function getZoneState(zone) {
      var _this$currentMap;
      const currentSave = this.currentSave;
      const currentZone = (_this$currentMap = this.currentMap) !== null && _this$currentMap !== void 0 ? _this$currentMap : '';
      return currentSave ? currentSave.getZoneState(zone || currentZone) : {};
    }
  }, {
    key: "getCharacterState",
    value: function getCharacterState(name) {
      const currentSave = this.currentSave;
      if (name) {
        const charState = currentSave.getCharacterState(name);
        return charState;
      }
      if (this.controlActor && this.controlActor.args.canonical) {
        const charState = currentSave.getCharacterState(this.controlActor.args.canonical);
        return charState;
      }
    }
  }, {
    key: "loadMap",
    value: function loadMap(_ref4) {
      let mapUrl = _ref4.mapUrl,
        _ref4$networked = _ref4.networked,
        networked = _ref4$networked === void 0 ? false : _ref4$networked,
        _ref4$useCheckpoint = _ref4.useCheckpoint,
        useCheckpoint = _ref4$useCheckpoint === void 0 ? true : _ref4$useCheckpoint;
      this.maps.clear();
      this.maps.set(mapUrl, {
        x: 0,
        y: 0
      });
      const tileMap = new _TileMap.TileMap({
        mapUrl: mapUrl
      });
      this.baseMap = this.currentMap = mapUrl;
      this.args.networked = networked;
      this.tileMap = tileMap;
      this.args.started = false;
      this.args.running = false;
      const load = new _LoadingCard.LoadingCard({
        timeout: -1,
        text: 'loading ... 0%'
      }, this);
      let inputType = 'kb';
      if (!this.args.selectedChar || this.args.selectedChar === 'Sonic') {
        inputType = this.args.inputType;
        if (inputType === 'input-generic') {
          inputType = 'input-xbox';
        }
        if (this.controller && this.controller.buttons && this.controller.buttons[6] && this.controller.buttons[7] && this.controller.buttons[6].time > 0 && this.controller.buttons[7].time > 0) {
          this.args.controlCardShown = false;
          inputType = 'input-dreamcast';
        } else if (this.controller && this.controller.buttons && this.controller.buttons[10] && this.controller.buttons[10].time > 0) {
          this.args.controlCardShown = false;
          inputType = 'input-gamecube';
        } else if (this.controller && this.controller.buttons && this.controller.buttons[8] && this.controller.buttons[8].time > 0) {
          this.args.controlCardShown = false;
        }
      }
      const controllerCard = new _GamepadConfig.GamepadConfig({
        inputType: inputType,
        char: this.args.selectedChar,
        timeout: -1,
        caption: 'loading ... 0%'
      });
      tileMap.addEventListener('level-progress', event => {
        const _event$detail = event.detail,
          received = _event$detail.received,
          length = _event$detail.length,
          done = _event$detail.done;
        load.args.text = `loading level ... ${(done * 100).toFixed(4)}%`;
        controllerCard.args.caption = `loading level ... ${(done * 100).toFixed(4)}%`;
      });
      tileMap.addEventListener('texture-progress', event => {
        const _event$detail2 = event.detail,
          received = _event$detail2.received,
          length = _event$detail2.length,
          done = _event$detail2.done;
        load.args.text = `loading textures ... ${(done * 100).toFixed(4)}%`;
        controllerCard.args.caption = `loading textures ... ${(done * 100).toFixed(4)}%`;
        if (done === 1) {
          load.args.text = `initializing...`;
          controllerCard.args.caption = `initializing...`;
        }
      });
      tileMap.ready.then(() => {
        const defList = Object.create(null);
        [...tileMap.getObjectDefs()].forEach(d => defList[d.oid || d.id] = d);
        this.defsByMap.set(this.currentMap, defList);
        if (this.tileMap.mapData && this.tileMap.mapData.properties) {
          for (const property of this.tileMap.mapData.properties) {
            const name = property.name.replace(/-/g, '_');
            this.meta[name] = property.value;
          }
        }
        this.args.fgLayers.length = 0;
        this.args.layers.length = 0;
        const layers = this.tileMap.tileLayers;
        const layerCount = layers.length;
        const blockSize = this.tileMap.mapData.tilewidth;
        this.args.blockSize = blockSize;
        for (let i = 0; i < layerCount; i++) {
          const layer = new _Layer.Layer({
            layerId: i,
            blockSize: blockSize,
            viewport: this,
            name: layers[i].name,
            width: this.args.width,
            height: this.args.height,
            parallax: layers[i].parallaxx,
            perspective: this.args.xPerspective
          });
          if (layers[i].name.substring(0, 10) === 'Foreground') {
            this.args.fgLayers.push(layer);
          } else {
            this.args.layers.push(layer);
          }
          if (this.meta.theme !== 'construct') {
            if (layers[i].name.substring(0, 9) === 'Collision') {
              layer.args.hidden = true;
            } else if (layers[i].name.substring(0, 6) === 'Moving' && layers[i].name.substring(0, 10) !== 'Moving Art') {
              layer.args.hidden = true;
            } else {
              layer.args.hidden = false;
            }
          }
        }
      });

      // if(mapUrl === '/map/see-saw-test.json')
      // {
      // 	tileMap.addMap('/map/appended-map.json');
      // }

      let waiter = new Promise(a => setTimeout(a, 6500));
      const cardShown = this.args.controlCardShown && !this.args.networked;
      const willShowCard = !cardShown && !this.args.map && (!this.args.selectedChar || this.args.selectedChar === 'Sonic' || this.args.selectedChar === 'Tails' || this.args.selectedChar === 'Knuckles');
      if (!this.replay && willShowCard && !_Router.Router.query.map) {
        this.args.titlecard = new _Series.Series({
          cards: [controllerCard]
        }, this);
        this.args.controlCardShown = true;
      } else {
        this.args.titlecard = new _Series.Series({
          cards: [load]
        }, this);
        waiter = Promise.resolve();
      }
      this.args.titlecard.play();
      const all = Promise.all([tileMap.ready, waiter]);
      all.then(() => load.args.text = `starting level`);
      all.then(() => this.startLevel({
        useCheckpoint: useCheckpoint
      }));
      return all;
    }
  }, {
    key: "fullscreen",
    value: function fullscreen() {
      this.exitFullscreen();
      this.args.focusMe.args.hide = 'hide';
      this.initScale = this.args.scale;
      this.showStatus(3500, ' hit escape to revert. ');
      this.tags.frame.node.requestFullscreen().then(res => {
        this.onTimeout(100, () => {
          this.fitScale();
          this.args.fullscreen = 'fullscreen';
        });
      }).catch(e => console.error(e));
    }
  }, {
    key: "exitFullscreen",
    value: function exitFullscreen() {
      if (document.fullscreenElement) {
        document.exitFullscreen();
        this.showStatus(0, '');
        this.args.focusMe.args.hide = '';
        this.args.fullscreen = '';
        return;
      }
    }
  }, {
    key: "fitScale",
    value: function fitScale() {
      let fill = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      if (!this.settings.scaling) {
        this.args.scale = 1;
      } else {
        const hScale = window.innerHeight / this.args.height;
        const vScale = window.innerWidth / this.args.width;
        if (fill) {
          this.args.scale = hScale > vScale ? hScale : vScale;
        } else {
          this.args.scale = hScale > vScale ? vScale : hScale;
        }
      }
      this.tags.frame && this.tags.frame.style({
        '--width': this.args.width * this.args.tileScale,
        '--height': this.args.height * this.args.tileScale,
        '--scale': this.args.scale
      });
    }
  }, {
    key: "showStatus",
    value: function showStatus(timeout, text) {
      this.args.status.args.hide = '';
      this.args.status.args.value = '';
      this.args.status.args.value = text;
      if (timeout >= 0) {
        if (this.statusTimeout) {
          clearTimeout(this.statusTimeout);
          this.statusTimeout = null;
        }
        this.statusTimeout = this.onTimeout(timeout, () => {
          this.args.status.args.hide = 'hide';
        });
        this.statusTimeout = this.onTimeout(timeout * 2, () => {
          this.args.status.args.hide = 'hide hidden';
        });
      }
    }
  }, {
    key: "getAudioSetting",
    value: function getAudioSetting() {
      var _localStorage$getItem;
      return !!JSON.parse((_localStorage$getItem = localStorage.getItem('sonic-3000-audio-enabled')) !== null && _localStorage$getItem !== void 0 ? _localStorage$getItem : true);
    }
  }, {
    key: "onAttached",
    value: function onAttached(event) {
      _Settings.Settings.viewport = this;
      _Impulse.Impulse.viewport = this;
      _Input.Input.viewport = this;
      _Mark.Mark.viewport = this;
      _Move.Move.viewport = this;
      _Pos.Pos.viewport = this;
      _Spawn.Spawn.viewport = this;
      _Chao.Chao.viewport = this;
      this.buildDetect();
      this.cpuDetect();
      this.gpuDetect();
      this.onTimeout(100, () => this.fitScale(false));
      this.onTimeout(5500, () => this.args.ntsc = '');
      const audioWasEnabled = this.getAudioSetting();
      const enableKeyboardMessage = ' Click here to enable keyboard control. ';
      const enableAudioMessage = ' Click here to enable audio. ';
      this.onTimeout(_Router.Router.query.map || _Router.Router.query.nointro ? 0 : 36000, () => {
        this.args.bindTo('interacted', v => {
          const focusMeMessage = !v && audioWasEnabled ? enableAudioMessage : enableKeyboardMessage;
          const oldMessage = this.args.focusMe.args.value;
          if (oldMessage === focusMeMessage) {
            return;
          }
          this.args.focusMe.args.value = '';
          this.args.focusMe.args.value = focusMeMessage;
        }, {
          wait: 250
        });
      });

      // this.listen(this.tags.frame, 'click', (event) => {
      // 	if(event.target === this.tags.frame.node)
      // 	{
      // 		this.tags.viewport.focus();
      // 	}
      // });

      this.settings.bindTo('blur', v => {
        if (v) {
          this.tags.blurDistance.setAttribute('style', `filter:url(#motionBlur)`);
          this.tags.blurDistanceFg.setAttribute('style', `filter:url(#motionBlur)`);
        } else {
          this.tags.blurDistance.setAttribute('style', ``);
          this.tags.blurDistanceFg.setAttribute('style', ``);
        }
      });
      this.listen(window, 'resize', event => {
        this.onTimeout(100, () => this.fitScale(false));
      });
      this.listen(document, 'fullscreenchange', event => {
        this.onTimeout(100, () => this.fitScale(false));
        if (!document.fullscreenElement) {
          this.args.scale = this.initScale;
          this.args.fullscreen = '';
          return;
        }
      });
      this.tags.frame.style({
        '--width': this.args.width,
        '--height': this.args.height,
        '--scale': this.args.scale
      });
      if (!this.startTime) {
        this.startTime = 0;
      }
      this.args.started = false;
      this.args.running = false;
      this.args.paused = false;
      this.listen(document.body, 'click', event => {
        let element = event.target;
        while (element && element.matches) {
          if (element.matches('[data-click-barrier]')) {
            return;
          }
          element = element.parentNode;
        }
        if (this.tags.viewport.contains(document.activeElement)) {
          return;
        }
        this.tags.viewport.focus();
      }, {
        capture: true
      });
      this.args.scale = this.args.scale || 1;
      const keyboard = _Keyboard.Keyboard.get();
      keyboard.listening = true;
      keyboard.focusElement = this.tags.viewport.node;
      keyboard.codes.bindTo((v, k, t, d) => {
        if (this.controller && this.controller.keyIsMapped(k)) {
          return;
        }
        if (v === -1) {
          this.sequences.map(s => s.check(k));
        }
      });
      this.tags.viewport.node.focus();
      if (0 || window.matchMedia('(display-mode: standalone)').matches || window.matchMedia('(display-mode: fullscreen)').matches) {
        this.args.standalone = 'standalone';
        document.title = 'Sonic 3000';
        this.listen(window, 'resize', () => this.fitScale(false));
        this.onTimeout(100, () => this.fitScale(false));
      }
      this.onTimeout(100, () => this.args.initializing = '');
    }
  }, {
    key: "setZoneCard",
    value: function setZoneCard() {
      let replay = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      if (!replay) {
        this.args.zonecard = new _Titlecard.Titlecard({
          waitFor: this.tileMap.ready
        }, this);
      }
      const line1 = this.meta.titlecard_title_1;
      const line2 = this.meta.titlecard_title_2;
      const author = this.meta.titlecard_author;
      const number = this.meta.titlecard_number;
      this.args.zonecard.args.firstLine = line1;
      this.args.zonecard.args.secondLine = line2;
      this.args.zonecard.args.creditLine = author;
      this.args.zonecard.args.actNumber = number;
      this.args.actName = `${line1} ${line2} ${number}`;
      if (!replay) {
        this.args.titlecard = new _Series.Series({
          cards: [this.args.zonecard]
        }, this);
        return this.args.titlecard.play();
      }
      return Promise.resolve();
    }
  }, {
    key: "fillBackground",
    value: function fillBackground() {
      const backdropClass = _BackdropPalette.BackdropPalette[this.meta.backdrop];
      delete this.args.backdrop;
      if (backdropClass) {
        this.args.backdrop = new backdropClass();
      } else {
        this.args.backdrop = null;
      }
      this.args.theme = this.meta.theme || 'construct';
      this.args.bg = this.meta.backdrop;
    }
  }, {
    key: "startLevel",
    value: function startLevel() {
      let refresh = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      this.populateMap();
      this.levelFinished = false;
      if (!this.args.isReplaying) {
        this.args._isRecording = !this.args.networked;
      }
      this.args.debugEditMode = false;
      this.clearDialog();
      this.hideDialog();
      this.args.mouse = 'hide';
      this.args.currentSheild = null;
      this.args.hasFire = false;
      this.args.hasWater = false;
      this.args.hasElectric = false;
      this.args.hasNormal = false;
      if (this.meta.zoneScript && _ScriptPalette.ScriptPalette[this.meta.zoneScript]) {
        this.zoneScript = new _ScriptPalette.ScriptPalette[this.meta.zoneScript]();
      }
      _Bgm.Bgm.stop('MENU_THEME');
      if (_Bgm.Bgm.playing && this.meta.bgm !== this.bgm) {
        _Bgm.Bgm.stop();
      }
      if (!this.meta.bgm) {
        _Bgm.Bgm.fadeOut(250);
      }
      if (!this.args.audio) {
        _Bgm.Bgm.pause();
      }
      if (refresh) {
        this.setZoneCard();
        this.zeroFrame = false;
      }
      this.fillBackground();
      if (this.args.networked && !this.remotePlayer) {
        const sonic = new _Sonic.Sonic({
          name: 'Player 1',
          id: String(new _Uuid.Uuid())
        }, this);
        const tails = new _Sonic.Sonic({
          name: 'Player 2',
          id: String(new _Uuid.Uuid())
        }, this);
        if (this.args.playerId === 1) {
          this.nextControl = sonic;
          this.remotePlayer = tails;
          tails.args.netplayer = true;
        } else if (this.args.playerId === 2) {
          this.remotePlayer = sonic;
          this.nextControl = tails;
          sonic.args.netplayer = true;
        }
        const startDef = this.defsByName.get('player-start');
        sonic.args.x = startDef.x;
        sonic.args.y = startDef.y;
        tails.args.x = startDef.x;
        tails.args.y = startDef.y;
        this.spawn.add({
          object: sonic
        });
        this.spawn.add({
          object: tails
        });
        this.auras.add(sonic);
        this.auras.add(tails);
        this.actors.add(sonic);
        this.actors.add(tails);
      }
      for (const layer of [...this.args.layers, ...this.args.fgLayers]) {
        layer.args.destroyed = false;
      }
      if (!this.args.networked) {
        const actors = this.actors.list;
        if (!this.playableIterator) {
          this.playableIterator = this.playable.entries();
        }
        if (Object.values(this.args.actors)[0] && Object.values(this.args.actors)[0].controllable) {
          this.nextControl = Object.values(this.args.actors)[0];
        }
      }
      if (this.nextControl && this.nextControl.controller) {
        this.nextControl.controller.zero();
      }
      if (this.controller) {
        this.controller.zero();
      }
      _Keyboard.Keyboard.get().reset();
      this.args.started = false;
      _Bgm.Bgm.unpause();
      this.args.zonecard.played.then(() => {
        const zoneState = this.getZoneState();
        if (!this.replay) {
          for (const emblemId of zoneState.emblems) {
            if (!this.actorsById[emblemId]) {
              continue;
            }
            const emblem = this.actorsByMap.get(this.currentMap)[emblemId];
            if (!emblem || emblem.mapUrl !== this.currentMap || !(emblem instanceof _Emblem.Emblem)) {
              continue;
            }
            emblem.existing = 'existing';
            if (this.nextControl && !this.nextControl.args.emblems.includes(emblem)) {
              this.nextControl.args.emblems.push(emblem);
            }
          }
          for (const emerald of this.currentSave.emeralds) {
            if (!this.args.emeralds.includes(emerald)) {
              this.args.emeralds.push(emerald);
            }
          }
        }
        this.args.startFrameId = this.args.frameId - this.replayOffset;
        this.args.actStartFrameId = this.args.startFrameId;
        if (this.replayStart) {
          if (this.nextControl) {
            for (let i in this.replayStart[2]) {
              Object.assign(this.nextControl.args, this.replayStart[2][i]);
              break;
            }
            this.nextControl.controller.replay(this.replayStart[1] || {});
            this.nextControl.readInput();
          }
        } else if (_Router.Router.query.start) {
          const start = _Router.Router.query.start;
          if (start.match(/\d+(\.\d+)?,\d+(\.\d+)?/)) {
            const _start$split = start.split(','),
              _start$split2 = _slicedToArray(_start$split, 2),
              _start$split2$ = _start$split2[0],
              x = _start$split2$ === void 0 ? 128 : _start$split2$,
              _start$split2$2 = _start$split2[1],
              y = _start$split2$2 === void 0 ? 128 : _start$split2$2;
            this.nextControl.args.x = Number(x);
            this.nextControl.args.y = Number(y);
          } else if (this.defsByName.has(start)) {
            const point = this.defsByName.get(start);
            this.nextControl.args.x = Number(point.x);
            this.nextControl.args.y = Number(point.y);
          }
          if (this.nextControl.follower) {
            this.nextControl.follower.args.x = this.nextControl.x;
            this.nextControl.follower.args.y = this.nextControl.y;
            this.setColCell(this.nextControl.follower);
          }
          if (_Router.Router.query.impulse) {
            const impulse = _Router.Router.query.impulse;
            console.log(impulse);
            if (impulse.match(/-?\d+(\.\d+)?,-?\d+(\.\d+)?/)) {
              const _impulse$split = impulse.split(','),
                _impulse$split2 = _slicedToArray(_impulse$split, 2),
                _impulse$split2$ = _impulse$split2[0],
                x = _impulse$split2$ === void 0 ? 0 : _impulse$split2$,
                _impulse$split2$2 = _impulse$split2[1],
                y = _impulse$split2$2 === void 0 ? 0 : _impulse$split2$2;
              console.log({
                x: x,
                y: y
              });
              this.nextControl.args.xSpeed = Number(x);
              this.nextControl.args.ySpeed = Number(y);
            }
          }
          if (_Router.Router.query.rings) {
            this.nextControl.args.rings = Number(_Router.Router.query.rings);
          }
          if (Number(_Router.Router.query.noClip)) {
            this.nextControl.args.float = -1;
            this.nextControl.noClip = 1;
          }
          if (Number(_Router.Router.query.pause)) {
            this.args.pauseMenu.args.hideMenu = 'pause-menu-hide';
            this.args.paused = Number(_Router.Router.query.pause);
          }
        } else if (!this.replay && !this.args.isReplaying && !this.args.isRecording && !this.args.networked) {
          this.args.demoIndicator = null;
          if (this.nextControl) {
            const storedPosition = this.getCheckpoint(this.nextControl.args.canonical);
            if (storedPosition) {
              const checkpoint = storedPosition ? this.actorsByMap.get(this.currentMap)[storedPosition.checkpointId] : null;
              if (checkpoint) {
                this.args.startFrameId = this.args.frameId - storedPosition.frames;
                this.args.actStartFrameId = this.args.startFrameId;
                checkpoint.args.wasActive = true;
                checkpoint.args.active = true;
                this.nextControl.args.x = checkpoint.x;
                this.nextControl.args.y = checkpoint.y;
                if (this.nextControl.follower) {
                  this.nextControl.follower.args.x = checkpoint.x;
                  this.nextControl.follower.args.y = checkpoint.y;
                  this.setColCell(this.nextControl.follower);
                }
                this.args.xOffset = 0.5;
                this.args.yOffset = 0.5;
                _Bgm.Bgm.play(this.meta.bgm, {
                  loop: true
                });
              }
            }
          }
        }
        this.args.level = 'level';
        this.args.fade = false;
        this.args.started = true;
        this.args.running = true;
        this.startTime = Date.now();
        this.onFrameOut(30, () => this.args.fade = 'hide');
        if (typeof ga === 'function') {
          ga('send', 'event', {
            eventCategory: 'zone',
            eventAction: 'started',
            eventLabel: `${this.args.actName}`
          });
        }
      });
    }
  }, {
    key: "finishLevel",
    value: function finishLevel() {
      if (!this.replay) {
        this.saveReplay('#008000').catch(() => {});
      }
      this.levelFinished = true;
    }
  }, {
    key: "saveReplay",
    value: function saveReplay(color) {
      const replay = new _Replay.Replay();
      replay.consume({
        color: color,
        map: this.baseMap,
        frames: [...this.replayFrames.values()]
      });
      if (replay.lastFrame - replay.firstFrame < 30) {
        return Promise.reject();
      }
      return _ReplayDatabase.ReplayDatabase.open('replays', 3).then(database => {
        delete replay.id;
        const res = database.insert('replays', replay).then(() => replay);
        this.replayFrames = new Map();
        this.replayOffset = 0;
        this.replayStart = null;
        this.replay = null;
        return res;
      });
    }
  }, {
    key: "takeInput",
    value: function takeInput(controller) {
      const keyboard = _Keyboard.Keyboard.get();
      keyboard.update();
      if (!this.gamepad && !this.args.cutScene) {
        controller.readInput({
          keyboard: keyboard
        });
        this.args.inputType = 'input-keyboard';
      } else if (!this.args.cutScene) {
        const gamepads = navigator.getGamepads();
        controller.readInput({
          keyboard: keyboard,
          gamepads: gamepads
        });
        for (let i = 0; i < gamepads.length; i++) {
          const gamepad = gamepads[i];
          if (!gamepad) {
            continue;
          }
          if (gamepad) {
            const gamepadId = String(gamepad.id);
            if (gamepadId.match(/x-?bo?x/i)) {
              this.args.inputType = 'input-xbox';
            } else if (gamepadId.match(/ps[345]/i) || gamepadId.match(/playstation/i) || gamepadId.match(/duals(hock|ense)/i) || gamepadId.match(/ds[45]/i)) {
              this.args.inputType = 'input-playstation';
            } else {
              this.args.inputType = 'input-generic';
            }
          } else {
            this.args.inputName = 'keyboard';
            this.args.inputType = 'input-keyboard';
          }
        }
      } else {
        this.controlActor.args.idleTime = 0;
      }
      if (this.controlActor && this.args.debugEditMode) {
        if (controller.buttons[0] && controller.buttons[0].time === 1) {
          const defKeys = Object.keys(_ObjectPalette.ObjectPalette);
          const debugObjectType = defKeys[this.args.debugObjectCursor];
          if (!this.debugBank[debugObjectType]) {
            this.debugBank[debugObjectType] = new _ObjectPalette.ObjectPalette[debugObjectType]();
          }
          const spawnObject = this.debugBank[debugObjectType];
          this.spawn.add({
            object: spawnObject
          });
          if (spawnObject.controllable) {
            spawnObject.args.name = 'SPAWN';
            this.playable.add(spawnObject);
          }
          spawnObject[Run] = this[Run];
          spawnObject.args.x = this.controlActor.args.x;
          spawnObject.args.y = this.controlActor.args.y;
          delete this.debugBank[debugObjectType];
        }
        if (controller.buttons[1] && controller.buttons[1].time === 1) {
          this.args.debugObjectCursor++;
          const defKeys = Object.keys(_ObjectPalette.ObjectPalette);
          if (this.args.debugObjectCursor >= defKeys.length) {
            this.args.debugObjectCursor = 0;
          }
          const debugObjectType = defKeys[this.args.debugObjectCursor];
          if (!this.debugBank[debugObjectType]) {
            this.debugBank[debugObjectType] = new _ObjectPalette.ObjectPalette[debugObjectType]();
          }
          while (this.tags.spawnPreview.node.firstChild) {
            this.tags.spawnPreview.node.firstChild.remove();
          }
          this.debugBank[debugObjectType].render(this.tags.spawnPreview.node);
          this.args.debugObjectName.args.value = debugObjectType;
        }
        if (controller.buttons[2] && controller.buttons[2].time === 1) {
          this.args.debugObjectCursor--;
          const defKeys = Object.keys(_ObjectPalette.ObjectPalette);
          if (this.args.debugObjectCursor <= 0) {
            this.args.debugObjectCursor = defKeys.length - 1;
          }
          const debugObjectType = defKeys[this.args.debugObjectCursor];
          if (!this.debugBank[debugObjectType]) {
            this.debugBank[debugObjectType] = new _ObjectPalette.ObjectPalette[debugObjectType]();
          }
          while (this.tags.spawnPreview.node.firstChild) {
            this.tags.spawnPreview.node.firstChild.remove();
          }
          this.debugBank[debugObjectType].render(this.tags.spawnPreview.node);
          this.args.debugObjectName.args.value = debugObjectType;
        }
      }
      if (this.args.debugEnabled) {
        if (!this.args.plot) {
          this.args.plot = new _Plot.Plot();
        }
        if (controller.buttons[8] && controller.buttons[8].time === 1) {
          this.args.debugEditMode = !this.args.debugEditMode;
          this.settings.debugOsd = this.args.debugEditMode;
        }
      }
      if (controller.buttons[2011] && controller.buttons[2011].time === 1) {
        this.fullscreen();
      }
      if (controller.buttons[2008] && controller.buttons[2008].time === 1) {
        this.args.muteSwitch.args.active = !this.args.muteSwitch.args.active;
      }
      if (controller.buttons[2009] && controller.buttons[2009].time === 1) {
        this.settings.debugOsd = !this.settings.debugOsd;
      }
      if (controller.buttons[1050] && controller.buttons[1050].time === 1) {
        if (this.args.fullscreen) {
          this.exitFullscreen();
        }
      }
      if (controller.buttons[1020] && controller.buttons[1020].time === 1) {
        if (this.args.started) {
          this.args.paused ? this.unpauseGame() : this.pauseGame();
        }
      }
      if (!this.args.networked && controller.buttons[1011] && controller.buttons[1011].time > 0) {
        this.args.pauseMenu.input(controller);
      }
      if (this.replay && this.replay.auto && controller.buttons[1209] && controller.buttons[1209].time > 0) {
        this.quit(this.args.replayQuickExit ? 2 : 1);
      }
      if (!this.args.networked && !this.args.paused) {
        if (!this.dontSwitch && controller.buttons[11] && controller.buttons[11].time === 1) {
          this.playableIterator = this.playableIterator || this.playable.entries();
          let next = this.playableIterator.next();
          if (next.done) {
            this.playableIterator = false;
            this.playableIterator = this.playable.entries();
            next = this.playableIterator.next();
          }
          if (next.value) {
            this.nextControl = next.value[0];
            this.dontSwitch = 3;
          }
        }
      }
      if (this.args.started) {
        if (this.controlActor) {
          this.args.currentSheild = this.controlActor.args.currentSheild ? this.controlActor.args.currentSheild.type : '';
        }
        const pauseButton = 9;
        if (controller.buttons[pauseButton] && controller.buttons[pauseButton].active && controller.buttons[pauseButton].time === 1) {
          if (this.args.paused) {
            this.unpauseGame();
          } else {
            this.pauseGame();
          }
        }
        if (!this.args.isReplaying && (this.args.isRecording || this.args._isRecording)) {
          if (this.args.isRecording && !this.args.demoIndicator) {
            this.args.demoIndicator = new _CharacterString.CharacterString({
              value: '⏺ REC',
              color: 'red'
            });
          }
          const frame = this.args.frameId - this.args.startFrameId;
          const input = controller.serialize();
          let args = {},
            _args = {},
            _input = {};
          if (this.controlActor) {
            args = _defineProperty({}, this.controlActor.args.id, {
              x: this.controlActor.args.x,
              y: this.controlActor.args.y,
              mode: this.controlActor.args.mode,
              falling: this.controlActor.args.falling,
              groundAngle: this.controlActor.args.groundAngle,
              gSpeed: this.controlActor.args.gSpeed,
              xSpeed: this.controlActor.args.xSpeed,
              ySpeed: this.controlActor.args.ySpeed
            });
          }
          let changed = false;
          if (frame % 60 === 0 || this.replayFrames.size === 0) for (let i in args) {
            _args[i] = _args[i] || {};
            this.lastFrame.args[i] = this.lastFrame.args[i] || {};
            let _changed = false;
            for (let j in args[i]) {
              if (args[i][j] !== this.lastFrame.args[i][j]) {
                this.lastFrame.args[i][j] = _args[i][j] = args[i][j];
                changed = _changed = true;
              }
            }
            if (!_changed) {
              delete _args[i];
            }
          }
          for (let i in input) {
            _input[i] = _input[i] || {};
            this.lastFrame.input[i] = this.lastFrame.input[i] || {};
            for (let j in input[i]) {
              if (input[i][j] !== this.lastFrame.input[i][j]) {
                this.lastFrame.input[i][j] = _input[i][j] = input[i][j];
                changed = true;
              }
            }
          }
          if (_input.axes && !Object.keys(_input.axes).length) {
            delete _input.axes;
          }
          if (_input.buttons && !Object.keys(_input.buttons).length) {
            delete _input.buttons;
          } else {
            delete _input.buttons[1011];
          }
          if (changed && this.controlActor && !this.controlActor.args.dead) {
            this.replayFrames.set(frame, [frame, _input, _args]);
          }
        }
      }
      controller.update({
        gamepad: this.gamepad
      });
    }
  }, {
    key: "moveCamera",
    value: function moveCamera() {
      if (!this.controlActor) {
        return;
      }
      if (!this.zeroFrame) {
        this.args.x = -this.controlActor.args.x;
        this.args.y = -this.controlActor.args.y;
      }
      this.zeroFrame = true;
      if (this.cameraBound <= this.maxCameraBound) {
        this.cameraBound = this.maxCameraBound;
      } else if (this.cameraBound < Infinity) {
        this.cameraBound -= 0.05 * this.cameraBound;
      } else {
        this.maxCameraBound = this.cameraBound = Math.hypot(this.args.x + this.controlActor.args.x, this.args.y + this.controlActor.args.y);
      }
      let cameraSpeed = 25;
      let actor = this.controlActor;
      let groundBias = 0;
      if (actor.args.standingOn) {
        groundBias = actor.args.standingOn.args.cameraBias;
        if (actor.args.standingOn.isVehicle) {
          actor = actor.args.standingOn;
        }
      }
      if (actor.focused) {
        if (this.cameraMode !== 'panning' && actor.args.cameraMode === 'panning') {
          const focus = actor.focused;
          this.cameraBound = this.maxCameraBound = Math.max(Math.abs(focus.x - actor.args.x), Math.abs(focus.y - actor.args.y));
          this.args.x -= actor.args.x - focus.x;
          this.args.y -= actor.args.y - focus.y;
        }
        this.cameraMode = actor.args.cameraMode;
        actor = actor.focused;
      } else {
        this.cameraMode = actor.args.cameraMode;
      }
      const highJump = actor.args.highJump;
      const deepJump = actor.args.deepJump;
      const falling = actor.args.falling;
      const fallSpeed = actor.args.ySpeed;
      switch (this.cameraMode) {
        case 'panning':
          this.args.xOffsetTarget = 0.5;
          this.args.yOffsetTarget = 0.85;
          cameraSpeed = 8;
          break;
        case 'boost-ring':
          const angle = actor.args.angle;
          if (!angle || Math.abs(angle - Math.PI) < 0.1) {
            this.args.xOffsetTarget = 0.5;
            this.args.yOffsetTarget = 0.5;
            cameraSpeed = 24;
          } else {
            this.args.xOffsetTarget = 0.5 - 0.5 * Math.cos(angle);
            this.args.yOffsetTarget = 0.5 - 0.2 * Math.sin(angle);
            cameraSpeed = 16;
          }
          break;
        case 'cross-cannon':
          this.args.xOffsetTarget = 0.5;
          this.args.yOffsetTarget = 0.4;
          cameraSpeed = 18;
          break;
        case 'cross-cannon-quick':
          this.args.xOffsetTarget = 0.5;
          this.args.yOffsetTarget = 0.4;
          cameraSpeed = 5;
          break;
        case 'cutScene':
          this.args.xOffsetTarget = [0.50, 0.25, 0.50, 0.75][actor.args.mode];
          this.args.yOffsetTarget = [0.75, 0.50, 0.25, 0.50][actor.args.mode];
          this.maxCameraBound = 64;
          cameraSpeed = 15;
          break;
        case 'corkscrew':
          this.args.xOffsetTarget = 0.5;
          this.args.yOffsetTarget = 0.75;
          this.maxCameraBound = 96;
          cameraSpeed = 64;
          break;
        case 'normal':
          this.args.xOffsetTarget = [0.50, 0.45, 0.50, 0.55][actor.args.mode];
          this.args.yOffsetTarget = [0.50, 0.50, 0.50, 0.50][actor.args.mode];
          this.maxCameraBound = 96;
          cameraSpeed = 24;
          if (actor.args.mode === 0) {
            cameraSpeed = 9;
          }
          break;
        case 'perspective':
          this.args.xOffsetTarget = [0.50, 0.30, 0.50, 0.70][actor.args.mode];
          this.args.yOffsetTarget = [0.50, 0.50, 0.50, 0.50][actor.args.mode];
          this.maxCameraBound = 96;
          cameraSpeed = 24;
          break;
        case 'climbing':
          this.args.xOffsetTarget = [0.50, 0.33, 0.50, 0.66][actor.args.mode];
          this.args.yOffsetTarget = [0.50, 0.50, 0.50, 0.50][actor.args.mode];
          this.maxCameraBound = 48;
          cameraSpeed = 24;
          break;
        case 'airplane':
          {
            const xSpeed = actor.args.xSpeed;
            const absSpeed = Math.abs(xSpeed);
            const shiftSpeed = 5;
            cameraSpeed = 20;
            const speedBias = Math.max(absSpeed / 100, 0.45) * -Math.sign(xSpeed);
            this.args.xOffsetTarget = 0.5 + speedBias;
            this.args.yOffsetTarget = 0.5;
            break;
          }

        // case 'railcar-aerial':
        // case 'railcar-normal':
        // 	this.args.xOffsetTarget = 0.5;
        // 	this.args.yOffsetTarget = 0.5;
        // 	this.maxCameraBound = 0;
        // 	cameraSpeed = 0;

        // 	break;

        case 'aerial':
          this.args.xOffsetTarget = 0.5;
          cameraSpeed = 24;
          if (!actor.args.flying && (deepJump || highJump)) {
            if (fallSpeed < 0) {
              this.args.yOffsetTarget = 0.75;
            } else {
              this.args.yOffsetTarget = 0.35;

              // cameraSpeed = 15;
            }
          } else {
            this.args.yOffsetTarget = 0.5;
          }
          break;
        case 'popping':
          this.args.xOffsetTarget = 0.5;
          this.args.yOffsetTarget = 0.25;
          this.maxCameraBound = 64;
          cameraSpeed = 6;
          break;
        case 'hooked':
          this.args.xOffsetTarget = 0.50;
          this.args.yOffsetTarget = 0.60;
          this.maxCameraBound = 1;
          cameraSpeed = 25;
          break;
        case 'tube':
          this.args.xOffsetTarget = 0.50;
          this.args.yOffsetTarget = 0.50;
          this.maxCameraBound = 64;
          cameraSpeed = 24;
          break;
        case 'cinematic':
          this.args.xOffsetTarget = 0.50;
          this.args.yOffsetTarget = 0.50;
          this.maxCameraBound = 1;
          cameraSpeed = 0;
          break;
        case 'cliff':
          this.args.xOffsetTarget = 0.50 + -0.1 * actor.args.direction;
          this.args.yOffsetTarget = 0.30;
          cameraSpeed = 30;
          break;
        case 'bridge':
          this.args.xOffsetTarget = 0.50;
          this.args.yOffsetTarget = 0.35;
          cameraSpeed = 24;
          break;
        case 'boss':
          this.args.xOffsetTarget = 0.50;
          this.args.yOffsetTarget = 0.72;
          this.maxCameraBound = 64;
          cameraSpeed = 24;
          break;
        case 'draggable':
          this.args.xOffsetTarget = 0.5;
          this.args.yOffsetTarget = 0.5;
          this.maxCameraBound = 48;
          cameraSpeed = 3;
          break;
        case 'locked':
          this.args.xOffsetTarget = 0.50;
          this.args.yOffsetTarget = 0.25;
          this.maxCameraBound = 32;
          cameraSpeed = 16;
          break;
        default:
          this.maxCameraBound = 64;
          cameraSpeed = 25;
          break;
      }
      const biasModes = ['normal', 'perspective', 'bridge', 'cliff', 'aerial', 'tube', 'hooked', 'cutScene', 'hooked', 'corkscrew'];
      if (biasModes.includes(this.cameraMode) && !actor.args.pushing && actor.args.modeTime > 0) {
        let biaser = actor;
        if (actor.args.standingOn && actor.args.standingOn.invertsBias) {
          biaser = actor.args.standingOn;
        }
        let gSpeed = biaser.args.gSpeed;
        let xSpeed = biaser.args.xSpeed;
        if (actor.args.hangingFrom) {
          xSpeed = actor.args.hangingFrom.args.xSpeed;
        }
        if (biaser.args.standingLayer) {
          gSpeed += biaser.args.standingLayer.offsetXChanged;
        }
        const grounded = !biaser.args.falling;
        const absSpeed = Math.abs(grounded ? gSpeed : xSpeed);
        const shiftSpeed = 17;
        let speedBias = Math.abs(biaser.xLast - biaser.args.x) > 1 && Math.min(absSpeed / shiftSpeed, 1) * -Math.sign(gSpeed || xSpeed);
        if (biaser !== actor) {
          speedBias *= 4;
        }
        switch (biaser.args.mode) {
          case 0:
            this.args.xOffsetTarget += speedBias * 0.4;
            break;
          case 1:
            this.args.yOffsetTarget += speedBias * 0.4;
            break;
          case 2:
            this.args.xOffsetTarget -= speedBias * 0.4;
            break;
          case 3:
            this.args.yOffsetTarget -= speedBias * 0.4;
            break;
        }
        this.args.speedBias = speedBias;
      }
      this.args.xOffsetTarget = Math.max(0, Math.min(1, this.args.xOffsetTarget));
      if (actor.args.jumping && actor.args.fallTime > 15) {
        this.maxCameraBound = 128;
        if (deepJump || highJump) {
          cameraSpeed *= 0.75;
        }
      }
      let ySpeedBias = 0;
      let ySpeedMax = 512;
      let ySpeed = 0;
      if (this.cameraMode !== 'boss' && this.cameraMode !== 'rocket' && actor.args.modeTime > 0) {
        if (!actor.args.falling && actor.args.mode === 1) {
          ySpeedMax = actor.args.gSpeedMax;
          ySpeed = actor.args.gSpeed / 12;
        } else if (!actor.args.falling && actor.args.mode === 3) {
          ySpeedMax = actor.args.gSpeedMax;
          ySpeed = -actor.args.gSpeed / 12;
        }
        if (actor.args.rolling) {
          ySpeed /= 4;
        }
        if (actor.args.falling && actor.args.ySpeed > 0) {
          if (deepJump || highJump) {
            ySpeed = actor.args.ySpeed;
          }
          if (actor.args.ySpeed > 0) {
            ySpeedBias += actor.args.ySpeed > 24 ? 0.5 : 0;
          } else {
            ySpeedBias += actor.args.deepJump || actor.args.ySpeed < -24 ? -0.5 : 0;
          }
        }
        if (actor.args.hangingFrom) {
          ySpeed = actor.args.ySpeed;
        }
        ySpeedBias += ySpeed / ySpeedMax;
        if (actor.args.hangingFrom) {
          ySpeedBias += 0.2;
        }
      }
      if (actor.args.climbing) {
        ySpeedBias = -0.33 * Math.sign(actor.args.gSpeed) * (Math.max(4, Math.abs(actor.args.gSpeed)) / 4) * (actor.args.mode === 1 ? -1 : 1);
      }
      this.args.yOffsetTarget += groundBias + actor.args.cameraBias - ySpeedBias;
      if (actor.args.mode === 0 && Math.abs(actor.args.groundAngle - -Math.PI / 4) < 0.001) {
        this.args.yOffsetTarget -= 0.25;
      }
      if (cameraSpeed) {
        const xOffsetDiff = this.args.xOffsetTarget - this.args.xOffset;
        const yOffsetDiff = this.args.yOffsetTarget - this.args.yOffset;
        this.args.xOffset += xOffsetDiff / cameraSpeed;
        this.args.yOffset += yOffsetDiff / cameraSpeed;
      } else {
        this.args.xOffset = this.args.xOffsetTarget;
        this.args.yOffset = this.args.yOffsetTarget;
      }
      const center = actor.rotatePoint(0, -actor.args.height / 2);
      if (actor.cofocused) {
        if (!actor.cofocusPoint) {
          actor.cofocusPoint = {};
        }
        actor.cofocusPoint.x = (actor.args.x + actor.cofocused.args.x) * 0.5;
        actor.cofocusPoint.y = (actor.args.y + actor.cofocused.args.y) * 0.5;
      } else {
        actor.cofocusPoint = null;
      }
      const actorX = center[0] + (actor.cofocused ? -actor.cofocusPoint.x : -actor.args.x);
      const actorY = center[1] + (actor.cofocused ? -actor.cofocusPoint.y : -actor.args.y);
      const xNext = actorX + center[0] + this.args.width * Number(this.args.xOffset);
      const yNext = actorY + center[1] + this.args.height * Number(this.args.yOffset);
      const xDiff = this.args.x + -xNext;
      const yDiff = this.args.y + -yNext;
      const distance = Math.hypot(xDiff, yDiff);
      const angle = Math.atan2(yDiff, xDiff);
      const maxDistance = this.cameraBound;
      const dragDistance = Math.min(maxDistance, distance);
      const snapFactor = Math.abs(dragDistance / maxDistance);
      const snapFrames = this.cameraMode === 'panning' ? 6 : 12;
      const snapSpeed = dragDistance / snapFrames;
      let x = xNext + dragDistance * Math.cos(angle);
      let y = yNext + dragDistance * Math.sin(angle);
      if (snapFactor * snapSpeed > 0.01) {
        x = x - snapFactor * Math.cos(angle) * snapSpeed;
        y = y - snapFactor * Math.sin(angle) * snapSpeed / 2;
      }
      const xMin = actor.screenLock ? -(actor.screenLock.xMin + 0) : 0;
      if (x > xMin && !this.meta.wrapX) {
        x = xMin;
      }
      if (y > 0 && !this.meta.wrapY) {
        y = 0;
      }
      const playableHeight = this.meta.deathLine || this.tileMap.mapData.height * this.tileMap.mapData.tileheight;
      const xMax = actor.screenLock ? -(actor.screenLock.xMax - this.args.width) : -(this.tileMap.mapData.width * this.tileMap.mapData.tilewidth) + this.args.width;
      const yMax = -playableHeight + this.args.height;
      if (x < xMax && !this.meta.wrapX) {
        x = xMax;
      }
      if (y < yMax && !this.meta.wrapY) {
        y = yMax;
      }
      this.args.shakeX *= -0.95;
      this.args.shakeY *= -0.95;
      this.args.shakeX = Math.abs(this.args.shakeX) < 0.1 ? 0 : this.args.shakeX;
      this.args.shakeY = Math.abs(this.args.shakeY) < 0.1 ? 0 : this.args.shakeY;
      if (actor.args.dead && !actor.args.respawning) {
        this.args.x = x + this.args.shakeX;
      } else {
        this.args.x = x + this.args.shakeX;
        this.args.y = y + this.args.shakeY;
      }
    }
  }, {
    key: "applyMotionBlur",
    value: function applyMotionBlur() {
      if (this.args.frameId % this.settings.frameSkip !== 0) {
        return;
      }
      const controlActor = this.controlActor;
      if (this.settings.blur && controlActor && this.tags.blur) {
        const xMoved = this.args.x - this.xPrev;
        const yMoved = this.args.y - this.yPrev;
        const blurDenominator = 6;
        let xBlur = Math.pow(Number(xMoved) / blurDenominator, 2);
        let yBlur = Math.pow(Number(yMoved) / blurDenominator, 2);
        const maxBlur = 32;
        xBlur = xBlur < maxBlur ? xBlur : maxBlur;
        yBlur = yBlur < maxBlur ? yBlur : maxBlur;
        let blur = Math.max(0, -1 + 0.25 * Math.hypot(xBlur, yBlur));
        const blurAngle = Math.atan2(yMoved, xMoved);
        if (this.args.frozen > 0) {
          blur = 0;
        }
        if (blur > 0.5) {
          this.tags.blurAngle.setAttribute('style', `transform:rotate(calc(1rad * ${blurAngle}))`);
          this.tags.blurAngleFg.setAttribute('style', `transform:rotate(calc(1rad * ${blurAngle}))`);
          this.tags.blurAngleCancel.setAttribute('style', `transform:rotate(calc(-1rad * ${blurAngle}))`);
          this.tags.blurAngleCancelFg.setAttribute('style', `transform:rotate(calc(-1rad * ${blurAngle}))`);
          this.tags.blur.setAttribute('stdDeviation', `${blur}, 0`);
        } else {
          this.tags.blurAngle.setAttribute('style', `transform:none;`);
          this.tags.blurAngleFg.setAttribute('style', `transform:none;`);
          this.tags.blurAngleCancel.setAttribute('style', `transform:none;`);
          this.tags.blurAngleCancelFg.setAttribute('style', `transform:none;`);
          this.tags.blur.removeAttribute('stdDeviation');
        }
        this.xPrev = this.args.x;
        this.yPrev = this.args.y;
      } else {
        this.tags.blurAngle.setAttribute('style', `transform:none;`);
        this.tags.blurAngleFg.setAttribute('style', `transform:none;`);
        this.tags.blurAngleCancel.setAttribute('style', `transform:none;`);
        this.tags.blurAngleCancelFg.setAttribute('style', `transform:none;`);
        this.tags.blur.removeAttribute('stdDeviation');
      }
    }
  }, {
    key: "updateBackground",
    value: function updateBackground() {
      if (this.args.frameId % this.settings.frameSkip !== 0) {
        return;
      }
      let controlActor = this.controlActor;
      if (controlActor && controlActor.standingOn && controlActor.standingOn.isVehicle) {
        controlActor = this.controlActor.standingOn;
      }
      this.tags.bgFilters.style({
        '--x': this.args.x,
        '--y': this.args.y
      });
      if (this.args.plot) {
        this.args.plot.args.x = Number(this.args.x).toFixed(2);
        this.args.plot.args.y = Number(this.args.y).toFixed(2);
      }
      this.tags.content.style({
        '--x': this.args.x,
        '--y': this.args.y,
        '--xPerspective': this.args.xPerspective,
        '--outlineWidth': this.settings.outline + 'px'
      });
      const xMod = this.args.x <= 0 ? this.args.x % this.args.blockSize : (-this.args.blockSize + this.args.x % this.args.blockSize) % this.args.blockSize;
      const yMod = this.args.y <= 0 ? this.args.y % this.args.blockSize : (-this.args.blockSize + this.args.y % this.args.blockSize) % this.args.blockSize;
      this.tags.background.style({
        transform: `translate( ${xMod.toFixed(2)}px, ${yMod.toFixed(2)}px )`
      });
      this.tags.foreground.style({
        transform: `translate( ${xMod.toFixed(2)}px, ${yMod.toFixed(2)}px )`
      });
      this.tags.frame.style({
        '--width': this.args.width,
        '--height': this.args.height,
        '--scale': this.args.scale
      });
    }
  }, {
    key: "updateBackdrops",
    value: function updateBackdrops() {
      if (this.args.frameId % this.settings.frameSkip !== 0) {
        return;
      }
      for (const _ref5 of this.backdrops) {
        var _ref6 = _slicedToArray(_ref5, 2);
        const backdrop = _ref6[1];
        if (!backdrop.view) {
          const args = {};
          let backdropType = '';
          for (const property of backdrop.properties) {
            if (property.name === 'backdrop') {
              backdropType = property.value;
              continue;
            }
            args[property.name] = property.value;
          }
          args.width = backdrop.width;
          args.height = backdrop.height;
          args.bX = backdrop.x;
          args.bY = backdrop.y;
          const backdropClass = _BackdropPalette.BackdropPalette[backdropType];
          if (backdropClass) {
            backdrop.view = new backdropClass(args, this);
            backdrop.view.render(this.tags.backdrops);
          }
        }
        const leftIntersect = this.args.width + -this.args.x + -backdrop.x;
        const topIntersect = this.args.height + -this.args.y + -backdrop.y;
        const rightIntersect = -(-backdrop.width + -this.args.x + -backdrop.x);
        const bottomIntersect = -(-backdrop.height + -this.args.y + -backdrop.y);
        const xMax = this.tileMap ? -(this.tileMap.mapData.width * 32) : Math.pow(2, 9);
        const yMax = this.tileMap ? -(this.tileMap.mapData.height * 32) : Math.pow(2, 9);
        backdrop.view && Object.assign(backdrop.view.args, {
          x: this.args.x,
          xOffset: -this.args.x + -backdrop.x,
          xPan: this.args.x + this.args.xPerspective * 1.5,
          xMax: xMax,
          y: this.args.y + backdrop.y,
          yMax: this.args.y + backdrop.y + -backdrop.view.stacked,
          stacked: -backdrop.view.stacked + 'px',
          frame: this.args.frameId,
          top: topIntersect,
          bottom: bottomIntersect
        });
      }
      const tWidth = this.tileMap.mapData.tilewidth;
      const tHeight = this.tileMap.mapData.tileheight;
      const mWidth = this.tileMap.mapData.width;
      const mHeight = this.tileMap.mapData.height;
      this.tileMap && this.tileMap.ready.then(() => {
        const xMax = this.tileMap ? -(mWidth * tHeight) : Math.pow(2, 9);
        const yMax = this.tileMap ? -(mHeight * tHeight) : Math.pow(2, 9);
        this.args.backdrop && Object.assign(this.args.backdrop.args, {
          x: 0,
          xPan: this.args.x + this.args.xPerspective * 1.5,
          y: this.args.y + this.args.yOffset,
          xMax: xMax !== null && xMax !== void 0 ? xMax : 0,
          yMax: yMax !== null && yMax !== void 0 ? yMax : 0,
          frame: this.args.frameId,
          stacked: -this.args.backdrop.stacked + 'px'
        });
      });
    }
  }, {
    key: "spawnFromDef",
    value: function spawnFromDef(objDef) {
      const objType = objDef.type || objDef.class || objDef.name;
      if (objDef.id > this.maxObjectId) {
        this.maxObjectId = objDef.id;
      }
      if (objType === 'particle') {
        const particle = new _Particle3d.Particle3d();
        particle.style({
          '--x': objDef.x,
          '--y': objDef.y
        });
        this.particles.add(particle.node);
      }
      if (objType === 'backdrop') {
        this.backdrops.set(objDef.id, objDef);
        return;
      }
      if (!_ObjectPalette.ObjectPalette[objType]) {
        return;
      }
      const objClass = _ObjectPalette.ObjectPalette[objType];
      const rawActor = objClass.fromDef(objDef);
      rawActor[Run] = this[Run];
      rawActor[_Bindable.Bindable.NoGetters] = true;
      const actor = _Bindable.Bindable.make(rawActor);
      actor.oid = objDef.oid || objDef.id;
      actor.name = actor.name || objDef.name;
      actor.startFrame = this.args.frameId || 0;
      this.actors.add(actor);
      return actor;
    }
  }, {
    key: "spawnInitialObjects",
    value: function spawnInitialObjects(objDefs, mapUrl) {
      const spawned = new Set();
      for (let i in objDefs) {
        this.defsByName.set(objDefs[i].name, objDefs[i]);
        this.objDefs.set(objDefs[i].id, objDefs[i]);
        const actor = this.spawnFromDef(objDefs[i]);
        if (actor) {
          actor.mapUrl = mapUrl;
          spawned.add(actor);
          if (!this.actorsByMap.has(mapUrl)) {
            this.actorsByMap.set(mapUrl, Object.create(null));
          }
          this.actorsByMap.get(mapUrl)[actor.oid] = actor;
        }
      }
      if (this.defsByName.has('player-start') && !this.args.started) {
        const start = this.defsByName.get('player-start');
        this.args.x = -start.x;
        this.args.y = -start.y;
      }
      for (const actor of this.actors.items()) {
        if (!spawned.has(actor)) {
          continue;
        }
        for (const o in actor.others) {
          actor.others[o] = this.actorsById[actor.others[o]];
        }
        if (actor.objDef && actor.objDef.properties) {
          for (const property of actor.objDef.properties) {
            if (property.type === 'object') {
              actor.otherDefs[property.name] = this.objDefs.get(property.value);
            }
          }
        }
        if (this.actorIsOnScreen(actor)) {
          actor.args.display = actor.defaultDisplay || null;
          actor.render(this.tags.actors);
        } else {
          actor.args.display = 'none';
          actor.render();
          actor.detach();
        }
        if (actor.onAttach && actor.onAttach() === false || actor.args.hidden) {
          actor.args.display = 'none';
          actor.detach();
        }
        if (actor.controllable) {
          actor.args.display = actor.defaultDisplay || null;
        }
      }
      for (const actor of this.actors.items()) {
        actor.initialize && actor.initialize();
        actor.vizi = false;
      }
    }
  }, {
    key: "appendMap",
    value: function appendMap(url, x, y) {
      this.maps.set(url, {
        x: x,
        y: y
      });
      this.args.loadingMap = true;
      return this.tileMap.preloadMap(url).then(mapData => {
        const newBottom = y + mapData.height;
        if (newBottom > this.tileMap.mapData.height) {
          const yDiff = newBottom - this.tileMap.mapData.height;
          this.tileMap.resize(this.tileMap.mapData.width, newBottom);
          this.offsetMap(0, yDiff);
          y = 0;
        }
        return this.tileMap.append(url, x, y, this.maxObjectId);
      }).then(_ref7 => {
        let defs = _ref7.defs,
          data = _ref7.data;
        this.currentMap = url;
        const zoneState = this.getZoneState();
        this.controlActor.args.emblems.splice(0);
        const maxObjectId = this.maxObjectId;
        let newMaxObjectId = 0;
        for (const def of defs) {
          def.oid = def.id;
          def.id += maxObjectId;
          def.x += x * this.tileMap.mapData.tilewidth;
          def.y += y * this.tileMap.mapData.tileheight;
          newMaxObjectId = Math.max(newMaxObjectId, def.id);
          if (!def.properties) {
            continue;
          }
          for (const prop of def.properties) {
            if (prop.type === 'object') {
              prop.value += maxObjectId;
            }
          }
        }
        const defList = Object.create(null);
        [...defs].forEach(d => defList[d.oid] = d);
        this.defsByMap.set(this.currentMap, defList);
        this.maxObjectId = newMaxObjectId;
        for (const prop of Object.values(data.properties)) {
          const name = prop.name.replace(/-/g, '_');
          this.meta[name] = prop.value;
        }
        const spawn = this.spawnInitialObjects(defs, url);
        const newStart = this.defsByName.get('player-start');
        if (newStart) {
          this.storeCheckpoint(this.controlActor.args.canonical, newStart.oid || newStart.args.id);
        }
        for (const emblemId of zoneState.emblems) {
          const emblem = this.actorsByMap.get(this.currentMap)[emblemId];
          if (!emblem || emblem.mapUrl !== url) {
            continue;
          }
          emblem.existing = 'existing';
          if (this.controlActor && !this.controlActor.args.emblems.includes(emblem)) {
            this.controlActor.args.emblems.push(emblem);
          }
        }
        return spawn;
      }).finally(() => this.args.loadingMap = false);
    }
  }, {
    key: "offsetMap",
    value: function offsetMap(x, y) {
      for (const actor of this.actors.items()) {
        actor.args.x += x * this.tileMap.blockSize;
        actor.args.y += y * this.tileMap.blockSize;
        this.setColCell(actor);
      }
      this.args.x -= x * this.tileMap.blockSize;
      this.args.y -= y * this.tileMap.blockSize;
      if (this.meta.deathLine) {
        this.meta.deathLine += y * this.tileMap.blockSize;
      }
      this.tileMap.offset(x, y);
    }
  }, {
    key: "populateMap",
    value: function populateMap() {
      if (this.args.populated) {
        return;
      }
      const mapWidth = this.tileMap.mapData.width * 32 + 64;
      const mapHeight = this.tileMap.mapData.height * 32 + 64;

      // this.quadCell = new QuadCell(
      // 	this.args.width * 2
      // 	, {x: mapWidth/2, y: mapHeight/2}
      // 	, {x: mapWidth, y: mapHeight}
      // );

      this.args.populated = true;
      this.defsByName = new Map();
      this.objDefs = new Map();
      for (const _ref8 of this.backdrops) {
        var _ref9 = _slicedToArray(_ref8, 2);
        const id = _ref9[0];
        const backdrop = _ref9[1];
        if (backdrop.view) {
          backdrop.view.remove();
          backdrop.view = undefined;
        }
        this.backdrops.delete(id);
      }
      for (const particle of Object.entries(this.particles.list)) {
        if (particle) {
          this.particles.remove(particle);
        }
      }
      const selectedChar = String(this.args.selectedChar || _Router.Router.query.char || 'Sonic').toLowerCase();
      const charClass = _ObjectPalette.ObjectPalette[selectedChar] || _Sonic.Sonic;
      const character = new charClass({
        name: selectedChar
      }, this);

      // const objDefs = this.tileMap.getObjectDefs();

      for (const _ref10 of this.defsByMap) {
        var _ref11 = _slicedToArray(_ref10, 2);
        const mapUrl = _ref11[0];
        const objDefs = _ref11[1];
        this.spawnInitialObjects(objDefs, mapUrl);
      }
      if (!this.args.networked) {
        var _startDef$z;
        let startType = 'player-start';
        if (!character.canRoll && this.defsByName.has('wide-player-start')) {
          startType = 'wide-player-start';
        }
        const startDef = this.defsByName.get(startType);
        character.args.x = startDef ? startDef.x : mapWidth / 2;
        character.args.y = startDef ? startDef.y : mapHeight / 2;
        character.args.z = startDef ? (_startDef$z = startDef.z) !== null && _startDef$z !== void 0 ? _startDef$z : 10 : 10;
        character.args.animation = 'dropping';
        const followerChar = String(this.args.followerChar || _Router.Router.query.follower || '').toLowerCase();
        if (followerChar) {
          const charClass = _ObjectPalette.ObjectPalette[followerChar] || _Tails.Tails;
          const follower = new charClass({
            following: true,
            name: followerChar,
            x: character.args.x,
            y: character.args.y,
            z: character.args.z - 1
          }, this);
          this.spawn.add({
            object: follower
          });
          this.auras.add(follower);
          this.actors.add(follower);
          character.follower = follower;
        }
        this.spawn.add({
          object: character
        });
        this.auras.add(character);
        this.actors.add(character);
        if (startDef && startDef.properties) {
          for (const property of startDef.properties) {
            character.args[property.name] = property.value;
          }
        }
        this.nextControl = character;
      }
      this.onFrameOut(1, () => {
        if (character.follower) {
          character.follower.args.x = character.args.x;
          character.follower.args.y = character.args.y;
        }
      });
      if (!this.replayStart) for (const _ref12 of Object.entries(this.actors.list)) {
        var _ref13 = _slicedToArray(_ref12, 2);
        const id = _ref13[0];
        const actor = _ref13[1];
        if (!actor || actor.args.npc) {
          continue;
        }
        if (!actor.controllable) {
          continue;
        }
        const position = this.getCheckpoint(actor.args.canonical);
        if (position && position.checkpointId) {
          const checkpointDef = this.defsByMap.get(this.currentMap)[position.checkpointId];
          const checkpointObj = this.actorsByMap.get(this.currentMap)[position.checkpointId];
          if (checkpointDef) {
            actor.args.x = checkpointDef.x;
            actor.args.y = checkpointDef.y;
          }
          if (checkpointObj) {
            checkpointObj.args.active = true;
          }
        }
      }
    }
  }, {
    key: "actorIsOnScreen",
    value: function actorIsOnScreen(actor) {
      let margin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 512;
      if (!actor) {
        return;
      }
      const width = this.args.width;
      const height = this.args.height;
      const camLeft = -this.args.x + -16 + -margin;
      const camRight = -this.args.x + 16 + margin + width;
      const camTop = -this.args.y - margin;
      const camBottom = -this.args.y + height + margin * 0.5;
      const actorWidth = actor.args.width;
      const actorTop = actor.args.y - actor.args.height;
      const actorLeft = actor.args.x - (actor.isRegion ? 0 : actorWidth / 2);
      const actorRight = actor.args.x + (actor.isRegion ? actorWidth : actorWidth / 2);
      if (camLeft > actorRight || actorLeft > camRight) {
        return false;
      }
      if (camTop > actor.args.y || actorTop > camBottom) {
        return false;
      }
      return true;
    }
  }, {
    key: "spawnActors",
    value: function spawnActors() {
      const actorDoc = new DocumentFragment();
      const regionDoc = new DocumentFragment();
      let actorSpawned = false;
      let regionSpawned = false;
      for (const spawn of this.spawn) {
        if (spawn.frame) {
          if (spawn.frame <= this.args.frameId) {
            this.spawn.delete(spawn);
            spawn.object[_Bindable.Bindable.NoGetters] = true;
            spawn.object[Run] = this[Run];
            spawn.object.startFrame = this.args.frameId || 0;
            spawn.object.args.id = ++this.maxObjectId;
            this.actors.add(_Bindable.Bindable.make(spawn.object));
            const isRegion = spawn.object instanceof _Region.Region;
            const doc = actorDoc;
            spawn.object.render(doc);
            spawn.object.onRendered();
            if (spawn.object.onAttach && spawn.object.onAttach() === false) {
              if (!spawn.object.args.hidden) {
                spawn.object.detach();
              }
            }
            this.setColCell(spawn.object);
            actorSpawned = true;
            spawn.object.initialize && spawn.object.initialize();
          }
        } else {
          this.spawn.delete(spawn);
          spawn.object[_Bindable.Bindable.NoGetters] = true;
          spawn.object[Run] = this[Run];
          spawn.object.startFrame = this.args.frameId || 0;
          spawn.object.args.id = ++this.maxObjectId;
          this.actors.add(_Bindable.Bindable.make(spawn.object));
          spawn.object.render(actorDoc);
          spawn.object.onRendered();
          spawn.object.onAttached && spawn.object.onAttached();
          if (spawn.object.onAttach && spawn.object.onAttach() === false) {
            spawn.object.detach();
          }
          actorSpawned = true;
          spawn.object.initialize && spawn.object.initialize();
        }
      }
      if (actorSpawned) {
        this.tags.actors.append(actorDoc);
      }
      if (regionSpawned) {
        this.tags.actors.append(regionDoc);
      }
    }
  }, {
    key: "actorUpdateStart",
    value: function actorUpdateStart(actor) {
      if (this.updateStarted.has(actor)) {
        return;
      }
      this.updateStarted.add(actor);
      actor.updateStart();
      if (actor.colliding) {
        actor.colliding = false;
      }
      actor.moved = false;
    }
  }, {
    key: "actorUpdate",
    value: function actorUpdate(actor) {
      if (this.updated.has(actor)) {
        return;
      }
      this.updated.add(actor);
      actor.update();
    }
  }, {
    key: "actorUpdateEnd",
    value: function actorUpdateEnd(actor) {
      if (this.updateEnded.has(actor)) {
        return;
      }
      this.updateEnded.add(actor);
      actor.args.colliding = actor.colliding;
      actor.updateEnd();
      if (actor.moved && !actor.removed) {
        this.setColCell(actor);
      }

      // this.quadCell.remove(actor, actor.args);

      // this.quadCell.insert(actor, actor.args);

      // this.quadCell.insert(actor, {x: actor.args.x - actor.args.width / 2, y: actor.args.y});
      // this.quadCell.insert(actor, {x: actor.args.x + actor.args.width / 2, y: actor.args.y});
    }
  }, {
    key: "nearbyActors",
    value: function nearbyActors(x, y) {
      let regions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      const nearbyCells = this.getNearbyColCells(x, y);
      const result = new Set();
      for (const actors of nearbyCells) {
        for (const actor of actors) {
          if (regions && !actor.isRegion) {
            continue;
          }
          result.add(actor);
        }
      }
      return result;
    }
  }, {
    key: "update",
    value: function update() {
      const frameId = this.args.frameId - this.args.startFrameId;
      if (this.zoneScript && this.args.started && this.args.paused === false) {
        this.zoneScript.update(frameId, this);
      }
      if (this.args.started && this.meta.bgm && frameId === (this.meta.bgm_delay || 1)) {
        _Bgm.Bgm.play(this.meta.bgm, {
          loop: true
        });
      }
      if (this.socket && this.args.frameId % 120 === 0) {
        this.socket.publish('keepalive', '');
      }
      if (this.args.loadingMap) {
        return;
      }
      if (this.args.paused > 0) {
        this.args.paused--;
      }
      if (this.args.frozen > 0) {
        this.args.frozen--;
      }
      if (this.tallyBoard && !this.args.paused) {
        this.tallyBoard.update(this);
        this.args.score.args.value = String(this.controlActor.args.score).padStart(4, ' ');
        if (!this.tallyBoard.done) {
          this.args.frozen = 1;
        }
      }
      const controller = this.controlActor ? this.controlActor.controller : this.controller;
      for (const b in controller.buttons) {
        if (controller.buttonIsMapped(b)) {
          continue;
        }
        if (controller.buttons[b].active && controller.buttons[b].time === 1) {
          this.debugSeq.check(`Button${b}`);
          this.konamiSeqA.check(`Button${b}`);
          this.konamiSeqB.check(`Button${b}`);
        }
      }
      if (this.args.frameId % 600 === 0) {
        ga('set', 'metric1', this.args.frameId / 60);
        if (typeof ga === 'function') {
          ga('send', 'event', {
            eventCategory: 'fps-check',
            eventAction: `fps-check::${navigator.platform}::cores_${navigator.hardwareConcurrency}`,
            eventLabel: `${this.args.actName}`,
            eventValue: Math.trunc(this.args.fps),
            Value: Math.trunc(this.args.fps)
          });
        }
      }
      if (!this.args.started) {
        this.startTime = Date.now();
        if (controller) {
          this.takeInput(controller);
          if (this.args.titlecard) {
            this.args.titlecard.input(controller);
          }
        }
      }
      if (this.args.paused !== false) {
        this.takeInput(controller);
        this.args.pauseMenu.input(controller);
      }
      if (this.args.paused === false || this.args.paused > 0 || this.args.networked) {
        this.callFrameOuts();
        this.callRenderedFrameOut();
        this.callFrameIntervals();
        for (const _ref14 of this.timers) {
          var _ref15 = _slicedToArray(_ref14, 2);
          const key = _ref15[0];
          const timer = _ref15[1];
          timer.update();
        }
        this.args.lastFrameId = this.args.frameId;
        if (this.args.cutScene) {
          this.args.startFrameId++;
          this.args.showHud = false;
        } else if (this.settings.showHud) {
          this.args.showHud = true;
        }
        if (!this.args.debugEditMode) {
          this.args.frameId++;
        }
        if (this.args.debugOsd) {
          this.args.frame.args.value = this.args.frameId;
        }
      }
      if (!this.args.networked && this.args.started && this.args.paused !== false && this.args.paused <= 0) {
        return;
      }
      if (!this.args.networked && this.args.frozen > 0) {
        this.args.startFrameId++;
        this.args.blur = 0;
        return;
      }
      if (!this.args.started) {
        return;
      }
      if (this.tileMap && this.tileMap.mapData) {
        this.updateBackdrops();
      }
      for (const _ref16 of this.willDetach) {
        var _ref17 = _slicedToArray(_ref16, 2);
        const detachee = _ref17[0];
        const detacher = _ref17[1];
        this.willDetach.delete(detachee);
        detacher();
      }
      if (!Number(this.args.rings.args.value)) {
        this.args.ringLabel.args.color = 'red-alert';
      } else {
        this.args.ringLabel.args.color = 'yellow';
      }
      this.args.fpsSprite.args.value = Number(this.args.fps).toFixed(0).padStart(2, '0');
      const time = (this.args.frameId - this.args.actStartFrameId) / 60;
      let minutes = String(Math.trunc(Math.abs(time) / 60)).padStart(2, '0');
      let seconds = String(Math.trunc(Math.abs(time) % 60)).padStart(2, '0');
      const neg = time < 0 ? '-' : '';
      if (neg) {
        minutes = Number(minutes);
      }
      this.args.timer.args.value = `${neg}${minutes}:${seconds}`;
      if (this.dontSwitch > 0) {
        this.dontSwitch--;
      }
      if (this.dontSwitch < 0) {
        this.dontSwitch = 0;
      }
      this.args.rippleFrame = this.args.frameId % 128;
      this.args.displaceWater = this.args.frameId % 128;
      this[ActorPointCache].clear();
      if (!this.args.isReplaying && !this.args.isRecording) {
        this.args.demoIndicator = null;
      }
      this.updateBackground();
      if (this.controlActor) {
        if (this.args.isReplaying) {
          const keyboard = _Keyboard.Keyboard.get();
          if (keyboard.getKeyCode('NumpadAdd') > 0) {
            this.focus();
            this.args.paused = 1;
            this.args.pauseMenu.args.hideMenu = 'pause-menu-hide';
          }
          if (!this.args.demoIndicator) {
            this.args.demoIndicator = new _CharacterString.CharacterString({
              value: '▶ PLAY',
              color: 'green'
            });
          }
          this.onFrameOut(60, () => {
            if (this.args.focusMe.args.hide) {
              this.args.focusMe.args.hide = 'hide hidden';
            }
          });
          const frameId = this.args.frameId - this.args.startFrameId;
          if (frameId < this.maxReplayFrame) {
            const actor = this.controlActor;
            this.lastInput = this.lastInput || {};
            this.lastInput.axes = this.lastInput.axes || {};
            this.lastInput.buttons = this.lastInput.buttons || {};
            if (this.replayFrames.has(frameId)) {
              const _this$replayFrames$ge = this.replayFrames.get(frameId),
                _this$replayFrames$ge2 = _slicedToArray(_this$replayFrames$ge, 3),
                _ = _this$replayFrames$ge2[0],
                input = _this$replayFrames$ge2[1],
                args = _this$replayFrames$ge2[2];
              const frame = {
                frame: _,
                input: input,
                args: args
              };
              if (frame.args) {
                for (const actorId in frame.args) {
                  Object.assign(actor.args, frame.args[actorId]);
                  actor.args.ignore = 0;
                  actor.args.respawning = false;
                  actor.args.dead = false;
                  actor.noClip = false;
                }
              }
              if (frame.input && frame.input.buttons) {
                delete frame.input.buttons[9];
              }
              if (frame.input) {
                Object.assign(this.lastInput.axes, frame.input.axes || {});
                Object.assign(this.lastInput.buttons, frame.input.buttons || {});
                actor.controller.replay(this.lastInput);
                actor.readInput();

                // console.log(frameId, JSON.stringify(this.lastInput));
              } else {
                actor.controller.replay(this.lastInput);
                actor.readInput();
              }
            } else {
              // console.log(frameId, JSON.stringify(this.lastInput));
              actor.controller.replay(this.lastInput);
              actor.readInput();
            }
            this.args.hasRecording = true;
            if (this.args.replayBanners && this.args.frameId - this.args.startFrameId < 5) {
              this.args.topLine.args.hide = 'hide hidden';
              this.args.status.args.hide = 'hide hidden';
              this.args.focusMe.args.hide = 'hide hidden';
              this.onTimeout(1, () => {
                // this.args.topLine.args.value = '    i cant believe its not canvas!    ';
                // this.args.topLine.args.hide = '';

                // this.args.status.args.value = '    click here to exit demo.    ';
                // this.args.status.args.hide = '';
              });
            }
          } else {
            this.args.topLine.args.hide = 'hide hidden';
            this.args.status.args.hide = 'hide hidden';
            this.replayFrames = new Map();
            this.replayOffset = 0;
            this.replayStart = null;
            // this.replay = null;

            this.args.isReplaying = false;
            this.args._isRecording = false;
            this.onFrameOut(30, () => this.quit(this.args.replayQuickExit ? 2 : 1));
          }
        } else {
          if (this.gamepad) {
            this.args.focusMe.args.hide = 'hide hidden';
          }
          this.controlActor.controller && this.takeInput(this.controlActor.controller);
          if (!this.args.cutScene) {
            this.controlActor.readInput();
          }
        }
      }
      if (this.controlActor && this.controlActor.args.respawning && !this.args.isReplaying) {
        this.replay = null;
      }
      if (!this.args.isReplaying && this.controlActor && this.controlActor.args.dead) {
        this.onFrameOut(30, () => {
          if (this.replayFrames.size) {
            this.saveReplay('#804000').catch(() => {});
            this.replayFrames = new Map();
          }
        });
      }
      this.collisions = new Map();
      this.updateStarted.clear();
      this.updated.clear();
      if (this.controlActor) {
        this.controlActor.setCameraMode();
      }
      this.updateEnded.clear();
      _Layer.Layer.updateCount = 0;
      for (const layer of [...this.args.layers, ...this.args.fgLayers]) {
        const xDir = Math.sign(layer.x - this.args.x);
        const yDir = Math.sign(layer.y - this.args.y);
        layer.x = this.args.x;
        layer.y = this.args.y;
        layer.update(this.tileMap, xDir, yDir);
      }

      // console.log(Layer.updateCount);

      for (const layer of [...this.args.layers, ...this.args.fgLayers]) {
        layer.move();
      }
      if (this.args.running && !this.args.debugEditMode) {
        const updatable = new Set();
        for (const region of this.regions) {
          if (!this.actorIsOnScreen(region, 768)) {
            continue;
          }
          updatable.add(region);
        }
        for (const actor of this.auras) {
          if (!actor || actor.removed) {
            this.auras.delete(actor);
            continue;
          }
          if (actor !== this.controlActor) {
            updatable.add(actor);
          }
          const nearbyActors = this.nearbyActors(actor.args.x, actor.args.y);
          for (const actor of nearbyActors) {
            if (actor !== this.controlActor && !actor.removed) {
              updatable.add(actor);
            }
          }
        }
        for (const actor of updatable) {
          if (actor[Run] === this[Run] && !actor.removed) {
            this.actorUpdateStart(actor);
          }
        }
        if (this.controlActor) {
          if (this.controlActor[Run] === this[Run]) {
            this.actorUpdateStart(this.controlActor);
          }
        }
        for (const actor of updatable) {
          if (actor[Run] === this[Run] && !actor.removed) {
            this.actorUpdate(actor);
          }
        }
        if (this.controlActor) {
          if (this.controlActor[Run] === this[Run]) {
            this.actorUpdate(this.controlActor);
          }
        }
        for (const actor of updatable) {
          if (actor[Run] === this[Run] && !actor.removed) {
            this.actorUpdateEnd(actor);
          }
        }
        if (this.controlActor) {
          if (this.controlActor[Run] === this[Run]) {
            this.actorUpdateEnd(this.controlActor);
          }
        }
        for (const actor of updatable) {
          if (actor.moved && !actor.removed && actor[Run] === this[Run]) {
            this.setColCell(actor);
          }
        }
        if (this.controlActor) {
          if (this.controlActor[Run] === this[Run]) {
            this.setColCell(this.controlActor);
          }
        }
        if (this.collisions) {
          for (const _ref18 of this.collisions) {
            var _ref19 = _slicedToArray(_ref18, 2);
            const collider = _ref19[0];
            const collidees = _ref19[1];
            for (const _ref20 of collidees) {
              var _ref21 = _slicedToArray(_ref20, 2);
              const collidee = _ref21[0];
              const type = _ref21[1];
              if (!collidee) {
                continue;
              }
              collidee.pause(false);
            }
          }
        }
        if (this.controlActor) {
          this.args.score.args.value = String(this.controlActor.args.score).padStart(4, ' ');
          this.args.rings.args.value = String(this.controlActor.args.rings).padStart(4, ' ');
          this.args.emblems = this.controlActor.args.emblems;
          this.args.hasRings = !!this.controlActor.args.rings;
          this.args.hasEmeralds = !!this.controlActor.args.emeralds;
          this.args.char.args.value = this.controlActor.args.name;
          this.args.charName = this.controlActor.args.name;
          if (this.args.debugOsd) {
            this.args.xPos.args.value = Number(this.controlActor.args.x).toFixed(3);
            this.args.yPos.args.value = Number(this.controlActor.args.y).toFixed(3);
            this.args.layer.args.value = Number(this.controlActor.args.layer);
            this.args.ground.args.value = this.controlActor.args.landed;
            this.args.gSpeed.args.value = Number(this.controlActor.args.gSpeed).toFixed(3);
            this.args.xSpeed.args.value = Number(this.controlActor.args.xSpeed).toFixed(3);
            this.args.ySpeed.args.value = Number(this.controlActor.args.ySpeed).toFixed(3);
            this.args.angle.args.value = (Math.round(this.controlActor.args.groundAngle * 1000) / 1000).toFixed(3);
            this.args.airAngle.args.value = (Math.round(this.controlActor.args.airAngle * 1000) / 1000).toFixed(3);
            this.args.actorCount.args.value = this.actors.size;
            this.args.regionCount.args.value = this.regions.size;
            this.args.ignore.args.value = this.controlActor.args.ignore;
            const modes = ['FLOOR (0)', 'L-WALL (1)', 'CEILING (2)', 'R-WALL (3)'];
            this.args.mode.args.value = modes[Math.floor(this.controlActor.args.mode)] || Math.floor(this.controlActor.args.mode);
            this.args.cameraMode.args.value = this.controlActor.args.cameraMode;
          }
        }
      } else if (this.args.running && this.args.debugEditMode) {
        if (this.controlActor) {
          this.controlActor.args.x += controller.axes[0].magnitude * 4;
          this.controlActor.args.y += controller.axes[1].magnitude * 4;
          this.controlActor.args.respawning = false;
          this.controlActor.args.dead = false;
          this.controlActor.noClip = false;
          this.controlActor.args.xSpeed = 0;
          this.controlActor.args.ySpeed = 0;
          this.controlActor.args.gSpeed = 0;
        }
      }
      const width = this.args.width;
      const height = this.args.height;
      const margin = 16;
      const camLeft = -this.args.x + -16 + -margin;
      const camRight = -this.args.x + width + -16 + margin;
      const camTop = -this.args.y - margin;
      const camBottom = -this.args.y + height + margin;
      const inAuras = new WeakSet();
      if (this.controlActor) {
        const actorDoc = new DocumentFragment();
        const regionDoc = new DocumentFragment();
        let wakeActors = false;
        let wakeRegions = false;
        let focusedActor = this.controlActor;
        if (this.controlActor.focused) {
          focusedActor = this.controlActor.focused;
        }
        const nearbyActors = this.nearbyActors(focusedActor.args.x, focusedActor.args.y) || [];
        const nearbyRegions = this.nearbyActors(focusedActor.args.x, focusedActor.args.y, true) || [];
        for (const actorList of [nearbyActors, nearbyRegions]) {
          for (const actor of actorList) {
            if (actor[Run] !== this[Run]) {
              continue;
            }
            if (!actor.args.hidden && !actor.nodes.length) {
              actor.render(this.tags.actors);
            }
            const actorIsOnScreen = this.actorIsOnScreen(actor);
            if (actorIsOnScreen && !(actor instanceof _LayerSwitch.LayerSwitch)) {
              actor.args.display = actor.defaultDisplay || null;
              if (!actor.vizi) {
                if (!actor.nodes.length) {
                  if (actor.onAttach && actor.onAttach() === false) {
                    actor.detach();
                  }
                }
                if (!actor.args.hidden) {
                  if (actor instanceof _Region.Region) {
                    actor.nodes.map(n => actorDoc.append(n));
                    wakeActors = true;
                  } else {
                    actor.nodes.map(n => actorDoc.append(n));
                    wakeActors = true;
                  }
                }
                actor.wakeUp();
              }
              this.willDetach.delete(actor);
              this.visible.add(actor);
              if (!actor.args.hidden) {
                actor.vizi = true;
              }
            }
            inAuras.add(actor);
            this.recent.add(actor);
          }
        }
        for (const actor of new Set([...this.recent, ...this.visible])) {
          if (actor.removed) {
            this.visible.delete(actor);
            this.recent.delete(actor);
            continue;
          }
          if (actor[Run] !== this[Run]) {
            this.recent.delete(actor);
            continue;
          }
          const actorIsOnScreen = !actor.args.hidden && this.actorIsOnScreen(actor);
          if (actor.vizi && !actorIsOnScreen) {
            this.willDetach.set(actor, () => {
              actor.sleep();
              actor.args.display = 'none';
              actor.detach();
              this.visible.delete(actor);
              actor.vizi = false;
              actor.willhide = null;
              this.willDetach.delete(actor);
            });
            this.recent.delete(actor);
          }
        }
        if (wakeActors) {
          this.tags.actors.append(actorDoc);
        }
        if (wakeRegions) {
          this.tags.actors.append(regionDoc);
        }
      }
      if (this.nextControl) {
        !this.args.networked && this.auras.clear();
        this.controlActor && this.controlActor.sprite && this.controlActor.sprite.parentNode && this.controlActor.sprite.parentNode.classList.remove('actor-selected');
        if (this.controlActor) {
          this.controlActor.args.selected = false;
        }
        this.controlActor = this.nextControl;
        this.controlActor.args.selected = true;
        this.auras.add(this.controlActor);
        this.controlActor.args.display = this.controlActor.defaultDisplay || null;
        this.controlActor.nodes.map(n => this.tags.actors.append(n));
        this.visible.add(this.controlActor);
        this.controlActor.vizi = true;
        this.args.maxSpeed = null;
        this.nextControl = null;
      }
      this.updated.forEach(actor => {
        if (actor.args.standingLayer) {
          const groundShift = actor.args.standingLayer.offsetXChanged;
          if (groundShift) {
            const spaceLeft = actor.bMap('scanForward', groundShift).get(_Platformer2.Platformer);
            if (spaceLeft === false) {
              actor.args.x += groundShift || 0;
            } else {
              actor.args.x += spaceLeft * Math.sign(groundShift);
            }
          }
          actor.args.y += actor.args.standingLayer.offsetYChanged || 0;
        }
      });
      if (this.controlActor) {
        this.moveCamera();
        this.applyMotionBlur();
        this.args.popTopLine = this.args.popTopLine || this.getUnusedCharString({
          color: 'yellow'
        });
        this.args.popBottomLine = this.args.popBottomLine || this.getUnusedCharString({
          color: 'yellow'
        });
        let multiply = 0;
        let base = 0;
        let showCombo = this.controlActor.args.popChain.length > 1;
        let len = 0;
        if (this.controlActor.args.popChain.length) {
          if (this.controlActor.args.popChain[0].special) {
            showCombo = true;
          }
          len = this.controlActor.args.popChain.length;
          const cutOff = Math.max(0, len - 4);
          if (!len) {
            for (const item of this.args.combo) {
              // this.pooledCharStringDetached(item.score);
              this.pooledCharStringDetached(item.label);
            }
          }
          let pulse = false;
          for (let i = 0; i < len; i++) {
            const pop = this.controlActor.args.popChain[i];
            multiply += pop.multiplier;
            base += pop.points;
            const c = i + -cutOff;
            if (i >= cutOff) {
              this.args.combo[c] = this.args.combo[c] || {
                label: this.getUnusedCharString(),
                score: null,
                index: i
              };
              this.args.combo[c].label = this.args.combo[c].label || this.getUnusedCharString();
              if (this.args.combo[c].index !== i) {
                pulse = true;
              }

              // this.args.combo[c].score.args.value = pop.points;
              this.args.combo[c].label.args.value = String(pop.label).replace(/-/g, ' ');
              this.args.combo[c].index = i;
              if (pop.color) {
                this.args.combo[c].label.args.color = pop.color;
              } else if (pop.multiplier > 1) {
                this.args.combo[c].label.args.color = 'orange';
              } else {
                this.args.combo[c].label.args.color = 'white';
              }
            } else if (i < cutOff && this.args.combo[c]) {
              // this.pooledCharStringDetached(this.args.combo[c].score);
              this.pooledCharStringDetached(this.args.combo[c].label);
            }
          }
          if (pulse) {
            const last = this.args.combo[this.args.combo.length + -1];
            last.label.args.classes = 'pulse';
            this.onFrameOut(1, () => last.label.args.classes = '');
            // this.onFrameOut(30, () => last.label.args.classes = '');
          }

          this.args.combo.length = Math.min(4, Math.max(0, -cutOff + this.controlActor.args.popChain.length));
        } else {
          for (const item of this.args.combo) {
            // this.pooledCharStringDetached(item.score);
            this.pooledCharStringDetached(item.label);
          }
          this.args.combo.length = 0;
        }
        this.args.popTopLine.args.value = base + ' x ' + multiply;
        this.args.popBottomLine.args.value = len > 4 ? '+' + (len - 4) : '';
        this.args.showCombo = showCombo;
      }
      if (this.args.networked && this.controlActor) {
        const netState = {
          frame: this.serializePlayer()
        };
        if (this.args.playerId === 1) {
          this.server.send(JSON.stringify(netState));
        } else if (this.args.playerId === 2) {
          this.client.send(JSON.stringify(netState));
        }
      }
      if (this.socket && this.args.publishTime <= 0) {
        this.packPlayerFrame().arrayBuffer().then(buffer => this.socket.publish(0, buffer));
        this.args.publishTime = 10;
      } else {
        this.args.publishTime--;
      }
      this.spawnActors();
      if (this.args.fps < 30) {
        this.settings.frameSkip = 3;
      } else if (this.args.fps < 20) {
        this.settings.frameSkip = 2;
      } else {
        this.settings.frameSkip = 1;
      }
      for (const b in this.mouseState.buttons) {
        if (this.mouseState.buttons[b]) {
          this.mouseState.buttons[b]++;
        }
      }
    }
  }, {
    key: "populateCharStringPool",
    value: function populateCharStringPool() {
      if (!this.charStringPool) {
        this.charStringPool = new Set();
        this.charStringOpen = new Set();
        for (let i = 0; i < 30; i++) {
          const charString = _Bindable.Bindable.make(new _CharacterString.CharacterString({
            value: ' '.repeat(10)
          }));
          charString.preserve = true;
          this.charStringPool.add(charString);
          this.charStringOpen.add(charString);
        }
      }
    }
  }, {
    key: "getUnusedCharString",
    value: function getUnusedCharString() {
      let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this.populateCharStringPool();
      for (const charString of this.charStringOpen) {
        this.charStringOpen.delete(charString);
        Object.assign(charString.args, args);
        if (!args.value) {
          charString.args.value = '';
        }
        return charString;
      }
    }
  }, {
    key: "pooledCharStringDetached",
    value: function pooledCharStringDetached(charString) {
      this.charStringOpen.add(charString);
    }
  }, {
    key: "resetCharStringPool",
    value: function resetCharStringPool() {
      this.populateCharStringPool();
      for (const charString of this.charStringPool) {
        this.charStringOpen.add(charString);
      }
    }
  }, {
    key: "click",
    value: function click(event) {
      if (this.args.isReplaying) {
        this.controlActor && this.controlActor.controller.zero();
        this.stop();
        this.args.topLine.args.hide = 'hide hidden';
        this.args.status.args.hide = 'hide hidden';
        this.quit(this.args.replayQuickExit ? 2 : 1);
      }
    }
  }, {
    key: "regionsAtPoint",
    value: function regionsAtPoint(x, y) {
      const regions = new Set();
      for (const region of this.nearbyActors(x, y, true)) {
        if (region[Run] !== this[Run]) {
          this.regions.delete(region);
          continue;
        }
        const regionArgs = region.args;
        const regionX = regionArgs.x;
        const regionY = regionArgs.y;
        const width = regionArgs.width;
        const height = regionArgs.height;
        const offset = Math.floor(width / 2);
        const left = regionX;
        const right = regionX + width;
        const top = regionY - height;
        const bottom = regionY;
        if (x >= left && right > x) {
          if (bottom >= y && y > top) {
            regions.add(region);
          }
        }
      }
      return regions;
    }
  }, {
    key: "actorsAtPoint",
    value: function actorsAtPoint(x, y) {
      let w = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      let h = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      let ghosts = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
      // x = Math.trunc(x);

      // const cacheKey = x+'::'+y+'::'+w+'::'+h;
      // const actorPointCache = this[ActorPointCache];

      // if(actorPointCache.has(cacheKey))
      // {
      // 	return actorPointCache.get(cacheKey);
      // }

      const nearbyActors = this.nearbyActors(x, y);
      if (!nearbyActors.size) {
        return [];
      }
      const actors = new Set();
      for (const actor of nearbyActors) {
        if (!ghosts && actor.isGhost) {
          continue;
        }
        const myRadius = Math.max(Math.floor(w / 2), 0);
        const myLeft = x - myRadius;
        const myRight = x + myRadius;
        const actorArgs = actor.args;
        const actorX = actorArgs.x;
        const width = actorArgs.width;
        const offset = width / 2;
        const isRegion = actor.isRegion;
        const otherLeft = actorX - (isRegion ? 0 : offset);
        const otherRight = actorX + (isRegion ? width : offset);

        // if(myRight < otherLeft || otherRight <= myLeft)
        if (myRight < otherLeft || otherRight < myLeft) {
          continue;
        }
        const myTop = y - Math.max(h, 0);
        const myBottom = y;
        const actorY = actorArgs.y;
        const height = actorArgs.height;
        const otherTop = actorY - height;
        const otherBottom = actorY;
        if (otherBottom < myTop || myBottom < otherTop) {
          continue;
        }
        actors.add(actor);
      }
      const list = Array.from(actors.values());

      // actorPointCache.set(cacheKey, list);

      return list;
    }
  }, {
    key: "actorsAtLine",
    value: function actorsAtLine(x1, y1, x2, y2) {
      const testActors = new Set();
      const cellX1 = Math.floor(x1 / this.colCellDiv);
      const cellY1 = Math.floor(y1 / this.colCellDiv);
      const cellX2 = Math.floor(x2 / this.colCellDiv);
      const cellY2 = Math.floor(y2 / this.colCellDiv);
      for (let x = 0; x < 3 + Math.abs(cellX1 + -cellX2); x++) for (let y = 0; y < 3 + Math.abs(cellY1 + -cellY2); y++) {
        const name = x + Math.min(cellX1, cellX2) + -1 + ':' + (y + Math.min(cellY1, cellY2) + -1);
        if (!this.colCells.has(name)) {
          continue;
        }
        for (const actor of this.colCells.get(name)) {
          testActors.add(actor);
        }
      }
      const actors = new Map();
      for (const actor of testActors) {
        if (actor.isGhost) {
          continue;
        }
        const intersection = this.actorIntersectsLine(actor, x1, y1, x2, y2);
        if (!intersection) {
          continue;
        }
        const distance = Math.hypot(x1 - intersection[0], y1 - intersection[1]);
        actors.set(actor, {
          intersection: intersection,
          distance: distance
        });
      }
      return new Map(Array.from(actors.entries()).sort((a, b) => a[1].distance - b[1].distance));
    }
  }, {
    key: "lineIntersectsLine",
    value: function lineIntersectsLine(a1x, a1y, a2x, a2y, b1x, b1y, b2x, b2y) {
      const ax = a2x - a1x;
      const ay = a2y - a1y;
      const bx = b2x - b1x;
      const by = b2y - b1y;
      const crossProduct = ax * by - ay * bx;
      if (crossProduct === 0) {
        return false;
      }
      const cx = b1x - a1x;
      const cy = b1y - a1y;
      const d = (cx * by - cy * bx) / crossProduct;
      if (d < 0 || d > 1) {
        return false;
      }
      const e = (cx * ay - cy * ax) / crossProduct;
      if (e < 0 || e > 1) {
        return false;
      }
      return [a1x + d * ax, a1y + d * ay];
    }
  }, {
    key: "actorIntersectsLine",
    value: function actorIntersectsLine(actor, b1x, b1y, b2x, b2y) {
      const actorArgs = actor.args;
      const width = actorArgs.width;
      const height = actorArgs.height;
      const bottom = actorArgs.y;
      const top = bottom - height;
      const left = actorArgs.x - (actor.isRegion ? 0 : width * 0.5);
      const right = left + width;
      if (left < b1x && b1x < right && top < b1y && b1y < bottom) {
        return [b1x, b1y];
      }
      const points = [];
      const bounds = actor.getBoundingLines();
      let min = Infinity,
        closest;
      for (const line of bounds) {
        const point = this.lineIntersectsLine(line[0], line[1], line[2], line[3], b1x, b1y, b2x, b2y);
        if (!point) {
          continue;
        }
        const dist = Math.hypot(b1x - point[0], b1y - point[1]);
        if (dist < min) {
          min = dist;
          closest = point;
        }
      }
      return closest;

      // if(!points.length)
      // {
      // 	if(left < b2x && b2x < right && top < b2y && b2y < bottom)
      // 	{
      // 		return [b2x, b2y];
      // 	}

      // 	return false;
      // }

      // const distances = points.map(point => Math.hypot(b1x - point[0], b1y - point[1]));

      // const closest = points[ distances.indexOf(Math.min(...distances)) ];

      // return closest;
    }
  }, {
    key: "padConnected",
    value: function padConnected(event) {
      this.gamepad = event.gamepad;
      console.log(this.gamepad);
      const shortName = String(this.gamepad.id).replace(/\(.\)/, ' ').replace(/\s?\(.+/, '');
      this.showStatus(2500, ' Gamepad connected: ' + shortName + ' ');
      this.args.focusMe.args.hide = 'hide';
      this.interact();
      if (typeof ga === 'function') {
        ga('send', 'event', {
          eventCategory: 'gamepad',
          eventAction: 'connected',
          eventLabel: event.gamepad.id
        });
      }
    }
  }, {
    key: "padRemoved",
    value: function padRemoved(event) {
      if (!this.gamepad) {
        return;
      }
      const shortName = String(this.gamepad.id).replace(/\(.\)/, ' ').replace(/\s?\(.+/, '');
      this.showStatus(2500, ' Gamepad disconnected: ' + shortName + ' ');
      if (this.args.started) {
        this.pauseGame();
      }
      if (this.gamepad.index === event.gamepad.index) {
        this.gamepad = null;
      }
      if (typeof ga === 'function') {
        ga('send', 'event', {
          eventCategory: 'gamepad',
          eventAction: 'disconnected',
          eventLabel: event.gamepad.id
        });
      }
    }
  }, {
    key: "getColCell",
    value: function getColCell(point) {
      const colCellDiv = this.colCellDiv;
      const colCells = this.colCells;
      const cellX = Math.floor(point.x / colCellDiv);
      const cellY = Math.floor(point.y / colCellDiv);
      const name = `${cellX}:${cellY}`;
      if (!colCells.has(name)) {
        const cell = new Set();
        colCells.set(name, cell);
        cell.name = name;
        return cell;
      }
      return colCells.get(name);
    }
  }, {
    key: "getColCells",
    value: function getColCells(actor) {
      const colCellDiv = this.colCellDiv;
      const actorTop = actor.args.y - actor.args.height;
      const actorWidth = actor.args.width;
      const actorLeft = actor.args.x - (actor.isRegion ? 0 : actorWidth / 2);
      const actorRight = actor.args.x + (actor.isRegion ? actorWidth : actorWidth / 2);
      const cellMinX = -1 + Math.floor(actorLeft / colCellDiv);
      const cellMaxX = Math.ceil(actorRight / colCellDiv);
      const cellMinY = -1 + Math.floor(actorTop / colCellDiv);
      const cellMaxY = Math.ceil(actor.args.y / colCellDiv);
      const cells = new Set();
      for (let x = cellMinX; x <= cellMaxX; x++) {
        for (let y = cellMinY; y <= cellMaxY; y++) {
          const cell = this.getColCell({
            x: x * colCellDiv,
            y: y * colCellDiv
          });
          cell.add(actor);
          cells.add(cell);
        }
      }
      return cells;
    }
  }, {
    key: "actorsInCells",
    value: function actorsInCells(cells) {
      const actors = new Set();
      for (const cell of cells) {
        for (const actor of cell) {
          actors.add(actor);
        }
      }
      return actors;
    }
  }, {
    key: "setColCell",
    value: function setColCell(actor) {
      if (actor.removed) {
        return;
      }
      if (!_Bindable.Bindable.isBindable(actor)) {
        console.log(actor);
      }
      actor[_Bindable.Bindable.NoGetters] = true;
      actor = _Bindable.Bindable.make(actor);
      const cell = this.getColCell(actor.args);
      if (actor[ColCell] && actor[ColCell] !== cell) {
        actor[ColCell].delete(actor);
      }
      cell.add(actor);
      actor[ColCell] = cell;
      if (!actor.isRegion) {
        return cell;
      }
      const prevCells = actor[ColCells];
      actor[ColCells] = this.getColCells(actor);
      if (prevCells) for (const prevCell of prevCells) {
        if (!actor[ColCells].has(prevCell)) {
          prevCell.delete(actor);
        }
      }
      return cell;
    }
  }, {
    key: "getNearbyColCells",
    value: function getNearbyColCells(actorX, actorY) {
      // const actorX = actor.args.x;
      // const actorY = actor.args.y;

      const colCellDiv = this.colCellDiv;
      const cellX = Math.floor(actorX / colCellDiv);
      const cellY = Math.floor(actorY / colCellDiv);
      const name = `${cellX}::${cellY}`;
      let cache = this.colCellCache.get(name);
      if (cache) {
        return cache; //.filter(set=>set.size);
      }

      const space = colCellDiv;
      const colA = actorX - space * 2;
      const colB = actorX - space;
      const colC = actorX;
      const colD = actorX + space;
      const colE = actorX + space * 2;
      const rowA = actorY - space * 2;
      const rowB = actorY - space;
      const rowC = actorY;
      const rowD = actorY + space;
      const rowE = actorY + space * 2;
      this.colCellCache.set(name, cache = [
      // this.getColCell({x:colA, y:rowA})
      // , this.getColCell({x:colA, y:rowB})
      // , this.getColCell({x:colA, y:rowC})
      // , this.getColCell({x:colA, y:rowD})
      // , this.getColCell({x:colA, y:rowE})

      // , this.getColCell({x:colB, y:rowA})
      this.getColCell({
        x: colB,
        y: rowB
      }), this.getColCell({
        x: colB,
        y: rowC
      }), this.getColCell({
        x: colB,
        y: rowD
      })
      // , this.getColCell({x:colB, y:rowE})

      // , this.getColCell({x:colC, y:rowA})
      , this.getColCell({
        x: colC,
        y: rowB
      }), this.getColCell({
        x: colC,
        y: rowC
      }), this.getColCell({
        x: colC,
        y: rowD
      })
      // , this.getColCell({x:colC, y:rowE})

      // , this.getColCell({x:colD, y:rowA})
      , this.getColCell({
        x: colD,
        y: rowB
      }), this.getColCell({
        x: colD,
        y: rowC
      }), this.getColCell({
        x: colD,
        y: rowD
      })
      // , this.getColCell({x:colD, y:rowE})

      // , this.getColCell({x:colE, y:rowA})
      // , this.getColCell({x:colE, y:rowB})
      // , this.getColCell({x:colE, y:rowC})
      // , this.getColCell({x:colE, y:rowD})
      // , this.getColCell({x:colE, y:rowE})
      ]);

      return cache; //.filter(set=>set.size);
    }
  }, {
    key: "screenFilter",
    value: function screenFilter(filterName) {
      this.args.screenFilter = filterName;
    }
  }, {
    key: "reset",
    value: function reset() {
      console.clear();
      this[Run]++;
      this.stop();
      this.args.currentSheild = null;
      this.args.hasFire = false;
      this.args.hasWater = false;
      this.args.hasElectric = false;
      this.args.hasNormal = false;
      this.clearDialog();
      this.hideDialog();
      this.replayFrames = new Map();
      // this.replayOffset = 0;
      // this.replay = null;

      this.visible.clear();
      this.callFrames.clear();
      this.callIntervals.clear();
      this.collisions.clear();
      this.colCellCache.clear();
      this.colCells.clear();
      this.regions.clear();
      this.spawn.clear();
      this.auras.clear();
      this.updateStarted.clear();
      this.updateEnded.clear();
      this.updated.clear();

      // this.actorPointCache.clear();

      this.objectDb = new _Classifier.Classifier(Object.values(_ObjectPalette.ObjectPalette));
      this.args.actClear = false;
      this.args.cutScene = false;
      this.args.fade = false;
      this.onFrameOut(30, () => this.args.fade = 'hide');
      this.args.xOffset = 0.5;
      this.args.yOffset = 0.5;
      this.args.screenEffects = new _Bag.Bag();
      if (this.tileMap) {
        this.tileMap.unreplace();
        const layers = this.tileMap.tileLayers;
        for (const layerDef of layers) {
          layerDef.offsetX = 0;
          layerDef.offsetY = 0;
          layerDef.offsetXChanged = 0;
          layerDef.offsetYChanged = 0;
        }
        for (const layer of [...this.args.layers, ...this.args.fgLayers]) {
          layer.args.destroyed = false;
          layer.args.offsetX = 0;
          layer.args.offsetY = 0;
          layer.args.offsetXChanged = 0;
          layer.args.offsetYChanged = 0;
        }
      }
      for (const actor of this.actors.items()) {
        this.actors.remove(actor);
      }
      this.controlActor && this.actors.remove(this.controlActor);
      this.nextControl = null;
      this.actorsById = {};
      for (const _ref22 of Object.entries(this.effects.list)) {
        var _ref23 = _slicedToArray(_ref22, 2);
        const id = _ref23[0];
        const effect = _ref23[1];
        effect && this.effects.remove(effect);
      }
      for (const _ref24 of Object.entries(this.particles.list)) {
        var _ref25 = _slicedToArray(_ref24, 2);
        const id = _ref25[0];
        const particle = _ref25[1];
        particle && this.particles.remove(particle);
      }
      this.spawn.clear();
      this[ActorPointCache].clear();
      this.args.isRecording = false;
      this.args.isReplaying = false;
      this.args.populated = false;
      this.controlActor = null;
      // this.args.frameId   = -1;

      this.tags.viewport.focus();
      this.args.paused = true;
    }
  }, {
    key: "quit",
    value: function quit() {
      let quick = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      let after = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      if (!this.replay && !this.levelFinished) {
        this.saveReplay('#FFF').catch(() => {});
      }
      this.baseMap = this.currentMap = null;
      if (this.args.networked) {
        this.server && this.server.close();
        this.client && this.client.close();
        this.actors.remove(this.remotePlayer);
        this.actors.remove(this.controlActor);
        this.controlActor = this.remotePlayer = null;
      }
      this.args.fade = this.args.fade === true ? this.args.fade : false;
      this.onNextFrame(() => this.args.fade = true);
      this.onFrameOut(45, () => {
        this.args.actClear = false;
        this.args.cutScene = false;
        this.args.screenEffects = new _Bag.Bag();
        this.callFrames.clear();
        this.callIntervals.clear();
        this.collisions.clear();
        this.colCellCache.clear();
        this.colCells.clear();
        this.regions.clear();
        this.spawn.clear();
        this.auras.clear();
        this.replayFrames = new Map();
        this.replayOffset = 0;
        this.replayStart = null;
        this.replay = null;
        this.args.timeBonus.args.value = 0;
        this.args.ringBonus.args.value = 0;
        this.args.speedBonus.args.value = 0;
        this.args.totalBonus.args.value = 0;
        this.defsByMap.clear();
        this.actorsByMap.clear();
        this.meta = {};
        this.willDetach.clear();
        this.objectDb.clear();
        this.args.currentSheild = null;
        this.args.hasFire = false;
        this.args.hasWater = false;
        this.args.hasElectric = false;
        this.args.hasNormal = false;
        this.args.isRecording = false;
        this.args.isReplaying = false;
        this.playableIterator = false;
        this.args.populated = false;
        this.args.paused = false;
        this.args.started = false;
        this.controlActor = null;
        this.args.frameId = -1;
        this.args.timer.args.value = '';
        this.args.rings.args.value = 0;
        // this.emeralds.args.value = 0;
        // this.coins.args.value    = 0;

        this.args.hasRings = false;
        this.args.hasCoins = false;
        this.args.hasEmeralds = false;
        this.args.char.args.value = '';
        this.args.charName = '';
        this.args.level = false;
        const layers = this.args.layers;
        const layerCount = layers.length;
        for (const actor of this.actors.items()) {
          this.actors.remove(actor);
        }
        for (const particle of this.particles.items()) {
          this.particles.remove(particle);
          particle.remove();
        }
        for (const layer of [...this.args.layers, ...this.args.fgLayers]) {
          layer.args.destroyed = false;
        }
        for (const layer of this.args.layers) {
          layer.remove();
        }
        for (const layer of this.args.fgLayers) {
          layer.remove();
        }
        this.args.bg = this.args.backdrop = null;
        for (const _ref26 of this.backdrops) {
          var _ref27 = _slicedToArray(_ref26, 2);
          const k = _ref27[0];
          const v = _ref27[1];
          v.view.remove();
        }
        this.backdrops.clear();
        if (after) {
          this.onFrameOut(15, () => after());
        } else {
          const cards = [];
          if (quick === 2 || this.args.networked) {
            const menu = new _MainMenu.MainMenu({
              timeout: -1
            }, this);
            if (this.args.networked) {
              menu.args.initialPath = ['Multiplayer'];
            }
            cards.push(menu);
          } else if (quick) {
            _Bgm.Bgm.fadeOut(2000);
            cards.push(...this.homeCards());
          } else {
            _Bgm.Bgm.fadeOut(3000);
            cards.push(...this.returnHomeCards());
          }
          this.onFrameOut(15, () => {
            this.args.titlecard = new _Series.Series({
              cards: cards
            }, this);
            this.args.titlecard.play();
          });
        }
      });
      _Keyboard.Keyboard.get().reset();
      this.controller.zero();
    }
  }, {
    key: "introCards",
    value: function introCards() {
      return [new _LoadingCard.LoadingCard({
        timeout: 3500,
        text: 'loading'
      }, this), new _BootCard.BootCard({
        timeout: 3500
      }), new _WarningCard.WarningCard({
        timeout: 8500
      }), new _DebianCard.DebianCard({
        timeout: 4500
      }), new _WebkitCard.WebkitCard({
        timeout: 3500
      }), new _SaneCard.SaneCard({
        timeout: 4500
      }), new _GamepadCard.GamepadCard({
        timeout: 2500
      }), new _SeanCard.SeanCard({
        timeout: 5000
      }, this), ...this.homeCards()];
    }
  }, {
    key: "homeCards",
    value: function homeCards() {
      return [new _TitleScreenCard.TitleScreenCard({
        timeout: 51000
      }, this), new _MainMenu.MainMenu({
        timeout: -1
      }, this)];
    }
  }, {
    key: "returnHomeCards",
    value: function returnHomeCards() {
      return [new _ThankYouCard.ThankYouCard({
        timeout: 5000
      }, this), ...this.homeCards()];
    }
  }, {
    key: "playCards",
    value: function playCards() {
      this.args.titlecard.play();
    }
  }, {
    key: "record",
    value: function record() {
      this.args.demoIndicator = null;
      this.reset();
      this.args.frameId = 0;
      this.replayFrames = new Map();
      this.args.isRecording = true;
      this.args.isReplaying = false;
      this.args.hasRecording = true;
      this.args.paused = false;
      this.startLevel();
    }
  }, {
    key: "playback",
    value: function playback() {
      this.args.demoIndicator = null;
      this.args.frameId = 0;
      this.args.isReplaying = true;
      this.args.isRecording = false;
      this.lastInput = {};
      this.startLevel();
      this.args.paused = false;
    }
  }, {
    key: "stop",
    value: function stop() {
      if (this.args.isRecording) {
        const replay = JSON.stringify(this.replayFrames.entries());
        localStorage.setItem('replay', replay);
      }
      this.args.isReplaying = false;
      this.args.isRecording = false;
      this.args.paused = false;
      this.controlActor && this.controlActor.controller.zero();
      this.tags.viewport.focus();
    }
  }, {
    key: "focus",
    value: function focus() {
      this.tags.viewport && this.tags.viewport.focus();
    }
  }, {
    key: "getServer",
    value: function getServer() {
      let refresh = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      if (!refresh && this.server && this.server.peerServer && this.server.peerServer.connectionState === 'new') {
        return this.server;
      }
      const rtcConfig = {
        iceServers: [{
          urls: this.settings.iceServer1
        }, {
          urls: this.settings.iceServer2
        }]
      };
      const server = refresh || !this.server ? new _RtcServer.RtcServer(rtcConfig) : this.server || new _RtcServer.RtcServer(rtcConfig);
      const onOpen = event => {
        // console.log('Connection opened!');
        this.args.chatBox = new _ChatBox.ChatBox({
          pipe: server
        });
        this.args.playerId = 1;
      };
      const onMessage = event => {
        // const actors = this.actors.list;

        if (this.remotePlayer) {
          const packet = JSON.parse(event.detail);
          const actor = this.remotePlayer;
          if (packet.frame) {
            if (packet.frame.frame > this.args.frameId) {
              this.args.frameId = packet.frame.frame;
            }
            if (packet.frame.input) {
              actor.controller.replay(packet.frame.input);
              actor.readInput();
            }
            if (packet.frame.args) {
              Object.assign(actor.args, packet.frame.args);
            }
            actor.noClip = actor.args.dead;
          }
        }
      };
      const onClose = event => {
        this.actors.remove(this.remotePlayer);
        this.quit(2);
      };
      this.listen(server, 'open', onOpen, {
        once: true
      });
      this.listen(server, 'close', onClose, {
        once: true
      });
      this.listen(server, 'message', onMessage);
      this.server = server;
      return server;
    }
  }, {
    key: "getClient",
    value: function getClient() {
      let refresh = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      if (!refresh && this.client && this.client.peerClient && this.client.peerClient.connectionState === 'new') {
        return this.client;
      }
      const rtcConfig = {
        iceServers: [{
          urls: this.settings.iceServer1
        }, {
          urls: this.settings.iceServer2
        }]
      };

      // const client = (!refresh && this.client) || new RtcClient(rtcConfig);
      const client = refresh || !this.client ? new _RtcClient.RtcClient(rtcConfig) : this.client || new _RtcClient.RtcClient(rtcConfig);
      const onOpen = event => {
        // console.log('Connection opened!')
        this.args.chatBox = new _ChatBox.ChatBox({
          pipe: client
        });
        this.args.playerId = 2;
      };
      const onMessage = event => {
        // const actors = this.actors.list;

        if (this.remotePlayer) {
          const packet = JSON.parse(event.detail);
          const actor = this.remotePlayer;
          if (packet.frame) {
            if (packet.frame.frame > this.args.frameId) {
              this.args.frameId = packet.frame.frame;
            }
            if (packet.frame.input) {
              actor.controller.replay(packet.frame.input);
              actor.readInput();
            }
            if (packet.frame.args) {
              Object.assign(actor.args, packet.frame.args);
            }
            actor.noClip = actor.args.dead;
          }
        }
      };
      const onClose = event => this.quit(2);
      this.listen(client, 'open', onOpen, {
        once: true
      });
      this.listen(client, 'close', onClose, {
        once: true
      });
      this.listen(client, 'message', onMessage);
      this.client = client;
      return client;
    }
  }, {
    key: "serializePlayer",
    value: function serializePlayer() {
      if (!this.controlActor || !this.controlActor.controller) {
        return {};
      }
      const frame = this.args.frameId;
      const input = this.controlActor.controller.serialize();
      const actorArgs = this.controlActor.args;
      const args = {
        x: actorArgs.x,
        y: actorArgs.y,
        gSpeed: actorArgs.gSpeed,
        xSpeed: actorArgs.xSpeed,
        ySpeed: actorArgs.ySpeed,
        direction: actorArgs.direction,
        facing: actorArgs.facing,
        falling: actorArgs.falling,
        rolling: actorArgs.rolling,
        jumping: actorArgs.jumping,
        flying: actorArgs.flying,
        float: actorArgs.float,
        angle: actorArgs.angle,
        mode: actorArgs.mode,
        rings: actorArgs.rings,
        groundAngle: actorArgs.groundAngle,
        respawning: actorArgs.respawning,
        dead: actorArgs.dead ? true : false
      };
      return {
        frame: frame,
        input: input,
        args: args
      };
    }
  }, {
    key: "packPlayerFrame",
    value: function packPlayerFrame() {
      const actorArgs = this.controlActor.args;
      const axisInts = new Int8Array(8);
      const buttonInts = new Int8Array(16);
      const playerInts = new Int32Array(11);
      const playerFloats = new Float32Array(7);
      const gameInts = new Int32Array(1);
      playerInts[0] = actorArgs.direction;
      playerInts[1] = actorArgs.facing === 'left' ? -1 : 1;
      playerInts[2] = actorArgs.falling;
      playerInts[3] = actorArgs.rolling;
      playerInts[4] = actorArgs.jumping;
      playerInts[5] = actorArgs.flying;
      playerInts[6] = actorArgs.float;
      playerInts[7] = actorArgs.mode;
      playerInts[8] = actorArgs.rings;
      playerInts[9] = actorArgs.respawning;
      playerInts[10] = Number(actorArgs.dead);
      playerFloats[0] = actorArgs.x;
      playerFloats[1] = actorArgs.y;
      playerFloats[2] = actorArgs.gSpeed;
      playerFloats[3] = actorArgs.xSpeed;
      playerFloats[4] = actorArgs.ySpeed;
      playerFloats[5] = actorArgs.angle;
      playerFloats[6] = actorArgs.groundAngle;
      gameInts[0] = this.args.frameId;
      const _this$controlActor$co = this.controlActor.controller.serialize(),
        axes = _this$controlActor$co.axes,
        buttons = _this$controlActor$co.buttons;
      for (const i in axisInts) {
        var _axes$i;
        axisInts[i] = 127 * ((_axes$i = axes[i]) !== null && _axes$i !== void 0 ? _axes$i : 0);
      }
      for (const i in buttonInts) {
        var _buttons$i;
        buttonInts[i] = 127 * ((_buttons$i = buttons[i]) !== null && _buttons$i !== void 0 ? _buttons$i : 0);
      }
      const packed = new Blob([axisInts.buffer, buttonInts.buffer, playerInts.buffer, playerFloats.buffer, gameInts.buffer]);
      return packed;
    }
  }, {
    key: "unpackPlayerFrame",
    value: function unpackPlayerFrame(buffer) {
      const axisView = new DataView(buffer, 0);
      const buttonView = new DataView(buffer, 8);
      const playerIntView = new DataView(buffer, 24);
      const playerFloatView = new DataView(buffer, 68);
      const gameIntView = new DataView(buffer, 96);
      const input = {
        axes: {},
        buttons: {}
      };
      const args = {};
      for (let i = 0; i < 8; i++) {
        input.axes[i] = axisView.getInt8(i) / 127;
      }
      for (let i = 0; i < 16; i++) {
        input.buttons[i] = buttonView.getInt8(i) / 127;
      }
      args.direction = playerIntView.getInt32(0, true);
      args.facing = playerIntView.getInt32(4, true) === -1 ? 'left' : 'right';
      args.falling = playerIntView.getInt32(8, true);
      args.rolling = playerIntView.getInt32(12, true);
      args.jumping = playerIntView.getInt32(16, true);
      args.flying = playerIntView.getInt32(20, true);
      args.float = playerIntView.getInt32(24, true);
      args.mode = playerIntView.getInt32(28, true);
      args.rings = playerIntView.getInt32(32, true);
      args.respawning = playerIntView.getInt32(36, true);
      args.dead = playerIntView.getInt32(40, true);
      args.x = playerFloatView.getFloat32(0, true);
      args.y = playerFloatView.getFloat32(4, true);
      args.gSpeed = playerFloatView.getFloat32(8, true);
      args.xSpeed = playerFloatView.getFloat32(12, true);
      args.ySpeed = playerFloatView.getFloat32(16, true);
      args.angle = playerFloatView.getFloat32(20, true);
      args.groundAngle = playerFloatView.getFloat32(24, true);
      const frame = gameIntView.getInt32(0, true);
      return {
        frame: {
          input: input,
          args: args,
          frame: frame
        }
      };
    }
  }, {
    key: "onRenderedFrameOut",
    value: function onRenderedFrameOut(frames, callback) {
      if (frames < 0) {
        callback();
        return;
      }
      this.callRenderedFrames.set(callback, frames);
    }
  }, {
    key: "onFrameOut",
    value: function onFrameOut(frames, callback) {
      if (frames <= 0) {
        callback();
        return;
      }
      const callFrame = this.args.frameId + frames;
      if (!this.callFrames.has(callFrame)) {
        this.callFrames.set(callFrame, new Set());
      }
      const callbacks = this.callFrames.get(callFrame);
      callbacks.add(callback);
      return () => callbacks.delete(callback);
    }
  }, {
    key: "onFrameInterval",
    value: function onFrameInterval(interval, callback) {
      if (frames <= 0) {
        return;
      }
      const callInterval = interval;
      if (!this.callIntervals.has(callInterval)) {
        this.callIntervals.set(callInterval, new Set());
      }
      const callbacks = this.callIntervals.get(callInterval);
      callbacks.add(callback);
      return () => callbacks.delete(callback);
    }
  }, {
    key: "callFrameOuts",
    value: function callFrameOuts() {
      for (let i = this.args.lastFrameId; i <= this.args.frameId; i++) {
        if (!this.callFrames.has(i)) {
          continue;
        }
        const callbacks = this.callFrames.get(i);
        for (const callback of callbacks) {
          callback();
        }
        this.callFrames.delete(i);
      }
    }
  }, {
    key: "callRenderedFrameOut",
    value: function callRenderedFrameOut() {
      if (this.args.frameId % this.settings.frameSkip !== 0) {
        return;
      }
      for (const _ref28 of this.callRenderedFrames) {
        var _ref29 = _slicedToArray(_ref28, 2);
        const callback = _ref29[0];
        const framesLeft = _ref29[1];
        if (framesLeft <= 0) {
          callback();
          continue;
        }
        this.callRenderedFrames.set(callback, -1 + frames);
      }
    }
  }, {
    key: "callFrameIntervals",
    value: function callFrameIntervals() {
      for (let i = this.args.lastFrameId; i <= this.args.frameId; i++) {
        for (const _ref30 of this.callIntervals) {
          var _ref31 = _slicedToArray(_ref30, 2);
          const interval = _ref31[0];
          const callbacks = _ref31[1];
          if (i % interval === 0) {
            for (const callback of callbacks) {
              callback();
            }
          }
        }
      }
    }
  }, {
    key: "pauseGame",
    value: function pauseGame() {
      this.focus();
      this.args.mouse = 'moved';
      this.args.paused = -1;
      this.args.pauseMenu.focusFirst();
      _Bgm.Bgm.pause();
      this.onTimeout(6, () => {
        this.controller && this.controller.zero();
      });
    }
  }, {
    key: "unpauseGame",
    value: function unpauseGame() {
      this.args.pauseMenu.reset();
      _Bgm.Bgm.unpause();
      this.args.mouse = 'hide';
      this.onTimeout(15, () => {
        this.controller && this.controller.zero();
      });
      this.onTimeout(30, () => {
        this.focus();
      });
      this.onTimeout(60, () => {
        this.args.paused = false;
      });
    }
  }, {
    key: "mousemove",
    value: function mousemove(event) {
      this.args.mouse = 'moved';
      const xOrigin = event.currentTarget.offsetLeft;
      const yOrigin = event.currentTarget.offsetTop;
      const xMouse = (event.pageX + -xOrigin) / this.args.scale;
      const yMouse = (event.pageY + -yOrigin) / this.args.scale;
      this.args.xMouseOffset = xMouse;
      this.args.yMouseOffset = yMouse;
      this.onTimeout(800, () => {
        this.args.mouse = 'hide';
      });
    }
  }, {
    key: "mousedown",
    value: function mousedown(event) {
      this.setMouseButtons(event);
    }
  }, {
    key: "mouseup",
    value: function mouseup(event) {
      this.setMouseButtons(event);
    }
  }, {
    key: "setMouseButtons",
    value: function setMouseButtons(event) {
      for (let i = 0; i < 8; i++) {
        const bit = Math.pow(2, i);
        this.mouseState.buttons[i] = this.mouseState.buttons[i] || 0;
        if (event.buttons & bit) {
          this.mouseState.buttons[i]++;
        } else {
          this.mouseState.buttons[i] = 0;
        }
      }
    }
  }, {
    key: "hyphenate",
    value: function hyphenate(string) {
      return String(string).replace(/\s/g, '-').toLowerCase();
    }
  }, {
    key: "storeCheckpoint",
    value: function storeCheckpoint(name, checkpointId) {
      if (!this.checkpoints[this.currentMap]) {
        this.checkpoints[this.currentMap] = {};
      }
      const checkpointsByActor = this.checkpoints[this.currentMap];
      checkpointsByActor[name] = {
        checkpointId: checkpointId,
        frames: this.args.frameId - this.args.startFrameId
      };
      localStorage.setItem(`checkpoints:::${this.currentMap}`, JSON.stringify(this.checkpoints[this.currentMap]));
    }
  }, {
    key: "getCheckpoint",
    value: function getCheckpoint(name) {
      if (!this.checkpoints[this.currentMap]) {
        const checkpointSource = localStorage.getItem(`checkpoints:::${this.currentMap}`) || '{}';
        this.checkpoints[this.currentMap] = JSON.parse(checkpointSource) || {};
      }
      const checkpointsByActor = this.checkpoints[this.currentMap];
      const currentCheckpoint = checkpointsByActor[name];
      return currentCheckpoint;
    }
  }, {
    key: "setCheckpoint",
    value: function setCheckpoint(mapUrl, storedCheckpoint) {
      const checkpointSource = localStorage.setItem(`checkpoints:::${mapUrl}`, JSON.stringify(storedCheckpoint));
    }
  }, {
    key: "clearCheckpoints",
    value: function clearCheckpoints() {
      let name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      if (!this.controlActor) {
        return;
      }
      if (name === null) {
        name = this.controlActor.args.canonical;
      }
      if (!this.checkpoints[this.currentMap]) {
        this.checkpoints[this.currentMap] = {};
      }
      const checkpointsByActor = this.checkpoints[this.currentMap];
      delete checkpointsByActor[name];
      localStorage.setItem(`checkpoints:::${this.currentMap}`, JSON.stringify(this.checkpoints[this.currentMap]));
    }
  }, {
    key: "showCenterMessage",
    value: function showCenterMessage(message, color) {
      this.args.centerMessage = new _CharacterString.CharacterString({
        value: message,
        color: color
      });
    }
  }, {
    key: "hideCenterMessage",
    value: function hideCenterMessage() {
      this.args.centerMessage = false;
    }
  }, {
    key: "showDialog",
    value: function showDialog() {
      let lines = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      let classes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
      this.args.dialog = true;
      this.clearDialog();
      lines = lines.map(t => new _CharacterString.CharacterString({
        value: t
      }));
      let offset = 0;
      for (const line of lines) {
        line.offset = offset;
        offset += line.args.value.length;
      }
      this.args.dialogLines = lines;
      this.args.dialogClasses = classes;
    }
  }, {
    key: "hideDialog",
    value: function hideDialog(message) {
      this.clearDialog();
      this.args.dialog = false;
    }
  }, {
    key: "clearDialog",
    value: function clearDialog() {
      this.args.dialogLines = [];
    }
  }, {
    key: "clearAct",
    value: function clearAct(message) {
      let showZonecard = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      const zoneState = this.getZoneState();
      if (this.controlActor && this.controlActor.args.canonical) {
        const charState = this.getCharacterState(this.controlActor.args.canonical);
        if (charState) {
          if (!(this.currentMap in charState.cleared)) {
            charState.cleared[this.currentMap] = {
              firstCleared: Date.now()
            };
          }
          charState.cleared[this.currentMap].clearCount = charState.cleared[this.currentMap].clearCount || 0;
          charState.cleared[this.currentMap].lastCleared = Date.now();
          charState.cleared[this.currentMap].clearCount++;
        }
      }
      this.args.actClearLabel.args.value = message;
      const rings = this.controlActor.args.rings;
      const frames = this.args.frameId - this.args.startFrameId;
      const time = frames / 60;
      const air = this.controlActor.args.airTimeTotal / (this.controlActor.args.airTimeTotal + this.controlActor.args.groundTimeTotal);
      const speedBonus = Math.trunc(this.controlActor.args.clearSpeed * 10);
      const ringBonus = rings * 100;
      const airBonus = Math.round(10000 * (air || 0));
      let timeBonus = 0;
      const seconds = Math.trunc(Math.abs(time));
      if (seconds < 30) {
        timeBonus = 50000;
      } else if (seconds < 45) {
        timeBonus = 10000;
      } else if (seconds < 60) {
        timeBonus = 5000;
      } else if (seconds < 90) {
        timeBonus = 4000;
      } else if (seconds < 120) {
        timeBonus = 3000;
      } else if (seconds < 180) {
        timeBonus = 2000;
      } else if (seconds < 240) {
        timeBonus = 1000;
      } else {
        timeBonus = 500;
      }
      const totalBonus = timeBonus + ringBonus + speedBonus + airBonus;
      const score = totalBonus;
      this.args.actClear = true;
      this.args.skidBonusValue = this.controlActor.args.dragBonus || 0;

      // this.args.timeBonus.args.value  = 0;
      // this.args.ringBonus.args.value  = 0;
      // this.args.airBonus.args.value   = 0;
      // this.args.speedBonus.args.value = 0;
      // this.args.skidBonus.args.value  = 0;
      // this.args.totalBonus.args.value = 0;

      const skidBonus = this.controlActor.args.dragBonus || 0;

      // this.onFrameOut(45 * 1, () => this.args.timeBonus.args.value  = timeBonus);
      // this.onFrameOut(45 * 2, () => this.args.ringBonus.args.value  = ringBonus);
      // this.onFrameOut(45 * 3, () => this.args.speedBonus.args.value = speedBonus);
      // this.onFrameOut(45 * 4, () => this.args.skidBonus.args.value  = skidBonus);
      // this.onFrameOut(45 * 5, () => this.args.airBonus.args.value   = airBonus);
      // this.onFrameOut(45 * 6, () => this.args.totalBonus.args.value = totalBonus);
      // this.onFrameOut(45 * 7, () => this.args.actClear = false);

      // tallyBoard.addCounter({label:'Skid Bonus:',  value: skidBonus||30000});

      const tallyBoard = new _TallyBoard.TallyBoard();
      tallyBoard.addCounter({
        label: 'Time Bonus:',
        value: timeBonus
      });
      tallyBoard.addCounter({
        label: 'Ring Bonus:',
        value: ringBonus
      });
      if (speedBonus) {
        tallyBoard.addCounter({
          label: 'Speed Bonus:',
          value: speedBonus
        });
      }
      tallyBoard.addCounter({
        label: 'Air Bonus:',
        value: airBonus
      });
      _Bgm.Bgm.play('ACT_CLEAR', {
        interlude: true
      });
      tallyBoard.update(this);

      // tallyBoard.addEventListener('almostdone', console.log);
      // tallyBoard.addEventListener('totalingstarted', console.log);

      if (showZonecard) {
        tallyBoard.addEventListener('totalingdone', event => this.setZoneCard(true));
      }
      tallyBoard.addEventListener('done', event => {
        this.controlActor.args.clearSpeed = 0;
        this.args.tallyBoard = null;
        this.tallyBoard = false;
        this.args.actStartFrameId = this.args.frameId;
        this.args.actClear = false;
        this.args.inventory.splice(0);
        _Bgm.Bgm.stop('ACT_CLEAR');
        if (showZonecard) {
          this.args.zonecard.replay();
        }
      });
      this.tallyBoard = tallyBoard;
      this.args.tallyBoard = tallyBoard.view();
      if (!zoneState.time || zoneState.time > frames) {
        zoneState.time = frames;
      }
      if (!zoneState.rings || zoneState.rings < rings) {
        zoneState.rings = rings;
      }
      if (!zoneState.air || zoneState.air < air) {
        zoneState.air = air;
      }
      if (!zoneState.score || zoneState.score < score) {
        zoneState.score = score;
      }
      this.currentSave.save();
      return tallyBoard;
    }
  }, {
    key: "cpuDetect",
    value: function cpuDetect() {
      try {
        ga('send', 'event', {
          eventCategory: 'cpu',
          eventAction: 'cores',
          eventLabel: `core check`,
          eventValue: navigator.hardwareConcurrency
        });
      } catch (error) {
        ga && ga('send', 'event', {
          eventCategory: 'cpu',
          eventAction: 'cpu detect fail',
          eventLabel: `Cpu Detect Failure: ${error}`
        });
      }
    }
  }, {
    key: "gpuDetect",
    value: function gpuDetect() {
      try {
        this.gpuDetector = this.gpuDetector || document.createElement('canvas').getContext('webgl');
        const debug = this.gpuDetector.getExtension('WEBGL_debug_renderer_info');
        const vendor = this.gpuDetector.getParameter(debug.UNMASKED_VENDOR_WEBGL);
        const gpu = this.gpuDetector.getParameter(debug.UNMASKED_RENDERER_WEBGL);
        ga('send', 'event', {
          eventCategory: 'gpu',
          eventAction: 'gpu detect',
          eventLabel: `${vendor} :: ${gpu}`
        });
      } catch (error) {
        ga && ga('send', 'event', {
          eventCategory: 'gpu',
          eventAction: 'gpu detect fail',
          eventLabel: `Gpu Detect Failure: ${error}`
        });
      }
    }
  }, {
    key: "buildDetect",
    value: function buildDetect() {
      const buildTag = document.head.querySelector('meta[name="x-build-time"]');
      const build = buildTag.getAttribute('content');
      ga && ga('send', 'event', {
        eventCategory: 'build',
        eventAction: 'build check',
        eventLabel: build
      });
    }
  }, {
    key: "interact",
    value: function interact() {
      this.args.interacted = true;
    }
  }, {
    key: "matrixConnect",
    value: function matrixConnect() {
      let refresh = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      if (!this.settings.matrixUrl) {
        console.error('No matrixUrl defined!!!');
      }
      const redirectUrl = location.origin + '/accept-sso';
      if (!refresh && this.matrix) {
        if (!this.matrix.isLoggedIn) {
          return this.matrix.logIn(redirectUrl).then(() => this.matrix);
        }
        return Promise.resolve(this.matrix);
      }
      return this.matrix.logIn(redirectUrl).then(() => this.matrix);
    }
  }, {
    key: "subspaceConnect",
    value: function subspaceConnect() {
      this.socket = _Socket.Socket.get('ws://localhost:9998');
      this.socket.subscribe('open', () => {
        console.log('socket ready!');
        fetch('http://localhost:2020/auth?api').then(r => r.text()).then(token => {
          console.log(token);
          this.socket.send(`auth ${token}`);
          const channel = 'testing';
          const message = 'This is the payload.';
          this.socket.subscribe('message', (event, message, channel, origin, originId, originalChannel) => {
            if (origin === 'user') {
              return;
            }
            console.log(event.data);
            if (event.data[0] !== '{') {
              return;
            }
            const packet = JSON.parse(event.data);
            if ('youruid' in packet) {
              this.netId = packet.youruid;
            }
          });
          this.socket.send('uid');
          this.socket.subscribe('message:0', (event, message, channel, origin, originId, originalChannel) => {
            this.bytesReceived += message.length || message.byteLength;
            if (origin !== 'user') {
              console.log(message);
              return;
            }
            if (!this.controlActor || originId === this.netId) {
              return;
            }
            const packet = this.unpackPlayerFrame(message);
            if (!this.netPlayers.has(originId)) {
              const netPlayer = new _Sonic.Sonic({
                name: 'Player ' + originId,
                id: String(new _Uuid.Uuid()),
                netplayer: true
              }, this);
              this.netPlayers.set(originId, netPlayer);
              this.spawn.add({
                object: netPlayer
              });
              this.actors.add(netPlayer);
              this.auras.add(netPlayer);
            }
            const netPlayer = this.netPlayers.get(originId);
            if (packet.frame) {
              if (packet.frame.frame > this.args.frameId) {
                this.args.frameId = packet.frame.frame;
              }
              if (packet.frame.input) {
                netPlayer.controller.replay(packet.frame.input);
                netPlayer.readInput();
              }
              if (packet.frame.args) {
                Object.assign(netPlayer.args, packet.frame.args);
              }
              netPlayer.noClip = netPlayer.args.dead;
            }

            // console.log('message received!', {event, message, channel, origin, originId, originalChannel});
          });

          this.socket.publish(channel, message);
        });
      });
      this.socket.subscribe('close', () => {
        console.log('socket closed!');
        this.quit(2);
      });
    }
  }, {
    key: "nowPlayingClicked",
    value: function nowPlayingClicked(event) {
      if (!this.args.audioComment) {
        return;
      }
      this.pauseGame();
      window.open(this.args.audioComment, 'audio-credit');
    }
  }, {
    key: "handleUncaughtException",
    value: function handleUncaughtException(event) {
      console.error(event.error);
      ga('send', 'event', {
        eventCategory: 'error',
        eventAction: `${event.error.message} @ ${event.filename}:${event.lineno}:${event.colno}`,
        eventLabel: event.error.stack
      });
      _TraceDatabase.TraceDatabase.open('traces', 1).then(database => {
        const trace = _Trace.Trace.from(event.error);
        delete trace.id;
        console.log(JSON.stringify(trace));
        trace.consume(event);
        console.log(JSON.stringify(trace));
        console.log(trace, event);
        if (!this.currentMap) {
          return;
        }
        database.insert('traces', trace).then(() => {
          if (this.replay) {
            trace.replay = this.replay.uuid;
            database.update('traces', trace);
            return;
          }
          this.saveReplay('#FF0000').then(replay => {
            trace.replay = replay.uuid;
            database.update('traces', trace);
          }).catch(() => {});
        });
      });
    }
  }, {
    key: "mouse",
    get: function get() {
      this.mouseState.position[0] = this.args.xMouseOffset + -this.args.x;
      this.mouseState.position[1] = this.args.yMouseOffset + -this.args.y;
      return this.mouseState;
    }
  }]);
  return Viewport;
}(_View2.View);
exports.Viewport = Viewport;
});

;require.register("viewport/layer.html", function(exports, require, module) {
module.exports = "<div data-name = \"[[name]]\" class = \"viewport-background\" cv-each = \"blocks:block:b\" cv-ref = \"background\" data-layer = \"[[layerId]]\">[[block]]</div>\n"
});

;require.register("viewport/viewport.html", function(exports, require, module) {
module.exports = "<section class = \"filters\" cv-each = \"effects:effect\">[[effect]]</section>\n\n<div class = \"viewport-frame [[initializing]] [[standalone]] [[secret]] [[level]] [[noIntro]] [[inputType]] [[ntsc]] [[windowFocused]]\" data-theme = \"[[theme]]\" data-bg = \"[[bg]]\" cv-ref = \"frame\" data-paused = \"[[paused]]\" data-smoothing = [[smoothing]] cv-on = \"mousedown:interact:c;keydown:interact:c;\">\n\t<div class = \"viewport [[standalone]] [[fullscreen]] displacement-[[displacement]] mouse-[[mouse]] [[theme]] [[hideNowPlaying]] [[hiddenNowPlaying]] [[invert]]\" cv-ref = \"viewport\" tabindex=\"0\" cv-on = \"click;mousemove;mousedown;mouseup;\">\n\n\t\t<svg height=\"32\" width=\"32\">\n\t\t<defs>\n\t\t\t<filter id=\"motionBlur\" x=\"0%\"\n y=\"0%\" width=\"100%\" height=\"100%\">\n\t\t\t\t<feGaussianBlur\n\t\t\t\t\tin = \"SourceGraphic\"\n\t\t\t\t\tedgeMode = \"duplicate\"\n\t\t\t\t\tstdDeviation = \"0,0\"\n\t\t\t\t\tcv-ref = \"blur\"\n\t\t\t\t/>\n\t\t\t</filter>\n\t\t</defs>\n\t\t</svg>\n\n\t\t<svg height=\"100\" width=\"100\">\n\t\t<defs>\n\t\t\t<filter id=\"waterBlur\">\n\t\t\t\t<feGaussianBlur in=\"SourceGraphic\" stdDeviation=\"0.25,0\" />\n\t\t\t</filter>\n\n\t\t\t<filter id=\"dilate\">\n\t\t\t\t<feMorphology operator=\"dilate\" radius=\"0.25\" result = \"expanded\"/>\n\t\t\t\t<feMerge>\n\t\t\t\t\t<feMergeNode in=\"expanded\" />\n\t\t\t\t\t<feMergeNode in=\"SourceGraphic\" />\n\t\t\t\t</feMerge>\n\t\t\t</filter>\n\n\t\t\t<filter id = \"waves\"\n\t\t\t\tcolor-interpolation-filters=\"sRGB\"\n\t\t\t\tx      =\"0%\"\n\t\t\t\ty      =\"0%\"\n\t\t\t\theight =\"100%\"\n\t\t\t\twidth  =\"100%\"\n\t\t\t>\n\t\t\t\t<feFlood\n\t\t\t\t\tflood-color=\"#408000\"\n\t\t\t\t\tresult = \"DisplacementGreen\"\n\t\t\t\t></feFlood>\n\n\t\t\t\t<feImage\n\t\t\t\t\txlink:href=\"/effects/wave.png\"\n\t\t\t\t\tresult=\"DisplacementSource\"\n\t\t\t\t\theight=\"64\"\n\t\t\t\t\twidth=\"64\"\n\t\t\t\t></feImage>\n\n\t\t\t\t<feTile\n\t\t\t\t\tin=\"DisplacementSource\"\n\t\t\t\t\tresult=\"DisplacementTile\"\n\t\t\t\t></feTile>\n\n\t\t\t\t<feComposite\n\t\t\t\t\tin  = \"DisplacementTile\"\n\t\t\t\t\tin2 = \"DisplacementGreen\"\n\t\t\t\t\tresult =\"DisplacementField\"\n\t\t\t\t\toperator =\"over\"\n\t\t\t\t></feComposite>\n\n\t\t\t\t<feOffset\n\t\t\t\t\tin  = \"DisplacementField\"\n\t\t\t\t\tout = \"DisplacementOffset\"\n\t\t\t\t\tdx  = \"0\"\n\t\t\t\t>\n\t\t\t\t\t<animate\n\t\t\t\t\t\tattributeName=\"dy\"\n\t\t\t\t\t\tvalues = \"0;-64\"\n\t\t\t\t\t\tdur=\"1500ms\"\n\t\t\t\t\t\trepeatCount=\"indefinite\" />\n\n\t\t\t\t</feOffset>\n\n\t\t\t\t<feDisplacementMap\n\t\t\t\t\tin=\"SourceGraphic\"\n\t\t\t\t\tin2=\"DisplacementOffset\"\n\t\t\t\t\tresult=\"Displaced\"\n\t\t\t\t\txChannelSelector=\"R\"\n\t\t\t\t\tyChannelSelector=\"G\"\n\t\t\t\t\tscale=\"4\"\n\t\t\t\t></feDisplacementMap>\n\n\t\t\t\t<feGaussianBlur\n\t\t\t\t\tin=\"Displaced\"\n\t\t\t\t\tstdDeviation=\"0.35\"\n\t\t\t\t></feGaussianBlur>\n\t\t\t</filter>\n\n\t\t\t<filter id = \"ntsc\"\n\t\t\t\tcolor-interpolation-filters=\"sRGB\"\n\t\t\t\tx      = \"0%\"\n\t\t\t\ty      = \"0%\"\n\t\t\t\twidth  = \"100%\"\n\t\t\t\theight = \"200%\"\n\t\t\t>\n\t\t\t\t<feFlood\n\t\t\t\t\tflood-color=\"#808000\"\n\t\t\t\t\tresult = \"DisplacementGreen\"\n\t\t\t\t></feFlood>\n\n\t\t\t\t<feImage\n\t\t\t\t\txlink:href=\"/effects/ntsc-static.png\"\n\t\t\t\t\tresult =\"DisplacementSource\"\n\t\t\t\t\twidth  = \"128\"\n\t\t\t\t\theight = \"128\"\n\t\t\t\t></feImage>\n\n\t\t\t\t<feTile\n\t\t\t\t\tin=\"DisplacementSource\"\n\t\t\t\t\tresult=\"DisplacementTile\"\n\t\t\t\t></feTile>\n\n\t\t\t\t<feComposite\n\t\t\t\t\tin  = \"DisplacementTile\"\n\t\t\t\t\tin2 = \"DisplacementGreen\"\n\t\t\t\t\tresult =\"DisplacementField\"\n\t\t\t\t\toperator =\"over\"\n\t\t\t\t></feComposite>\n\n\t\t\t\t<feOffset\n\t\t\t\t\tin  = \"DisplacementField\"\n\t\t\t\t\tout = \"DisplacementOffset\"\n\t\t\t\t\tdx  = \"0\"\n\t\t\t\t\tdy  = \"0\"\n\t\t\t\t>\n\t\t\t\t\t<animate\n\t\t\t\t\t\tattributeName=\"dy\"\n\t\t\t\t\t\tvalues = \"-128;0\"\n\t\t\t\t\t\tbegin=\"2000ms\"\n\t\t\t\t\t\tdur=\"2000ms\"\n\t\t\t\t\t\trepeatCount=\"8\"\n\t\t\t\t\t></animate>\n\n\t\t\t\t</feOffset>\n\n\t\t\t\t<feDisplacementMap\n\t\t\t\t\tin=\"SourceGraphic\"\n\t\t\t\t\tin2=\"DisplacementOffset\"\n\t\t\t\t\tresult=\"Displaced\"\n\t\t\t\t\txChannelSelector=\"R\"\n\t\t\t\t\tyChannelSelector=\"G\"\n\t\t\t\t\tscale = \"0\"\n\t\t\t\t>\n\t\t\t\t\t<animate\n\t\t\t\t\t\tattributeName=\"scale\"\n\t\t\t\t\t\tvalues = \"512;192;0\"\n\t\t\t\t\t\tbegin=\"2000ms\"\n\t\t\t\t\t\tdur=\"2000ms\"\n\t\t\t\t\t\trepeatCount=\"1\"\n\t\t\t\t\t></animate>\n\n\t\t\t\t</feDisplacementMap>\n\t\t\t</filter>\n\n\t\t</defs>\n\t\t</svg>\n\n\t\t<div class = \"viewport-zoom\">\n\n\t\t\t[[backdrop]]\n\n\t\t\t<div class = \"backdrops\" cv-ref =\"backdrops\"></div>\n\n\t\t\t<div class = \"blurAngle\" cv-ref = \"blurAngle\">\n\t\t\t<div class = \"blurDistance\" cv-ref = \"blurDistance\">\n\t\t\t<div class = \"blurAngleCancel\" cv-ref = \"blurAngleCancel\">\n\t\t\t\t<div\n\t\t\t\t\tcv-ref  = \"background\"\n\t\t\t\t\tclass   = \"viewport-bg-layers\"\n\t\t\t\t\tcv-each = \"layers:layer\"\n\t\t\t\t>[[layer]]</div>\n\t\t\t</div>\n\t\t\t</div>\n\t\t\t</div>\n\n\t\t\t<div class = \"filters filters-background\" cv-ref = \"bgFilters\"></div>\n\n\t\t\t<div cv-ref = \"content\" class = \"viewport-content\">\n\t\t\t\t<div cv-ref = \"actors\" class = \"viewport-actors\"></div>\n\t\t\t\t<div cv-ref = \"particles\" class = \"viewport-particles\"></div>\n \t\t\t</div>\n\n\t\t\t<div class = \"blurAngle\" cv-ref = \"blurAngleFg\">\n\t\t\t<div class = \"blurDistance\" cv-ref = \"blurDistanceFg\">\n \t\t\t<div class = \"blurAngleCancel\" cv-ref = \"blurAngleCancelFg\">\n\t\t\t\t<div\n\t\t\t\t\tcv-ref  = \"foreground\"\n\t\t\t\t\tclass   = \"viewport-bg-layers\"\n\t\t\t\t\tcv-each = \"fgLayers:layer\"\n\t\t\t\t>[[layer]]</div>\n\t\t\t</div>\n\t\t\t</div>\n\t\t\t</div>\n \t\t</div>\n\n \t\t[[plot]]\n\n \t\t<div class = \"viewport-overlay\">\n \t\t\t<div class = \"debug-spawn\" cv-if = \"debugEditMode\">\n \t\t\t\t<div class = \"debug-spawn\" cv-ref = \"spawnPreview\"></div>\n \t\t\t\t<div class = \"debug-spawn\">[[debugObjectName]]</div>\n \t\t\t</div>\n\n\t\t\t<div class = \"hud hud-top-right hud-table combo-table\">\n\t\t\t\t<span cv-if = \"showCombo\">\n\t\t\t\t\t<span>\n\t\t\t\t\t\t<span class = \"combo-list\" cv-each = \"combo:pop:p\">\n\t\t\t\t\t\t\t<div>[[pop.label]]</div>\n\t\t\t\t\t\t</span>\n\t\t\t\t\t\t<span class = \"comboTopLine\" cv-if = \"combo\">[[popBottomLine]]</span>\n\t\t\t\t\t</span>\n\t\t\t\t\t<span class = \"comboTopLine\" cv-if = \"combo\">[[popTopLine]]</span>\n\t\t\t\t</span>\n\t\t\t\t<span class = \"comboFail\">[[comboFail]]</span>\n\t\t\t\t<span class = \"comboResult\">[[comboResult]]</span>\n\t\t\t</div>\n\n\t\t\t<div class = \"hud hud-top-right hud-table quick-form\">[[quickForm]]</div>\n\n\t\t\t<div class = \"hud hud-top-right hud-table\"  cv-if = \"debugOsd\">\n\t\t\t\t<table>\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<td colspan = \"2\">[[char]]</td>\n\t\t\t\t\t</tr>\n\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<td>[[labelGround]]</td>\n\t\t\t\t\t\t<td>[[ground]]</td>\n\t\t\t\t\t</tr>\n\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<td>[[labelCamera]]</td>\n\t\t\t\t\t\t<td>[[cameraMode]]</td>\n\t\t\t\t\t</tr>\n\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<td>[[labelMode]]</td>\n\t\t\t\t\t\t<td>[[mode]]</td>\n\t\t\t\t\t</tr>\n\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<td>[[labelX]]</td>\n\t\t\t\t\t\t<td>[[xPos]]</td>\n\t\t\t\t\t</tr>\n\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<td>[[labelY]]</td>\n\t\t\t\t\t\t<td>[[yPos]]</td>\n\t\t\t\t\t</tr>\n\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<td>[[labelLayer]]</td>\n\t\t\t\t\t\t<td>[[layer]]</td>\n\t\t\t\t\t</tr>\n\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<td>[[labelGSpeed]]</td>\n\t\t\t\t\t\t<td>[[gSpeed]]</td>\n\t\t\t\t\t</tr>\n\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<td>[[labelXSpeed]]</td>\n\t\t\t\t\t\t<td>[[xSpeed]]</td>\n\t\t\t\t\t</tr>\n\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<td>[[labelYSpeed]]</td>\n\t\t\t\t\t\t<td>[[ySpeed]]</td>\n\t\t\t\t\t</tr>\n\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<td>[[labelAirAngle]]</td>\n\t\t\t\t\t\t<td>[[airAngle]]</td>\n\t\t\t\t\t</tr>\n\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<td>[[labelAngle]]</td>\n\t\t\t\t\t\t<td>[[angle]]</td>\n\t\t\t\t\t</tr>\n\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<td>[[labelActors]]</td>\n\t\t\t\t\t\t<td>[[actorCount]]</td>\n\t\t\t\t\t</tr>\n\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<td>[[labelRegions]]</td>\n\t\t\t\t\t\t<td>[[regionCount]]</td>\n\t\t\t\t\t</tr>\n\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<td>[[labelFrame]]</td>\n\t\t\t\t\t\t<td>[[frame]]</td>\n\t\t\t\t\t</tr>\n\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<td>[[labelIgnore]]</td>\n\t\t\t\t\t\t<td>[[ignore]]</td>\n\t\t\t\t\t</tr>\n\n\t\t\t\t</table>\n\t\t\t</div>\n\n\t\t\t<div class = \"hud hud-top-right\" cv-if = \"showHud\">\n\n\t\t\t\t<div class = \"char-hud\">\n\t\t\t\t\t[[char]]\n\t\t\t\t\t<div class = \"char-icon [[charName|hyphenate]]\"></div>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<div class = \"emblem-hud\" cv-each = \"emblems:emblem:e\">\n\t\t\t\t\t\t<img loading=\"lazy\" src = \"/custom/hud-emblem.png\" class = \"[[emblem.existing]]\" />\n\t\t\t\t\t</div>\n\t\t\t\t\t<div class = \"collectible-hud\" cv-each = \"inventory:item\">\n\t\t\t\t\t\t<span cv-if = \"item.icon\">\n\t\t\t\t\t\t\t<img loading=\"lazy\" src = \"[[item.icon]]\" class = \"inventory-icon\" />\n\t\t\t\t\t\t</span>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t\t<div class = \"emerald-hud\" cv-each = \"emeralds:emerald:e\">\n\t\t\t\t\t<img loading=\"lazy\" src = \"/Sonic/emerald-[[emerald]]-mini.png\" />\n\t\t\t\t</div>\n\t\t\t</div>\n\n\t\t\t<div class = \"hud hud-bottom-right\">\n\n\t\t\t\t<div cv-if = \"showHud\" class =\"sheild-hud [[currentSheild]] [[hasElectric]] [[hasFire]] [[hasWater]] [[hasNormal]]\">\n\t\t\t\t\t<div class = \"sheild-icon sheild-electric\"></div>\n\t\t\t\t\t<div class = \"sheild-icon sheild-normal\"></div>\n\t\t\t\t\t<div class = \"sheild-icon sheild-fire\"></div>\n\t\t\t\t\t<div class = \"sheild-icon sheild-water\"></div>\n\t\t\t\t</div>\n\n\t\t\t\t<span class = \"contents\" cv-if = \"showFps\">\n\t\t\t\t\t<table>\n\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t<td>[[labelFps]]</td>\n\t\t\t\t\t\t\t<td>[[fpsSprite]]</td>\n\t\t\t\t\t\t</tr>\n\t\t\t\t\t</table>\n\t\t\t\t</span>\n\t\t\t</div>\n\n\t\t\t<div class = \"hud hud-dark hud-bottom-left\" cv-if = \"showHud\" data-extra = \"[[audioComment]]\" cv-on = \"click:nowPlayingClicked\">\n\t\t\t\t[[nowPlaying]]\n\t\t\t\t[[trackName]]\n\t\t\t</div>\n\n\t\t\t<div class = \"hud hud-top-left hud-table\"  cv-if = \"showHud\">\n\t\t\t\t<table>\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<td>[[scoreLabel]]</td><td>[[score]]</td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<td>[[timerLabel]]</td><td>[[timer]]</td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<td>[[ringLabel]]</td><td>[[rings]]</td>\n\t\t\t\t\t</tr>\n\t\t\t\t</table>\n\t\t\t\t<!-- <div class = \"demo-hud\" cv-if = \"demoIndicator\">[[demoIndicator]]</div> -->\n\t\t\t</div>\n\n\t\t\t<div class = \"hud hud-dark hud-centered\" cv-if = \"actClear\">\n\t\t\t\t<div class = \"centered act-cleared\">[[actClearLabel]]</div>\n\t\t\t\t[[tallyBoard]]\n\t\t\t</div>\n\n\t\t\t<div class = \"hud hud-dark hud-centered\" cv-if = \"centerMessage\">\n\t\t\t\t[[centerMessage]]\n\t\t\t</div>\n\n\t\t\t<div class = \"hud hud-dark hud-centered-raised\" cv-if = \"dialog\">\n\t\t\t\t<div class = \"dialog-frame [[dialogClasses]]\">\n\t\t\t\t\t<div class = \"dialog-icon\">\n\t\t\t\t\t</div>\n\t\t\t\t\t<div cv-each = \"dialogLines:line\" class = \"dialog-text\">\n\t\t\t\t\t\t<span style = \"--text-offset:[[line.offset]]\">[[line]]</span>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t</div>\n\n\t\t\t<div class = \"screen-effects\" cv-each = \"screenEffects:effect\">\n\t\t\t\t[[effect]]\n\t\t\t</div>\n\n\t\t\t<section class = \"pause-menu full\" cv-if = \"paused\">[[pauseMenu]]</section>\n\n\t\t\t[[titlecard]]\n\n\t\t\t<div class = \"topLine\">\n\t\t\t\t<div class = \"status-message\">[[topLine]]</div>\n\t\t\t</div>\n\n\t\t\t<div class = \"focus-me\">\n\t\t\t\t<div class = \"status-message\">[[focusMe]]</div>\n\t\t\t</div>\n\n\t\t\t<div class = \"status-message\">[[status]]</div>\n\t\t\t<section class = \"contents\" cv-if = \"networked\">[[chatBox]]</section>\n\t\t\t<!-- <div class = \"filters filters-foreground\" cv-ref = \"fgFilters\"></div> -->\n\t\t\t<div class = \"console [[showConsole]]\" cv-ref = \"subspace\" tab-index = \"0\">[[subspace]]</div>\n\t\t\t<div class = \"shade\" data-fade = \"[[fade]]\"></div>\n\n\t\t</div>\n\n\t\t<div class = \"quick-controls\" cv-if = \"shortcuts\">\n\t\t\t[[muteSwitch]]\n\t\t\t<div class = \"button\" cv-on = \"click:fullscreen()\">\n\t\t\t\t<image src = \"/ui/fullscreen.svg\" />\n\t\t\t</div>\n\t\t</div>\n\n\t</div>\n</div>\n"
});

;require.register("zoneScripts/ChaoGarden.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ChaoGarden = void 0;
var _Spring = require("../actor/Spring");
var _OrbSmall = require("../actor/OrbSmall");
var _WoodenCrate = require("../actor/WoodenCrate");
var _SkidDust = require("../behavior/SkidDust");
var _Chao = require("../actor/Chao");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let ChaoGarden = /*#__PURE__*/function () {
  function ChaoGarden() {
    _classCallCheck(this, ChaoGarden);
  }
  _createClass(ChaoGarden, [{
    key: "update",
    value: function update(frameId, viewport) {
      if (frameId === 0) {
        const zoneState = viewport.getZoneState();
        if (zoneState.chao) for (const chaoData of zoneState.chao) {
          const chao = new _Chao.Chao();
          chao.load(chaoData);
          viewport.spawn.add({
            object: chao
          });
        }
      }

      // if(!viewport.controlActor)
      // {
      // 	return;
      // }

      // if(!frameId)
      // {
      // }
    }
  }]);
  return ChaoGarden;
}();
exports.ChaoGarden = ChaoGarden;
});

;require.register("zoneScripts/InfiniteRuin.js", function(exports, require, module) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.InfiniteRuin = void 0;
var _Spring = require("../actor/Spring");
var _OrbSmall = require("../actor/OrbSmall");
var _WoodenCrate = require("../actor/WoodenCrate");
var _SkidDust = require("../behavior/SkidDust");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
let InfiniteRuin = /*#__PURE__*/function () {
  function InfiniteRuin() {
    _classCallCheck(this, InfiniteRuin);
  }
  _createClass(InfiniteRuin, [{
    key: "update",
    value: function update(frameId, viewport) {
      if (!viewport.controlActor) {
        return;
      }

      // if(frameId > 120)
      // {
      // 	viewport.arg.fake = 'fail';
      // }

      if (viewport.controlActor.args.dead || viewport.controlActor.args.startled) {
        return;
      }
      if (frameId < 30 && viewport.controlActor) {
        viewport.controlActor.args.gSpeed = 15;
      }
      let freq = 120;
      if (frameId < 600) {
        freq = 150;
      }
      if (frameId > 1200) {
        freq = 100;
      }
      if (frameId > 1800) {
        freq = 90;
      }
      if (frameId > 120 && frameId % freq === 0 && viewport.controlActor) {
        let rand = Math.random();
        if (frameId < 900) {
          rand = 0;
        }
        if (frameId < 900) {
          rand *= 0.79;
        }
        if (viewport.objectDb.has(_WoodenCrate.WoodenCrate)) {
          if (viewport.objectDb.get(_WoodenCrate.WoodenCrate).size) {
            rand = 0;
          }
        }
        if (rand > 0.5) {
          this.spawnBox(viewport);
        } else {
          this.spawnOrb(viewport);
        }
      }
    }
  }, {
    key: "spawnOrb",
    value: function spawnOrb(viewport) {
      let thing;
      thing = new _OrbSmall.OrbSmall();
      let type = Math.trunc(Math.random() * 8);
      thing.args.xSpeed = viewport.controlActor.args.gSpeed || viewport.controlActor.args.xSpeed;
      thing.args.gSpeed = viewport.controlActor.args.gSpeed || viewport.controlActor.args.xSpeed;
      switch (type) {
        case 0:
          thing.args.x = viewport.controlActor.args.x + 320;
          thing.args.y = 928 - 320;
          thing.args.friction = 0.75;
          thing.args.bounce = 0.75;
          break;
        case 1:
          thing.args.x = viewport.controlActor.args.x + 320;
          thing.args.y = 928 - 320;
          thing.args.friction = 0.70;
          thing.args.bounce = 0.75;
          break;
        case 2:
          thing.args.x = viewport.controlActor.args.x + 400;
          thing.args.y = 928 - 0;
          thing.args.decel = 0.05;
          thing.args.bounce = 0.0;
          thing.args.gSpeed = 18;
          thing.args.xSpeed = 18;
          break;
        case 3:
          thing.args.x = viewport.controlActor.args.x + 400;
          thing.args.y = 928 - 0;
          thing.args.decel = 0.2;
          thing.args.bounce = 0.0;
          thing.args.gSpeed = 18;
          thing.args.xSpeed = 18;
          break;
        case 4:
          thing.args.x = viewport.controlActor.args.x + 400;
          thing.args.y = 928 - 48;
          thing.args.friction = 0.90;
          thing.args.decel = 0.15;
          thing.args.bounce = 0.999;
          break;
        case 5:
          thing.args.x = viewport.controlActor.args.x + 400;
          thing.args.y = 928 - 24;
          thing.args.friction = 0.80;
          thing.args.decel = 0.15;
          thing.args.bounce = 0.999;
          break;
        case 6:
          thing.args.x = viewport.controlActor.args.x + 320;
          thing.args.y = 928 - 320;
          thing.args.friction = 0.75;
          thing.args.bounce = 0.70;
          break;
        case 7:
          thing.args.x = viewport.controlActor.args.x + 320;
          thing.args.y = 928 - 320;
          thing.args.friction = 0.70;
          thing.args.bounce = 0.80;
          break;
      }
      thing.args.canHide = true;
      viewport.spawn.add({
        object: thing
      });
    }
  }, {
    key: "spawnBox",
    value: function spawnBox(viewport) {
      let thing;
      thing = new _WoodenCrate.WoodenCrate();
      let type = Math.trunc(Math.random() * 8);
      thing.args.x = viewport.controlActor.args.x + 320;
      thing.args.y = 928 - 320;
      thing.args.friction = 0.76;
      thing.args.bounce = 0.65;
      thing.args.contains = 'ring-monitor';
      thing.alwaysSkidding = true;
      thing.dustFreq = 5;
      thing.behaviors.add(new _SkidDust.SkidDust());
      thing.args.xSpeed = viewport.controlActor.args.gSpeed || viewport.controlActor.args.xSpeed;
      thing.args.gSpeed = viewport.controlActor.args.gSpeed || viewport.controlActor.args.xSpeed;
      viewport.spawn.add({
        object: thing
      });
    }
  }, {
    key: "spawnSpring",
    value: function spawnSpring(viewport) {
      let thing;
      thing = new _Spring.Spring();
      let type = Math.trunc(Math.random() * 8);
      thing.args.x = viewport.controlActor.args.x + 320;
      thing.args.y = 928 - 320;
      thing.args.decel = 0.03;
      thing.args.power = 10;
      thing.args.width = 32;
      thing.args.height = 16;
      thing.args.angle = -Math.PI / 2;
      thing.args.groundAngle = 0;
      thing.args.static = false;
      thing.args.canHide = true;
      thing.alwaysSkidding = true;
      thing.float = 0;
      thing.dustFreq = 5;
      thing.behaviors.add(new _SkidDust.SkidDust());
      thing.args.xSpeed = viewport.controlActor.args.gSpeed || viewport.controlActor.args.xSpeed;
      thing.args.gSpeed = viewport.controlActor.args.gSpeed || viewport.controlActor.args.xSpeed;
      viewport.spawn.add({
        object: thing
      });
      const originalSleep = thing.sleep;
      thing.sleep = () => viewport.actors.remove(thing);
    }
  }]);
  return InfiniteRuin;
}();
exports.InfiniteRuin = InfiniteRuin;
});

;require.register("___globals___", function(exports, require, module) {
  
});})();require('___globals___');

"use strict";

/* jshint ignore:start */
(function () {
  var WebSocket = window.WebSocket || window.MozWebSocket;
  var br = window.brunch = window.brunch || {};
  var ar = br['auto-reload'] = br['auto-reload'] || {};
  if (!WebSocket || ar.disabled) return;
  if (window._ar) return;
  window._ar = true;
  var cacheBuster = function cacheBuster(url) {
    var date = Math.round(Date.now() / 1000).toString();
    url = url.replace(/(\&|\\?)cacheBuster=\d*/, '');
    return url + (url.indexOf('?') >= 0 ? '&' : '?') + 'cacheBuster=' + date;
  };
  var browser = navigator.userAgent.toLowerCase();
  var forceRepaint = ar.forceRepaint || browser.indexOf('chrome') > -1;
  var reloaders = {
    page: function page() {
      window.location.reload(true);
    },
    stylesheet: function stylesheet() {
      [].slice.call(document.querySelectorAll('link[rel=stylesheet]')).filter(function (link) {
        var val = link.getAttribute('data-autoreload');
        return link.href && val != 'false';
      }).forEach(function (link) {
        link.href = cacheBuster(link.href);
      });

      // Hack to force page repaint after 25ms.
      if (forceRepaint) setTimeout(function () {
        document.body.offsetHeight;
      }, 25);
    },
    javascript: function javascript() {
      var scripts = [].slice.call(document.querySelectorAll('script'));
      var textScripts = scripts.map(function (script) {
        return script.text;
      }).filter(function (text) {
        return text.length > 0;
      });
      var srcScripts = scripts.filter(function (script) {
        return script.src;
      });
      var loaded = 0;
      var all = srcScripts.length;
      var onLoad = function onLoad() {
        loaded = loaded + 1;
        if (loaded === all) {
          textScripts.forEach(function (script) {
            eval(script);
          });
        }
      };
      srcScripts.forEach(function (script) {
        var src = script.src;
        script.remove();
        var newScript = document.createElement('script');
        newScript.src = cacheBuster(src);
        newScript.async = true;
        newScript.onload = onLoad;
        document.head.appendChild(newScript);
      });
    }
  };
  var port = ar.port || 9485;
  var host = br.server || window.location.hostname || 'localhost';
  var connect = function connect() {
    var connection = new WebSocket('ws://' + host + ':' + port);
    connection.onmessage = function (event) {
      if (ar.disabled) return;
      var message = event.data;
      var reloader = reloaders[message] || reloaders.page;
      reloader();
    };
    connection.onerror = function () {
      if (connection.readyState) connection.close();
    };
    connection.onclose = function () {
      window.setTimeout(connect, 1000);
    };
  };
  connect();
})();
/* jshint ignore:end */
;
//# sourceMappingURL=app.js.map